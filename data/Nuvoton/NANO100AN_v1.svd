<?xml version="1.0" encoding="utf-8"?>
<device schemaVersion="1.1" xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" xs:noNamespaceSchemaLocation="CMSIS-SVD_Schema_1_1.xsd" >
  <name>NANO100AN_v1</name>
  <version>1.0</version>
  <description>NANO100AN_v1 SVD file</description>
  <!-- Bus Interface Properties -->
  <!-- Cortex-M0 is byte addressable -->
  <addressUnitBits>8</addressUnitBits>
  <!-- the maximum data bit width accessible within a single transfer is 32bits -->
  <width>32</width>

  <!-- Register Default Properties -->
  <!-- the size of the registers is set to a bit width of 32. This can be overruled for individual peripherals and/or registers -->
  <size>32</size>
  <!-- the access to all registers is set to be readable and writeable. This can be overruled for individual peripherals and/or registers -->
  <access>read-write</access>
  <!-- for demonstration purposes the resetValue for all registers of the device is set to be 0. This can be overruled within the description -->
  <resetValue>0</resetValue>
  <!-- the resetMask = 0 specifies that by default no register of this device has a defined reset value -->
  <resetMask>0</resetMask>

  <peripherals>
    <peripheral>
      <name>SCS</name>
      <description>SCS Register Map</description>
      <groupName>SCS</groupName>
      <baseAddress>0xE000E000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x10</offset>
        <size>0xC</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x100</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x180</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x200</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x280</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x400</offset>
        <size>0x20</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0xD00</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0xD0C</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0xD1C</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>SYST_CTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYST_CTL</displayName>
          <description>SysTick Control and Status</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000004</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ENABLE</name>
              <description></description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The counter is Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The counter will operate in a multi-shot manner</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TICKINT</name>
              <description></description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Counting down to 0 does not cause the SysTick exception to be pended. Software can use COUNTFLAG to determine if a count to zero has occurred</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Counting down to 0 will cause the SysTick exception to be pended. Clearing the SysTick Current Value register by a register write in software will not cause SysTick to be pended</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLKSRC</name>
              <description></description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock Source is (optional) external reference clock</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Core clock used for SysTick If no external clock provided, this bit will read as 1 and ignore writes</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>COUNTFLAG</name>
              <description>Returns 1 If Timer Counted To 0 Since Last Time This Register Was Read\n COUNTFLAG is set by a count transition from 1 to 0.\n COUNTFLAG is cleared on read or by a write to the Current Value register.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYST_RVR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYST_RVR</displayName>
          <description>SysTick Reload Value Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>RELOAD</name>
              <description>The value to load into the Current Value register when the counter reaches 0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYST_CVR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYST_CVR</displayName>
          <description>SysTick Current Value</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>CURRENT</name>
              <description>Current Counter Value \nThis is the value of the counter at the time it is sampled. The counter does not provide read-modify-write protection. The register is write-clear. A software write of any value will clear the register to 0. Unsupported bits RAZ (Read As Zero, writes ignore) (See SysTick Reload Value register).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_ISER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_ISER</displayName>
          <description>IRQ0~IRQ31 Set-enable Control Register</description>
          <addressOffset>0x100</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SETENA</name>
              <description>Enable one or more interrupts within a group of 32. Each Bit Represents An Interrupt Number From IRQ0 ~ IRQ31 (Vector Number From 16 ~ 47) \nWriting 1 will enable the associated interrupt.\nWriting 0 has no effect.\nThe register reads back with the current enable state.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_ICER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_ICER</displayName>
          <description>IRQ0~IRQ31 Clear-enable Control Register</description>
          <addressOffset>0x180</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLRENA</name>
              <description>Disable one or more interrupts within a group of 32. Each Bit Represents An Interrupt Number From IRQ0 ~ IRQ31 (Vector Number From 16 ~ 47) \nWriting 1 will disable the associated interrupt.\nWriting 0 has no effect.\nThe register reads back with the current enable state.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_ISPR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_ISPR</displayName>
          <description>IRQ0~IRQ31 Set-pending Control Register</description>
          <addressOffset>0x200</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SETPEND</name>
              <description>Writing 1 To A Bit To Set Pending State Of The Associated Interrupt Under Software Control Each bit represents an interrupt number from IRQ0 ~ IRQ31 (Vector number from 16 ~ 47).\nWriting 0 has no effect.\nThe register reads back with the current pending state.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_ICPR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_ICPR</displayName>
          <description>IRQ0~IRQ31 Clear-pending Control Register</description>
          <addressOffset>0x280</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLRPEND</name>
              <description>Writing 1 To A Bit To Remove The Pending State Of Associated Interrupt Under Software Control Each bit represents an interrupt number from IRQ0 ~ IRQ31 (Vector number from 16 ~ 47).\nWriting 0 has no effect.\nThe register reads back with the current pending state.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_IPR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_IPR0</displayName>
          <description>IRQ0~IRQ3 Priority Control Register</description>
          <addressOffset>0x400</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_0</name>
              <description>Priority Of IRQ0\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_1</name>
              <description>Priority Of IRQ1\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_2</name>
              <description>Priority Of IRQ2\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_3</name>
              <description>Priority Of IRQ3\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_IPR1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_IPR1</displayName>
          <description>IRQ4~IRQ7 Priority Control Register</description>
          <addressOffset>0x404</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_4</name>
              <description>Priority Of IRQ4\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_5</name>
              <description>Priority Of IRQ5\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_6</name>
              <description>Priority Of IRQ6\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_7</name>
              <description>Priority Of IRQ7\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_IPR2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_IPR2</displayName>
          <description>IRQ8~IRQ11 Priority Control Register</description>
          <addressOffset>0x408</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_8</name>
              <description>Priority Of IRQ8\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_9</name>
              <description>Priority Of IRQ9\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_10</name>
              <description>Priority Of IRQ10\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_11</name>
              <description>Priority Of IRQ11\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_IPR3</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_IPR3</displayName>
          <description>IRQ12~IRQ15 Priority Control Register</description>
          <addressOffset>0x40C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_12</name>
              <description>Priority Of IRQ12\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_13</name>
              <description>Priority Of IRQ13\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_14</name>
              <description>Priority Of IRQ14\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_15</name>
              <description>Priority Of IRQ15\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_IPR4</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_IPR4</displayName>
          <description>IRQ16~IRQ19 Priority Control Register</description>
          <addressOffset>0x410</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_16</name>
              <description>Priority Of IRQ16\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_17</name>
              <description>Priority Of IRQ17\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_18</name>
              <description>Priority Of IRQ18\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_19</name>
              <description>Priority Of IRQ19\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_IPR5</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_IPR5</displayName>
          <description>IRQ20~IRQ23 Priority Control Register</description>
          <addressOffset>0x414</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_20</name>
              <description>Priority Of IRQ20\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_21</name>
              <description>Priority Of IRQ21\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_22</name>
              <description>Priority Of IRQ22\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_23</name>
              <description>Priority Of IRQ23\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_IPR6</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_IPR6</displayName>
          <description>IRQ24~IRQ27 Priority Control Register</description>
          <addressOffset>0x418</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_24</name>
              <description>Priority Of IRQ24\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_25</name>
              <description>Priority Of IRQ25\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_26</name>
              <description>Priority Of IRQ26\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_27</name>
              <description>Priority Of IRQ27\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_IPR7</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_IPR7</displayName>
          <description>IRQ28~IRQ31 Priority Control Register</description>
          <addressOffset>0x41C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_28</name>
              <description>Priority Of IRQ28\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_29</name>
              <description>Priority Of IRQ29\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_30</name>
              <description>Priority Of IRQ30\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_31</name>
              <description>Priority Of IRQ31\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CPUID</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CPUID</displayName>
          <description>CPUID Base Register</description>
          <addressOffset>0xD00</addressOffset>
          <access>read-only</access>
          <resetValue>0x410CC200</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REVISION</name>
              <description>Reads as 0x0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PARTNO</name>
              <description>Reads as 0xC20.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PART</name>
              <description>Reads as 0xC for ARMv6-M parts</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>IMPLEMENTER</name>
              <description></description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ICSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ICSR</displayName>
          <description>Interrupt Control State Register</description>
          <addressOffset>0xD04</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VECTACTIVE</name>
              <description>If value of VECTACTIVE   1: the exception number for the current executing exception.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Thread mode</description>
                    <value>0</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>VECTPENDING</name>
              <description>Indicates The Exception Number For The Highest Priority Pending Exception\nThe pending state includes the effect of memory-mapped enable and mask registers. It does not include the PRIMASK special-purpose register qualifier. A value of zero indicates no pending exceptions.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRPENDING</name>
              <description>Indicates if an external configurable (NVIC generated) interrupt is pending.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRPREEMPT</name>
              <description>If set, a pending exception will be serviced on exit from the debug halt state.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PENDSTCLR</name>
              <description>Write 1 to clear a pending SysTick.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PENDSTSET</name>
              <description>Set A Pending SysTick Reads back with current state (1 if Pending, 0 if not).</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PENDSVCLR</name>
              <description>Write 1 to clear a pending PendSV interrupt.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PENDSVSET</name>
              <description>Set A Pending PendSV Interrupt\nThis is normally used to request a context switch. Reads back with current state (1 if Pending, 0 if not).</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NMIPENDSET</name>
              <description>Setting This Bit Will Activate An NMI\nSince NMI is the highest priority exception, it will activate as soon as it is registered. Reads back with current state (1 if Pending, 0 if not).</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>AIRCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>AIRCR</displayName>
          <description>Application Interrupt and Reset Control Register</description>
          <addressOffset>0xD0C</addressOffset>
          <access>read-write</access>
          <resetValue>0xFA050000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VECTCLRACTIVE</name>
              <description>Set This Bit To 1 Will Clears All Active State Information For Fixed And Configurable Exceptions\nThe bit is a write only bit and can only be written when the core is halted.\nNote: It is the debugger's responsibility to re-initialize the stack.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SYSRESETREQ</name>
              <description>Writing This Bit 1 Will Cause A Reset Signal To Be Asserted To The Chip To Indicate A Reset Is Requested\nThe bit is a write only bit and self-clears as part of the reset sequence.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VECTORKEY</name>
              <description>When write this register, this field should be 0x05FA, otherwise the write action will be unpredictable.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SCR</displayName>
          <description>System Control Register</description>
          <addressOffset>0xD10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SLEEPONEXIT</name>
              <description>When Set To 1, The Core Can Enter A Sleep State On An Exception Return To Thread Mode This is the mode and exception level entered at reset, the base level of execution.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SLEEPDEEP</name>
              <description>A qualifying hint that indicates waking from sleep might take longer.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEVONPEND</name>
              <description>When enabled, interrupt transitions from Inactive to Pending are included in the list of wake-up events for the WFE instruction.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SHPR2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SHPR2</displayName>
          <description>System Handler Priority Register 2</description>
          <addressOffset>0xD1C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_11</name>
              <description>Priority Of System Handler 11 - SVCall\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SHPR3</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SHPR3</displayName>
          <description>System Handler Priority Register 3</description>
          <addressOffset>0xD20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_14</name>
              <description>Priority Of System Handler 14 - PendSV\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_15</name>
              <description>Priority Of System Handler 15 - SysTick\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>INT</name>
      <description>SCS Register Map</description>
      <groupName>SCS</groupName>
      <baseAddress>0x50000300</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x88</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>IRQ0_SRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IRQ0_SRC</displayName>
          <description>MCU IRQ0 (BOD_INT) Interrupt Source Identify</description>
          <addressOffset>0x0</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>INT_SRC</name>
              <description>Interrupt Source\nDefine the interrupt sources for interrupt event.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ1_SRC</name>
          <displayName>IRQ1_SRC</displayName>
          <description>MCU IRQ1 (WDT_INT) Interrupt Source Identify</description>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ2_SRC</name>
          <displayName>IRQ2_SRC</displayName>
          <description>MCU IRQ2 (EINT0) Interrupt Source Identify</description>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ3_SRC</name>
          <displayName>IRQ3_SRC</displayName>
          <description>MCU IRQ3 (EINT1) Interrupt Source Identify</description>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ4_SRC</name>
          <displayName>IRQ4_SRC</displayName>
          <description>MCU IRQ4 (GPABC_INT) Interrupt Source Identify</description>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ5_SRC</name>
          <displayName>IRQ5_SRC</displayName>
          <description>MCU IRQ5 (GPDEF_INT) Interrupt Source Identify</description>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ6_SRC</name>
          <displayName>IRQ6_SRC</displayName>
          <description>MCU IRQ6 (PWM0_INT) Interrupt Source Identify</description>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ7_SRC</name>
          <displayName>IRQ7_SRC</displayName>
          <description>MCU IRQ7 (PWM1_INT) Interrupt Source Identify</description>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ8_SRC</name>
          <displayName>IRQ8_SRC</displayName>
          <description>MCU IRQ8 (TMR0_INT) Interrupt Source Identify</description>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ9_SRC</name>
          <displayName>IRQ9_SRC</displayName>
          <description>MCU IRQ9 (TMR1_INT) Interrupt Source Identify</description>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ10_SRC</name>
          <displayName>IRQ10_SRC</displayName>
          <description>MCU IRQ10 (TMR2_INT) Interrupt Source Identify</description>
          <addressOffset>0x28</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ11_SRC</name>
          <displayName>IRQ11_SRC</displayName>
          <description>MCU IRQ11 (TMR3_INT) Interrupt Source Identify</description>
          <addressOffset>0x2C</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ12_SRC</name>
          <displayName>IRQ12_SRC</displayName>
          <description>MCU IRQ12 (UART0_INT) Interrupt Source Identify</description>
          <addressOffset>0x30</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ13_SRC</name>
          <displayName>IRQ13_SRC</displayName>
          <description>MCU IRQ13 (UART1_INT) Interrupt Source Identify</description>
          <addressOffset>0x34</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ14_SRC</name>
          <displayName>IRQ14_SRC</displayName>
          <description>MCU IRQ14 (SPI0_INT) Interrupt Source Identify</description>
          <addressOffset>0x38</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ15_SRC</name>
          <displayName>IRQ15_SRC</displayName>
          <description>MCU IRQ15 (SPI1_INT) Interrupt Source Identify</description>
          <addressOffset>0x3C</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ16_SRC</name>
          <displayName>IRQ16_SRC</displayName>
          <description>MCU IRQ16 (SPI2_INT) Interrupt Source Identify</description>
          <addressOffset>0x40</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ17_SRC</name>
          <displayName>IRQ17_SRC</displayName>
          <description>MCU IRQ17 (IRC_INT) Interrupt Source Identify</description>
          <addressOffset>0x44</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ18_SRC</name>
          <displayName>IRQ18_SRC</displayName>
          <description>MCU IRQ18 (I2C0_INT) Interrupt Source Identify</description>
          <addressOffset>0x48</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ19_SRC</name>
          <displayName>IRQ19_SRC</displayName>
          <description>MCU IRQ19 (I2C1_INT) Interrupt Source Identify</description>
          <addressOffset>0x4C</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ20_SRC</name>
          <displayName>IRQ20_SRC</displayName>
          <description>MCU IRQ20 (Reserved) Interrupt Source Identify</description>
          <addressOffset>0x50</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ21_SRC</name>
          <displayName>IRQ21_SRC</displayName>
          <description>MCU IRQ21 (SC0_INT) Interrupt Source Identify</description>
          <addressOffset>0x54</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ22_SRC</name>
          <displayName>IRQ22_SRC</displayName>
          <description>MCU IRQ22 (SC1_INT) Interrupt Source Identify</description>
          <addressOffset>0x58</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ23_SRC</name>
          <displayName>IRQ23_SRC</displayName>
          <description>MCU IRQ23 (USB_INT) Interrupt Source Identify</description>
          <addressOffset>0x5C</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ24_SRC</name>
          <displayName>IRQ24_SRC</displayName>
          <description>Reserved</description>
          <addressOffset>0x60</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ25_SRC</name>
          <displayName>IRQ25_SRC</displayName>
          <description>Reserved</description>
          <addressOffset>0x64</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ26_SRC</name>
          <displayName>IRQ26_SRC</displayName>
          <description>MCU IRQ26 (DMA_INT) Interrupt Source Identify</description>
          <addressOffset>0x68</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ27_SRC</name>
          <displayName>IRQ27_SRC</displayName>
          <description>MCU IRQ27 (I2S_INT) Interrupt Source Identify</description>
          <addressOffset>0x6C</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ28_SRC</name>
          <displayName>IRQ28_SRC</displayName>
          <description>MCU IRQ28 (PDWU_INT) Interrupt Source Identify</description>
          <addressOffset>0x70</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ29_SRC</name>
          <displayName>IRQ29_SRC</displayName>
          <description>MCU IRQ29 (ADC_INT) Interrupt Source Identify</description>
          <addressOffset>0x74</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ30_SRC</name>
          <displayName>IRQ30_SRC</displayName>
          <description>Reserved</description>
          <addressOffset>0x78</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ31_SRC</name>
          <displayName>IRQ31_SRC</displayName>
          <description>MCU IRQ31 (RTC_INT) Interrupt Source Identify</description>
          <addressOffset>0x7C</addressOffset>
       </register>
       <register>
          <name>NMI_SEL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NMI_SEL</displayName>
          <description>NMI Source Interrupt Select Control Register</description>
          <addressOffset>0x80</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NMI_SEL</name>
              <description>The NMI Interrupt To Cortex-M0 Can Be Selected From One Of The Interrupt[31:0]\nThe NMI_SEL bit[4:0] used to select the NMI interrupt source</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>MCU_IRQ</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>MCU_IRQ</displayName>
          <description>MCU Interrupt Request Source Register</description>
          <addressOffset>0x84</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MCU_IRQ</name>
              <description>MCU IRQ Source Register \nThe MCU_IRQ collects all the interrupts from the peripherals and generates the synchronous interrupt to MCU Cortex-M0. There are two modes to generate interrupt to Cortex-M0, the normal mode.\nWhen the MCU_IRQ[n] is "0", set MCU_IRQ[n] "1" will generate an interrupt to Cortex_M0 NVIC[n].\nWhen the MCU_IRQ[n] is "1" (mean an interrupt is assert), set the MCU_bit[n] will clear the interrupt\nSet MCU_IRQ[n] "0" : no any effect</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>GCR</name>
      <description>GCR Register Map</description>
      <groupName>GCR</groupName>
      <baseAddress>0x50000000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x14</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x20</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x30</offset>
        <size>0x2C</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x60</offset>
        <size>0x10</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x80</offset>
        <size>0xC</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x100</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>PDID</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDID</displayName>
          <description>Part Device Identification Number Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-only</access>
          <resetValue>0x00140018</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDID</name>
              <description>Part Device ID \nThis register reflects device part number code. Software can read this register to identify which device is used.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>RST_SRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>RST_SRC</displayName>
          <description>System Reset Source Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFF00</resetMask>
          <fields>
            <field>
              <name>RSTS_POR</name>
              <description>The RSTS_POR Flag Is Set By The "Reset Signal" From The Power-On Reset (POR) Module Or Bit CHIP_RST (IPRST_CTL1[0]) To Indicate The Previous Reset Source\nThis bit is cleared by writing 1 to itself.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No reset from POR or CHIP_RST</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The Power-On Reset (POR) or CHIP_RST had issued the reset signal to reset the system</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RSTS_PAD</name>
              <description>The RSTS_PAD Flag Is Set By The "Reset Signal" From The /RESET Pin To Indicate The Previous Reset Source\nThis bit is cleared by writing 1 to itself.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No reset from  /RESET pin</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The /RESET pin had issued the reset signal to reset the system</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RSTS_WDT</name>
              <description>The RSTS_WDT Flag Is Set By The "Reset Signal" From The Watch-Dog Timer Module To Indicate The Previous Reset Source\nThis bit is cleared by writing 1 to itself.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No reset from Watch-Dog Timer</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The Watch-Dog Timer module had issued the reset signal to reset the system</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RSTS_BOD</name>
              <description>The RSTS_BOD Flag Is Set By The "Reset Signal" From The Brown-Out-Detected Module To Indicate The Previous Reset Source\nThis bit is cleared by writing 1 to itself.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No reset from BOD</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The Brown-Out-Detected module had issued the reset signal to reset the system</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RSTS_SYS</name>
              <description>The RSTS_SYS Flag Is Set By The "Reset Signal" From The Cortex_M0 Kernel To Indicate The Previous Reset Source\nThis bit is cleared by writing 1 to itself.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No reset from Cortex_M0</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The Cortex_M0 had issued the reset signal to reset the system by software writing 1 to bit SYSRESTREQ(AIRCR[2], Application Interrupt and Reset Control Register) in system control registers of Cortex_M0 kernel</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RSTS_CPU</name>
              <description>The RSTS_CPU Flag Is Set By Hardware If Software Writes CPU_RST (IPRST_CTL1[1]) "1" To Rest Cortex-M0 CPU Kernel And Flash Memory Controller (FMC)\nThis bit is cleared by writing 1 to itself.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No reset from CPU</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The Cortex-M0 CPU kernel and FMC are reset by software setting CPU_RST to 1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>IPRST_CTL1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IPRST_CTL1</displayName>
          <description>IP Reset Control Resister 1</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CHIP_RST</name>
              <description>CHIP One Shot Reset \nThis is a protected register. Please refer to open lock sequence to program it.\nSetting this bit will reset the whole chip, including CPU kernel and all peripherals like power-on reset and this bit will automatically return to "0" after the 2 clock cycles.\nThe chip setting from flash will be also reloaded when chip one shot reset.\nNote: In the following condition, chip setting from flash will be reloaded\nThe Power-On Reset\nBrown-Out-Detected Reset\nThe low level on the /RESET pin \nSet CHIP_RST(IPRST_CTL1[0])</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Normal</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset CHIP</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CPU_RST</name>
              <description>CPU Kernel One Shot Reset \nThis is a protected register. Please refer to open lock sequence to program it.\nSetting this bit will only reset the CPU kernel and Flash Memory Controller(FMC), and this bit will automatically return to "0" after the 2 clock cycles\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Normal</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset CPU</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_RST</name>
              <description>DMA Controller Reset\nThis is a protected register. Please refer to open lock sequence to program it.\nSet this bit "1" will generate a reset signal to the DMA. SW needs to set this bit to low to release reset signal.\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>DMA IP reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EBI_RST</name>
              <description>EBI Controller Reset\nThis is a protected register. Please refer to open lock sequence to program it.\nSet this bit "1" will generate a reset signal to the EBI. SW needs to set this bit to low to release reset signal.\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>EBI IP reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>IPRST_CTL2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IPRST_CTL2</displayName>
          <description>IP Reset Control Resister 2</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPIO_RST</name>
              <description>GPIO Controller Reset\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR0_RST</name>
              <description>Timer0 Controller Reset\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer0 normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer0 reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR1_RST</name>
              <description>Timer1 Controller Reset\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer1 normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer1 block reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR2_RST</name>
              <description>Timer2 Controller Reset\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer2 normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer2 block reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR3_RST</name>
              <description>Timer3 Controller Reset\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer3 normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer3 block reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C0_RST</name>
              <description>I2C0 Controller Reset\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I2C0 normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2C0 block reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C1_RST</name>
              <description>I2C1 Controller Reset\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I2C1 block normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2C1 block reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI0_RST</name>
              <description>SPI0 Controller Reset\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPI0 block normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI0 block reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI1_RST</name>
              <description>SPI1 Controller Reset\n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPI1 normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI1 block reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI2_RST</name>
              <description>SPI2 Controller Reset\n</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPI2 normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI2 block reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>UART0_RST</name>
              <description>UART0 Controller Reset\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UART0 normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART0 block reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>UART1_RST</name>
              <description>UART1 Controller Reset\n</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UART1 normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART1 block reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM0_RST</name>
              <description>PWM0 Controller Reset\n</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM0 block normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM0 block reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM1_RST</name>
              <description>PWM1 Controller Reset\n</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM1 block normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM1 block reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>USBD_RST</name>
              <description>USB Device Controller Reset\n</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>USB block normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>USB block reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_RST</name>
              <description>ADC Controller Reset\n</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ADC block normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ADC block reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>I2S_RST</name>
              <description>I2S Controller Reset\n</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I2S block normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2S block reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SC0_RST</name>
              <description>SC 0 Controller Reset\n</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SC block normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SC block reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SC1_RST</name>
              <description>SC 1 Controller Reset\n</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SC block normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SC block reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CPR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CPR</displayName>
          <description>Chip Performance Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HPE</name>
              <description>High Performance Enable\nThis bit is used to control chip operation performance.\nWhen this bit set, internal RAM and GPIO access is working with zero wait state, Flash controller will predict next address more efficiently \n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Chip operation at normal mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Chip operation at high performance mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TEMPCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TEMPCTL</displayName>
          <description>Temperature Sensor Control Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VTEMP_EN</name>
              <description>Temperature Sensor Enable\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Temperature sensor function Disabled (default)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Temperature sensor function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PA_L_MFP</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PA_L_MFP</displayName>
          <description>Port A Low Byte Multiple Function Control Register</description>
          <addressOffset>0x30</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PA0_MFP</name>
              <description>PA.0 Pin Function Selection\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PA1_MFP</name>
              <description>PA.1 Pin Function Selection\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PA2_MFP</name>
              <description>PA.2 Pin Function Selection\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PA3_MFP</name>
              <description>PA.3 Pin Function Selection\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PA4_MFP</name>
              <description>PA.4 Pin Function Selection\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PA5_MFP</name>
              <description>PA.5 Pin Function Selection\n</description>
              <bitOffset>20</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PA6_MFP</name>
              <description>PA.6 Pin Function Selection\n</description>
              <bitOffset>24</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PA7_MFP</name>
              <description>PA.7 Pin Function Selection\n</description>
              <bitOffset>28</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PA_H_MFP</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PA_H_MFP</displayName>
          <description>Port A High Byte Multiple Function Control Register</description>
          <addressOffset>0x34</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PA8_MFP</name>
              <description>PA.8 Pin Function Selection\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PA9_MFP</name>
              <description>PA.9 Pin Function Selection\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PA10_MFP</name>
              <description>PA.10 Pin Function Selection\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PA11_MFP</name>
              <description>PA.11 Pin Function Selection\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PA12_MFP</name>
              <description>PA.12 Pin Function Selection\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PA13_MFP</name>
              <description>PA.13 Pin Function Selection\n</description>
              <bitOffset>20</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PA14_MFP</name>
              <description>PA.14 Pin Function Selection\n</description>
              <bitOffset>24</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PA15_MFP</name>
              <description>PA.15 Pin Function Selection\n</description>
              <bitOffset>28</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PB_L_MFP</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PB_L_MFP</displayName>
          <description>Port B Low Byte Multiple Function Control Register</description>
          <addressOffset>0x38</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PB0_MFP</name>
              <description>PB.0 Pin Function Selection\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PB1_MFP</name>
              <description>PB.1 Pin Function Selection\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PB2_MFP</name>
              <description>PB.2 Pin Function Selection\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PB3_MFP</name>
              <description>PB.3 Pin Function Selection\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PB4_MFP</name>
              <description>PB.4 Pin Function Selection\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PB5_MFP</name>
              <description>PB.5 Pin Function Selection\n</description>
              <bitOffset>20</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PB6_MFP</name>
              <description>PB.6 Pin Function Selection\n</description>
              <bitOffset>24</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PB7_MFP</name>
              <description>PB.7 Pin Function Selection\n</description>
              <bitOffset>28</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PB_H_MFP</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PB_H_MFP</displayName>
          <description>Port B High Byte Multiple Function Control Register</description>
          <addressOffset>0x3C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PB8_MFP</name>
              <description>PB.8 Pin Function Selection\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PB9_MFP</name>
              <description>PB.9 Pin Function Selection\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PB10_MFP</name>
              <description>PB.10 Pin Function Selection\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PB11_MFP</name>
              <description>PB.11 Pin Function Selection\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PB12_MFP</name>
              <description>PB.12 Pin Function Selection\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PB13_MFP</name>
              <description>PB.13 Pin Function Selection\n</description>
              <bitOffset>20</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PB14_MFP</name>
              <description>PB.14 Pin Function Selection\n</description>
              <bitOffset>24</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PB15_MFP</name>
              <description>PB.15 Pin Function Selection\n</description>
              <bitOffset>28</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PC_L_MFP</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PC_L_MFP</displayName>
          <description>Port C Low Byte Multiple Function Control Register</description>
          <addressOffset>0x40</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PC0_MFP</name>
              <description>PC.0 Pin Function Selection\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PC1_MFP</name>
              <description>PC.1 Pin Function Selection\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PC2_MFP</name>
              <description>PC.2 Pin Function Selection\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PC3_MFP</name>
              <description>PC.3 Pin Function Selection\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PC4_MFP</name>
              <description>PC.4 Pin Function Selection\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PC5_MFP</name>
              <description>PC.5 Pin Function Selection\n</description>
              <bitOffset>20</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PC6_MFP</name>
              <description>PC.6 Pin Function Selection\n\n</description>
              <bitOffset>24</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PC7_MFP</name>
              <description>PC.7 Pin Function Selection\n</description>
              <bitOffset>28</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PC_H_MFP</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PC_H_MFP</displayName>
          <description>Port C High Byte Multiple Function Control Register</description>
          <addressOffset>0x44</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PC8_MFP</name>
              <description>PC.8 Pin Function Selection\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PC9_MFP</name>
              <description>PC.9 Pin Function Selection\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PC10_MFP</name>
              <description>PC.10 Pin Function Selection\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PC11_MFP</name>
              <description>PC.11 Pin Function Selection\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PC12_MFP</name>
              <description>PC.12 Pin Function Selection\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PC13_MFP</name>
              <description>PC.13 Pin Function Selection\n</description>
              <bitOffset>20</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PC14_MFP</name>
              <description>PC.14 Pin Function Selection\n</description>
              <bitOffset>24</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PC15_MFP</name>
              <description>PC.15 Pin Function Selection\n</description>
              <bitOffset>28</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PD_L_MFP</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PD_L_MFP</displayName>
          <description>Port D Low Byte Multiple Function Control Register</description>
          <addressOffset>0x48</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PD0_MFP</name>
              <description>PD.0 Pin Function Selection\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PD1_MFP</name>
              <description>PD.1 Pin Function Selection\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PD2_MFP</name>
              <description>PD.2 Pin Function Selection\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PD3_MFP</name>
              <description>PD.3 Pin Function Selection\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PD4_MFP</name>
              <description>PD.4 Pin Function Selection\n\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PD5_MFP</name>
              <description>PD.5 Pin Function Selection\n</description>
              <bitOffset>20</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PD6_MFP</name>
              <description>PD.6 Pin Function Selection\n</description>
              <bitOffset>24</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PD7_MFP</name>
              <description>PD.7 Pin Function Selection\n</description>
              <bitOffset>28</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PD_H_MFP</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PD_H_MFP</displayName>
          <description>Port D High Byte Multiple Function Control Register</description>
          <addressOffset>0x4C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PD8_MFP</name>
              <description>PD.8 Pin Function Selection\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PD9_MFP</name>
              <description>PD.9 Pin Function Selection\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PD10_MFP</name>
              <description>PD.10 Pin Function Selection\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PD11_MFP</name>
              <description>PD.11 Pin Function Selection\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PD12_MFP</name>
              <description>PD.12 Pin Function Selection\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PD13_MFP</name>
              <description>PD.13 Pin Function Selection\n</description>
              <bitOffset>20</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PD14_MFP</name>
              <description>PD.14 Pin Function Selection\n</description>
              <bitOffset>24</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PD15_MFP</name>
              <description>PD.15 Pin Function Selection\n</description>
              <bitOffset>28</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PE_L_MFP</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PE_L_MFP</displayName>
          <description>Port E Low Byte Multiple Function Control Register</description>
          <addressOffset>0x50</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PE0_MFP</name>
              <description>PE.0 Pin Function Selection\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PE1_MFP</name>
              <description>PE.1 Pin Function Selection\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PE2_MFP</name>
              <description>PE.2 Pin Function Selection\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PE3_MFP</name>
              <description>PE.3 Pin Function Selection\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PE4_MFP</name>
              <description>PE.4 Pin Function Selection\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PE5_MFP</name>
              <description>PE.5 Pin Function Selection\n</description>
              <bitOffset>20</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PE6_MFP</name>
              <description>PE.6 Pin Function Selection\nAll setting : GPIOE[6]</description>
              <bitOffset>24</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PE7_MFP</name>
              <description>PE.7 Pin Function Selection\n</description>
              <bitOffset>28</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PE_H_MFP</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PE_H_MFP</displayName>
          <description>Port E High Byte Multiple Function Control Register</description>
          <addressOffset>0x54</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PE8_MFP</name>
              <description>PE.8 Pin Function Selection\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PE9_MFP</name>
              <description>PE.9 Pin Function Selection\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PE10_MFP</name>
              <description>PE.10 Pin Function Selection\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PE11_MFP</name>
              <description>PE.11 Pin Function Selection\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PE12_MFP</name>
              <description>PE.12 Pin Function Selection\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PE13_MFP</name>
              <description>PE.13 Pin Function Selection\n</description>
              <bitOffset>20</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PE14_MFP</name>
              <description>PE.14 Pin Function Selection\n</description>
              <bitOffset>24</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PE15_MFP</name>
              <description>PE.15 Pin Function Selection\n</description>
              <bitOffset>28</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PF_L_MFP</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PF_L_MFP</displayName>
          <description>Port F Low Byte Multiple Function Control Register</description>
          <addressOffset>0x58</addressOffset>
          <access>read-write</access>
          <resetValue>0x00777777</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PF0_MFP</name>
              <description>PF.0 Pin Function Selection\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PF1_MFP</name>
              <description>PF.1 Pin Function Selection\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PF2_MFP</name>
              <description>PF.2 Pin Function Selection\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PF3_MFP</name>
              <description>PF.3 Pin Function Selection\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PF4_MFP</name>
              <description>PF.4 Pin Function Selection\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PF5_MFP</name>
              <description>PF.5 Pin Function Selection\n</description>
              <bitOffset>20</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PORCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PORCTL</displayName>
          <description>Power-On-reset Controller Register</description>
          <addressOffset>0x60</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>POR_DIS_CODE</name>
              <description>Power-On Reset Enable Control\nThis is a protected register. Please refer to open lock sequence to program it.\nWhen powered on, the POR circuit generates a reset signal to reset the whole chip function, but noise on the power may cause the POR active again. If setting the POR_DIS_CODE to 0x5AA5, the POR reset function will be disabled and the POR function will be active again when POR_DIS_CODE is set to another value or POR_DIS_CODE is reset by chip other reset functions, including: /RESET, Watchdog Timer reset, BOD reset, ICE reset command and the software-chip reset function</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>BODCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BODCTL</displayName>
          <description>Brown-out Detector Control Register</description>
          <addressOffset>0x64</addressOffset>
          <access>read-write</access>
          <resetValue>0x00FFF000</resetValue>
          <resetMask>0xFFFFFF00</resetMask>
          <fields>
            <field>
              <name>BOD17_EN</name>
              <description>Brown-Out Detector 1.7V Function Enable \n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Brown-out Detector 1.7V function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Brown-out Detector 1.7V function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BOD20_EN</name>
              <description>Brown-Out Detector 2.0 V Function Enable \nThis is a protected register. Please refer to open lock sequence to program it.\nBOD20_EN is default on. If SW disables it, Brown-out Detector 2.0 V function is not disabled until chip enters power-down mode. If system is not in power-down mode, BOD20_EN will be enabled by hardware automatically.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Brown-out Detector 2.0 V function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Brown-out Detector 2.0 V function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BOD25_EN</name>
              <description>Brown-Out Detector 2.5 V Function Enable \nThis is a protected register. Please refer to open lock sequence to program it.\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Brown-out Detector 2.5 V function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Brown-out Detector 2.5 V function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BOD17_RST_EN</name>
              <description>BOD 1.7 V Reset Enable\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Reset does not  issue when BOD17 occurs</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset issues when BOD17 occurs</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BOD20_RST_EN</name>
              <description>BOD 2.0 V Reset Enable\nThis is a protected register. Please refer to open lock sequence to program it.\nThe default value is set by flash controller user configuration register config0 bit[20:19]</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Reset does not issue when BOD20 occurs</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset issues when BOD20 occurs</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BOD25_RST_EN</name>
              <description>BOD 2.5 V Reset Enable\nThis is a protected register. Please refer to open lock sequence to program it.\nThe default value is set by flash controller user configuration register config0 bit[20:19]</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Reset does not issue when BOD25 occurs</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset issues when BOD25 occurs</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BOD17_INT_EN</name>
              <description>BOD 1.7 V Interrupt Enable\nThis is a protected register. Please refer to open lock sequence to program it.\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt does not issue when BOD17 occurs</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt issues when BOD17 occurs</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BOD20_INT_EN</name>
              <description>BOD 2.0 V Interrupt Enable\nThis is a protected register. Please refer to open lock sequence to program it.\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt does not issue when BOD20 occurs</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt issues when BOD20 occurs</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BOD25_INT_EN</name>
              <description>BOD 2.5 V Interrupt Enable\nThis is a protected register. Please refer to open lock sequence to program it.\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt does not issue when BOD25 occurs</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt issues when BOD25 occurs</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>BODSTS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BODSTS</displayName>
          <description>Brown-out Detector Status Register</description>
          <addressOffset>0x68</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BOD_INT</name>
              <description>Brown-Out Detector Interrupt Status\nThis bit is cleared by writing 1 to itself.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Brown-out Detector does not detect any voltage drift at VDD down through or up through the target detected voltage after interrupt is enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When Brown-out Detector detects the VDD is dropped down through the target detected voltage or the VDD is raised up through the target detected voltage and Brown-out interrupt is enabled, this bit will be set to 1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BOD17_OUT</name>
              <description>Brown-Out Detector Output Status\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Brown-out Detector output status is 0. It means the detected voltage is higher than target detected voltage setting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Brown-out Detector output status is 1. It means the detected voltage is lower than target detected voltage setting (1.7V). If the BOD17_EN is "0", BOD17 function disabled,  this bit always responds "0"</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BOD20_OUT</name>
              <description>Brown-Out Detector Output Status\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Brown-out Detector output status is 0. It means the detected voltage is higher than target detected voltage setting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Brown-out Detector output status is 1. It means the detected voltage is lower than target detected voltage setting (2.0 V). If the BOD20_EN is "0", BOD20 function disabled,  this bit always responds "0"</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BOD25_OUT</name>
              <description>Brown-Out Detector Output Status\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Brown-out Detector output status is 0. It means the detected voltage is higher than target detected voltage setting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Brown-out Detector output status is 1. It means the detected voltage is lower than target detected voltage setting (2.5 V). If the BOD25_EN is "0", BOD25 function disabled,  this bit always responds "0"</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>VREFCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>VREFCTL</displayName>
          <description>Voltage Reference Control Register</description>
          <addressOffset>0x6C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000F00</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BGP_EN</name>
              <description>Band-Gap Enable\nThis is a protected register. Please refer to open lock sequence to program it.\nBand-gap is the reference voltage of internal reference voltage. User must enable band-gap if want to enable internal 1.5V or 2.5V reference voltage.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>REG_EN</name>
              <description>Regulator Enable\nEnable internal 1.5V or 2.5V reference voltage.\nThis is a protected register. Please refer to open lock sequence to program it.\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SEL25</name>
              <description>Regulator Output Voltage Selection\nSelect internal reference voltage level.\nThis is a protected register. Please refer to open lock sequence to program it.\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>1.5V</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>2.5V</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EXT_MODE</name>
              <description>Regulator External Mode\nThis is a protected register. Please refer to open lock sequence to program it.\nUsers can output regulator output voltage in Vref pin if EXT_MODE is high.\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No connection with external VREF pin</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Connet to external VREF pin. Connect a 1uF to 10uF capacitor to AVSS will let internal voltage reference be more stable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>IRCTRIMCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IRCTRIMCTL</displayName>
          <description>HIRC Trim Control Register</description>
          <addressOffset>0x80</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TRIM_SEL</name>
              <description>Trim Frequency Selection\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIM_LOOP</name>
              <description>Trim Calculation Loop\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIM_RETRY_CNT</name>
              <description>Trim Value Update Limitation Count\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>IRCTRIMIEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IRCTRIMIEN</displayName>
          <description>HIRC Trim Interrupt Enable Register</description>
          <addressOffset>0x84</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TRIM_FAIL_IEN</name>
              <description>Trim Failure Interrupt Enable\nThis bit controls if an interrupt will be triggered while HIRC trim value update limitation count reached and HIRC frequency still not locked on target frequency set by TRIM_SEL (IRCTRIMCTL[1:0]).\nIf this bit is high and TRIM_FAIL_INT (IRCTRIMINT[1]) is set during auto trim operation, an interrupt will be triggered to notify that HIRC trim value update limitation count was reached.\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TRIM_FAIL_INT (IRCTRIMINT[1]) status Disabled to trigger an interrupt to CPU</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TRIM_FAIL_INT (IRCTRIMINT[1]) status Enabled to trigger an interrupt to CPU</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>_32K_ERR_IEN</name>
              <description>32.768 KHz Clock Error Interrupt Enable\nThis bit controls if CPU would get an interrupt while 32.768 kHz clock is inaccuracy during auto trim operation.\nIf this bit is high, and 32K_ERR_INT (IRCTRIMINT[2]) is set during auto trim operation, an interrupt will be triggered to notify the 32.768 kHz clock frequency is inaccuracy.\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>32K_ERR_INT (IRCTRIMINT[2]) status Disabled to trigger an interrupt to CPU</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>32K_ERR_INT (IRCTRIMINT[2]) status Enabled to trigger an interrupt to CPU</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>IRCTRIMINT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IRCTRIMINT</displayName>
          <description>HIRC Trim Interrupt Status Register</description>
          <addressOffset>0x88</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FREQ_LOCK</name>
              <description>HIRC Frequency Lock Status\nThis bit indicates the HIRC frequency lock.\nThis is a status bit and doesn't trigger any interrupt.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIM_FAIL_INT</name>
              <description>Trim Failure Interrupt Status\nThis bit indicates that HIRC trim value update limitation count reached and HIRC clock frequency still doesn't lock. Once this bit is set, the auto trim operation stopped and TRIM_SEL (IRCTRIMCTL[1:0]) will be cleared to 00 by hardware automatically.\nIf this bit is set and TRIM_FAIL_IEN (IRCTRIMIEN[1]) is high, an interrupt will be triggered to notify that HIRC trim value update limitation count was reached. Write 1 to clear this to zero.\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Trim value update limitation count doesn't reach</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Trim value update limitation count reached and HIRC frequency still doesn't lock</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>_32K_ERR_INT</name>
              <description>32.768 KHz Clock Error Interrupt Status\nThis bit indicates that 32.768 kHz clock frequency is inaccuracy. Once this bit is set, the auto trim operation stopped and TRIM_SEL (IRCTRIMCTL[1:0]) will be cleared to 00 by hardware automatically.\nIf this bit is set and 32K_ERR_IEN (IRCTRIMIEN[2]) is high, an interrupt will be triggered to notify the 32.768 kHz clock frequency is inaccuracy. Write 1 to clear this to zero.\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>32.768 kHz clock frequency is accuracy</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>32.768 kHz clock frequency is inaccuracy</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>RegLockAddr</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>RegLockAddr</displayName>
          <description>Register Lock Key Address Register</description>
          <addressOffset>0x100</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RegUnLock</name>
              <description></description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Protected register are locked. Any write to the target register is ignored</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Protected registers are Unlock</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>CLK</name>
      <description>CLK Register Map</description>
      <groupName>CLK</groupName>
      <baseAddress>0x50000200</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x2C</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x30</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>PWRCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWRCTL</displayName>
          <description>System Power Down Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000310</resetValue>
          <resetMask>0xFFFFFFF0</resetMask>
          <fields>
            <field>
              <name>HXT_EN</name>
              <description>HXT Control\nThis is a protected register. Please refer to open lock sequence to program it.\nThe bit default value is set by flash controller user configuration register config0 [26]. \nHXT is disabled by default.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LXT_EN</name>
              <description>LXT Control\nThis is a protected register. Please refer to open lock sequence to program it.\nLXT is disabled by default.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>HIRC_EN</name>
              <description>HIRC Control\nThis is a protected register. Please refer to open lock sequence to program it.\nHIRC is enabled by default.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIRC_EN</name>
              <description>LIRC Control\nThis is a protected register. Please refer to open lock sequence to program it.\nLIRC is enabled by default.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WK_DLY</name>
              <description>Wake-Up Delay Counter Enable\nThis is a protected register. Please refer to open lock sequence to program it.\nWhen chip wakes up from Power-down mode, the clock control will delay 4096 clock cycles to wait HXT stable or 16 clock cycles to wait HIRC stable.\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Delay clock cycle delay Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Delay clock cycle delay Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_WK_IE</name>
              <description>Power-Down Mode Wake-Up Interrupt Enable \nThis is a protected register. Please refer to open lock sequence to program it.\nPD_WK_INT will be set if both PD_WK_IS (PD_WK_IS[0]) and PD_WK_IE (PWRCTL[5]) are high.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_EN</name>
              <description>Chip Power-Down Mode Enable Bit\nThis is a protected register. Please refer to open lock sequence to program it.\nWhen CPU sets this bit, the chip power down is enabled and chip will not enter Power-down mode until CPU sleep mode is also active.  \nWhen chip wakes up from Power-down mode, this bit will be auto cleared.\nWhen chip is in Power-down mode, the LDO, HXT and HIRC will be disabled, but LXT and LIRC are not controlled by Power-down mode.\nWhen power down, the PLL and system clock (CPU, HCLKx and PCLKx) are also disabled no matter the Clock Source selection. Peripheral clocks are not controlled by this bit, if peripheral Clock Source is from LXT or LIRC.\nIn Power-down mode, flash macro power is ON.\nNOTE: It inhibits to set both PD_EN and DPD_EN high.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Chip operated in Normal mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Chip power down Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>HXT_SELXT</name>
              <description>HXT SELXT\nThis is a protected register. Please refer to open lock sequence to program it.\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>High frequency crystal loop back path Disabled. It is used for external oscillator</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>High frequency crystal loop back path Enabled. It is used for external crystal</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>HXT_GAIN</name>
              <description>HXT Gain Control Bit\nThis is a protected register. Please refer to open lock sequence to program it.\nGain control is used to enlarge the gain of crystal to make sure crystal wok normally. If gain control is enabled, crystal will consume more power than gain control off. \n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Gain control Disabled. It means HXT gain is always high</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Gain control Enabled. HXT gain will be high lasting 2ms then low. This is for power saving</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LXT_SCNT</name>
              <description>LXT Stable Time Control\nThis is a protected register. Please refer to open lock sequence to program it.\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Delay 4096 LXT before LXT output</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Delay 8192 LXT before LXT output</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>AHBCLK</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>AHBCLK</displayName>
          <description>AHB Devices Clock Enable Control Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000035</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPIO_EN</name>
              <description>GPIO Controller Clock Enable \n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_EN</name>
              <description>DMA Controller Clock Enable\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISP_EN</name>
              <description>Flash ISP Controller Clock Enable\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EBI_EN</name>
              <description>EBI Controller Clock Enable\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SRAM_EN</name>
              <description>SRAM Controller Clock Enable\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TICK_EN</name>
              <description>System Tick Clock Enable\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>APBCLK</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>APBCLK</displayName>
          <description>APB Devices Clock Enable Control Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WDT_EN</name>
              <description>Watch-Dog Timer Clock Enable Control \nThis is a protected register. Please refer to open lock sequence to program it.\nThis bit is used to control the WDT APB clock only, The WDT engine Clock Source is from LIRC.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RTC_EN</name>
              <description>Real-Time-Clock Clock Enable Control \nThis bit is used to control the RTC APB clock only, The RTC engine Clock Source is from LXT.\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR0_EN</name>
              <description>Timer0 Clock Enable Control\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR1_EN</name>
              <description>Timer1 Clock Enable Control\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR2_EN</name>
              <description>Timer2 Clock Enable Control\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR3_EN</name>
              <description>Timer3 Clock Enable Control\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FDIV_EN</name>
              <description>Frequency Divider Output Clock Enable Control\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C0_EN</name>
              <description>I2C0 Clock Enable Control \n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C1_EN</name>
              <description>I2C1 Clock Enable Control \n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI0_EN</name>
              <description>SPI0 Clock Enable Control \n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI1_EN</name>
              <description>SPI1 Clock Enable Control \n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI2_EN</name>
              <description>SPI2 Clock Enable Control \n</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>UART0_EN</name>
              <description>UART0 Clock Enable Control\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>UART1_EN</name>
              <description>UART1 Clock Enable Control\n</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM0_CH01_EN</name>
              <description>PWM0 Channel 0 And Channel 1Clock Enable Control\n</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM0_CH23_EN</name>
              <description>PWM0 Channel 2 And Channel 3 Clock Enable Control\n</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM1_CH01_EN</name>
              <description>PWM1 Channel 0 And Channel 1 Clock Enable Control\n</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM1_CH23_EN</name>
              <description>PWM1 Channel 2 And Channel 3 Clock Enable Control\n</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>USBD_EN</name>
              <description>USB FS Device Controller Clock Enable Control\n</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_EN</name>
              <description>Analog-Digital-Converter (ADC) Clock Enable Control\n</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>I2S_EN</name>
              <description>I2S Clock Enable Control\n</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SC0_EN</name>
              <description>SmartCard 0 Clock Enable Control\n</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SC1_EN</name>
              <description>SmartCard 1 Clock Enable Control\n</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CLKSTATUS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CLKSTATUS</displayName>
          <description>Clock Status Monitor Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000010</resetValue>
          <resetMask>0xFFFFFFF0</resetMask>
          <fields>
            <field>
              <name>HXT_STB</name>
              <description>HEXT Clock Source Stable Flag\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>HXT clock is not stable or not enable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>HXT clock is stable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LXT_STB</name>
              <description>LEXT Clock Source Stable Flag\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LXT clock is not stable or not enable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LXT clock is stable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>PLL_STB</name>
              <description>PLL Clock Source Stable Flag\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PLL clock is not stable or not enable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PLL clock is stable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LIRC_STB</name>
              <description>LIRC Clock Source Stable Flag\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIRC clock is not stable or not enable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIRC clock is stable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>HIRC_STB</name>
              <description>HIRC Clock Source Stable Flag\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>HIRC clock is not stable or not enable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>HIRC clock is stable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>CLK_SW_FAIL</name>
              <description>Clock Switch Fail Flag\nThis bit will be set when target switch Clock Source is not stable. This bit is write 1 clear</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock switch success</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock switch fail</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CLKSEL0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CLKSEL0</displayName>
          <description>Clock Source Select Control Register 0</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFF0</resetMask>
          <fields>
            <field>
              <name>HCLK_S</name>
              <description>HCLK Clock Source Selection\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CLKSEL1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CLKSEL1</displayName>
          <description>Clock Source Select Control Register 1</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x0007FFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>UART_S</name>
              <description>UART 0/1 Clock Source Selection (UART0 And UART1 Use The Same Clock Source Selection)\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_S</name>
              <description>ADC Clock Source Selection\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM0_CH01_S</name>
              <description>PWM0 Channel 0 And Channel 1 Clock Source Selection\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM0_CH23_S</name>
              <description>PWM0 Channel 2 And Channel 3 Clock Source Selection\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR0_S</name>
              <description>TIMER 0 Clock Source Selection\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR1_S</name>
              <description>TIMER 1 Clock Source Selection\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CLKSEL2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CLKSEL2</displayName>
          <description>Clock Source Select Control Register 2</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x000FFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FRQDIV_S</name>
              <description>Clock Divider Clock Source Selection\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM1_CH01_S</name>
              <description>PWM1 Channel 0 And Channel 1 Clock Source Selection\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM1_CH23_S</name>
              <description>PWM1 Channel 2 And Channel 2 Clock Source Selection\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR2_S</name>
              <description>TIMER 2 Clock Source Selection\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR3_S</name>
              <description>TIMER 3 Clock Source Selection\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>I2S_S</name>
              <description>I2S Clock Source Selection\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SC_S</name>
              <description>SC Clock Source Selection\n</description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CLKDIV0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CLKDIV0</displayName>
          <description>Clock Divider Number Register 0</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HCLK_N</name>
              <description>HCLK Clock Divide Number From HCLK Clock Source\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>USB_N</name>
              <description>USB Clock Divide Number From PLL Clock \n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_N</name>
              <description>UART Clock Divide Number From UART Clock Source\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>I2S_N</name>
              <description>I2S Clock Divide Number From I2S Clock Source\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_N</name>
              <description>ADC Clock Divide Number From ADC Clock Source\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SC0_N</name>
              <description>SC 0 Clock Divide Number From SC 0 Clock Source\n</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CLKDIV1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CLKDIV1</displayName>
          <description>Clock Divider Number Register 1</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SC1_N</name>
              <description>SC 1 Clock Divide Number From SC 1 Clock Source\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PLLCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PLLCTL</displayName>
          <description>PLL Control Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00031120</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FB_DV</name>
              <description>PLL Feedback Divider Control Pins \nRefer to the formulas below the table.\nThe range of FB_DV is from 0 to 63.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IN_DV</name>
              <description>PLL Input Divider Control Pins\nRefer to the formulas below the table.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OUT_DV</name>
              <description>PLL Output Divider Control Pins \nRefer to the formulas below the table.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PD</name>
              <description>Power-Down Mode \nIf set the PD_EN(PWRCTL[6]) "1" , the PLL will enter Power-down mode too\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PLL is in normal mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PLL is in power-down mode (default)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PLL_SRC</name>
              <description>PLL Source Clock Select\n</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PLL source clock from HXT</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PLL source clock from HIRC</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>FRQDIV</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>FRQDIV</displayName>
          <description>Frequency Divider Control Register</description>
          <addressOffset>0x28</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FSEL</name>
              <description>Divider Output Frequency Selection Bits\nThe formula of output frequency is\nWhere Fin is the input clock frequency, Fout is the frequency of divider output clock and N is the 4-bit value of FSEL(FRQDIV[3:0]).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FDIV_EN</name>
              <description>Frequency Divider Enable Bit\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Frequency Divider Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Frequency Divider Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PD_WK_IS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PD_WK_IS</displayName>
          <description>Power-down Wake-up Interrupt Status Register</description>
          <addressOffset>0x30</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PD_WK_IS</name>
              <description>Wake-Up Interrupt Sstatus In Chip Power-Down Mode\nThis bit indicates that some event resumes chip from Power-down mode \nThe status is set if external interrupts, UART, GPIO, RTC, USB, SPI, Timer, WDT, and BOD wake-up occurred.\nWrite 1 to clear this bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>FMC</name>
      <description>FMC Register Map</description>
      <groupName>FMC</groupName>
      <baseAddress>0x5000C000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x18</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x40</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>ISPCON</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ISPCON</displayName>
          <description>ISP Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ISPEN</name>
              <description>ISP Enable (Erite-Protection Bit)\nISP function enable bit. Set this bit to enable ISP function.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ISP function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ISP function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BS</name>
              <description>Boot Select (Write-Protection Bit)\nSet/clear this bit to select next booting from LDROM/APROM, respectively. This bit also functions as chip booting status flag, which can be used to check where chip booted from. This bit is initiated with the inversed value of CBS in Config0 after power-on reset; It keeps the same value at other reset.\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>boot from APROM</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>boot from LDROM</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISPFF</name>
              <description>ISP Fail Flag (Write-Protection Bit)\nThis bit is set by hardware when a triggered ISP meets any of the following conditions:\n(1) APROM writes to itself\n(2) LDROM writes to itself\n(3) CONFIG is erased/programmed when the MCU is running in APROM\n(4) Destination address is illegal, such as over an available range\nWrite 1 to clear.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SWRST</name>
              <description>Software Reset\nWriting 1 to this bit to start software reset. \nIt is cleared by hardware after reset is finished.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PT</name>
              <description>Flash Program Time (Write-Protection Bits)\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ET</name>
              <description>Flash Erase Time (Write-Protection Bits)\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ISPADR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ISPADR</displayName>
          <description>ISP Address Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ISPADR</name>
              <description>ISP Address\nThis chip supports word program only. ISPADR[1:0] must be kept 00b for ISP operation.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ISPDAT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ISPDAT</displayName>
          <description>ISP Data Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ISPDAT</name>
              <description>ISP Data\nWrite data to this register before ISP program operation.\nRead data from this register after ISP read operation.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ISPCMD</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ISPCMD</displayName>
          <description>ISP Command Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FCTRL</name>
              <description>ISP Command\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FCEN</name>
              <description>ISP Command\nThe ISP command table is shown as follows.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FOEN</name>
              <description>ISP Command\nThe ISP command table is shown as follows.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ISPTRG</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ISPTRG</displayName>
          <description>ISP Trigger Control Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ISPGO</name>
              <description>ISP Start Trigger\nWrite 1 to start ISP operation and this bit will be cleared to 0 by hardware automatically when ISP operation is finished.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ISP operation is finished</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ISP is on going</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>DFBADR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>DFBADR</displayName>
          <description>Data Flash Base Address</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x0001F000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DFBA</name>
              <description>Data Flash Base Address\nThis register indicates data flash start address. It is a read only register.\nThe data flash start address is defined by user. Since on chip flash erase unit is 512 bytes, it is mandatory to keep bit 8-0 as 0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ISPSTA</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ISPSTA</displayName>
          <description>ISP Status Register</description>
          <addressOffset>0x40</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ISPBUSY</name>
              <description>ISP BUSY\n\nRead Only</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ISP operation is finished</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ISP operation is busy</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CBS</name>
              <description>Config Boot Selection Status\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ISPFF</name>
              <description>ISP Fail Flag\nThis bit is set by hardware when a triggered ISP meets any of the following conditions:\n(1) APROM writes to itself.\n(2) LDROM writes to itself. \n(3) CONFIG is erased/programmed when the MCU is running in APROM.\n(4) Destination address is illegal, such as over an available range.\nWrite 1 to clear.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VECMAP</name>
              <description>Vector Page Mapping Address (Read Only)\nThe current system memory space 0x0000_0000~0x0000_01FF is mapped to flash memory page with base address (VECMAP[11:0]    9). When chip is reset, the remapping address (VECMAP) is clear to CONFIG0 (CBS) default address setting.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>EBI</name>
      <description>EBI Register Map</description>
      <groupName>EBI</groupName>
      <baseAddress>0x50010000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>EBICON</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>EBICON</displayName>
          <description>External Bus Interface General Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ExtEN</name>
              <description>EBI Enable Control\nThis bit is the functional enable bit for EBI.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>EBI function is disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>EBI function is enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ExtBW16</name>
              <description>EBI Data Width 16-Bit\nThis bit defines if the data bus is 8-bit or 16-bit.\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>EBI data width is 8-bit</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>EBI data width is 16-bit</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MCLKDIV</name>
              <description>External Output Clock Divider\nThe frequency of EBI output clock is controlled by MCLKDIV as shown in the following table.\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>HCLK/1</description>
                    <value>0x0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>HCLK/2</description>
                    <value>0x1</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>HCLK/4</description>
                    <value>0x2</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>HCLK/8</description>
                    <value>0x3</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>HCLK/16</description>
                    <value>0x4</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>HCLK/32</description>
                    <value>0x5</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>HCLK/1</description>
                    <value>0x6</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>HCLK/1</description>
                    <value>0x7</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MCLKEN</name>
              <description>External Clock Enable Control\nThis bit control if EBI generates the clock to external device.\nIf external device is a synchronous device, it's necessary to set this bit high to enable EBI generating clock to external device.\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled EBI to generate clock to external device</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ExttALE</name>
              <description>Expand Time Of ALE\nThe ALE width (tALE) to latch the address can be controlled by ExttALE.\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>EXTIME</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>EXTIME</displayName>
          <description>External Bus Interface Timing Control Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ExttACC</name>
              <description>EBI Data Access Time\nExttACC define data access time (tACC).\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ExttAHD</name>
              <description>EBI Data Access Hold Time\nExttAHD define data access hold time (tAHD).\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ExtIW2X</name>
              <description>Idle State Cycle After Write\nWhen write action is finish, idle state is inserted and nCS return to high if ExtIW2X is not zero.\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ExtIR2W</name>
              <description>Idle State Cycle Between Read-Write\nWhen read action is finish and next action is going to write, idle state is inserted and nCS return to high if ExtIR2W is not zero.\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ExtIR2R</name>
              <description>Idle State Cycle Between Read-Read\nWhen read action is finish and next action is going to read, idle state is inserted and nCS return to high if ExtIR2R is not zero.\n</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>GP</name>
      <description>GP Register Map</description>
      <groupName>GP</groupName>
      <baseAddress>0x50004000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x28</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x40</offset>
        <size>0x28</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x80</offset>
        <size>0x28</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0xC0</offset>
        <size>0x28</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x100</offset>
        <size>0x28</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x140</offset>
        <size>0x28</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x180</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x200</offset>
        <size>0x158</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>GPIOA_PMD</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPIOA_PMD</displayName>
          <description>GPIO Port A Pin I/O Mode Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PMD0</name>
              <description>GPIO Port [X] Pin [N] Mode Control\nDetermine the I/O type of GPIO port [x] pin [n]\nNote: \nFor GPIOC_PMD, PMD4~PMD5 and PMD12~PMD13 are reserved.\nFor GPIOD_PMD, PMD0~PMD5 and PMD8~PMD13 are reserved.\nFor GPIOE_PMD, PMD0~PMD4 and PMD6~PMD15 are reserved.\nFor GPIOF_PMD, PMD2 ~ PMD15 are reserved.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [x] pin [n] is in INPUT mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [x] pin [n] is in OUTPUT mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [x] pin [n] is in Open-Drain mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD1</name>
              <description>GPIO Port [X] Pin [N] Mode Control\nDetermine the I/O type of GPIO port [x] pin [n]\nNote: \nFor GPIOC_PMD, PMD4~PMD5 and PMD12~PMD13 are reserved.\nFor GPIOD_PMD, PMD0~PMD5 and PMD8~PMD13 are reserved.\nFor GPIOE_PMD, PMD0~PMD4 and PMD6~PMD15 are reserved.\nFor GPIOF_PMD, PMD2 ~ PMD15 are reserved.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [x] pin [n] is in INPUT mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [x] pin [n] is in OUTPUT mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [x] pin [n] is in Open-Drain mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD2</name>
              <description>GPIO Port [X] Pin [N] Mode Control\nDetermine the I/O type of GPIO port [x] pin [n]\nNote: \nFor GPIOC_PMD, PMD4~PMD5 and PMD12~PMD13 are reserved.\nFor GPIOD_PMD, PMD0~PMD5 and PMD8~PMD13 are reserved.\nFor GPIOE_PMD, PMD0~PMD4 and PMD6~PMD15 are reserved.\nFor GPIOF_PMD, PMD2 ~ PMD15 are reserved.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [x] pin [n] is in INPUT mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [x] pin [n] is in OUTPUT mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [x] pin [n] is in Open-Drain mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD3</name>
              <description>GPIO Port [X] Pin [N] Mode Control\nDetermine the I/O type of GPIO port [x] pin [n]\nNote: \nFor GPIOC_PMD, PMD4~PMD5 and PMD12~PMD13 are reserved.\nFor GPIOD_PMD, PMD0~PMD5 and PMD8~PMD13 are reserved.\nFor GPIOE_PMD, PMD0~PMD4 and PMD6~PMD15 are reserved.\nFor GPIOF_PMD, PMD2 ~ PMD15 are reserved.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [x] pin [n] is in INPUT mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [x] pin [n] is in OUTPUT mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [x] pin [n] is in Open-Drain mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD4</name>
              <description>GPIO Port [X] Pin [N] Mode Control\nDetermine the I/O type of GPIO port [x] pin [n]\nNote: \nFor GPIOC_PMD, PMD4~PMD5 and PMD12~PMD13 are reserved.\nFor GPIOD_PMD, PMD0~PMD5 and PMD8~PMD13 are reserved.\nFor GPIOE_PMD, PMD0~PMD4 and PMD6~PMD15 are reserved.\nFor GPIOF_PMD, PMD2 ~ PMD15 are reserved.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [x] pin [n] is in INPUT mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [x] pin [n] is in OUTPUT mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [x] pin [n] is in Open-Drain mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD5</name>
              <description>GPIO Port [X] Pin [N] Mode Control\nDetermine the I/O type of GPIO port [x] pin [n]\nNote: \nFor GPIOC_PMD, PMD4~PMD5 and PMD12~PMD13 are reserved.\nFor GPIOD_PMD, PMD0~PMD5 and PMD8~PMD13 are reserved.\nFor GPIOE_PMD, PMD0~PMD4 and PMD6~PMD15 are reserved.\nFor GPIOF_PMD, PMD2 ~ PMD15 are reserved.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [x] pin [n] is in INPUT mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [x] pin [n] is in OUTPUT mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [x] pin [n] is in Open-Drain mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD6</name>
              <description>GPIO Port [X] Pin [N] Mode Control\nDetermine the I/O type of GPIO port [x] pin [n]\nNote: \nFor GPIOC_PMD, PMD4~PMD5 and PMD12~PMD13 are reserved.\nFor GPIOD_PMD, PMD0~PMD5 and PMD8~PMD13 are reserved.\nFor GPIOE_PMD, PMD0~PMD4 and PMD6~PMD15 are reserved.\nFor GPIOF_PMD, PMD2 ~ PMD15 are reserved.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [x] pin [n] is in INPUT mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [x] pin [n] is in OUTPUT mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [x] pin [n] is in Open-Drain mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD7</name>
              <description>GPIO Port [X] Pin [N] Mode Control\nDetermine the I/O type of GPIO port [x] pin [n]\nNote: \nFor GPIOC_PMD, PMD4~PMD5 and PMD12~PMD13 are reserved.\nFor GPIOD_PMD, PMD0~PMD5 and PMD8~PMD13 are reserved.\nFor GPIOE_PMD, PMD0~PMD4 and PMD6~PMD15 are reserved.\nFor GPIOF_PMD, PMD2 ~ PMD15 are reserved.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [x] pin [n] is in INPUT mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [x] pin [n] is in OUTPUT mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [x] pin [n] is in Open-Drain mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD8</name>
              <description>GPIO Port [X] Pin [N] Mode Control\nDetermine the I/O type of GPIO port [x] pin [n]\nNote: \nFor GPIOC_PMD, PMD4~PMD5 and PMD12~PMD13 are reserved.\nFor GPIOD_PMD, PMD0~PMD5 and PMD8~PMD13 are reserved.\nFor GPIOE_PMD, PMD0~PMD4 and PMD6~PMD15 are reserved.\nFor GPIOF_PMD, PMD2 ~ PMD15 are reserved.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [x] pin [n] is in INPUT mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [x] pin [n] is in OUTPUT mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [x] pin [n] is in Open-Drain mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD9</name>
              <description>GPIO Port [X] Pin [N] Mode Control\nDetermine the I/O type of GPIO port [x] pin [n]\nNote: \nFor GPIOC_PMD, PMD4~PMD5 and PMD12~PMD13 are reserved.\nFor GPIOD_PMD, PMD0~PMD5 and PMD8~PMD13 are reserved.\nFor GPIOE_PMD, PMD0~PMD4 and PMD6~PMD15 are reserved.\nFor GPIOF_PMD, PMD2 ~ PMD15 are reserved.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [x] pin [n] is in INPUT mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [x] pin [n] is in OUTPUT mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [x] pin [n] is in Open-Drain mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD10</name>
              <description>GPIO Port [X] Pin [N] Mode Control\nDetermine the I/O type of GPIO port [x] pin [n]\nNote: \nFor GPIOC_PMD, PMD4~PMD5 and PMD12~PMD13 are reserved.\nFor GPIOD_PMD, PMD0~PMD5 and PMD8~PMD13 are reserved.\nFor GPIOE_PMD, PMD0~PMD4 and PMD6~PMD15 are reserved.\nFor GPIOF_PMD, PMD2 ~ PMD15 are reserved.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [x] pin [n] is in INPUT mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [x] pin [n] is in OUTPUT mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [x] pin [n] is in Open-Drain mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD11</name>
              <description>GPIO Port [X] Pin [N] Mode Control\nDetermine the I/O type of GPIO port [x] pin [n]\nNote: \nFor GPIOC_PMD, PMD4~PMD5 and PMD12~PMD13 are reserved.\nFor GPIOD_PMD, PMD0~PMD5 and PMD8~PMD13 are reserved.\nFor GPIOE_PMD, PMD0~PMD4 and PMD6~PMD15 are reserved.\nFor GPIOF_PMD, PMD2 ~ PMD15 are reserved.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [x] pin [n] is in INPUT mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [x] pin [n] is in OUTPUT mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [x] pin [n] is in Open-Drain mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD12</name>
              <description>GPIO Port [X] Pin [N] Mode Control\nDetermine the I/O type of GPIO port [x] pin [n]\nNote: \nFor GPIOC_PMD, PMD4~PMD5 and PMD12~PMD13 are reserved.\nFor GPIOD_PMD, PMD0~PMD5 and PMD8~PMD13 are reserved.\nFor GPIOE_PMD, PMD0~PMD4 and PMD6~PMD15 are reserved.\nFor GPIOF_PMD, PMD2 ~ PMD15 are reserved.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [x] pin [n] is in INPUT mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [x] pin [n] is in OUTPUT mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [x] pin [n] is in Open-Drain mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD13</name>
              <description>GPIO Port [X] Pin [N] Mode Control\nDetermine the I/O type of GPIO port [x] pin [n]\nNote: \nFor GPIOC_PMD, PMD4~PMD5 and PMD12~PMD13 are reserved.\nFor GPIOD_PMD, PMD0~PMD5 and PMD8~PMD13 are reserved.\nFor GPIOE_PMD, PMD0~PMD4 and PMD6~PMD15 are reserved.\nFor GPIOF_PMD, PMD2 ~ PMD15 are reserved.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [x] pin [n] is in INPUT mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [x] pin [n] is in OUTPUT mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [x] pin [n] is in Open-Drain mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD14</name>
              <description>GPIO Port [X] Pin [N] Mode Control\nDetermine the I/O type of GPIO port [x] pin [n]\nNote: \nFor GPIOC_PMD, PMD4~PMD5 and PMD12~PMD13 are reserved.\nFor GPIOD_PMD, PMD0~PMD5 and PMD8~PMD13 are reserved.\nFor GPIOE_PMD, PMD0~PMD4 and PMD6~PMD15 are reserved.\nFor GPIOF_PMD, PMD2 ~ PMD15 are reserved.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [x] pin [n] is in INPUT mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [x] pin [n] is in OUTPUT mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [x] pin [n] is in Open-Drain mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD15</name>
              <description>GPIO Port [X] Pin [N] Mode Control\nDetermine the I/O type of GPIO port [x] pin [n]\nNote: \nFor GPIOC_PMD, PMD4~PMD5 and PMD12~PMD13 are reserved.\nFor GPIOD_PMD, PMD0~PMD5 and PMD8~PMD13 are reserved.\nFor GPIOE_PMD, PMD0~PMD4 and PMD6~PMD15 are reserved.\nFor GPIOF_PMD, PMD2 ~ PMD15 are reserved.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [x] pin [n] is in INPUT mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [x] pin [n] is in OUTPUT mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [x] pin [n] is in Open-Drain mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPIOA_OFFD</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPIOA_OFFD</displayName>
          <description>GPIO Port A Pin OFF Digital Enable Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OFFD0</name>
              <description>GPIO Port [X] Pin [N] Digital Input Path Disable\nDetermine if the digital input path of GPIO port [x] pin [n] is disabled.\nNote: \nFor GPIOC_OFFD, bits [21:20] and [29:28] are reserved.\nFor GPIOD_OFFD, bits [21:16] and [29:24] are reserved.\nFor GPIOE_OFFD, bits [20:16] and [31:22] are reserved.\nFor GPIOF_OFFD, bits [31:18] are reserved.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>digital input path of GPIO port [x] pin [n] Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>digital input path of GPIO port [x] pin [n] Disabled (tied digital input to low)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>OFFD1</name>
              <description>GPIO Port [X] Pin [N] Digital Input Path Disable\nDetermine if the digital input path of GPIO port [x] pin [n] is disabled.\nNote: \nFor GPIOC_OFFD, bits [21:20] and [29:28] are reserved.\nFor GPIOD_OFFD, bits [21:16] and [29:24] are reserved.\nFor GPIOE_OFFD, bits [20:16] and [31:22] are reserved.\nFor GPIOF_OFFD, bits [31:18] are reserved.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>digital input path of GPIO port [x] pin [n] Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>digital input path of GPIO port [x] pin [n] Disabled (tied digital input to low)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>OFFD2</name>
              <description>GPIO Port [X] Pin [N] Digital Input Path Disable\nDetermine if the digital input path of GPIO port [x] pin [n] is disabled.\nNote: \nFor GPIOC_OFFD, bits [21:20] and [29:28] are reserved.\nFor GPIOD_OFFD, bits [21:16] and [29:24] are reserved.\nFor GPIOE_OFFD, bits [20:16] and [31:22] are reserved.\nFor GPIOF_OFFD, bits [31:18] are reserved.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>digital input path of GPIO port [x] pin [n] Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>digital input path of GPIO port [x] pin [n] Disabled (tied digital input to low)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>OFFD3</name>
              <description>GPIO Port [X] Pin [N] Digital Input Path Disable\nDetermine if the digital input path of GPIO port [x] pin [n] is disabled.\nNote: \nFor GPIOC_OFFD, bits [21:20] and [29:28] are reserved.\nFor GPIOD_OFFD, bits [21:16] and [29:24] are reserved.\nFor GPIOE_OFFD, bits [20:16] and [31:22] are reserved.\nFor GPIOF_OFFD, bits [31:18] are reserved.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>digital input path of GPIO port [x] pin [n] Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>digital input path of GPIO port [x] pin [n] Disabled (tied digital input to low)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>OFFD4</name>
              <description>GPIO Port [X] Pin [N] Digital Input Path Disable\nDetermine if the digital input path of GPIO port [x] pin [n] is disabled.\nNote: \nFor GPIOC_OFFD, bits [21:20] and [29:28] are reserved.\nFor GPIOD_OFFD, bits [21:16] and [29:24] are reserved.\nFor GPIOE_OFFD, bits [20:16] and [31:22] are reserved.\nFor GPIOF_OFFD, bits [31:18] are reserved.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>digital input path of GPIO port [x] pin [n] Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>digital input path of GPIO port [x] pin [n] Disabled (tied digital input to low)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>OFFD5</name>
              <description>GPIO Port [X] Pin [N] Digital Input Path Disable\nDetermine if the digital input path of GPIO port [x] pin [n] is disabled.\nNote: \nFor GPIOC_OFFD, bits [21:20] and [29:28] are reserved.\nFor GPIOD_OFFD, bits [21:16] and [29:24] are reserved.\nFor GPIOE_OFFD, bits [20:16] and [31:22] are reserved.\nFor GPIOF_OFFD, bits [31:18] are reserved.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>digital input path of GPIO port [x] pin [n] Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>digital input path of GPIO port [x] pin [n] Disabled (tied digital input to low)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>OFFD6</name>
              <description>GPIO Port [X] Pin [N] Digital Input Path Disable\nDetermine if the digital input path of GPIO port [x] pin [n] is disabled.\nNote: \nFor GPIOC_OFFD, bits [21:20] and [29:28] are reserved.\nFor GPIOD_OFFD, bits [21:16] and [29:24] are reserved.\nFor GPIOE_OFFD, bits [20:16] and [31:22] are reserved.\nFor GPIOF_OFFD, bits [31:18] are reserved.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>digital input path of GPIO port [x] pin [n] Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>digital input path of GPIO port [x] pin [n] Disabled (tied digital input to low)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>OFFD7</name>
              <description>GPIO Port [X] Pin [N] Digital Input Path Disable\nDetermine if the digital input path of GPIO port [x] pin [n] is disabled.\nNote: \nFor GPIOC_OFFD, bits [21:20] and [29:28] are reserved.\nFor GPIOD_OFFD, bits [21:16] and [29:24] are reserved.\nFor GPIOE_OFFD, bits [20:16] and [31:22] are reserved.\nFor GPIOF_OFFD, bits [31:18] are reserved.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>digital input path of GPIO port [x] pin [n] Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>digital input path of GPIO port [x] pin [n] Disabled (tied digital input to low)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>OFFD8</name>
              <description>GPIO Port [X] Pin [N] Digital Input Path Disable\nDetermine if the digital input path of GPIO port [x] pin [n] is disabled.\nNote: \nFor GPIOC_OFFD, bits [21:20] and [29:28] are reserved.\nFor GPIOD_OFFD, bits [21:16] and [29:24] are reserved.\nFor GPIOE_OFFD, bits [20:16] and [31:22] are reserved.\nFor GPIOF_OFFD, bits [31:18] are reserved.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>digital input path of GPIO port [x] pin [n] Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>digital input path of GPIO port [x] pin [n] Disabled (tied digital input to low)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>OFFD9</name>
              <description>GPIO Port [X] Pin [N] Digital Input Path Disable\nDetermine if the digital input path of GPIO port [x] pin [n] is disabled.\nNote: \nFor GPIOC_OFFD, bits [21:20] and [29:28] are reserved.\nFor GPIOD_OFFD, bits [21:16] and [29:24] are reserved.\nFor GPIOE_OFFD, bits [20:16] and [31:22] are reserved.\nFor GPIOF_OFFD, bits [31:18] are reserved.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>digital input path of GPIO port [x] pin [n] Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>digital input path of GPIO port [x] pin [n] Disabled (tied digital input to low)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>OFFD10</name>
              <description>GPIO Port [X] Pin [N] Digital Input Path Disable\nDetermine if the digital input path of GPIO port [x] pin [n] is disabled.\nNote: \nFor GPIOC_OFFD, bits [21:20] and [29:28] are reserved.\nFor GPIOD_OFFD, bits [21:16] and [29:24] are reserved.\nFor GPIOE_OFFD, bits [20:16] and [31:22] are reserved.\nFor GPIOF_OFFD, bits [31:18] are reserved.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>digital input path of GPIO port [x] pin [n] Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>digital input path of GPIO port [x] pin [n] Disabled (tied digital input to low)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>OFFD11</name>
              <description>GPIO Port [X] Pin [N] Digital Input Path Disable\nDetermine if the digital input path of GPIO port [x] pin [n] is disabled.\nNote: \nFor GPIOC_OFFD, bits [21:20] and [29:28] are reserved.\nFor GPIOD_OFFD, bits [21:16] and [29:24] are reserved.\nFor GPIOE_OFFD, bits [20:16] and [31:22] are reserved.\nFor GPIOF_OFFD, bits [31:18] are reserved.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>digital input path of GPIO port [x] pin [n] Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>digital input path of GPIO port [x] pin [n] Disabled (tied digital input to low)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>OFFD12</name>
              <description>GPIO Port [X] Pin [N] Digital Input Path Disable\nDetermine if the digital input path of GPIO port [x] pin [n] is disabled.\nNote: \nFor GPIOC_OFFD, bits [21:20] and [29:28] are reserved.\nFor GPIOD_OFFD, bits [21:16] and [29:24] are reserved.\nFor GPIOE_OFFD, bits [20:16] and [31:22] are reserved.\nFor GPIOF_OFFD, bits [31:18] are reserved.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>digital input path of GPIO port [x] pin [n] Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>digital input path of GPIO port [x] pin [n] Disabled (tied digital input to low)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>OFFD13</name>
              <description>GPIO Port [X] Pin [N] Digital Input Path Disable\nDetermine if the digital input path of GPIO port [x] pin [n] is disabled.\nNote: \nFor GPIOC_OFFD, bits [21:20] and [29:28] are reserved.\nFor GPIOD_OFFD, bits [21:16] and [29:24] are reserved.\nFor GPIOE_OFFD, bits [20:16] and [31:22] are reserved.\nFor GPIOF_OFFD, bits [31:18] are reserved.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>digital input path of GPIO port [x] pin [n] Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>digital input path of GPIO port [x] pin [n] Disabled (tied digital input to low)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>OFFD14</name>
              <description>GPIO Port [X] Pin [N] Digital Input Path Disable\nDetermine if the digital input path of GPIO port [x] pin [n] is disabled.\nNote: \nFor GPIOC_OFFD, bits [21:20] and [29:28] are reserved.\nFor GPIOD_OFFD, bits [21:16] and [29:24] are reserved.\nFor GPIOE_OFFD, bits [20:16] and [31:22] are reserved.\nFor GPIOF_OFFD, bits [31:18] are reserved.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>digital input path of GPIO port [x] pin [n] Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>digital input path of GPIO port [x] pin [n] Disabled (tied digital input to low)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>OFFD15</name>
              <description>GPIO Port [X] Pin [N] Digital Input Path Disable\nDetermine if the digital input path of GPIO port [x] pin [n] is disabled.\nNote: \nFor GPIOC_OFFD, bits [21:20] and [29:28] are reserved.\nFor GPIOD_OFFD, bits [21:16] and [29:24] are reserved.\nFor GPIOE_OFFD, bits [20:16] and [31:22] are reserved.\nFor GPIOF_OFFD, bits [31:18] are reserved.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>digital input path of GPIO port [x] pin [n] Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>digital input path of GPIO port [x] pin [n] Disabled (tied digital input to low)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPIOA_DOUT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPIOA_DOUT</displayName>
          <description>GPIO Port A Data Output Value Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x0000FFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DOUT0</name>
              <description>GPIO Port [X] Pin [N] Output Value\nEach of these bits controls the status of a GPIO port [x] pin [n] when the GPIO pin is configures as output or open-drain mode\nNote: \nFor GPIOC_OFFD, bits [5:4] and [13:12] are reserved.\nFor GPIOD_OFFD, bits [5:0] and [13:8] are reserved.\nFor GPIOE_OFFD, bits [4:0] and [15:6] are reserved.\nFor GPIOF_DOUT, bits [15:2] are reserved.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [x] Pin [n] will drive Low if the corresponding output mode enabling bit is set</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [x] Pin [n] will drive High if the corresponding output mode enabling bit is set</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT1</name>
              <description>GPIO Port [X] Pin [N] Output Value\nEach of these bits controls the status of a GPIO port [x] pin [n] when the GPIO pin is configures as output or open-drain mode\nNote: \nFor GPIOC_OFFD, bits [5:4] and [13:12] are reserved.\nFor GPIOD_OFFD, bits [5:0] and [13:8] are reserved.\nFor GPIOE_OFFD, bits [4:0] and [15:6] are reserved.\nFor GPIOF_DOUT, bits [15:2] are reserved.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [x] Pin [n] will drive Low if the corresponding output mode enabling bit is set</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [x] Pin [n] will drive High if the corresponding output mode enabling bit is set</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT2</name>
              <description>GPIO Port [X] Pin [N] Output Value\nEach of these bits controls the status of a GPIO port [x] pin [n] when the GPIO pin is configures as output or open-drain mode\nNote: \nFor GPIOC_OFFD, bits [5:4] and [13:12] are reserved.\nFor GPIOD_OFFD, bits [5:0] and [13:8] are reserved.\nFor GPIOE_OFFD, bits [4:0] and [15:6] are reserved.\nFor GPIOF_DOUT, bits [15:2] are reserved.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [x] Pin [n] will drive Low if the corresponding output mode enabling bit is set</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [x] Pin [n] will drive High if the corresponding output mode enabling bit is set</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT3</name>
              <description>GPIO Port [X] Pin [N] Output Value\nEach of these bits controls the status of a GPIO port [x] pin [n] when the GPIO pin is configures as output or open-drain mode\nNote: \nFor GPIOC_OFFD, bits [5:4] and [13:12] are reserved.\nFor GPIOD_OFFD, bits [5:0] and [13:8] are reserved.\nFor GPIOE_OFFD, bits [4:0] and [15:6] are reserved.\nFor GPIOF_DOUT, bits [15:2] are reserved.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [x] Pin [n] will drive Low if the corresponding output mode enabling bit is set</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [x] Pin [n] will drive High if the corresponding output mode enabling bit is set</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT4</name>
              <description>GPIO Port [X] Pin [N] Output Value\nEach of these bits controls the status of a GPIO port [x] pin [n] when the GPIO pin is configures as output or open-drain mode\nNote: \nFor GPIOC_OFFD, bits [5:4] and [13:12] are reserved.\nFor GPIOD_OFFD, bits [5:0] and [13:8] are reserved.\nFor GPIOE_OFFD, bits [4:0] and [15:6] are reserved.\nFor GPIOF_DOUT, bits [15:2] are reserved.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [x] Pin [n] will drive Low if the corresponding output mode enabling bit is set</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [x] Pin [n] will drive High if the corresponding output mode enabling bit is set</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT5</name>
              <description>GPIO Port [X] Pin [N] Output Value\nEach of these bits controls the status of a GPIO port [x] pin [n] when the GPIO pin is configures as output or open-drain mode\nNote: \nFor GPIOC_OFFD, bits [5:4] and [13:12] are reserved.\nFor GPIOD_OFFD, bits [5:0] and [13:8] are reserved.\nFor GPIOE_OFFD, bits [4:0] and [15:6] are reserved.\nFor GPIOF_DOUT, bits [15:2] are reserved.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [x] Pin [n] will drive Low if the corresponding output mode enabling bit is set</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [x] Pin [n] will drive High if the corresponding output mode enabling bit is set</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT6</name>
              <description>GPIO Port [X] Pin [N] Output Value\nEach of these bits controls the status of a GPIO port [x] pin [n] when the GPIO pin is configures as output or open-drain mode\nNote: \nFor GPIOC_OFFD, bits [5:4] and [13:12] are reserved.\nFor GPIOD_OFFD, bits [5:0] and [13:8] are reserved.\nFor GPIOE_OFFD, bits [4:0] and [15:6] are reserved.\nFor GPIOF_DOUT, bits [15:2] are reserved.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [x] Pin [n] will drive Low if the corresponding output mode enabling bit is set</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [x] Pin [n] will drive High if the corresponding output mode enabling bit is set</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT7</name>
              <description>GPIO Port [X] Pin [N] Output Value\nEach of these bits controls the status of a GPIO port [x] pin [n] when the GPIO pin is configures as output or open-drain mode\nNote: \nFor GPIOC_OFFD, bits [5:4] and [13:12] are reserved.\nFor GPIOD_OFFD, bits [5:0] and [13:8] are reserved.\nFor GPIOE_OFFD, bits [4:0] and [15:6] are reserved.\nFor GPIOF_DOUT, bits [15:2] are reserved.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [x] Pin [n] will drive Low if the corresponding output mode enabling bit is set</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [x] Pin [n] will drive High if the corresponding output mode enabling bit is set</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT8</name>
              <description>GPIO Port [X] Pin [N] Output Value\nEach of these bits controls the status of a GPIO port [x] pin [n] when the GPIO pin is configures as output or open-drain mode\nNote: \nFor GPIOC_OFFD, bits [5:4] and [13:12] are reserved.\nFor GPIOD_OFFD, bits [5:0] and [13:8] are reserved.\nFor GPIOE_OFFD, bits [4:0] and [15:6] are reserved.\nFor GPIOF_DOUT, bits [15:2] are reserved.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [x] Pin [n] will drive Low if the corresponding output mode enabling bit is set</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [x] Pin [n] will drive High if the corresponding output mode enabling bit is set</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT9</name>
              <description>GPIO Port [X] Pin [N] Output Value\nEach of these bits controls the status of a GPIO port [x] pin [n] when the GPIO pin is configures as output or open-drain mode\nNote: \nFor GPIOC_OFFD, bits [5:4] and [13:12] are reserved.\nFor GPIOD_OFFD, bits [5:0] and [13:8] are reserved.\nFor GPIOE_OFFD, bits [4:0] and [15:6] are reserved.\nFor GPIOF_DOUT, bits [15:2] are reserved.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [x] Pin [n] will drive Low if the corresponding output mode enabling bit is set</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [x] Pin [n] will drive High if the corresponding output mode enabling bit is set</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT10</name>
              <description>GPIO Port [X] Pin [N] Output Value\nEach of these bits controls the status of a GPIO port [x] pin [n] when the GPIO pin is configures as output or open-drain mode\nNote: \nFor GPIOC_OFFD, bits [5:4] and [13:12] are reserved.\nFor GPIOD_OFFD, bits [5:0] and [13:8] are reserved.\nFor GPIOE_OFFD, bits [4:0] and [15:6] are reserved.\nFor GPIOF_DOUT, bits [15:2] are reserved.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [x] Pin [n] will drive Low if the corresponding output mode enabling bit is set</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [x] Pin [n] will drive High if the corresponding output mode enabling bit is set</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT11</name>
              <description>GPIO Port [X] Pin [N] Output Value\nEach of these bits controls the status of a GPIO port [x] pin [n] when the GPIO pin is configures as output or open-drain mode\nNote: \nFor GPIOC_OFFD, bits [5:4] and [13:12] are reserved.\nFor GPIOD_OFFD, bits [5:0] and [13:8] are reserved.\nFor GPIOE_OFFD, bits [4:0] and [15:6] are reserved.\nFor GPIOF_DOUT, bits [15:2] are reserved.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [x] Pin [n] will drive Low if the corresponding output mode enabling bit is set</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [x] Pin [n] will drive High if the corresponding output mode enabling bit is set</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT12</name>
              <description>GPIO Port [X] Pin [N] Output Value\nEach of these bits controls the status of a GPIO port [x] pin [n] when the GPIO pin is configures as output or open-drain mode\nNote: \nFor GPIOC_OFFD, bits [5:4] and [13:12] are reserved.\nFor GPIOD_OFFD, bits [5:0] and [13:8] are reserved.\nFor GPIOE_OFFD, bits [4:0] and [15:6] are reserved.\nFor GPIOF_DOUT, bits [15:2] are reserved.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [x] Pin [n] will drive Low if the corresponding output mode enabling bit is set</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [x] Pin [n] will drive High if the corresponding output mode enabling bit is set</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT13</name>
              <description>GPIO Port [X] Pin [N] Output Value\nEach of these bits controls the status of a GPIO port [x] pin [n] when the GPIO pin is configures as output or open-drain mode\nNote: \nFor GPIOC_OFFD, bits [5:4] and [13:12] are reserved.\nFor GPIOD_OFFD, bits [5:0] and [13:8] are reserved.\nFor GPIOE_OFFD, bits [4:0] and [15:6] are reserved.\nFor GPIOF_DOUT, bits [15:2] are reserved.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [x] Pin [n] will drive Low if the corresponding output mode enabling bit is set</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [x] Pin [n] will drive High if the corresponding output mode enabling bit is set</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT14</name>
              <description>GPIO Port [X] Pin [N] Output Value\nEach of these bits controls the status of a GPIO port [x] pin [n] when the GPIO pin is configures as output or open-drain mode\nNote: \nFor GPIOC_OFFD, bits [5:4] and [13:12] are reserved.\nFor GPIOD_OFFD, bits [5:0] and [13:8] are reserved.\nFor GPIOE_OFFD, bits [4:0] and [15:6] are reserved.\nFor GPIOF_DOUT, bits [15:2] are reserved.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [x] Pin [n] will drive Low if the corresponding output mode enabling bit is set</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [x] Pin [n] will drive High if the corresponding output mode enabling bit is set</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT15</name>
              <description>GPIO Port [X] Pin [N] Output Value\nEach of these bits controls the status of a GPIO port [x] pin [n] when the GPIO pin is configures as output or open-drain mode\nNote: \nFor GPIOC_OFFD, bits [5:4] and [13:12] are reserved.\nFor GPIOD_OFFD, bits [5:0] and [13:8] are reserved.\nFor GPIOE_OFFD, bits [4:0] and [15:6] are reserved.\nFor GPIOF_DOUT, bits [15:2] are reserved.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [x] Pin [n] will drive Low if the corresponding output mode enabling bit is set</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [x] Pin [n] will drive High if the corresponding output mode enabling bit is set</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPIOA_DMASK</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPIOA_DMASK</displayName>
          <description>GPIO Port A Data Output Write Mask Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMASK0</name>
              <description>GPIO Port [X] Pin [N] Data Output Write Mask\nThese bits are used to protect the corresponding register of GPIOx_DOUT bit [n]. When set the DMASK[n] to "1", the corresponding DOUT[n] bit is protected. The write signal is masked, write data to the protect bit is ignored\nNote: For GPIOF_DMASK, bits [15:6] are reserved.\nNote: These mask bits only take effect while CPU is doing write operation to register GPIOx_DOUT. If CPU is doing write operation to register GPIO[x][n], these mask bits will not take effect.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>the corresponding GPIO_DOUT bit [n] can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>the corresponding GPIO_DOUT bit [n] is protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK1</name>
              <description>GPIO Port [X] Pin [N] Data Output Write Mask\nThese bits are used to protect the corresponding register of GPIOx_DOUT bit [n]. When set the DMASK[n] to "1", the corresponding DOUT[n] bit is protected. The write signal is masked, write data to the protect bit is ignored\nNote: For GPIOF_DMASK, bits [15:6] are reserved.\nNote: These mask bits only take effect while CPU is doing write operation to register GPIOx_DOUT. If CPU is doing write operation to register GPIO[x][n], these mask bits will not take effect.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>the corresponding GPIO_DOUT bit [n] can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>the corresponding GPIO_DOUT bit [n] is protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK2</name>
              <description>GPIO Port [X] Pin [N] Data Output Write Mask\nThese bits are used to protect the corresponding register of GPIOx_DOUT bit [n]. When set the DMASK[n] to "1", the corresponding DOUT[n] bit is protected. The write signal is masked, write data to the protect bit is ignored\nNote: For GPIOF_DMASK, bits [15:6] are reserved.\nNote: These mask bits only take effect while CPU is doing write operation to register GPIOx_DOUT. If CPU is doing write operation to register GPIO[x][n], these mask bits will not take effect.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>the corresponding GPIO_DOUT bit [n] can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>the corresponding GPIO_DOUT bit [n] is protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK3</name>
              <description>GPIO Port [X] Pin [N] Data Output Write Mask\nThese bits are used to protect the corresponding register of GPIOx_DOUT bit [n]. When set the DMASK[n] to "1", the corresponding DOUT[n] bit is protected. The write signal is masked, write data to the protect bit is ignored\nNote: For GPIOF_DMASK, bits [15:6] are reserved.\nNote: These mask bits only take effect while CPU is doing write operation to register GPIOx_DOUT. If CPU is doing write operation to register GPIO[x][n], these mask bits will not take effect.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>the corresponding GPIO_DOUT bit [n] can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>the corresponding GPIO_DOUT bit [n] is protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK4</name>
              <description>GPIO Port [X] Pin [N] Data Output Write Mask\nThese bits are used to protect the corresponding register of GPIOx_DOUT bit [n]. When set the DMASK[n] to "1", the corresponding DOUT[n] bit is protected. The write signal is masked, write data to the protect bit is ignored\nNote: For GPIOF_DMASK, bits [15:6] are reserved.\nNote: These mask bits only take effect while CPU is doing write operation to register GPIOx_DOUT. If CPU is doing write operation to register GPIO[x][n], these mask bits will not take effect.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>the corresponding GPIO_DOUT bit [n] can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>the corresponding GPIO_DOUT bit [n] is protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK5</name>
              <description>GPIO Port [X] Pin [N] Data Output Write Mask\nThese bits are used to protect the corresponding register of GPIOx_DOUT bit [n]. When set the DMASK[n] to "1", the corresponding DOUT[n] bit is protected. The write signal is masked, write data to the protect bit is ignored\nNote: For GPIOF_DMASK, bits [15:6] are reserved.\nNote: These mask bits only take effect while CPU is doing write operation to register GPIOx_DOUT. If CPU is doing write operation to register GPIO[x][n], these mask bits will not take effect.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>the corresponding GPIO_DOUT bit [n] can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>the corresponding GPIO_DOUT bit [n] is protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK6</name>
              <description>GPIO Port [X] Pin [N] Data Output Write Mask\nThese bits are used to protect the corresponding register of GPIOx_DOUT bit [n]. When set the DMASK[n] to "1", the corresponding DOUT[n] bit is protected. The write signal is masked, write data to the protect bit is ignored\nNote: For GPIOF_DMASK, bits [15:6] are reserved.\nNote: These mask bits only take effect while CPU is doing write operation to register GPIOx_DOUT. If CPU is doing write operation to register GPIO[x][n], these mask bits will not take effect.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>the corresponding GPIO_DOUT bit [n] can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>the corresponding GPIO_DOUT bit [n] is protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK7</name>
              <description>GPIO Port [X] Pin [N] Data Output Write Mask\nThese bits are used to protect the corresponding register of GPIOx_DOUT bit [n]. When set the DMASK[n] to "1", the corresponding DOUT[n] bit is protected. The write signal is masked, write data to the protect bit is ignored\nNote: For GPIOF_DMASK, bits [15:6] are reserved.\nNote: These mask bits only take effect while CPU is doing write operation to register GPIOx_DOUT. If CPU is doing write operation to register GPIO[x][n], these mask bits will not take effect.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>the corresponding GPIO_DOUT bit [n] can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>the corresponding GPIO_DOUT bit [n] is protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK8</name>
              <description>GPIO Port [X] Pin [N] Data Output Write Mask\nThese bits are used to protect the corresponding register of GPIOx_DOUT bit [n]. When set the DMASK[n] to "1", the corresponding DOUT[n] bit is protected. The write signal is masked, write data to the protect bit is ignored\nNote: For GPIOF_DMASK, bits [15:6] are reserved.\nNote: These mask bits only take effect while CPU is doing write operation to register GPIOx_DOUT. If CPU is doing write operation to register GPIO[x][n], these mask bits will not take effect.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>the corresponding GPIO_DOUT bit [n] can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>the corresponding GPIO_DOUT bit [n] is protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK9</name>
              <description>GPIO Port [X] Pin [N] Data Output Write Mask\nThese bits are used to protect the corresponding register of GPIOx_DOUT bit [n]. When set the DMASK[n] to "1", the corresponding DOUT[n] bit is protected. The write signal is masked, write data to the protect bit is ignored\nNote: For GPIOF_DMASK, bits [15:6] are reserved.\nNote: These mask bits only take effect while CPU is doing write operation to register GPIOx_DOUT. If CPU is doing write operation to register GPIO[x][n], these mask bits will not take effect.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>the corresponding GPIO_DOUT bit [n] can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>the corresponding GPIO_DOUT bit [n] is protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK10</name>
              <description>GPIO Port [X] Pin [N] Data Output Write Mask\nThese bits are used to protect the corresponding register of GPIOx_DOUT bit [n]. When set the DMASK[n] to "1", the corresponding DOUT[n] bit is protected. The write signal is masked, write data to the protect bit is ignored\nNote: For GPIOF_DMASK, bits [15:6] are reserved.\nNote: These mask bits only take effect while CPU is doing write operation to register GPIOx_DOUT. If CPU is doing write operation to register GPIO[x][n], these mask bits will not take effect.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>the corresponding GPIO_DOUT bit [n] can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>the corresponding GPIO_DOUT bit [n] is protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK11</name>
              <description>GPIO Port [X] Pin [N] Data Output Write Mask\nThese bits are used to protect the corresponding register of GPIOx_DOUT bit [n]. When set the DMASK[n] to "1", the corresponding DOUT[n] bit is protected. The write signal is masked, write data to the protect bit is ignored\nNote: For GPIOF_DMASK, bits [15:6] are reserved.\nNote: These mask bits only take effect while CPU is doing write operation to register GPIOx_DOUT. If CPU is doing write operation to register GPIO[x][n], these mask bits will not take effect.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>the corresponding GPIO_DOUT bit [n] can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>the corresponding GPIO_DOUT bit [n] is protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK12</name>
              <description>GPIO Port [X] Pin [N] Data Output Write Mask\nThese bits are used to protect the corresponding register of GPIOx_DOUT bit [n]. When set the DMASK[n] to "1", the corresponding DOUT[n] bit is protected. The write signal is masked, write data to the protect bit is ignored\nNote: For GPIOF_DMASK, bits [15:6] are reserved.\nNote: These mask bits only take effect while CPU is doing write operation to register GPIOx_DOUT. If CPU is doing write operation to register GPIO[x][n], these mask bits will not take effect.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>the corresponding GPIO_DOUT bit [n] can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>the corresponding GPIO_DOUT bit [n] is protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK13</name>
              <description>GPIO Port [X] Pin [N] Data Output Write Mask\nThese bits are used to protect the corresponding register of GPIOx_DOUT bit [n]. When set the DMASK[n] to "1", the corresponding DOUT[n] bit is protected. The write signal is masked, write data to the protect bit is ignored\nNote: For GPIOF_DMASK, bits [15:6] are reserved.\nNote: These mask bits only take effect while CPU is doing write operation to register GPIOx_DOUT. If CPU is doing write operation to register GPIO[x][n], these mask bits will not take effect.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>the corresponding GPIO_DOUT bit [n] can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>the corresponding GPIO_DOUT bit [n] is protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK14</name>
              <description>GPIO Port [X] Pin [N] Data Output Write Mask\nThese bits are used to protect the corresponding register of GPIOx_DOUT bit [n]. When set the DMASK[n] to "1", the corresponding DOUT[n] bit is protected. The write signal is masked, write data to the protect bit is ignored\nNote: For GPIOF_DMASK, bits [15:6] are reserved.\nNote: These mask bits only take effect while CPU is doing write operation to register GPIOx_DOUT. If CPU is doing write operation to register GPIO[x][n], these mask bits will not take effect.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>the corresponding GPIO_DOUT bit [n] can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>the corresponding GPIO_DOUT bit [n] is protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK15</name>
              <description>GPIO Port [X] Pin [N] Data Output Write Mask\nThese bits are used to protect the corresponding register of GPIOx_DOUT bit [n]. When set the DMASK[n] to "1", the corresponding DOUT[n] bit is protected. The write signal is masked, write data to the protect bit is ignored\nNote: For GPIOF_DMASK, bits [15:6] are reserved.\nNote: These mask bits only take effect while CPU is doing write operation to register GPIOx_DOUT. If CPU is doing write operation to register GPIO[x][n], these mask bits will not take effect.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>the corresponding GPIO_DOUT bit [n] can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>the corresponding GPIO_DOUT bit [n] is protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPIOA_PIN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPIOA_PIN</displayName>
          <description>GPIO Port A Pin Value Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFF0000</resetMask>
          <fields>
            <field>
              <name>PIN0</name>
              <description>GPIO Port [X] Pin [N] Value\nThe value read from each of these bit reflects the actual status of the respective GPIO pin\nNote: \nFor GPIOC_PIN, bits [5:4] and [13:12] are reserved.\nFor GPIOD_PIN, bits [5:0] and [13:8] are reserved.\nFor GPIOE_PIN, bits [4:0] and [15:6] are reserved.\nFor GPIOF_PIN, bits [15:2] are reserved.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN1</name>
              <description>GPIO Port [X] Pin [N] Value\nThe value read from each of these bit reflects the actual status of the respective GPIO pin\nNote: \nFor GPIOC_PIN, bits [5:4] and [13:12] are reserved.\nFor GPIOD_PIN, bits [5:0] and [13:8] are reserved.\nFor GPIOE_PIN, bits [4:0] and [15:6] are reserved.\nFor GPIOF_PIN, bits [15:2] are reserved.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN2</name>
              <description>GPIO Port [X] Pin [N] Value\nThe value read from each of these bit reflects the actual status of the respective GPIO pin\nNote: \nFor GPIOC_PIN, bits [5:4] and [13:12] are reserved.\nFor GPIOD_PIN, bits [5:0] and [13:8] are reserved.\nFor GPIOE_PIN, bits [4:0] and [15:6] are reserved.\nFor GPIOF_PIN, bits [15:2] are reserved.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN3</name>
              <description>GPIO Port [X] Pin [N] Value\nThe value read from each of these bit reflects the actual status of the respective GPIO pin\nNote: \nFor GPIOC_PIN, bits [5:4] and [13:12] are reserved.\nFor GPIOD_PIN, bits [5:0] and [13:8] are reserved.\nFor GPIOE_PIN, bits [4:0] and [15:6] are reserved.\nFor GPIOF_PIN, bits [15:2] are reserved.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN4</name>
              <description>GPIO Port [X] Pin [N] Value\nThe value read from each of these bit reflects the actual status of the respective GPIO pin\nNote: \nFor GPIOC_PIN, bits [5:4] and [13:12] are reserved.\nFor GPIOD_PIN, bits [5:0] and [13:8] are reserved.\nFor GPIOE_PIN, bits [4:0] and [15:6] are reserved.\nFor GPIOF_PIN, bits [15:2] are reserved.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN5</name>
              <description>GPIO Port [X] Pin [N] Value\nThe value read from each of these bit reflects the actual status of the respective GPIO pin\nNote: \nFor GPIOC_PIN, bits [5:4] and [13:12] are reserved.\nFor GPIOD_PIN, bits [5:0] and [13:8] are reserved.\nFor GPIOE_PIN, bits [4:0] and [15:6] are reserved.\nFor GPIOF_PIN, bits [15:2] are reserved.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN6</name>
              <description>GPIO Port [X] Pin [N] Value\nThe value read from each of these bit reflects the actual status of the respective GPIO pin\nNote: \nFor GPIOC_PIN, bits [5:4] and [13:12] are reserved.\nFor GPIOD_PIN, bits [5:0] and [13:8] are reserved.\nFor GPIOE_PIN, bits [4:0] and [15:6] are reserved.\nFor GPIOF_PIN, bits [15:2] are reserved.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN7</name>
              <description>GPIO Port [X] Pin [N] Value\nThe value read from each of these bit reflects the actual status of the respective GPIO pin\nNote: \nFor GPIOC_PIN, bits [5:4] and [13:12] are reserved.\nFor GPIOD_PIN, bits [5:0] and [13:8] are reserved.\nFor GPIOE_PIN, bits [4:0] and [15:6] are reserved.\nFor GPIOF_PIN, bits [15:2] are reserved.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN8</name>
              <description>GPIO Port [X] Pin [N] Value\nThe value read from each of these bit reflects the actual status of the respective GPIO pin\nNote: \nFor GPIOC_PIN, bits [5:4] and [13:12] are reserved.\nFor GPIOD_PIN, bits [5:0] and [13:8] are reserved.\nFor GPIOE_PIN, bits [4:0] and [15:6] are reserved.\nFor GPIOF_PIN, bits [15:2] are reserved.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN9</name>
              <description>GPIO Port [X] Pin [N] Value\nThe value read from each of these bit reflects the actual status of the respective GPIO pin\nNote: \nFor GPIOC_PIN, bits [5:4] and [13:12] are reserved.\nFor GPIOD_PIN, bits [5:0] and [13:8] are reserved.\nFor GPIOE_PIN, bits [4:0] and [15:6] are reserved.\nFor GPIOF_PIN, bits [15:2] are reserved.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN10</name>
              <description>GPIO Port [X] Pin [N] Value\nThe value read from each of these bit reflects the actual status of the respective GPIO pin\nNote: \nFor GPIOC_PIN, bits [5:4] and [13:12] are reserved.\nFor GPIOD_PIN, bits [5:0] and [13:8] are reserved.\nFor GPIOE_PIN, bits [4:0] and [15:6] are reserved.\nFor GPIOF_PIN, bits [15:2] are reserved.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN11</name>
              <description>GPIO Port [X] Pin [N] Value\nThe value read from each of these bit reflects the actual status of the respective GPIO pin\nNote: \nFor GPIOC_PIN, bits [5:4] and [13:12] are reserved.\nFor GPIOD_PIN, bits [5:0] and [13:8] are reserved.\nFor GPIOE_PIN, bits [4:0] and [15:6] are reserved.\nFor GPIOF_PIN, bits [15:2] are reserved.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN12</name>
              <description>GPIO Port [X] Pin [N] Value\nThe value read from each of these bit reflects the actual status of the respective GPIO pin\nNote: \nFor GPIOC_PIN, bits [5:4] and [13:12] are reserved.\nFor GPIOD_PIN, bits [5:0] and [13:8] are reserved.\nFor GPIOE_PIN, bits [4:0] and [15:6] are reserved.\nFor GPIOF_PIN, bits [15:2] are reserved.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN13</name>
              <description>GPIO Port [X] Pin [N] Value\nThe value read from each of these bit reflects the actual status of the respective GPIO pin\nNote: \nFor GPIOC_PIN, bits [5:4] and [13:12] are reserved.\nFor GPIOD_PIN, bits [5:0] and [13:8] are reserved.\nFor GPIOE_PIN, bits [4:0] and [15:6] are reserved.\nFor GPIOF_PIN, bits [15:2] are reserved.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN14</name>
              <description>GPIO Port [X] Pin [N] Value\nThe value read from each of these bit reflects the actual status of the respective GPIO pin\nNote: \nFor GPIOC_PIN, bits [5:4] and [13:12] are reserved.\nFor GPIOD_PIN, bits [5:0] and [13:8] are reserved.\nFor GPIOE_PIN, bits [4:0] and [15:6] are reserved.\nFor GPIOF_PIN, bits [15:2] are reserved.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN15</name>
              <description>GPIO Port [X] Pin [N] Value\nThe value read from each of these bit reflects the actual status of the respective GPIO pin\nNote: \nFor GPIOC_PIN, bits [5:4] and [13:12] are reserved.\nFor GPIOD_PIN, bits [5:0] and [13:8] are reserved.\nFor GPIOE_PIN, bits [4:0] and [15:6] are reserved.\nFor GPIOF_PIN, bits [15:2] are reserved.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPIOA_DBEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPIOA_DBEN</displayName>
          <description>GPIO Port A De-bounce Enable Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DBEN0</name>
              <description>GPIO Port [X] Pin [N] Input Signal De-Bounce Enable\nDBEN[n] used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle the input signal transition is seen as the signal bounce and will not trigger the interrupt.\nDBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt\nThe de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.\nNote: \nFor GPIOC_DBEN, bits [5:4] and [13:12] are reserved.\nFor GPIOD_DBEN, bits [5:0] and [13:8] are reserved.\nFor GPIOE_DBEN, bits [4:0] and [15:6] are reserved.\nFor GPIOF_DBEN, bits [15:2] are reserved.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The GPIO port [x] Pin [n] input signal de-bounce function is disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The GPIO port [x] Pin [n] input signal de-bounce function is enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN1</name>
              <description>GPIO Port [X] Pin [N] Input Signal De-Bounce Enable\nDBEN[n] used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle the input signal transition is seen as the signal bounce and will not trigger the interrupt.\nDBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt\nThe de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.\nNote: \nFor GPIOC_DBEN, bits [5:4] and [13:12] are reserved.\nFor GPIOD_DBEN, bits [5:0] and [13:8] are reserved.\nFor GPIOE_DBEN, bits [4:0] and [15:6] are reserved.\nFor GPIOF_DBEN, bits [15:2] are reserved.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The GPIO port [x] Pin [n] input signal de-bounce function is disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The GPIO port [x] Pin [n] input signal de-bounce function is enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN2</name>
              <description>GPIO Port [X] Pin [N] Input Signal De-Bounce Enable\nDBEN[n] used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle the input signal transition is seen as the signal bounce and will not trigger the interrupt.\nDBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt\nThe de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.\nNote: \nFor GPIOC_DBEN, bits [5:4] and [13:12] are reserved.\nFor GPIOD_DBEN, bits [5:0] and [13:8] are reserved.\nFor GPIOE_DBEN, bits [4:0] and [15:6] are reserved.\nFor GPIOF_DBEN, bits [15:2] are reserved.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The GPIO port [x] Pin [n] input signal de-bounce function is disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The GPIO port [x] Pin [n] input signal de-bounce function is enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN3</name>
              <description>GPIO Port [X] Pin [N] Input Signal De-Bounce Enable\nDBEN[n] used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle the input signal transition is seen as the signal bounce and will not trigger the interrupt.\nDBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt\nThe de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.\nNote: \nFor GPIOC_DBEN, bits [5:4] and [13:12] are reserved.\nFor GPIOD_DBEN, bits [5:0] and [13:8] are reserved.\nFor GPIOE_DBEN, bits [4:0] and [15:6] are reserved.\nFor GPIOF_DBEN, bits [15:2] are reserved.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The GPIO port [x] Pin [n] input signal de-bounce function is disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The GPIO port [x] Pin [n] input signal de-bounce function is enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN4</name>
              <description>GPIO Port [X] Pin [N] Input Signal De-Bounce Enable\nDBEN[n] used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle the input signal transition is seen as the signal bounce and will not trigger the interrupt.\nDBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt\nThe de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.\nNote: \nFor GPIOC_DBEN, bits [5:4] and [13:12] are reserved.\nFor GPIOD_DBEN, bits [5:0] and [13:8] are reserved.\nFor GPIOE_DBEN, bits [4:0] and [15:6] are reserved.\nFor GPIOF_DBEN, bits [15:2] are reserved.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The GPIO port [x] Pin [n] input signal de-bounce function is disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The GPIO port [x] Pin [n] input signal de-bounce function is enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN5</name>
              <description>GPIO Port [X] Pin [N] Input Signal De-Bounce Enable\nDBEN[n] used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle the input signal transition is seen as the signal bounce and will not trigger the interrupt.\nDBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt\nThe de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.\nNote: \nFor GPIOC_DBEN, bits [5:4] and [13:12] are reserved.\nFor GPIOD_DBEN, bits [5:0] and [13:8] are reserved.\nFor GPIOE_DBEN, bits [4:0] and [15:6] are reserved.\nFor GPIOF_DBEN, bits [15:2] are reserved.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The GPIO port [x] Pin [n] input signal de-bounce function is disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The GPIO port [x] Pin [n] input signal de-bounce function is enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN6</name>
              <description>GPIO Port [X] Pin [N] Input Signal De-Bounce Enable\nDBEN[n] used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle the input signal transition is seen as the signal bounce and will not trigger the interrupt.\nDBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt\nThe de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.\nNote: \nFor GPIOC_DBEN, bits [5:4] and [13:12] are reserved.\nFor GPIOD_DBEN, bits [5:0] and [13:8] are reserved.\nFor GPIOE_DBEN, bits [4:0] and [15:6] are reserved.\nFor GPIOF_DBEN, bits [15:2] are reserved.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The GPIO port [x] Pin [n] input signal de-bounce function is disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The GPIO port [x] Pin [n] input signal de-bounce function is enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN7</name>
              <description>GPIO Port [X] Pin [N] Input Signal De-Bounce Enable\nDBEN[n] used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle the input signal transition is seen as the signal bounce and will not trigger the interrupt.\nDBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt\nThe de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.\nNote: \nFor GPIOC_DBEN, bits [5:4] and [13:12] are reserved.\nFor GPIOD_DBEN, bits [5:0] and [13:8] are reserved.\nFor GPIOE_DBEN, bits [4:0] and [15:6] are reserved.\nFor GPIOF_DBEN, bits [15:2] are reserved.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The GPIO port [x] Pin [n] input signal de-bounce function is disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The GPIO port [x] Pin [n] input signal de-bounce function is enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN8</name>
              <description>GPIO Port [X] Pin [N] Input Signal De-Bounce Enable\nDBEN[n] used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle the input signal transition is seen as the signal bounce and will not trigger the interrupt.\nDBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt\nThe de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.\nNote: \nFor GPIOC_DBEN, bits [5:4] and [13:12] are reserved.\nFor GPIOD_DBEN, bits [5:0] and [13:8] are reserved.\nFor GPIOE_DBEN, bits [4:0] and [15:6] are reserved.\nFor GPIOF_DBEN, bits [15:2] are reserved.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The GPIO port [x] Pin [n] input signal de-bounce function is disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The GPIO port [x] Pin [n] input signal de-bounce function is enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN9</name>
              <description>GPIO Port [X] Pin [N] Input Signal De-Bounce Enable\nDBEN[n] used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle the input signal transition is seen as the signal bounce and will not trigger the interrupt.\nDBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt\nThe de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.\nNote: \nFor GPIOC_DBEN, bits [5:4] and [13:12] are reserved.\nFor GPIOD_DBEN, bits [5:0] and [13:8] are reserved.\nFor GPIOE_DBEN, bits [4:0] and [15:6] are reserved.\nFor GPIOF_DBEN, bits [15:2] are reserved.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The GPIO port [x] Pin [n] input signal de-bounce function is disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The GPIO port [x] Pin [n] input signal de-bounce function is enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN10</name>
              <description>GPIO Port [X] Pin [N] Input Signal De-Bounce Enable\nDBEN[n] used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle the input signal transition is seen as the signal bounce and will not trigger the interrupt.\nDBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt\nThe de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.\nNote: \nFor GPIOC_DBEN, bits [5:4] and [13:12] are reserved.\nFor GPIOD_DBEN, bits [5:0] and [13:8] are reserved.\nFor GPIOE_DBEN, bits [4:0] and [15:6] are reserved.\nFor GPIOF_DBEN, bits [15:2] are reserved.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The GPIO port [x] Pin [n] input signal de-bounce function is disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The GPIO port [x] Pin [n] input signal de-bounce function is enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN11</name>
              <description>GPIO Port [X] Pin [N] Input Signal De-Bounce Enable\nDBEN[n] used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle the input signal transition is seen as the signal bounce and will not trigger the interrupt.\nDBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt\nThe de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.\nNote: \nFor GPIOC_DBEN, bits [5:4] and [13:12] are reserved.\nFor GPIOD_DBEN, bits [5:0] and [13:8] are reserved.\nFor GPIOE_DBEN, bits [4:0] and [15:6] are reserved.\nFor GPIOF_DBEN, bits [15:2] are reserved.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The GPIO port [x] Pin [n] input signal de-bounce function is disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The GPIO port [x] Pin [n] input signal de-bounce function is enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN12</name>
              <description>GPIO Port [X] Pin [N] Input Signal De-Bounce Enable\nDBEN[n] used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle the input signal transition is seen as the signal bounce and will not trigger the interrupt.\nDBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt\nThe de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.\nNote: \nFor GPIOC_DBEN, bits [5:4] and [13:12] are reserved.\nFor GPIOD_DBEN, bits [5:0] and [13:8] are reserved.\nFor GPIOE_DBEN, bits [4:0] and [15:6] are reserved.\nFor GPIOF_DBEN, bits [15:2] are reserved.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The GPIO port [x] Pin [n] input signal de-bounce function is disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The GPIO port [x] Pin [n] input signal de-bounce function is enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN13</name>
              <description>GPIO Port [X] Pin [N] Input Signal De-Bounce Enable\nDBEN[n] used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle the input signal transition is seen as the signal bounce and will not trigger the interrupt.\nDBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt\nThe de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.\nNote: \nFor GPIOC_DBEN, bits [5:4] and [13:12] are reserved.\nFor GPIOD_DBEN, bits [5:0] and [13:8] are reserved.\nFor GPIOE_DBEN, bits [4:0] and [15:6] are reserved.\nFor GPIOF_DBEN, bits [15:2] are reserved.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The GPIO port [x] Pin [n] input signal de-bounce function is disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The GPIO port [x] Pin [n] input signal de-bounce function is enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN14</name>
              <description>GPIO Port [X] Pin [N] Input Signal De-Bounce Enable\nDBEN[n] used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle the input signal transition is seen as the signal bounce and will not trigger the interrupt.\nDBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt\nThe de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.\nNote: \nFor GPIOC_DBEN, bits [5:4] and [13:12] are reserved.\nFor GPIOD_DBEN, bits [5:0] and [13:8] are reserved.\nFor GPIOE_DBEN, bits [4:0] and [15:6] are reserved.\nFor GPIOF_DBEN, bits [15:2] are reserved.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The GPIO port [x] Pin [n] input signal de-bounce function is disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The GPIO port [x] Pin [n] input signal de-bounce function is enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN15</name>
              <description>GPIO Port [X] Pin [N] Input Signal De-Bounce Enable\nDBEN[n] used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle the input signal transition is seen as the signal bounce and will not trigger the interrupt.\nDBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt\nThe de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.\nNote: \nFor GPIOC_DBEN, bits [5:4] and [13:12] are reserved.\nFor GPIOD_DBEN, bits [5:0] and [13:8] are reserved.\nFor GPIOE_DBEN, bits [4:0] and [15:6] are reserved.\nFor GPIOF_DBEN, bits [15:2] are reserved.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The GPIO port [x] Pin [n] input signal de-bounce function is disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The GPIO port [x] Pin [n] input signal de-bounce function is enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPIOA_IMD</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPIOA_IMD</displayName>
          <description>GPIO Port A Interrupt Mode Control Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IMD0</name>
              <description>GPIO Port [X] Pin [N] Edge Or Level Detection Interrupt Control\nIMD[n] used to decide whether the interrupt is controlled by level trigger or by edge trigger. If the interrupt is controlled by edge trigger, the trigger source is sampled by de-bounce. If the interrupt is controlled by level trigger, the input source is sampled by one clock and the interrupt generates. \nIf set pin as the level trigger interrupt, then only one level can be set on the registers GPIOX_IER. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur\nThe de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.\nNote: \nFor GPIOC_IMD, bits [5:4] and [13:12] are reserved.\nFor GPIOD_IMD, bits [5:0] and [13:8] are reserved.\nFor GPIOE_IMD, bits [4:0] and [15:6] are reserved.\nFor GPIOF_IMD, bits [15:2] are reserved.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD1</name>
              <description>GPIO Port [X] Pin [N] Edge Or Level Detection Interrupt Control\nIMD[n] used to decide whether the interrupt is controlled by level trigger or by edge trigger. If the interrupt is controlled by edge trigger, the trigger source is sampled by de-bounce. If the interrupt is controlled by level trigger, the input source is sampled by one clock and the interrupt generates. \nIf set pin as the level trigger interrupt, then only one level can be set on the registers GPIOX_IER. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur\nThe de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.\nNote: \nFor GPIOC_IMD, bits [5:4] and [13:12] are reserved.\nFor GPIOD_IMD, bits [5:0] and [13:8] are reserved.\nFor GPIOE_IMD, bits [4:0] and [15:6] are reserved.\nFor GPIOF_IMD, bits [15:2] are reserved.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD2</name>
              <description>GPIO Port [X] Pin [N] Edge Or Level Detection Interrupt Control\nIMD[n] used to decide whether the interrupt is controlled by level trigger or by edge trigger. If the interrupt is controlled by edge trigger, the trigger source is sampled by de-bounce. If the interrupt is controlled by level trigger, the input source is sampled by one clock and the interrupt generates. \nIf set pin as the level trigger interrupt, then only one level can be set on the registers GPIOX_IER. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur\nThe de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.\nNote: \nFor GPIOC_IMD, bits [5:4] and [13:12] are reserved.\nFor GPIOD_IMD, bits [5:0] and [13:8] are reserved.\nFor GPIOE_IMD, bits [4:0] and [15:6] are reserved.\nFor GPIOF_IMD, bits [15:2] are reserved.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD3</name>
              <description>GPIO Port [X] Pin [N] Edge Or Level Detection Interrupt Control\nIMD[n] used to decide whether the interrupt is controlled by level trigger or by edge trigger. If the interrupt is controlled by edge trigger, the trigger source is sampled by de-bounce. If the interrupt is controlled by level trigger, the input source is sampled by one clock and the interrupt generates. \nIf set pin as the level trigger interrupt, then only one level can be set on the registers GPIOX_IER. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur\nThe de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.\nNote: \nFor GPIOC_IMD, bits [5:4] and [13:12] are reserved.\nFor GPIOD_IMD, bits [5:0] and [13:8] are reserved.\nFor GPIOE_IMD, bits [4:0] and [15:6] are reserved.\nFor GPIOF_IMD, bits [15:2] are reserved.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD4</name>
              <description>GPIO Port [X] Pin [N] Edge Or Level Detection Interrupt Control\nIMD[n] used to decide whether the interrupt is controlled by level trigger or by edge trigger. If the interrupt is controlled by edge trigger, the trigger source is sampled by de-bounce. If the interrupt is controlled by level trigger, the input source is sampled by one clock and the interrupt generates. \nIf set pin as the level trigger interrupt, then only one level can be set on the registers GPIOX_IER. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur\nThe de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.\nNote: \nFor GPIOC_IMD, bits [5:4] and [13:12] are reserved.\nFor GPIOD_IMD, bits [5:0] and [13:8] are reserved.\nFor GPIOE_IMD, bits [4:0] and [15:6] are reserved.\nFor GPIOF_IMD, bits [15:2] are reserved.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD5</name>
              <description>GPIO Port [X] Pin [N] Edge Or Level Detection Interrupt Control\nIMD[n] used to decide whether the interrupt is controlled by level trigger or by edge trigger. If the interrupt is controlled by edge trigger, the trigger source is sampled by de-bounce. If the interrupt is controlled by level trigger, the input source is sampled by one clock and the interrupt generates. \nIf set pin as the level trigger interrupt, then only one level can be set on the registers GPIOX_IER. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur\nThe de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.\nNote: \nFor GPIOC_IMD, bits [5:4] and [13:12] are reserved.\nFor GPIOD_IMD, bits [5:0] and [13:8] are reserved.\nFor GPIOE_IMD, bits [4:0] and [15:6] are reserved.\nFor GPIOF_IMD, bits [15:2] are reserved.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD6</name>
              <description>GPIO Port [X] Pin [N] Edge Or Level Detection Interrupt Control\nIMD[n] used to decide whether the interrupt is controlled by level trigger or by edge trigger. If the interrupt is controlled by edge trigger, the trigger source is sampled by de-bounce. If the interrupt is controlled by level trigger, the input source is sampled by one clock and the interrupt generates. \nIf set pin as the level trigger interrupt, then only one level can be set on the registers GPIOX_IER. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur\nThe de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.\nNote: \nFor GPIOC_IMD, bits [5:4] and [13:12] are reserved.\nFor GPIOD_IMD, bits [5:0] and [13:8] are reserved.\nFor GPIOE_IMD, bits [4:0] and [15:6] are reserved.\nFor GPIOF_IMD, bits [15:2] are reserved.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD7</name>
              <description>GPIO Port [X] Pin [N] Edge Or Level Detection Interrupt Control\nIMD[n] used to decide whether the interrupt is controlled by level trigger or by edge trigger. If the interrupt is controlled by edge trigger, the trigger source is sampled by de-bounce. If the interrupt is controlled by level trigger, the input source is sampled by one clock and the interrupt generates. \nIf set pin as the level trigger interrupt, then only one level can be set on the registers GPIOX_IER. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur\nThe de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.\nNote: \nFor GPIOC_IMD, bits [5:4] and [13:12] are reserved.\nFor GPIOD_IMD, bits [5:0] and [13:8] are reserved.\nFor GPIOE_IMD, bits [4:0] and [15:6] are reserved.\nFor GPIOF_IMD, bits [15:2] are reserved.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD8</name>
              <description>GPIO Port [X] Pin [N] Edge Or Level Detection Interrupt Control\nIMD[n] used to decide whether the interrupt is controlled by level trigger or by edge trigger. If the interrupt is controlled by edge trigger, the trigger source is sampled by de-bounce. If the interrupt is controlled by level trigger, the input source is sampled by one clock and the interrupt generates. \nIf set pin as the level trigger interrupt, then only one level can be set on the registers GPIOX_IER. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur\nThe de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.\nNote: \nFor GPIOC_IMD, bits [5:4] and [13:12] are reserved.\nFor GPIOD_IMD, bits [5:0] and [13:8] are reserved.\nFor GPIOE_IMD, bits [4:0] and [15:6] are reserved.\nFor GPIOF_IMD, bits [15:2] are reserved.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD9</name>
              <description>GPIO Port [X] Pin [N] Edge Or Level Detection Interrupt Control\nIMD[n] used to decide whether the interrupt is controlled by level trigger or by edge trigger. If the interrupt is controlled by edge trigger, the trigger source is sampled by de-bounce. If the interrupt is controlled by level trigger, the input source is sampled by one clock and the interrupt generates. \nIf set pin as the level trigger interrupt, then only one level can be set on the registers GPIOX_IER. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur\nThe de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.\nNote: \nFor GPIOC_IMD, bits [5:4] and [13:12] are reserved.\nFor GPIOD_IMD, bits [5:0] and [13:8] are reserved.\nFor GPIOE_IMD, bits [4:0] and [15:6] are reserved.\nFor GPIOF_IMD, bits [15:2] are reserved.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD10</name>
              <description>GPIO Port [X] Pin [N] Edge Or Level Detection Interrupt Control\nIMD[n] used to decide whether the interrupt is controlled by level trigger or by edge trigger. If the interrupt is controlled by edge trigger, the trigger source is sampled by de-bounce. If the interrupt is controlled by level trigger, the input source is sampled by one clock and the interrupt generates. \nIf set pin as the level trigger interrupt, then only one level can be set on the registers GPIOX_IER. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur\nThe de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.\nNote: \nFor GPIOC_IMD, bits [5:4] and [13:12] are reserved.\nFor GPIOD_IMD, bits [5:0] and [13:8] are reserved.\nFor GPIOE_IMD, bits [4:0] and [15:6] are reserved.\nFor GPIOF_IMD, bits [15:2] are reserved.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD11</name>
              <description>GPIO Port [X] Pin [N] Edge Or Level Detection Interrupt Control\nIMD[n] used to decide whether the interrupt is controlled by level trigger or by edge trigger. If the interrupt is controlled by edge trigger, the trigger source is sampled by de-bounce. If the interrupt is controlled by level trigger, the input source is sampled by one clock and the interrupt generates. \nIf set pin as the level trigger interrupt, then only one level can be set on the registers GPIOX_IER. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur\nThe de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.\nNote: \nFor GPIOC_IMD, bits [5:4] and [13:12] are reserved.\nFor GPIOD_IMD, bits [5:0] and [13:8] are reserved.\nFor GPIOE_IMD, bits [4:0] and [15:6] are reserved.\nFor GPIOF_IMD, bits [15:2] are reserved.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD12</name>
              <description>GPIO Port [X] Pin [N] Edge Or Level Detection Interrupt Control\nIMD[n] used to decide whether the interrupt is controlled by level trigger or by edge trigger. If the interrupt is controlled by edge trigger, the trigger source is sampled by de-bounce. If the interrupt is controlled by level trigger, the input source is sampled by one clock and the interrupt generates. \nIf set pin as the level trigger interrupt, then only one level can be set on the registers GPIOX_IER. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur\nThe de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.\nNote: \nFor GPIOC_IMD, bits [5:4] and [13:12] are reserved.\nFor GPIOD_IMD, bits [5:0] and [13:8] are reserved.\nFor GPIOE_IMD, bits [4:0] and [15:6] are reserved.\nFor GPIOF_IMD, bits [15:2] are reserved.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD13</name>
              <description>GPIO Port [X] Pin [N] Edge Or Level Detection Interrupt Control\nIMD[n] used to decide whether the interrupt is controlled by level trigger or by edge trigger. If the interrupt is controlled by edge trigger, the trigger source is sampled by de-bounce. If the interrupt is controlled by level trigger, the input source is sampled by one clock and the interrupt generates. \nIf set pin as the level trigger interrupt, then only one level can be set on the registers GPIOX_IER. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur\nThe de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.\nNote: \nFor GPIOC_IMD, bits [5:4] and [13:12] are reserved.\nFor GPIOD_IMD, bits [5:0] and [13:8] are reserved.\nFor GPIOE_IMD, bits [4:0] and [15:6] are reserved.\nFor GPIOF_IMD, bits [15:2] are reserved.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD14</name>
              <description>GPIO Port [X] Pin [N] Edge Or Level Detection Interrupt Control\nIMD[n] used to decide whether the interrupt is controlled by level trigger or by edge trigger. If the interrupt is controlled by edge trigger, the trigger source is sampled by de-bounce. If the interrupt is controlled by level trigger, the input source is sampled by one clock and the interrupt generates. \nIf set pin as the level trigger interrupt, then only one level can be set on the registers GPIOX_IER. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur\nThe de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.\nNote: \nFor GPIOC_IMD, bits [5:4] and [13:12] are reserved.\nFor GPIOD_IMD, bits [5:0] and [13:8] are reserved.\nFor GPIOE_IMD, bits [4:0] and [15:6] are reserved.\nFor GPIOF_IMD, bits [15:2] are reserved.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD15</name>
              <description>GPIO Port [X] Pin [N] Edge Or Level Detection Interrupt Control\nIMD[n] used to decide whether the interrupt is controlled by level trigger or by edge trigger. If the interrupt is controlled by edge trigger, the trigger source is sampled by de-bounce. If the interrupt is controlled by level trigger, the input source is sampled by one clock and the interrupt generates. \nIf set pin as the level trigger interrupt, then only one level can be set on the registers GPIOX_IER. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur\nThe de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.\nNote: \nFor GPIOC_IMD, bits [5:4] and [13:12] are reserved.\nFor GPIOD_IMD, bits [5:0] and [13:8] are reserved.\nFor GPIOE_IMD, bits [4:0] and [15:6] are reserved.\nFor GPIOF_IMD, bits [15:2] are reserved.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPIOA_IER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPIOA_IER</displayName>
          <description>GPIO Port A Interrupt Enable Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FIER0</name>
              <description>GPIO Port [X] Pin [N] Interrupt Enable By Input Falling Edge Or Input Level Low\nFIER[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit "1" also enable the pin wake-up function\nWhen set the FIER[n] bit "1":\nIf the interrupt is level mode trigger, the input PIN[n] state at level "low" will generate the interrupt.\nIf the interrupt is edge mode trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.\nNote: \nFor GPIOC_IER, bits [5:4] and [13:12] are reserved.\nFor GPIOD_IER, bits [5:0] and [13:8] are reserved.\nFor GPIOE_IER, bits [4:0] and [15:6] are reserved.\nFor GPIOF_IER, bits [15:2] are reserved.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FIER1</name>
              <description>GPIO Port [X] Pin [N] Interrupt Enable By Input Falling Edge Or Input Level Low\nFIER[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit "1" also enable the pin wake-up function\nWhen set the FIER[n] bit "1":\nIf the interrupt is level mode trigger, the input PIN[n] state at level "low" will generate the interrupt.\nIf the interrupt is edge mode trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.\nNote: \nFor GPIOC_IER, bits [5:4] and [13:12] are reserved.\nFor GPIOD_IER, bits [5:0] and [13:8] are reserved.\nFor GPIOE_IER, bits [4:0] and [15:6] are reserved.\nFor GPIOF_IER, bits [15:2] are reserved.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FIER2</name>
              <description>GPIO Port [X] Pin [N] Interrupt Enable By Input Falling Edge Or Input Level Low\nFIER[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit "1" also enable the pin wake-up function\nWhen set the FIER[n] bit "1":\nIf the interrupt is level mode trigger, the input PIN[n] state at level "low" will generate the interrupt.\nIf the interrupt is edge mode trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.\nNote: \nFor GPIOC_IER, bits [5:4] and [13:12] are reserved.\nFor GPIOD_IER, bits [5:0] and [13:8] are reserved.\nFor GPIOE_IER, bits [4:0] and [15:6] are reserved.\nFor GPIOF_IER, bits [15:2] are reserved.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FIER3</name>
              <description>GPIO Port [X] Pin [N] Interrupt Enable By Input Falling Edge Or Input Level Low\nFIER[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit "1" also enable the pin wake-up function\nWhen set the FIER[n] bit "1":\nIf the interrupt is level mode trigger, the input PIN[n] state at level "low" will generate the interrupt.\nIf the interrupt is edge mode trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.\nNote: \nFor GPIOC_IER, bits [5:4] and [13:12] are reserved.\nFor GPIOD_IER, bits [5:0] and [13:8] are reserved.\nFor GPIOE_IER, bits [4:0] and [15:6] are reserved.\nFor GPIOF_IER, bits [15:2] are reserved.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FIER4</name>
              <description>GPIO Port [X] Pin [N] Interrupt Enable By Input Falling Edge Or Input Level Low\nFIER[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit "1" also enable the pin wake-up function\nWhen set the FIER[n] bit "1":\nIf the interrupt is level mode trigger, the input PIN[n] state at level "low" will generate the interrupt.\nIf the interrupt is edge mode trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.\nNote: \nFor GPIOC_IER, bits [5:4] and [13:12] are reserved.\nFor GPIOD_IER, bits [5:0] and [13:8] are reserved.\nFor GPIOE_IER, bits [4:0] and [15:6] are reserved.\nFor GPIOF_IER, bits [15:2] are reserved.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FIER5</name>
              <description>GPIO Port [X] Pin [N] Interrupt Enable By Input Falling Edge Or Input Level Low\nFIER[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit "1" also enable the pin wake-up function\nWhen set the FIER[n] bit "1":\nIf the interrupt is level mode trigger, the input PIN[n] state at level "low" will generate the interrupt.\nIf the interrupt is edge mode trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.\nNote: \nFor GPIOC_IER, bits [5:4] and [13:12] are reserved.\nFor GPIOD_IER, bits [5:0] and [13:8] are reserved.\nFor GPIOE_IER, bits [4:0] and [15:6] are reserved.\nFor GPIOF_IER, bits [15:2] are reserved.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FIER6</name>
              <description>GPIO Port [X] Pin [N] Interrupt Enable By Input Falling Edge Or Input Level Low\nFIER[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit "1" also enable the pin wake-up function\nWhen set the FIER[n] bit "1":\nIf the interrupt is level mode trigger, the input PIN[n] state at level "low" will generate the interrupt.\nIf the interrupt is edge mode trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.\nNote: \nFor GPIOC_IER, bits [5:4] and [13:12] are reserved.\nFor GPIOD_IER, bits [5:0] and [13:8] are reserved.\nFor GPIOE_IER, bits [4:0] and [15:6] are reserved.\nFor GPIOF_IER, bits [15:2] are reserved.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FIER7</name>
              <description>GPIO Port [X] Pin [N] Interrupt Enable By Input Falling Edge Or Input Level Low\nFIER[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit "1" also enable the pin wake-up function\nWhen set the FIER[n] bit "1":\nIf the interrupt is level mode trigger, the input PIN[n] state at level "low" will generate the interrupt.\nIf the interrupt is edge mode trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.\nNote: \nFor GPIOC_IER, bits [5:4] and [13:12] are reserved.\nFor GPIOD_IER, bits [5:0] and [13:8] are reserved.\nFor GPIOE_IER, bits [4:0] and [15:6] are reserved.\nFor GPIOF_IER, bits [15:2] are reserved.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FIER8</name>
              <description>GPIO Port [X] Pin [N] Interrupt Enable By Input Falling Edge Or Input Level Low\nFIER[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit "1" also enable the pin wake-up function\nWhen set the FIER[n] bit "1":\nIf the interrupt is level mode trigger, the input PIN[n] state at level "low" will generate the interrupt.\nIf the interrupt is edge mode trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.\nNote: \nFor GPIOC_IER, bits [5:4] and [13:12] are reserved.\nFor GPIOD_IER, bits [5:0] and [13:8] are reserved.\nFor GPIOE_IER, bits [4:0] and [15:6] are reserved.\nFor GPIOF_IER, bits [15:2] are reserved.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FIER9</name>
              <description>GPIO Port [X] Pin [N] Interrupt Enable By Input Falling Edge Or Input Level Low\nFIER[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit "1" also enable the pin wake-up function\nWhen set the FIER[n] bit "1":\nIf the interrupt is level mode trigger, the input PIN[n] state at level "low" will generate the interrupt.\nIf the interrupt is edge mode trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.\nNote: \nFor GPIOC_IER, bits [5:4] and [13:12] are reserved.\nFor GPIOD_IER, bits [5:0] and [13:8] are reserved.\nFor GPIOE_IER, bits [4:0] and [15:6] are reserved.\nFor GPIOF_IER, bits [15:2] are reserved.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FIER10</name>
              <description>GPIO Port [X] Pin [N] Interrupt Enable By Input Falling Edge Or Input Level Low\nFIER[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit "1" also enable the pin wake-up function\nWhen set the FIER[n] bit "1":\nIf the interrupt is level mode trigger, the input PIN[n] state at level "low" will generate the interrupt.\nIf the interrupt is edge mode trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.\nNote: \nFor GPIOC_IER, bits [5:4] and [13:12] are reserved.\nFor GPIOD_IER, bits [5:0] and [13:8] are reserved.\nFor GPIOE_IER, bits [4:0] and [15:6] are reserved.\nFor GPIOF_IER, bits [15:2] are reserved.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FIER11</name>
              <description>GPIO Port [X] Pin [N] Interrupt Enable By Input Falling Edge Or Input Level Low\nFIER[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit "1" also enable the pin wake-up function\nWhen set the FIER[n] bit "1":\nIf the interrupt is level mode trigger, the input PIN[n] state at level "low" will generate the interrupt.\nIf the interrupt is edge mode trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.\nNote: \nFor GPIOC_IER, bits [5:4] and [13:12] are reserved.\nFor GPIOD_IER, bits [5:0] and [13:8] are reserved.\nFor GPIOE_IER, bits [4:0] and [15:6] are reserved.\nFor GPIOF_IER, bits [15:2] are reserved.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FIER12</name>
              <description>GPIO Port [X] Pin [N] Interrupt Enable By Input Falling Edge Or Input Level Low\nFIER[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit "1" also enable the pin wake-up function\nWhen set the FIER[n] bit "1":\nIf the interrupt is level mode trigger, the input PIN[n] state at level "low" will generate the interrupt.\nIf the interrupt is edge mode trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.\nNote: \nFor GPIOC_IER, bits [5:4] and [13:12] are reserved.\nFor GPIOD_IER, bits [5:0] and [13:8] are reserved.\nFor GPIOE_IER, bits [4:0] and [15:6] are reserved.\nFor GPIOF_IER, bits [15:2] are reserved.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FIER13</name>
              <description>GPIO Port [X] Pin [N] Interrupt Enable By Input Falling Edge Or Input Level Low\nFIER[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit "1" also enable the pin wake-up function\nWhen set the FIER[n] bit "1":\nIf the interrupt is level mode trigger, the input PIN[n] state at level "low" will generate the interrupt.\nIf the interrupt is edge mode trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.\nNote: \nFor GPIOC_IER, bits [5:4] and [13:12] are reserved.\nFor GPIOD_IER, bits [5:0] and [13:8] are reserved.\nFor GPIOE_IER, bits [4:0] and [15:6] are reserved.\nFor GPIOF_IER, bits [15:2] are reserved.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FIER14</name>
              <description>GPIO Port [X] Pin [N] Interrupt Enable By Input Falling Edge Or Input Level Low\nFIER[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit "1" also enable the pin wake-up function\nWhen set the FIER[n] bit "1":\nIf the interrupt is level mode trigger, the input PIN[n] state at level "low" will generate the interrupt.\nIf the interrupt is edge mode trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.\nNote: \nFor GPIOC_IER, bits [5:4] and [13:12] are reserved.\nFor GPIOD_IER, bits [5:0] and [13:8] are reserved.\nFor GPIOE_IER, bits [4:0] and [15:6] are reserved.\nFor GPIOF_IER, bits [15:2] are reserved.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FIER15</name>
              <description>GPIO Port [X] Pin [N] Interrupt Enable By Input Falling Edge Or Input Level Low\nFIER[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit "1" also enable the pin wake-up function\nWhen set the FIER[n] bit "1":\nIf the interrupt is level mode trigger, the input PIN[n] state at level "low" will generate the interrupt.\nIf the interrupt is edge mode trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.\nNote: \nFor GPIOC_IER, bits [5:4] and [13:12] are reserved.\nFor GPIOD_IER, bits [5:0] and [13:8] are reserved.\nFor GPIOE_IER, bits [4:0] and [15:6] are reserved.\nFor GPIOF_IER, bits [15:2] are reserved.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RIER0</name>
              <description>GPIO Port [X] Pin [N] Interrupt Enable By Input Rising Edge Or Input Level High\nRIER[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[x]. Set bit "1" also enable the pin wake-up function \nWhen set the RIER[x] bit "1":\nIf the interrupt is level mode trigger, the input PIN[n] state at level "high" will generate the interrupt.\nIf the interrupt is edge mode trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.\nNote: \nFor GPIOC_IER, bits [21:20] and [29:28] are reserved.\nFor GPIOD_IER, bits [21:16] and [29:24] are reserved.\nFor GPIOE_IER, bits [20:16] and [31:22] are reserved.\nFor GPIOF_IER, bits [31:18] are reserved.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RIER1</name>
              <description>GPIO Port [X] Pin [N] Interrupt Enable By Input Rising Edge Or Input Level High\nRIER[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[x]. Set bit "1" also enable the pin wake-up function \nWhen set the RIER[x] bit "1":\nIf the interrupt is level mode trigger, the input PIN[n] state at level "high" will generate the interrupt.\nIf the interrupt is edge mode trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.\nNote: \nFor GPIOC_IER, bits [21:20] and [29:28] are reserved.\nFor GPIOD_IER, bits [21:16] and [29:24] are reserved.\nFor GPIOE_IER, bits [20:16] and [31:22] are reserved.\nFor GPIOF_IER, bits [31:18] are reserved.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RIER2</name>
              <description>GPIO Port [X] Pin [N] Interrupt Enable By Input Rising Edge Or Input Level High\nRIER[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[x]. Set bit "1" also enable the pin wake-up function \nWhen set the RIER[x] bit "1":\nIf the interrupt is level mode trigger, the input PIN[n] state at level "high" will generate the interrupt.\nIf the interrupt is edge mode trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.\nNote: \nFor GPIOC_IER, bits [21:20] and [29:28] are reserved.\nFor GPIOD_IER, bits [21:16] and [29:24] are reserved.\nFor GPIOE_IER, bits [20:16] and [31:22] are reserved.\nFor GPIOF_IER, bits [31:18] are reserved.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RIER3</name>
              <description>GPIO Port [X] Pin [N] Interrupt Enable By Input Rising Edge Or Input Level High\nRIER[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[x]. Set bit "1" also enable the pin wake-up function \nWhen set the RIER[x] bit "1":\nIf the interrupt is level mode trigger, the input PIN[n] state at level "high" will generate the interrupt.\nIf the interrupt is edge mode trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.\nNote: \nFor GPIOC_IER, bits [21:20] and [29:28] are reserved.\nFor GPIOD_IER, bits [21:16] and [29:24] are reserved.\nFor GPIOE_IER, bits [20:16] and [31:22] are reserved.\nFor GPIOF_IER, bits [31:18] are reserved.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RIER4</name>
              <description>GPIO Port [X] Pin [N] Interrupt Enable By Input Rising Edge Or Input Level High\nRIER[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[x]. Set bit "1" also enable the pin wake-up function \nWhen set the RIER[x] bit "1":\nIf the interrupt is level mode trigger, the input PIN[n] state at level "high" will generate the interrupt.\nIf the interrupt is edge mode trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.\nNote: \nFor GPIOC_IER, bits [21:20] and [29:28] are reserved.\nFor GPIOD_IER, bits [21:16] and [29:24] are reserved.\nFor GPIOE_IER, bits [20:16] and [31:22] are reserved.\nFor GPIOF_IER, bits [31:18] are reserved.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RIER5</name>
              <description>GPIO Port [X] Pin [N] Interrupt Enable By Input Rising Edge Or Input Level High\nRIER[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[x]. Set bit "1" also enable the pin wake-up function \nWhen set the RIER[x] bit "1":\nIf the interrupt is level mode trigger, the input PIN[n] state at level "high" will generate the interrupt.\nIf the interrupt is edge mode trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.\nNote: \nFor GPIOC_IER, bits [21:20] and [29:28] are reserved.\nFor GPIOD_IER, bits [21:16] and [29:24] are reserved.\nFor GPIOE_IER, bits [20:16] and [31:22] are reserved.\nFor GPIOF_IER, bits [31:18] are reserved.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RIER6</name>
              <description>GPIO Port [X] Pin [N] Interrupt Enable By Input Rising Edge Or Input Level High\nRIER[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[x]. Set bit "1" also enable the pin wake-up function \nWhen set the RIER[x] bit "1":\nIf the interrupt is level mode trigger, the input PIN[n] state at level "high" will generate the interrupt.\nIf the interrupt is edge mode trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.\nNote: \nFor GPIOC_IER, bits [21:20] and [29:28] are reserved.\nFor GPIOD_IER, bits [21:16] and [29:24] are reserved.\nFor GPIOE_IER, bits [20:16] and [31:22] are reserved.\nFor GPIOF_IER, bits [31:18] are reserved.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RIER7</name>
              <description>GPIO Port [X] Pin [N] Interrupt Enable By Input Rising Edge Or Input Level High\nRIER[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[x]. Set bit "1" also enable the pin wake-up function \nWhen set the RIER[x] bit "1":\nIf the interrupt is level mode trigger, the input PIN[n] state at level "high" will generate the interrupt.\nIf the interrupt is edge mode trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.\nNote: \nFor GPIOC_IER, bits [21:20] and [29:28] are reserved.\nFor GPIOD_IER, bits [21:16] and [29:24] are reserved.\nFor GPIOE_IER, bits [20:16] and [31:22] are reserved.\nFor GPIOF_IER, bits [31:18] are reserved.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RIER8</name>
              <description>GPIO Port [X] Pin [N] Interrupt Enable By Input Rising Edge Or Input Level High\nRIER[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[x]. Set bit "1" also enable the pin wake-up function \nWhen set the RIER[x] bit "1":\nIf the interrupt is level mode trigger, the input PIN[n] state at level "high" will generate the interrupt.\nIf the interrupt is edge mode trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.\nNote: \nFor GPIOC_IER, bits [21:20] and [29:28] are reserved.\nFor GPIOD_IER, bits [21:16] and [29:24] are reserved.\nFor GPIOE_IER, bits [20:16] and [31:22] are reserved.\nFor GPIOF_IER, bits [31:18] are reserved.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RIER9</name>
              <description>GPIO Port [X] Pin [N] Interrupt Enable By Input Rising Edge Or Input Level High\nRIER[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[x]. Set bit "1" also enable the pin wake-up function \nWhen set the RIER[x] bit "1":\nIf the interrupt is level mode trigger, the input PIN[n] state at level "high" will generate the interrupt.\nIf the interrupt is edge mode trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.\nNote: \nFor GPIOC_IER, bits [21:20] and [29:28] are reserved.\nFor GPIOD_IER, bits [21:16] and [29:24] are reserved.\nFor GPIOE_IER, bits [20:16] and [31:22] are reserved.\nFor GPIOF_IER, bits [31:18] are reserved.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RIER10</name>
              <description>GPIO Port [X] Pin [N] Interrupt Enable By Input Rising Edge Or Input Level High\nRIER[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[x]. Set bit "1" also enable the pin wake-up function \nWhen set the RIER[x] bit "1":\nIf the interrupt is level mode trigger, the input PIN[n] state at level "high" will generate the interrupt.\nIf the interrupt is edge mode trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.\nNote: \nFor GPIOC_IER, bits [21:20] and [29:28] are reserved.\nFor GPIOD_IER, bits [21:16] and [29:24] are reserved.\nFor GPIOE_IER, bits [20:16] and [31:22] are reserved.\nFor GPIOF_IER, bits [31:18] are reserved.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RIER11</name>
              <description>GPIO Port [X] Pin [N] Interrupt Enable By Input Rising Edge Or Input Level High\nRIER[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[x]. Set bit "1" also enable the pin wake-up function \nWhen set the RIER[x] bit "1":\nIf the interrupt is level mode trigger, the input PIN[n] state at level "high" will generate the interrupt.\nIf the interrupt is edge mode trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.\nNote: \nFor GPIOC_IER, bits [21:20] and [29:28] are reserved.\nFor GPIOD_IER, bits [21:16] and [29:24] are reserved.\nFor GPIOE_IER, bits [20:16] and [31:22] are reserved.\nFor GPIOF_IER, bits [31:18] are reserved.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RIER12</name>
              <description>GPIO Port [X] Pin [N] Interrupt Enable By Input Rising Edge Or Input Level High\nRIER[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[x]. Set bit "1" also enable the pin wake-up function \nWhen set the RIER[x] bit "1":\nIf the interrupt is level mode trigger, the input PIN[n] state at level "high" will generate the interrupt.\nIf the interrupt is edge mode trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.\nNote: \nFor GPIOC_IER, bits [21:20] and [29:28] are reserved.\nFor GPIOD_IER, bits [21:16] and [29:24] are reserved.\nFor GPIOE_IER, bits [20:16] and [31:22] are reserved.\nFor GPIOF_IER, bits [31:18] are reserved.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RIER13</name>
              <description>GPIO Port [X] Pin [N] Interrupt Enable By Input Rising Edge Or Input Level High\nRIER[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[x]. Set bit "1" also enable the pin wake-up function \nWhen set the RIER[x] bit "1":\nIf the interrupt is level mode trigger, the input PIN[n] state at level "high" will generate the interrupt.\nIf the interrupt is edge mode trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.\nNote: \nFor GPIOC_IER, bits [21:20] and [29:28] are reserved.\nFor GPIOD_IER, bits [21:16] and [29:24] are reserved.\nFor GPIOE_IER, bits [20:16] and [31:22] are reserved.\nFor GPIOF_IER, bits [31:18] are reserved.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RIER14</name>
              <description>GPIO Port [X] Pin [N] Interrupt Enable By Input Rising Edge Or Input Level High\nRIER[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[x]. Set bit "1" also enable the pin wake-up function \nWhen set the RIER[x] bit "1":\nIf the interrupt is level mode trigger, the input PIN[n] state at level "high" will generate the interrupt.\nIf the interrupt is edge mode trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.\nNote: \nFor GPIOC_IER, bits [21:20] and [29:28] are reserved.\nFor GPIOD_IER, bits [21:16] and [29:24] are reserved.\nFor GPIOE_IER, bits [20:16] and [31:22] are reserved.\nFor GPIOF_IER, bits [31:18] are reserved.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RIER15</name>
              <description>GPIO Port [X] Pin [N] Interrupt Enable By Input Rising Edge Or Input Level High\nRIER[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[x]. Set bit "1" also enable the pin wake-up function \nWhen set the RIER[x] bit "1":\nIf the interrupt is level mode trigger, the input PIN[n] state at level "high" will generate the interrupt.\nIf the interrupt is edge mode trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.\nNote: \nFor GPIOC_IER, bits [21:20] and [29:28] are reserved.\nFor GPIOD_IER, bits [21:16] and [29:24] are reserved.\nFor GPIOE_IER, bits [20:16] and [31:22] are reserved.\nFor GPIOF_IER, bits [31:18] are reserved.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPIOA_ISRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPIOA_ISRC</displayName>
          <description>GPIO Port A Interrupt Trigger Source Status Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ISRC0</name>
              <description>GPIO Port [X] Pin [N] Interrupt Trigger Source Indicator\nRead :\nNote: \nFor GPIOC_ISRC, bits [5:4] and [13:12] are reserved.\nFor GPIOD_ISRC, bits [5:0] and [13:8] are reserved.\nFor GPIOE_ISRC, bits [4:0] and [15:6] are reserved.\nFor GPIOF_ISRC, bits [15:2] are reserved.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at Port x[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Port x[n] generate an interrupt.\nClear the correspond pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC1</name>
              <description>GPIO Port [X] Pin [N] Interrupt Trigger Source Indicator\nRead :\nNote: \nFor GPIOC_ISRC, bits [5:4] and [13:12] are reserved.\nFor GPIOD_ISRC, bits [5:0] and [13:8] are reserved.\nFor GPIOE_ISRC, bits [4:0] and [15:6] are reserved.\nFor GPIOF_ISRC, bits [15:2] are reserved.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at Port x[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Port x[n] generate an interrupt.\nClear the correspond pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC2</name>
              <description>GPIO Port [X] Pin [N] Interrupt Trigger Source Indicator\nRead :\nNote: \nFor GPIOC_ISRC, bits [5:4] and [13:12] are reserved.\nFor GPIOD_ISRC, bits [5:0] and [13:8] are reserved.\nFor GPIOE_ISRC, bits [4:0] and [15:6] are reserved.\nFor GPIOF_ISRC, bits [15:2] are reserved.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at Port x[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Port x[n] generate an interrupt.\nClear the correspond pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC3</name>
              <description>GPIO Port [X] Pin [N] Interrupt Trigger Source Indicator\nRead :\nNote: \nFor GPIOC_ISRC, bits [5:4] and [13:12] are reserved.\nFor GPIOD_ISRC, bits [5:0] and [13:8] are reserved.\nFor GPIOE_ISRC, bits [4:0] and [15:6] are reserved.\nFor GPIOF_ISRC, bits [15:2] are reserved.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at Port x[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Port x[n] generate an interrupt.\nClear the correspond pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC4</name>
              <description>GPIO Port [X] Pin [N] Interrupt Trigger Source Indicator\nRead :\nNote: \nFor GPIOC_ISRC, bits [5:4] and [13:12] are reserved.\nFor GPIOD_ISRC, bits [5:0] and [13:8] are reserved.\nFor GPIOE_ISRC, bits [4:0] and [15:6] are reserved.\nFor GPIOF_ISRC, bits [15:2] are reserved.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at Port x[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Port x[n] generate an interrupt.\nClear the correspond pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC5</name>
              <description>GPIO Port [X] Pin [N] Interrupt Trigger Source Indicator\nRead :\nNote: \nFor GPIOC_ISRC, bits [5:4] and [13:12] are reserved.\nFor GPIOD_ISRC, bits [5:0] and [13:8] are reserved.\nFor GPIOE_ISRC, bits [4:0] and [15:6] are reserved.\nFor GPIOF_ISRC, bits [15:2] are reserved.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at Port x[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Port x[n] generate an interrupt.\nClear the correspond pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC6</name>
              <description>GPIO Port [X] Pin [N] Interrupt Trigger Source Indicator\nRead :\nNote: \nFor GPIOC_ISRC, bits [5:4] and [13:12] are reserved.\nFor GPIOD_ISRC, bits [5:0] and [13:8] are reserved.\nFor GPIOE_ISRC, bits [4:0] and [15:6] are reserved.\nFor GPIOF_ISRC, bits [15:2] are reserved.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at Port x[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Port x[n] generate an interrupt.\nClear the correspond pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC7</name>
              <description>GPIO Port [X] Pin [N] Interrupt Trigger Source Indicator\nRead :\nNote: \nFor GPIOC_ISRC, bits [5:4] and [13:12] are reserved.\nFor GPIOD_ISRC, bits [5:0] and [13:8] are reserved.\nFor GPIOE_ISRC, bits [4:0] and [15:6] are reserved.\nFor GPIOF_ISRC, bits [15:2] are reserved.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at Port x[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Port x[n] generate an interrupt.\nClear the correspond pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC8</name>
              <description>GPIO Port [X] Pin [N] Interrupt Trigger Source Indicator\nRead :\nNote: \nFor GPIOC_ISRC, bits [5:4] and [13:12] are reserved.\nFor GPIOD_ISRC, bits [5:0] and [13:8] are reserved.\nFor GPIOE_ISRC, bits [4:0] and [15:6] are reserved.\nFor GPIOF_ISRC, bits [15:2] are reserved.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at Port x[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Port x[n] generate an interrupt.\nClear the correspond pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC9</name>
              <description>GPIO Port [X] Pin [N] Interrupt Trigger Source Indicator\nRead :\nNote: \nFor GPIOC_ISRC, bits [5:4] and [13:12] are reserved.\nFor GPIOD_ISRC, bits [5:0] and [13:8] are reserved.\nFor GPIOE_ISRC, bits [4:0] and [15:6] are reserved.\nFor GPIOF_ISRC, bits [15:2] are reserved.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at Port x[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Port x[n] generate an interrupt.\nClear the correspond pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC10</name>
              <description>GPIO Port [X] Pin [N] Interrupt Trigger Source Indicator\nRead :\nNote: \nFor GPIOC_ISRC, bits [5:4] and [13:12] are reserved.\nFor GPIOD_ISRC, bits [5:0] and [13:8] are reserved.\nFor GPIOE_ISRC, bits [4:0] and [15:6] are reserved.\nFor GPIOF_ISRC, bits [15:2] are reserved.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at Port x[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Port x[n] generate an interrupt.\nClear the correspond pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC11</name>
              <description>GPIO Port [X] Pin [N] Interrupt Trigger Source Indicator\nRead :\nNote: \nFor GPIOC_ISRC, bits [5:4] and [13:12] are reserved.\nFor GPIOD_ISRC, bits [5:0] and [13:8] are reserved.\nFor GPIOE_ISRC, bits [4:0] and [15:6] are reserved.\nFor GPIOF_ISRC, bits [15:2] are reserved.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at Port x[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Port x[n] generate an interrupt.\nClear the correspond pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC12</name>
              <description>GPIO Port [X] Pin [N] Interrupt Trigger Source Indicator\nRead :\nNote: \nFor GPIOC_ISRC, bits [5:4] and [13:12] are reserved.\nFor GPIOD_ISRC, bits [5:0] and [13:8] are reserved.\nFor GPIOE_ISRC, bits [4:0] and [15:6] are reserved.\nFor GPIOF_ISRC, bits [15:2] are reserved.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at Port x[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Port x[n] generate an interrupt.\nClear the correspond pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC13</name>
              <description>GPIO Port [X] Pin [N] Interrupt Trigger Source Indicator\nRead :\nNote: \nFor GPIOC_ISRC, bits [5:4] and [13:12] are reserved.\nFor GPIOD_ISRC, bits [5:0] and [13:8] are reserved.\nFor GPIOE_ISRC, bits [4:0] and [15:6] are reserved.\nFor GPIOF_ISRC, bits [15:2] are reserved.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at Port x[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Port x[n] generate an interrupt.\nClear the correspond pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC14</name>
              <description>GPIO Port [X] Pin [N] Interrupt Trigger Source Indicator\nRead :\nNote: \nFor GPIOC_ISRC, bits [5:4] and [13:12] are reserved.\nFor GPIOD_ISRC, bits [5:0] and [13:8] are reserved.\nFor GPIOE_ISRC, bits [4:0] and [15:6] are reserved.\nFor GPIOF_ISRC, bits [15:2] are reserved.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at Port x[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Port x[n] generate an interrupt.\nClear the correspond pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC15</name>
              <description>GPIO Port [X] Pin [N] Interrupt Trigger Source Indicator\nRead :\nNote: \nFor GPIOC_ISRC, bits [5:4] and [13:12] are reserved.\nFor GPIOD_ISRC, bits [5:0] and [13:8] are reserved.\nFor GPIOE_ISRC, bits [4:0] and [15:6] are reserved.\nFor GPIOF_ISRC, bits [15:2] are reserved.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at Port x[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Port x[n] generate an interrupt.\nClear the correspond pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPIOA_PUEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPIOA_PUEN</displayName>
          <description>GPIO Port A Pull-up Enable Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PUEN0</name>
              <description>GPIO Port [X] Pin [N] Pull-Up Enable Register\nRead :\nNote: \nFor GPIOC_PUEN, bits [5:4] and [13:12] are reserved.\nFor GPIOD_PUEN, bits [5:0] and [13:8] are reserved.\nFor GPIOE_PUEN, bits [4:0] and [15:6] are reserved.\nFor GPIOF_PUEN, bits [15:2] are reserved.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/D/E/F] bit [n] pull-up resistor Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/D/E/F] bit [n] pull-up resistor Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PUEN1</name>
              <description>GPIO Port [X] Pin [N] Pull-Up Enable Register\nRead :\nNote: \nFor GPIOC_PUEN, bits [5:4] and [13:12] are reserved.\nFor GPIOD_PUEN, bits [5:0] and [13:8] are reserved.\nFor GPIOE_PUEN, bits [4:0] and [15:6] are reserved.\nFor GPIOF_PUEN, bits [15:2] are reserved.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/D/E/F] bit [n] pull-up resistor Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/D/E/F] bit [n] pull-up resistor Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PUEN2</name>
              <description>GPIO Port [X] Pin [N] Pull-Up Enable Register\nRead :\nNote: \nFor GPIOC_PUEN, bits [5:4] and [13:12] are reserved.\nFor GPIOD_PUEN, bits [5:0] and [13:8] are reserved.\nFor GPIOE_PUEN, bits [4:0] and [15:6] are reserved.\nFor GPIOF_PUEN, bits [15:2] are reserved.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/D/E/F] bit [n] pull-up resistor Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/D/E/F] bit [n] pull-up resistor Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PUEN3</name>
              <description>GPIO Port [X] Pin [N] Pull-Up Enable Register\nRead :\nNote: \nFor GPIOC_PUEN, bits [5:4] and [13:12] are reserved.\nFor GPIOD_PUEN, bits [5:0] and [13:8] are reserved.\nFor GPIOE_PUEN, bits [4:0] and [15:6] are reserved.\nFor GPIOF_PUEN, bits [15:2] are reserved.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/D/E/F] bit [n] pull-up resistor Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/D/E/F] bit [n] pull-up resistor Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PUEN4</name>
              <description>GPIO Port [X] Pin [N] Pull-Up Enable Register\nRead :\nNote: \nFor GPIOC_PUEN, bits [5:4] and [13:12] are reserved.\nFor GPIOD_PUEN, bits [5:0] and [13:8] are reserved.\nFor GPIOE_PUEN, bits [4:0] and [15:6] are reserved.\nFor GPIOF_PUEN, bits [15:2] are reserved.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/D/E/F] bit [n] pull-up resistor Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/D/E/F] bit [n] pull-up resistor Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PUEN5</name>
              <description>GPIO Port [X] Pin [N] Pull-Up Enable Register\nRead :\nNote: \nFor GPIOC_PUEN, bits [5:4] and [13:12] are reserved.\nFor GPIOD_PUEN, bits [5:0] and [13:8] are reserved.\nFor GPIOE_PUEN, bits [4:0] and [15:6] are reserved.\nFor GPIOF_PUEN, bits [15:2] are reserved.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/D/E/F] bit [n] pull-up resistor Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/D/E/F] bit [n] pull-up resistor Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PUEN6</name>
              <description>GPIO Port [X] Pin [N] Pull-Up Enable Register\nRead :\nNote: \nFor GPIOC_PUEN, bits [5:4] and [13:12] are reserved.\nFor GPIOD_PUEN, bits [5:0] and [13:8] are reserved.\nFor GPIOE_PUEN, bits [4:0] and [15:6] are reserved.\nFor GPIOF_PUEN, bits [15:2] are reserved.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/D/E/F] bit [n] pull-up resistor Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/D/E/F] bit [n] pull-up resistor Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PUEN7</name>
              <description>GPIO Port [X] Pin [N] Pull-Up Enable Register\nRead :\nNote: \nFor GPIOC_PUEN, bits [5:4] and [13:12] are reserved.\nFor GPIOD_PUEN, bits [5:0] and [13:8] are reserved.\nFor GPIOE_PUEN, bits [4:0] and [15:6] are reserved.\nFor GPIOF_PUEN, bits [15:2] are reserved.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/D/E/F] bit [n] pull-up resistor Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/D/E/F] bit [n] pull-up resistor Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PUEN8</name>
              <description>GPIO Port [X] Pin [N] Pull-Up Enable Register\nRead :\nNote: \nFor GPIOC_PUEN, bits [5:4] and [13:12] are reserved.\nFor GPIOD_PUEN, bits [5:0] and [13:8] are reserved.\nFor GPIOE_PUEN, bits [4:0] and [15:6] are reserved.\nFor GPIOF_PUEN, bits [15:2] are reserved.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/D/E/F] bit [n] pull-up resistor Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/D/E/F] bit [n] pull-up resistor Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PUEN9</name>
              <description>GPIO Port [X] Pin [N] Pull-Up Enable Register\nRead :\nNote: \nFor GPIOC_PUEN, bits [5:4] and [13:12] are reserved.\nFor GPIOD_PUEN, bits [5:0] and [13:8] are reserved.\nFor GPIOE_PUEN, bits [4:0] and [15:6] are reserved.\nFor GPIOF_PUEN, bits [15:2] are reserved.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/D/E/F] bit [n] pull-up resistor Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/D/E/F] bit [n] pull-up resistor Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PUEN10</name>
              <description>GPIO Port [X] Pin [N] Pull-Up Enable Register\nRead :\nNote: \nFor GPIOC_PUEN, bits [5:4] and [13:12] are reserved.\nFor GPIOD_PUEN, bits [5:0] and [13:8] are reserved.\nFor GPIOE_PUEN, bits [4:0] and [15:6] are reserved.\nFor GPIOF_PUEN, bits [15:2] are reserved.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/D/E/F] bit [n] pull-up resistor Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/D/E/F] bit [n] pull-up resistor Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PUEN11</name>
              <description>GPIO Port [X] Pin [N] Pull-Up Enable Register\nRead :\nNote: \nFor GPIOC_PUEN, bits [5:4] and [13:12] are reserved.\nFor GPIOD_PUEN, bits [5:0] and [13:8] are reserved.\nFor GPIOE_PUEN, bits [4:0] and [15:6] are reserved.\nFor GPIOF_PUEN, bits [15:2] are reserved.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/D/E/F] bit [n] pull-up resistor Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/D/E/F] bit [n] pull-up resistor Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PUEN12</name>
              <description>GPIO Port [X] Pin [N] Pull-Up Enable Register\nRead :\nNote: \nFor GPIOC_PUEN, bits [5:4] and [13:12] are reserved.\nFor GPIOD_PUEN, bits [5:0] and [13:8] are reserved.\nFor GPIOE_PUEN, bits [4:0] and [15:6] are reserved.\nFor GPIOF_PUEN, bits [15:2] are reserved.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/D/E/F] bit [n] pull-up resistor Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/D/E/F] bit [n] pull-up resistor Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PUEN13</name>
              <description>GPIO Port [X] Pin [N] Pull-Up Enable Register\nRead :\nNote: \nFor GPIOC_PUEN, bits [5:4] and [13:12] are reserved.\nFor GPIOD_PUEN, bits [5:0] and [13:8] are reserved.\nFor GPIOE_PUEN, bits [4:0] and [15:6] are reserved.\nFor GPIOF_PUEN, bits [15:2] are reserved.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/D/E/F] bit [n] pull-up resistor Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/D/E/F] bit [n] pull-up resistor Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PUEN14</name>
              <description>GPIO Port [X] Pin [N] Pull-Up Enable Register\nRead :\nNote: \nFor GPIOC_PUEN, bits [5:4] and [13:12] are reserved.\nFor GPIOD_PUEN, bits [5:0] and [13:8] are reserved.\nFor GPIOE_PUEN, bits [4:0] and [15:6] are reserved.\nFor GPIOF_PUEN, bits [15:2] are reserved.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/D/E/F] bit [n] pull-up resistor Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/D/E/F] bit [n] pull-up resistor Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PUEN15</name>
              <description>GPIO Port [X] Pin [N] Pull-Up Enable Register\nRead :\nNote: \nFor GPIOC_PUEN, bits [5:4] and [13:12] are reserved.\nFor GPIOD_PUEN, bits [5:0] and [13:8] are reserved.\nFor GPIOE_PUEN, bits [4:0] and [15:6] are reserved.\nFor GPIOF_PUEN, bits [15:2] are reserved.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/D/E/F] bit [n] pull-up resistor Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/D/E/F] bit [n] pull-up resistor Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="GPIOA_PMD">
          <name>GPIOB_PMD</name>
          <displayName>GPIOB_PMD</displayName>
          <description>GPIO Port B Pin I/O Mode Control Register</description>
          <addressOffset>0x40</addressOffset>
       </register>
       <register derivedFrom="GPIOA_OFFD">
          <name>GPIOB_OFFD</name>
          <displayName>GPIOB_OFFD</displayName>
          <description>GPIO Port B Pin OFF Digital Enable Register</description>
          <addressOffset>0x44</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DOUT">
          <name>GPIOB_DOUT</name>
          <displayName>GPIOB_DOUT</displayName>
          <description>GPIO Port B Data Output Value Register</description>
          <addressOffset>0x48</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DMASK">
          <name>GPIOB_DMASK</name>
          <displayName>GPIOB_DMASK</displayName>
          <description>GPIO Port B Data Output Write Mask Register</description>
          <addressOffset>0x4C</addressOffset>
       </register>
       <register derivedFrom="GPIOA_PIN">
          <name>GPIOB_PIN</name>
          <displayName>GPIOB_PIN</displayName>
          <description>GPIO Port B Pin Value Register</description>
          <addressOffset>0x50</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DBEN">
          <name>GPIOB_DBEN</name>
          <displayName>GPIOB_DBEN</displayName>
          <description>GPIO Port B De-bounce Enable Register</description>
          <addressOffset>0x54</addressOffset>
       </register>
       <register derivedFrom="GPIOA_IMD">
          <name>GPIOB_IMD</name>
          <displayName>GPIOB_IMD</displayName>
          <description>GPIO Port B Interrupt Mode Control Register</description>
          <addressOffset>0x58</addressOffset>
       </register>
       <register derivedFrom="GPIOA_IER">
          <name>GPIOB_IER</name>
          <displayName>GPIOB_IER</displayName>
          <description>GPIO Port B Interrupt Enable Register</description>
          <addressOffset>0x5C</addressOffset>
       </register>
       <register derivedFrom="GPIOA_ISRC">
          <name>GPIOB_ISRC</name>
          <displayName>GPIOB_ISRC</displayName>
          <description>GPIO Port B Interrupt Trigger Source Status Register</description>
          <addressOffset>0x60</addressOffset>
       </register>
       <register derivedFrom="GPIOA_PUEN">
          <name>GPIOB_PUEN</name>
          <displayName>GPIOB_PUEN</displayName>
          <description>GPIO Port B Pull-up Enable Register</description>
          <addressOffset>0x64</addressOffset>
       </register>
       <register derivedFrom="GPIOA_PMD">
          <name>GPIOC_PMD</name>
          <displayName>GPIOC_PMD</displayName>
          <description>GPIO Port C Pin I/O Mode Control Register</description>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="GPIOA_OFFD">
          <name>GPIOC_OFFD</name>
          <displayName>GPIOC_OFFD</displayName>
          <description>GPIO Port C Pin OFF Digital Enable Register</description>
          <addressOffset>0x84</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DOUT">
          <name>GPIOC_DOUT</name>
          <displayName>GPIOC_DOUT</displayName>
          <description>GPIO Port C Data Output Value Register</description>
          <addressOffset>0x88</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DMASK">
          <name>GPIOC_DMASK</name>
          <displayName>GPIOC_DMASK</displayName>
          <description>GPIO Port C Data Output Write Mask Register</description>
          <addressOffset>0x8C</addressOffset>
       </register>
       <register derivedFrom="GPIOA_PIN">
          <name>GPIOC_PIN</name>
          <displayName>GPIOC_PIN</displayName>
          <description>GPIO Port C Pin Value Register</description>
          <addressOffset>0x90</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DBEN">
          <name>GPIOC_DBEN</name>
          <displayName>GPIOC_DBEN</displayName>
          <description>GPIO Port C De-bounce Enable Register</description>
          <addressOffset>0x94</addressOffset>
       </register>
       <register derivedFrom="GPIOA_IMD">
          <name>GPIOC_IMD</name>
          <displayName>GPIOC_IMD</displayName>
          <description>GPIO Port C Interrupt Mode Control Register</description>
          <addressOffset>0x98</addressOffset>
       </register>
       <register derivedFrom="GPIOA_IER">
          <name>GPIOC_IER</name>
          <displayName>GPIOC_IER</displayName>
          <description>GPIO Port C Interrupt Enable Register</description>
          <addressOffset>0x9C</addressOffset>
       </register>
       <register derivedFrom="GPIOA_ISRC">
          <name>GPIOC_ISRC</name>
          <displayName>GPIOC_ISRC</displayName>
          <description>GPIO Port C Interrupt Trigger Source Status Register</description>
          <addressOffset>0xA0</addressOffset>
       </register>
       <register derivedFrom="GPIOA_PUEN">
          <name>GPIOC_PUEN</name>
          <displayName>GPIOC_PUEN</displayName>
          <description>GPIO Port C Pull-up Enable Register</description>
          <addressOffset>0xA4</addressOffset>
       </register>
       <register derivedFrom="GPIOA_PMD">
          <name>GPIOD_PMD</name>
          <displayName>GPIOD_PMD</displayName>
          <description>GPIO Port D Pin I/O Mode Control Register</description>
          <addressOffset>0xC0</addressOffset>
       </register>
       <register derivedFrom="GPIOA_OFFD">
          <name>GPIOD_OFFD</name>
          <displayName>GPIOD_OFFD</displayName>
          <description>GPIO Port D Pin OFF Digital Enable Register</description>
          <addressOffset>0xC4</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DOUT">
          <name>GPIOD_DOUT</name>
          <displayName>GPIOD_DOUT</displayName>
          <description>GPIO Port D Data Output Value Register</description>
          <addressOffset>0xC8</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DMASK">
          <name>GPIOD_DMASK</name>
          <displayName>GPIOD_DMASK</displayName>
          <description>GPIO Port D Data Output Write Mask Register</description>
          <addressOffset>0xCC</addressOffset>
       </register>
       <register derivedFrom="GPIOA_PIN">
          <name>GPIOD_PIN</name>
          <displayName>GPIOD_PIN</displayName>
          <description>GPIO Port D Pin Value Register</description>
          <addressOffset>0xD0</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DBEN">
          <name>GPIOD_DBEN</name>
          <displayName>GPIOD_DBEN</displayName>
          <description>GPIO Port D De-bounce Enable Register</description>
          <addressOffset>0xD4</addressOffset>
       </register>
       <register derivedFrom="GPIOA_IMD">
          <name>GPIOD_IMD</name>
          <displayName>GPIOD_IMD</displayName>
          <description>GPIO Port D Interrupt Mode Control Register</description>
          <addressOffset>0xD8</addressOffset>
       </register>
       <register derivedFrom="GPIOA_IER">
          <name>GPIOD_IER</name>
          <displayName>GPIOD_IER</displayName>
          <description>GPIO Port D Interrupt Enable Register</description>
          <addressOffset>0xDC</addressOffset>
       </register>
       <register derivedFrom="GPIOA_ISRC">
          <name>GPIOD_ISRC</name>
          <displayName>GPIOD_ISRC</displayName>
          <description>GPIO Port D Interrupt Trigger Source Status Register</description>
          <addressOffset>0xE0</addressOffset>
       </register>
       <register derivedFrom="GPIOA_PUEN">
          <name>GPIOD_PUEN</name>
          <displayName>GPIOD_PUEN</displayName>
          <description>GPIO Port D Pull-up Enable Register</description>
          <addressOffset>0xE4</addressOffset>
       </register>
       <register derivedFrom="GPIOA_PMD">
          <name>GPIOE_PMD</name>
          <displayName>GPIOE_PMD</displayName>
          <description>GPIO Port E Pin I/O Mode Control Register</description>
          <addressOffset>0x100</addressOffset>
       </register>
       <register derivedFrom="GPIOA_OFFD">
          <name>GPIOE_OFFD</name>
          <displayName>GPIOE_OFFD</displayName>
          <description>GPIO Port E Pin OFF Digital Enable Register</description>
          <addressOffset>0x104</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DOUT">
          <name>GPIOE_DOUT</name>
          <displayName>GPIOE_DOUT</displayName>
          <description>GPIO Port E Data Output Value Register</description>
          <addressOffset>0x108</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DMASK">
          <name>GPIOE_DMASK</name>
          <displayName>GPIOE_DMASK</displayName>
          <description>GPIO Port E Data Output Write Mask Register</description>
          <addressOffset>0x10C</addressOffset>
       </register>
       <register derivedFrom="GPIOA_PIN">
          <name>GPIOE_PIN</name>
          <displayName>GPIOE_PIN</displayName>
          <description>GPIO Port E Pin Value Register</description>
          <addressOffset>0x110</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DBEN">
          <name>GPIOE_DBEN</name>
          <displayName>GPIOE_DBEN</displayName>
          <description>GPIO Port E De-bounce Enable Register</description>
          <addressOffset>0x114</addressOffset>
       </register>
       <register derivedFrom="GPIOA_IMD">
          <name>GPIOE_IMD</name>
          <displayName>GPIOE_IMD</displayName>
          <description>GPIO Port E Interrupt Mode Control Register</description>
          <addressOffset>0x118</addressOffset>
       </register>
       <register derivedFrom="GPIOA_IER">
          <name>GPIOE_IER</name>
          <displayName>GPIOE_IER</displayName>
          <description>GPIO Port E Interrupt Enable Register</description>
          <addressOffset>0x11C</addressOffset>
       </register>
       <register derivedFrom="GPIOA_ISRC">
          <name>GPIOE_ISRC</name>
          <displayName>GPIOE_ISRC</displayName>
          <description>GPIO Port E Interrupt Trigger Source Status Register</description>
          <addressOffset>0x120</addressOffset>
       </register>
       <register derivedFrom="GPIOA_PUEN">
          <name>GPIOE_PUEN</name>
          <displayName>GPIOE_PUEN</displayName>
          <description>GPIO Port E Pull-up Enable Register</description>
          <addressOffset>0x124</addressOffset>
       </register>
       <register derivedFrom="GPIOA_PMD">
          <name>GPIOF_PMD</name>
          <displayName>GPIOF_PMD</displayName>
          <description>GPIO Port F Pin I/O Mode Control Register</description>
          <addressOffset>0x140</addressOffset>
       </register>
       <register derivedFrom="GPIOA_OFFD">
          <name>GPIOF_OFFD</name>
          <displayName>GPIOF_OFFD</displayName>
          <description>GPIO Port F Pin OFF Digital Enable Register</description>
          <addressOffset>0x144</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DOUT">
          <name>GPIOF_DOUT</name>
          <displayName>GPIOF_DOUT</displayName>
          <description>GPIO Port F Data Output Value Register</description>
          <addressOffset>0x148</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DMASK">
          <name>GPIOF_DMASK</name>
          <displayName>GPIOF_DMASK</displayName>
          <description>GPIO Port F Data Output Write Mask Register</description>
          <addressOffset>0x14C</addressOffset>
       </register>
       <register derivedFrom="GPIOA_PIN">
          <name>GPIOF_PIN</name>
          <displayName>GPIOF_PIN</displayName>
          <description>GPIO Port F Pin Value Register</description>
          <addressOffset>0x150</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DBEN">
          <name>GPIOF_DBEN</name>
          <displayName>GPIOF_DBEN</displayName>
          <description>GPIO Port F De-bounce Enable Register</description>
          <addressOffset>0x154</addressOffset>
       </register>
       <register derivedFrom="GPIOA_IMD">
          <name>GPIOF_IMD</name>
          <displayName>GPIOF_IMD</displayName>
          <description>GPIO Port F Interrupt Mode Control Register</description>
          <addressOffset>0x158</addressOffset>
       </register>
       <register derivedFrom="GPIOA_IER">
          <name>GPIOF_IER</name>
          <displayName>GPIOF_IER</displayName>
          <description>GPIO Port F Interrupt Enable Register</description>
          <addressOffset>0x15C</addressOffset>
       </register>
       <register derivedFrom="GPIOA_ISRC">
          <name>GPIOF_ISRC</name>
          <displayName>GPIOF_ISRC</displayName>
          <description>GPIO Port F Interrupt Trigger Source Status Register</description>
          <addressOffset>0x160</addressOffset>
       </register>
       <register derivedFrom="GPIOA_PUEN">
          <name>GPIOF_PUEN</name>
          <displayName>GPIOF_PUEN</displayName>
          <description>GPIO Port F Pull-up Enable Register</description>
          <addressOffset>0x164</addressOffset>
       </register>
       <register>
          <name>DBNCECON</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>DBNCECON</displayName>
          <description>De-bounce Cycle Control Register</description>
          <addressOffset>0x180</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DBCLKSEL</name>
              <description>De-Bounce Sampling Cycle Selection\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Sample interrupt input once per 1 clock</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Sample interrupt input once per 2 clocks</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Sample interrupt input once per 4 clocks</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Sample interrupt input once per 8 clocks</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>Sample interrupt input once per 16 clocks</description>
                    <value>#0100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Sample interrupt input once per 32 clocks</description>
                    <value>#0101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Sample interrupt input once per 64 clocks</description>
                    <value>#0110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Sample interrupt input once per 128 clocks</description>
                    <value>#0111</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>8</name>
                    <description>Sample interrupt input once per 256 clocks</description>
                    <value>#1000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>9</name>
                    <description>Sample interrupt input once per 2*256 clocks</description>
                    <value>#1001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>10</name>
                    <description>Sample interrupt input once per 4*256clocks</description>
                    <value>#1010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>11</name>
                    <description>Sample interrupt input once per 8*256 clocks</description>
                    <value>#1011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>12</name>
                    <description>Sample interrupt input once per 16*256 clocks</description>
                    <value>#1100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>13</name>
                    <description>Sample interrupt input once per 32*256 clocks</description>
                    <value>#1101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>14</name>
                    <description>Sample interrupt input once per 64*256 clocks</description>
                    <value>#1110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>15</name>
                    <description>Sample interrupt input once per 128*256 clocks</description>
                    <value>#1111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBCLKSRC</name>
              <description>De-Bounce Counter Clock Source Selection\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>De-bounce counter Clock Source is the HCLK</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>De-bounce counter Clock Source is the internal 10 kHz clock</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBCLK_ON</name>
              <description>De-Bounce Clock Enable\nThis bit controls if the de-bounce clock is enabled.\nHowever, if GPIO pin's interrupt is enabled, the de-bounce clock will be enabled automatically no matter what the DBCLK_ON value is.\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>De-bounce clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>De-bounce clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPIOA0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPIOA0</displayName>
          <description>GPIO Port A Bit 0 Data Register</description>
          <addressOffset>0x200</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFF0</resetMask>
          <fields>
            <field>
              <name>GPIO</name>
              <description>GPIO Port [X] Pin [N] I/O Data\nThis field supports the bit operation mode on related GPIO port [x] pin [n].\nWriting this filed to set the corresponding GPIO port [x] pin [n] output value while reading this field to get the corresponding GPIO port [x] pin [n] value.\nRead:\nNote: The write operation will not be affected by register GPIOx_DMASK.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The corresponding GPIO port [x] pin [n] value is low.\nSet corresponding GPIO port [x] pin [n] to low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The corresponding GPIO port [x] pin [n] value is high.\nSet corresponding GPIO port [x] pin [n] to high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOA1</name>
          <displayName>GPIOA1</displayName>
          <description>GPIO Port A Bit 1 Data Register</description>
          <addressOffset>0x204</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOA2</name>
          <displayName>GPIOA2</displayName>
          <description>GPIO Port A Bit 2 Data Register</description>
          <addressOffset>0x208</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOA3</name>
          <displayName>GPIOA3</displayName>
          <description>GPIO Port A Bit 3 Data Register</description>
          <addressOffset>0x20C</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOA4</name>
          <displayName>GPIOA4</displayName>
          <description>GPIO Port A Bit 4 Data Register</description>
          <addressOffset>0x210</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOA5</name>
          <displayName>GPIOA5</displayName>
          <description>GPIO Port A Bit 5 Data Register</description>
          <addressOffset>0x214</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOA6</name>
          <displayName>GPIOA6</displayName>
          <description>GPIO Port A Bit 6 Data Register</description>
          <addressOffset>0x218</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOA7</name>
          <displayName>GPIOA7</displayName>
          <description>GPIO Port A Bit 7 Data Register</description>
          <addressOffset>0x21C</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOA8</name>
          <displayName>GPIOA8</displayName>
          <description>GPIO Port A Bit 8 Data Register</description>
          <addressOffset>0x220</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOA9</name>
          <displayName>GPIOA9</displayName>
          <description>GPIO Port A Bit 9 Data Register</description>
          <addressOffset>0x224</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOA10</name>
          <displayName>GPIOA10</displayName>
          <description>GPIO Port A Bit 10 Data Register</description>
          <addressOffset>0x228</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOA11</name>
          <displayName>GPIOA11</displayName>
          <description>GPIO Port A Bit 11 Data Register</description>
          <addressOffset>0x22C</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOA12</name>
          <displayName>GPIOA12</displayName>
          <description>GPIO Port A Bit 12 Data Register</description>
          <addressOffset>0x230</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOA13</name>
          <displayName>GPIOA13</displayName>
          <description>GPIO Port A Bit 13 Data Register</description>
          <addressOffset>0x234</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOA14</name>
          <displayName>GPIOA14</displayName>
          <description>GPIO Port A Bit 14 Data Register</description>
          <addressOffset>0x238</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOA15</name>
          <displayName>GPIOA15</displayName>
          <description>GPIO Port A Bit 15 Data Register</description>
          <addressOffset>0x23C</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOB0</name>
          <displayName>GPIOB0</displayName>
          <description>GPIO Port B Bit 0 Data Register</description>
          <addressOffset>0x240</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOB1</name>
          <displayName>GPIOB1</displayName>
          <description>GPIO Port B Bit 1 Data Register</description>
          <addressOffset>0x244</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOB2</name>
          <displayName>GPIOB2</displayName>
          <description>GPIO Port B Bit 2 Data Register</description>
          <addressOffset>0x248</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOB3</name>
          <displayName>GPIOB3</displayName>
          <description>GPIO Port B Bit 3 Data Register</description>
          <addressOffset>0x24C</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOB4</name>
          <displayName>GPIOB4</displayName>
          <description>GPIO Port B Bit 4 Data Register</description>
          <addressOffset>0x250</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOB5</name>
          <displayName>GPIOB5</displayName>
          <description>GPIO Port B Bit 5 Data Register</description>
          <addressOffset>0x254</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOB6</name>
          <displayName>GPIOB6</displayName>
          <description>GPIO Port B Bit 6 Data Register</description>
          <addressOffset>0x258</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOB7</name>
          <displayName>GPIOB7</displayName>
          <description>GPIO Port B Bit 7 Data Register</description>
          <addressOffset>0x25C</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOB8</name>
          <displayName>GPIOB8</displayName>
          <description>GPIO Port B Bit 8 Data Register</description>
          <addressOffset>0x260</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOB9</name>
          <displayName>GPIOB9</displayName>
          <description>GPIO Port B Bit 9 Data Register</description>
          <addressOffset>0x264</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOB10</name>
          <displayName>GPIOB10</displayName>
          <description>GPIO Port B Bit 10 Data Register</description>
          <addressOffset>0x268</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOB11</name>
          <displayName>GPIOB11</displayName>
          <description>GPIO Port B Bit 11 Data Register</description>
          <addressOffset>0x26C</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOB12</name>
          <displayName>GPIOB12</displayName>
          <description>GPIO Port B Bit 12 Data Register</description>
          <addressOffset>0x270</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOB13</name>
          <displayName>GPIOB13</displayName>
          <description>GPIO Port B Bit 13 Data Register</description>
          <addressOffset>0x274</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOB14</name>
          <displayName>GPIOB14</displayName>
          <description>GPIO Port B Bit 14 Data Register</description>
          <addressOffset>0x278</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOB15</name>
          <displayName>GPIOB15</displayName>
          <description>GPIO Port B Bit 15 Data Register</description>
          <addressOffset>0x27C</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOC0</name>
          <displayName>GPIOC0</displayName>
          <description>GPIO Port C Bit 0 Data Register</description>
          <addressOffset>0x280</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOC1</name>
          <displayName>GPIOC1</displayName>
          <description>GPIO Port C Bit 1 Data Register</description>
          <addressOffset>0x284</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOC2</name>
          <displayName>GPIOC2</displayName>
          <description>GPIO Port C Bit 2 Data Register</description>
          <addressOffset>0x288</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOC3</name>
          <displayName>GPIOC3</displayName>
          <description>GPIO Port C Bit 3 Data Register</description>
          <addressOffset>0x28C</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOC4</name>
          <displayName>GPIOC4</displayName>
          <description>GPIO Port C Bit 4 Data Register</description>
          <addressOffset>0x290</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOC5</name>
          <displayName>GPIOC5</displayName>
          <description>GPIO Port C Bit 5 Data Register</description>
          <addressOffset>0x294</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOC6</name>
          <displayName>GPIOC6</displayName>
          <description>GPIO Port C Bit 6 Data Register</description>
          <addressOffset>0x298</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOC7</name>
          <displayName>GPIOC7</displayName>
          <description>GPIO Port C Bit 7 Data Register</description>
          <addressOffset>0x29C</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOC8</name>
          <displayName>GPIOC8</displayName>
          <description>GPIO Port C Bit 8 Data Register</description>
          <addressOffset>0x2A0</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOC9</name>
          <displayName>GPIOC9</displayName>
          <description>GPIO Port C Bit 9 Data Register</description>
          <addressOffset>0x2A4</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOC10</name>
          <displayName>GPIOC10</displayName>
          <description>GPIO Port C Bit 10 Data Register</description>
          <addressOffset>0x2A8</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOC11</name>
          <displayName>GPIOC11</displayName>
          <description>GPIO Port C Bit 11 Data Register</description>
          <addressOffset>0x2AC</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOC12</name>
          <displayName>GPIOC12</displayName>
          <description>GPIO Port C Bit 12 Data Register</description>
          <addressOffset>0x2B0</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOC13</name>
          <displayName>GPIOC13</displayName>
          <description>GPIO Port C Bit 13 Data Register</description>
          <addressOffset>0x2B4</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOC14</name>
          <displayName>GPIOC14</displayName>
          <description>GPIO Port C Bit 14 Data Register</description>
          <addressOffset>0x2B8</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOC15</name>
          <displayName>GPIOC15</displayName>
          <description>GPIO Port C Bit 15 Data Register</description>
          <addressOffset>0x2BC</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOD0</name>
          <displayName>GPIOD0</displayName>
          <description>GPIO Port D Bit 0 Data Register</description>
          <addressOffset>0x2C0</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOD1</name>
          <displayName>GPIOD1</displayName>
          <description>GPIO Port D Bit 1 Data Register</description>
          <addressOffset>0x2C4</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOD2</name>
          <displayName>GPIOD2</displayName>
          <description>GPIO Port D Bit 2 Data Register</description>
          <addressOffset>0x2C8</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOD3</name>
          <displayName>GPIOD3</displayName>
          <description>GPIO Port D Bit 3 Data Register</description>
          <addressOffset>0x2CC</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOD4</name>
          <displayName>GPIOD4</displayName>
          <description>GPIO Port D Bit 4 Data Register</description>
          <addressOffset>0x2D0</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOD5</name>
          <displayName>GPIOD5</displayName>
          <description>GPIO Port D Bit 5 Data Register</description>
          <addressOffset>0x2D4</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOD6</name>
          <displayName>GPIOD6</displayName>
          <description>GPIO Port D Bit 6 Data Register</description>
          <addressOffset>0x2D8</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOD7</name>
          <displayName>GPIOD7</displayName>
          <description>GPIO Port D Bit 7 Data Register</description>
          <addressOffset>0x2DC</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOD8</name>
          <displayName>GPIOD8</displayName>
          <description>GPIO Port D Bit 8 Data Register</description>
          <addressOffset>0x2E0</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOD9</name>
          <displayName>GPIOD9</displayName>
          <description>GPIO Port D Bit 9 Data Register</description>
          <addressOffset>0x2E4</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOD10</name>
          <displayName>GPIOD10</displayName>
          <description>GPIO Port D Bit 10 Data Register</description>
          <addressOffset>0x2E8</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOD11</name>
          <displayName>GPIOD11</displayName>
          <description>GPIO Port D Bit 11 Data Register</description>
          <addressOffset>0x2EC</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOD12</name>
          <displayName>GPIOD12</displayName>
          <description>GPIO Port D Bit 12 Data Register</description>
          <addressOffset>0x2F0</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOD13</name>
          <displayName>GPIOD13</displayName>
          <description>GPIO Port D Bit 13 Data Register</description>
          <addressOffset>0x2F4</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOD14</name>
          <displayName>GPIOD14</displayName>
          <description>GPIO Port D Bit 14 Data Register</description>
          <addressOffset>0x2F8</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOD15</name>
          <displayName>GPIOD15</displayName>
          <description>GPIO Port D Bit 15 Data Register</description>
          <addressOffset>0x2FC</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOE0</name>
          <displayName>GPIOE0</displayName>
          <description>GPIO Port E Bit 0 Data Register</description>
          <addressOffset>0x300</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOE1</name>
          <displayName>GPIOE1</displayName>
          <description>GPIO Port E Bit 1 Data Register</description>
          <addressOffset>0x304</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOE2</name>
          <displayName>GPIOE2</displayName>
          <description>GPIO Port E Bit 2 Data Register</description>
          <addressOffset>0x308</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOE3</name>
          <displayName>GPIOE3</displayName>
          <description>GPIO Port E Bit 3 Data Register</description>
          <addressOffset>0x30C</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOE4</name>
          <displayName>GPIOE4</displayName>
          <description>GPIO Port E Bit 4 Data Register</description>
          <addressOffset>0x310</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOE5</name>
          <displayName>GPIOE5</displayName>
          <description>GPIO Port E Bit 5 Data Register</description>
          <addressOffset>0x314</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOE6</name>
          <displayName>GPIOE6</displayName>
          <description>GPIO Port E Bit 6 Data Register</description>
          <addressOffset>0x318</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOE7</name>
          <displayName>GPIOE7</displayName>
          <description>GPIO Port E Bit 7 Data Register</description>
          <addressOffset>0x31C</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOE8</name>
          <displayName>GPIOE8</displayName>
          <description>GPIO Port E Bit 8 Data Register</description>
          <addressOffset>0x320</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOE9</name>
          <displayName>GPIOE9</displayName>
          <description>GPIO Port E Bit 9 Data Register</description>
          <addressOffset>0x324</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOE10</name>
          <displayName>GPIOE10</displayName>
          <description>GPIO Port E Bit 10 Data Register</description>
          <addressOffset>0x328</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOE11</name>
          <displayName>GPIOE11</displayName>
          <description>GPIO Port E Bit 11 Data Register</description>
          <addressOffset>0x32C</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOE12</name>
          <displayName>GPIOE12</displayName>
          <description>GPIO Port E Bit 12 Data Register</description>
          <addressOffset>0x330</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOE13</name>
          <displayName>GPIOE13</displayName>
          <description>GPIO Port E Bit 13 Data Register</description>
          <addressOffset>0x334</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOE14</name>
          <displayName>GPIOE14</displayName>
          <description>GPIO Port E Bit 14 Data Register</description>
          <addressOffset>0x338</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOE15</name>
          <displayName>GPIOE15</displayName>
          <description>GPIO Port E Bit 15 Data Register</description>
          <addressOffset>0x33C</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOF0</name>
          <displayName>GPIOF0</displayName>
          <description>GPIO Port F Bit 0 Data Register</description>
          <addressOffset>0x340</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOF1</name>
          <displayName>GPIOF1</displayName>
          <description>GPIO Port F Bit 1 Data Register</description>
          <addressOffset>0x344</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOF2</name>
          <displayName>GPIOF2</displayName>
          <description>GPIO Port F Bit 2 Data Register</description>
          <addressOffset>0x348</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOF3</name>
          <displayName>GPIOF3</displayName>
          <description>GPIO Port F Bit 3 Data Register</description>
          <addressOffset>0x34C</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOF4</name>
          <displayName>GPIOF4</displayName>
          <description>GPIO Port F Bit 4 Data Register</description>
          <addressOffset>0x350</addressOffset>
       </register>
       <register derivedFrom="GPIOA0">
          <name>GPIOF5</name>
          <displayName>GPIOF5</displayName>
          <description>GPIO Port F Bit 5 Data Register</description>
          <addressOffset>0x354</addressOffset>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>DMA_GCR</name>
      <description>VDMA Register Map</description>
      <groupName>VDMA</groupName>
      <baseAddress>0x50008F00</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x10</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>DMA_GCRCSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>DMA_GCRCSR</displayName>
          <description>DMA Global Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLK0_EN</name>
              <description>DMA Controller Channel 0 Clock Enable Control\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK1_EN</name>
              <description>DMA Controller Channel 1 Clock Enable Control\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK2_EN</name>
              <description>DMA Controller Channel 2 Clock Enable Control\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK3_EN</name>
              <description>DMA Controller Channel 3 Clock Enable Control\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK4_EN</name>
              <description>DMA Controller Channel 4 Clock Enable Control\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>DMA_DSSR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>DMA_DSSR0</displayName>
          <description>DMA Service Selection Control Register 0</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x1F1F1F00</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH1_SEL</name>
              <description>Channel 1 Selection \nThis filed defines which peripheral is connected to PDMA channel 1. User can configure the peripheral by setting CH1_SEL.\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Connect to SPI0_TX</description>
                    <value>#00000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Connect to SPI1_TX</description>
                    <value>#00001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Connect to UART0_TX</description>
                    <value>#00010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Connect to UART1_TX</description>
                    <value>#00011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>Connect to  USB_TX</description>
                    <value>#00100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Connect to I2S_TX</description>
                    <value>#00101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Reserved</description>
                    <value>#00110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Reserved</description>
                    <value>#00111</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>8</name>
                    <description>Connect to SPI2_TX</description>
                    <value>#01000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>9</name>
                    <description>Connect to TMR0 CH0</description>
                    <value>#01001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>10</name>
                    <description>Connect to TMR0 CH1</description>
                    <value>#01010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>11</name>
                    <description>Connect to TMR1 CH0</description>
                    <value>#01011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>12</name>
                    <description>Connect to TMR1 CH1</description>
                    <value>#01100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>16</name>
                    <description>Connect to SPI0_RX</description>
                    <value>#10000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>17</name>
                    <description>Connect to SPI1_RX</description>
                    <value>#10001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>18</name>
                    <description>Connect to UART0_RX</description>
                    <value>#10010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>19</name>
                    <description>Connect to UART1_RX</description>
                    <value>#10011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>20</name>
                    <description>Connect to USB_RX</description>
                    <value>#10100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>21</name>
                    <description>Connect to I2S_RX</description>
                    <value>#10101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>22</name>
                    <description>Connect to ADC</description>
                    <value>#10110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>23</name>
                    <description>Reserved</description>
                    <value>#10111</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>24</name>
                    <description>Connect to SPI2_RX</description>
                    <value>#11000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>25</name>
                    <description>Connect to PWM0_CH0</description>
                    <value>#11001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>26</name>
                    <description>Connect to PWM0_CH2</description>
                    <value>#11010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>27</name>
                    <description>Connect to PWM1_CH0</description>
                    <value>#11011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>28</name>
                    <description>Connect to PWM1_CH2</description>
                    <value>#11100</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH2_SEL</name>
              <description>Channel 2 Selection \nThis filed defines which peripheral is connected to PDMA channel 2. User can configure the peripheral setting by CH2_SEL. The channel configuration is the same as CH1_SEL field. Please refer to the explanation of CH1_SEL.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH3_SEL</name>
              <description>Channel 3 Selection \nThis filed defines which peripheral is connected to PDMA channel 3. User can configure the peripheral setting by CH3_SEL. The channel configuration is the same as CH1_SEL field. Please refer to the explanation of CH1_SEL.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>DMA_DSSR1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>DMA_DSSR1</displayName>
          <description>DMA Service Selection Control Register 1</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x0000001F</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH4_SEL</name>
              <description>Channel 4 Selection \nThis filed defines which peripheral is connected to PDMA channel 4. User can configure the peripheral by setting CH4_SEL.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Connect to SPI0_TX</description>
                    <value>#00000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Connect to SPI1_TX</description>
                    <value>#00001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Connect to UART0_TX</description>
                    <value>#00010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Connect to UART1_TX</description>
                    <value>#00011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>Connect to  USB_TX</description>
                    <value>#00100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Connect to I2S_TX</description>
                    <value>#00101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Reserved</description>
                    <value>#00110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Reserved</description>
                    <value>#00111</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>8</name>
                    <description>Connect to SPI2_TX</description>
                    <value>#01000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>9</name>
                    <description>Connect to TMR0 CH0</description>
                    <value>#01001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>10</name>
                    <description>Connect to TMR0 CH1</description>
                    <value>#01010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>11</name>
                    <description>Connect to TMR1 CH0</description>
                    <value>#01011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>12</name>
                    <description>Connect to TMR1 CH1</description>
                    <value>#01100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>16</name>
                    <description>Connect to SPI0_RX</description>
                    <value>#10000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>17</name>
                    <description>Connect to SPI1_RX</description>
                    <value>#10001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>18</name>
                    <description>Connect to UART0_RX</description>
                    <value>#10010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>19</name>
                    <description>Connect to UART1_RX</description>
                    <value>#10011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>20</name>
                    <description>Connect to USB_RX</description>
                    <value>#10100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>21</name>
                    <description>Connect to I2S_RX</description>
                    <value>#10101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>22</name>
                    <description>Connect to ADC</description>
                    <value>#10110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>23</name>
                    <description>Reserved</description>
                    <value>#10111</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>24</name>
                    <description>Connect to SPI2_RX</description>
                    <value>#11000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>25</name>
                    <description>Connect to PWM0_CH0</description>
                    <value>#11001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>26</name>
                    <description>Connect to PWM0_CH2</description>
                    <value>#11010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>27</name>
                    <description>Connect to PWM1_CH0</description>
                    <value>#11011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>28</name>
                    <description>Connect to PWM1_CH2</description>
                    <value>#11100</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>DMA_GCRISR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>DMA_GCRISR</displayName>
          <description>DMA Global Interrupt Status Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INTR0</name>
              <description>Interrupt Status Of Channel 0 (Read Only)\nThis bit is the Interrupt status of DMA channel 0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>INTR1</name>
              <description>Interrupt Status Of Channel 1 (Read Only)\nThis bit is the Interrupt status of DMA channel 1.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>INTR2</name>
              <description>Interrupt Status Of Channel 2 (Read Only)\nThis bit is the Interrupt status of DMA channel 2.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>INTR3</name>
              <description>Interrupt Status Of Channel 3 (Read Only)\nThis bit is the Interrupt status of DMA channel 3.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>INTR4</name>
              <description>Interrupt Status Of Channel 4 (Read Only)\nThis bit is the Interrupt status of DMA channel 4.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>VDMA</name>
      <description>VDMA Register Map</description>
      <groupName>VDMA</groupName>
      <baseAddress>0x50008000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x10</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x14</offset>
        <size>0x14</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x2C</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x80</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>VDMA_CSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>VDMA_CSR</displayName>
          <description>VDMA Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VDMACEN</name>
              <description>VDMA Channel Enable Control\nSetting this bit to "1" enables VDMA's operation. If this bit is cleared, VDMA will ignore all VDMA request and force Bus Master into IDLE state.\nNote: SW_RST will clear this bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_RST</name>
              <description>Software Engine Reset\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the internal state machine and pointers. The contents of control register will not be cleared. This bit will be automatically cleared after few clock cycles</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>STRIDE_EN</name>
              <description>Stride Mode Enable Control\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Stride transfer mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Stride transfer mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DIR_SEL</name>
              <description>Transfer Source/Destination Address Direction Selection\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer address is incremented successively</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transfer address is decremented successively</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIG_EN</name>
              <description>Trigger Enable Control\nNote: When VDMA transfer is completed, this bit will be cleared automatically.\nIf the bus error occurs, all VDMA transfer will be stopped. User must reset all VDMA channel, and then trigger again.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>VDMA data read or write transfer Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>VDMA_SAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>VDMA_SAR</displayName>
          <description>VDMA Source Address Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VDMA_SAR</name>
              <description>VDMA Transfer Source Address Bits\nThis field indicates a 32-bit source address of VDMA.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>VDMA_DAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>VDMA_DAR</displayName>
          <description>VDMA Destination Address Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VDMA_DAR</name>
              <description>VDMA Transfer Destination Address Bits\nThis field indicates a 32-bit destination address of VDMA.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>VDMA_BCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>VDMA_BCR</displayName>
          <description>VDMA Transfer Byte Count Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VDMA_BCR</name>
              <description>VDMA Transfer Byte Count Bits\nThis field indicates a 16-bit transfer byte count number of VDMA.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>VDMA_CSAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>VDMA_CSAR</displayName>
          <description>VDMA Current Source Address Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VDMA_CSAR</name>
              <description>VDMA Current Source Address Bits (Read Only)\nThis field indicates the source address where the VDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>VDMA_CDAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>VDMA_CDAR</displayName>
          <description>VDMA Current Destination Address Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VDMA_CDAR</name>
              <description>VDMA Current Destination Address Bits (Read Only)\nThis field indicates the destination address where the VDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>VDMA_CBCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>VDMA_CBCR</displayName>
          <description>VDMA Current Transfer Byte Count Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VDMA_CBCR</name>
              <description>VDMA Current Byte Count Bits (Read Only)\nThis field indicates the current remained byte count of VDMA.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>VDMA_IER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>VDMA_IER</displayName>
          <description>VDMA Interrupt Enable Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IE</name>
              <description>VDMA Read/Write Target Abort Interrupt Enable Control\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Target abort interrupt generation Disabled during VDMA transfer</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Target abort interrupt generation Enabled during VDMA transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TD_IE</name>
              <description>VDMA Transfer Done Interrupt Enable Control\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Iinterrupt generator Disabled during VDMA transfer done</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt generator Enabled during VDMA transfer done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>VDMA_ISR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>VDMA_ISR</displayName>
          <description>VDMA Interrupt Status Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IS</name>
              <description>VDMA Read/Write Target Abort Interrupt Status Flag\nNote1: This bit is cleared by writing "1" to it.\nNote2: This bit indicates bus master received ERROR response or not, if bus master received occur it means that target abort is happened. VDMA controller will stop transfer and respond this event to user then go to IDLE state. When target abort occurred, user must reset VDMA controller, and then transfer those data again.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No bus ERROR response received</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bus ERROR response received</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TD_IS</name>
              <description>Transfer Done Interrupt Status Flag\nThis bit indicates that VDMA has finished all transfer. \n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Not finished yet</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Done. Note: This bit is cleared by writing "1" to it</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>VDMA_SASOCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>VDMA_SASOCR</displayName>
          <description>VDMA Source Address Stride Offset Register</description>
          <addressOffset>0x2C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SASTOBL</name>
              <description>VDMA Source Address Stride Offset Byte Length\nThe 16-bit register defines the source address stride transfer offset count of each row.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STBC</name>
              <description>VDMA Stride Transfer Byte Count\nThe 16-bit register defines the stride transfer byte count of each row.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>VDMA_DASOCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>VDMA_DASOCR</displayName>
          <description>VDMA Destination Address Stride Offset Register</description>
          <addressOffset>0x30</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DASTOBL</name>
              <description>VDMA Destination Address Stride Offset Byte Length\nThe 16-bit register defines the destination address stride transfer offset count of each row.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>VDMA_BUF0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>VDMA_BUF0</displayName>
          <description>VDMA Internal Buffer FIFO 0</description>
          <addressOffset>0x80</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VDMA_BUF0</name>
              <description>VDMA Internal Buffer FIFO 0 (Read Only)\nVDMA channel has its own 2 words internal buffer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>VDMA_BUF1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>VDMA_BUF1</displayName>
          <description>VDMA Internal Buffer FIFO 1</description>
          <addressOffset>0x84</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VDMA_BUF1</name>
              <description>VDMA Internal Buffer FIFO 1 (Read Only)\nVDMA channel has its own 2 words internal buffer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PDMA_CH1</name>
      <description>VDMA Register Map</description>
      <groupName>VDMA</groupName>
      <baseAddress>0x50008100</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x10</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x14</offset>
        <size>0x18</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x80</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>PDMA_CSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CSR</displayName>
          <description>PDMA Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMACEN</name>
              <description>PDMA Channel Enable Control\nSetting this bit to "1" enables PDMA operation. If this bit is cleared, PDMA will ignore all PDMA request and force Bus Master into IDLE state.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_RST</name>
              <description>Software Engine Reset\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the internal state machine and pointers. The contents of control register will not be cleared. This bit will be automatically cleared after few clock cycles</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE_SEL</name>
              <description>PDMA Mode Selection\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Memory to Memory mode (Memory-to-Memory)</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Peripheral to Memory mode (Peripheral-to-Memory)</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Memory to Peripheral mode (Memory-to-Peripheral)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SAD_SEL</name>
              <description>Transfer Source Address Direction Selection\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer Source address is incremented successively</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer Source address is fixed (This feature can be used when data where transferred from a single source to multiple destinations)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Transfer Source address is wrap around (When the PDMA_CBCR is equal to 0, the PDMA_CSAR and PDMA_CBCR register will be updated by PDMA_SAR and PDMA_BCR automatically. PDMA will start another transfer without user trigger until PDMA_EN disabled. When the PDMA_EN is disabled, the PDMA will complete the active transfer but the remained data which in the PDMA_BUF will not transfer to destination address)</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DAD_SEL</name>
              <description>Transfer Destination Address Direction Selection\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer Destination address is incremented successively</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer Destination address is fixed (This feature can be used when data where transferred from multiple sources to a single destination)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Transfer Destination address is wrapped around (When the PDMA_CBCR is equal to 0, the PDMA_CDAR and PDMA_CBCR register will be updated by PDMA_DAR and PDMA_BCR automatically. PDMA will start another transfer without user trigger until PDMA_EN disabled. When the PDMA_EN is disabled, the PDMA will complete the active transfer but the remained data which in the PDMA_BUF will not transfer to destination address)</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TO_EN</name>
              <description>Time-Out Enable Control\nThis bit will enable PDMA internal Counter. While this counter counts to zero, the TO_IS will be set.\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PDMA internal counter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PDMA internal counter Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>APB_TWS</name>
              <description>Peripheral Transfer Width Selection\nNote: This field is meaningful only when MODE_SEL is Peripheral to Memory mode (Peripheral-to-Memory) or Memory to Peripheral mode (Memory-to-Peripheral).</description>
              <bitOffset>19</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One word (32-bit) is transferred for every PDMA operation</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>One byte (8-bit) is transferred for every PDMA operation</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>One half-word (16-bit) is transferred for every PDMA operation</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIG_EN</name>
              <description>Trigger Enable Control\nNote: When PDMA transfer completed, this bit will be cleared automatically.\nIf the bus error occurs, all PDMA transfer will be stopped. User must reset all PDMA channel, and then trigger again.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PDMA data read or write transfer Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_SAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_SAR</displayName>
          <description>PDMA Source Address Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_SAR</name>
              <description>PDMA Transfer Source Address Bits\nThis field indicates a 32-bit source address of PDMA.\nNote: The source address must be word alignment.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_DAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_DAR</displayName>
          <description>PDMA Destination Address Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_DAR</name>
              <description>PDMA Transfer Destination Address Bits\nThis field indicates a 32-bit destination address of PDMA.\nNote : The destination address must be word alignment</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_BCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_BCR</displayName>
          <description>PDMA Transfer Byte Count Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_BCR</name>
              <description>PDMA Transfer Byte Count Bits\nThis field indicates a 16-bit transfer byte count of PDMA.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_CSAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CSAR</displayName>
          <description>PDMA Current Source Address Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CSAR</name>
              <description>PDMA Current Source Address Bits (Read Only)\nThis field indicates the source address where the PDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_CDAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CDAR</displayName>
          <description>PDMA Current Destination Address Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CDAR</name>
              <description>PDMA Current Destination Address Bits (Read Only)\nThis field indicates the destination address where the PDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_CBCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CBCR</displayName>
          <description>PDMA Current Transfer Byte Count Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CBCR</name>
              <description>PDMA Current Byte Count Bits (Read Only)\nThis field indicates the current remained byte count of PDMA.\nNote: This field will be changed when PDMA finishes data transfer (data transfer to destination address).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_IER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_IER</displayName>
          <description>PDMA Interrupt Enable Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IE</name>
              <description>PDMA Read/Write Target Abort Interrupt Enable Control\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Target abort interrupt generation Disabled during PDMA transfer</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Target abort interrupt generation Enabled during PDMA transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TD_IE</name>
              <description>PDMA Transfer Done Interrupt Enable Control\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt generator Disabled when PDMA transfer is done</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt generator Enabled when PDMA transfer is done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WRA_BCR_IE</name>
              <description>Wrap Around Byte Count Interrupt Enable Control\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt enable of PDMA_CBCR equals 0</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>Interrupt enable of PDMA_CBCR equals 1/2 PDMA_BCR</description>
                    <value>#0100</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TO_IE</name>
              <description>Time-Out Interrupt Enable Control\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Time-out interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time-out interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_ISR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_ISR</displayName>
          <description>PDMA Interrupt Status Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IS</name>
              <description>PDMA Read/Write Target Abort Interrupt Status Flag\nNote1: This bit is cleared by writing "1" to it.\nNote2: This bit indicates bus master received ERROR response or not, if bus master received occur it means that target abort is happened. PDMA controller will stop transfer and respond this event to user then go to IDLE state. When target abort occurred, user must reset PDMA controller, and then transfer those data again.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No bus ERROR response received</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bus ERROR response received</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TD_IS</name>
              <description>Transfer Done Interrupt Status Flag\nThis bit indicates that PDMA has finished all transfer. \nNote: This bit is cleared by writing "1" to it.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Not finished yet</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WRA_BCR_IS</name>
              <description>Wrap Around Transfer Byte Count Interrupt Status Flag\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TO_IS</name>
              <description>Time-Out Interrupt Status Flag\nThis flag indicated that PDMA has waited peripheral request for a period defined by PDMA_TCR.\nNote: This bit is cleared by writing "1" to it.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No time-out flag</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time-out flag</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_TCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_TCR</displayName>
          <description>PDMA Timer Counter Setting Register</description>
          <addressOffset>0x28</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_TCR</name>
              <description>PDMA Timer Count Setting Bits\nEach PDMA channel contains an internal counter. This internal counter will reload and start counting when completing each peripheral request service. The internal counter loads the value of PDAM_TCR and starts counting down when setting TO_EN (PDMA_CSRx[12]). PDMA will request interrupt when this internal counter reaches 0 and TO_IE (PDMA_IERx[6]) is 1.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_BUF</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_BUF</displayName>
          <description>PDMA Internal Buffer FIFO</description>
          <addressOffset>0x80</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_BUF</name>
              <description>PDMA Internal Buffer FIFO (Read Only)\nEach channel has its own 1 word internal buffer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PDMA_CH2</name>
      <description>VDMA Register Map</description>
      <groupName>VDMA</groupName>
      <baseAddress>0x50008200</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x10</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x14</offset>
        <size>0x18</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x80</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>PDMA_CSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CSR</displayName>
          <description>PDMA Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMACEN</name>
              <description>PDMA Channel Enable Control\nSetting this bit to "1" enables PDMA operation. If this bit is cleared, PDMA will ignore all PDMA request and force Bus Master into IDLE state.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_RST</name>
              <description>Software Engine Reset\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the internal state machine and pointers. The contents of control register will not be cleared. This bit will be automatically cleared after few clock cycles</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE_SEL</name>
              <description>PDMA Mode Selection\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Memory to Memory mode (Memory-to-Memory)</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Peripheral to Memory mode (Peripheral-to-Memory)</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Memory to Peripheral mode (Memory-to-Peripheral)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SAD_SEL</name>
              <description>Transfer Source Address Direction Selection\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer Source address is incremented successively</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer Source address is fixed (This feature can be used when data where transferred from a single source to multiple destinations)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Transfer Source address is wrap around (When the PDMA_CBCR is equal to 0, the PDMA_CSAR and PDMA_CBCR register will be updated by PDMA_SAR and PDMA_BCR automatically. PDMA will start another transfer without user trigger until PDMA_EN disabled. When the PDMA_EN is disabled, the PDMA will complete the active transfer but the remained data which in the PDMA_BUF will not transfer to destination address)</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DAD_SEL</name>
              <description>Transfer Destination Address Direction Selection\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer Destination address is incremented successively</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer Destination address is fixed (This feature can be used when data where transferred from multiple sources to a single destination)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Transfer Destination address is wrapped around (When the PDMA_CBCR is equal to 0, the PDMA_CDAR and PDMA_CBCR register will be updated by PDMA_DAR and PDMA_BCR automatically. PDMA will start another transfer without user trigger until PDMA_EN disabled. When the PDMA_EN is disabled, the PDMA will complete the active transfer but the remained data which in the PDMA_BUF will not transfer to destination address)</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TO_EN</name>
              <description>Time-Out Enable Control\nThis bit will enable PDMA internal Counter. While this counter counts to zero, the TO_IS will be set.\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PDMA internal counter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PDMA internal counter Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>APB_TWS</name>
              <description>Peripheral Transfer Width Selection\nNote: This field is meaningful only when MODE_SEL is Peripheral to Memory mode (Peripheral-to-Memory) or Memory to Peripheral mode (Memory-to-Peripheral).</description>
              <bitOffset>19</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One word (32-bit) is transferred for every PDMA operation</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>One byte (8-bit) is transferred for every PDMA operation</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>One half-word (16-bit) is transferred for every PDMA operation</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIG_EN</name>
              <description>Trigger Enable Control\nNote: When PDMA transfer completed, this bit will be cleared automatically.\nIf the bus error occurs, all PDMA transfer will be stopped. User must reset all PDMA channel, and then trigger again.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PDMA data read or write transfer Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_SAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_SAR</displayName>
          <description>PDMA Source Address Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_SAR</name>
              <description>PDMA Transfer Source Address Bits\nThis field indicates a 32-bit source address of PDMA.\nNote: The source address must be word alignment.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_DAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_DAR</displayName>
          <description>PDMA Destination Address Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_DAR</name>
              <description>PDMA Transfer Destination Address Bits\nThis field indicates a 32-bit destination address of PDMA.\nNote : The destination address must be word alignment</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_BCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_BCR</displayName>
          <description>PDMA Transfer Byte Count Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_BCR</name>
              <description>PDMA Transfer Byte Count Bits\nThis field indicates a 16-bit transfer byte count of PDMA.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_CSAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CSAR</displayName>
          <description>PDMA Current Source Address Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CSAR</name>
              <description>PDMA Current Source Address Bits (Read Only)\nThis field indicates the source address where the PDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_CDAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CDAR</displayName>
          <description>PDMA Current Destination Address Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CDAR</name>
              <description>PDMA Current Destination Address Bits (Read Only)\nThis field indicates the destination address where the PDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_CBCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CBCR</displayName>
          <description>PDMA Current Transfer Byte Count Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CBCR</name>
              <description>PDMA Current Byte Count Bits (Read Only)\nThis field indicates the current remained byte count of PDMA.\nNote: This field will be changed when PDMA finishes data transfer (data transfer to destination address).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_IER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_IER</displayName>
          <description>PDMA Interrupt Enable Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IE</name>
              <description>PDMA Read/Write Target Abort Interrupt Enable Control\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Target abort interrupt generation Disabled during PDMA transfer</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Target abort interrupt generation Enabled during PDMA transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TD_IE</name>
              <description>PDMA Transfer Done Interrupt Enable Control\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt generator Disabled when PDMA transfer is done</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt generator Enabled when PDMA transfer is done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WRA_BCR_IE</name>
              <description>Wrap Around Byte Count Interrupt Enable Control\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt enable of PDMA_CBCR equals 0</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>Interrupt enable of PDMA_CBCR equals 1/2 PDMA_BCR</description>
                    <value>#0100</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TO_IE</name>
              <description>Time-Out Interrupt Enable Control\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Time-out interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time-out interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_ISR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_ISR</displayName>
          <description>PDMA Interrupt Status Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IS</name>
              <description>PDMA Read/Write Target Abort Interrupt Status Flag\nNote1: This bit is cleared by writing "1" to it.\nNote2: This bit indicates bus master received ERROR response or not, if bus master received occur it means that target abort is happened. PDMA controller will stop transfer and respond this event to user then go to IDLE state. When target abort occurred, user must reset PDMA controller, and then transfer those data again.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No bus ERROR response received</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bus ERROR response received</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TD_IS</name>
              <description>Transfer Done Interrupt Status Flag\nThis bit indicates that PDMA has finished all transfer. \nNote: This bit is cleared by writing "1" to it.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Not finished yet</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WRA_BCR_IS</name>
              <description>Wrap Around Transfer Byte Count Interrupt Status Flag\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TO_IS</name>
              <description>Time-Out Interrupt Status Flag\nThis flag indicated that PDMA has waited peripheral request for a period defined by PDMA_TCR.\nNote: This bit is cleared by writing "1" to it.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No time-out flag</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time-out flag</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_TCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_TCR</displayName>
          <description>PDMA Timer Counter Setting Register</description>
          <addressOffset>0x28</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_TCR</name>
              <description>PDMA Timer Count Setting Bits\nEach PDMA channel contains an internal counter. This internal counter will reload and start counting when completing each peripheral request service. The internal counter loads the value of PDAM_TCR and starts counting down when setting TO_EN (PDMA_CSRx[12]). PDMA will request interrupt when this internal counter reaches 0 and TO_IE (PDMA_IERx[6]) is 1.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_BUF</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_BUF</displayName>
          <description>PDMA Internal Buffer FIFO</description>
          <addressOffset>0x80</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_BUF</name>
              <description>PDMA Internal Buffer FIFO (Read Only)\nEach channel has its own 1 word internal buffer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PDMA_CH3</name>
      <description>VDMA Register Map</description>
      <groupName>VDMA</groupName>
      <baseAddress>0x50008300</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x10</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x14</offset>
        <size>0x18</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x80</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>PDMA_CSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CSR</displayName>
          <description>PDMA Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMACEN</name>
              <description>PDMA Channel Enable Control\nSetting this bit to "1" enables PDMA operation. If this bit is cleared, PDMA will ignore all PDMA request and force Bus Master into IDLE state.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_RST</name>
              <description>Software Engine Reset\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the internal state machine and pointers. The contents of control register will not be cleared. This bit will be automatically cleared after few clock cycles</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE_SEL</name>
              <description>PDMA Mode Selection\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Memory to Memory mode (Memory-to-Memory)</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Peripheral to Memory mode (Peripheral-to-Memory)</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Memory to Peripheral mode (Memory-to-Peripheral)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SAD_SEL</name>
              <description>Transfer Source Address Direction Selection\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer Source address is incremented successively</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer Source address is fixed (This feature can be used when data where transferred from a single source to multiple destinations)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Transfer Source address is wrap around (When the PDMA_CBCR is equal to 0, the PDMA_CSAR and PDMA_CBCR register will be updated by PDMA_SAR and PDMA_BCR automatically. PDMA will start another transfer without user trigger until PDMA_EN disabled. When the PDMA_EN is disabled, the PDMA will complete the active transfer but the remained data which in the PDMA_BUF will not transfer to destination address)</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DAD_SEL</name>
              <description>Transfer Destination Address Direction Selection\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer Destination address is incremented successively</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer Destination address is fixed (This feature can be used when data where transferred from multiple sources to a single destination)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Transfer Destination address is wrapped around (When the PDMA_CBCR is equal to 0, the PDMA_CDAR and PDMA_CBCR register will be updated by PDMA_DAR and PDMA_BCR automatically. PDMA will start another transfer without user trigger until PDMA_EN disabled. When the PDMA_EN is disabled, the PDMA will complete the active transfer but the remained data which in the PDMA_BUF will not transfer to destination address)</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TO_EN</name>
              <description>Time-Out Enable Control\nThis bit will enable PDMA internal Counter. While this counter counts to zero, the TO_IS will be set.\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PDMA internal counter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PDMA internal counter Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>APB_TWS</name>
              <description>Peripheral Transfer Width Selection\nNote: This field is meaningful only when MODE_SEL is Peripheral to Memory mode (Peripheral-to-Memory) or Memory to Peripheral mode (Memory-to-Peripheral).</description>
              <bitOffset>19</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One word (32-bit) is transferred for every PDMA operation</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>One byte (8-bit) is transferred for every PDMA operation</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>One half-word (16-bit) is transferred for every PDMA operation</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIG_EN</name>
              <description>Trigger Enable Control\nNote: When PDMA transfer completed, this bit will be cleared automatically.\nIf the bus error occurs, all PDMA transfer will be stopped. User must reset all PDMA channel, and then trigger again.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PDMA data read or write transfer Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_SAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_SAR</displayName>
          <description>PDMA Source Address Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_SAR</name>
              <description>PDMA Transfer Source Address Bits\nThis field indicates a 32-bit source address of PDMA.\nNote: The source address must be word alignment.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_DAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_DAR</displayName>
          <description>PDMA Destination Address Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_DAR</name>
              <description>PDMA Transfer Destination Address Bits\nThis field indicates a 32-bit destination address of PDMA.\nNote : The destination address must be word alignment</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_BCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_BCR</displayName>
          <description>PDMA Transfer Byte Count Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_BCR</name>
              <description>PDMA Transfer Byte Count Bits\nThis field indicates a 16-bit transfer byte count of PDMA.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_CSAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CSAR</displayName>
          <description>PDMA Current Source Address Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CSAR</name>
              <description>PDMA Current Source Address Bits (Read Only)\nThis field indicates the source address where the PDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_CDAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CDAR</displayName>
          <description>PDMA Current Destination Address Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CDAR</name>
              <description>PDMA Current Destination Address Bits (Read Only)\nThis field indicates the destination address where the PDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_CBCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CBCR</displayName>
          <description>PDMA Current Transfer Byte Count Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CBCR</name>
              <description>PDMA Current Byte Count Bits (Read Only)\nThis field indicates the current remained byte count of PDMA.\nNote: This field will be changed when PDMA finishes data transfer (data transfer to destination address).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_IER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_IER</displayName>
          <description>PDMA Interrupt Enable Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IE</name>
              <description>PDMA Read/Write Target Abort Interrupt Enable Control\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Target abort interrupt generation Disabled during PDMA transfer</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Target abort interrupt generation Enabled during PDMA transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TD_IE</name>
              <description>PDMA Transfer Done Interrupt Enable Control\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt generator Disabled when PDMA transfer is done</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt generator Enabled when PDMA transfer is done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WRA_BCR_IE</name>
              <description>Wrap Around Byte Count Interrupt Enable Control\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt enable of PDMA_CBCR equals 0</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>Interrupt enable of PDMA_CBCR equals 1/2 PDMA_BCR</description>
                    <value>#0100</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TO_IE</name>
              <description>Time-Out Interrupt Enable Control\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Time-out interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time-out interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_ISR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_ISR</displayName>
          <description>PDMA Interrupt Status Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IS</name>
              <description>PDMA Read/Write Target Abort Interrupt Status Flag\nNote1: This bit is cleared by writing "1" to it.\nNote2: This bit indicates bus master received ERROR response or not, if bus master received occur it means that target abort is happened. PDMA controller will stop transfer and respond this event to user then go to IDLE state. When target abort occurred, user must reset PDMA controller, and then transfer those data again.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No bus ERROR response received</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bus ERROR response received</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TD_IS</name>
              <description>Transfer Done Interrupt Status Flag\nThis bit indicates that PDMA has finished all transfer. \nNote: This bit is cleared by writing "1" to it.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Not finished yet</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WRA_BCR_IS</name>
              <description>Wrap Around Transfer Byte Count Interrupt Status Flag\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TO_IS</name>
              <description>Time-Out Interrupt Status Flag\nThis flag indicated that PDMA has waited peripheral request for a period defined by PDMA_TCR.\nNote: This bit is cleared by writing "1" to it.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No time-out flag</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time-out flag</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_TCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_TCR</displayName>
          <description>PDMA Timer Counter Setting Register</description>
          <addressOffset>0x28</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_TCR</name>
              <description>PDMA Timer Count Setting Bits\nEach PDMA channel contains an internal counter. This internal counter will reload and start counting when completing each peripheral request service. The internal counter loads the value of PDAM_TCR and starts counting down when setting TO_EN (PDMA_CSRx[12]). PDMA will request interrupt when this internal counter reaches 0 and TO_IE (PDMA_IERx[6]) is 1.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_BUF</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_BUF</displayName>
          <description>PDMA Internal Buffer FIFO</description>
          <addressOffset>0x80</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_BUF</name>
              <description>PDMA Internal Buffer FIFO (Read Only)\nEach channel has its own 1 word internal buffer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PDMA_CH4</name>
      <description>VDMA Register Map</description>
      <groupName>VDMA</groupName>
      <baseAddress>0x50008400</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x10</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x14</offset>
        <size>0x18</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x80</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>PDMA_CSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CSR</displayName>
          <description>PDMA Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMACEN</name>
              <description>PDMA Channel Enable Control\nSetting this bit to "1" enables PDMA operation. If this bit is cleared, PDMA will ignore all PDMA request and force Bus Master into IDLE state.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_RST</name>
              <description>Software Engine Reset\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the internal state machine and pointers. The contents of control register will not be cleared. This bit will be automatically cleared after few clock cycles</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE_SEL</name>
              <description>PDMA Mode Selection\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Memory to Memory mode (Memory-to-Memory)</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Peripheral to Memory mode (Peripheral-to-Memory)</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Memory to Peripheral mode (Memory-to-Peripheral)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SAD_SEL</name>
              <description>Transfer Source Address Direction Selection\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer Source address is incremented successively</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer Source address is fixed (This feature can be used when data where transferred from a single source to multiple destinations)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Transfer Source address is wrap around (When the PDMA_CBCR is equal to 0, the PDMA_CSAR and PDMA_CBCR register will be updated by PDMA_SAR and PDMA_BCR automatically. PDMA will start another transfer without user trigger until PDMA_EN disabled. When the PDMA_EN is disabled, the PDMA will complete the active transfer but the remained data which in the PDMA_BUF will not transfer to destination address)</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DAD_SEL</name>
              <description>Transfer Destination Address Direction Selection\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer Destination address is incremented successively</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer Destination address is fixed (This feature can be used when data where transferred from multiple sources to a single destination)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Transfer Destination address is wrapped around (When the PDMA_CBCR is equal to 0, the PDMA_CDAR and PDMA_CBCR register will be updated by PDMA_DAR and PDMA_BCR automatically. PDMA will start another transfer without user trigger until PDMA_EN disabled. When the PDMA_EN is disabled, the PDMA will complete the active transfer but the remained data which in the PDMA_BUF will not transfer to destination address)</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TO_EN</name>
              <description>Time-Out Enable Control\nThis bit will enable PDMA internal Counter. While this counter counts to zero, the TO_IS will be set.\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PDMA internal counter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PDMA internal counter Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>APB_TWS</name>
              <description>Peripheral Transfer Width Selection\nNote: This field is meaningful only when MODE_SEL is Peripheral to Memory mode (Peripheral-to-Memory) or Memory to Peripheral mode (Memory-to-Peripheral).</description>
              <bitOffset>19</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One word (32-bit) is transferred for every PDMA operation</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>One byte (8-bit) is transferred for every PDMA operation</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>One half-word (16-bit) is transferred for every PDMA operation</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIG_EN</name>
              <description>Trigger Enable Control\nNote: When PDMA transfer completed, this bit will be cleared automatically.\nIf the bus error occurs, all PDMA transfer will be stopped. User must reset all PDMA channel, and then trigger again.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PDMA data read or write transfer Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_SAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_SAR</displayName>
          <description>PDMA Source Address Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_SAR</name>
              <description>PDMA Transfer Source Address Bits\nThis field indicates a 32-bit source address of PDMA.\nNote: The source address must be word alignment.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_DAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_DAR</displayName>
          <description>PDMA Destination Address Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_DAR</name>
              <description>PDMA Transfer Destination Address Bits\nThis field indicates a 32-bit destination address of PDMA.\nNote : The destination address must be word alignment</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_BCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_BCR</displayName>
          <description>PDMA Transfer Byte Count Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_BCR</name>
              <description>PDMA Transfer Byte Count Bits\nThis field indicates a 16-bit transfer byte count of PDMA.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_CSAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CSAR</displayName>
          <description>PDMA Current Source Address Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CSAR</name>
              <description>PDMA Current Source Address Bits (Read Only)\nThis field indicates the source address where the PDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_CDAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CDAR</displayName>
          <description>PDMA Current Destination Address Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CDAR</name>
              <description>PDMA Current Destination Address Bits (Read Only)\nThis field indicates the destination address where the PDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_CBCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CBCR</displayName>
          <description>PDMA Current Transfer Byte Count Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CBCR</name>
              <description>PDMA Current Byte Count Bits (Read Only)\nThis field indicates the current remained byte count of PDMA.\nNote: This field will be changed when PDMA finishes data transfer (data transfer to destination address).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_IER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_IER</displayName>
          <description>PDMA Interrupt Enable Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IE</name>
              <description>PDMA Read/Write Target Abort Interrupt Enable Control\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Target abort interrupt generation Disabled during PDMA transfer</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Target abort interrupt generation Enabled during PDMA transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TD_IE</name>
              <description>PDMA Transfer Done Interrupt Enable Control\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt generator Disabled when PDMA transfer is done</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt generator Enabled when PDMA transfer is done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WRA_BCR_IE</name>
              <description>Wrap Around Byte Count Interrupt Enable Control\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt enable of PDMA_CBCR equals 0</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>Interrupt enable of PDMA_CBCR equals 1/2 PDMA_BCR</description>
                    <value>#0100</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TO_IE</name>
              <description>Time-Out Interrupt Enable Control\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Time-out interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time-out interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_ISR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_ISR</displayName>
          <description>PDMA Interrupt Status Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IS</name>
              <description>PDMA Read/Write Target Abort Interrupt Status Flag\nNote1: This bit is cleared by writing "1" to it.\nNote2: This bit indicates bus master received ERROR response or not, if bus master received occur it means that target abort is happened. PDMA controller will stop transfer and respond this event to user then go to IDLE state. When target abort occurred, user must reset PDMA controller, and then transfer those data again.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No bus ERROR response received</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bus ERROR response received</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TD_IS</name>
              <description>Transfer Done Interrupt Status Flag\nThis bit indicates that PDMA has finished all transfer. \nNote: This bit is cleared by writing "1" to it.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Not finished yet</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WRA_BCR_IS</name>
              <description>Wrap Around Transfer Byte Count Interrupt Status Flag\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TO_IS</name>
              <description>Time-Out Interrupt Status Flag\nThis flag indicated that PDMA has waited peripheral request for a period defined by PDMA_TCR.\nNote: This bit is cleared by writing "1" to it.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No time-out flag</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time-out flag</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_TCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_TCR</displayName>
          <description>PDMA Timer Counter Setting Register</description>
          <addressOffset>0x28</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_TCR</name>
              <description>PDMA Timer Count Setting Bits\nEach PDMA channel contains an internal counter. This internal counter will reload and start counting when completing each peripheral request service. The internal counter loads the value of PDAM_TCR and starts counting down when setting TO_EN (PDMA_CSRx[12]). PDMA will request interrupt when this internal counter reaches 0 and TO_IE (PDMA_IERx[6]) is 1.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_BUF</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_BUF</displayName>
          <description>PDMA Internal Buffer FIFO</description>
          <addressOffset>0x80</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_BUF</name>
              <description>PDMA Internal Buffer FIFO (Read Only)\nEach channel has its own 1 word internal buffer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>TMR0</name>
      <description>TMR Register Map</description>
      <groupName>TMR</groupName>
      <baseAddress>0x40010000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1C</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x200</offset>
        <size>0x18</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>TMR0_CTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TMR0_CTL</displayName>
          <description>Timer 0 Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TMR_EN</name>
              <description>Timer Counter Enable Bit\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Stops/Suspends counting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Starts counting</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_RST</name>
              <description>Software Reset\nSet this bit will reset the timer counter, pre-scale counter and also force TMR_EN (TMRx_CTL[0])  to 0.\nNote: This bit will auto clear and takes at least 3 TMRx_CLK clock cycles.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset Timer's pre-scale counter, internal 24-bit up-counter and TMR_EN (TMRx_CTL[0]) bit</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKE_EN</name>
              <description>Wake-Up Enable\nWhen WAKE_EN is set and the TMR_IS (TMRx_ISR[0]) or TCAP_IS (TMRx_ISR[1])  is set, the timer controller will generate a wake-up trigger event to CPU.\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Wake-up trigger event disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Wake-up trigger event enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBGACK_EN</name>
              <description>ICE Debug Mode Acknowledge Ineffective Enable\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ICE debug mode acknowledgement effects TIMER counting and TIMER counter will be held while ICE debug mode acknowledged</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ICE debug mode acknowledgement is ineffective and TIMER counter will keep going no matter ICE debug mode acknowledged or not</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE_SEL</name>
              <description>Timer Operating Mode Select\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR_ACT</name>
              <description>Timer Active Status Bit (Read Only)\nThis bit indicates the timer counter status of timer.\n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer is not active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer is in active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>ADC_TEEN</name>
              <description>TMR_IS Or TCAP_IS Trigger ADC Enable\nThis bit controls if TMR_IS (TMRx_ISR[0]) or TCAP_IS (TMRx_ISR[1]) could trigger ADC.\nWhen ADC_TEEN is set, TMR_IS (TMRx_ISR[0]) is set and the CAP_TRG_EN (TMRx_CTL[11]) is low, the timer controller will generate an internal trigger event to ADC controller.\nWhen ADC_TEEN is set, TCAP_IS (TMRx_ISR[1]) is set and the CAP_TRG_EN (TMRx_CTL[11]) is high, the timer controller will generate an internal trigger event to ADC controller.\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TMR_IS (TMRx_ISR[0]) or TCAP_IS (TMRx_ISR[1])  trigger ADC Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TMR_IS (TMRx_ISR[0]) or TCAP_IS (TMRx_ISR[1]) trigger ADC Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PDMA_TEEN</name>
              <description>TMR_IS Or TCAP_IS Trigger PDMA Enable\nThis bit controls if TMR_IS (TMRx_ISR[0])  or TCAP_IS (TMRx_ISR[1]) could trigger PDMA.\nWhen PDMA_TEEN is set, TMR_IS (TMRx_ISR[0]) is set and the CAP_TRG_EN (TMRx_CTL[11]) is low, the timer controller will generate an internal trigger event to PDMA controller.\nWhen PDMA_TEEN is set, TCAP_IS (TMRx_ISR[1]) is set and the CAP_TRG_EN (TMRx_CTL[11]) is high, the timer controller will generate an internal trigger event to PDMA controller.\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TMR_IS (TMRx_ISR[0]) or TCAP_IS (TMRx_ISR[1]) trigger PDMA Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TMR_IS (TMRx_ISR[0]) or TCAP_IS (TMRx_ISR[1])trigger PDMA Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAP_TRG_EN</name>
              <description>TCAP_IS Trigger Mode Enable\nThis bit controls if the TMR_IS (TMRx_ISR[0]) or TCAP_IS (TMRx_ISR[1]) is used to trigger PDMA and ADC while TMR_IS (TMRx_ISR[0]) or TCAP_IS (TMRx_ISR[1]) is set.\nIf this bit is low and TMR_IS (TMRx_ISR[0]) is set, timer will generate an internal trigger event to PDMA or ADC while related trigger enable bit (PDMA_TEEN, or ADC_TEEN) is also set.\nIf this bit is set high and TCAP_IS is set, timer will generate an internal trigger event to PDMA or ADC while related trigger enable bit (PDMA_TEEN (TMRx_CTL[10]), or ADC_TEEN(TMRx_CTL[8])) is also set.\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TMR_IS (TMRx_ISR[0]) is used to trigger PDMA and ADC</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TCAP_IS (TMRx_ISR[1]) is used to trigger PDMA and ADC</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EVENT_EN</name>
              <description>Event Counting Mode Enable\nWhen EVENT_EN is set, the increase of 24-bit up-counting timer is controlled by external event pin.\nWhile the transition of external event pin matches the definition of EVENT_EDGE (TMRx_CTL[13]), the 24-bit up-counting timer increases by 1. Or, the 24-bit up-counting timer will keep its value unchanged.\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer counting is not controlled by external event pin</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer counting is controlled by external event pin</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EVENT_EDGE</name>
              <description>Event Counting Mode Edge Selection\nThis bit indicates which edge of external event pin enabling the timer to increase 1.\n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>A falling edge of external event enabling the timer to increase 1</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>A rising edge of external event enabling the timer to increase 1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EVNT_DEB_EN</name>
              <description>External Event De-Bounce Enable\nWhen EVNT_DEB_EN is set, the external event pin de-bounce circuit will be enabled to eliminate the bouncing of the signal.\nIn de-bounce circuit the external event pin will be sampled 4 times by TMRx_CLK.\nNote: When EVENT_EN (TMRx_CTL[12]) is enabled, enable this bit is recommended. And, while EVENT_EN (TMRx_CTL[12]) is disabled, disable this bit is recommended to save power consumption.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>De-bounce circuit Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>De-bounce circuit Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TCAP_EN</name>
              <description>TCapture Pin Functional Enable\nThis bit controls if the transition on TCapture pin could be used as timer counter reset function or timer capture function.\nNote: For TMRx_CTL, if INTR_TRG_EN  (TMRx_CTL[24]) is set, the TCAP_EN will be forced to low and the TCapture pin transition is ignored.\nNote: For TMRx+1_CTL, if INTR_TRG_EN  (TMRx_CTL[24]) is set, the TCAP_EN will be forced to high.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The transition on TCapture pin is ignored</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The transition on TCapture pin will result in the capture or reset of 24-bit timer counter</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TCAP_MODE</name>
              <description>TCapture Pin Function Mode Selection\nThis bit indicates if the transition on TCapture pin is used as timer counter reset function or timer capture function.\nNote: For TMRx+1_CTL, if INTR_TRG_EN is set, the TCAP_MODE will be forced to low.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transition on TCapture pin is used as timer capture function</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transition on TCapture pin is used as timer counter reset function</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TCAP_EDGE</name>
              <description>TCapture Pin Edge Detect Selection\n</description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAP_CNT_MOD</name>
              <description>Timer Capture Counting Mode Selection\nThis bit indicates the behavior of 24-bit up-counting timer while TCAP_EN (TMRx_CTL[16]) is set to high.\nIf this bit is 0, the free-counting mode, the behavior of 24-bit up-counting timer is defined by MODE_SEL (TMRx_CTL[5:4]) field. When TCAP_EN (TMRx_CTL[16]) is set, TCAP_MODE  (TMRx_CTL[17]) is 0, and the transition of Tcapture pin matches the TCAP_EDGE (TMRx_CTL[19:18]) setting, the value of 24-bit up-counting timer will be saved into register TMRx_TCAP.\nIf this bit is 1, Trigger-counting mode, 24-bit up-counting timer will be not counting and keep its value at zero. When TCAP_EN (TMRx_CTL[16]) is set, TCAP_MODE (TMRx_CTL[17]) is 0, and once the transition of external pin matches the 1st transition of TCAP_EDGE (TMRx_CTL[19:18]) setting, the 24-bit up-counting timer will start counting. And then if the transition of external pin matches the 2nd transition of TCAP_EDGE (TMRx_CTL[19:18])  setting, the 24-bit up-counting timer will stop counting. And its value will be saved into register TMRx_TCAP.\nNote: For TMRx+1_CTL, if INTR_TRG_EN (TMRx_CTL[24]) is set, the CAP_CNT_MOD will be forced to high, the capture with trigger-counting timer mode.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Capture with free-counting timer mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture with trigger-counting timer mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TCAP_DEB_EN</name>
              <description>TCapture Pin De-Bounce Enable\nWhen CAP_DEB_EN is set, the TCapture pin de-bounce circuit will be enabled to eliminate the bouncing of the signal.\nIn de-bounce circuit the TCapture pin signal will be sampled 4 times by TMRx_CLK.\nNote: When TCAP_EN (TMRx_CTL[16]) is enabled, enable this bit is recommended. And, while TCAP_EN (TMRx_CTL[16]) is disabled, disable this bit is recommended to save power consumption.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>De-bounce circuit Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>De-bounce circuit Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INTR_TRG_EN</name>
              <description>Inter-Timer Trigger Mode Enable\nThis bit controls if the inter-timer trigger mode is enabled.\nIf inter-timer trigger mode is enabled, the TMRx will be in counter mode and counting with external Clock Source or event. And, TMRx +1 will be in trigger-counting mode of capture function.\nNote: For TMRx+1_CTL, this bit is ignored and the read back value is always 1'b0.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inter-timer trigger mode is disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inter-timer trigger mode is enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TMR0_PRECNT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TMR0_PRECNT</displayName>
          <description>Timer 0 Pre-scale Counter Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRESCALE_CNT</name>
              <description>Pre-Scale Counter\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TMR0_CMPR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TMR0_CMPR</displayName>
          <description>Timer 0 Compare Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TMR_CMP</name>
              <description>Timer Compared Value\nTMR_CMP is a 24-bit compared register. When the internal 24-bit up-counter counts and its value is equal to TMR_CMP value, a Timer Interrupt is requested if the timer interrupt is enabled with TMR_EN (TMRx_CTL[0]) is enabled. The TMR_CMP value defines the timer counting cycle time.\nNote1: Never write 0 or 1 in TMR_CMP, or the core will run into unknown state.\nNote2: No matter TMR_EN (TMRx_CTL[0]) is 0 or 1, whenever software write a new value into this register, TIMER will restart counting using this new value and abort previous count.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TMR0_IER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TMR0_IER</displayName>
          <description>Timer 0 Interrupt Enable Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TMR_IE</name>
              <description>Timer Interrupt Enable\nNOTE: If timer interrupt is enabled, the timer asserts its interrupt signal when the associated counter is equal to TMR_CMPR.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TCAP_IE</name>
              <description>Timer Capture Function Interrupt Enable\nNOTE: If timer external pin function interrupt is enabled, the timer asserts its interrupt signal when the TCAP_EN (TMRx_CTL[16]) is set and the transition of external pin matches the TCAP_EDGE (TMRx_CTL[19:18])setting.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer External Pin Function Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer External Pin Function Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TMR0_ISR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TMR0_ISR</displayName>
          <description>Timer 0 Interrupt Status Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TMR_IS</name>
              <description>Timer Interrupt Status\nThis bit indicates the interrupt status of Timer.\nThis bit is set by hardware when the up counting value of internal 24-bit counter matches the timer compared value (TMR_CMPR). Write 1 to clear this bit to zero.\nIf this bit is active and TMR_IE (TMRx_IER[0]) is enabled, Timer will trigger an interrupt to CPU.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TCAP_IS</name>
              <description>Timer Capture Function Interrupt Status\nThis bit indicates the external pin function interrupt status of Timer.\nThis bit is set by hardware when TCAP_EN (TMRx_CTL[16]) is set high, and the transition of external pin matches the TCAP_EDGE (TMRx_CTL[19:18]) setting. Write 1 to clear this bit to zero.\nIf this bit is active and TCAP_IE (TMRx_IER[1]) is enabled, Timer will trigger an interrupt to CPU.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR_Wake_STS</name>
              <description>Timer Wake-Up Status\nIf timer causes CPU wakes up from power-down mode, this bit will be set to high. It must be cleared by software with a write 1 to this bit.\n0: Timer does not cause system wake-up.\n1: Wakes system up from power-down mode by Timer timeout.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NCAP_DET_STS</name>
              <description>New Capture Detected Status\nThis status is to indicate there is a new incoming capture event detected before CPU clearing the TCAP_IS (TMRx_ISR[1]) status.\nIf the above condition occurred, the Timer will keep register TMRx_CAP unchanged and drop the new capture value.\nThis bit is also cleared to 0 while TCAP_IS (TMRx_ISR[1]) is cleared.\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>New incoming capture event didn't detect before CPU clearing TCAP_IS (TMRx_ISR[1]) status</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>New incoming capture event detected before CPU clearing TCAP_IS (TMRx_ISR[1]) status</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TMR0_DR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TMR0_DR</displayName>
          <description>Timer 0 Data Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TDR</name>
              <description>Timer Data Register\nUser can read this register for internal 24-bit timer up-counter value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TMR0_TCAP</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TMR0_TCAP</displayName>
          <description>Timer 0 Capture Data Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CAP</name>
              <description>Timer Capture Data Register\nWhen TCAP_EN (TMRx_CTL[16]) is set, TCAP_MODE (TMRx_CTL[17]) is 0, TCAP_CNT_MOD (TMRx_CTL[20]) is 0, and the transition of external pin matches the TCAP_EDGE (TMRx_CTL[19:18]) setting, the value of 24-bit up-counting timer will be saved into register TMRx_TCAP.\nWhen TCAP_EN (TMRx_CTL[16]) is set, TCAP_MODE (TMRx_CTL[17]) is 0, TCAP_CNT_MOD (TMRx_CTL[20]) is 1, and the transition of external pin matches the 2nd transition of TCAP_EDGE (TMRx_CTL[19:18]) setting, the value of 24-bit up-counting timer will be saved into register TMRx_TCAP.\nUser can read this register to get the counter value.\nWhen a new incoming capture event detected before CPU clearing the TCAP_IS (TMRx_ISR[1]) status, Timer will keep this filed value unchanged and drop the new capture value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPA_SHADOW</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPA_SHADOW</displayName>
          <description>GPIO Port A Pin Value Shadow Register</description>
          <addressOffset>0x200</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFF0000</resetMask>
          <fields>
            <field>
              <name>PIN0</name>
              <description>GPIO Port [A/B/C/D/E/F] Pin Values\nThe value read from each of these bit reflects the actual status of the respective GPIO pin.\nThese registers are shadow registers of GPIOx_PIN register.\nNote: For GPF_SHADOW, bits [15:9] are reserved.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN1</name>
              <description>GPIO Port [A/B/C/D/E/F] Pin Values\nThe value read from each of these bit reflects the actual status of the respective GPIO pin.\nThese registers are shadow registers of GPIOx_PIN register.\nNote: For GPF_SHADOW, bits [15:9] are reserved.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN2</name>
              <description>GPIO Port [A/B/C/D/E/F] Pin Values\nThe value read from each of these bit reflects the actual status of the respective GPIO pin.\nThese registers are shadow registers of GPIOx_PIN register.\nNote: For GPF_SHADOW, bits [15:9] are reserved.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN3</name>
              <description>GPIO Port [A/B/C/D/E/F] Pin Values\nThe value read from each of these bit reflects the actual status of the respective GPIO pin.\nThese registers are shadow registers of GPIOx_PIN register.\nNote: For GPF_SHADOW, bits [15:9] are reserved.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN4</name>
              <description>GPIO Port [A/B/C/D/E/F] Pin Values\nThe value read from each of these bit reflects the actual status of the respective GPIO pin.\nThese registers are shadow registers of GPIOx_PIN register.\nNote: For GPF_SHADOW, bits [15:9] are reserved.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN5</name>
              <description>GPIO Port [A/B/C/D/E/F] Pin Values\nThe value read from each of these bit reflects the actual status of the respective GPIO pin.\nThese registers are shadow registers of GPIOx_PIN register.\nNote: For GPF_SHADOW, bits [15:9] are reserved.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN6</name>
              <description>GPIO Port [A/B/C/D/E/F] Pin Values\nThe value read from each of these bit reflects the actual status of the respective GPIO pin.\nThese registers are shadow registers of GPIOx_PIN register.\nNote: For GPF_SHADOW, bits [15:9] are reserved.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN7</name>
              <description>GPIO Port [A/B/C/D/E/F] Pin Values\nThe value read from each of these bit reflects the actual status of the respective GPIO pin.\nThese registers are shadow registers of GPIOx_PIN register.\nNote: For GPF_SHADOW, bits [15:9] are reserved.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN8</name>
              <description>GPIO Port [A/B/C/D/E/F] Pin Values\nThe value read from each of these bit reflects the actual status of the respective GPIO pin.\nThese registers are shadow registers of GPIOx_PIN register.\nNote: For GPF_SHADOW, bits [15:9] are reserved.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN9</name>
              <description>GPIO Port [A/B/C/D/E/F] Pin Values\nThe value read from each of these bit reflects the actual status of the respective GPIO pin.\nThese registers are shadow registers of GPIOx_PIN register.\nNote: For GPF_SHADOW, bits [15:9] are reserved.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN10</name>
              <description>GPIO Port [A/B/C/D/E/F] Pin Values\nThe value read from each of these bit reflects the actual status of the respective GPIO pin.\nThese registers are shadow registers of GPIOx_PIN register.\nNote: For GPF_SHADOW, bits [15:9] are reserved.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN11</name>
              <description>GPIO Port [A/B/C/D/E/F] Pin Values\nThe value read from each of these bit reflects the actual status of the respective GPIO pin.\nThese registers are shadow registers of GPIOx_PIN register.\nNote: For GPF_SHADOW, bits [15:9] are reserved.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN12</name>
              <description>GPIO Port [A/B/C/D/E/F] Pin Values\nThe value read from each of these bit reflects the actual status of the respective GPIO pin.\nThese registers are shadow registers of GPIOx_PIN register.\nNote: For GPF_SHADOW, bits [15:9] are reserved.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN13</name>
              <description>GPIO Port [A/B/C/D/E/F] Pin Values\nThe value read from each of these bit reflects the actual status of the respective GPIO pin.\nThese registers are shadow registers of GPIOx_PIN register.\nNote: For GPF_SHADOW, bits [15:9] are reserved.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN14</name>
              <description>GPIO Port [A/B/C/D/E/F] Pin Values\nThe value read from each of these bit reflects the actual status of the respective GPIO pin.\nThese registers are shadow registers of GPIOx_PIN register.\nNote: For GPF_SHADOW, bits [15:9] are reserved.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN15</name>
              <description>GPIO Port [A/B/C/D/E/F] Pin Values\nThe value read from each of these bit reflects the actual status of the respective GPIO pin.\nThese registers are shadow registers of GPIOx_PIN register.\nNote: For GPF_SHADOW, bits [15:9] are reserved.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="GPA_SHADOW">
          <name>GPB_SHADOW</name>
          <displayName>GPB_SHADOW</displayName>
          <description>GPIO Port B Pin Value Shadow Register</description>
          <addressOffset>0x204</addressOffset>
       </register>
       <register derivedFrom="GPA_SHADOW">
          <name>GPC_SHADOW</name>
          <displayName>GPC_SHADOW</displayName>
          <description>GPIO Port C Pin Value Shadow Register</description>
          <addressOffset>0x208</addressOffset>
       </register>
       <register derivedFrom="GPA_SHADOW">
          <name>GPD_SHADOW</name>
          <displayName>GPD_SHADOW</displayName>
          <description>GPIO Port D Pin Value Shadow Register</description>
          <addressOffset>0x20C</addressOffset>
       </register>
       <register derivedFrom="GPA_SHADOW">
          <name>GPE_SHADOW</name>
          <displayName>GPE_SHADOW</displayName>
          <description>GPIO Port E Pin Value Shadow Register</description>
          <addressOffset>0x210</addressOffset>
       </register>
       <register derivedFrom="GPA_SHADOW">
          <name>GPF_SHADOW</name>
          <displayName>GPF_SHADOW</displayName>
          <description>GPIO Port F Pin Value Shadow Register</description>
          <addressOffset>0x214</addressOffset>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>TMR1</name>
      <description>TMR Register Map</description>
      <groupName>TMR</groupName>
      <baseAddress>0x40010100</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1C</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>TMR1_CTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TMR1_CTL</displayName>
          <description>Timer 1 Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TMR_EN</name>
              <description>Timer Counter Enable Bit\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Stops/Suspends counting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Starts counting</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_RST</name>
              <description>Software Reset\nSet this bit will reset the timer counter, pre-scale counter and also force TMR_EN (TMRx_CTL[0])  to 0.\nNote: This bit will auto clear and takes at least 3 TMRx_CLK clock cycles.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset Timer's pre-scale counter, internal 24-bit up-counter and TMR_EN (TMRx_CTL[0]) bit</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKE_EN</name>
              <description>Wake-Up Enable\nWhen WAKE_EN is set and the TMR_IS (TMRx_ISR[0]) or TCAP_IS (TMRx_ISR[1])  is set, the timer controller will generate a wake-up trigger event to CPU.\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Wake-up trigger event disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Wake-up trigger event enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBGACK_EN</name>
              <description>ICE Debug Mode Acknowledge Ineffective Enable\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ICE debug mode acknowledgement effects TIMER counting and TIMER counter will be held while ICE debug mode acknowledged</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ICE debug mode acknowledgement is ineffective and TIMER counter will keep going no matter ICE debug mode acknowledged or not</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE_SEL</name>
              <description>Timer Operating Mode Select\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR_ACT</name>
              <description>Timer Active Status Bit (Read Only)\nThis bit indicates the timer counter status of timer.\n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer is not active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer is in active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>ADC_TEEN</name>
              <description>TMR_IS Or TCAP_IS Trigger ADC Enable\nThis bit controls if TMR_IS (TMRx_ISR[0]) or TCAP_IS (TMRx_ISR[1]) could trigger ADC.\nWhen ADC_TEEN is set, TMR_IS (TMRx_ISR[0]) is set and the CAP_TRG_EN (TMRx_CTL[11]) is low, the timer controller will generate an internal trigger event to ADC controller.\nWhen ADC_TEEN is set, TCAP_IS (TMRx_ISR[1]) is set and the CAP_TRG_EN (TMRx_CTL[11]) is high, the timer controller will generate an internal trigger event to ADC controller.\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TMR_IS (TMRx_ISR[0]) or TCAP_IS (TMRx_ISR[1])  trigger ADC Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TMR_IS (TMRx_ISR[0]) or TCAP_IS (TMRx_ISR[1]) trigger ADC Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PDMA_TEEN</name>
              <description>TMR_IS Or TCAP_IS Trigger PDMA Enable\nThis bit controls if TMR_IS (TMRx_ISR[0])  or TCAP_IS (TMRx_ISR[1]) could trigger PDMA.\nWhen PDMA_TEEN is set, TMR_IS (TMRx_ISR[0]) is set and the CAP_TRG_EN (TMRx_CTL[11]) is low, the timer controller will generate an internal trigger event to PDMA controller.\nWhen PDMA_TEEN is set, TCAP_IS (TMRx_ISR[1]) is set and the CAP_TRG_EN (TMRx_CTL[11]) is high, the timer controller will generate an internal trigger event to PDMA controller.\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TMR_IS (TMRx_ISR[0]) or TCAP_IS (TMRx_ISR[1]) trigger PDMA Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TMR_IS (TMRx_ISR[0]) or TCAP_IS (TMRx_ISR[1])trigger PDMA Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAP_TRG_EN</name>
              <description>TCAP_IS Trigger Mode Enable\nThis bit controls if the TMR_IS (TMRx_ISR[0]) or TCAP_IS (TMRx_ISR[1]) is used to trigger PDMA and ADC while TMR_IS (TMRx_ISR[0]) or TCAP_IS (TMRx_ISR[1]) is set.\nIf this bit is low and TMR_IS (TMRx_ISR[0]) is set, timer will generate an internal trigger event to PDMA or ADC while related trigger enable bit (PDMA_TEEN, or ADC_TEEN) is also set.\nIf this bit is set high and TCAP_IS is set, timer will generate an internal trigger event to PDMA or ADC while related trigger enable bit (PDMA_TEEN (TMRx_CTL[10]), or ADC_TEEN(TMRx_CTL[8])) is also set.\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TMR_IS (TMRx_ISR[0]) is used to trigger PDMA and ADC</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TCAP_IS (TMRx_ISR[1]) is used to trigger PDMA and ADC</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EVENT_EN</name>
              <description>Event Counting Mode Enable\nWhen EVENT_EN is set, the increase of 24-bit up-counting timer is controlled by external event pin.\nWhile the transition of external event pin matches the definition of EVENT_EDGE (TMRx_CTL[13]), the 24-bit up-counting timer increases by 1. Or, the 24-bit up-counting timer will keep its value unchanged.\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer counting is not controlled by external event pin</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer counting is controlled by external event pin</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EVENT_EDGE</name>
              <description>Event Counting Mode Edge Selection\nThis bit indicates which edge of external event pin enabling the timer to increase 1.\n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>A falling edge of external event enabling the timer to increase 1</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>A rising edge of external event enabling the timer to increase 1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EVNT_DEB_EN</name>
              <description>External Event De-Bounce Enable\nWhen EVNT_DEB_EN is set, the external event pin de-bounce circuit will be enabled to eliminate the bouncing of the signal.\nIn de-bounce circuit the external event pin will be sampled 4 times by TMRx_CLK.\nNote: When EVENT_EN (TMRx_CTL[12]) is enabled, enable this bit is recommended. And, while EVENT_EN (TMRx_CTL[12]) is disabled, disable this bit is recommended to save power consumption.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>De-bounce circuit Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>De-bounce circuit Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TCAP_EN</name>
              <description>TCapture Pin Functional Enable\nThis bit controls if the transition on TCapture pin could be used as timer counter reset function or timer capture function.\nNote: For TMRx_CTL, if INTR_TRG_EN  (TMRx_CTL[24]) is set, the TCAP_EN will be forced to low and the TCapture pin transition is ignored.\nNote: For TMRx+1_CTL, if INTR_TRG_EN  (TMRx_CTL[24]) is set, the TCAP_EN will be forced to high.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The transition on TCapture pin is ignored</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The transition on TCapture pin will result in the capture or reset of 24-bit timer counter</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TCAP_MODE</name>
              <description>TCapture Pin Function Mode Selection\nThis bit indicates if the transition on TCapture pin is used as timer counter reset function or timer capture function.\nNote: For TMRx+1_CTL, if INTR_TRG_EN is set, the TCAP_MODE will be forced to low.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transition on TCapture pin is used as timer capture function</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transition on TCapture pin is used as timer counter reset function</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TCAP_EDGE</name>
              <description>TCapture Pin Edge Detect Selection\n</description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAP_CNT_MOD</name>
              <description>Timer Capture Counting Mode Selection\nThis bit indicates the behavior of 24-bit up-counting timer while TCAP_EN (TMRx_CTL[16]) is set to high.\nIf this bit is 0, the free-counting mode, the behavior of 24-bit up-counting timer is defined by MODE_SEL (TMRx_CTL[5:4]) field. When TCAP_EN (TMRx_CTL[16]) is set, TCAP_MODE  (TMRx_CTL[17]) is 0, and the transition of Tcapture pin matches the TCAP_EDGE (TMRx_CTL[19:18]) setting, the value of 24-bit up-counting timer will be saved into register TMRx_TCAP.\nIf this bit is 1, Trigger-counting mode, 24-bit up-counting timer will be not counting and keep its value at zero. When TCAP_EN (TMRx_CTL[16]) is set, TCAP_MODE (TMRx_CTL[17]) is 0, and once the transition of external pin matches the 1st transition of TCAP_EDGE (TMRx_CTL[19:18]) setting, the 24-bit up-counting timer will start counting. And then if the transition of external pin matches the 2nd transition of TCAP_EDGE (TMRx_CTL[19:18])  setting, the 24-bit up-counting timer will stop counting. And its value will be saved into register TMRx_TCAP.\nNote: For TMRx+1_CTL, if INTR_TRG_EN (TMRx_CTL[24]) is set, the CAP_CNT_MOD will be forced to high, the capture with trigger-counting timer mode.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Capture with free-counting timer mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture with trigger-counting timer mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TCAP_DEB_EN</name>
              <description>TCapture Pin De-Bounce Enable\nWhen CAP_DEB_EN is set, the TCapture pin de-bounce circuit will be enabled to eliminate the bouncing of the signal.\nIn de-bounce circuit the TCapture pin signal will be sampled 4 times by TMRx_CLK.\nNote: When TCAP_EN (TMRx_CTL[16]) is enabled, enable this bit is recommended. And, while TCAP_EN (TMRx_CTL[16]) is disabled, disable this bit is recommended to save power consumption.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>De-bounce circuit Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>De-bounce circuit Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INTR_TRG_EN</name>
              <description>Inter-Timer Trigger Mode Enable\nThis bit controls if the inter-timer trigger mode is enabled.\nIf inter-timer trigger mode is enabled, the TMRx will be in counter mode and counting with external Clock Source or event. And, TMRx +1 will be in trigger-counting mode of capture function.\nNote: For TMRx+1_CTL, this bit is ignored and the read back value is always 1'b0.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inter-timer trigger mode is disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inter-timer trigger mode is enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TMR1_PRECNT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TMR1_PRECNT</displayName>
          <description>Timer 1 Pre-scale Counter Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRESCALE_CNT</name>
              <description>Pre-Scale Counter\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TMR1_CMPR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TMR1_CMPR</displayName>
          <description>Timer 1 Compare Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TMR_CMP</name>
              <description>Timer Compared Value\nTMR_CMP is a 24-bit compared register. When the internal 24-bit up-counter counts and its value is equal to TMR_CMP value, a Timer Interrupt is requested if the timer interrupt is enabled with TMR_EN (TMRx_CTL[0]) is enabled. The TMR_CMP value defines the timer counting cycle time.\nNote1: Never write 0 or 1 in TMR_CMP, or the core will run into unknown state.\nNote2: No matter TMR_EN (TMRx_CTL[0]) is 0 or 1, whenever software write a new value into this register, TIMER will restart counting using this new value and abort previous count.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TMR1_IER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TMR1_IER</displayName>
          <description>Timer 1 Interrupt Enable Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TMR_IE</name>
              <description>Timer Interrupt Enable\nNOTE: If timer interrupt is enabled, the timer asserts its interrupt signal when the associated counter is equal to TMR_CMPR.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TCAP_IE</name>
              <description>Timer Capture Function Interrupt Enable\nNOTE: If timer external pin function interrupt is enabled, the timer asserts its interrupt signal when the TCAP_EN (TMRx_CTL[16]) is set and the transition of external pin matches the TCAP_EDGE (TMRx_CTL[19:18])setting.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer External Pin Function Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer External Pin Function Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TMR1_ISR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TMR1_ISR</displayName>
          <description>Timer 1 Interrupt Status Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TMR_IS</name>
              <description>Timer Interrupt Status\nThis bit indicates the interrupt status of Timer.\nThis bit is set by hardware when the up counting value of internal 24-bit counter matches the timer compared value (TMR_CMPR). Write 1 to clear this bit to zero.\nIf this bit is active and TMR_IE (TMRx_IER[0]) is enabled, Timer will trigger an interrupt to CPU.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TCAP_IS</name>
              <description>Timer Capture Function Interrupt Status\nThis bit indicates the external pin function interrupt status of Timer.\nThis bit is set by hardware when TCAP_EN (TMRx_CTL[16]) is set high, and the transition of external pin matches the TCAP_EDGE (TMRx_CTL[19:18]) setting. Write 1 to clear this bit to zero.\nIf this bit is active and TCAP_IE (TMRx_IER[1]) is enabled, Timer will trigger an interrupt to CPU.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR_Wake_STS</name>
              <description>Timer Wake-Up Status\nIf timer causes CPU wakes up from power-down mode, this bit will be set to high. It must be cleared by software with a write 1 to this bit.\n0: Timer does not cause system wake-up.\n1: Wakes system up from power-down mode by Timer timeout.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NCAP_DET_STS</name>
              <description>New Capture Detected Status\nThis status is to indicate there is a new incoming capture event detected before CPU clearing the TCAP_IS (TMRx_ISR[1]) status.\nIf the above condition occurred, the Timer will keep register TMRx_CAP unchanged and drop the new capture value.\nThis bit is also cleared to 0 while TCAP_IS (TMRx_ISR[1]) is cleared.\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>New incoming capture event didn't detect before CPU clearing TCAP_IS (TMRx_ISR[1]) status</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>New incoming capture event detected before CPU clearing TCAP_IS (TMRx_ISR[1]) status</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TMR1_DR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TMR1_DR</displayName>
          <description>Timer 1 Data Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TDR</name>
              <description>Timer Data Register\nUser can read this register for internal 24-bit timer up-counter value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TMR1_TCAP</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TMR1_TCAP</displayName>
          <description>Timer 1 Capture Data Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CAP</name>
              <description>Timer Capture Data Register\nWhen TCAP_EN (TMRx_CTL[16]) is set, TCAP_MODE (TMRx_CTL[17]) is 0, TCAP_CNT_MOD (TMRx_CTL[20]) is 0, and the transition of external pin matches the TCAP_EDGE (TMRx_CTL[19:18]) setting, the value of 24-bit up-counting timer will be saved into register TMRx_TCAP.\nWhen TCAP_EN (TMRx_CTL[16]) is set, TCAP_MODE (TMRx_CTL[17]) is 0, TCAP_CNT_MOD (TMRx_CTL[20]) is 1, and the transition of external pin matches the 2nd transition of TCAP_EDGE (TMRx_CTL[19:18]) setting, the value of 24-bit up-counting timer will be saved into register TMRx_TCAP.\nUser can read this register to get the counter value.\nWhen a new incoming capture event detected before CPU clearing the TCAP_IS (TMRx_ISR[1]) status, Timer will keep this filed value unchanged and drop the new capture value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>TMR2</name>
      <description>TMR Register Map</description>
      <groupName>TMR</groupName>
      <baseAddress>0x40110000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1C</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>TMR2_CTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TMR2_CTL</displayName>
          <description>Timer 2 Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TMR_EN</name>
              <description>Timer Counter Enable Bit\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Stops/Suspends counting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Starts counting</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_RST</name>
              <description>Software Reset\nSet this bit will reset the timer counter, pre-scale counter and also force TMR_EN (TMRx_CTL[0])  to 0.\nNote: This bit will auto clear and takes at least 3 TMRx_CLK clock cycles.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset Timer's pre-scale counter, internal 24-bit up-counter and TMR_EN (TMRx_CTL[0]) bit</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKE_EN</name>
              <description>Wake-Up Enable\nWhen WAKE_EN is set and the TMR_IS (TMRx_ISR[0]) or TCAP_IS (TMRx_ISR[1])  is set, the timer controller will generate a wake-up trigger event to CPU.\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Wake-up trigger event disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Wake-up trigger event enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBGACK_EN</name>
              <description>ICE Debug Mode Acknowledge Ineffective Enable\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ICE debug mode acknowledgement effects TIMER counting and TIMER counter will be held while ICE debug mode acknowledged</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ICE debug mode acknowledgement is ineffective and TIMER counter will keep going no matter ICE debug mode acknowledged or not</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE_SEL</name>
              <description>Timer Operating Mode Select\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR_ACT</name>
              <description>Timer Active Status Bit (Read Only)\nThis bit indicates the timer counter status of timer.\n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer is not active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer is in active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>ADC_TEEN</name>
              <description>TMR_IS Or TCAP_IS Trigger ADC Enable\nThis bit controls if TMR_IS (TMRx_ISR[0]) or TCAP_IS (TMRx_ISR[1]) could trigger ADC.\nWhen ADC_TEEN is set, TMR_IS (TMRx_ISR[0]) is set and the CAP_TRG_EN (TMRx_CTL[11]) is low, the timer controller will generate an internal trigger event to ADC controller.\nWhen ADC_TEEN is set, TCAP_IS (TMRx_ISR[1]) is set and the CAP_TRG_EN (TMRx_CTL[11]) is high, the timer controller will generate an internal trigger event to ADC controller.\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TMR_IS (TMRx_ISR[0]) or TCAP_IS (TMRx_ISR[1])  trigger ADC Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TMR_IS (TMRx_ISR[0]) or TCAP_IS (TMRx_ISR[1]) trigger ADC Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PDMA_TEEN</name>
              <description>TMR_IS Or TCAP_IS Trigger PDMA Enable\nThis bit controls if TMR_IS (TMRx_ISR[0])  or TCAP_IS (TMRx_ISR[1]) could trigger PDMA.\nWhen PDMA_TEEN is set, TMR_IS (TMRx_ISR[0]) is set and the CAP_TRG_EN (TMRx_CTL[11]) is low, the timer controller will generate an internal trigger event to PDMA controller.\nWhen PDMA_TEEN is set, TCAP_IS (TMRx_ISR[1]) is set and the CAP_TRG_EN (TMRx_CTL[11]) is high, the timer controller will generate an internal trigger event to PDMA controller.\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TMR_IS (TMRx_ISR[0]) or TCAP_IS (TMRx_ISR[1]) trigger PDMA Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TMR_IS (TMRx_ISR[0]) or TCAP_IS (TMRx_ISR[1])trigger PDMA Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAP_TRG_EN</name>
              <description>TCAP_IS Trigger Mode Enable\nThis bit controls if the TMR_IS (TMRx_ISR[0]) or TCAP_IS (TMRx_ISR[1]) is used to trigger PDMA and ADC while TMR_IS (TMRx_ISR[0]) or TCAP_IS (TMRx_ISR[1]) is set.\nIf this bit is low and TMR_IS (TMRx_ISR[0]) is set, timer will generate an internal trigger event to PDMA or ADC while related trigger enable bit (PDMA_TEEN, or ADC_TEEN) is also set.\nIf this bit is set high and TCAP_IS is set, timer will generate an internal trigger event to PDMA or ADC while related trigger enable bit (PDMA_TEEN (TMRx_CTL[10]), or ADC_TEEN(TMRx_CTL[8])) is also set.\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TMR_IS (TMRx_ISR[0]) is used to trigger PDMA and ADC</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TCAP_IS (TMRx_ISR[1]) is used to trigger PDMA and ADC</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EVENT_EN</name>
              <description>Event Counting Mode Enable\nWhen EVENT_EN is set, the increase of 24-bit up-counting timer is controlled by external event pin.\nWhile the transition of external event pin matches the definition of EVENT_EDGE (TMRx_CTL[13]), the 24-bit up-counting timer increases by 1. Or, the 24-bit up-counting timer will keep its value unchanged.\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer counting is not controlled by external event pin</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer counting is controlled by external event pin</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EVENT_EDGE</name>
              <description>Event Counting Mode Edge Selection\nThis bit indicates which edge of external event pin enabling the timer to increase 1.\n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>A falling edge of external event enabling the timer to increase 1</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>A rising edge of external event enabling the timer to increase 1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EVNT_DEB_EN</name>
              <description>External Event De-Bounce Enable\nWhen EVNT_DEB_EN is set, the external event pin de-bounce circuit will be enabled to eliminate the bouncing of the signal.\nIn de-bounce circuit the external event pin will be sampled 4 times by TMRx_CLK.\nNote: When EVENT_EN (TMRx_CTL[12]) is enabled, enable this bit is recommended. And, while EVENT_EN (TMRx_CTL[12]) is disabled, disable this bit is recommended to save power consumption.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>De-bounce circuit Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>De-bounce circuit Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TCAP_EN</name>
              <description>TCapture Pin Functional Enable\nThis bit controls if the transition on TCapture pin could be used as timer counter reset function or timer capture function.\nNote: For TMRx_CTL, if INTR_TRG_EN  (TMRx_CTL[24]) is set, the TCAP_EN will be forced to low and the TCapture pin transition is ignored.\nNote: For TMRx+1_CTL, if INTR_TRG_EN  (TMRx_CTL[24]) is set, the TCAP_EN will be forced to high.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The transition on TCapture pin is ignored</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The transition on TCapture pin will result in the capture or reset of 24-bit timer counter</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TCAP_MODE</name>
              <description>TCapture Pin Function Mode Selection\nThis bit indicates if the transition on TCapture pin is used as timer counter reset function or timer capture function.\nNote: For TMRx+1_CTL, if INTR_TRG_EN is set, the TCAP_MODE will be forced to low.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transition on TCapture pin is used as timer capture function</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transition on TCapture pin is used as timer counter reset function</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TCAP_EDGE</name>
              <description>TCapture Pin Edge Detect Selection\n</description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAP_CNT_MOD</name>
              <description>Timer Capture Counting Mode Selection\nThis bit indicates the behavior of 24-bit up-counting timer while TCAP_EN (TMRx_CTL[16]) is set to high.\nIf this bit is 0, the free-counting mode, the behavior of 24-bit up-counting timer is defined by MODE_SEL (TMRx_CTL[5:4]) field. When TCAP_EN (TMRx_CTL[16]) is set, TCAP_MODE  (TMRx_CTL[17]) is 0, and the transition of Tcapture pin matches the TCAP_EDGE (TMRx_CTL[19:18]) setting, the value of 24-bit up-counting timer will be saved into register TMRx_TCAP.\nIf this bit is 1, Trigger-counting mode, 24-bit up-counting timer will be not counting and keep its value at zero. When TCAP_EN (TMRx_CTL[16]) is set, TCAP_MODE (TMRx_CTL[17]) is 0, and once the transition of external pin matches the 1st transition of TCAP_EDGE (TMRx_CTL[19:18]) setting, the 24-bit up-counting timer will start counting. And then if the transition of external pin matches the 2nd transition of TCAP_EDGE (TMRx_CTL[19:18])  setting, the 24-bit up-counting timer will stop counting. And its value will be saved into register TMRx_TCAP.\nNote: For TMRx+1_CTL, if INTR_TRG_EN (TMRx_CTL[24]) is set, the CAP_CNT_MOD will be forced to high, the capture with trigger-counting timer mode.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Capture with free-counting timer mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture with trigger-counting timer mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TCAP_DEB_EN</name>
              <description>TCapture Pin De-Bounce Enable\nWhen CAP_DEB_EN is set, the TCapture pin de-bounce circuit will be enabled to eliminate the bouncing of the signal.\nIn de-bounce circuit the TCapture pin signal will be sampled 4 times by TMRx_CLK.\nNote: When TCAP_EN (TMRx_CTL[16]) is enabled, enable this bit is recommended. And, while TCAP_EN (TMRx_CTL[16]) is disabled, disable this bit is recommended to save power consumption.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>De-bounce circuit Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>De-bounce circuit Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INTR_TRG_EN</name>
              <description>Inter-Timer Trigger Mode Enable\nThis bit controls if the inter-timer trigger mode is enabled.\nIf inter-timer trigger mode is enabled, the TMRx will be in counter mode and counting with external Clock Source or event. And, TMRx +1 will be in trigger-counting mode of capture function.\nNote: For TMRx+1_CTL, this bit is ignored and the read back value is always 1'b0.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inter-timer trigger mode is disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inter-timer trigger mode is enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TMR2_PRECNT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TMR2_PRECNT</displayName>
          <description>Timer 2 Pre-scale Counter Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRESCALE_CNT</name>
              <description>Pre-Scale Counter\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TMR2_CMPR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TMR2_CMPR</displayName>
          <description>Timer 2 Compare Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TMR_CMP</name>
              <description>Timer Compared Value\nTMR_CMP is a 24-bit compared register. When the internal 24-bit up-counter counts and its value is equal to TMR_CMP value, a Timer Interrupt is requested if the timer interrupt is enabled with TMR_EN (TMRx_CTL[0]) is enabled. The TMR_CMP value defines the timer counting cycle time.\nNote1: Never write 0 or 1 in TMR_CMP, or the core will run into unknown state.\nNote2: No matter TMR_EN (TMRx_CTL[0]) is 0 or 1, whenever software write a new value into this register, TIMER will restart counting using this new value and abort previous count.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TMR2_IER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TMR2_IER</displayName>
          <description>Timer 2 Interrupt Enable Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TMR_IE</name>
              <description>Timer Interrupt Enable\nNOTE: If timer interrupt is enabled, the timer asserts its interrupt signal when the associated counter is equal to TMR_CMPR.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TCAP_IE</name>
              <description>Timer Capture Function Interrupt Enable\nNOTE: If timer external pin function interrupt is enabled, the timer asserts its interrupt signal when the TCAP_EN (TMRx_CTL[16]) is set and the transition of external pin matches the TCAP_EDGE (TMRx_CTL[19:18])setting.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer External Pin Function Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer External Pin Function Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TMR2_ISR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TMR2_ISR</displayName>
          <description>Timer 2 Interrupt Status Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TMR_IS</name>
              <description>Timer Interrupt Status\nThis bit indicates the interrupt status of Timer.\nThis bit is set by hardware when the up counting value of internal 24-bit counter matches the timer compared value (TMR_CMPR). Write 1 to clear this bit to zero.\nIf this bit is active and TMR_IE (TMRx_IER[0]) is enabled, Timer will trigger an interrupt to CPU.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TCAP_IS</name>
              <description>Timer Capture Function Interrupt Status\nThis bit indicates the external pin function interrupt status of Timer.\nThis bit is set by hardware when TCAP_EN (TMRx_CTL[16]) is set high, and the transition of external pin matches the TCAP_EDGE (TMRx_CTL[19:18]) setting. Write 1 to clear this bit to zero.\nIf this bit is active and TCAP_IE (TMRx_IER[1]) is enabled, Timer will trigger an interrupt to CPU.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR_Wake_STS</name>
              <description>Timer Wake-Up Status\nIf timer causes CPU wakes up from power-down mode, this bit will be set to high. It must be cleared by software with a write 1 to this bit.\n0: Timer does not cause system wake-up.\n1: Wakes system up from power-down mode by Timer timeout.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NCAP_DET_STS</name>
              <description>New Capture Detected Status\nThis status is to indicate there is a new incoming capture event detected before CPU clearing the TCAP_IS (TMRx_ISR[1]) status.\nIf the above condition occurred, the Timer will keep register TMRx_CAP unchanged and drop the new capture value.\nThis bit is also cleared to 0 while TCAP_IS (TMRx_ISR[1]) is cleared.\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>New incoming capture event didn't detect before CPU clearing TCAP_IS (TMRx_ISR[1]) status</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>New incoming capture event detected before CPU clearing TCAP_IS (TMRx_ISR[1]) status</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TMR2_DR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TMR2_DR</displayName>
          <description>Timer 2 Data Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TDR</name>
              <description>Timer Data Register\nUser can read this register for internal 24-bit timer up-counter value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TMR2_TCAP</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TMR2_TCAP</displayName>
          <description>Timer 2 Capture Data Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CAP</name>
              <description>Timer Capture Data Register\nWhen TCAP_EN (TMRx_CTL[16]) is set, TCAP_MODE (TMRx_CTL[17]) is 0, TCAP_CNT_MOD (TMRx_CTL[20]) is 0, and the transition of external pin matches the TCAP_EDGE (TMRx_CTL[19:18]) setting, the value of 24-bit up-counting timer will be saved into register TMRx_TCAP.\nWhen TCAP_EN (TMRx_CTL[16]) is set, TCAP_MODE (TMRx_CTL[17]) is 0, TCAP_CNT_MOD (TMRx_CTL[20]) is 1, and the transition of external pin matches the 2nd transition of TCAP_EDGE (TMRx_CTL[19:18]) setting, the value of 24-bit up-counting timer will be saved into register TMRx_TCAP.\nUser can read this register to get the counter value.\nWhen a new incoming capture event detected before CPU clearing the TCAP_IS (TMRx_ISR[1]) status, Timer will keep this filed value unchanged and drop the new capture value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>TMR3</name>
      <description>TMR Register Map</description>
      <groupName>TMR</groupName>
      <baseAddress>0x40110100</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1C</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>TMR3_CTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TMR3_CTL</displayName>
          <description>Timer 3 Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TMR_EN</name>
              <description>Timer Counter Enable Bit\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Stops/Suspends counting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Starts counting</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_RST</name>
              <description>Software Reset\nSet this bit will reset the timer counter, pre-scale counter and also force TMR_EN (TMRx_CTL[0])  to 0.\nNote: This bit will auto clear and takes at least 3 TMRx_CLK clock cycles.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset Timer's pre-scale counter, internal 24-bit up-counter and TMR_EN (TMRx_CTL[0]) bit</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKE_EN</name>
              <description>Wake-Up Enable\nWhen WAKE_EN is set and the TMR_IS (TMRx_ISR[0]) or TCAP_IS (TMRx_ISR[1])  is set, the timer controller will generate a wake-up trigger event to CPU.\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Wake-up trigger event disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Wake-up trigger event enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBGACK_EN</name>
              <description>ICE Debug Mode Acknowledge Ineffective Enable\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ICE debug mode acknowledgement effects TIMER counting and TIMER counter will be held while ICE debug mode acknowledged</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ICE debug mode acknowledgement is ineffective and TIMER counter will keep going no matter ICE debug mode acknowledged or not</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE_SEL</name>
              <description>Timer Operating Mode Select\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR_ACT</name>
              <description>Timer Active Status Bit (Read Only)\nThis bit indicates the timer counter status of timer.\n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer is not active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer is in active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>ADC_TEEN</name>
              <description>TMR_IS Or TCAP_IS Trigger ADC Enable\nThis bit controls if TMR_IS (TMRx_ISR[0]) or TCAP_IS (TMRx_ISR[1]) could trigger ADC.\nWhen ADC_TEEN is set, TMR_IS (TMRx_ISR[0]) is set and the CAP_TRG_EN (TMRx_CTL[11]) is low, the timer controller will generate an internal trigger event to ADC controller.\nWhen ADC_TEEN is set, TCAP_IS (TMRx_ISR[1]) is set and the CAP_TRG_EN (TMRx_CTL[11]) is high, the timer controller will generate an internal trigger event to ADC controller.\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TMR_IS (TMRx_ISR[0]) or TCAP_IS (TMRx_ISR[1])  trigger ADC Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TMR_IS (TMRx_ISR[0]) or TCAP_IS (TMRx_ISR[1]) trigger ADC Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PDMA_TEEN</name>
              <description>TMR_IS Or TCAP_IS Trigger PDMA Enable\nThis bit controls if TMR_IS (TMRx_ISR[0])  or TCAP_IS (TMRx_ISR[1]) could trigger PDMA.\nWhen PDMA_TEEN is set, TMR_IS (TMRx_ISR[0]) is set and the CAP_TRG_EN (TMRx_CTL[11]) is low, the timer controller will generate an internal trigger event to PDMA controller.\nWhen PDMA_TEEN is set, TCAP_IS (TMRx_ISR[1]) is set and the CAP_TRG_EN (TMRx_CTL[11]) is high, the timer controller will generate an internal trigger event to PDMA controller.\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TMR_IS (TMRx_ISR[0]) or TCAP_IS (TMRx_ISR[1]) trigger PDMA Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TMR_IS (TMRx_ISR[0]) or TCAP_IS (TMRx_ISR[1])trigger PDMA Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAP_TRG_EN</name>
              <description>TCAP_IS Trigger Mode Enable\nThis bit controls if the TMR_IS (TMRx_ISR[0]) or TCAP_IS (TMRx_ISR[1]) is used to trigger PDMA and ADC while TMR_IS (TMRx_ISR[0]) or TCAP_IS (TMRx_ISR[1]) is set.\nIf this bit is low and TMR_IS (TMRx_ISR[0]) is set, timer will generate an internal trigger event to PDMA or ADC while related trigger enable bit (PDMA_TEEN, or ADC_TEEN) is also set.\nIf this bit is set high and TCAP_IS is set, timer will generate an internal trigger event to PDMA or ADC while related trigger enable bit (PDMA_TEEN (TMRx_CTL[10]), or ADC_TEEN(TMRx_CTL[8])) is also set.\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TMR_IS (TMRx_ISR[0]) is used to trigger PDMA and ADC</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TCAP_IS (TMRx_ISR[1]) is used to trigger PDMA and ADC</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EVENT_EN</name>
              <description>Event Counting Mode Enable\nWhen EVENT_EN is set, the increase of 24-bit up-counting timer is controlled by external event pin.\nWhile the transition of external event pin matches the definition of EVENT_EDGE (TMRx_CTL[13]), the 24-bit up-counting timer increases by 1. Or, the 24-bit up-counting timer will keep its value unchanged.\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer counting is not controlled by external event pin</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer counting is controlled by external event pin</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EVENT_EDGE</name>
              <description>Event Counting Mode Edge Selection\nThis bit indicates which edge of external event pin enabling the timer to increase 1.\n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>A falling edge of external event enabling the timer to increase 1</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>A rising edge of external event enabling the timer to increase 1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EVNT_DEB_EN</name>
              <description>External Event De-Bounce Enable\nWhen EVNT_DEB_EN is set, the external event pin de-bounce circuit will be enabled to eliminate the bouncing of the signal.\nIn de-bounce circuit the external event pin will be sampled 4 times by TMRx_CLK.\nNote: When EVENT_EN (TMRx_CTL[12]) is enabled, enable this bit is recommended. And, while EVENT_EN (TMRx_CTL[12]) is disabled, disable this bit is recommended to save power consumption.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>De-bounce circuit Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>De-bounce circuit Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TCAP_EN</name>
              <description>TCapture Pin Functional Enable\nThis bit controls if the transition on TCapture pin could be used as timer counter reset function or timer capture function.\nNote: For TMRx_CTL, if INTR_TRG_EN  (TMRx_CTL[24]) is set, the TCAP_EN will be forced to low and the TCapture pin transition is ignored.\nNote: For TMRx+1_CTL, if INTR_TRG_EN  (TMRx_CTL[24]) is set, the TCAP_EN will be forced to high.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The transition on TCapture pin is ignored</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The transition on TCapture pin will result in the capture or reset of 24-bit timer counter</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TCAP_MODE</name>
              <description>TCapture Pin Function Mode Selection\nThis bit indicates if the transition on TCapture pin is used as timer counter reset function or timer capture function.\nNote: For TMRx+1_CTL, if INTR_TRG_EN is set, the TCAP_MODE will be forced to low.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transition on TCapture pin is used as timer capture function</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transition on TCapture pin is used as timer counter reset function</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TCAP_EDGE</name>
              <description>TCapture Pin Edge Detect Selection\n</description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAP_CNT_MOD</name>
              <description>Timer Capture Counting Mode Selection\nThis bit indicates the behavior of 24-bit up-counting timer while TCAP_EN (TMRx_CTL[16]) is set to high.\nIf this bit is 0, the free-counting mode, the behavior of 24-bit up-counting timer is defined by MODE_SEL (TMRx_CTL[5:4]) field. When TCAP_EN (TMRx_CTL[16]) is set, TCAP_MODE  (TMRx_CTL[17]) is 0, and the transition of Tcapture pin matches the TCAP_EDGE (TMRx_CTL[19:18]) setting, the value of 24-bit up-counting timer will be saved into register TMRx_TCAP.\nIf this bit is 1, Trigger-counting mode, 24-bit up-counting timer will be not counting and keep its value at zero. When TCAP_EN (TMRx_CTL[16]) is set, TCAP_MODE (TMRx_CTL[17]) is 0, and once the transition of external pin matches the 1st transition of TCAP_EDGE (TMRx_CTL[19:18]) setting, the 24-bit up-counting timer will start counting. And then if the transition of external pin matches the 2nd transition of TCAP_EDGE (TMRx_CTL[19:18])  setting, the 24-bit up-counting timer will stop counting. And its value will be saved into register TMRx_TCAP.\nNote: For TMRx+1_CTL, if INTR_TRG_EN (TMRx_CTL[24]) is set, the CAP_CNT_MOD will be forced to high, the capture with trigger-counting timer mode.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Capture with free-counting timer mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture with trigger-counting timer mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TCAP_DEB_EN</name>
              <description>TCapture Pin De-Bounce Enable\nWhen CAP_DEB_EN is set, the TCapture pin de-bounce circuit will be enabled to eliminate the bouncing of the signal.\nIn de-bounce circuit the TCapture pin signal will be sampled 4 times by TMRx_CLK.\nNote: When TCAP_EN (TMRx_CTL[16]) is enabled, enable this bit is recommended. And, while TCAP_EN (TMRx_CTL[16]) is disabled, disable this bit is recommended to save power consumption.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>De-bounce circuit Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>De-bounce circuit Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INTR_TRG_EN</name>
              <description>Inter-Timer Trigger Mode Enable\nThis bit controls if the inter-timer trigger mode is enabled.\nIf inter-timer trigger mode is enabled, the TMRx will be in counter mode and counting with external Clock Source or event. And, TMRx +1 will be in trigger-counting mode of capture function.\nNote: For TMRx+1_CTL, this bit is ignored and the read back value is always 1'b0.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inter-timer trigger mode is disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inter-timer trigger mode is enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TMR3_PRECNT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TMR3_PRECNT</displayName>
          <description>Timer 3 Pre-scale Counter Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRESCALE_CNT</name>
              <description>Pre-Scale Counter\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TMR3_CMPR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TMR3_CMPR</displayName>
          <description>Timer 3 Compare Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TMR_CMP</name>
              <description>Timer Compared Value\nTMR_CMP is a 24-bit compared register. When the internal 24-bit up-counter counts and its value is equal to TMR_CMP value, a Timer Interrupt is requested if the timer interrupt is enabled with TMR_EN (TMRx_CTL[0]) is enabled. The TMR_CMP value defines the timer counting cycle time.\nNote1: Never write 0 or 1 in TMR_CMP, or the core will run into unknown state.\nNote2: No matter TMR_EN (TMRx_CTL[0]) is 0 or 1, whenever software write a new value into this register, TIMER will restart counting using this new value and abort previous count.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TMR3_IER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TMR3_IER</displayName>
          <description>Timer 3 Interrupt Enable Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TMR_IE</name>
              <description>Timer Interrupt Enable\nNOTE: If timer interrupt is enabled, the timer asserts its interrupt signal when the associated counter is equal to TMR_CMPR.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TCAP_IE</name>
              <description>Timer Capture Function Interrupt Enable\nNOTE: If timer external pin function interrupt is enabled, the timer asserts its interrupt signal when the TCAP_EN (TMRx_CTL[16]) is set and the transition of external pin matches the TCAP_EDGE (TMRx_CTL[19:18])setting.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer External Pin Function Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer External Pin Function Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TMR3_ISR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TMR3_ISR</displayName>
          <description>Timer 3 Interrupt Status Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TMR_IS</name>
              <description>Timer Interrupt Status\nThis bit indicates the interrupt status of Timer.\nThis bit is set by hardware when the up counting value of internal 24-bit counter matches the timer compared value (TMR_CMPR). Write 1 to clear this bit to zero.\nIf this bit is active and TMR_IE (TMRx_IER[0]) is enabled, Timer will trigger an interrupt to CPU.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TCAP_IS</name>
              <description>Timer Capture Function Interrupt Status\nThis bit indicates the external pin function interrupt status of Timer.\nThis bit is set by hardware when TCAP_EN (TMRx_CTL[16]) is set high, and the transition of external pin matches the TCAP_EDGE (TMRx_CTL[19:18]) setting. Write 1 to clear this bit to zero.\nIf this bit is active and TCAP_IE (TMRx_IER[1]) is enabled, Timer will trigger an interrupt to CPU.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR_Wake_STS</name>
              <description>Timer Wake-Up Status\nIf timer causes CPU wakes up from power-down mode, this bit will be set to high. It must be cleared by software with a write 1 to this bit.\n0: Timer does not cause system wake-up.\n1: Wakes system up from power-down mode by Timer timeout.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NCAP_DET_STS</name>
              <description>New Capture Detected Status\nThis status is to indicate there is a new incoming capture event detected before CPU clearing the TCAP_IS (TMRx_ISR[1]) status.\nIf the above condition occurred, the Timer will keep register TMRx_CAP unchanged and drop the new capture value.\nThis bit is also cleared to 0 while TCAP_IS (TMRx_ISR[1]) is cleared.\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>New incoming capture event didn't detect before CPU clearing TCAP_IS (TMRx_ISR[1]) status</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>New incoming capture event detected before CPU clearing TCAP_IS (TMRx_ISR[1]) status</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TMR3_DR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TMR3_DR</displayName>
          <description>Timer 3 Data Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TDR</name>
              <description>Timer Data Register\nUser can read this register for internal 24-bit timer up-counter value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TMR3_TCAP</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TMR3_TCAP</displayName>
          <description>Timer 3 Capture Data Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CAP</name>
              <description>Timer Capture Data Register\nWhen TCAP_EN (TMRx_CTL[16]) is set, TCAP_MODE (TMRx_CTL[17]) is 0, TCAP_CNT_MOD (TMRx_CTL[20]) is 0, and the transition of external pin matches the TCAP_EDGE (TMRx_CTL[19:18]) setting, the value of 24-bit up-counting timer will be saved into register TMRx_TCAP.\nWhen TCAP_EN (TMRx_CTL[16]) is set, TCAP_MODE (TMRx_CTL[17]) is 0, TCAP_CNT_MOD (TMRx_CTL[20]) is 1, and the transition of external pin matches the 2nd transition of TCAP_EDGE (TMRx_CTL[19:18]) setting, the value of 24-bit up-counting timer will be saved into register TMRx_TCAP.\nUser can read this register to get the counter value.\nWhen a new incoming capture event detected before CPU clearing the TCAP_IS (TMRx_ISR[1]) status, Timer will keep this filed value unchanged and drop the new capture value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PWM0</name>
      <description>PWM Register Map</description>
      <groupName>PWM</groupName>
      <baseAddress>0x40040000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x18</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x1C</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x28</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x34</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x40</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x54</offset>
        <size>0x34</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>PWM0_PRES</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM0_PRES</displayName>
          <description>PWM Prescaler Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CP01</name>
              <description>Clock Prescaler 0 For PWM Timer 0   1\nClock input is divided by (CP01 + 1) before it is fed to the counter 0   1\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CP23</name>
              <description>Clock Prescaler 2 For PWM Timer 2   3\nClock input is divided by (CP23 + 1) before it is fed to the counter 2   3\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DZ01</name>
              <description>Dead Zone Interval Register For CH0 And CH1 Pair\nThese 8 bits determine dead zone length.\nThe unit time of dead zone length is received from clock selector 0.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DZ23</name>
              <description>Dead Zone Interval Register For CH2 And CH3 Pair\nThese 8 bits determine dead zone length.\nThe unit time of dead zone length is received from clock selector 2.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PWM0_PRES">
          <name>PWM1_PRES</name>
          <displayName>PWM1_PRES</displayName>
          <description>PWM Prescaler Register</description>
          <alternateRegister>PWM0_PRES</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register>
          <name>PWM0_CLKSEL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM0_CLKSEL</displayName>
          <description>PWM Clock Select Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLKSEL0</name>
              <description>Timer 0 Clock Source Selection\nSelect clock input for timer 0.\n(Table is the same as CLKSEL3)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CLKSEL1</name>
              <description>Timer 1 Clock Source Selection\nSelect clock input for timer 1.\n(Table is the same as CLKSEL3)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CLKSEL2</name>
              <description>Timer 2Clock Source Selection\nSelect clock input for timer 2.\n(Table is the same as CLKSEL3)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CLKSEL3</name>
              <description>Timer 3 Clock Source Selection\nSelect clock input for timer 3.\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>input clock is divided by 2</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>input clock is divided by 4</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>input clock is divided by 8</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>input clock is divided by 16</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>input clock is divided by 1</description>
                    <value>#100</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PWM0_CLKSEL">
          <name>PWM1_CLKSEL</name>
          <displayName>PWM1_CLKSEL</displayName>
          <description>PWM Clock Select Register</description>
          <alternateRegister>PWM0_CLKSEL</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register>
          <name>PWM0_CTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM0_CTL</displayName>
          <description>PWM Control Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH0EN</name>
              <description>PWM-Timer 0 Enable/Disable Start Run\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM-Timer 0 Running Stopped</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM-Timer 0 Start Run Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH0INV</name>
              <description>PWM-Timer 0 Output Inverter ON/OFF\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inverter OFF</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverter ON</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH0MOD</name>
              <description>PWM-Timer 0 Continuous/One-Shot Mode\nNote: If there is a rising transition at this bit, it will cause CN and CM of PWMx_DUTY0 to be cleared.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One-shot Mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Continuous Mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DZEN01</name>
              <description>Dead-Zone 0 Generator Enable/Disable\nNote: When Dead-Zone Generator is enabled, the pair of PWM0 and PWM1 becomes a complementary pair.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DZEN23</name>
              <description>Dead-Zone 2 Generator Enable/Disable\nNote: When Dead-Zone Generator is enabled, the pair of PWM2 and PWM3 becomes a complementary pair.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH1EN</name>
              <description>PWM-Timer 1 Enable/Disable Start Run\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM-Timer 1 Running Stopped</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM-Timer 1 Start Run Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH1INV</name>
              <description>PWM-Timer 1 Output Inverter ON/OFF\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inverter OFF</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverter ON</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH1MOD</name>
              <description>PWM-Timer 1 Continuous/One-Shot Mode\nNote: If there is a rising transition at this bit, it will cause CN and CM of PWMx_DUTY1 to be cleared.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One-shot Mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Continuous Mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH2EN</name>
              <description>PWM-Timer 2 Enable/Disable Start Run\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM-Timer 2 Running Stopped</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM-Timer 2 Start Run Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH2INV</name>
              <description>PWM-Timer 2 Output Inverter ON/OFF\n</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inverter OFF</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverter ON</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH2MOD</name>
              <description>PWM-Timer 2 Continuous/One-Shot Mode\nNote: If there is a rising transition at this bit, it will cause CN and CM of PWMx_DUTY2 be cleared.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One-shot Mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Continuous Mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH3EN</name>
              <description>PWM-Timer 3 Enable/Disable Start Run\n</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM-Timer 3 Running Stopped</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM-Timer 3 Start Run Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH3INV</name>
              <description>PWM-Timer 3 Output Inverter ON/OFF\n</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inverter OFF</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverter ON</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH3MOD</name>
              <description>PWM-Timer 3 Continuous/One-Shot Mode\nNote: If there is a rising transition at this bit, it will cause CN and CM of PWMx_DUTY3 to be cleared.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One-shot Mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Continuous Mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PWM0_CTL">
          <name>PWM1_CTL</name>
          <displayName>PWM1_CTL</displayName>
          <description>PWM Control Register</description>
          <alternateRegister>PWM0_CTL</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register>
          <name>PWM0_INTEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM0_INTEN</displayName>
          <description>PWM Interrupt Enable Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TMIE0</name>
              <description>PWM Timer 0 Interrupt Enable\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMIE1</name>
              <description>PWM Timer 1 Interrupt Enable\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMIE2</name>
              <description>PWM Timer 2 Interrupt Enable\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMIE3</name>
              <description>PWM Timer 3 Interrupt Enable\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PWM0_INTEN">
          <name>PWM1_INTEN</name>
          <displayName>PWM1_INTEN</displayName>
          <description>PWM Interrupt Enable Register</description>
          <alternateRegister>PWM0_INTEN</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register>
          <name>PWM0_INTSTS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM0_INTSTS</displayName>
          <description>PWM Interrupt Indication Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000010</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TMINT0</name>
              <description>PWM Timer 0 Interrupt Flag\nFlag is set by hardware when PWM0 down counter reaches zero, software can clear this bit by writing a one to it.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TMINT1</name>
              <description>PWM Timer 1 Interrupt Flag\nFlag is set by hardware when PWM1 down counter reaches zero, software can clear this bit by writing a one to it.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TMINT2</name>
              <description>PWM Timer 2 Interrupt Flag\nFlag is set by hardware when PWM2 down counter reaches zero, software can clear this bit by writing a one to it.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TMINT3</name>
              <description>PWM Timer 3 Interrupt Flag\nFlag is set by hardware when PWM3 down counter reaches zero, software can clear this bit by writing a one to it.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>Duty0Syncflag</name>
              <description>Duty0 Synchronize Flag\nNote: software should check this flag when writing duty0, if this flag is set, and user ignore this flag and change duty0, the corresponding CNR and CMR may be wrong for one duty cycle</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Duty0 has been synchronized to ECLK domain</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Duty0 is synchronizing to ECLK domain</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>Duty1Syncflag</name>
              <description>Duty1 Synchronize Flag\nNote: software should check this flag when writing duty1, if this flag is set, and user ignore this flag and change duty1, the corresponding CNR and CMR may be wrong for one duty cycle</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Duty1 has been synchronized to ECLK domain</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Duty1 is synchronizing to ECLK domain</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>Duty2Syncflag</name>
              <description>Duty2 Synchronize Flag\nNote: software should check this flag when writing duty2, if this flag is set, and user ignore this flag and change duty2, the corresponding CNR and CMR may be wrong for one duty cycle</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Duty2 has been synchronized to ECLK domain</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Duty2 is synchronizing to ECLK domain</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>Duty3Syncflag</name>
              <description>Duty3 Synchronize Flag\nNote: software should check this flag when writing duty3, if this flag is set, and user ignore this flag and change duty3, the corresponding CNR and CMR may be wrong for one duty cycle</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Duty3 has been synchronized to ECLK domain</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Duty3 is synchronizing to ECLK domain</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PresSyncFlag</name>
              <description>Prescale Synchronize Flag\nNote: software should check this flag when writing Prescale, if this flag is set, and user ignore this flag and change Prescale, the Prescale may be wrong for one  prescale cycle</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Prescale has been synchronized to ECLK domain</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Prescale is synchronizing to ECLK domain</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PWM0_INTSTS">
          <name>PWM1_INTSTS</name>
          <displayName>PWM1_INTSTS</displayName>
          <description>PWM Interrupt Indication Register</description>
          <alternateRegister>PWM0_INTSTS</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register>
          <name>PWM0_OE</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM0_OE</displayName>
          <description>PWM Output Enable Register for CH0 ~ CH3</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH0_OE</name>
              <description>PWM CH0 Output Enable Register\nNote: The corresponding GPIO pin also must be switched to PWM function (refer to GPx_MFP)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM CH0 output to pin Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM CH0 output to pin Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH1_OE</name>
              <description>PWM CH1 Output Enable Register\nNote: The corresponding GPIO pin also must be switched to PWM function (refer to GPx_MFP)</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM CH1 output to pin Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM CH1 output to pin Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH2_OE</name>
              <description>PWM CH2 Output Enable Register\nNote: The corresponding GPIO pin also must be switched to PWM function (refer to GPx_MFP)</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM CH2 output to pin Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM CH2 output to pin Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH3_OE</name>
              <description>PWM CH3 Output Enable Register\nNote: The corresponding GPIO pin also must be switched to PWM function (refer to GPx_MFP)</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM CH3 output to pin Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM CH3 output to pin Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PWM0_OE">
          <name>PWM1_OE</name>
          <displayName>PWM1_OE</displayName>
          <description>PWM Output Enable Register for CH0 ~ CH3</description>
          <alternateRegister>PWM0_OE</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register>
          <name>PWM0_DUTY0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM0_DUTY0</displayName>
          <description>PWM Counter/Comparator Register 0</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CN</name>
              <description>PWM Counter/Timer Loaded Value\nCN determines the PWM period.\nNote: \nAny write to CN will take effect in next PWM cycle.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CM</name>
              <description>PWM Comparator Register\nCM determines the PWM duty.\nNote:\n Any write to CM will take effect in next PWM cycle.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PWM0_DUTY0">
          <name>PWM1_DUTY0</name>
          <displayName>PWM1_DUTY0</displayName>
          <description>PWM Counter/Comparator Register 0</description>
          <alternateRegister>PWM0_DUTY0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register>
          <name>PWM0_DATA0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM0_DATA0</displayName>
          <description>PWM Data Register 0</description>
          <addressOffset>0x20</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>PWM Data Register\nUser can monitor PWMx_DATAy to know the current value in 16-bit down count counter of corresponding channel y.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DATA_H</name>
              <description>PWM Data Register\nUser can monitor PWMx_DATAy to know the current value in 32-bit down count counter of corresponding channel y.\nNotes:This will be valid only for the corresponding cascade enable bit is set</description>
              <bitOffset>16</bitOffset>
              <bitWidth>15</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>sync</name>
              <description>Indicate That CNR Value Is Sync To PWM Counter\nNote: when the corresponding cascade enable .bit is set is bit will not appear in the corresponding channel</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>CNR value is sync to PWM counter</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CNR value is not sync to PWM counter</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PWM0_DATA0">
          <name>PWM1_DATA0</name>
          <displayName>PWM1_DATA0</displayName>
          <description>PWM Data Register 0</description>
          <alternateRegister>PWM0_DATA0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PWM0_DUTY0">
          <name>PWM0_DUTY1</name>
          <displayName>PWM0_DUTY1</displayName>
          <description>PWM Counter/Comparator Register 1</description>
          <addressOffset>0x28</addressOffset>
       </register>
       <register derivedFrom="PWM0_DUTY1">
          <name>PWM1_DUTY1</name>
          <displayName>PWM1_DUTY1</displayName>
          <description>PWM Counter/Comparator Register 1</description>
          <alternateRegister>PWM0_DUTY1</alternateRegister>
          <addressOffset>0x28</addressOffset>
       </register>
       <register derivedFrom="PWM0_DATA0">
          <name>PWM0_DATA1</name>
          <displayName>PWM0_DATA1</displayName>
          <description>PWM Data Register 1</description>
          <addressOffset>0x2C</addressOffset>
       </register>
       <register derivedFrom="PWM0_DATA1">
          <name>PWM1_DATA1</name>
          <displayName>PWM1_DATA1</displayName>
          <description>PWM Data Register 1</description>
          <alternateRegister>PWM0_DATA1</alternateRegister>
          <addressOffset>0x2C</addressOffset>
       </register>
       <register derivedFrom="PWM0_DUTY0">
          <name>PWM0_DUTY2</name>
          <displayName>PWM0_DUTY2</displayName>
          <description>PWM Counter/Comparator Register 2</description>
          <addressOffset>0x34</addressOffset>
       </register>
       <register derivedFrom="PWM0_DUTY2">
          <name>PWM1_DUTY2</name>
          <displayName>PWM1_DUTY2</displayName>
          <description>PWM Counter/Comparator Register 2</description>
          <alternateRegister>PWM0_DUTY2</alternateRegister>
          <addressOffset>0x34</addressOffset>
       </register>
       <register derivedFrom="PWM0_DATA0">
          <name>PWM0_DATA2</name>
          <displayName>PWM0_DATA2</displayName>
          <description>PWM Data Register 2</description>
          <addressOffset>0x38</addressOffset>
       </register>
       <register derivedFrom="PWM0_DATA2">
          <name>PWM1_DATA2</name>
          <displayName>PWM1_DATA2</displayName>
          <description>PWM Data Register 2</description>
          <alternateRegister>PWM0_DATA2</alternateRegister>
          <addressOffset>0x38</addressOffset>
       </register>
       <register derivedFrom="PWM0_DUTY0">
          <name>PWM0_DUTY3</name>
          <displayName>PWM0_DUTY3</displayName>
          <description>PWM Counter/Comparator Register 3</description>
          <addressOffset>0x40</addressOffset>
       </register>
       <register derivedFrom="PWM0_DUTY3">
          <name>PWM1_DUTY3</name>
          <displayName>PWM1_DUTY3</displayName>
          <description>PWM Counter/Comparator Register 3</description>
          <alternateRegister>PWM0_DUTY3</alternateRegister>
          <addressOffset>0x40</addressOffset>
       </register>
       <register derivedFrom="PWM0_DATA0">
          <name>PWM0_DATA3</name>
          <displayName>PWM0_DATA3</displayName>
          <description>PWM Data Register 3</description>
          <addressOffset>0x44</addressOffset>
       </register>
       <register derivedFrom="PWM0_DATA3">
          <name>PWM1_DATA3</name>
          <displayName>PWM1_DATA3</displayName>
          <description>PWM Data Register 3</description>
          <alternateRegister>PWM0_DATA3</alternateRegister>
          <addressOffset>0x44</addressOffset>
       </register>
       <register>
          <name>PWM0_CAPCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM0_CAPCTL</displayName>
          <description>Capture Control Register</description>
          <addressOffset>0x54</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INV0</name>
              <description>Channel 0 Inverter ON/OFF\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inverter OFF</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverter ON. Reverse the input signal from GPIO before fed to Capture timer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPCH0EN</name>
              <description>Capture Channel 0 Transition Enable/Disable\nWhen Enabled, Capture latched the PWM-timer value and saved to PWMx_CRL0 (Rising latch) and PWMx_CFL0 (Falling latch).\nWhen Disabled, Capture does not update PWMx_CRL0 and PWMx_CFL0, and disable Channel 0 Interrupt.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Capture function on channel 0 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture function on channel 0 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPCH0PADEN</name>
              <description>Capture Input Enable Register\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable the channel 0 input capture signal from corresponding multi-function pin</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable the channel 0 input capture signal from corresponding multi-function pin</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH0PDMAEN</name>
              <description>Channel 0 PDMA Enable\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Channel 0 PDMA function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Channel 0 PDMA function Enabled for the channel 0 captured data and transfer to memory</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PDMACAPMOD0</name>
              <description>Select CRL0 Or CFL0 For PDMA Transfer\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>reserved</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CRL0 will be transmitted</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>CFL0 will be transmitted</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Both CRL0 and CFL0 will be transmitted</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPRELOADREN0</name>
              <description>Reload CNR0 When CH0 Capture Rising Event Comes \n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Rising capture reload for CH0 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Rising capture reload for CH0 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPRELOADFEN0</name>
              <description>Reload CNR0 When CH0 Capture Falling Event Comes\n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Falling capture reload for CH0 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Falling capture reload for CH0 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INV1</name>
              <description>Channel 1 Inverter ON/OFF\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inverter OFF</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverter ON. Reverse the input signal from GPIO before fed to Capture timer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPCH1EN</name>
              <description>Capture Channel 1 Transition Enable/Disable\nWhen Enabled, Capture latched the PMW-counter and saved to PWMx_CRL1 (Rising latch) and PWMx_CFL1 (Falling latch).\nWhen Disabled, Capture does not update PWMx_CRL1 and PWMx_CFL1, and disable Channel 1 Interrupt.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Capture function on channel 1 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture function on channel 1 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPCH1PADEN</name>
              <description>Capture Input Enable Register\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable the channel 1 input capture signal from corresponding multi-function pin</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable the channel 1 input capture signal from corresponding multi-function pin</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH0RFORDER</name>
              <description></description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWMx_CFL0 is the first captured data to memory</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWMx_CRL0 is the first captured data to memory</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH01CASK</name>
              <description>Cascade channel 0 and channel 1 PWM timer for capturing usage</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPRELOADREN1</name>
              <description>Reload CNR1 When CH1 Capture Rising Event Comes\n</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Rising capture reload for CH1 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Rising capture reload for CH1 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPRELOADFEN1</name>
              <description>Reload CNR1 When CH1 Capture Falling Event Coming \n</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Capture falling reload for CH1 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture falling reload for CH1 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INV2</name>
              <description>Channel 2 Inverter ON/OFF\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inverter OFF</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverter ON. Reverse the input signal from GPIO before fed to Capture timer </description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPCH2EN</name>
              <description>Capture Channel 2 Transition Enable/Disable\nWhen Enabled, Capture latched the PWM-timer value and saved to PWMx_CRL2 (Rising latch) and PWMx_CFL2 (Falling latch).\nWhen Disabled, Capture does not update PWMx_CRL2 and PWMx_CFL2, and disable Channel 2 Interrupt.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Capture function on channel 2 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture function on channel 2 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPCH2PADEN</name>
              <description>Capture Input Enable Register\n</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable the channel 2 input capture signal from corresponding multi-function pin</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable the channel 2 input capture signal from corresponding multi-function pin</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH2PDMAEN</name>
              <description>Channel 2 PDMA Enable\n</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Channel 2 PDMA function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Channel 2 PDMA function Enabled for the channel 2 captured data and transfer to memory</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PDMACAPMOD2</name>
              <description>Select CRL2 Or CFL2 For PDMA Transfer\n</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>reserved</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CRL2 will be transmitted</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>CFL2 will be transmitted</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Both CRL2 and CFL2 will be transmitted</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPRELOADREN2</name>
              <description>Reload CNR2 When CH2 Capture Rising Event Coming \n</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Rising capture reload for CH2 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Rising capture reload for CH2 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPRELOADFEN2</name>
              <description>Reload CNR2 When CH2 Capture Failing Event Coming \n</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Failing capture reload for CH2 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Failing capture reload for CH2 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INV3</name>
              <description>Channel 3 Inverter ON/OFF\n</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inverter OFF</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverter ON. Reverse the input signal from GPIO before fed to Capture timer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPCH3EN</name>
              <description>Capture Channel 3 Transition Enable/Disable\nWhen Enabled, Capture latched the PMW-timer and saved to PWMx_CRL3 (Rising latch) and PWMx_CFL3 (Falling latch).\nWhen Disabled, Capture does not update PWMx_CRL3 and PWMx_CFL3, and disable Channel 3 Interrupt.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Capture function on channel 3 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture function on channel 3 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPCH3PADEN</name>
              <description>Capture Input Enable Register\n</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable the channel 3 input capture signal from corresponding multi-function pin</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable the channel 3 input capture signal from corresponding multi-function pin</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH2RFORDER</name>
              <description></description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWMx_CFL2 is the first captured data to memory</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWMx_CRL2 is the first captured data to memory</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH23CASK</name>
              <description>Cascade channel 2 and channel 3 PWM counter for capturing usage</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPRELOADREN3</name>
              <description>Reload CNR3 When CH3 Rising Capture Event Comes\n</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Rising capture reload for CH3 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Rising capture reload for CH3 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPRELOADFEN3</name>
              <description>Reload CNR3 When CH3 Falling Capture Event Comes \n</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Falling  capture reload for CH3 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Falling  capture reload for CH3 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PWM0_CAPCTL">
          <name>PWM1_CAPCTL</name>
          <displayName>PWM1_CAPCTL</displayName>
          <description>Capture Control Register</description>
          <alternateRegister>PWM0_CAPCTL</alternateRegister>
          <addressOffset>0x54</addressOffset>
       </register>
       <register>
          <name>PWM0_CAPINTEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM0_CAPINTEN</displayName>
          <description>Capture Interrupt Enable Register</description>
          <addressOffset>0x58</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CRL_IE0</name>
              <description>When Enabled, if Capture detects Channel 0 has rising transition, Capture issues an Interrupt.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Rising latch interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CFL_IE0</name>
              <description>Channel 0 Falling Latch Interrupt Enable ON/OFF\nWhen Enabled, if Capture detects Channel 0 has falling transition, Capture issues an Interrupt.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Falling latch interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Falling latch interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CRL_IE1</name>
              <description>Channel 1 Rising Latch Interrupt Enable \nWhen Enabled, if Capture detects Channel 1 has rising transition, Capture issues an Interrupt.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Rising latch interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Rising latch interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CFL_IE1</name>
              <description>Channel 1 Falling Latch Interrupt Enable \nWhen Enabled, if Capture detects Channel 1 has falling transition, Capture issues an Interrupt.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Falling latch interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Falling latch interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CRL_IE2</name>
              <description>Channel 2 Rising Latch Interrupt Enable ON/OFF\nWhen Enabled, if Capture detects Channel 2 has rising transition, Capture issues an Interrupt.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Rising latch interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Rising latch interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CFL_IE2</name>
              <description>Channel 2 Falling Latch Interrupt Enable ON/OFF\nWhen Enabled, if Capture detects Channel 2 has falling transition, Capture issues an Interrupt.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Falling latch interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Falling latch interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CRL_IE3</name>
              <description>Channel 3 Rising Latch Interrupt Enable ON/OFF\nWhen Enabled, if Capture detects Channel 3 has rising transition, Capture issues an Interrupt.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Rising latch interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Rising latch interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CFL_IE3</name>
              <description>Channel 3 Falling Latch Interrupt Enable ON/OFF\nWhen Enabled, if Capture detects Channel 3 has falling transition, Capture issues an Interrupt.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Falling latch interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Falling latch interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PWM0_CAPINTEN">
          <name>PWM1_CAPINTEN</name>
          <displayName>PWM1_CAPINTEN</displayName>
          <description>Capture Interrupt Enable Register</description>
          <alternateRegister>PWM0_CAPINTEN</alternateRegister>
          <addressOffset>0x58</addressOffset>
       </register>
       <register>
          <name>PWM0_CAPINTSTS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM0_CAPINTSTS</displayName>
          <description>Capture Interrupt Indication Register</description>
          <addressOffset>0x5C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CAPIF0</name>
              <description>Capture0 Interrupt Indication Flag\nIf channel 0 rising latch interrupt (CRL_IE0, PWMx_CAPINTEN[0]) is enabled, a rising transition occurs at input channel 0 will result in CAPIF0 to high; Similarly, a falling transition will cause CAPIF0 to be set high if channel 0 falling latch interrupt (CFL_IE0, PWMx_CAPINTEN[1]) is enabled. This flag is cleared by software with a write 1 on it.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CRLI0</name>
              <description>PWM_CRL0 Latched Indicator Bit\nWhen input channel 0 has a rising transition, PWMx_CRL0 was latched with the value of PWM down-counter and this bit is set by hardware, software can clear this bit by writing 1 to it.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CFLI0</name>
              <description>PWM_CFL0 Latched Indicator Bit\nWhen input channel 0 has a falling transition, PWMx_CFL0 was latched with the value of PWM down-counter and this bit is set by hardware, software can clear this bit by writing 1 to it.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPOVR0</name>
              <description>Capture Rising Flag Over Run For Channel 0\nThis flag indicate CRL0 update faster than software reading it when it is set \nThis bit will be cleared automatically when user clears CRLI0 (PWMx_CAPINTSTS[1]).</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPOVF0</name>
              <description>Capture Falling Flag Over Run For Channel 0\nThis flag indicate CFL0 update faster than software reading it when it is set\nThis bit will be cleared automatically when user clear CFLI0 (PWMx_CAPINTSTS[2])</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPIF1</name>
              <description>Capture1 Interrupt Indication Flag\nIf channel 1 rising latch interrupt (CRL_IE1, PWMx_CAPINTEN[8]) is enabled, a rising transition occurs at input channel 1 will result in CAPIF1 to high; Similarly, a falling transition will cause CAPIF1 to be set high if channel 1 falling latch interrupt (CFL_IE1, PWMx_CAPINTEN[9]) is enabled. This flag is cleared by software with a write 1 on it.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CRLI1</name>
              <description>PWM_CRL1 Latched Indicator Bit\nWhen input channel 1 has a rising transition, PWMx_CRL1 was latched with the value of PWM down-counter and this bit is set by hardware, software can clear this bit by writing 1 to it.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CFLI1</name>
              <description>PWM_CFL1 Latched Indicator Bit\nWhen input channel 1 has a falling transition, PWMx_CFL1 was latched with the value of PWM down-counter and this bit is set by hardware, software can clear this bit by writing a 1 to it.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPOVR1</name>
              <description>Capture Rising Flag Over Run For Channel 1\nThis flag indicate CRL1 update faster than software reading it when it is set \nThis bit will be cleared automatically when user clear CRLI1 (PWMx_CAPINTSTS[9])</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPOVF1</name>
              <description>Capture Falling Flag Over Run For Channel 1\nThis flag indicate CFL1 update faster than software reading it when it is set\nThis bit will be cleared automatically when user clear CFLI1 (PWMx_CAPINTSTS[10])</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPIF2</name>
              <description>Capture2 Interrupt Indication Flag\nIf channel 2 rising latch interrupt (CRL_IE2, PWMx_CAPINTEN[16]) is enabled, a rising transition occurs at input channel 2 will result in CAPIF2 to high; Similarly, a falling transition will cause CAPIF2 to be set high if channel 2 falling latch interrupt (CFL_IE2, PWMx_CAPINTEN[17]) is enabled. This flag is cleared by software with a write 1 on it.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CRLI2</name>
              <description>PWM_CRL2 Latched Indicator Bit\nWhen input channel 2 has a rising transition, PWMx_CRL2 was latched with the value of PWM down-counter and this bit is set by hardware, software can clear this bit by writing 1 to it.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CFLI2</name>
              <description>PWM_CFL2 Latched Indicator Bit\nWhen input channel 2 has a falling transition, PWMx_CFL2 was latched with the value of PWM down-counter and this bit is set by hardware, software can clear this bit by writing 1 to it.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPOVR2</name>
              <description>Capture Rising Flag Over Run For Channel 2\nThis flag indicate CRL2 update faster than software reading it when it is set\nThis bit will be cleared automatically when user clear CRLI2 (PWMx_CAPINTSTS[17])</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPOVF2</name>
              <description>Capture Falling Flag Over Run For Channel 2 \nThis flag indicate CFL2 update faster than software reading it when it is set\nThis bit will be cleared automatically when user clear CFLI2 (PWMx_CAPINTSTS[18])</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPIF3</name>
              <description>Capture3 Interrupt Indication Flag\nIf channel 3 rising latch interrupt (CRL_IE3, PWMx_CAPINTEN[24]) is enabled, a rising transition occurs at input channel 3 will result in CAPIF3 to high; Similarly, a falling transition will cause CAPIF3 to be set high if channel 3 falling latch interrupt (CFL_IE3, PWMx_CAPINTEN[25]) is enabled. This flag is cleared by software with a write 1 on it.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CRLI3</name>
              <description>PWM_CRL3 Latched Indicator Bit\nWhen input channel 3 has a rising transition, PWMx_CRL3 was latched with the value of PWM down-counter and this bit is set by hardware, software can clear this bit by writing 1 to it.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CFLI3</name>
              <description>PWM_CFL3 Latched Indicator Bit\nWhen input channel 3 has a falling transition, PWMx_CFL3 was latched with the value of PWM down-counter and this bit is set by hardware, software can clear this bit by writing 1 to it.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPOVR3</name>
              <description>Capture Rising Flag Over Run For Channel 3\nThis flag indicate CRL3 update faster than software reading it when it is set\nThis bit will be cleared automatically when user clear CRLI3 (PWMx_CAPINTSTS[25])</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPOVF3</name>
              <description>Capture Falling Flag Over Run For Channel 3 \nThis flag indicate CFL3 update faster than software reading it when it is set\nThis bit will be cleared automatically when user clear CFLI3 (PWMx_CAPINTSTS[26])</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PWM0_CAPINTSTS">
          <name>PWM1_CAPINTSTS</name>
          <displayName>PWM1_CAPINTSTS</displayName>
          <description>Capture Interrupt Indication Register</description>
          <alternateRegister>PWM0_CAPINTSTS</alternateRegister>
          <addressOffset>0x5C</addressOffset>
       </register>
       <register>
          <name>PWM0_CRL0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM0_CRL0</displayName>
          <description>Capture Rising Latch Register (Channel 0)</description>
          <addressOffset>0x60</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CRL</name>
              <description>Capture Rising Latch Register\nLatch the PWM counter when Channel 0/1/2/3 has rising transition.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CRL_H</name>
              <description>Upper Half Word Of 32-Bit Capture Data When Cascade Is Enable \nWhen cascade is enabled for capture channel 0, 2,the original 16 bit counter extend to 32 bit, and capture result CRL0 and CRL2 are also extend to 32 bit,</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PWM0_CRL0">
          <name>PWM1_CRL0</name>
          <displayName>PWM1_CRL0</displayName>
          <description>Capture Rising Latch Register (Channel 0)</description>
          <alternateRegister>PWM0_CRL0</alternateRegister>
          <addressOffset>0x60</addressOffset>
       </register>
       <register>
          <name>PWM0_CFL0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM0_CFL0</displayName>
          <description>Capture Falling Latch Register (Channel 0)</description>
          <addressOffset>0x64</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CFL</name>
              <description>Capture Falling Latch Register\nLatch the PWM counter when Channel 01/2/3 has Falling transition.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CFL_H</name>
              <description>Upper Half Word Of 32 Bit Capture Data When Cascade Is Enable \nWhen cascade is enabled for capture channel 0, 2,the original 16 bit counter extend to 32 bit, and capture result CFL0 and CFL2 are also extend to 32 bit,</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PWM0_CFL0">
          <name>PWM1_CFL0</name>
          <displayName>PWM1_CFL0</displayName>
          <description>Capture Falling Latch Register (Channel 0)</description>
          <alternateRegister>PWM0_CFL0</alternateRegister>
          <addressOffset>0x64</addressOffset>
       </register>
       <register derivedFrom="PWM0_CRL0">
          <name>PWM0_CRL1</name>
          <displayName>PWM0_CRL1</displayName>
          <description>Capture Rising Latch Register (Channel 1)</description>
          <addressOffset>0x68</addressOffset>
       </register>
       <register derivedFrom="PWM0_CRL1">
          <name>PWM1_CRL1</name>
          <displayName>PWM1_CRL1</displayName>
          <description>Capture Rising Latch Register (Channel 1)</description>
          <alternateRegister>PWM0_CRL1</alternateRegister>
          <addressOffset>0x68</addressOffset>
       </register>
       <register derivedFrom="PWM0_CFL0">
          <name>PWM0_CFL1</name>
          <displayName>PWM0_CFL1</displayName>
          <description>Capture Falling Latch Register (Channel 1)</description>
          <addressOffset>0x6C</addressOffset>
       </register>
       <register derivedFrom="PWM0_CFL1">
          <name>PWM1_CFL1</name>
          <displayName>PWM1_CFL1</displayName>
          <description>Capture Falling Latch Register (Channel 1)</description>
          <alternateRegister>PWM0_CFL1</alternateRegister>
          <addressOffset>0x6C</addressOffset>
       </register>
       <register derivedFrom="PWM0_CRL0">
          <name>PWM0_CRL2</name>
          <displayName>PWM0_CRL2</displayName>
          <description>Capture Rising Latch Register (Channel 2)</description>
          <addressOffset>0x70</addressOffset>
       </register>
       <register derivedFrom="PWM0_CRL2">
          <name>PWM1_CRL2</name>
          <displayName>PWM1_CRL2</displayName>
          <description>Capture Rising Latch Register (Channel 2)</description>
          <alternateRegister>PWM0_CRL2</alternateRegister>
          <addressOffset>0x70</addressOffset>
       </register>
       <register derivedFrom="PWM0_CFL0">
          <name>PWM0_CFL2</name>
          <displayName>PWM0_CFL2</displayName>
          <description>Capture Falling Latch Register (Channel 2)</description>
          <addressOffset>0x74</addressOffset>
       </register>
       <register derivedFrom="PWM0_CFL2">
          <name>PWM1_CFL2</name>
          <displayName>PWM1_CFL2</displayName>
          <description>Capture Falling Latch Register (Channel 2)</description>
          <alternateRegister>PWM0_CFL2</alternateRegister>
          <addressOffset>0x74</addressOffset>
       </register>
       <register derivedFrom="PWM0_CRL0">
          <name>PWM0_CRL3</name>
          <displayName>PWM0_CRL3</displayName>
          <description>Capture Rising Latch Register (Channel 3)</description>
          <addressOffset>0x78</addressOffset>
       </register>
       <register derivedFrom="PWM0_CRL3">
          <name>PWM1_CRL3</name>
          <displayName>PWM1_CRL3</displayName>
          <description>Capture Rising Latch Register (Channel 3)</description>
          <alternateRegister>PWM0_CRL3</alternateRegister>
          <addressOffset>0x78</addressOffset>
       </register>
       <register derivedFrom="PWM0_CFL0">
          <name>PWM0_CFL3</name>
          <displayName>PWM0_CFL3</displayName>
          <description>Capture Falling Latch Register (Channel 3)</description>
          <addressOffset>0x7C</addressOffset>
       </register>
       <register derivedFrom="PWM0_CFL3">
          <name>PWM1_CFL3</name>
          <displayName>PWM1_CFL3</displayName>
          <description>Capture Falling Latch Register (Channel 3)</description>
          <alternateRegister>PWM0_CFL3</alternateRegister>
          <addressOffset>0x7C</addressOffset>
       </register>
       <register>
          <name>PWM0_PDMACH0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM0_PDMACH0</displayName>
          <description>PDMA Channel 0 Captured Data</description>
          <addressOffset>0x80</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMACH01</name>
              <description>Captured Data Of Channel 0\nWhen CH01CASK is disabled, it is the capturing value(CFL0/CRL0) for channel 0\nWhen CH01CASK is enabled, It is the for the first byte of 32 bit capturing data for channel 0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PDMACH02</name>
              <description>Captured Data Of Channel 0\nWhen CH01CASK is disabled, it is the capturing value(CFL0/CRL0) for channel 0\nWhen CH01CASK is enabled, It is the second byte of 32 bit capturing data for channel 0</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PDMACH03</name>
              <description>Captured Data Of Channel 0\nWhen CH01CASK is disabled, this byte is 0\nWhen CH01CASK is enabled, It is the third byte of 32 bit capturing data for channel 0</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PDMACH04</name>
              <description>Captured Data Of Channel 0\nWhen CH01CASK is disabled, this byte is 0\nWhen CH01CASK is enabled, It is the fourth byte of 32 bit capturing data for channel 0</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PWM0_PDMACH0">
          <name>PWM1_PDMACH0</name>
          <displayName>PWM1_PDMACH0</displayName>
          <description>PDMA Channel 0 Captured Data</description>
          <alternateRegister>PWM0_PDMACH0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register>
          <name>PWM0_PDMACH2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM0_PDMACH2</displayName>
          <description>PDMA Channel 2 Captured Data</description>
          <addressOffset>0x84</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMACH21</name>
              <description>Captured Data Of Channel 2\nWhen CH23CASK is disabled, it is the capturing value(CFL0/CRL0) for channel 2\nWhen CH23CASK is enabled, It is the for the first byte of 32 bit capturing data for channel 2</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PDMACH22</name>
              <description>Captured Data Of Channel 2\nWhen CH23CASK is disabled, it is the capturing value(CFL0/CRL0) for channel 2\nWhen CH23CASK is enabled, It is the second byte of 32 bit capturing data for channel 2</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PDMACH23</name>
              <description>Captured Data Of Channel 2\nWhen CH23CASK is disabled, this byte is 0\nWhen CH23CASK is enabled, It is the third byte of 32 bit capturing data for channel 2</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PDMACH24</name>
              <description>Captured Data Of Channel 2\nWhen CH23CASK is disabled, this byte is 0\nWhen CH23CASK is enabled, It is the fourth byte of 32 bit capturing data for channel 2</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PWM0_PDMACH2">
          <name>PWM1_PDMACH2</name>
          <displayName>PWM1_PDMACH2</displayName>
          <description>PDMA Channel 2 Captured Data</description>
          <alternateRegister>PWM0_PDMACH2</alternateRegister>
          <addressOffset>0x84</addressOffset>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PWM1</name>
      <description>PWM Register Map</description>
      <groupName>PWM</groupName>
      <baseAddress>0x40140000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x18</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x1C</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x28</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x34</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x40</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x54</offset>
        <size>0x34</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>PWM0_PRES</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM0_PRES</displayName>
          <description>PWM Prescaler Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CP01</name>
              <description>Clock Prescaler 0 For PWM Timer 0   1\nClock input is divided by (CP01 + 1) before it is fed to the counter 0   1\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CP23</name>
              <description>Clock Prescaler 2 For PWM Timer 2   3\nClock input is divided by (CP23 + 1) before it is fed to the counter 2   3\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DZ01</name>
              <description>Dead Zone Interval Register For CH0 And CH1 Pair\nThese 8 bits determine dead zone length.\nThe unit time of dead zone length is received from clock selector 0.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DZ23</name>
              <description>Dead Zone Interval Register For CH2 And CH3 Pair\nThese 8 bits determine dead zone length.\nThe unit time of dead zone length is received from clock selector 2.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PWM0_PRES">
          <name>PWM1_PRES</name>
          <displayName>PWM1_PRES</displayName>
          <description>PWM Prescaler Register</description>
          <alternateRegister>PWM0_PRES</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register>
          <name>PWM0_CLKSEL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM0_CLKSEL</displayName>
          <description>PWM Clock Select Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLKSEL0</name>
              <description>Timer 0 Clock Source Selection\nSelect clock input for timer 0.\n(Table is the same as CLKSEL3)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CLKSEL1</name>
              <description>Timer 1 Clock Source Selection\nSelect clock input for timer 1.\n(Table is the same as CLKSEL3)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CLKSEL2</name>
              <description>Timer 2Clock Source Selection\nSelect clock input for timer 2.\n(Table is the same as CLKSEL3)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CLKSEL3</name>
              <description>Timer 3 Clock Source Selection\nSelect clock input for timer 3.\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>input clock is divided by 2</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>input clock is divided by 4</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>input clock is divided by 8</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>input clock is divided by 16</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>input clock is divided by 1</description>
                    <value>#100</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PWM0_CLKSEL">
          <name>PWM1_CLKSEL</name>
          <displayName>PWM1_CLKSEL</displayName>
          <description>PWM Clock Select Register</description>
          <alternateRegister>PWM0_CLKSEL</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register>
          <name>PWM0_CTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM0_CTL</displayName>
          <description>PWM Control Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH0EN</name>
              <description>PWM-Timer 0 Enable/Disable Start Run\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM-Timer 0 Running Stopped</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM-Timer 0 Start Run Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH0INV</name>
              <description>PWM-Timer 0 Output Inverter ON/OFF\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inverter OFF</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverter ON</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH0MOD</name>
              <description>PWM-Timer 0 Continuous/One-Shot Mode\nNote: If there is a rising transition at this bit, it will cause CN and CM of PWMx_DUTY0 to be cleared.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One-shot Mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Continuous Mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DZEN01</name>
              <description>Dead-Zone 0 Generator Enable/Disable\nNote: When Dead-Zone Generator is enabled, the pair of PWM0 and PWM1 becomes a complementary pair.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DZEN23</name>
              <description>Dead-Zone 2 Generator Enable/Disable\nNote: When Dead-Zone Generator is enabled, the pair of PWM2 and PWM3 becomes a complementary pair.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH1EN</name>
              <description>PWM-Timer 1 Enable/Disable Start Run\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM-Timer 1 Running Stopped</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM-Timer 1 Start Run Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH1INV</name>
              <description>PWM-Timer 1 Output Inverter ON/OFF\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inverter OFF</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverter ON</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH1MOD</name>
              <description>PWM-Timer 1 Continuous/One-Shot Mode\nNote: If there is a rising transition at this bit, it will cause CN and CM of PWMx_DUTY1 to be cleared.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One-shot Mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Continuous Mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH2EN</name>
              <description>PWM-Timer 2 Enable/Disable Start Run\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM-Timer 2 Running Stopped</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM-Timer 2 Start Run Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH2INV</name>
              <description>PWM-Timer 2 Output Inverter ON/OFF\n</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inverter OFF</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverter ON</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH2MOD</name>
              <description>PWM-Timer 2 Continuous/One-Shot Mode\nNote: If there is a rising transition at this bit, it will cause CN and CM of PWMx_DUTY2 be cleared.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One-shot Mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Continuous Mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH3EN</name>
              <description>PWM-Timer 3 Enable/Disable Start Run\n</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM-Timer 3 Running Stopped</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM-Timer 3 Start Run Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH3INV</name>
              <description>PWM-Timer 3 Output Inverter ON/OFF\n</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inverter OFF</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverter ON</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH3MOD</name>
              <description>PWM-Timer 3 Continuous/One-Shot Mode\nNote: If there is a rising transition at this bit, it will cause CN and CM of PWMx_DUTY3 to be cleared.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One-shot Mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Continuous Mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PWM0_CTL">
          <name>PWM1_CTL</name>
          <displayName>PWM1_CTL</displayName>
          <description>PWM Control Register</description>
          <alternateRegister>PWM0_CTL</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register>
          <name>PWM0_INTEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM0_INTEN</displayName>
          <description>PWM Interrupt Enable Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TMIE0</name>
              <description>PWM Timer 0 Interrupt Enable\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMIE1</name>
              <description>PWM Timer 1 Interrupt Enable\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMIE2</name>
              <description>PWM Timer 2 Interrupt Enable\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMIE3</name>
              <description>PWM Timer 3 Interrupt Enable\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PWM0_INTEN">
          <name>PWM1_INTEN</name>
          <displayName>PWM1_INTEN</displayName>
          <description>PWM Interrupt Enable Register</description>
          <alternateRegister>PWM0_INTEN</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register>
          <name>PWM0_INTSTS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM0_INTSTS</displayName>
          <description>PWM Interrupt Indication Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000010</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TMINT0</name>
              <description>PWM Timer 0 Interrupt Flag\nFlag is set by hardware when PWM0 down counter reaches zero, software can clear this bit by writing a one to it.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TMINT1</name>
              <description>PWM Timer 1 Interrupt Flag\nFlag is set by hardware when PWM1 down counter reaches zero, software can clear this bit by writing a one to it.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TMINT2</name>
              <description>PWM Timer 2 Interrupt Flag\nFlag is set by hardware when PWM2 down counter reaches zero, software can clear this bit by writing a one to it.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TMINT3</name>
              <description>PWM Timer 3 Interrupt Flag\nFlag is set by hardware when PWM3 down counter reaches zero, software can clear this bit by writing a one to it.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>Duty0Syncflag</name>
              <description>Duty0 Synchronize Flag\nNote: software should check this flag when writing duty0, if this flag is set, and user ignore this flag and change duty0, the corresponding CNR and CMR may be wrong for one duty cycle</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Duty0 has been synchronized to ECLK domain</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Duty0 is synchronizing to ECLK domain</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>Duty1Syncflag</name>
              <description>Duty1 Synchronize Flag\nNote: software should check this flag when writing duty1, if this flag is set, and user ignore this flag and change duty1, the corresponding CNR and CMR may be wrong for one duty cycle</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Duty1 has been synchronized to ECLK domain</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Duty1 is synchronizing to ECLK domain</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>Duty2Syncflag</name>
              <description>Duty2 Synchronize Flag\nNote: software should check this flag when writing duty2, if this flag is set, and user ignore this flag and change duty2, the corresponding CNR and CMR may be wrong for one duty cycle</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Duty2 has been synchronized to ECLK domain</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Duty2 is synchronizing to ECLK domain</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>Duty3Syncflag</name>
              <description>Duty3 Synchronize Flag\nNote: software should check this flag when writing duty3, if this flag is set, and user ignore this flag and change duty3, the corresponding CNR and CMR may be wrong for one duty cycle</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Duty3 has been synchronized to ECLK domain</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Duty3 is synchronizing to ECLK domain</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PresSyncFlag</name>
              <description>Prescale Synchronize Flag\nNote: software should check this flag when writing Prescale, if this flag is set, and user ignore this flag and change Prescale, the Prescale may be wrong for one  prescale cycle</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Prescale has been synchronized to ECLK domain</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Prescale is synchronizing to ECLK domain</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PWM0_INTSTS">
          <name>PWM1_INTSTS</name>
          <displayName>PWM1_INTSTS</displayName>
          <description>PWM Interrupt Indication Register</description>
          <alternateRegister>PWM0_INTSTS</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register>
          <name>PWM0_OE</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM0_OE</displayName>
          <description>PWM Output Enable Register for CH0 ~ CH3</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH0_OE</name>
              <description>PWM CH0 Output Enable Register\nNote: The corresponding GPIO pin also must be switched to PWM function (refer to GPx_MFP)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM CH0 output to pin Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM CH0 output to pin Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH1_OE</name>
              <description>PWM CH1 Output Enable Register\nNote: The corresponding GPIO pin also must be switched to PWM function (refer to GPx_MFP)</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM CH1 output to pin Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM CH1 output to pin Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH2_OE</name>
              <description>PWM CH2 Output Enable Register\nNote: The corresponding GPIO pin also must be switched to PWM function (refer to GPx_MFP)</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM CH2 output to pin Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM CH2 output to pin Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH3_OE</name>
              <description>PWM CH3 Output Enable Register\nNote: The corresponding GPIO pin also must be switched to PWM function (refer to GPx_MFP)</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM CH3 output to pin Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM CH3 output to pin Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PWM0_OE">
          <name>PWM1_OE</name>
          <displayName>PWM1_OE</displayName>
          <description>PWM Output Enable Register for CH0 ~ CH3</description>
          <alternateRegister>PWM0_OE</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register>
          <name>PWM0_DUTY0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM0_DUTY0</displayName>
          <description>PWM Counter/Comparator Register 0</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CN</name>
              <description>PWM Counter/Timer Loaded Value\nCN determines the PWM period.\nNote: \nAny write to CN will take effect in next PWM cycle.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CM</name>
              <description>PWM Comparator Register\nCM determines the PWM duty.\nNote:\n Any write to CM will take effect in next PWM cycle.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PWM0_DUTY0">
          <name>PWM1_DUTY0</name>
          <displayName>PWM1_DUTY0</displayName>
          <description>PWM Counter/Comparator Register 0</description>
          <alternateRegister>PWM0_DUTY0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register>
          <name>PWM0_DATA0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM0_DATA0</displayName>
          <description>PWM Data Register 0</description>
          <addressOffset>0x20</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>PWM Data Register\nUser can monitor PWMx_DATAy to know the current value in 16-bit down count counter of corresponding channel y.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DATA_H</name>
              <description>PWM Data Register\nUser can monitor PWMx_DATAy to know the current value in 32-bit down count counter of corresponding channel y.\nNotes:This will be valid only for the corresponding cascade enable bit is set</description>
              <bitOffset>16</bitOffset>
              <bitWidth>15</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>sync</name>
              <description>Indicate That CNR Value Is Sync To PWM Counter\nNote: when the corresponding cascade enable .bit is set is bit will not appear in the corresponding channel</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>CNR value is sync to PWM counter</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CNR value is not sync to PWM counter</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PWM0_DATA0">
          <name>PWM1_DATA0</name>
          <displayName>PWM1_DATA0</displayName>
          <description>PWM Data Register 0</description>
          <alternateRegister>PWM0_DATA0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PWM0_DUTY0">
          <name>PWM0_DUTY1</name>
          <displayName>PWM0_DUTY1</displayName>
          <description>PWM Counter/Comparator Register 1</description>
          <addressOffset>0x28</addressOffset>
       </register>
       <register derivedFrom="PWM0_DUTY1">
          <name>PWM1_DUTY1</name>
          <displayName>PWM1_DUTY1</displayName>
          <description>PWM Counter/Comparator Register 1</description>
          <alternateRegister>PWM0_DUTY1</alternateRegister>
          <addressOffset>0x28</addressOffset>
       </register>
       <register derivedFrom="PWM0_DATA0">
          <name>PWM0_DATA1</name>
          <displayName>PWM0_DATA1</displayName>
          <description>PWM Data Register 1</description>
          <addressOffset>0x2C</addressOffset>
       </register>
       <register derivedFrom="PWM0_DATA1">
          <name>PWM1_DATA1</name>
          <displayName>PWM1_DATA1</displayName>
          <description>PWM Data Register 1</description>
          <alternateRegister>PWM0_DATA1</alternateRegister>
          <addressOffset>0x2C</addressOffset>
       </register>
       <register derivedFrom="PWM0_DUTY0">
          <name>PWM0_DUTY2</name>
          <displayName>PWM0_DUTY2</displayName>
          <description>PWM Counter/Comparator Register 2</description>
          <addressOffset>0x34</addressOffset>
       </register>
       <register derivedFrom="PWM0_DUTY2">
          <name>PWM1_DUTY2</name>
          <displayName>PWM1_DUTY2</displayName>
          <description>PWM Counter/Comparator Register 2</description>
          <alternateRegister>PWM0_DUTY2</alternateRegister>
          <addressOffset>0x34</addressOffset>
       </register>
       <register derivedFrom="PWM0_DATA0">
          <name>PWM0_DATA2</name>
          <displayName>PWM0_DATA2</displayName>
          <description>PWM Data Register 2</description>
          <addressOffset>0x38</addressOffset>
       </register>
       <register derivedFrom="PWM0_DATA2">
          <name>PWM1_DATA2</name>
          <displayName>PWM1_DATA2</displayName>
          <description>PWM Data Register 2</description>
          <alternateRegister>PWM0_DATA2</alternateRegister>
          <addressOffset>0x38</addressOffset>
       </register>
       <register derivedFrom="PWM0_DUTY0">
          <name>PWM0_DUTY3</name>
          <displayName>PWM0_DUTY3</displayName>
          <description>PWM Counter/Comparator Register 3</description>
          <addressOffset>0x40</addressOffset>
       </register>
       <register derivedFrom="PWM0_DUTY3">
          <name>PWM1_DUTY3</name>
          <displayName>PWM1_DUTY3</displayName>
          <description>PWM Counter/Comparator Register 3</description>
          <alternateRegister>PWM0_DUTY3</alternateRegister>
          <addressOffset>0x40</addressOffset>
       </register>
       <register derivedFrom="PWM0_DATA0">
          <name>PWM0_DATA3</name>
          <displayName>PWM0_DATA3</displayName>
          <description>PWM Data Register 3</description>
          <addressOffset>0x44</addressOffset>
       </register>
       <register derivedFrom="PWM0_DATA3">
          <name>PWM1_DATA3</name>
          <displayName>PWM1_DATA3</displayName>
          <description>PWM Data Register 3</description>
          <alternateRegister>PWM0_DATA3</alternateRegister>
          <addressOffset>0x44</addressOffset>
       </register>
       <register>
          <name>PWM0_CAPCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM0_CAPCTL</displayName>
          <description>Capture Control Register</description>
          <addressOffset>0x54</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INV0</name>
              <description>Channel 0 Inverter ON/OFF\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inverter OFF</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverter ON. Reverse the input signal from GPIO before fed to Capture timer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPCH0EN</name>
              <description>Capture Channel 0 Transition Enable/Disable\nWhen Enabled, Capture latched the PWM-timer value and saved to PWMx_CRL0 (Rising latch) and PWMx_CFL0 (Falling latch).\nWhen Disabled, Capture does not update PWMx_CRL0 and PWMx_CFL0, and disable Channel 0 Interrupt.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Capture function on channel 0 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture function on channel 0 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPCH0PADEN</name>
              <description>Capture Input Enable Register\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable the channel 0 input capture signal from corresponding multi-function pin</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable the channel 0 input capture signal from corresponding multi-function pin</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH0PDMAEN</name>
              <description>Channel 0 PDMA Enable\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Channel 0 PDMA function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Channel 0 PDMA function Enabled for the channel 0 captured data and transfer to memory</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PDMACAPMOD0</name>
              <description>Select CRL0 Or CFL0 For PDMA Transfer\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>reserved</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CRL0 will be transmitted</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>CFL0 will be transmitted</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Both CRL0 and CFL0 will be transmitted</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPRELOADREN0</name>
              <description>Reload CNR0 When CH0 Capture Rising Event Comes \n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Rising capture reload for CH0 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Rising capture reload for CH0 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPRELOADFEN0</name>
              <description>Reload CNR0 When CH0 Capture Falling Event Comes\n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Falling capture reload for CH0 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Falling capture reload for CH0 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INV1</name>
              <description>Channel 1 Inverter ON/OFF\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inverter OFF</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverter ON. Reverse the input signal from GPIO before fed to Capture timer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPCH1EN</name>
              <description>Capture Channel 1 Transition Enable/Disable\nWhen Enabled, Capture latched the PMW-counter and saved to PWMx_CRL1 (Rising latch) and PWMx_CFL1 (Falling latch).\nWhen Disabled, Capture does not update PWMx_CRL1 and PWMx_CFL1, and disable Channel 1 Interrupt.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Capture function on channel 1 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture function on channel 1 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPCH1PADEN</name>
              <description>Capture Input Enable Register\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable the channel 1 input capture signal from corresponding multi-function pin</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable the channel 1 input capture signal from corresponding multi-function pin</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH0RFORDER</name>
              <description></description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWMx_CFL0 is the first captured data to memory</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWMx_CRL0 is the first captured data to memory</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH01CASK</name>
              <description>Cascade channel 0 and channel 1 PWM timer for capturing usage</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPRELOADREN1</name>
              <description>Reload CNR1 When CH1 Capture Rising Event Comes\n</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Rising capture reload for CH1 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Rising capture reload for CH1 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPRELOADFEN1</name>
              <description>Reload CNR1 When CH1 Capture Falling Event Coming \n</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Capture falling reload for CH1 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture falling reload for CH1 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INV2</name>
              <description>Channel 2 Inverter ON/OFF\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inverter OFF</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverter ON. Reverse the input signal from GPIO before fed to Capture timer </description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPCH2EN</name>
              <description>Capture Channel 2 Transition Enable/Disable\nWhen Enabled, Capture latched the PWM-timer value and saved to PWMx_CRL2 (Rising latch) and PWMx_CFL2 (Falling latch).\nWhen Disabled, Capture does not update PWMx_CRL2 and PWMx_CFL2, and disable Channel 2 Interrupt.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Capture function on channel 2 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture function on channel 2 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPCH2PADEN</name>
              <description>Capture Input Enable Register\n</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable the channel 2 input capture signal from corresponding multi-function pin</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable the channel 2 input capture signal from corresponding multi-function pin</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH2PDMAEN</name>
              <description>Channel 2 PDMA Enable\n</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Channel 2 PDMA function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Channel 2 PDMA function Enabled for the channel 2 captured data and transfer to memory</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PDMACAPMOD2</name>
              <description>Select CRL2 Or CFL2 For PDMA Transfer\n</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>reserved</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CRL2 will be transmitted</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>CFL2 will be transmitted</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Both CRL2 and CFL2 will be transmitted</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPRELOADREN2</name>
              <description>Reload CNR2 When CH2 Capture Rising Event Coming \n</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Rising capture reload for CH2 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Rising capture reload for CH2 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPRELOADFEN2</name>
              <description>Reload CNR2 When CH2 Capture Failing Event Coming \n</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Failing capture reload for CH2 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Failing capture reload for CH2 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INV3</name>
              <description>Channel 3 Inverter ON/OFF\n</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inverter OFF</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverter ON. Reverse the input signal from GPIO before fed to Capture timer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPCH3EN</name>
              <description>Capture Channel 3 Transition Enable/Disable\nWhen Enabled, Capture latched the PMW-timer and saved to PWMx_CRL3 (Rising latch) and PWMx_CFL3 (Falling latch).\nWhen Disabled, Capture does not update PWMx_CRL3 and PWMx_CFL3, and disable Channel 3 Interrupt.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Capture function on channel 3 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture function on channel 3 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPCH3PADEN</name>
              <description>Capture Input Enable Register\n</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable the channel 3 input capture signal from corresponding multi-function pin</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable the channel 3 input capture signal from corresponding multi-function pin</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH2RFORDER</name>
              <description></description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWMx_CFL2 is the first captured data to memory</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWMx_CRL2 is the first captured data to memory</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH23CASK</name>
              <description>Cascade channel 2 and channel 3 PWM counter for capturing usage</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPRELOADREN3</name>
              <description>Reload CNR3 When CH3 Rising Capture Event Comes\n</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Rising capture reload for CH3 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Rising capture reload for CH3 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPRELOADFEN3</name>
              <description>Reload CNR3 When CH3 Falling Capture Event Comes \n</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Falling  capture reload for CH3 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Falling  capture reload for CH3 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PWM0_CAPCTL">
          <name>PWM1_CAPCTL</name>
          <displayName>PWM1_CAPCTL</displayName>
          <description>Capture Control Register</description>
          <alternateRegister>PWM0_CAPCTL</alternateRegister>
          <addressOffset>0x54</addressOffset>
       </register>
       <register>
          <name>PWM0_CAPINTEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM0_CAPINTEN</displayName>
          <description>Capture Interrupt Enable Register</description>
          <addressOffset>0x58</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CRL_IE0</name>
              <description>When Enabled, if Capture detects Channel 0 has rising transition, Capture issues an Interrupt.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Rising latch interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CFL_IE0</name>
              <description>Channel 0 Falling Latch Interrupt Enable ON/OFF\nWhen Enabled, if Capture detects Channel 0 has falling transition, Capture issues an Interrupt.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Falling latch interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Falling latch interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CRL_IE1</name>
              <description>Channel 1 Rising Latch Interrupt Enable \nWhen Enabled, if Capture detects Channel 1 has rising transition, Capture issues an Interrupt.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Rising latch interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Rising latch interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CFL_IE1</name>
              <description>Channel 1 Falling Latch Interrupt Enable \nWhen Enabled, if Capture detects Channel 1 has falling transition, Capture issues an Interrupt.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Falling latch interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Falling latch interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CRL_IE2</name>
              <description>Channel 2 Rising Latch Interrupt Enable ON/OFF\nWhen Enabled, if Capture detects Channel 2 has rising transition, Capture issues an Interrupt.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Rising latch interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Rising latch interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CFL_IE2</name>
              <description>Channel 2 Falling Latch Interrupt Enable ON/OFF\nWhen Enabled, if Capture detects Channel 2 has falling transition, Capture issues an Interrupt.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Falling latch interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Falling latch interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CRL_IE3</name>
              <description>Channel 3 Rising Latch Interrupt Enable ON/OFF\nWhen Enabled, if Capture detects Channel 3 has rising transition, Capture issues an Interrupt.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Rising latch interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Rising latch interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CFL_IE3</name>
              <description>Channel 3 Falling Latch Interrupt Enable ON/OFF\nWhen Enabled, if Capture detects Channel 3 has falling transition, Capture issues an Interrupt.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Falling latch interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Falling latch interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PWM0_CAPINTEN">
          <name>PWM1_CAPINTEN</name>
          <displayName>PWM1_CAPINTEN</displayName>
          <description>Capture Interrupt Enable Register</description>
          <alternateRegister>PWM0_CAPINTEN</alternateRegister>
          <addressOffset>0x58</addressOffset>
       </register>
       <register>
          <name>PWM0_CAPINTSTS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM0_CAPINTSTS</displayName>
          <description>Capture Interrupt Indication Register</description>
          <addressOffset>0x5C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CAPIF0</name>
              <description>Capture0 Interrupt Indication Flag\nIf channel 0 rising latch interrupt (CRL_IE0, PWMx_CAPINTEN[0]) is enabled, a rising transition occurs at input channel 0 will result in CAPIF0 to high; Similarly, a falling transition will cause CAPIF0 to be set high if channel 0 falling latch interrupt (CFL_IE0, PWMx_CAPINTEN[1]) is enabled. This flag is cleared by software with a write 1 on it.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CRLI0</name>
              <description>PWM_CRL0 Latched Indicator Bit\nWhen input channel 0 has a rising transition, PWMx_CRL0 was latched with the value of PWM down-counter and this bit is set by hardware, software can clear this bit by writing 1 to it.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CFLI0</name>
              <description>PWM_CFL0 Latched Indicator Bit\nWhen input channel 0 has a falling transition, PWMx_CFL0 was latched with the value of PWM down-counter and this bit is set by hardware, software can clear this bit by writing 1 to it.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPOVR0</name>
              <description>Capture Rising Flag Over Run For Channel 0\nThis flag indicate CRL0 update faster than software reading it when it is set \nThis bit will be cleared automatically when user clears CRLI0 (PWMx_CAPINTSTS[1]).</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPOVF0</name>
              <description>Capture Falling Flag Over Run For Channel 0\nThis flag indicate CFL0 update faster than software reading it when it is set\nThis bit will be cleared automatically when user clear CFLI0 (PWMx_CAPINTSTS[2])</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPIF1</name>
              <description>Capture1 Interrupt Indication Flag\nIf channel 1 rising latch interrupt (CRL_IE1, PWMx_CAPINTEN[8]) is enabled, a rising transition occurs at input channel 1 will result in CAPIF1 to high; Similarly, a falling transition will cause CAPIF1 to be set high if channel 1 falling latch interrupt (CFL_IE1, PWMx_CAPINTEN[9]) is enabled. This flag is cleared by software with a write 1 on it.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CRLI1</name>
              <description>PWM_CRL1 Latched Indicator Bit\nWhen input channel 1 has a rising transition, PWMx_CRL1 was latched with the value of PWM down-counter and this bit is set by hardware, software can clear this bit by writing 1 to it.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CFLI1</name>
              <description>PWM_CFL1 Latched Indicator Bit\nWhen input channel 1 has a falling transition, PWMx_CFL1 was latched with the value of PWM down-counter and this bit is set by hardware, software can clear this bit by writing a 1 to it.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPOVR1</name>
              <description>Capture Rising Flag Over Run For Channel 1\nThis flag indicate CRL1 update faster than software reading it when it is set \nThis bit will be cleared automatically when user clear CRLI1 (PWMx_CAPINTSTS[9])</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPOVF1</name>
              <description>Capture Falling Flag Over Run For Channel 1\nThis flag indicate CFL1 update faster than software reading it when it is set\nThis bit will be cleared automatically when user clear CFLI1 (PWMx_CAPINTSTS[10])</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPIF2</name>
              <description>Capture2 Interrupt Indication Flag\nIf channel 2 rising latch interrupt (CRL_IE2, PWMx_CAPINTEN[16]) is enabled, a rising transition occurs at input channel 2 will result in CAPIF2 to high; Similarly, a falling transition will cause CAPIF2 to be set high if channel 2 falling latch interrupt (CFL_IE2, PWMx_CAPINTEN[17]) is enabled. This flag is cleared by software with a write 1 on it.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CRLI2</name>
              <description>PWM_CRL2 Latched Indicator Bit\nWhen input channel 2 has a rising transition, PWMx_CRL2 was latched with the value of PWM down-counter and this bit is set by hardware, software can clear this bit by writing 1 to it.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CFLI2</name>
              <description>PWM_CFL2 Latched Indicator Bit\nWhen input channel 2 has a falling transition, PWMx_CFL2 was latched with the value of PWM down-counter and this bit is set by hardware, software can clear this bit by writing 1 to it.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPOVR2</name>
              <description>Capture Rising Flag Over Run For Channel 2\nThis flag indicate CRL2 update faster than software reading it when it is set\nThis bit will be cleared automatically when user clear CRLI2 (PWMx_CAPINTSTS[17])</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPOVF2</name>
              <description>Capture Falling Flag Over Run For Channel 2 \nThis flag indicate CFL2 update faster than software reading it when it is set\nThis bit will be cleared automatically when user clear CFLI2 (PWMx_CAPINTSTS[18])</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPIF3</name>
              <description>Capture3 Interrupt Indication Flag\nIf channel 3 rising latch interrupt (CRL_IE3, PWMx_CAPINTEN[24]) is enabled, a rising transition occurs at input channel 3 will result in CAPIF3 to high; Similarly, a falling transition will cause CAPIF3 to be set high if channel 3 falling latch interrupt (CFL_IE3, PWMx_CAPINTEN[25]) is enabled. This flag is cleared by software with a write 1 on it.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CRLI3</name>
              <description>PWM_CRL3 Latched Indicator Bit\nWhen input channel 3 has a rising transition, PWMx_CRL3 was latched with the value of PWM down-counter and this bit is set by hardware, software can clear this bit by writing 1 to it.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CFLI3</name>
              <description>PWM_CFL3 Latched Indicator Bit\nWhen input channel 3 has a falling transition, PWMx_CFL3 was latched with the value of PWM down-counter and this bit is set by hardware, software can clear this bit by writing 1 to it.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPOVR3</name>
              <description>Capture Rising Flag Over Run For Channel 3\nThis flag indicate CRL3 update faster than software reading it when it is set\nThis bit will be cleared automatically when user clear CRLI3 (PWMx_CAPINTSTS[25])</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPOVF3</name>
              <description>Capture Falling Flag Over Run For Channel 3 \nThis flag indicate CFL3 update faster than software reading it when it is set\nThis bit will be cleared automatically when user clear CFLI3 (PWMx_CAPINTSTS[26])</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PWM0_CAPINTSTS">
          <name>PWM1_CAPINTSTS</name>
          <displayName>PWM1_CAPINTSTS</displayName>
          <description>Capture Interrupt Indication Register</description>
          <alternateRegister>PWM0_CAPINTSTS</alternateRegister>
          <addressOffset>0x5C</addressOffset>
       </register>
       <register>
          <name>PWM0_CRL0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM0_CRL0</displayName>
          <description>Capture Rising Latch Register (Channel 0)</description>
          <addressOffset>0x60</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CRL</name>
              <description>Capture Rising Latch Register\nLatch the PWM counter when Channel 0/1/2/3 has rising transition.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CRL_H</name>
              <description>Upper Half Word Of 32-Bit Capture Data When Cascade Is Enable \nWhen cascade is enabled for capture channel 0, 2,the original 16 bit counter extend to 32 bit, and capture result CRL0 and CRL2 are also extend to 32 bit,</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PWM0_CRL0">
          <name>PWM1_CRL0</name>
          <displayName>PWM1_CRL0</displayName>
          <description>Capture Rising Latch Register (Channel 0)</description>
          <alternateRegister>PWM0_CRL0</alternateRegister>
          <addressOffset>0x60</addressOffset>
       </register>
       <register>
          <name>PWM0_CFL0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM0_CFL0</displayName>
          <description>Capture Falling Latch Register (Channel 0)</description>
          <addressOffset>0x64</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CFL</name>
              <description>Capture Falling Latch Register\nLatch the PWM counter when Channel 01/2/3 has Falling transition.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CFL_H</name>
              <description>Upper Half Word Of 32 Bit Capture Data When Cascade Is Enable \nWhen cascade is enabled for capture channel 0, 2,the original 16 bit counter extend to 32 bit, and capture result CFL0 and CFL2 are also extend to 32 bit,</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PWM0_CFL0">
          <name>PWM1_CFL0</name>
          <displayName>PWM1_CFL0</displayName>
          <description>Capture Falling Latch Register (Channel 0)</description>
          <alternateRegister>PWM0_CFL0</alternateRegister>
          <addressOffset>0x64</addressOffset>
       </register>
       <register derivedFrom="PWM0_CRL0">
          <name>PWM0_CRL1</name>
          <displayName>PWM0_CRL1</displayName>
          <description>Capture Rising Latch Register (Channel 1)</description>
          <addressOffset>0x68</addressOffset>
       </register>
       <register derivedFrom="PWM0_CRL1">
          <name>PWM1_CRL1</name>
          <displayName>PWM1_CRL1</displayName>
          <description>Capture Rising Latch Register (Channel 1)</description>
          <alternateRegister>PWM0_CRL1</alternateRegister>
          <addressOffset>0x68</addressOffset>
       </register>
       <register derivedFrom="PWM0_CFL0">
          <name>PWM0_CFL1</name>
          <displayName>PWM0_CFL1</displayName>
          <description>Capture Falling Latch Register (Channel 1)</description>
          <addressOffset>0x6C</addressOffset>
       </register>
       <register derivedFrom="PWM0_CFL1">
          <name>PWM1_CFL1</name>
          <displayName>PWM1_CFL1</displayName>
          <description>Capture Falling Latch Register (Channel 1)</description>
          <alternateRegister>PWM0_CFL1</alternateRegister>
          <addressOffset>0x6C</addressOffset>
       </register>
       <register derivedFrom="PWM0_CRL0">
          <name>PWM0_CRL2</name>
          <displayName>PWM0_CRL2</displayName>
          <description>Capture Rising Latch Register (Channel 2)</description>
          <addressOffset>0x70</addressOffset>
       </register>
       <register derivedFrom="PWM0_CRL2">
          <name>PWM1_CRL2</name>
          <displayName>PWM1_CRL2</displayName>
          <description>Capture Rising Latch Register (Channel 2)</description>
          <alternateRegister>PWM0_CRL2</alternateRegister>
          <addressOffset>0x70</addressOffset>
       </register>
       <register derivedFrom="PWM0_CFL0">
          <name>PWM0_CFL2</name>
          <displayName>PWM0_CFL2</displayName>
          <description>Capture Falling Latch Register (Channel 2)</description>
          <addressOffset>0x74</addressOffset>
       </register>
       <register derivedFrom="PWM0_CFL2">
          <name>PWM1_CFL2</name>
          <displayName>PWM1_CFL2</displayName>
          <description>Capture Falling Latch Register (Channel 2)</description>
          <alternateRegister>PWM0_CFL2</alternateRegister>
          <addressOffset>0x74</addressOffset>
       </register>
       <register derivedFrom="PWM0_CRL0">
          <name>PWM0_CRL3</name>
          <displayName>PWM0_CRL3</displayName>
          <description>Capture Rising Latch Register (Channel 3)</description>
          <addressOffset>0x78</addressOffset>
       </register>
       <register derivedFrom="PWM0_CRL3">
          <name>PWM1_CRL3</name>
          <displayName>PWM1_CRL3</displayName>
          <description>Capture Rising Latch Register (Channel 3)</description>
          <alternateRegister>PWM0_CRL3</alternateRegister>
          <addressOffset>0x78</addressOffset>
       </register>
       <register derivedFrom="PWM0_CFL0">
          <name>PWM0_CFL3</name>
          <displayName>PWM0_CFL3</displayName>
          <description>Capture Falling Latch Register (Channel 3)</description>
          <addressOffset>0x7C</addressOffset>
       </register>
       <register derivedFrom="PWM0_CFL3">
          <name>PWM1_CFL3</name>
          <displayName>PWM1_CFL3</displayName>
          <description>Capture Falling Latch Register (Channel 3)</description>
          <alternateRegister>PWM0_CFL3</alternateRegister>
          <addressOffset>0x7C</addressOffset>
       </register>
       <register>
          <name>PWM0_PDMACH0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM0_PDMACH0</displayName>
          <description>PDMA Channel 0 Captured Data</description>
          <addressOffset>0x80</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMACH01</name>
              <description>Captured Data Of Channel 0\nWhen CH01CASK is disabled, it is the capturing value(CFL0/CRL0) for channel 0\nWhen CH01CASK is enabled, It is the for the first byte of 32 bit capturing data for channel 0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PDMACH02</name>
              <description>Captured Data Of Channel 0\nWhen CH01CASK is disabled, it is the capturing value(CFL0/CRL0) for channel 0\nWhen CH01CASK is enabled, It is the second byte of 32 bit capturing data for channel 0</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PDMACH03</name>
              <description>Captured Data Of Channel 0\nWhen CH01CASK is disabled, this byte is 0\nWhen CH01CASK is enabled, It is the third byte of 32 bit capturing data for channel 0</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PDMACH04</name>
              <description>Captured Data Of Channel 0\nWhen CH01CASK is disabled, this byte is 0\nWhen CH01CASK is enabled, It is the fourth byte of 32 bit capturing data for channel 0</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PWM0_PDMACH0">
          <name>PWM1_PDMACH0</name>
          <displayName>PWM1_PDMACH0</displayName>
          <description>PDMA Channel 0 Captured Data</description>
          <alternateRegister>PWM0_PDMACH0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register>
          <name>PWM0_PDMACH2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM0_PDMACH2</displayName>
          <description>PDMA Channel 2 Captured Data</description>
          <addressOffset>0x84</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMACH21</name>
              <description>Captured Data Of Channel 2\nWhen CH23CASK is disabled, it is the capturing value(CFL0/CRL0) for channel 2\nWhen CH23CASK is enabled, It is the for the first byte of 32 bit capturing data for channel 2</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PDMACH22</name>
              <description>Captured Data Of Channel 2\nWhen CH23CASK is disabled, it is the capturing value(CFL0/CRL0) for channel 2\nWhen CH23CASK is enabled, It is the second byte of 32 bit capturing data for channel 2</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PDMACH23</name>
              <description>Captured Data Of Channel 2\nWhen CH23CASK is disabled, this byte is 0\nWhen CH23CASK is enabled, It is the third byte of 32 bit capturing data for channel 2</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PDMACH24</name>
              <description>Captured Data Of Channel 2\nWhen CH23CASK is disabled, this byte is 0\nWhen CH23CASK is enabled, It is the fourth byte of 32 bit capturing data for channel 2</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PWM0_PDMACH2">
          <name>PWM1_PDMACH2</name>
          <displayName>PWM1_PDMACH2</displayName>
          <description>PDMA Channel 2 Captured Data</description>
          <alternateRegister>PWM0_PDMACH2</alternateRegister>
          <addressOffset>0x84</addressOffset>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>WDT</name>
      <description>WDT Register Map</description>
      <groupName>WDT</groupName>
      <baseAddress>0x40004000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0xC</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>WDT_CTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>WDT_CTL</displayName>
          <description>Watchdog Timer Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000070</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WTR</name>
              <description>Clear Watchdog Timer (Write Protect)\nPlease refer to open lock sequence to program it.\nSet this bit will clear the Watchdog timer. \nNote: This bit will auto clear after few clock cycle</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the contents of the Watchdog timer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WTRE</name>
              <description>Watchdog Timer Reset Function Enable Control (Write Protect)\nPlease refer to open lock sequence to program it.\nSetting this bit will enable the Watchdog timer reset function.\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Watchdog timer reset function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Watchdog timer reset function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WTWKE</name>
              <description>Watchdog Timer Wake-Up Function Enable Control (Write Protect)\nPlease refer to open lock sequence to program it.\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Watchdog timer Wake-up CPU function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Wake-up function Enabled so that Watchdog timer time-out can wake up CPU from power-down mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WTE</name>
              <description>Watchdog Timer Enable Control (Write Protect)\nPlease refer to open lock sequence to program it.\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Watchdog timer Disabled (this action will reset the internal counter)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Watchdog timer Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WTIS</name>
              <description>Watchdog Timer Interval Selection (Write Protect)\nPlease refer to open lock sequence to program it.\nThe three bits select the time-out interval for the Watchdog timer. This count is free running counter.\nPlease refer to Table 5.191 Watchdog Time-out Interval Selection</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>WDT_IER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>WDT_IER</displayName>
          <description>Watchdog Timer Interrupt Enable Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WDT_IE</name>
              <description>Watchdog Timer Interrupt Enable Control\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Watchdog timer interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Watchdog timer interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>WDT_ISR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>WDT_ISR</displayName>
          <description>Watchdog Timer Interrupt Status Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WDT_IS</name>
              <description>Watchdog Timer Interrupt Status (Read Only)\nIf the Watchdog timer interrupt is enabled, then the hardware will set this bit to indicate that the Watchdog timer interrupt has occurred. If the Watchdog timer interrupt is not enabled, then this bit indicates that a time-out period has elapsed.\nNote: This bit is read only, but can be cleared by writing "1" to it.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Watchdog timer interrupt does not occur</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Watchdog timer interrupt occurs</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>WDT_RST_IS</name>
              <description>Watchdog Timer Reset Status (Read Only)\nWhen the Watchdog timer initiates a reset, the hardware will set this bit. This flag can be read by software to determine the source of reset. Software is responsible to clear it manually by writing "1" to it. If WTRE is disabled, then the Watchdog timer has no effect on this bit.\nNote: This bit is read only, but can be cleared by writing "1" to it.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Watchdog timer reset does not occur</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Watchdog timer reset occurs</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>WDT_WAKE_IS</name>
              <description>Watchdog Timer Wake-Up Status (Read Only)\nIf Watchdog timer causes system to wake up from power-down mode, this bit will be set to high. It must be cleared by software with a write "1" to this bit.\nNote1: When system in power-down mode and watchdog time-out, hardware will set WDT_WAKE_IS and WDT_IS.\nNote2: After one engine clock., this bit can be cleared by writing "1" to it</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Watchdog timer does not cause system wake-up</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Wake system up from power-down mode by Watchdog time-out</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>RTC</name>
      <description>RTC Register Map</description>
      <groupName>RTC</groupName>
      <baseAddress>0x40008000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x34</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x3C</offset>
        <size>0x54</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>RTC_INIR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>RTC_INIR</displayName>
          <description>RTC Initiation Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INIR</name>
              <description>RTC Initiation  (Write Only)\nWhen RTC block is powered on, RTC is at reset state. User has to write a number (0x a5eb1357) to INIR to make RTC leaving reset state. Once the INIR is written as 0xa5eb1357, the RTC will be in un-reset state permanently.\nThe INIR is a write-only field and read value will be always "0".\nRTC Active Status (Read Only), \n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTC is at reset state</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTC is at normal active state</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>write-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>RTC_AER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>RTC_AER</displayName>
          <description>RTC Access Enable Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AER</name>
              <description>RTC Register Access Enable Password (Write Only)\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>43365</name>
                    <description>Enable RTC acces.s</description>
                    <value>0xa965</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>write-only</access>
            </field>
            <field>
              <name>ENF</name>
              <description>RTC Register Access Enable Flag (Read Only)\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTC register read/write disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTC register read/write enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>RTC_FCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>RTC_FCR</displayName>
          <description>RTC Frequency Compensation Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000700</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FRACTION</name>
              <description>Fraction Part\nNote: Digit in FCR must be expressed as hexadecimal number.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INTEGER</name>
              <description>Integer Part\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>RTC_TLR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>RTC_TLR</displayName>
          <description>Time Loading Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>_1SEC</name>
              <description>1 Sec Time Digit (0~9)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_10SEC</name>
              <description>10 Sec Time Digit (0~5)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_1MIN</name>
              <description>1 Min Time Digit (0~9)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_10MIN</name>
              <description>10 Min Time Digit (0~5)</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_1HR</name>
              <description>1 Hour Time Digit (0~9)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_10HR</name>
              <description>10 Hour Time Digit (0~2)</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>RTC_CLR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>RTC_CLR</displayName>
          <description>Calendar Loading Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00050101</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>_1DAY</name>
              <description>1 Day Calendar Digit (0~9)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_10DAY</name>
              <description>10 Day Calendar Digit (0~3)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_1MON</name>
              <description>1 Month Calendar Digit (0~9)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_10MON</name>
              <description>10 Month Calendar Digit (0~1)</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_1YEAR</name>
              <description>1 Year Calendar Digit (0~9)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_10YEAR</name>
              <description>10 Year Calendar Digit (0~9)</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>RTC_TSSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>RTC_TSSR</displayName>
          <description>Time Scale Selection Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>_24hr_12hr</name>
              <description>24-Hour / 12-Hour Mode Selection\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>select 12-hour time scale with AM and PM indication</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>select 24-hour time scale</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>RTC_DWR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>RTC_DWR</displayName>
          <description>Day of the Week Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000006</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DWR</name>
              <description>Day Of The Week Register \n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>RTC_TAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>RTC_TAR</displayName>
          <description>Time Alarm Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>_1SEC</name>
              <description>1 Sec Time Digit of Alarm Setting (0~9)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_10SEC</name>
              <description>10 Sec Time Digit of Alarm Setting (0~5)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_1MIN</name>
              <description>1 Min Time Digit of Alarm Setting (0~9)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_10MIN</name>
              <description>10 Min Time Digit of Alarm Setting (0~5)</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_1HR</name>
              <description>1 Hour Time Digit of Alarm Setting (0~9)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_10HR</name>
              <description>10 Hour Time Digit of Alarm Setting (0~2)</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>RTC_CAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>RTC_CAR</displayName>
          <description>Calendar Alarm Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>_1DAY</name>
              <description>1 Day Calendar Digit of Alarm Setting (0~9)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_10DAY</name>
              <description>10 Day Calendar Digit of Alarm Setting (0~3)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_1MON</name>
              <description>1 Month Calendar Digit of Alarm Setting (0~9)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_10MON</name>
              <description>10 Month Calendar Digit of Alarm Setting (0~1)</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_1YEAR</name>
              <description>1 Year Calendar Digit of Alarm Setting (0~9)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_10YEAR</name>
              <description>10 Year Calendar Digit of Alarm Setting (0~9)</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>RTC_LIR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>RTC_LIR</displayName>
          <description>RTC Leap Year Indication Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LIR</name>
              <description>Leap Year Indication REGISTER (Read Only)\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>This year is not a leap year</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>This year is leap year</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>RTC_RIER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>RTC_RIER</displayName>
          <description>RTC Interrupt Enable Register</description>
          <addressOffset>0x28</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AIER</name>
              <description>Alarm Interrupt Enable\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTC Alarm Interrupt is disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTC Alarm Interrupt is enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TIER</name>
              <description>Time Tick Interrupt And Wake-Up By Tick Enable\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTC Time Tick Interrupt is disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTC Time Tick Interrupt is enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SNOOPIER</name>
              <description>Snooper Pin Event Detection Interrupt Enable\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Snooper Pin Event Detection Interrupt is disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Snooper Pin Event Detection Interrupt is enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>RTC_RIIR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>RTC_RIIR</displayName>
          <description>RTC Interrupt Indicator Register</description>
          <addressOffset>0x2C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AIS</name>
              <description>RTC Alarm Interrupt Status\nRTC unit will set AIF to high once the RTC real time counters TLR and CLR reach the alarm setting time registers TAR and CAR. When this bit is set and AIER is also high, RTC will generate an interrupt to CPU.\nThis bit is software clear by writing "1" to it.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Indicates RCT Alarm Interrupt condition never occurred</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Indicates RTC Alarm Interrupt is requested if RIER.AIER=1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TIS</name>
              <description>RTC Time Tick Interrupt Status\nRTC unit will set TIF to high periodically in the period selected by TTR(RTC_TTR[2:0]). When this bit is set and TIER is also high, RTC will generate an interrupt to CPU.\nThis bit is software clear by writing "1" to it.\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Indicates RCT Time Tick Interrupt condition never occurred</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Indicates RTC Time Tick Interrupt is requested</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SNOOPIS</name>
              <description>Snooper Pin Event Detection Interrupt Status\nWhen SNOOPEN is high and an event defined by SNOOPEDGE detected in snooper pin, this flag will be set. While this bit is set and SNOOPIER is also high, RTC will generate an interrupt to CPU.\nWrite "1" to clear this bit to "0".\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Snooper pin event defined by SNOOPEDGE never detected</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Snooper pin event defined by SNOOPEDGE detected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>RTC_TTR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>RTC_TTR</displayName>
          <description>RTC Time Tick Register</description>
          <addressOffset>0x30</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TTR</name>
              <description>Time Tick Register\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TWKE</name>
              <description>RTC Timer Wake-Up CPU Function Enable Bit\nIf TWKE is set before CPU enters power-down mode, when a RTC Time Tick, CPU will be wakened up by RTC unit.\nNote: Tick timer setting follows the TTR description.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Time Tick wake-up CPU function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Wake-up function Enabled so that CPU can be waken up from Power-down mode by Time Tick</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>RTC_SPRCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>RTC_SPRCTL</displayName>
          <description>RTC Spare Functional Control Register</description>
          <addressOffset>0x3C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000080</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SNOOPEN</name>
              <description>Snooper Pin Event Detection Enable\nThis bit enables the snooper pin event detection.\nWhen this bit is set high and an event defined by SNOOPEDGE detected, the 20 spare registers will be cleared to "0" by hardware automatically. And, the SNOOPIF will also be set. In addition, RTC will also generate wake-up event to wake system up.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Snooper pin event detection function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Snooper pin event detection function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SNOOPEDGE</name>
              <description>Snooper Active Edge Selection\nThis bit defines which edge of snooper pin will generate a snooper pin detected event to clear the 20 spare registers.\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Rising edge of snooper pin generates snooper pin detected event</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Falling edge of snooper pin generates snooper pin detected event</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPRRDY</name>
              <description>SPR Register Ready\nThis bit indicates if the registers SPR0 ~ SPR19 are ready to read.\nAfter CPU writing registers SPR0 ~ SPR19, polling this bit to check if SP0 ~ SPR19 are updated done is necessary.\nThis it is a read only bit and any write to this bit won't take any effect.\n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPR0 ~ SPR19 updating is in progress</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPR0 ~ SPR19 are updated done and ready to read</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>RTC_SPR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>RTC_SPR0</displayName>
          <description>RTC Spare Register 0</description>
          <addressOffset>0x40</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SPARE</name>
              <description>SPARE\nThis field is used to store back-up information defined by software.\nThis field will be cleared by hardware automatically once a snooper pin event is detected.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="RTC_SPR0">
          <name>RTC_SPR1</name>
          <displayName>RTC_SPR1</displayName>
          <description>RTC Spare Register 1</description>
          <addressOffset>0x44</addressOffset>
       </register>
       <register derivedFrom="RTC_SPR0">
          <name>RTC_SPR2</name>
          <displayName>RTC_SPR2</displayName>
          <description>RTC Spare Register 2</description>
          <addressOffset>0x48</addressOffset>
       </register>
       <register derivedFrom="RTC_SPR0">
          <name>RTC_SPR3</name>
          <displayName>RTC_SPR3</displayName>
          <description>RTC Spare Register 3</description>
          <addressOffset>0x4C</addressOffset>
       </register>
       <register derivedFrom="RTC_SPR0">
          <name>RTC_SPR4</name>
          <displayName>RTC_SPR4</displayName>
          <description>RTC Spare Register 4</description>
          <addressOffset>0x50</addressOffset>
       </register>
       <register derivedFrom="RTC_SPR0">
          <name>RTC_SPR5</name>
          <displayName>RTC_SPR5</displayName>
          <description>RTC Spare Register 5</description>
          <addressOffset>0x54</addressOffset>
       </register>
       <register derivedFrom="RTC_SPR0">
          <name>RTC_SPR6</name>
          <displayName>RTC_SPR6</displayName>
          <description>RTC Spare Register 6</description>
          <addressOffset>0x58</addressOffset>
       </register>
       <register derivedFrom="RTC_SPR0">
          <name>RTC_SPR7</name>
          <displayName>RTC_SPR7</displayName>
          <description>RTC Spare Register 7</description>
          <addressOffset>0x5C</addressOffset>
       </register>
       <register derivedFrom="RTC_SPR0">
          <name>RTC_SPR8</name>
          <displayName>RTC_SPR8</displayName>
          <description>RTC Spare Register 8</description>
          <addressOffset>0x60</addressOffset>
       </register>
       <register derivedFrom="RTC_SPR0">
          <name>RTC_SPR9</name>
          <displayName>RTC_SPR9</displayName>
          <description>RTC Spare Register 9</description>
          <addressOffset>0x64</addressOffset>
       </register>
       <register derivedFrom="RTC_SPR0">
          <name>RTC_SPR10</name>
          <displayName>RTC_SPR10</displayName>
          <description>RTC Spare Register 10</description>
          <addressOffset>0x68</addressOffset>
       </register>
       <register derivedFrom="RTC_SPR0">
          <name>RTC_SPR11</name>
          <displayName>RTC_SPR11</displayName>
          <description>RTC Spare Register 11</description>
          <addressOffset>0x6C</addressOffset>
       </register>
       <register derivedFrom="RTC_SPR0">
          <name>RTC_SPR12</name>
          <displayName>RTC_SPR12</displayName>
          <description>RTC Spare Register 12</description>
          <addressOffset>0x70</addressOffset>
       </register>
       <register derivedFrom="RTC_SPR0">
          <name>RTC_SPR13</name>
          <displayName>RTC_SPR13</displayName>
          <description>RTC Spare Register 13</description>
          <addressOffset>0x74</addressOffset>
       </register>
       <register derivedFrom="RTC_SPR0">
          <name>RTC_SPR14</name>
          <displayName>RTC_SPR14</displayName>
          <description>RTC Spare Register 14</description>
          <addressOffset>0x78</addressOffset>
       </register>
       <register derivedFrom="RTC_SPR0">
          <name>RTC_SPR15</name>
          <displayName>RTC_SPR15</displayName>
          <description>RTC Spare Register 15</description>
          <addressOffset>0x7C</addressOffset>
       </register>
       <register derivedFrom="RTC_SPR0">
          <name>RTC_SPR16</name>
          <displayName>RTC_SPR16</displayName>
          <description>RTC Spare Register 16</description>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="RTC_SPR0">
          <name>RTC_SPR17</name>
          <displayName>RTC_SPR17</displayName>
          <description>RTC Spare Register 17</description>
          <addressOffset>0x84</addressOffset>
       </register>
       <register derivedFrom="RTC_SPR0">
          <name>RTC_SPR18</name>
          <displayName>RTC_SPR18</displayName>
          <description>RTC Spare Register 18</description>
          <addressOffset>0x88</addressOffset>
       </register>
       <register derivedFrom="RTC_SPR0">
          <name>RTC_SPR19</name>
          <displayName>RTC_SPR19</displayName>
          <description>RTC Spare Register 19</description>
          <addressOffset>0x8C</addressOffset>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>UART0</name>
      <description>UART Register Map</description>
      <groupName>UART</groupName>
      <baseAddress>0x40050000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x28</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x30</offset>
        <size>0xC</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>UART_RBR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UART_RBR</displayName>
          <description>UART Receive Buffer Register.</description>
          <addressOffset>0x0</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>RBR</name>
              <description>Receive Buffer Register\nBy reading this register, the UART will return an 8-bit data received from RX pin (LSB first).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UART_THR</name>
          <alternateRegister>UART_RBR</alternateRegister>
          <!-- the display name is an unrestricted string. -->
          <displayName>UART_THR</displayName>
          <description>UART Transmit Holding Register.</description>
          <addressOffset>0x0</addressOffset>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>THR</name>
              <description>Transmit Holding Register\nBy writing to this register, the UART will send out an 8-bit data through the TX pin (LSB first).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UART_CTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UART_CTL</displayName>
          <description>UART Control Register.</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX_RST</name>
              <description>RX Software Reset\nWhen RX_RST is set, all the bytes in the receiving FIFO and RX internal state machine are cleared.\nNote: This bit will auto clear and takes at least 3 UART peripheral clock cycles.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the RX internal state machine and pointers</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_RST</name>
              <description>TX Software Reset\nWhen TX_RST is set, all the bytes in the transmitting FIFO and TX internal state machine are cleared.\nNote: This bit will auto clear and takes at least 3 UART engine clock cycles.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the TX internal state machine and pointers</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_DIS</name>
              <description>Receiver Disable Register\nNote1: In RS-485 NMM mode, user can setting this bit to receive data or not that before detect address byte.\nNote2: In RS-485 NMM mode, this bit will be setting to "1" automatically.\nNote3: In RS-485 AAD mode and LIN "break + sync +PID" header mode, hardware will control data automatically, so don't fill any value to this bit.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receiver Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receiver Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_DIS</name>
              <description>Transfer Disable Register\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transfer Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTO_RTS_EN</name>
              <description>RTSn Auto-Flow Control Enable \nWhen RTSn auto-flow is enabled, if the number of bytes in the RX-FIFO equals the RTS_TRI_LEV (UART_TLCTL[13:12]), the UART will reassert RTSn signal.\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTSn auto-flow control. Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTSn auto-flow control Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTO_CTS_EN</name>
              <description>CTSn Auto-Flow Control Enable \n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CTSn auto-flow control Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_RX_EN</name>
              <description>RX DMA Enable \nNote: If RLS_IE (UART_IER[2]) is enabled and RLS_IS(UART_ISR[2]) is set to 1, the RLS (Receive Line Status) Interrupt is caused. If RLS interrupt is caused by Break Error Flag BI_F(UART_FSR[6]), Frame Error Flag FE_F(UART_FSR[5]) or Parity Error Flag PE_F(UART_FSR[4]) , UART PDMA receive request operation is stop. Clear Break Error Flag BI_F or Frame Error Flag FE_F or Parity Error Flag PE_F by writing "1" to corresponding BI_F, FE_F and PE_F to make UART PDMA receive request operation continue.  </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX PDMA service function Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX PDMA service function Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_TX_EN</name>
              <description>TX DMA Enable \nNote: If RLS_IE (UART_IER[2]) is enabled and RLS_IS(UART_ISR[2]) is set to 1, the RLS (Receive Line Status) Interrupt is caused. If RLS interrupt is caused by Break Error Flag BI_F(UART_FSR[6]), Frame Error Flag FE_F(UART_FSR[5]) or Parity Error Flag PE_F(UART_FSR[4]) , UART PDMA transmit request operation is stop. Clear Break Error Flag BI_F or Frame Error Flag FE_F or Parity Error Flag PE_F by writing "1" to corresponding BI_F, FE_F and PE_F to make UART PDMA transmit request operation continue.  </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX PDMA service function Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX PDMA service function Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKE_CTS_EN</name>
              <description>CTSn Wake-Up Function Enable \n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>CTSn wake-up system function Disabled 1 = Wake-up function Enabled when the system is in power-down mode, an external CTSn change will wake-up system from power-down mode</description>
                    <value>#0</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKE_DATA_EN</name>
              <description>Incoming Data Wake-Up Function Enable \nNote: Hardware will clear this bit when the incoming data wake-up operation finishes and "system clock" work stable.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Incoming data wake-up system Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Incoming data wake-up function Enabled when the system is in power-down mode, incoming data will wake-up system from power-down mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ABAUD_EN</name>
              <description>Auto-Baud Rate Detect Enable\nNote: When the auto-baud rate detect operation finishes, hardware will clear this bit and the associated interrupt (INT_ABAUD) will be generated (If ABAUD_IE (UART_IER [7]) be enabled).</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Auto-baud rate detect function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-baud rate detect function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UART_TLCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UART_TLCTL</displayName>
          <description>UART Transfer Line Control Register.</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA_LEN</name>
              <description>Data Length\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Word length is 5-bit</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Word length is 6-bit</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Word length is 7-bit</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Word length is 8-bit</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>NSB</name>
              <description>Number Of STOP Bit Length\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>1 " STOP bit" is generated in the transmitted data</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>1.5 "STOP bit" is generated in the transmitted data when 5-bit word length is selected, and 2 STOP bit" is generated when 6, 7 and 8 bit data length is selected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PBE</name>
              <description>Parity Bit Enable\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Parity bit is not generated (transmitting data) or checked (receiving data) during transfer.1 = Parity bit is generated or checked between the  last data word bit  and  stop bit  of the serial data</description>
                    <value>#0</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EPE</name>
              <description>Even Parity Enable\nNote: This bit has effect only when PBE bit (parity bit enable) is set.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Odd number of logic 1's are transmitted or check the data word and parity bits in receiving mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Even number of logic 1's are transmitted or check the data word and parity bits in receiving mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPE</name>
              <description>Stick Parity Enable  \nStick Parity Enable  Control\nNote1: When bits PBE, EPE and SPE are set, the parity bit is transmitted and checked as "0". When PBE and SPE are set and EPE is cleared, the parity bit is transmitted and checked as "1". \nNote2: In RS-485 mode, PBE, EPE and SPE can control bit 9, the bit 9 setting are shown as follows.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Stick parity Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Stick parity Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BCB</name>
              <description>Break Control Bit  \nWhen this bit is set to logic "1", the serial data output (TX) is forced to the Spacing State (logic "0"). This bit acts only on TX pin and has no effect on the transmitter logic.\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Break control Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Break control Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RFITL</name>
              <description>RX-FIFO Interrupt (INT_RDA) Trigger Level \nWhen the number of bytes in the receiving FIFO equals to the RFITL then the RDA_IF will be set (if RDA_IEN (IER [0]) is enabled, an interrupt will be generated)\nNote: When operating in IrDA mode or RS-485 mode, the RFITL must be set to "0".</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX FIFO Interrupt Trigger Level is 1 byte</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX FIFO Interrupt Trigger Level is 4 bytes</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>RX FIFO Interrupt Trigger Level is 8 bytes</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>RX FIFO Interrupt Trigger Level is 14 bytes</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RTS_TRI_LEV</name>
              <description>RTSn Trigger Level (For Auto-Flow Control Use)\nNote: This field is used for auto RTSn flow control.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTS Trigger Level is 1 byte</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTS Trigger Level is 4 bytes</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>RTS Trigger Level is 8 bytes</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>RTS Trigger Level is 14 bytes</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UART_IER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UART_IER</displayName>
          <description>UART Interrupt Enable Register.</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDA_IE</name>
              <description>Receive Data Available Interrupt Enable\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>INT_RDA Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>INT_RDA Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>THRE_IE</name>
              <description>Transmit Holding Register Empty Interrupt Enable\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>INT_THRE Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>INT_THRE Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RLS_IE</name>
              <description>Receive Line Status Interrupt Enable \n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>INT_RLS Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>INT_RLS Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODEM_IE</name>
              <description>Modem Status Interrupt Enable \n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>INT_MOS Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>INT_MOS Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RTO_IE</name>
              <description>RX Time-Out Interrupt Enable\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>INT_TOUT Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>INT_TOUT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BUF_ERR_IE</name>
              <description>Buffer Error Interrupt Enable\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>INT_BUT_ERR Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>INT_BUF_ERR Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKE_IE</name>
              <description>Wake-Up Interrupt Enable\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>INT_WAKE Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>INT_WAKE Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ABAUD_IE</name>
              <description>Auto-Baud Rate Interrupt Enable\n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>INT_ABAUD Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>INT_ABAUD Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_IE</name>
              <description>LIN Interrupt Enable\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>INT_LIN Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>INT_LIN Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UART_ISR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UART_ISR</displayName>
          <description>UART Interrupt Status Register.</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000002</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDA_IS</name>
              <description>Receive Data Available Interrupt Flag (Read Only)\nWhen the number of bytes in the RX-FIFO equals the RFITL then the RDA_IF will be set. If RDA_IEN (IER [0]) is set then the RDA interrupt will be generated. \nNote:  This bit is read only and it will be cleared when the number of unread bytes of RX-FIFO drops below the threshold level (RFITL).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Receive Data available interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receive Data available interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>THRE_IS</name>
              <description>Transmit Holding Register Empty Interrupt Flag (Read Only) \nThis bit is set when the last data of TX-FIFO is transferred to Transmitter Shift Register. If THRE_IEN (IER [1]) is set that the THRE interrupt will be generated.\nNote: This bit is read only and it will be cleared when writing data into THR (TX-FIFO not empty).</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Transmit Holding register empty interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmit Holding register empty interrupt generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RLS_IS</name>
              <description>Receive Line Interrupt Status Flag (Read Only)\nThis bit is set when the RX received data has parity error (PE_F (UART_FSR[4])), framing error (FE_F (UART_FSR[5])), break error (BI_F (UART_FSR[6])) or RS-485 detect address byte (RS-485_ADDET_F (UART_TRSR[0])).If RLS_IE (UART_IER[2]) is set then the RLS interrupt will be generated.\nNote1: This bit is read only, but can be cleared by it by writing "1" to BI_F (UART_FSR[6]), FE_F (UART_FSR[5]), PE_F (UART_FSR[4]) or RS-485_ADDET_F (UART_TRSR[0]).\nNote2: This bit is cleared when both that the BI_F, FE_F, PE_F and RS-485_ADDET_F are cleared.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Receive Line interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receive Line interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>MODEM_IS</name>
              <description>MODEM Interrupt Status Flag (Read Only) \nNote: This bit is read only, but can be cleared by it by writing "1" to DCT_F (UART_MCSR [18]).</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No MODEM interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>MODEM interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RTO_IS</name>
              <description>RX Time-Out Interrupt Status Flag (Read Only)\nThis bit is set when the RX-FIFO is not empty and no activities occur in the RX-FIFO and the time-out counter equal to TOIC. If Tout_IEN (IER [4]) is set then the tout interrupt will be generated. \nNote: This bit is read only and user can read UART_RBR (RX is in active) to clear it.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RX Time-Out interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX Time-Out interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BUF_ERR_IS</name>
              <description>Buffer Error Interrupt Status Flag (Read Only)\nThis bit is set when the TX or RX-FIFO overflowed. When BUF_ERR_IS is set, the transfer maybe not correct. If BUF_ER_IEN (IER [5]) is set then the buffer error interrupt will be generated.\nNote1:  This bit is read only, but can be cleared by it by writing "1" to TX_OVER_F (UART_FSR[8]) or RX_OVER_F (UART_FSR[0]).\nNote2: This bit is cleared when both that the TX_OVER_F and RX_OVER_F are cleared.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Buffer error interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Buffer error interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>WAKE_IS</name>
              <description>Wake-Up Interrupt Status Flag\nThis bit is set in Power-down mode, the receiver received data or CTSn signal. If WAKE_IE (IER [6]) is set then the wake-up interrupt will be generated.\nNote:  This bit can be cleared by it by writing "1" to it.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Wake-Up interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Wake-Up interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ABAUD_IS</name>
              <description>Auto-Baud Rate Interrupt Status Flag (Read Only)\nThis bit is set when auto-baud rate detection function finished or the auto-baud rate counter was overflow and if ABAUD_IE (IER [7]) is set then the auto-baud rate interrupt will be generated.\nNote1: This bit is read only, but can be cleared by it by writing "1" to ABAUD_TOUT_F (UART_TRSR[2]) or ABAUD_F (UART_TRSR[1]).\nNote2: This bit is cleared when both that the ABAUD_TOUT_F and ABAUD_F are cleared.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Auto-Baud Rate interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-Baud Rate interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LIN_IS</name>
              <description>LIN Interrupt Status Flag (Read Only)\nThis bit is set when the LIN TX header transmitted, RX header received or the SIN does not equal SOUT and if LIN_IE (IER [8]) is set then the LIN interrupt will be generated. \nNote1: This bit is read only, but can be cleared by it by writing "1" to BIT_ERR_F (UART_TRSR[5]), LIN_TX_F (UART_TRSR[3]) or LIN_RX_F (UART_TRSR[4]).\nNote2: This bit is cleared when both that the BIT_ERR_F, BIT_TX_F and LIN_RX_F are cleared.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No LIN interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UART_TRSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UART_TRSR</displayName>
          <description>UART Transfer Status Register.</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RS_485_ADDET_F</name>
              <description>RS-485 Address Byte Detection Status Flag\nNote1: This field is used for RS-485 mode.\nNote2: This bit can be cleared by writing "1" to it.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RS-485 address detection interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RS-485 address detection interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ABAUD_F</name>
              <description>Auto-Baud Rate Interrupt\nThis bit is set to logic "1" when auto-baud rate detect function finished.\nNote: This bit can be cleared by writing "1" to it.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Auto- Baud Rate interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-Baud Rate interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ABAUD_TOUT_F</name>
              <description>Auto-Baud Rate Time-Out Interrupt\nThis bit is set to logic "1" in Auto-baud Rate Detect mode and the baud rate counter is overflow.\nNote: This bit can be cleared by writing "1" to it.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Auto-Baud Rate Time-Out interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-Baud Rate Time-Out interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_TX_F</name>
              <description>LIN TX Interrupt Flag\nThis bit is set to logic "1" when LIN transmitted header field. The header may be "break field" or "break field + sync field" or "break field + sync field + PID field", it can be choose by setting LIN_HEAD_SEL (UART_ALT_CTL[5:4]) register.\nNote: This bit can be cleared by writing "1" to it.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No LIN Tx interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN Tx interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_RX_F</name>
              <description>LIN RX Interrupt Flag\nThis bit is set to logic "1" when received LIN header field. The header may be "break field" or "break field + sync field" or "break field + sync field + PID field", and it can be choose by setting LIN_HEAD_SEL (UART_ALT_CTL [5:4]) register.\nNote: This bit can be cleared by writing "1" to it.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No LIN Rx interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN Rx interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BIT_ERR_F</name>
              <description>Bit Error Detect Status Flag\nAt TX transfer state, hardware will monitoring the bus state, if the input pin (SIN) state not equals to the output pin (SOUT) state, BIT_ERR_F will be set.\nWhen occur bit error, hardware will generate an interrupt to CPU (INT_LIN).\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Bit error interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit error interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_RX_SYNC_ERR_F</name>
              <description>LIN RX SYNC Error Flag (Read Only)\nThis bit is set to logic "1" when LIN received incorrect SYNC field. \nUser can choose the header by setting UART_ALT_CTL [LIN_HEAD_SEL] register.\nNote: This bit is read only, but can be cleared by writing "1" to LIN_RX_F.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No LIN Rx sync error is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN Rx sync error is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UART_FSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UART_FSR</displayName>
          <description>UART FIFO Status Register.</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000A02</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX_OVER_F</name>
              <description>RX Overflow Error Status Flag \nThis bit is set when RX-FIFO overflow.\nIf the number of bytes of received data is greater than RX-FIFO (UART_RBR) size, 16 bytes of UART0/UART1, this bit will be set.\nNote: This bit can be cleared by writing "1" to it.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX FIFO is not overflow</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX FIFO is overflow</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_EMPTY_F</name>
              <description>Receiver FIFO Empty (Read Only)\nThis bit initiate RX-FIFO empty or not.\nWhen the last byte of RX-FIFO has been read by CPU, hardware sets this bit high. It will be cleared when UART receives any new data.\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX FIFO is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX FIFO is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_FULL_F</name>
              <description>Receiver FIFO Full (Read Only)\nThis bit initiates RX-FIFO full or not.\nThis bit is set when RX_POINTER_F is equal to 16, otherwise is cleared by hardware.\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX FIFO is not full</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX FIFO is full</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>PE_F</name>
              <description>Parity Error State Status Flag\nThis bit is set to logic "1" whenever the received character does not have a valid "parity bit", and it is reset whenever the CPU writes "1" to this bit.\nNote: This bit can be cleared by writing "1" to it.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No parity error is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Parity error is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FE_F</name>
              <description>Framing Error Status Flag\nThis bit is set to logic "1" whenever the received character does not have a valid "stop bit" (that is, the stop bit following the last data bit or parity bit is detected as a logic "0"), and it is reset whenever the CPU writes "1" to this bit.\nNote: This bit can be cleared by writing "1" to it.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No framing error is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Framing error is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BI_F</name>
              <description>Break Status Flag\nThis bit is set to a logic "1" whenever the received data input(RX) is held in the "spacing state" (logic "0") for longer than a full word transmission time (that is, the total time of "start bit" + data bits + parity + stop bits) and it is reset whenever the CPU writes "1" to this bit.\nNote: This bit can be cleared by writing "1" to it.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Break interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Break interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_OVER_F</name>
              <description>TX Overflow Error Interrupt Status Flag\nIf TX-FIFO (UART_THR) is full, an additional write to UART_THR will cause this bit to logic "1". \nNote: This bit can be cleared by writing "1" to it.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX FIFO is not overflow</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX FIFO is overflow</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_EMPTY_F</name>
              <description>Transmitter FIFO Empty  (Read Only)\nThis bit indicates TX-FIFO empty or not.\nWhen the last byte of TX-FIFO has been transferred to Transmitter Shift Register, hardware sets this bit high. It will be cleared when writing data into THR (TX-FIFO not empty).\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX FIFO is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX FIFO is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_FULL_F</name>
              <description>Transmitter FIFO Full  (Read Only)\nThis bit indicates TX-FIFO full or not.\nThis bit is set when TX_POINTER_F is equal to 16, otherwise is cleared by hardware.\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX FIFO is not full</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX FIFO is full</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TE_F</name>
              <description>Transmitter Empty Status Flag (Read Only)\nThis bit is set by hardware when TX FIFO (UA_THR) is empty and the STOP bit of the last byte has been transmitted. \nThis bit is cleared automatically when TX FIFO is not empty or the last byte transmission has not completed.\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX FIFO is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX FIFO is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_POINTER_F</name>
              <description>RX-FIFO Pointer (Read Only)\nThis field indicates the RX-FIFO Buffer Pointer. When UART receives one byte from external device, RX_POINTER_F increases one. When one byte of RX-FIFO is read by CPU, RX_POINTER_F decreases one.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_POINTER_F</name>
              <description>TX-FIFO Pointer (Read Only)\nThis field indicates the TX-FIFO Buffer Pointer. When CPU writes one byte data into UART_THR, TX_POINTER_F increases one. When one byte of TX-FIFO is transferred to Transmitter Shift Register, TX_POINTER_F decreases one.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UART_MCSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UART_MCSR</displayName>
          <description>UART Modem Status Register.</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00020002</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LEV_RTS</name>
              <description>RTSn Trigger Level \n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>low level triggered</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>high level triggered</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RTS_ST</name>
              <description>RTSn Pin State (Read Only)\nThis bit is the pin status of RTSn.\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTS pin input is low level voltage logic state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTS pin input is high level voltage logic state</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LEV_CTS</name>
              <description>CTSn Trigger Level\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Low level triggered</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>High level triggered</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CTS_ST</name>
              <description>CTSn Pin Status (Read Only)\nThis bit is the pin status of CTSn.\n</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>CTS pin input is low level voltage logic state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CTS pin input is high level voltage logic state</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>DCT_F</name>
              <description>Detect CTSn State Change Status Flag (Read Only)\nThis bit is set whenever CTSn input has change state, and it will generate Modem interrupt to CPU when Modem_IEN (UART_IER [3]).\nNote: This bit is read only, but it can be cleared by writing "1" to it.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>CTS input has not change state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CTS input has change state</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UART_TMCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UART_TMCTL</displayName>
          <description>UART Time-out Control Register.</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x000001FF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TOIC</name>
              <description>Time-Out Comparator\nThe time-out counter resets and starts counting whenever the RX-FIFO receives a new data word. \nNote1: Fill all "0" to this field indicates to disable this function.\nNote2: The real time-out value is TOIC + 1.\nNote3: The counting clock is baud rate clock.\nNote4: The UART data format is start bit + 8 bit data + parity bit + stop bit, so although software can configure this field by any value but it is recommend to filled this field great than 0xA.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DLY</name>
              <description>TX Delay Time Value\nThis field is use to programming the transfer delay time between the last stop bit and next start bit.\n \nNote1: Fill all "0" to this field indicates to disable this function.\nNote2: The real delay value is DLY.\nNote3: The counting clock is baud rate clock.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UART_BAUD</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UART_BAUD</displayName>
          <description>UART Baud Rate Divisor Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BRD</name>
              <description>Baud Rate Divider \n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIV_16_EN</name>
              <description>Divider 16 Enable\nNote: In IrDA mode, this bit must disable.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The equation of baud rate is UART_CLK / [ (BRD+1)]</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The equation of baud rate is UART_CLK / [16 * (BRD+1)]</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UART_IRCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UART_IRCR</displayName>
          <description>UART IrDA Control Register.</description>
          <addressOffset>0x30</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000040</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX_SELECT</name>
              <description>TX_SELECT\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Select IrDA receiver</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Select IrDA transmitter</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INV_TX</name>
              <description>INV_TX\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX output signal no inversion</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX output signal inversion</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INV_RX</name>
              <description>INV_RX\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX input signal no inversion</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX input signal inversion</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UART_ALT_CTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UART_ALT_CTL</displayName>
          <description>UART Alternate Control State Register.</description>
          <addressOffset>0x34</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LIN_TX_BCNT</name>
              <description>LIN TX Break Field Count Register\nThe field contains 3-bit LIN TX break field count.\nNote: The break field length is LIN_TX_BCNT + 8.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_HEAD_SEL</name>
              <description>LIN Header Selection\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The LIN header includes "break field"</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The LIN header includes "break field + sync field"</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>The LIN header includes "break field + sync field + PID field"</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_RX_EN</name>
              <description>LIN RX Enable\nWhen LIN RX mode enabled and received a break field or sync field or PID field (Select by LIN_Header_SEL), the controller will generator a interrupt to CPU (INT_LIN)\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN RX mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN RX mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_TX_EN</name>
              <description>LIN TX Header Trigger Enable\nNote2: If user wants to receive transmit data, it recommended to enable LIN_RX_EN bit.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN TX Header Trigger Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN TX Header Trigger Enabled.Note1: This bit will be cleared automatically and generate a interrupt to CPU (INT_LIN)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BIT_ERR_EN</name>
              <description>Bit Error Detect Enable\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit error detection Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit error detection Enabled.Note: In LIN function mode, when bit error occurs, hardware will generate an interrupt to CPU (INT_LIN)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS_485_NMM</name>
              <description>RS-485 Normal Multi-Drop Operation Mode (RS-485 NMM Mode)\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RS-485 Normal Multi-drop Operation mode (NMM) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RS-485 Normal Multi-drop Operation mode (NMM) Enabled.Note: It can't be active in RS-485_AAD Operation mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS_485_AAD</name>
              <description>RS-485 Auto Address Detection Operation Mode (RS-485 AAD Mode)\n</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RS-485 Auto Address Detection Operation mode (AAD) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RS-485 Auto Address Detection Operation mode (AAD) Enabled.Note: It can't be active in RS-485_NMM Operation mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS_485_AUD</name>
              <description>RS-485 Auto Direction Mode (RS-485 AUD Mode)\n</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RS-485 Auto Direction mode (AUD) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RS-485 Auto Direction mode (AUD) Enabled.Note: It can be active in RS-485_AAD or RS-485_NMM operation mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS_485_ADD_EN</name>
              <description>RS-485 Address Detection Enable\nThis bit is used to enable RS-485 hardware address detection mode.\n</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Address detection mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Address detection mode Enabled.Note: This field is used for RS-485 any operation mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADDR_PID_MATCH</name>
              <description>Address / PID Match Value Register\nWhen in the RS-485 Function Mode, this field contains the RS-485 address match values.\nWhen in the LIN Function mode, this field contains the LIN protected identifier field, software fills ID0~ID5 (ADDR_PID_MATCH [5:0]), hardware will calculate P0 and P1.\n\nNote: This field is used for RS-485 auto address detection mode or used for LIN protected identifier field (PID).</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UART_FUN_SEL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UART_FUN_SEL</displayName>
          <description>UART Function Select Register.</description>
          <addressOffset>0x38</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FUN_SEL</name>
              <description>Function Select Enable\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UART function mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN function mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>IrDA function mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>RS-485 function mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>UART1</name>
      <description>UART Register Map</description>
      <groupName>UART</groupName>
      <baseAddress>0x40150000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x28</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x30</offset>
        <size>0xC</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>UART_RBR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UART_RBR</displayName>
          <description>UART Receive Buffer Register.</description>
          <addressOffset>0x0</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>RBR</name>
              <description>Receive Buffer Register\nBy reading this register, the UART will return an 8-bit data received from RX pin (LSB first).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UART_THR</name>
          <alternateRegister>UART_RBR</alternateRegister>
          <!-- the display name is an unrestricted string. -->
          <displayName>UART_THR</displayName>
          <description>UART Transmit Holding Register.</description>
          <addressOffset>0x0</addressOffset>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>THR</name>
              <description>Transmit Holding Register\nBy writing to this register, the UART will send out an 8-bit data through the TX pin (LSB first).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UART_CTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UART_CTL</displayName>
          <description>UART Control Register.</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX_RST</name>
              <description>RX Software Reset\nWhen RX_RST is set, all the bytes in the receiving FIFO and RX internal state machine are cleared.\nNote: This bit will auto clear and takes at least 3 UART peripheral clock cycles.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the RX internal state machine and pointers</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_RST</name>
              <description>TX Software Reset\nWhen TX_RST is set, all the bytes in the transmitting FIFO and TX internal state machine are cleared.\nNote: This bit will auto clear and takes at least 3 UART engine clock cycles.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the TX internal state machine and pointers</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_DIS</name>
              <description>Receiver Disable Register\nNote1: In RS-485 NMM mode, user can setting this bit to receive data or not that before detect address byte.\nNote2: In RS-485 NMM mode, this bit will be setting to "1" automatically.\nNote3: In RS-485 AAD mode and LIN "break + sync +PID" header mode, hardware will control data automatically, so don't fill any value to this bit.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receiver Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receiver Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_DIS</name>
              <description>Transfer Disable Register\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transfer Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTO_RTS_EN</name>
              <description>RTSn Auto-Flow Control Enable \nWhen RTSn auto-flow is enabled, if the number of bytes in the RX-FIFO equals the RTS_TRI_LEV (UART_TLCTL[13:12]), the UART will reassert RTSn signal.\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTSn auto-flow control. Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTSn auto-flow control Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTO_CTS_EN</name>
              <description>CTSn Auto-Flow Control Enable \n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CTSn auto-flow control Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_RX_EN</name>
              <description>RX DMA Enable \nNote: If RLS_IE (UART_IER[2]) is enabled and RLS_IS(UART_ISR[2]) is set to 1, the RLS (Receive Line Status) Interrupt is caused. If RLS interrupt is caused by Break Error Flag BI_F(UART_FSR[6]), Frame Error Flag FE_F(UART_FSR[5]) or Parity Error Flag PE_F(UART_FSR[4]) , UART PDMA receive request operation is stop. Clear Break Error Flag BI_F or Frame Error Flag FE_F or Parity Error Flag PE_F by writing "1" to corresponding BI_F, FE_F and PE_F to make UART PDMA receive request operation continue.  </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX PDMA service function Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX PDMA service function Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_TX_EN</name>
              <description>TX DMA Enable \nNote: If RLS_IE (UART_IER[2]) is enabled and RLS_IS(UART_ISR[2]) is set to 1, the RLS (Receive Line Status) Interrupt is caused. If RLS interrupt is caused by Break Error Flag BI_F(UART_FSR[6]), Frame Error Flag FE_F(UART_FSR[5]) or Parity Error Flag PE_F(UART_FSR[4]) , UART PDMA transmit request operation is stop. Clear Break Error Flag BI_F or Frame Error Flag FE_F or Parity Error Flag PE_F by writing "1" to corresponding BI_F, FE_F and PE_F to make UART PDMA transmit request operation continue.  </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX PDMA service function Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX PDMA service function Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKE_CTS_EN</name>
              <description>CTSn Wake-Up Function Enable \n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>CTSn wake-up system function Disabled 1 = Wake-up function Enabled when the system is in power-down mode, an external CTSn change will wake-up system from power-down mode</description>
                    <value>#0</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKE_DATA_EN</name>
              <description>Incoming Data Wake-Up Function Enable \nNote: Hardware will clear this bit when the incoming data wake-up operation finishes and "system clock" work stable.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Incoming data wake-up system Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Incoming data wake-up function Enabled when the system is in power-down mode, incoming data will wake-up system from power-down mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ABAUD_EN</name>
              <description>Auto-Baud Rate Detect Enable\nNote: When the auto-baud rate detect operation finishes, hardware will clear this bit and the associated interrupt (INT_ABAUD) will be generated (If ABAUD_IE (UART_IER [7]) be enabled).</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Auto-baud rate detect function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-baud rate detect function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UART_TLCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UART_TLCTL</displayName>
          <description>UART Transfer Line Control Register.</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA_LEN</name>
              <description>Data Length\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Word length is 5-bit</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Word length is 6-bit</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Word length is 7-bit</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Word length is 8-bit</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>NSB</name>
              <description>Number Of STOP Bit Length\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>1 " STOP bit" is generated in the transmitted data</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>1.5 "STOP bit" is generated in the transmitted data when 5-bit word length is selected, and 2 STOP bit" is generated when 6, 7 and 8 bit data length is selected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PBE</name>
              <description>Parity Bit Enable\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Parity bit is not generated (transmitting data) or checked (receiving data) during transfer.1 = Parity bit is generated or checked between the  last data word bit  and  stop bit  of the serial data</description>
                    <value>#0</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EPE</name>
              <description>Even Parity Enable\nNote: This bit has effect only when PBE bit (parity bit enable) is set.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Odd number of logic 1's are transmitted or check the data word and parity bits in receiving mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Even number of logic 1's are transmitted or check the data word and parity bits in receiving mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPE</name>
              <description>Stick Parity Enable  \nStick Parity Enable  Control\nNote1: When bits PBE, EPE and SPE are set, the parity bit is transmitted and checked as "0". When PBE and SPE are set and EPE is cleared, the parity bit is transmitted and checked as "1". \nNote2: In RS-485 mode, PBE, EPE and SPE can control bit 9, the bit 9 setting are shown as follows.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Stick parity Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Stick parity Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BCB</name>
              <description>Break Control Bit  \nWhen this bit is set to logic "1", the serial data output (TX) is forced to the Spacing State (logic "0"). This bit acts only on TX pin and has no effect on the transmitter logic.\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Break control Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Break control Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RFITL</name>
              <description>RX-FIFO Interrupt (INT_RDA) Trigger Level \nWhen the number of bytes in the receiving FIFO equals to the RFITL then the RDA_IF will be set (if RDA_IEN (IER [0]) is enabled, an interrupt will be generated)\nNote: When operating in IrDA mode or RS-485 mode, the RFITL must be set to "0".</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX FIFO Interrupt Trigger Level is 1 byte</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX FIFO Interrupt Trigger Level is 4 bytes</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>RX FIFO Interrupt Trigger Level is 8 bytes</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>RX FIFO Interrupt Trigger Level is 14 bytes</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RTS_TRI_LEV</name>
              <description>RTSn Trigger Level (For Auto-Flow Control Use)\nNote: This field is used for auto RTSn flow control.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTS Trigger Level is 1 byte</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTS Trigger Level is 4 bytes</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>RTS Trigger Level is 8 bytes</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>RTS Trigger Level is 14 bytes</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UART_IER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UART_IER</displayName>
          <description>UART Interrupt Enable Register.</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDA_IE</name>
              <description>Receive Data Available Interrupt Enable\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>INT_RDA Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>INT_RDA Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>THRE_IE</name>
              <description>Transmit Holding Register Empty Interrupt Enable\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>INT_THRE Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>INT_THRE Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RLS_IE</name>
              <description>Receive Line Status Interrupt Enable \n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>INT_RLS Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>INT_RLS Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODEM_IE</name>
              <description>Modem Status Interrupt Enable \n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>INT_MOS Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>INT_MOS Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RTO_IE</name>
              <description>RX Time-Out Interrupt Enable\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>INT_TOUT Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>INT_TOUT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BUF_ERR_IE</name>
              <description>Buffer Error Interrupt Enable\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>INT_BUT_ERR Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>INT_BUF_ERR Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKE_IE</name>
              <description>Wake-Up Interrupt Enable\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>INT_WAKE Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>INT_WAKE Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ABAUD_IE</name>
              <description>Auto-Baud Rate Interrupt Enable\n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>INT_ABAUD Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>INT_ABAUD Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_IE</name>
              <description>LIN Interrupt Enable\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>INT_LIN Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>INT_LIN Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UART_ISR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UART_ISR</displayName>
          <description>UART Interrupt Status Register.</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000002</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDA_IS</name>
              <description>Receive Data Available Interrupt Flag (Read Only)\nWhen the number of bytes in the RX-FIFO equals the RFITL then the RDA_IF will be set. If RDA_IEN (IER [0]) is set then the RDA interrupt will be generated. \nNote:  This bit is read only and it will be cleared when the number of unread bytes of RX-FIFO drops below the threshold level (RFITL).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Receive Data available interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receive Data available interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>THRE_IS</name>
              <description>Transmit Holding Register Empty Interrupt Flag (Read Only) \nThis bit is set when the last data of TX-FIFO is transferred to Transmitter Shift Register. If THRE_IEN (IER [1]) is set that the THRE interrupt will be generated.\nNote: This bit is read only and it will be cleared when writing data into THR (TX-FIFO not empty).</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Transmit Holding register empty interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmit Holding register empty interrupt generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RLS_IS</name>
              <description>Receive Line Interrupt Status Flag (Read Only)\nThis bit is set when the RX received data has parity error (PE_F (UART_FSR[4])), framing error (FE_F (UART_FSR[5])), break error (BI_F (UART_FSR[6])) or RS-485 detect address byte (RS-485_ADDET_F (UART_TRSR[0])).If RLS_IE (UART_IER[2]) is set then the RLS interrupt will be generated.\nNote1: This bit is read only, but can be cleared by it by writing "1" to BI_F (UART_FSR[6]), FE_F (UART_FSR[5]), PE_F (UART_FSR[4]) or RS-485_ADDET_F (UART_TRSR[0]).\nNote2: This bit is cleared when both that the BI_F, FE_F, PE_F and RS-485_ADDET_F are cleared.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Receive Line interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receive Line interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>MODEM_IS</name>
              <description>MODEM Interrupt Status Flag (Read Only) \nNote: This bit is read only, but can be cleared by it by writing "1" to DCT_F (UART_MCSR [18]).</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No MODEM interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>MODEM interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RTO_IS</name>
              <description>RX Time-Out Interrupt Status Flag (Read Only)\nThis bit is set when the RX-FIFO is not empty and no activities occur in the RX-FIFO and the time-out counter equal to TOIC. If Tout_IEN (IER [4]) is set then the tout interrupt will be generated. \nNote: This bit is read only and user can read UART_RBR (RX is in active) to clear it.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RX Time-Out interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX Time-Out interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BUF_ERR_IS</name>
              <description>Buffer Error Interrupt Status Flag (Read Only)\nThis bit is set when the TX or RX-FIFO overflowed. When BUF_ERR_IS is set, the transfer maybe not correct. If BUF_ER_IEN (IER [5]) is set then the buffer error interrupt will be generated.\nNote1:  This bit is read only, but can be cleared by it by writing "1" to TX_OVER_F (UART_FSR[8]) or RX_OVER_F (UART_FSR[0]).\nNote2: This bit is cleared when both that the TX_OVER_F and RX_OVER_F are cleared.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Buffer error interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Buffer error interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>WAKE_IS</name>
              <description>Wake-Up Interrupt Status Flag\nThis bit is set in Power-down mode, the receiver received data or CTSn signal. If WAKE_IE (IER [6]) is set then the wake-up interrupt will be generated.\nNote:  This bit can be cleared by it by writing "1" to it.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Wake-Up interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Wake-Up interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ABAUD_IS</name>
              <description>Auto-Baud Rate Interrupt Status Flag (Read Only)\nThis bit is set when auto-baud rate detection function finished or the auto-baud rate counter was overflow and if ABAUD_IE (IER [7]) is set then the auto-baud rate interrupt will be generated.\nNote1: This bit is read only, but can be cleared by it by writing "1" to ABAUD_TOUT_F (UART_TRSR[2]) or ABAUD_F (UART_TRSR[1]).\nNote2: This bit is cleared when both that the ABAUD_TOUT_F and ABAUD_F are cleared.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Auto-Baud Rate interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-Baud Rate interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LIN_IS</name>
              <description>LIN Interrupt Status Flag (Read Only)\nThis bit is set when the LIN TX header transmitted, RX header received or the SIN does not equal SOUT and if LIN_IE (IER [8]) is set then the LIN interrupt will be generated. \nNote1: This bit is read only, but can be cleared by it by writing "1" to BIT_ERR_F (UART_TRSR[5]), LIN_TX_F (UART_TRSR[3]) or LIN_RX_F (UART_TRSR[4]).\nNote2: This bit is cleared when both that the BIT_ERR_F, BIT_TX_F and LIN_RX_F are cleared.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No LIN interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UART_TRSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UART_TRSR</displayName>
          <description>UART Transfer Status Register.</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RS_485_ADDET_F</name>
              <description>RS-485 Address Byte Detection Status Flag\nNote1: This field is used for RS-485 mode.\nNote2: This bit can be cleared by writing "1" to it.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RS-485 address detection interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RS-485 address detection interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ABAUD_F</name>
              <description>Auto-Baud Rate Interrupt\nThis bit is set to logic "1" when auto-baud rate detect function finished.\nNote: This bit can be cleared by writing "1" to it.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Auto- Baud Rate interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-Baud Rate interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ABAUD_TOUT_F</name>
              <description>Auto-Baud Rate Time-Out Interrupt\nThis bit is set to logic "1" in Auto-baud Rate Detect mode and the baud rate counter is overflow.\nNote: This bit can be cleared by writing "1" to it.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Auto-Baud Rate Time-Out interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-Baud Rate Time-Out interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_TX_F</name>
              <description>LIN TX Interrupt Flag\nThis bit is set to logic "1" when LIN transmitted header field. The header may be "break field" or "break field + sync field" or "break field + sync field + PID field", it can be choose by setting LIN_HEAD_SEL (UART_ALT_CTL[5:4]) register.\nNote: This bit can be cleared by writing "1" to it.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No LIN Tx interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN Tx interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_RX_F</name>
              <description>LIN RX Interrupt Flag\nThis bit is set to logic "1" when received LIN header field. The header may be "break field" or "break field + sync field" or "break field + sync field + PID field", and it can be choose by setting LIN_HEAD_SEL (UART_ALT_CTL [5:4]) register.\nNote: This bit can be cleared by writing "1" to it.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No LIN Rx interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN Rx interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BIT_ERR_F</name>
              <description>Bit Error Detect Status Flag\nAt TX transfer state, hardware will monitoring the bus state, if the input pin (SIN) state not equals to the output pin (SOUT) state, BIT_ERR_F will be set.\nWhen occur bit error, hardware will generate an interrupt to CPU (INT_LIN).\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Bit error interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit error interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_RX_SYNC_ERR_F</name>
              <description>LIN RX SYNC Error Flag (Read Only)\nThis bit is set to logic "1" when LIN received incorrect SYNC field. \nUser can choose the header by setting UART_ALT_CTL [LIN_HEAD_SEL] register.\nNote: This bit is read only, but can be cleared by writing "1" to LIN_RX_F.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No LIN Rx sync error is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN Rx sync error is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UART_FSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UART_FSR</displayName>
          <description>UART FIFO Status Register.</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000A02</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX_OVER_F</name>
              <description>RX Overflow Error Status Flag \nThis bit is set when RX-FIFO overflow.\nIf the number of bytes of received data is greater than RX-FIFO (UART_RBR) size, 16 bytes of UART0/UART1, this bit will be set.\nNote: This bit can be cleared by writing "1" to it.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX FIFO is not overflow</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX FIFO is overflow</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_EMPTY_F</name>
              <description>Receiver FIFO Empty (Read Only)\nThis bit initiate RX-FIFO empty or not.\nWhen the last byte of RX-FIFO has been read by CPU, hardware sets this bit high. It will be cleared when UART receives any new data.\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX FIFO is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX FIFO is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_FULL_F</name>
              <description>Receiver FIFO Full (Read Only)\nThis bit initiates RX-FIFO full or not.\nThis bit is set when RX_POINTER_F is equal to 16, otherwise is cleared by hardware.\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX FIFO is not full</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX FIFO is full</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>PE_F</name>
              <description>Parity Error State Status Flag\nThis bit is set to logic "1" whenever the received character does not have a valid "parity bit", and it is reset whenever the CPU writes "1" to this bit.\nNote: This bit can be cleared by writing "1" to it.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No parity error is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Parity error is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FE_F</name>
              <description>Framing Error Status Flag\nThis bit is set to logic "1" whenever the received character does not have a valid "stop bit" (that is, the stop bit following the last data bit or parity bit is detected as a logic "0"), and it is reset whenever the CPU writes "1" to this bit.\nNote: This bit can be cleared by writing "1" to it.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No framing error is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Framing error is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BI_F</name>
              <description>Break Status Flag\nThis bit is set to a logic "1" whenever the received data input(RX) is held in the "spacing state" (logic "0") for longer than a full word transmission time (that is, the total time of "start bit" + data bits + parity + stop bits) and it is reset whenever the CPU writes "1" to this bit.\nNote: This bit can be cleared by writing "1" to it.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Break interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Break interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_OVER_F</name>
              <description>TX Overflow Error Interrupt Status Flag\nIf TX-FIFO (UART_THR) is full, an additional write to UART_THR will cause this bit to logic "1". \nNote: This bit can be cleared by writing "1" to it.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX FIFO is not overflow</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX FIFO is overflow</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_EMPTY_F</name>
              <description>Transmitter FIFO Empty  (Read Only)\nThis bit indicates TX-FIFO empty or not.\nWhen the last byte of TX-FIFO has been transferred to Transmitter Shift Register, hardware sets this bit high. It will be cleared when writing data into THR (TX-FIFO not empty).\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX FIFO is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX FIFO is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_FULL_F</name>
              <description>Transmitter FIFO Full  (Read Only)\nThis bit indicates TX-FIFO full or not.\nThis bit is set when TX_POINTER_F is equal to 16, otherwise is cleared by hardware.\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX FIFO is not full</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX FIFO is full</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TE_F</name>
              <description>Transmitter Empty Status Flag (Read Only)\nThis bit is set by hardware when TX FIFO (UA_THR) is empty and the STOP bit of the last byte has been transmitted. \nThis bit is cleared automatically when TX FIFO is not empty or the last byte transmission has not completed.\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX FIFO is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX FIFO is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_POINTER_F</name>
              <description>RX-FIFO Pointer (Read Only)\nThis field indicates the RX-FIFO Buffer Pointer. When UART receives one byte from external device, RX_POINTER_F increases one. When one byte of RX-FIFO is read by CPU, RX_POINTER_F decreases one.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_POINTER_F</name>
              <description>TX-FIFO Pointer (Read Only)\nThis field indicates the TX-FIFO Buffer Pointer. When CPU writes one byte data into UART_THR, TX_POINTER_F increases one. When one byte of TX-FIFO is transferred to Transmitter Shift Register, TX_POINTER_F decreases one.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UART_MCSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UART_MCSR</displayName>
          <description>UART Modem Status Register.</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00020002</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LEV_RTS</name>
              <description>RTSn Trigger Level \n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>low level triggered</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>high level triggered</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RTS_ST</name>
              <description>RTSn Pin State (Read Only)\nThis bit is the pin status of RTSn.\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTS pin input is low level voltage logic state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTS pin input is high level voltage logic state</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LEV_CTS</name>
              <description>CTSn Trigger Level\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Low level triggered</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>High level triggered</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CTS_ST</name>
              <description>CTSn Pin Status (Read Only)\nThis bit is the pin status of CTSn.\n</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>CTS pin input is low level voltage logic state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CTS pin input is high level voltage logic state</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>DCT_F</name>
              <description>Detect CTSn State Change Status Flag (Read Only)\nThis bit is set whenever CTSn input has change state, and it will generate Modem interrupt to CPU when Modem_IEN (UART_IER [3]).\nNote: This bit is read only, but it can be cleared by writing "1" to it.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>CTS input has not change state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CTS input has change state</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UART_TMCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UART_TMCTL</displayName>
          <description>UART Time-out Control Register.</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x000001FF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TOIC</name>
              <description>Time-Out Comparator\nThe time-out counter resets and starts counting whenever the RX-FIFO receives a new data word. \nNote1: Fill all "0" to this field indicates to disable this function.\nNote2: The real time-out value is TOIC + 1.\nNote3: The counting clock is baud rate clock.\nNote4: The UART data format is start bit + 8 bit data + parity bit + stop bit, so although software can configure this field by any value but it is recommend to filled this field great than 0xA.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DLY</name>
              <description>TX Delay Time Value\nThis field is use to programming the transfer delay time between the last stop bit and next start bit.\n \nNote1: Fill all "0" to this field indicates to disable this function.\nNote2: The real delay value is DLY.\nNote3: The counting clock is baud rate clock.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UART_BAUD</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UART_BAUD</displayName>
          <description>UART Baud Rate Divisor Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BRD</name>
              <description>Baud Rate Divider \n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIV_16_EN</name>
              <description>Divider 16 Enable\nNote: In IrDA mode, this bit must disable.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The equation of baud rate is UART_CLK / [ (BRD+1)]</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The equation of baud rate is UART_CLK / [16 * (BRD+1)]</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UART_IRCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UART_IRCR</displayName>
          <description>UART IrDA Control Register.</description>
          <addressOffset>0x30</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000040</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX_SELECT</name>
              <description>TX_SELECT\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Select IrDA receiver</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Select IrDA transmitter</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INV_TX</name>
              <description>INV_TX\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX output signal no inversion</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX output signal inversion</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INV_RX</name>
              <description>INV_RX\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX input signal no inversion</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX input signal inversion</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UART_ALT_CTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UART_ALT_CTL</displayName>
          <description>UART Alternate Control State Register.</description>
          <addressOffset>0x34</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LIN_TX_BCNT</name>
              <description>LIN TX Break Field Count Register\nThe field contains 3-bit LIN TX break field count.\nNote: The break field length is LIN_TX_BCNT + 8.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_HEAD_SEL</name>
              <description>LIN Header Selection\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The LIN header includes "break field"</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The LIN header includes "break field + sync field"</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>The LIN header includes "break field + sync field + PID field"</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_RX_EN</name>
              <description>LIN RX Enable\nWhen LIN RX mode enabled and received a break field or sync field or PID field (Select by LIN_Header_SEL), the controller will generator a interrupt to CPU (INT_LIN)\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN RX mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN RX mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_TX_EN</name>
              <description>LIN TX Header Trigger Enable\nNote2: If user wants to receive transmit data, it recommended to enable LIN_RX_EN bit.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN TX Header Trigger Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN TX Header Trigger Enabled.Note1: This bit will be cleared automatically and generate a interrupt to CPU (INT_LIN)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BIT_ERR_EN</name>
              <description>Bit Error Detect Enable\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit error detection Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit error detection Enabled.Note: In LIN function mode, when bit error occurs, hardware will generate an interrupt to CPU (INT_LIN)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS_485_NMM</name>
              <description>RS-485 Normal Multi-Drop Operation Mode (RS-485 NMM Mode)\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RS-485 Normal Multi-drop Operation mode (NMM) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RS-485 Normal Multi-drop Operation mode (NMM) Enabled.Note: It can't be active in RS-485_AAD Operation mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS_485_AAD</name>
              <description>RS-485 Auto Address Detection Operation Mode (RS-485 AAD Mode)\n</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RS-485 Auto Address Detection Operation mode (AAD) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RS-485 Auto Address Detection Operation mode (AAD) Enabled.Note: It can't be active in RS-485_NMM Operation mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS_485_AUD</name>
              <description>RS-485 Auto Direction Mode (RS-485 AUD Mode)\n</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RS-485 Auto Direction mode (AUD) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RS-485 Auto Direction mode (AUD) Enabled.Note: It can be active in RS-485_AAD or RS-485_NMM operation mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS_485_ADD_EN</name>
              <description>RS-485 Address Detection Enable\nThis bit is used to enable RS-485 hardware address detection mode.\n</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Address detection mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Address detection mode Enabled.Note: This field is used for RS-485 any operation mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADDR_PID_MATCH</name>
              <description>Address / PID Match Value Register\nWhen in the RS-485 Function Mode, this field contains the RS-485 address match values.\nWhen in the LIN Function mode, this field contains the LIN protected identifier field, software fills ID0~ID5 (ADDR_PID_MATCH [5:0]), hardware will calculate P0 and P1.\n\nNote: This field is used for RS-485 auto address detection mode or used for LIN protected identifier field (PID).</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UART_FUN_SEL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UART_FUN_SEL</displayName>
          <description>UART Function Select Register.</description>
          <addressOffset>0x38</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FUN_SEL</name>
              <description>Function Select Enable\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UART function mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN function mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>IrDA function mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>RS-485 function mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SC0</name>
      <description>SC Register Map</description>
      <groupName>SC</groupName>
      <baseAddress>0x40190000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x40</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>SC_RBR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_RBR</displayName>
          <description>SC Receiving Buffer Register.</description>
          <addressOffset>0x0</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>RBR</name>
              <description>Receiving Buffer \nBy reading RBR, the SC will return an 8-bit received data.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_THR</name>
          <alternateRegister>SC_RBR</alternateRegister>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_THR</displayName>
          <description>SC Transmit Holding Register.</description>
          <addressOffset>0x0</addressOffset>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>THR</name>
              <description>Transmit Holding Buffer\nBy writing data to THR, the SC will send out an 8-bit data.\nNote: If SC_CEN (SC_CTL[0]) is not enabled, THR cannot be programmed.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_CTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_CTL</displayName>
          <description>SC Control Register.</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SC_CEN</name>
              <description>SC Engine Enable Control\nSet this bit to 1 to enable SC operation. If this bit is cleared, SC will force all transition to IDLE state</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIS_RX</name>
              <description>RX Transition Disable Control\nNote: If AUTO_CON_EN (SC_CTL[3]) is enabled, these fields must be ignored.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The receiver Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The receiver Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DIS_TX</name>
              <description>TX Transition Disable Control\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The transceiver Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The transceiver Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTO_CON_EN</name>
              <description>Auto Convention Enable Control\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Auto-convention Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-convention Enabled. When hardware receives TS in answer to reset state and the TS is direct convention, CON_SEL (SC_CTL[5:4]) will be set to 00 automatically, otherwise if the TS is inverse convention, and CON_SEL (SC_CTL[5:4]) will be set to 11</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CON_SEL</name>
              <description>Convention Selection\nNote: If AUTO_CON_EN (SC_CTL[3]) enabled, this fields are ignored.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Direct convention</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Reserved</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Inverse convention</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_FTRI_LEV</name>
              <description>Rx Buffer Trigger Level \nWhen the number of bytes in the receiving buffer equals the RX_FTRI_LEV, the RDA_IF will be set (if RDA_IEN (IER[0]) is enabled, an interrupt will be generated).\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>INTR_RDA Trigger Level with 01 byte</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>INTR_RDA Trigger Level with 02 bytes</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>INTR_RDA Trigger Level with 03 bytes</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BGT</name>
              <description>Block Guard Time (BGT)\n\nIn RX mode, software can enable RX_BGT_EN (SC_ALTCTL[12]) to detect the first coming character timing. If the incoming data timing less than BGT, an interrupt will be generated.\nNote: The real block guard time is BGT + 1.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR_SEL</name>
              <description>Timer Selection \n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>All internal timer function Disabled</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Internal 24-bit timer Enabled. Software can configure it by setting SC_TMR0[23:0]. SC_TMR1 and SC_TMR2 will be ignored in this mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>internal 24-bit timer and 8-bit internal timer Enabled. Software can configure the 24-bit timer by setting SC_TMR0[23:0] and configure the 8-bit timer by setting SC_TMR1[7:0]. SC_TMR2 will be ignored in this mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Internal 24-bit timer and two 8-bit timers Enabled. Software can configure them by setting SC_TMR0[23:0], SC_TMR1[7:0] and SC_TMR2[7:0]</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLEN</name>
              <description>Stop Bit Length\nThis field indicates the length of stop bit.\nNote: The default stop bit length is 2. SMC and UART adopts SLEN to program the stop bit length</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The stop bit length is 2 ETU</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The stop bit length is 1 ETU</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_ERETRY</name>
              <description>RX Error Retry Count Number\nThis field indicates the maximum number of receiver retries that are allowed when parity error has occurred\nNote1: The real retry number is RX_ERETRY + 1, so 8 is the maximum retry number.\nNote2: This field cannot be changed when RX_ERETRY_EN enabled. The change flow is to disable RX_ETRTRY_EN first and then fill in new retry value.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_ERETRY_EN</name>
              <description>RX Error Retry Enable Control\n</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX error retry function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX error retry function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_ERETRY</name>
              <description>TX Error Retry Count Number\nThis field indicates the maximum number of transmitter retries that are allowed when parity error has occurred.\nNote1: The real retry number is TX_ERETRY + 1, so 8 is the maximum retry number.\nNote2: This field cannot be changed when TX_ERETRY_EN enabled. The change flow is to disable TX_ETRTRY_EN first and then fill in new retry value.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_ERETRY_EN</name>
              <description>TX Error Retry Enable Control\nThis bit enables transmitter retry function when parity error has occurred.\n</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX error retry function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX error retry function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CD_DEB_SEL</name>
              <description>Card Detect De-Bounce Selection\nThis field indicates the card detect de-bounce selection.\n</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>De-bounce sample card insert once per 384 (128 * 3) engine clocks and de-bounce sample card removal once per 128 engine clocks</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>De-bounce sample card insert once per 192 (64 * 3) engine clocks and de-bounce sample card removal once per 64 engine clocks</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>De-bounce sample card insert once per 96 (32 * 3) engine clocks and de-bounce sample card removal once per 32 engine clocks</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>De-bounce sample card insert once per 48 (16 * 3) engine clocks and de-bounce sample card removal once per 16 engine clocks</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_ALTCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_ALTCTL</displayName>
          <description>SC Alternate Control Register.</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX_RST</name>
              <description>TX Software Reset\nWhen TX_RST (SC_ALTCTL[0]) is set, all the bytes in the transmit buffer and TX internal state machine will be cleared.\nNote: This bit will be auto cleared after reset is complete.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the TX internal state machine and pointers</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_RST</name>
              <description>Rx Software Reset\nWhen RX_RST (SC_ALTCTL[1]) is set, all the bytes in the receiver buffer and Rx internal state machine will be cleared.\nNote: This bit will be auto cleared after reset is complete.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the Rx internal state machine and pointers</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DACT_EN</name>
              <description>Deactivation Sequence Generator Enable Control\nThis bit enables SC controller to initiate the card by deactivation sequence\nNote1: When the deactivation sequence completed, this bit will be cleared automatically and the INIT_IS(SC_ISR[8]) will be set to 1.\nNote2: This field will be cleared by TX_RST (SC_ALTCTL[0]) and RX_RST (SC_ALTCTL[1]). So don't fill these two bits TX_RST (SC_ALTCTL[0]) and RX_RST (SC_ALTCTL[1]) at the same time.\nNote3: If SC_CEN (SC_CTL[0]) is not enabled, this filed cannot be programmed.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Deactivation sequence generator Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ACT_EN</name>
              <description>Activation Sequence Generator Enable Control\nThis bit enables SC controller to initiate the card by activation sequence\nNote1: When the activation sequence completed, this bit will be cleared automatically and the INIT_IS (SC_ISR[8]) will be set to 1.\nNote2: This field will be cleared by TX_RST (SC_ALTCTL[0]) and RX_RST (SC_ALTCTL[1]). So don't fill these two bits TX_RST (SC_ALTCTL[0]) and RX_RST (SC_ALTCTL[1]) at the same time.\nNote3: If SC_CEN (SC_CTL[0]) is not enabled, this filed cannot be programmed.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Activation sequence generator Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WARST_EN</name>
              <description>Warm Reset Sequence Generator Enable Control\nThis bit enables SC controller to initiate the card by warm reset sequence\nNote1: When the warm reset sequence completed, this bit will be cleared automatically and the INIT_IS (SC_ISR[8]) will be set to 1.\nNote2: This field will be cleared by TX_RST (SC_ALTCTL[0]) and RX_RST (SC_ALTCTL[1]). So don't fill these two bits TX_RST (SC_ALTCTL[0]) and RX_RST (SC_ALTCTL[1]) at the same time.\nNote3: If SC_CEN (SC_CTL[0]) is not enabled, this filed cannot be programmed</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Warm reset sequence generator Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR0_SEN</name>
              <description>Internal Timer0 Start Enable Control\nThis bit enables Timer 0 to start counting. Software can fill 0 to stop it and set 1 to reload and count.\nNote3: This field will be cleared by TX_RST (SC_ALTCTL[0]) and RX_RST (SC_ALTCTL[1]). So don't fill these two bits TX_RST (SC_ALTCTL[0]) and RX_RST (SC_ALTCTL[1]) at the same time.\nNote4: If SC_CEN (SC_CTL[0]) is not enabled, this filed cannot be programmed.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Stop counting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Start counting</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR1_SEN</name>
              <description>Internal Timer1 Start Enable Control\nThis bit enables Timer 1 to start counting. Software can fill 0 to stop it and set 1 to reload and count.\nNote3: This field will be cleared by TX_RST (SC_ALTCTL[0]) and RX_RST (SC_ALTCTL[1]). So don't fill these two bits TX_RST (SC_ALTCTL[0]) and RX_RST (SC_ALTCTL[1]) at the same time.\nNote4: If SC_CEN (SC_CTL[0]) is not enabled, this filed cannot be programmed.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Stop counting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Start counting</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR2_SEN</name>
              <description>Internal Timer2 Start Enable Control\nThis bit enables Timer 2 to start counting. Software can fill 0 to stop it and set 1 to reload and count.\nNote3: This field will be cleared by TX_RST (SC_ALTCTL[0]) and RX_RST (SC_ALTCTL[1]). So don't fill these two bits TX_RST (SC_ALTCTL[0]) and RX_RST (SC_ALTCTL[1]) at the same time.\nNote4: If SC_CEN (SC_CTL[0]) is not enabled, this filed cannot be programmed.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Stop counting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Start counting</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INIT_SEL</name>
              <description>Initial Timing Selection\nThis fields indicates the timing of hardware initial state (activation or warm-reset or deactivation).\nUnit: SC clock\nActivation: Refer to SC Activation Sequence in 5.14.4.1.\nWarm-reset: refer to Warm-Reset Sequence in 5.14.4.1\nDeactivation: refer to Deactivation Sequence in 5.14.4.1</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_BGT_EN</name>
              <description>Receiver Block Guard Time Function Enable Control\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receiver block guard time function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receiver block guard time function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR0_ATV</name>
              <description>Internal Timer0 Active State (Read Only)\nThis bit indicates the timer counter status of timer0.\n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer0 is not active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer0 is active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TMR1_ATV</name>
              <description>Internal Timer1 Active State (Read Only)\nThis bit indicates the timer counter status of timer1.\n</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer1 is not active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer1 is active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TMR2_ATV</name>
              <description>Internal Timer2 Active State (Read Only)\nThis bit indicates the timer counter status of timer2.\n</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer2 is not active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer2 is active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>OUTSEL</name>
              <description>Smartcard Data Pin Output Mode Selection\nUse this bit to select smartcard data pin output mode\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Quasi mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Open-drain mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_EGTR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_EGTR</displayName>
          <description>SC Extend Guard Time Register.</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EGT</name>
              <description>Extended Guard Time\nThis field indicates the extended guard timer value.\n\nNote: The counter is ETU base and the real extended guard time is EGT.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_RFTMR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_RFTMR</displayName>
          <description>SC Receive Buffer Time-out Register.</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RFTM</name>
              <description>SC Receiver Buffer Time-Out  (ETU Base)\nNote1: The counter unit is ETU based and the interval of time-out is RFTM + 0.5\nNote2: Fill all 0 to this field indicates to disable this function.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_ETUCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_ETUCR</displayName>
          <description>SC ETU Control Register.</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000173</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ETU_RDIV</name>
              <description>ETU Rate Divider\nThe field indicates the clock rate divider.\nThe real ETU is ETU_RDIV + 1.\nNote: Software can configure this field, but this field must be greater than 0x004.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPEN_EN</name>
              <description>Compensation Mode Enable Control\nThis bit enables clock compensation function. When this bit enabled, hardware will alternate between n clock cycles and n-1 clock cycles, where n is the value to be written into the ETU_RDIV .\n</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Compensation function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Compensation function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_IER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_IER</displayName>
          <description>SC Interrupt Enable Control Register.</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDA_IE</name>
              <description>Receive Data Reach Interrupt Enable Control\nThis field is used for received data reaching trigger level RX_FTRI_LEV (SC_CTL[7:6]) interrupt enable.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receive data reach trigger level interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receive data reach trigger level interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TBE_IE</name>
              <description>Transmit Buffer Empty Interrupt Enable Control\nThis field is used for transmit buffer empty interrupt enable.\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmit buffer empty interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmit buffer empty interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TERR_IE</name>
              <description>Transfer Error Interrupt Enable Control\nThis field is used for transfer error interrupt enable. The transfer error states is at SC_SR register which includes receiver break error RX_EBR_F (SC_SR[6]), frame error RX_EFR_F (SC_SR[5]), parity error RX_EPA_F (SC_SR[4]), receiver buffer overflow error RX_OVER_F (SC_SR[0]), transmit buffer overflow error TX_OVER_F (SC_SR[8]), receiver retry over limit error RX_OVER_REERR (SC_SR[22]) and transmitter retry over limit error TX_OVER_REERR (SC_SR[30]).\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer error interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transfer error interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR0_IE</name>
              <description>Timer0 Interrupt Enable Control\nThis field is used to enable the TMR0 interrupt.\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer0 interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer0 interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR1_IE</name>
              <description>Timer1 Interrupt Enable Control\nThis field is used to enable the TMR1 interrupt.\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer1 interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer1 interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR2_IE</name>
              <description>Timer2 Interrupt Enable Control\nThis field is used for TMR2 interrupt enable.\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer2 interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer2 interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BGT_IE</name>
              <description>Block Guard Time Interrupt Enable Control\nThis field is used for block guard time interrupt enable.\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Block guard time Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Block guard time Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CD_IE</name>
              <description>Card Detect Interrupt Enable Control\nThis field is used for card detect interrupt enable. The card detect status is CD_INS_F (SC_SR[12]) \n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Card detect interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Card detect interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INIT_IE</name>
              <description>Initial End Interrupt Enable Control\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Initial end interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Initial end interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RTMR_IE</name>
              <description>Receiver Buffer Time-Out Interrupt Enable Control \nThis field is used for receiver buffer time-out interrupt enable.\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receiver buffer time-out interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receiver buffer time-out interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ACON_ERR_IE</name>
              <description>Auto Convention Error Interrupt Enable Control \nThis field is used for auto-convention error interrupt enable.\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Auto-convention error interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-convention error interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_ISR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_ISR</displayName>
          <description>SC Interrupt Status Register.</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000002</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDA_IS</name>
              <description>Receive Data Reach Interrupt Status Flag (Read Only)\nThis field is used for received data reaching trigger level RX_FTRI_LEV (SC_CTL[7:6]) interrupt status flag.\nNote: This field is the status flag of received data reaching RX_FTRI_LEV (SC_CTL[7:6]). If software reads data from SC_RBR and receiver buffer data byte number is less than RX_FTRI_LEV (SC_CTL[7:6]), this bit will be cleared automatically.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TBE_IS</name>
              <description>Transmit Buffer Empty Interrupt Status Flag (Read Only)\nThis field is used for transmit buffer empty interrupt status flag.\nNote: This field is the status flag of transmit buffer empty state. If software wants to clear this bit, software must write data to SC_THR buffer and then this bit will be cleared automatically.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TERR_IS</name>
              <description>Transfer Error Interrupt Status Flag (Read Only)\nThis field is used for transfer error interrupt status flag. The transfer error states is at  SC_SR register which includes receiver break error RX_EBR_F (SC_SR[6]), frame error RX_EFR_F (SC_SR[5]), parity error RX_EPA_F (SC_SR[4]) and receiver buffer overflow error RX_OVER_F (SC_SR[0]), transmit buffer overflow error TX_OVER_F (SC_SR[8]), receiver retry over limit error RX_OVER_REERR (SC_SR[22]) and transmitter retry over limit error TX_OVER_REERR (SC_SC[30]).\nNote: This field is the status flag of RX_EBR_F(SC_SR[6]), RX_EFR_F (SC_SR[5]), RX_EPA_F (SC_SR[4]), RX_OVER_F (SC_SR[0]), TX_OVER_F (SC_SR[8]), RX_OVER_REERR (SC_SR[22] or TX_OVER_REERR (SC_SC[30]). So, if software wants to clear this bit, software must write 1 to each field.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TMR0_IS</name>
              <description>Timer0 Interrupt Status Flag (Read Only)\nThis field is used for TMR0 interrupt status flag.\nNote: This bit is read only, but it can be cleared by writing 1 to it.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TMR1_IS</name>
              <description>Timer1 Interrupt Status Flag (Read Only)\nThis field is used for TMR1 interrupt status flag.\nNote: This bit is read only, but it can be cleared by writing 1 to it.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TMR2_IS</name>
              <description>Timer2 Interrupt Status Flag (Read Only)\nThis field is used for TMR2 interrupt status flag.\nNote: This bit is read only, but it can be cleared by writing 1 to it.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BGT_IS</name>
              <description>\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CD_IS</name>
              <description>Card Detect Interrupt Status Flag (Read Only)\nThis field is used for card detect interrupt status flag. The card detect status  is CD_INS_F (SC_SR[12]) and CD_REM_F (SC_SR[11]).\nNote: This field is the status flag of CD_INS_F (SC_SR[12]), CD_INS_F (SC_PINCSR[3]) or CD_REM_F (SC_SR[11]). So if software wants to clear this bit, software must write 1 to this field.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>INIT_IS</name>
              <description>Initial End Interrupt Status Flag (Read Only)\nThis field is used for activation (ACT_EN (SC_ALTCTL[3])), deactivation (DACT_EN (SC_ALTCTL[2])) and warm reset (WARST_EN (SC_ALTCTL[4])) sequence interrupt status flag.\nNote: This bit is read only, but it can be cleared by writing 1 to it.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RTMR_IS</name>
              <description>Receiver Buffer Time-Out Interrupt Status Flag (Read Only)\nThis field is used for receiver buffer time-out interrupt status flag.\nNote: This field is the status flag of receiver buffer time-out state. If software wants to clear this bit, software must read all receiver buffer remaining data by reading SC_RBR buffer,</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ACON_ERR_IS</name>
              <description>Auto Convention Error Interrupt Status Flag (Read Only)\nThis field indicates auto convention sequence error. If the received TS at ATR state is neither 0x3B nor 0x3F, this bit will be set.\nNote: This bit is read only, but it can be cleared by writing 1 to it.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_TRSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_TRSR</displayName>
          <description>SC Status Register.</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000202</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX_OVER_F</name>
              <description>RX Overflow Error Status Flag (Read Only) \nThis bit is set when RX buffer overflow.\nIf the number of received bytes is greater than Rx Buffer size (4 bytes), this bit will be set.\nNote: This bit is read only, but it can be cleared by writing 1 to it.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_EMPTY_F</name>
              <description>Receiver Buffer Empty Status Flag (Read Only)\nThis bit indicates RX buffer empty or not.\nWhen the last byte of Rx buffer has been read by CPU, hardware sets this bit high. It will be cleared when SC receives any new data.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_FULL_F</name>
              <description>Receiver Buffer Full Status Flag (Read Only)\nThis bit indicates RX buffer full or not.\nThis bit is set when RX pointer is equal to 4, otherwise it is cleared by hardware.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_EPA_F</name>
              <description>Receiver Parity Error Status Flag (Read Only)\nThis bit is set to logic 1 whenever the received character does not have a valid "parity bit".\nNote1: This bit is read only, but it can be cleared by writing 1 to it.\nNote2: If CPU sets receiver retries function by setting RX_ERETRY_EN (SC_CTL[19]) , hardware will not set this flag.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_EFR_F</name>
              <description>Receiver Frame Error Status Flag (Read Only)\nThis bit is set to logic 1 whenever the received character does not have a valid "stop bit" (that is, the stop bit following the last data bit or parity bit is detected as a logic 0). \nNote1: This bit is read only, but it can be cleared by writing 1 to it.\nNote2: If CPU sets receiver retries function by setting RX_ERETRY_EN (SC_CTL[19]) , hardware will not set this flag.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_EBR_F</name>
              <description>Receiver Break Error Status Flag (Read Only)\nThis bit is set to logic 1 whenever the received data input (RX) held in the "spacing state" (logic 0) is longer than a full word transmission time (that is, the total time of "start bit" + data bits + parity + stop bits). .\nNote1: This bit is read only, but it can be cleared by writing 1 to it.\nNote2: If CPU sets receiver retries function by setting RX_ERETRY_EN (SC_CTL[19]) , hardware will not set this flag.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_OVER_F</name>
              <description>TX Overflow Error Interrupt Status Flag (Read Only)\nIf TX buffer is full, an additional write to SC_THR will cause this bit be set to "1" by hardware. \nNote: This bit is read only, but it can be cleared by writing 1 to it.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_EMPTY_F</name>
              <description>Transmit Buffer Empty Status Flag (Read Only)\nThis bit indicates TX buffer empty or not.\nWhen the last byte of TX buffer has been transferred to Transmitter Shift Register, hardware sets this bit high. It will be cleared when writing data into SC_THR (TX buffer not empty).</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_FULL_F</name>
              <description>Transmit Buffer Full Status Flag (Read Only)\nThis bit indicates TX buffer full or not.This bit is set when TX pointer is equal to 4, otherwise is cleared by hardware.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CD_REM_F</name>
              <description>Card Detect Removal Status Of SC_CD Pin (Read Only)\nThis bit is set whenever card has been removal.\nNote1: This bit is read only, but it can be cleared by writing "1" to it.\nNote2: Card detect engine will start after SC_CEN (SC_CTL[0]) set.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Card removed</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>CD_INS_F</name>
              <description>Card Detect Insert Status Of SC_CD Pin (Read Only)\nThis bit is set whenever card has been inserted.\nNote1: This bit is read only, but it can be cleared by writing "1" to it.\nNote2: The card detect engine will start after SC_CEN (SC_CTL[0]) set.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Card insert</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>CD_PIN_F</name>
              <description>Card Detect Status Of SC_CD Pin Status (Read Only)\nThis bit is the pin status flag of SC_CD\n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The SC_CD pin state at low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The SC_CD pin state at high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_POINT_F</name>
              <description>Receiver Buffer Pointer Status Flag (Read Only)\nThis field indicates the RX buffer pointer status flag. When SC receives one byte from external device, RX_POINT_F (SC_SR[17:16]) increases one. When one byte of RX buffer is read by CPU, RX_POINT_F (SC_SR[17:16]) decreases one.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_REERR</name>
              <description>Receiver Retry Error (Read Only)\nThis bit is set by hardware when RX has any error and retries transfer.\nNote1: This bit is read only, but it can be cleared by writing 1 to it.\nNote2 This bit is a flag and cannot generate any interrupt to CPU.\nNote3: If CPU enables receiver retry function by setting RX_ERETRY_EN (SC_CTL[19]) , the RX_EPA_F (SC_SR[4]) flag will be ignored (hardware will not set RX_EPA_F (SC_SR[4])).</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_OVER_REERR</name>
              <description>Receiver Over Retry Error (Read Only)\nThis bit is set by hardware when RX transfer error retry over retry number limit.\nNote1: This bit is read only, but it can be cleared by writing 1 to it.\nNote2: If CPU enables receiver retries function by setting RX_ERETRY_EN (SC_CTL[19]), the RX_EPA_F (SC_SR[4]) flag will be ignored (hardware will not set RX_EPA_F (SC_SR[4])).</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_ATV</name>
              <description>Receiver In Active Status Flag (Read Only)\nThis bit is set by hardware when RX transfer is in active.\nThis bit is cleared automatically when RX transfer is finished.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_POINT_F</name>
              <description>Transmit Buffer Pointer Status Flag (Read Only)\nThis field indicates the TX buffer pointer status flag. When CPU writes data into SC_THR, TX_POINT_F increases one. When one byte of TX Buffer is transferred to transmitter shift register, TX_POINT_F decreases one.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_REERR</name>
              <description>Transmitter Retry Error (Read Only)\nThis bit is set by hardware when transmitter re-transmits.\nNote1: This bit is read only, but it can be cleared by writing 1 to it.\nNote2 This bit is a flag and cannot generate any interrupt to CPU.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_OVER_REERR</name>
              <description>Transmitter Over Retry Error (Read Only)\nThis bit is set by hardware when transmitter re-transmits over retry number limitation.\nNote: This bit is read only, but it can be cleared by writing 1 to it.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_ATV</name>
              <description>Transmit In Active Status Flag (Read Only)\n</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>This bit is cleared automatically when TX transfer is finished or the last byte transmission has completed</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>This bit is set by hardware when TX transfer is in active and the STOP bit of the last byte has been transmitted</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_PINCSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_PINCSR</displayName>
          <description>SC Pin Control State Register.</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFF0F</resetMask>
          <fields>
            <field>
              <name>POW_EN</name>
              <description>SC_POW_EN Pin Signal\nSoftware can set POW_EN and POW_INV to decide SC_PWR pin is in high or low level.\nWrite this field to drive SC_PWR pin\nRefer POW_INV description for programming SC_PWR pin voltage level. \nRead this field to get SC_PWR pin status.\nNote: When operating at activation, warm reset or deactivation mode, this bit will be changed automatically. So don't fill this field when operating in these modes.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SC_PWR pin status is low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SC_PWR pin status is high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SC_RST</name>
              <description>SC_RST Pin Signal\nThis bit is the pin status of SC_RST but user can drive SC_RST pin to high or low by setting this bit.\nWrite this field to drive SC_RST pin.\nNote: When operating at activation, warm reset or deactivation mode, this bit will be changed automatically. So don't fill this field when operating in these modes.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Drive SC_RST pin to low.\nSC_RST pin status is low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Drive SC_RST pin to high.\nSC_RST pin status is high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CD_REM_F</name>
              <description>Card Detect Removal Status Of SC_CD Pin (Read Only)\nThis bit is set whenever card has been removal.\nNote1: This bit is read only, but it can be cleared by writing "1" to it.\nNote2: Card detect engine will start after SC_CEN (SC_CTL[0]) set.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Card Removal</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>CD_INS_F</name>
              <description>Card Detect Insert Status Of SC_CD Pin (Read Only)\nThis bit is set whenever card has been inserted.\nNote1: This bit is read only, but it can be cleared by writing "1" to it.\nNote2: Card detect engine will start after SC_CEN (SC_CTL[0]) set.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Card insert</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>CD_PIN_ST</name>
              <description>Card Detect Status Of SC_CD Pin Status (Read Only)\nThis bit is the pin status flag of SC_CD\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SC_CD pin state at low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SC_CD pin state at high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>CLK_KEEP</name>
              <description>SC Clock Enable Control \nNote: When operating in activation, warm reset or deactivation mode, this bit will be changed automatically. So don't fill this field when operating in these modes.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SC clock generation Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SC clock always keeps free running</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADAC_CD_EN</name>
              <description>Auto Deactivation When Card Removal\nNote: When the card is removal, hardware will stop any process and then do deactivation sequence (if this bit be setting). If this process completes. Hardware will generate an interrupt INT_INIT to CPU.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Auto deactivation Disabled when hardware detected the card is removal</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto deactivation Enabled when hardware detected the card is removal</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SC_OEN_ST</name>
              <description>SC Data Output Enable Pin Status (Read Only)\nThis bit is the pin status of SC_DATA_OEN\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The SC_DATA_OEN pin state at low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The SC_DATA_OEN pin state at high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>SC_DATA_O</name>
              <description>SC Data Output Pin \nThis bit is the pin status of SC_DATA_O but user can drive SC_DATA_O pin to high or low by setting this bit.\nNote: When SC is at activation, warm reset or deactivation mode, this bit will be changed automatically. So don't fill this field when SC is in these modes.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Drive SC_DATA_O pin to low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Drive SC_DATA_O pin to high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CD_LEV</name>
              <description>Card Detect Level\n\nNote: Software must select card detect level before Smart Card engine enable</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>When hardware detects the card detect pin from high to low, it indicates a card is detected</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When hardware detects the card detect pin from low to high, it indicates a card is detected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SC_DATA_I_ST</name>
              <description>SC Data Input Pin Status (Read Only)\nThis bit is the pin status of SC_DATA_I\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The SC_DATA_I pin is low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The SC_DATA_I pin is high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_TMR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_TMR0</displayName>
          <description>SC Internal Timer Control Register 0.</description>
          <addressOffset>0x28</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNT</name>
              <description>Timer 0 Counter Value  (ETU Base)\nThis field indicates the internal timer operation values.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>Timer 0 Operation Mode Selection\nThis field indicates the internal 24-bit timer operation selection.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_TMR1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_TMR1</displayName>
          <description>SC Internal Timer Control Register 1.</description>
          <addressOffset>0x2C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNT</name>
              <description>Timer 1 Counter Value  (ETU Base)\nThis field indicates the internal timer operation values.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>Timer 1 Operation Mode Selection\nThis field indicates the internal 8-bit timer operation selection.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_TMR2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_TMR2</displayName>
          <description>SC Internal Timer Control Register 2.</description>
          <addressOffset>0x30</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNT</name>
              <description>Timer 2 Counter Value  (ETU Base)\nThis field indicates the internal timer operation values.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>Timer 2 Operation Mode Selection\nThis field indicates the internal 8-bit timer operation selection</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_UACTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_UACTL</displayName>
          <description>SC UART Mode Control Register.</description>
          <addressOffset>0x34</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>UA_MODE_EN</name>
              <description>UART Mode Enable Control\nNote3: When UART is enabled, hardware will generate a reset to reset FIFO and internal state machine.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Smart Card mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_LEN</name>
              <description>Data Length\nNote: In smart card mode, this DATA_LEN must be '00'</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Character Data Length is 8 bits</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Character Data Length is 7 bits</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Character Data length is 6 bits</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Character Data Length is 5 bits</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PBDIS</name>
              <description>Parity Bit Disable Control\nNote: In smart card mode, this field must be '0' (default setting is with parity bit)</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Parity bit is generated or checked between the "last data word bit" and "stop bit" of the serial data</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Parity bit is not generated (transmitting data) or checked (receiving data) during transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>OPE</name>
              <description>Odd Parity Enable Control\nNote: This bit has effect only when PBDIS bit is '0'.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Even number of logic 1's are transmitted or check the data word and parity bits in receiving mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Odd number of logic 1's are transmitted or check the data word and parity bits in receiving mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_TDRA</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_TDRA</displayName>
          <description>SC Timer Current Data Register A.</description>
          <addressOffset>0x38</addressOffset>
          <access>read-only</access>
          <resetValue>0x000007FF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TDR0</name>
              <description>Timer0 Current Data Value (Read Only)\nThis field indicates the current count values of Timer0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_TDRB</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_TDRB</displayName>
          <description>SC Timer Current Data Register B.</description>
          <addressOffset>0x3C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00007F7F</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TDR1</name>
              <description>Timer1 Current Data Value (Read Only)\nThis field indicates the current count values of Timer1.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TDR2</name>
              <description>Timer2 Current Data Value (Read Only)\nThis field indicates the current count values of Timer2.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SC1</name>
      <description>SC Register Map</description>
      <groupName>SC</groupName>
      <baseAddress>0x401B0000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x40</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>SC_RBR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_RBR</displayName>
          <description>SC Receiving Buffer Register.</description>
          <addressOffset>0x0</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>RBR</name>
              <description>Receiving Buffer \nBy reading RBR, the SC will return an 8-bit received data.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_THR</name>
          <alternateRegister>SC_RBR</alternateRegister>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_THR</displayName>
          <description>SC Transmit Holding Register.</description>
          <addressOffset>0x0</addressOffset>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>THR</name>
              <description>Transmit Holding Buffer\nBy writing data to THR, the SC will send out an 8-bit data.\nNote: If SC_CEN (SC_CTL[0]) is not enabled, THR cannot be programmed.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_CTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_CTL</displayName>
          <description>SC Control Register.</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SC_CEN</name>
              <description>SC Engine Enable Control\nSet this bit to 1 to enable SC operation. If this bit is cleared, SC will force all transition to IDLE state</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIS_RX</name>
              <description>RX Transition Disable Control\nNote: If AUTO_CON_EN (SC_CTL[3]) is enabled, these fields must be ignored.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The receiver Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The receiver Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DIS_TX</name>
              <description>TX Transition Disable Control\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The transceiver Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The transceiver Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTO_CON_EN</name>
              <description>Auto Convention Enable Control\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Auto-convention Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-convention Enabled. When hardware receives TS in answer to reset state and the TS is direct convention, CON_SEL (SC_CTL[5:4]) will be set to 00 automatically, otherwise if the TS is inverse convention, and CON_SEL (SC_CTL[5:4]) will be set to 11</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CON_SEL</name>
              <description>Convention Selection\nNote: If AUTO_CON_EN (SC_CTL[3]) enabled, this fields are ignored.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Direct convention</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Reserved</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Inverse convention</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_FTRI_LEV</name>
              <description>Rx Buffer Trigger Level \nWhen the number of bytes in the receiving buffer equals the RX_FTRI_LEV, the RDA_IF will be set (if RDA_IEN (IER[0]) is enabled, an interrupt will be generated).\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>INTR_RDA Trigger Level with 01 byte</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>INTR_RDA Trigger Level with 02 bytes</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>INTR_RDA Trigger Level with 03 bytes</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BGT</name>
              <description>Block Guard Time (BGT)\n\nIn RX mode, software can enable RX_BGT_EN (SC_ALTCTL[12]) to detect the first coming character timing. If the incoming data timing less than BGT, an interrupt will be generated.\nNote: The real block guard time is BGT + 1.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR_SEL</name>
              <description>Timer Selection \n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>All internal timer function Disabled</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Internal 24-bit timer Enabled. Software can configure it by setting SC_TMR0[23:0]. SC_TMR1 and SC_TMR2 will be ignored in this mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>internal 24-bit timer and 8-bit internal timer Enabled. Software can configure the 24-bit timer by setting SC_TMR0[23:0] and configure the 8-bit timer by setting SC_TMR1[7:0]. SC_TMR2 will be ignored in this mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Internal 24-bit timer and two 8-bit timers Enabled. Software can configure them by setting SC_TMR0[23:0], SC_TMR1[7:0] and SC_TMR2[7:0]</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLEN</name>
              <description>Stop Bit Length\nThis field indicates the length of stop bit.\nNote: The default stop bit length is 2. SMC and UART adopts SLEN to program the stop bit length</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The stop bit length is 2 ETU</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The stop bit length is 1 ETU</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_ERETRY</name>
              <description>RX Error Retry Count Number\nThis field indicates the maximum number of receiver retries that are allowed when parity error has occurred\nNote1: The real retry number is RX_ERETRY + 1, so 8 is the maximum retry number.\nNote2: This field cannot be changed when RX_ERETRY_EN enabled. The change flow is to disable RX_ETRTRY_EN first and then fill in new retry value.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_ERETRY_EN</name>
              <description>RX Error Retry Enable Control\n</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX error retry function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX error retry function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_ERETRY</name>
              <description>TX Error Retry Count Number\nThis field indicates the maximum number of transmitter retries that are allowed when parity error has occurred.\nNote1: The real retry number is TX_ERETRY + 1, so 8 is the maximum retry number.\nNote2: This field cannot be changed when TX_ERETRY_EN enabled. The change flow is to disable TX_ETRTRY_EN first and then fill in new retry value.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_ERETRY_EN</name>
              <description>TX Error Retry Enable Control\nThis bit enables transmitter retry function when parity error has occurred.\n</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX error retry function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX error retry function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CD_DEB_SEL</name>
              <description>Card Detect De-Bounce Selection\nThis field indicates the card detect de-bounce selection.\n</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>De-bounce sample card insert once per 384 (128 * 3) engine clocks and de-bounce sample card removal once per 128 engine clocks</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>De-bounce sample card insert once per 192 (64 * 3) engine clocks and de-bounce sample card removal once per 64 engine clocks</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>De-bounce sample card insert once per 96 (32 * 3) engine clocks and de-bounce sample card removal once per 32 engine clocks</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>De-bounce sample card insert once per 48 (16 * 3) engine clocks and de-bounce sample card removal once per 16 engine clocks</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_ALTCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_ALTCTL</displayName>
          <description>SC Alternate Control Register.</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX_RST</name>
              <description>TX Software Reset\nWhen TX_RST (SC_ALTCTL[0]) is set, all the bytes in the transmit buffer and TX internal state machine will be cleared.\nNote: This bit will be auto cleared after reset is complete.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the TX internal state machine and pointers</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_RST</name>
              <description>Rx Software Reset\nWhen RX_RST (SC_ALTCTL[1]) is set, all the bytes in the receiver buffer and Rx internal state machine will be cleared.\nNote: This bit will be auto cleared after reset is complete.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the Rx internal state machine and pointers</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DACT_EN</name>
              <description>Deactivation Sequence Generator Enable Control\nThis bit enables SC controller to initiate the card by deactivation sequence\nNote1: When the deactivation sequence completed, this bit will be cleared automatically and the INIT_IS(SC_ISR[8]) will be set to 1.\nNote2: This field will be cleared by TX_RST (SC_ALTCTL[0]) and RX_RST (SC_ALTCTL[1]). So don't fill these two bits TX_RST (SC_ALTCTL[0]) and RX_RST (SC_ALTCTL[1]) at the same time.\nNote3: If SC_CEN (SC_CTL[0]) is not enabled, this filed cannot be programmed.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Deactivation sequence generator Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ACT_EN</name>
              <description>Activation Sequence Generator Enable Control\nThis bit enables SC controller to initiate the card by activation sequence\nNote1: When the activation sequence completed, this bit will be cleared automatically and the INIT_IS (SC_ISR[8]) will be set to 1.\nNote2: This field will be cleared by TX_RST (SC_ALTCTL[0]) and RX_RST (SC_ALTCTL[1]). So don't fill these two bits TX_RST (SC_ALTCTL[0]) and RX_RST (SC_ALTCTL[1]) at the same time.\nNote3: If SC_CEN (SC_CTL[0]) is not enabled, this filed cannot be programmed.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Activation sequence generator Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WARST_EN</name>
              <description>Warm Reset Sequence Generator Enable Control\nThis bit enables SC controller to initiate the card by warm reset sequence\nNote1: When the warm reset sequence completed, this bit will be cleared automatically and the INIT_IS (SC_ISR[8]) will be set to 1.\nNote2: This field will be cleared by TX_RST (SC_ALTCTL[0]) and RX_RST (SC_ALTCTL[1]). So don't fill these two bits TX_RST (SC_ALTCTL[0]) and RX_RST (SC_ALTCTL[1]) at the same time.\nNote3: If SC_CEN (SC_CTL[0]) is not enabled, this filed cannot be programmed</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Warm reset sequence generator Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR0_SEN</name>
              <description>Internal Timer0 Start Enable Control\nThis bit enables Timer 0 to start counting. Software can fill 0 to stop it and set 1 to reload and count.\nNote3: This field will be cleared by TX_RST (SC_ALTCTL[0]) and RX_RST (SC_ALTCTL[1]). So don't fill these two bits TX_RST (SC_ALTCTL[0]) and RX_RST (SC_ALTCTL[1]) at the same time.\nNote4: If SC_CEN (SC_CTL[0]) is not enabled, this filed cannot be programmed.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Stop counting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Start counting</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR1_SEN</name>
              <description>Internal Timer1 Start Enable Control\nThis bit enables Timer 1 to start counting. Software can fill 0 to stop it and set 1 to reload and count.\nNote3: This field will be cleared by TX_RST (SC_ALTCTL[0]) and RX_RST (SC_ALTCTL[1]). So don't fill these two bits TX_RST (SC_ALTCTL[0]) and RX_RST (SC_ALTCTL[1]) at the same time.\nNote4: If SC_CEN (SC_CTL[0]) is not enabled, this filed cannot be programmed.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Stop counting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Start counting</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR2_SEN</name>
              <description>Internal Timer2 Start Enable Control\nThis bit enables Timer 2 to start counting. Software can fill 0 to stop it and set 1 to reload and count.\nNote3: This field will be cleared by TX_RST (SC_ALTCTL[0]) and RX_RST (SC_ALTCTL[1]). So don't fill these two bits TX_RST (SC_ALTCTL[0]) and RX_RST (SC_ALTCTL[1]) at the same time.\nNote4: If SC_CEN (SC_CTL[0]) is not enabled, this filed cannot be programmed.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Stop counting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Start counting</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INIT_SEL</name>
              <description>Initial Timing Selection\nThis fields indicates the timing of hardware initial state (activation or warm-reset or deactivation).\nUnit: SC clock\nActivation: Refer to SC Activation Sequence in 5.14.4.1.\nWarm-reset: refer to Warm-Reset Sequence in 5.14.4.1\nDeactivation: refer to Deactivation Sequence in 5.14.4.1</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_BGT_EN</name>
              <description>Receiver Block Guard Time Function Enable Control\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receiver block guard time function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receiver block guard time function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR0_ATV</name>
              <description>Internal Timer0 Active State (Read Only)\nThis bit indicates the timer counter status of timer0.\n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer0 is not active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer0 is active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TMR1_ATV</name>
              <description>Internal Timer1 Active State (Read Only)\nThis bit indicates the timer counter status of timer1.\n</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer1 is not active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer1 is active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TMR2_ATV</name>
              <description>Internal Timer2 Active State (Read Only)\nThis bit indicates the timer counter status of timer2.\n</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer2 is not active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer2 is active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>OUTSEL</name>
              <description>Smartcard Data Pin Output Mode Selection\nUse this bit to select smartcard data pin output mode\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Quasi mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Open-drain mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_EGTR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_EGTR</displayName>
          <description>SC Extend Guard Time Register.</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EGT</name>
              <description>Extended Guard Time\nThis field indicates the extended guard timer value.\n\nNote: The counter is ETU base and the real extended guard time is EGT.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_RFTMR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_RFTMR</displayName>
          <description>SC Receive Buffer Time-out Register.</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RFTM</name>
              <description>SC Receiver Buffer Time-Out  (ETU Base)\nNote1: The counter unit is ETU based and the interval of time-out is RFTM + 0.5\nNote2: Fill all 0 to this field indicates to disable this function.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_ETUCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_ETUCR</displayName>
          <description>SC ETU Control Register.</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000173</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ETU_RDIV</name>
              <description>ETU Rate Divider\nThe field indicates the clock rate divider.\nThe real ETU is ETU_RDIV + 1.\nNote: Software can configure this field, but this field must be greater than 0x004.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPEN_EN</name>
              <description>Compensation Mode Enable Control\nThis bit enables clock compensation function. When this bit enabled, hardware will alternate between n clock cycles and n-1 clock cycles, where n is the value to be written into the ETU_RDIV .\n</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Compensation function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Compensation function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_IER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_IER</displayName>
          <description>SC Interrupt Enable Control Register.</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDA_IE</name>
              <description>Receive Data Reach Interrupt Enable Control\nThis field is used for received data reaching trigger level RX_FTRI_LEV (SC_CTL[7:6]) interrupt enable.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receive data reach trigger level interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receive data reach trigger level interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TBE_IE</name>
              <description>Transmit Buffer Empty Interrupt Enable Control\nThis field is used for transmit buffer empty interrupt enable.\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmit buffer empty interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmit buffer empty interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TERR_IE</name>
              <description>Transfer Error Interrupt Enable Control\nThis field is used for transfer error interrupt enable. The transfer error states is at SC_SR register which includes receiver break error RX_EBR_F (SC_SR[6]), frame error RX_EFR_F (SC_SR[5]), parity error RX_EPA_F (SC_SR[4]), receiver buffer overflow error RX_OVER_F (SC_SR[0]), transmit buffer overflow error TX_OVER_F (SC_SR[8]), receiver retry over limit error RX_OVER_REERR (SC_SR[22]) and transmitter retry over limit error TX_OVER_REERR (SC_SR[30]).\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer error interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transfer error interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR0_IE</name>
              <description>Timer0 Interrupt Enable Control\nThis field is used to enable the TMR0 interrupt.\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer0 interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer0 interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR1_IE</name>
              <description>Timer1 Interrupt Enable Control\nThis field is used to enable the TMR1 interrupt.\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer1 interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer1 interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR2_IE</name>
              <description>Timer2 Interrupt Enable Control\nThis field is used for TMR2 interrupt enable.\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer2 interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer2 interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BGT_IE</name>
              <description>Block Guard Time Interrupt Enable Control\nThis field is used for block guard time interrupt enable.\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Block guard time Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Block guard time Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CD_IE</name>
              <description>Card Detect Interrupt Enable Control\nThis field is used for card detect interrupt enable. The card detect status is CD_INS_F (SC_SR[12]) \n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Card detect interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Card detect interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INIT_IE</name>
              <description>Initial End Interrupt Enable Control\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Initial end interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Initial end interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RTMR_IE</name>
              <description>Receiver Buffer Time-Out Interrupt Enable Control \nThis field is used for receiver buffer time-out interrupt enable.\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receiver buffer time-out interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receiver buffer time-out interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ACON_ERR_IE</name>
              <description>Auto Convention Error Interrupt Enable Control \nThis field is used for auto-convention error interrupt enable.\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Auto-convention error interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-convention error interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_ISR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_ISR</displayName>
          <description>SC Interrupt Status Register.</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000002</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDA_IS</name>
              <description>Receive Data Reach Interrupt Status Flag (Read Only)\nThis field is used for received data reaching trigger level RX_FTRI_LEV (SC_CTL[7:6]) interrupt status flag.\nNote: This field is the status flag of received data reaching RX_FTRI_LEV (SC_CTL[7:6]). If software reads data from SC_RBR and receiver buffer data byte number is less than RX_FTRI_LEV (SC_CTL[7:6]), this bit will be cleared automatically.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TBE_IS</name>
              <description>Transmit Buffer Empty Interrupt Status Flag (Read Only)\nThis field is used for transmit buffer empty interrupt status flag.\nNote: This field is the status flag of transmit buffer empty state. If software wants to clear this bit, software must write data to SC_THR buffer and then this bit will be cleared automatically.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TERR_IS</name>
              <description>Transfer Error Interrupt Status Flag (Read Only)\nThis field is used for transfer error interrupt status flag. The transfer error states is at  SC_SR register which includes receiver break error RX_EBR_F (SC_SR[6]), frame error RX_EFR_F (SC_SR[5]), parity error RX_EPA_F (SC_SR[4]) and receiver buffer overflow error RX_OVER_F (SC_SR[0]), transmit buffer overflow error TX_OVER_F (SC_SR[8]), receiver retry over limit error RX_OVER_REERR (SC_SR[22]) and transmitter retry over limit error TX_OVER_REERR (SC_SC[30]).\nNote: This field is the status flag of RX_EBR_F(SC_SR[6]), RX_EFR_F (SC_SR[5]), RX_EPA_F (SC_SR[4]), RX_OVER_F (SC_SR[0]), TX_OVER_F (SC_SR[8]), RX_OVER_REERR (SC_SR[22] or TX_OVER_REERR (SC_SC[30]). So, if software wants to clear this bit, software must write 1 to each field.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TMR0_IS</name>
              <description>Timer0 Interrupt Status Flag (Read Only)\nThis field is used for TMR0 interrupt status flag.\nNote: This bit is read only, but it can be cleared by writing 1 to it.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TMR1_IS</name>
              <description>Timer1 Interrupt Status Flag (Read Only)\nThis field is used for TMR1 interrupt status flag.\nNote: This bit is read only, but it can be cleared by writing 1 to it.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TMR2_IS</name>
              <description>Timer2 Interrupt Status Flag (Read Only)\nThis field is used for TMR2 interrupt status flag.\nNote: This bit is read only, but it can be cleared by writing 1 to it.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BGT_IS</name>
              <description>\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CD_IS</name>
              <description>Card Detect Interrupt Status Flag (Read Only)\nThis field is used for card detect interrupt status flag. The card detect status  is CD_INS_F (SC_SR[12]) and CD_REM_F (SC_SR[11]).\nNote: This field is the status flag of CD_INS_F (SC_SR[12]), CD_INS_F (SC_PINCSR[3]) or CD_REM_F (SC_SR[11]). So if software wants to clear this bit, software must write 1 to this field.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>INIT_IS</name>
              <description>Initial End Interrupt Status Flag (Read Only)\nThis field is used for activation (ACT_EN (SC_ALTCTL[3])), deactivation (DACT_EN (SC_ALTCTL[2])) and warm reset (WARST_EN (SC_ALTCTL[4])) sequence interrupt status flag.\nNote: This bit is read only, but it can be cleared by writing 1 to it.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RTMR_IS</name>
              <description>Receiver Buffer Time-Out Interrupt Status Flag (Read Only)\nThis field is used for receiver buffer time-out interrupt status flag.\nNote: This field is the status flag of receiver buffer time-out state. If software wants to clear this bit, software must read all receiver buffer remaining data by reading SC_RBR buffer,</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ACON_ERR_IS</name>
              <description>Auto Convention Error Interrupt Status Flag (Read Only)\nThis field indicates auto convention sequence error. If the received TS at ATR state is neither 0x3B nor 0x3F, this bit will be set.\nNote: This bit is read only, but it can be cleared by writing 1 to it.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_TRSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_TRSR</displayName>
          <description>SC Status Register.</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000202</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX_OVER_F</name>
              <description>RX Overflow Error Status Flag (Read Only) \nThis bit is set when RX buffer overflow.\nIf the number of received bytes is greater than Rx Buffer size (4 bytes), this bit will be set.\nNote: This bit is read only, but it can be cleared by writing 1 to it.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_EMPTY_F</name>
              <description>Receiver Buffer Empty Status Flag (Read Only)\nThis bit indicates RX buffer empty or not.\nWhen the last byte of Rx buffer has been read by CPU, hardware sets this bit high. It will be cleared when SC receives any new data.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_FULL_F</name>
              <description>Receiver Buffer Full Status Flag (Read Only)\nThis bit indicates RX buffer full or not.\nThis bit is set when RX pointer is equal to 4, otherwise it is cleared by hardware.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_EPA_F</name>
              <description>Receiver Parity Error Status Flag (Read Only)\nThis bit is set to logic 1 whenever the received character does not have a valid "parity bit".\nNote1: This bit is read only, but it can be cleared by writing 1 to it.\nNote2: If CPU sets receiver retries function by setting RX_ERETRY_EN (SC_CTL[19]) , hardware will not set this flag.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_EFR_F</name>
              <description>Receiver Frame Error Status Flag (Read Only)\nThis bit is set to logic 1 whenever the received character does not have a valid "stop bit" (that is, the stop bit following the last data bit or parity bit is detected as a logic 0). \nNote1: This bit is read only, but it can be cleared by writing 1 to it.\nNote2: If CPU sets receiver retries function by setting RX_ERETRY_EN (SC_CTL[19]) , hardware will not set this flag.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_EBR_F</name>
              <description>Receiver Break Error Status Flag (Read Only)\nThis bit is set to logic 1 whenever the received data input (RX) held in the "spacing state" (logic 0) is longer than a full word transmission time (that is, the total time of "start bit" + data bits + parity + stop bits). .\nNote1: This bit is read only, but it can be cleared by writing 1 to it.\nNote2: If CPU sets receiver retries function by setting RX_ERETRY_EN (SC_CTL[19]) , hardware will not set this flag.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_OVER_F</name>
              <description>TX Overflow Error Interrupt Status Flag (Read Only)\nIf TX buffer is full, an additional write to SC_THR will cause this bit be set to "1" by hardware. \nNote: This bit is read only, but it can be cleared by writing 1 to it.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_EMPTY_F</name>
              <description>Transmit Buffer Empty Status Flag (Read Only)\nThis bit indicates TX buffer empty or not.\nWhen the last byte of TX buffer has been transferred to Transmitter Shift Register, hardware sets this bit high. It will be cleared when writing data into SC_THR (TX buffer not empty).</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_FULL_F</name>
              <description>Transmit Buffer Full Status Flag (Read Only)\nThis bit indicates TX buffer full or not.This bit is set when TX pointer is equal to 4, otherwise is cleared by hardware.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CD_REM_F</name>
              <description>Card Detect Removal Status Of SC_CD Pin (Read Only)\nThis bit is set whenever card has been removal.\nNote1: This bit is read only, but it can be cleared by writing "1" to it.\nNote2: Card detect engine will start after SC_CEN (SC_CTL[0]) set.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Card removed</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>CD_INS_F</name>
              <description>Card Detect Insert Status Of SC_CD Pin (Read Only)\nThis bit is set whenever card has been inserted.\nNote1: This bit is read only, but it can be cleared by writing "1" to it.\nNote2: The card detect engine will start after SC_CEN (SC_CTL[0]) set.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Card insert</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>CD_PIN_F</name>
              <description>Card Detect Status Of SC_CD Pin Status (Read Only)\nThis bit is the pin status flag of SC_CD\n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The SC_CD pin state at low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The SC_CD pin state at high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_POINT_F</name>
              <description>Receiver Buffer Pointer Status Flag (Read Only)\nThis field indicates the RX buffer pointer status flag. When SC receives one byte from external device, RX_POINT_F (SC_SR[17:16]) increases one. When one byte of RX buffer is read by CPU, RX_POINT_F (SC_SR[17:16]) decreases one.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_REERR</name>
              <description>Receiver Retry Error (Read Only)\nThis bit is set by hardware when RX has any error and retries transfer.\nNote1: This bit is read only, but it can be cleared by writing 1 to it.\nNote2 This bit is a flag and cannot generate any interrupt to CPU.\nNote3: If CPU enables receiver retry function by setting RX_ERETRY_EN (SC_CTL[19]) , the RX_EPA_F (SC_SR[4]) flag will be ignored (hardware will not set RX_EPA_F (SC_SR[4])).</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_OVER_REERR</name>
              <description>Receiver Over Retry Error (Read Only)\nThis bit is set by hardware when RX transfer error retry over retry number limit.\nNote1: This bit is read only, but it can be cleared by writing 1 to it.\nNote2: If CPU enables receiver retries function by setting RX_ERETRY_EN (SC_CTL[19]), the RX_EPA_F (SC_SR[4]) flag will be ignored (hardware will not set RX_EPA_F (SC_SR[4])).</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_ATV</name>
              <description>Receiver In Active Status Flag (Read Only)\nThis bit is set by hardware when RX transfer is in active.\nThis bit is cleared automatically when RX transfer is finished.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_POINT_F</name>
              <description>Transmit Buffer Pointer Status Flag (Read Only)\nThis field indicates the TX buffer pointer status flag. When CPU writes data into SC_THR, TX_POINT_F increases one. When one byte of TX Buffer is transferred to transmitter shift register, TX_POINT_F decreases one.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_REERR</name>
              <description>Transmitter Retry Error (Read Only)\nThis bit is set by hardware when transmitter re-transmits.\nNote1: This bit is read only, but it can be cleared by writing 1 to it.\nNote2 This bit is a flag and cannot generate any interrupt to CPU.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_OVER_REERR</name>
              <description>Transmitter Over Retry Error (Read Only)\nThis bit is set by hardware when transmitter re-transmits over retry number limitation.\nNote: This bit is read only, but it can be cleared by writing 1 to it.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_ATV</name>
              <description>Transmit In Active Status Flag (Read Only)\n</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>This bit is cleared automatically when TX transfer is finished or the last byte transmission has completed</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>This bit is set by hardware when TX transfer is in active and the STOP bit of the last byte has been transmitted</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_PINCSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_PINCSR</displayName>
          <description>SC Pin Control State Register.</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFF0F</resetMask>
          <fields>
            <field>
              <name>POW_EN</name>
              <description>SC_POW_EN Pin Signal\nSoftware can set POW_EN and POW_INV to decide SC_PWR pin is in high or low level.\nWrite this field to drive SC_PWR pin\nRefer POW_INV description for programming SC_PWR pin voltage level. \nRead this field to get SC_PWR pin status.\nNote: When operating at activation, warm reset or deactivation mode, this bit will be changed automatically. So don't fill this field when operating in these modes.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SC_PWR pin status is low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SC_PWR pin status is high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SC_RST</name>
              <description>SC_RST Pin Signal\nThis bit is the pin status of SC_RST but user can drive SC_RST pin to high or low by setting this bit.\nWrite this field to drive SC_RST pin.\nNote: When operating at activation, warm reset or deactivation mode, this bit will be changed automatically. So don't fill this field when operating in these modes.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Drive SC_RST pin to low.\nSC_RST pin status is low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Drive SC_RST pin to high.\nSC_RST pin status is high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CD_REM_F</name>
              <description>Card Detect Removal Status Of SC_CD Pin (Read Only)\nThis bit is set whenever card has been removal.\nNote1: This bit is read only, but it can be cleared by writing "1" to it.\nNote2: Card detect engine will start after SC_CEN (SC_CTL[0]) set.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Card Removal</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>CD_INS_F</name>
              <description>Card Detect Insert Status Of SC_CD Pin (Read Only)\nThis bit is set whenever card has been inserted.\nNote1: This bit is read only, but it can be cleared by writing "1" to it.\nNote2: Card detect engine will start after SC_CEN (SC_CTL[0]) set.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Card insert</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>CD_PIN_ST</name>
              <description>Card Detect Status Of SC_CD Pin Status (Read Only)\nThis bit is the pin status flag of SC_CD\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SC_CD pin state at low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SC_CD pin state at high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>CLK_KEEP</name>
              <description>SC Clock Enable Control \nNote: When operating in activation, warm reset or deactivation mode, this bit will be changed automatically. So don't fill this field when operating in these modes.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SC clock generation Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SC clock always keeps free running</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADAC_CD_EN</name>
              <description>Auto Deactivation When Card Removal\nNote: When the card is removal, hardware will stop any process and then do deactivation sequence (if this bit be setting). If this process completes. Hardware will generate an interrupt INT_INIT to CPU.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Auto deactivation Disabled when hardware detected the card is removal</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto deactivation Enabled when hardware detected the card is removal</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SC_OEN_ST</name>
              <description>SC Data Output Enable Pin Status (Read Only)\nThis bit is the pin status of SC_DATA_OEN\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The SC_DATA_OEN pin state at low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The SC_DATA_OEN pin state at high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>SC_DATA_O</name>
              <description>SC Data Output Pin \nThis bit is the pin status of SC_DATA_O but user can drive SC_DATA_O pin to high or low by setting this bit.\nNote: When SC is at activation, warm reset or deactivation mode, this bit will be changed automatically. So don't fill this field when SC is in these modes.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Drive SC_DATA_O pin to low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Drive SC_DATA_O pin to high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CD_LEV</name>
              <description>Card Detect Level\n\nNote: Software must select card detect level before Smart Card engine enable</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>When hardware detects the card detect pin from high to low, it indicates a card is detected</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When hardware detects the card detect pin from low to high, it indicates a card is detected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SC_DATA_I_ST</name>
              <description>SC Data Input Pin Status (Read Only)\nThis bit is the pin status of SC_DATA_I\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The SC_DATA_I pin is low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The SC_DATA_I pin is high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_TMR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_TMR0</displayName>
          <description>SC Internal Timer Control Register 0.</description>
          <addressOffset>0x28</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNT</name>
              <description>Timer 0 Counter Value  (ETU Base)\nThis field indicates the internal timer operation values.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>Timer 0 Operation Mode Selection\nThis field indicates the internal 24-bit timer operation selection.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_TMR1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_TMR1</displayName>
          <description>SC Internal Timer Control Register 1.</description>
          <addressOffset>0x2C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNT</name>
              <description>Timer 1 Counter Value  (ETU Base)\nThis field indicates the internal timer operation values.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>Timer 1 Operation Mode Selection\nThis field indicates the internal 8-bit timer operation selection.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_TMR2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_TMR2</displayName>
          <description>SC Internal Timer Control Register 2.</description>
          <addressOffset>0x30</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNT</name>
              <description>Timer 2 Counter Value  (ETU Base)\nThis field indicates the internal timer operation values.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>Timer 2 Operation Mode Selection\nThis field indicates the internal 8-bit timer operation selection</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_UACTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_UACTL</displayName>
          <description>SC UART Mode Control Register.</description>
          <addressOffset>0x34</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>UA_MODE_EN</name>
              <description>UART Mode Enable Control\nNote3: When UART is enabled, hardware will generate a reset to reset FIFO and internal state machine.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Smart Card mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_LEN</name>
              <description>Data Length\nNote: In smart card mode, this DATA_LEN must be '00'</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Character Data Length is 8 bits</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Character Data Length is 7 bits</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Character Data length is 6 bits</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Character Data Length is 5 bits</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PBDIS</name>
              <description>Parity Bit Disable Control\nNote: In smart card mode, this field must be '0' (default setting is with parity bit)</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Parity bit is generated or checked between the "last data word bit" and "stop bit" of the serial data</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Parity bit is not generated (transmitting data) or checked (receiving data) during transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>OPE</name>
              <description>Odd Parity Enable Control\nNote: This bit has effect only when PBDIS bit is '0'.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Even number of logic 1's are transmitted or check the data word and parity bits in receiving mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Odd number of logic 1's are transmitted or check the data word and parity bits in receiving mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_TDRA</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_TDRA</displayName>
          <description>SC Timer Current Data Register A.</description>
          <addressOffset>0x38</addressOffset>
          <access>read-only</access>
          <resetValue>0x000007FF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TDR0</name>
              <description>Timer0 Current Data Value (Read Only)\nThis field indicates the current count values of Timer0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_TDRB</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_TDRB</displayName>
          <description>SC Timer Current Data Register B.</description>
          <addressOffset>0x3C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00007F7F</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TDR1</name>
              <description>Timer1 Current Data Value (Read Only)\nThis field indicates the current count values of Timer1.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TDR2</name>
              <description>Timer2 Current Data Value (Read Only)\nThis field indicates the current count values of Timer2.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>I2C0</name>
      <description>I2C Register Map</description>
      <groupName>I2C</groupName>
      <baseAddress>0x40020000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x20</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x28</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>I2CON</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CON</displayName>
          <description>I2C Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IPEN</name>
              <description>I2C Function Enable Control\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I2C function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2C function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ACK</name>
              <description>Assert Acknowledge Control Bit\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>When this bit is set to 0 prior to address or data received, a Not acknowledged (high level to SDA) will be returned during the acknowledge clock pulse</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When this bit is set to 1 prior to address or data received, an acknowledged will be returned during the acknowledge clock pulse on the SCL line when (a). A slave is acknowledging the address sent from master. (b). The receiver devices are acknowledging the data sent by transmitter</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>STOP</name>
              <description>I2C STOP Control Bit \nIn Master mode, set this bit to 1 to transmit a STOP condition to bus then the controller will check the bus condition if a STOP condition is detected and this bit will be cleared by hardware automatically.\nIn Slave mode, set this bit to 1 to reset the controller to the defined "not addressed" Slave mode. This means it is NO LONGER in the slave receiver mode to receive data from the master transmit device.\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Will be cleared by hardware automatically if a STOP condition is detected</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Sends a STOP condition to bus in Master mode or reset the controller to "not addressed" in Slave mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>START</name>
              <description>I2C START Command\nSetting this bit to 1 to enter Master mode, the device sends a START or repeat START condition to bus when the bus is free and it will be cleared to 0 after the START command is active and the STATUS has been updated.\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>After START or repeat START is active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Sends a START or repeat START condition to bus</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STS</name>
              <description>I2C Status\nWhen a new state is present in the I2CSTATUS register, if the INTEN bit is set, the I2C interrupt is requested. It must write one by software to this bit after the I2CINTSTS[0] is set to 1 and the I2C protocol function will go ahead until the STOP is active or the IPEN is disabled.\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I2C's Status disabled and the I2C protocol function will go ahead</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2C's Status active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INTEN</name>
              <description>Interrupt Enable Control\n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I2C interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2C interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2CINTSTS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CINTSTS</displayName>
          <description>I2C Interrupt Status Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INTSTS</name>
              <description>I2C STATUS's Interrupt Status\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No bus event occurred</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>New state is presented in the I2CSTATUS. Software can write 1 to cleat this bit</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TIF</name>
              <description>Time-Out Status\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Time-out flag. Software can cleat this flag</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time-Out flag active and it is set by hardware. It can interrupt CPU when INTEN bit is set</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2CSTATUS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CSTATUS</displayName>
          <description>I2C Status Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-only</access>
          <resetValue>0x000000F8</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>STATUS</name>
              <description>I2C Status Bits (Read Only)\nIndicates the current status code of the bus information. The detail information about the status is described in the sections of I2C protocol register and operation mode.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2CDIV</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CDIV</displayName>
          <description>I2C Clock Divided Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLK_DIV</name>
              <description>I2C Clock Divided Bits\nNote: the minimum value of CLK_DIV is 4.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2CTOUT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CTOUT</displayName>
          <description>I2C Time Out Counter Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TOUTEN</name>
              <description>Time-Out Counter Enable/Disable Control\nWhen set this bit to enable, the 14 bits time-out counter will start counting when INTSTS (I2CINTSTS[0]) is cleared. Setting flag STAINTSTS to high or the falling edge of I2C clock or stop signal will reset counter and re-start up counting after INTSTS is cleared.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DIV4</name>
              <description>Time-Out Counter Input Clock Divider By 4 \nWhen Enabled, the time-out period is extended 4 times.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2CDATA</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CDATA</displayName>
          <description>I2C DATA Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>I2C Data Bits\nThe DATA contains a byte of serial data to be transmitted or a byte which has just been received. \nNote: Refer to Data register section for more detail information.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2CSADDR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CSADDR0</displayName>
          <description>Slave Address Register 0</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GCALL</name>
              <description>General Call Function \nNote: Refer to Address Register section for more detail information..</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>General Call Function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>General Call Function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SADDR</name>
              <description>I2C Salve Address Bits\nThe content of this register is irrelevant when the device is in Master mode. In the Slave mode, the seven most significant bits must be loaded with the device's own address. The device will react if either of the address is matched.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="I2CSADDR0">
          <name>I2CSADDR1</name>
          <displayName>I2CSADDR1</displayName>
          <description>Slave Address Register 1</description>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register>
          <name>I2CSAMASK0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CSAMASK0</displayName>
          <description>Slave Address Mask Register 0</description>
          <addressOffset>0x28</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SAMASK</name>
              <description>I2C Slave Address Mask Bits\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>7</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Mask disable (the received corresponding register bit should be exact the same as address register)</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Mask enable (the received corresponding address bit is don't care).</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="I2CSAMASK0">
          <name>I2CSAMASK1</name>
          <displayName>I2CSAMASK1</displayName>
          <description>Slave Address Mask Register 1</description>
          <addressOffset>0x2C</addressOffset>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>I2C1</name>
      <description>I2C Register Map</description>
      <groupName>I2C</groupName>
      <baseAddress>0x40120000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x20</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x28</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>I2CON</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CON</displayName>
          <description>I2C Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IPEN</name>
              <description>I2C Function Enable Control\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I2C function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2C function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ACK</name>
              <description>Assert Acknowledge Control Bit\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>When this bit is set to 0 prior to address or data received, a Not acknowledged (high level to SDA) will be returned during the acknowledge clock pulse</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When this bit is set to 1 prior to address or data received, an acknowledged will be returned during the acknowledge clock pulse on the SCL line when (a). A slave is acknowledging the address sent from master. (b). The receiver devices are acknowledging the data sent by transmitter</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>STOP</name>
              <description>I2C STOP Control Bit \nIn Master mode, set this bit to 1 to transmit a STOP condition to bus then the controller will check the bus condition if a STOP condition is detected and this bit will be cleared by hardware automatically.\nIn Slave mode, set this bit to 1 to reset the controller to the defined "not addressed" Slave mode. This means it is NO LONGER in the slave receiver mode to receive data from the master transmit device.\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Will be cleared by hardware automatically if a STOP condition is detected</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Sends a STOP condition to bus in Master mode or reset the controller to "not addressed" in Slave mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>START</name>
              <description>I2C START Command\nSetting this bit to 1 to enter Master mode, the device sends a START or repeat START condition to bus when the bus is free and it will be cleared to 0 after the START command is active and the STATUS has been updated.\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>After START or repeat START is active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Sends a START or repeat START condition to bus</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STS</name>
              <description>I2C Status\nWhen a new state is present in the I2CSTATUS register, if the INTEN bit is set, the I2C interrupt is requested. It must write one by software to this bit after the I2CINTSTS[0] is set to 1 and the I2C protocol function will go ahead until the STOP is active or the IPEN is disabled.\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I2C's Status disabled and the I2C protocol function will go ahead</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2C's Status active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INTEN</name>
              <description>Interrupt Enable Control\n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I2C interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2C interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2CINTSTS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CINTSTS</displayName>
          <description>I2C Interrupt Status Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INTSTS</name>
              <description>I2C STATUS's Interrupt Status\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No bus event occurred</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>New state is presented in the I2CSTATUS. Software can write 1 to cleat this bit</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TIF</name>
              <description>Time-Out Status\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Time-out flag. Software can cleat this flag</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time-Out flag active and it is set by hardware. It can interrupt CPU when INTEN bit is set</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2CSTATUS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CSTATUS</displayName>
          <description>I2C Status Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-only</access>
          <resetValue>0x000000F8</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>STATUS</name>
              <description>I2C Status Bits (Read Only)\nIndicates the current status code of the bus information. The detail information about the status is described in the sections of I2C protocol register and operation mode.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2CDIV</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CDIV</displayName>
          <description>I2C Clock Divided Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLK_DIV</name>
              <description>I2C Clock Divided Bits\nNote: the minimum value of CLK_DIV is 4.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2CTOUT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CTOUT</displayName>
          <description>I2C Time Out Counter Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TOUTEN</name>
              <description>Time-Out Counter Enable/Disable Control\nWhen set this bit to enable, the 14 bits time-out counter will start counting when INTSTS (I2CINTSTS[0]) is cleared. Setting flag STAINTSTS to high or the falling edge of I2C clock or stop signal will reset counter and re-start up counting after INTSTS is cleared.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DIV4</name>
              <description>Time-Out Counter Input Clock Divider By 4 \nWhen Enabled, the time-out period is extended 4 times.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2CDATA</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CDATA</displayName>
          <description>I2C DATA Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>I2C Data Bits\nThe DATA contains a byte of serial data to be transmitted or a byte which has just been received. \nNote: Refer to Data register section for more detail information.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2CSADDR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CSADDR0</displayName>
          <description>Slave Address Register 0</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GCALL</name>
              <description>General Call Function \nNote: Refer to Address Register section for more detail information..</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>General Call Function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>General Call Function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SADDR</name>
              <description>I2C Salve Address Bits\nThe content of this register is irrelevant when the device is in Master mode. In the Slave mode, the seven most significant bits must be loaded with the device's own address. The device will react if either of the address is matched.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="I2CSADDR0">
          <name>I2CSADDR1</name>
          <displayName>I2CSADDR1</displayName>
          <description>Slave Address Register 1</description>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register>
          <name>I2CSAMASK0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CSAMASK0</displayName>
          <description>Slave Address Mask Register 0</description>
          <addressOffset>0x28</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SAMASK</name>
              <description>I2C Slave Address Mask Bits\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>7</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Mask disable (the received corresponding register bit should be exact the same as address register)</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Mask enable (the received corresponding address bit is don't care)</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="I2CSAMASK0">
          <name>I2CSAMASK1</name>
          <displayName>I2CSAMASK1</displayName>
          <description>Slave Address Mask Register 1</description>
          <addressOffset>0x2C</addressOffset>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SPI0</name>
      <description>SPI Register Map</description>
      <groupName>SPI</groupName>
      <baseAddress>0x40030000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x18</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x20</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x34</offset>
        <size>0xC</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>SPI_CTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_CTL</displayName>
          <description>SPI Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000004</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GO_BUSY</name>
              <description>Go And Busy Status\nDuring the data transfer, this bit keeps the value of '1'. As the transfer is finished, this bit will be cleared automatically.\nNote 1: All registers should be set before writing "1" to the GO_BUSY bit in the SPI_CTL register.\nNote 2: In FIFO mode, this bit will be controlled by hardware. Software should not modify this bit..</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Writing this bit "0" to stop data transfer if SPI is transferring</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>In Master mode, writing "1" to this bit to start the SPI data transfer; In Slave mode, writing '1' to this bit indicates that the salve is ready to communicate with a master</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_NEG</name>
              <description>Receive At Negative Edge\nNote: Refer to Edge Condition section.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The received data is latched at the rising edge of SPICLK</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The received data is latched at the falling edge of SPICLK</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_NEG</name>
              <description>Transmit At Negative Edge\nNote: Refer to Edge Condition section.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The transmitted data output is changed at the rising edge of SPICLK</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The transmitted data output is changed at the falling edge of SPICLK</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_BIT_LEN</name>
              <description>Transmit Bit Length\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_NUM</name>
              <description>Number Of Transmit/Receive Transaction\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LSB</name>
              <description>Send LSB First\nNote: Refer to LSB First section.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The MSB, which bit of transmit/receive register depends on the setting of TX_BIT_LEN, is transmitted/received first</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The LSB, bit 0 of the SPI_TX0/1, is sent first to the the SPI data output pin, and the first bit received from the SPI data input pin will be put in the LSB position of the SPI_RX register (SPI_RX0/1)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLKP</name>
              <description>Clock Polarity\nNote: Refer to Clock Parity section.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The default level of SPICLK is low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The default level of SPICLK is high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SP_CYCLE</name>
              <description>Suspend Interval (Master Only)\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INTEN</name>
              <description>Interrupt Enable\n</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPI Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLAVE</name>
              <description>Slave Mode Indication\nNote: Refer to Slave Selection section</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPI controller is set as Master mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI controller is set as Slave mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>REORDER</name>
              <description>Reorder Mode Selection\nNote: The suspend interval is defined in SP_CYCLE</description>
              <bitOffset>19</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable both byte reorder and suspend functions</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable byte reorder function and insert a byte suspend interval among each byte. The setting of TX_BIT_LEN must be configured as 00b (32 bits/ word)</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Enable byte reorder function, but disable byte suspend function</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Disable byte reorder function, but insert a suspend interval among each byte. The setting of TX_BIT_LEN must be configured as 00b (32 bits/ word)</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FIFOM</name>
              <description>FIFO Mode Enable\nNote: Refer to Dual FIFO Mode section.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>FIFO mode Disabled (in Normal mode)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>FIFO mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TWOB</name>
              <description>2 Data Channel Transfer Mode Active\nNote: When enabling TWOB, the setting of TX_NUM must be programmed as 00.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>2data channel transfer mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>2data channel transfer mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>VARCLK_EN</name>
              <description>Variable Clock Enable\nNote: Refer to Variable Serial Clock Frequency section.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The serial clock output frequency is fixed and only decided by the value of DIVIDER1</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The serial clock output frequency is variable. The output frequency is decided by the value of VARCLK (SPI_VARCLK), DIVIDER1 and DIVIDER2</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WKEUP_EN</name>
              <description>Wake-Up Enable\nNote: When the system enters the power-down mode, the system can be wake-up from the SPI controller when this bit is enabled and if there is any toggle in the SPICLK port. After the system wake-up, this bit must be clear by user to disable the wake-up requirement.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Wake-up function Disabled when the system enters the power-down mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Wake-up function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_STATUS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_STATUS</displayName>
          <description>SPI Status Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000005</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX_EMPTY</name>
              <description>Received Dual FIFO_EMPTY Status\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Received data FIFO is not empty in the dual FIFO mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Received data FIFO is empty in the dual FIFO mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_FULL</name>
              <description>Received Dual FIFO_FULL Status\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Received data FIFO is not full in dual FIFO mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Received data FIFO is full in the dual FIFO mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_EMPTY</name>
              <description>Transmitted Dual FIFO_EMPTY Status\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmitted data FIFO is not empty in the dual FIFO mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmitted data FIFO is empty in the dual FIFO mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_FULL</name>
              <description>Transmitted Dual FIFO_FULL Status\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmitted data FIFO is not full in the dual FIFO mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmitted data FIFO is full in the dual FIFO mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LTRIG_FLAG</name>
              <description>Level Trigger Flag (INTERNAL ONLY)\nIn Slave mode, this bit indicates whether the received bit number meets the requirement or not after the current transaction done.\nNote: This bit is read only</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The transferred bit length of one transaction does not meet the specified requirement</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The transferred bit length meets the specified requirement which defined in TX_BIT_LEN</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLV_START_INTSTS</name>
              <description>Slave Start Interrupt Status\nIt is used to indicate that the transfer has started in Slave mode with no slave select.\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Slave started transfer no active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transfer has started in Slave mode with no slave select. It is auto clear by transfer done or writing one clear</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INTSTS</name>
              <description>Interrupt Status\nNote: This bit is read only, but can be cleared by writing "1" to this bit.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer is not finished yet</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transfer is done. The interrupt is requested when the INTEN (SPI_CTL[17]) bit is enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_CLKDIV</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_CLKDIV</displayName>
          <description>SPI Clock Divider Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DIVIDER1</name>
              <description>Clock Divider 1 Register \nThe value is the 1th frequency divider of the PCLK to generate the serial clock of SPICLK. The desired frequency is obtained according to the following equation:\n/\n\nNote 1: The DIVIDER1 can be set as 0. If the DIVIDER1 is set as zero, the frequency of SPI_SCLK is the same as PCLK in Master mode.\nNote 2: In Slave mode, the period of SPI clock driven by a master shall equal to or over 5 times the period of PCLK. In other words, the maximum frequency of SPI clock is the fifth of the frequency of slave's PCLK.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIVIDER2</name>
              <description>Clock Divider 2 Register \nThe value is the 2nd 2nd frequency divider of the PCLK to generate the serial clock of SPICLK. The desired frequency is obtained according to the following equation:\n/</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_SSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_SSR</displayName>
          <description>SPI Slave Select Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SSR</name>
              <description>Slave Select Active Register (Master Only)\nIf AUTOSS bit (SPI_SSR[3]) is cleared, writing "1" to SSR[0] bit sets the SPISS[0] line to an active state and writing "0" sets the line back to inactive state.( the same as SSR[1] for SPISS[1])\nNote 1: This interface can only drive one device/slave at a given time. Therefore, the slave select of the selected device must be set to its active level before starting any read or write transfer.\nNote 2: SPISS[0] is also defined as device/slave select input in Slave mode. And that the slave select input must be driven by edge active trigger which level depend on the SS_LVL setting, otherwise the SPI slave core will go into dead path until the edge active triggers again or reset the SPI core by software.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Both SPISS[1] and SPISS[0] are inactive</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPISS[1] is inactive, SPISS[0] is active.\nSPISS[1] is inactive, SPISS[0] is active on the duration of transaction</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>SPISS[1] is active, SPISS[0] is inactive.\nSPISS[1] is active on the duration of transaction, SPISS[0] is inactive</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Both SPISS[1] and SPISS[0] are active.\nBoth SPISS[1] and SPISS[0] are active on the duration of transaction</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SS_LVL</name>
              <description>Slave Select Active Level\nIt defines the active level of device/slave select signals (SPISS[1:0]).\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The SPISS slave select signal is active Low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The SPISS slave select signal is active High</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTOSS</name>
              <description>Automatic Slave Selection (Master Only)\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>If this bit is set as "0", slave select signals are asserted and de-asserted by setting and clearing related bits in SSR[1:0] register</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>If this bit is set as "1", SPISS[1:0] signals are generated automatically. It means that device/slave select signal, which is set in SSR[1:0] register is asserted by the SPI controller when transmit/receive is started by setting the GO_BUSY bit, and is de-asserted after each transaction is done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SS_LTRIG</name>
              <description>Slave Select Level Trigger\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The input slave select signal is edge-trigger</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The slave select signal will be level-trigger.  It depends on SS_LVL to decide the signal is active low or active high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>NOSLVSEL</name>
              <description>No Slave Selected In Slave Mode\nThis is used to ignore the slave select signal in Slave mode. The SPI controller can work on 3 wire interface including SPICLK, SPI_MISO and SPI_MOSI when it is set as a slave device.\nNote 1: Refer to No Slave Select Mode.\nNote 2: In no slave select signal mode, the SS_LTRIG (SPI_SSR[4]) shall be set as "1".</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The controller is 4-wire bi-direction interface</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The controller is 3-wire bi-direction interface in Slave mode. When this bit is set as 1, the controller start to transmit/receive data after the GO_BUSY bit active and the serial clock input</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLV_ABORT</name>
              <description>Abort In Slave Mode With No Slave Selected\nNote 1:Refer to No Slave Select Mode.\nNote 2: It is auto clear to "0" by hardware when the abort event is active.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No force the slave abort</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Force the current transfer done in no slave select mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SSTA_INTEN</name>
              <description>Slave Start Interrupt Enable\nNote : Refer to No Slave Select Mode.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer start interrupt Disabled in no slave select mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transaction start interrupt Enabled in no slave select mode. It is cleared when the current transfer done or the SLV_START_INTSTS bit cleared (write 1 clear)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_RX0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_RX0</displayName>
          <description>SPI Receive Data FIFO Register 0</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXDATA</name>
              <description>Receive Data FIFO Register\nThe received data can be read on it. If the FIFOM bit is set as 1, the user also checks the RX_EMPTY (SPI_STATUS[0]) to check if there is any more received data or not.\nNote 1: The SPI_RX1 is used only in TWOB bit (SPI_CTL[22]) is set 1. The first channel's received data shall be read from SPI_RX0 and the second channel's received data shall be read from SPI_RX1 in two-bit mode. SPI_RX0 shall be read first in TWOB mode.\nNote 2: These two registers are read only.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="SPI_RX0">
          <name>SPI_RX1</name>
          <displayName>SPI_RX1</displayName>
          <description>SPI Receive Data FIFO Register 1</description>
          <addressOffset>0x14</addressOffset>
       </register>
       <register>
          <name>SPI_TX0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_TX0</displayName>
          <description>SPI Transmit Data FIFO Register 0</description>
          <addressOffset>0x20</addressOffset>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TDATA</name>
              <description>Transmit Data FIFO Register\nThe Data Transmit Registers hold the data to be transmitted in the next transfer. The number of valid bits depends on the setting of transmit bit length field of the SPI_CTL register.\nFor example, if TX_BIT_LEN is set to 0x8, the bit SPI_TX[7:0] will be transmitted in next transfer. If TX_BIT_LEN is set to 0x0, the SPI controller will perform a 32-bit transfer.\nNote: The SPI_TX1 is used only in TWOB bit (SPI_CTL[22]) is set 1. The first channel's transmitted data shall be written into SPI_TX0 and the second channel's transmitted data shall be written into SPI_TX1 in twodata channel mode. SPI_TX0 shall be written first in TWOB mode.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="SPI_TX0">
          <name>SPI_TX1</name>
          <displayName>SPI_TX1</displayName>
          <description>SPI Transmit Data FIFO Register 1</description>
          <addressOffset>0x24</addressOffset>
       </register>
       <register>
          <name>SPI_VARCLK</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_VARCLK</displayName>
          <description>SPI Variable Clock Pattern Flag Register</description>
          <addressOffset>0x34</addressOffset>
          <access>read-write</access>
          <resetValue>0x003FFFC3</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VARCLK</name>
              <description>Variable Clock Pattern Flag\nThe value in this field is the frequency patterns of the SPICLK.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_PDMA</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_PDMA</displayName>
          <description>SPI PDMA Control Register</description>
          <addressOffset>0x38</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX_DMA_EN</name>
              <description>Transmit PDMA Enable (PDMA Writes Data To SPI)\nNote 1: Refer to DMA section for more detail information.\nNote 2: Two transaction need minimal 18 APB clock + 8 SPI peripheral clocks suspend interval in master mode for edge mode and 18 APB clock + 9.5 SPI peripheral clocks for level mode.\nNote 3: If the 2 data channel function is enabled, the requirement timing shall append 18 APB clock based on the above clock period.\nNote 4: Hardware will clear this bit to 0 automatically after PDMA transfer done.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmit PDMA function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmit PDMA function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_DMA_EN</name>
              <description>Receiver PDMA Enable (PDMA Reads SPI Data To Memory)\nNote 1: Refer to DMA section for more detail information.\nNote 2: Hardware will clear this bit to 0 automatically after PDMA transfer done.\nNote 3: In Slave mode and the FIFO bit is disabled, if the receive PDMA is enabled but the transmit PDMA is disabled, the minimal suspend interval between two successive  transactions input is need to be larger than 9 SPI peripheral clock + 4 APB clock for edge mode and 9.5 SPI peripheral clocks + 4 APB clocks.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receiver PDMA function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receiver PDMA function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PDMA_RST</name>
              <description>PDMA Reset\nIt is used to reset the SPI PDMA function into default state. \nNote: It is auto cleared to "0" after the reset function done.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>After reset PDMA function or in normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset PDMA function</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_FFCLR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_FFCLR</displayName>
          <description>SPI FIFO Counter Clear Control Register</description>
          <addressOffset>0x3C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX_CLR</name>
              <description>Receiving FIFO Counter Clear\nNote: This bit is used to clear the receiver counter in FIFO Mode. This bit can be written "1" to clear the receiver counter and this bit will be cleared to "0" automatically after clearing receiving counter. After the clear operation, the flag of RX_EMPTY in SPI_STATUS[0] will be set to "1".</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No clear the received FIFO</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clear the received FIFO</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_CLR</name>
              <description>Transmitting FIFO Counter Clear\nNote: This bit is used to clear the transmit counter in FIFO Mode. This bit can be written "1" to clear the transmitting counter and this bit will be cleared to "0" automatically after clearing transmitting counter. After the clear operation, the flag of TX_EMPTY in SPI_STATUS[2] will be set to "1".</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No clear the transmitted FIFO</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clear the transmitted FIFO</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SPI1</name>
      <description>SPI Register Map</description>
      <groupName>SPI</groupName>
      <baseAddress>0x40130000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x18</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x20</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x34</offset>
        <size>0xC</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>SPI_CTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_CTL</displayName>
          <description>SPI Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000004</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GO_BUSY</name>
              <description>Go And Busy Status\nDuring the data transfer, this bit keeps the value of '1'. As the transfer is finished, this bit will be cleared automatically.\nNote 1: All registers should be set before writing "1" to the GO_BUSY bit in the SPI_CTL register.\nNote 2: In FIFO mode, this bit will be controlled by hardware. Software should not modify this bit..</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Writing this bit "0" to stop data transfer if SPI is transferring</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>In Master mode, writing "1" to this bit to start the SPI data transfer; In Slave mode, writing '1' to this bit indicates that the salve is ready to communicate with a master</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_NEG</name>
              <description>Receive At Negative Edge\nNote: Refer to Edge Condition section.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The received data is latched at the rising edge of SPICLK</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The received data is latched at the falling edge of SPICLK</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_NEG</name>
              <description>Transmit At Negative Edge\nNote: Refer to Edge Condition section.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The transmitted data output is changed at the rising edge of SPICLK</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The transmitted data output is changed at the falling edge of SPICLK</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_BIT_LEN</name>
              <description>Transmit Bit Length\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_NUM</name>
              <description>Number Of Transmit/Receive Transaction\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LSB</name>
              <description>Send LSB First\nNote: Refer to LSB First section.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The MSB, which bit of transmit/receive register depends on the setting of TX_BIT_LEN, is transmitted/received first</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The LSB, bit 0 of the SPI_TX0/1, is sent first to the the SPI data output pin, and the first bit received from the SPI data input pin will be put in the LSB position of the SPI_RX register (SPI_RX0/1)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLKP</name>
              <description>Clock Polarity\nNote: Refer to Clock Parity section.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The default level of SPICLK is low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The default level of SPICLK is high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SP_CYCLE</name>
              <description>Suspend Interval (Master Only)\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INTEN</name>
              <description>Interrupt Enable\n</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPI Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLAVE</name>
              <description>Slave Mode Indication\nNote: Refer to Slave Selection section</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPI controller is set as Master mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI controller is set as Slave mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>REORDER</name>
              <description>Reorder Mode Selection\nNote: The suspend interval is defined in SP_CYCLE</description>
              <bitOffset>19</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable both byte reorder and suspend functions</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable byte reorder function and insert a byte suspend interval among each byte. The setting of TX_BIT_LEN must be configured as 00b (32 bits/ word)</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Enable byte reorder function, but disable byte suspend function</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Disable byte reorder function, but insert a suspend interval among each byte. The setting of TX_BIT_LEN must be configured as 00b (32 bits/ word)</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FIFOM</name>
              <description>FIFO Mode Enable\nNote: Refer to Dual FIFO Mode section.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>FIFO mode Disabled (in Normal mode)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>FIFO mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TWOB</name>
              <description>2 Data Channel Transfer Mode Active\nNote: When enabling TWOB, the setting of TX_NUM must be programmed as 00.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>2data channel transfer mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>2data channel transfer mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>VARCLK_EN</name>
              <description>Variable Clock Enable\nNote: Refer to Variable Serial Clock Frequency section.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The serial clock output frequency is fixed and only decided by the value of DIVIDER1</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The serial clock output frequency is variable. The output frequency is decided by the value of VARCLK (SPI_VARCLK), DIVIDER1 and DIVIDER2</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WKEUP_EN</name>
              <description>Wake-Up Enable\nNote: When the system enters the power-down mode, the system can be wake-up from the SPI controller when this bit is enabled and if there is any toggle in the SPICLK port. After the system wake-up, this bit must be clear by user to disable the wake-up requirement.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Wake-up function Disabled when the system enters the power-down mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Wake-up function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_STATUS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_STATUS</displayName>
          <description>SPI Status Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000005</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX_EMPTY</name>
              <description>Received Dual FIFO_EMPTY Status\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Received data FIFO is not empty in the dual FIFO mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Received data FIFO is empty in the dual FIFO mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_FULL</name>
              <description>Received Dual FIFO_FULL Status\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Received data FIFO is not full in dual FIFO mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Received data FIFO is full in the dual FIFO mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_EMPTY</name>
              <description>Transmitted Dual FIFO_EMPTY Status\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmitted data FIFO is not empty in the dual FIFO mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmitted data FIFO is empty in the dual FIFO mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_FULL</name>
              <description>Transmitted Dual FIFO_FULL Status\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmitted data FIFO is not full in the dual FIFO mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmitted data FIFO is full in the dual FIFO mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LTRIG_FLAG</name>
              <description>Level Trigger Flag (INTERNAL ONLY)\nIn Slave mode, this bit indicates whether the received bit number meets the requirement or not after the current transaction done.\nNote: This bit is read only</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The transferred bit length of one transaction does not meet the specified requirement</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The transferred bit length meets the specified requirement which defined in TX_BIT_LEN</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLV_START_INTSTS</name>
              <description>Slave Start Interrupt Status\nIt is used to indicate that the transfer has started in Slave mode with no slave select.\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Slave started transfer no active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transfer has started in Slave mode with no slave select. It is auto clear by transfer done or writing one clear</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INTSTS</name>
              <description>Interrupt Status\nNote: This bit is read only, but can be cleared by writing "1" to this bit.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer is not finished yet</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transfer is done. The interrupt is requested when the INTEN (SPI_CTL[17]) bit is enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_CLKDIV</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_CLKDIV</displayName>
          <description>SPI Clock Divider Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DIVIDER1</name>
              <description>Clock Divider 1 Register \nThe value is the 1th frequency divider of the PCLK to generate the serial clock of SPICLK. The desired frequency is obtained according to the following equation:\n/\n\nNote 1: The DIVIDER1 can be set as 0. If the DIVIDER1 is set as zero, the frequency of SPI_SCLK is the same as PCLK in Master mode.\nNote 2: In Slave mode, the period of SPI clock driven by a master shall equal to or over 5 times the period of PCLK. In other words, the maximum frequency of SPI clock is the fifth of the frequency of slave's PCLK.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIVIDER2</name>
              <description>Clock Divider 2 Register \nThe value is the 2nd 2nd frequency divider of the PCLK to generate the serial clock of SPICLK. The desired frequency is obtained according to the following equation:\n/</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_SSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_SSR</displayName>
          <description>SPI Slave Select Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SSR</name>
              <description>Slave Select Active Register (Master Only)\nIf AUTOSS bit (SPI_SSR[3]) is cleared, writing "1" to SSR[0] bit sets the SPISS[0] line to an active state and writing "0" sets the line back to inactive state.( the same as SSR[1] for SPISS[1])\nNote 1: This interface can only drive one device/slave at a given time. Therefore, the slave select of the selected device must be set to its active level before starting any read or write transfer.\nNote 2: SPISS[0] is also defined as device/slave select input in Slave mode. And that the slave select input must be driven by edge active trigger which level depend on the SS_LVL setting, otherwise the SPI slave core will go into dead path until the edge active triggers again or reset the SPI core by software.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Both SPISS[1] and SPISS[0] are inactive</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPISS[1] is inactive, SPISS[0] is active.\nSPISS[1] is inactive, SPISS[0] is active on the duration of transaction</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>SPISS[1] is active, SPISS[0] is inactive.\nSPISS[1] is active on the duration of transaction, SPISS[0] is inactive</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Both SPISS[1] and SPISS[0] are active.\nBoth SPISS[1] and SPISS[0] are active on the duration of transaction</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SS_LVL</name>
              <description>Slave Select Active Level\nIt defines the active level of device/slave select signals (SPISS[1:0]).\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The SPISS slave select signal is active Low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The SPISS slave select signal is active High</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTOSS</name>
              <description>Automatic Slave Selection (Master Only)\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>If this bit is set as "0", slave select signals are asserted and de-asserted by setting and clearing related bits in SSR[1:0] register</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>If this bit is set as "1", SPISS[1:0] signals are generated automatically. It means that device/slave select signal, which is set in SSR[1:0] register is asserted by the SPI controller when transmit/receive is started by setting the GO_BUSY bit, and is de-asserted after each transaction is done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SS_LTRIG</name>
              <description>Slave Select Level Trigger\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The input slave select signal is edge-trigger</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The slave select signal will be level-trigger.  It depends on SS_LVL to decide the signal is active low or active high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>NOSLVSEL</name>
              <description>No Slave Selected In Slave Mode\nThis is used to ignore the slave select signal in Slave mode. The SPI controller can work on 3 wire interface including SPICLK, SPI_MISO and SPI_MOSI when it is set as a slave device.\nNote 1: Refer to No Slave Select Mode.\nNote 2: In no slave select signal mode, the SS_LTRIG (SPI_SSR[4]) shall be set as "1".</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The controller is 4-wire bi-direction interface</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The controller is 3-wire bi-direction interface in Slave mode. When this bit is set as 1, the controller start to transmit/receive data after the GO_BUSY bit active and the serial clock input</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLV_ABORT</name>
              <description>Abort In Slave Mode With No Slave Selected\nNote 1:Refer to No Slave Select Mode.\nNote 2: It is auto clear to "0" by hardware when the abort event is active.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No force the slave abort</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Force the current transfer done in no slave select mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SSTA_INTEN</name>
              <description>Slave Start Interrupt Enable\nNote : Refer to No Slave Select Mode.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer start interrupt Disabled in no slave select mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transaction start interrupt Enabled in no slave select mode. It is cleared when the current transfer done or the SLV_START_INTSTS bit cleared (write 1 clear)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_RX0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_RX0</displayName>
          <description>SPI Receive Data FIFO Register 0</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXDATA</name>
              <description>Receive Data FIFO Register\nThe received data can be read on it. If the FIFOM bit is set as 1, the user also checks the RX_EMPTY (SPI_STATUS[0]) to check if there is any more received data or not.\nNote 1: The SPI_RX1 is used only in TWOB bit (SPI_CTL[22]) is set 1. The first channel's received data shall be read from SPI_RX0 and the second channel's received data shall be read from SPI_RX1 in two-bit mode. SPI_RX0 shall be read first in TWOB mode.\nNote 2: These two registers are read only.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="SPI_RX0">
          <name>SPI_RX1</name>
          <displayName>SPI_RX1</displayName>
          <description>SPI Receive Data FIFO Register 1</description>
          <addressOffset>0x14</addressOffset>
       </register>
       <register>
          <name>SPI_TX0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_TX0</displayName>
          <description>SPI Transmit Data FIFO Register 0</description>
          <addressOffset>0x20</addressOffset>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TDATA</name>
              <description>Transmit Data FIFO Register\nThe Data Transmit Registers hold the data to be transmitted in the next transfer. The number of valid bits depends on the setting of transmit bit length field of the SPI_CTL register.\nFor example, if TX_BIT_LEN is set to 0x8, the bit SPI_TX[7:0] will be transmitted in next transfer. If TX_BIT_LEN is set to 0x0, the SPI controller will perform a 32-bit transfer.\nNote: The SPI_TX1 is used only in TWOB bit (SPI_CTL[22]) is set 1. The first channel's transmitted data shall be written into SPI_TX0 and the second channel's transmitted data shall be written into SPI_TX1 in twodata channel mode. SPI_TX0 shall be written first in TWOB mode.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="SPI_TX0">
          <name>SPI_TX1</name>
          <displayName>SPI_TX1</displayName>
          <description>SPI Transmit Data FIFO Register 1</description>
          <addressOffset>0x24</addressOffset>
       </register>
       <register>
          <name>SPI_VARCLK</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_VARCLK</displayName>
          <description>SPI Variable Clock Pattern Flag Register</description>
          <addressOffset>0x34</addressOffset>
          <access>read-write</access>
          <resetValue>0x003FFFC3</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VARCLK</name>
              <description>Variable Clock Pattern Flag\nThe value in this field is the frequency patterns of the SPICLK.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_PDMA</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_PDMA</displayName>
          <description>SPI PDMA Control Register</description>
          <addressOffset>0x38</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX_DMA_EN</name>
              <description>Transmit PDMA Enable (PDMA Writes Data To SPI)\nNote 1: Refer to DMA section for more detail information.\nNote 2: Two transaction need minimal 18 APB clock + 8 SPI peripheral clocks suspend interval in master mode for edge mode and 18 APB clock + 9.5 SPI peripheral clocks for level mode.\nNote 3: If the 2 data channel function is enabled, the requirement timing shall append 18 APB clock based on the above clock period.\nNote 4: Hardware will clear this bit to 0 automatically after PDMA transfer done.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmit PDMA function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmit PDMA function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_DMA_EN</name>
              <description>Receiver PDMA Enable (PDMA Reads SPI Data To Memory)\nNote 1: Refer to DMA section for more detail information.\nNote 2: Hardware will clear this bit to 0 automatically after PDMA transfer done.\nNote 3: In Slave mode and the FIFO bit is disabled, if the receive PDMA is enabled but the transmit PDMA is disabled, the minimal suspend interval between two successive  transactions input is need to be larger than 9 SPI peripheral clock + 4 APB clock for edge mode and 9.5 SPI peripheral clocks + 4 APB clocks.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receiver PDMA function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receiver PDMA function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PDMA_RST</name>
              <description>PDMA Reset\nIt is used to reset the SPI PDMA function into default state. \nNote: It is auto cleared to "0" after the reset function done.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>After reset PDMA function or in normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset PDMA function</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_FFCLR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_FFCLR</displayName>
          <description>SPI FIFO Counter Clear Control Register</description>
          <addressOffset>0x3C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX_CLR</name>
              <description>Receiving FIFO Counter Clear\nNote: This bit is used to clear the receiver counter in FIFO Mode. This bit can be written "1" to clear the receiver counter and this bit will be cleared to "0" automatically after clearing receiving counter. After the clear operation, the flag of RX_EMPTY in SPI_STATUS[0] will be set to "1".</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No clear the received FIFO</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clear the received FIFO</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_CLR</name>
              <description>Transmitting FIFO Counter Clear\nNote: This bit is used to clear the transmit counter in FIFO Mode. This bit can be written "1" to clear the transmitting counter and this bit will be cleared to "0" automatically after clearing transmitting counter. After the clear operation, the flag of TX_EMPTY in SPI_STATUS[2] will be set to "1".</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No clear the transmitted FIFO</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clear the transmitted FIFO</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>I2S</name>
      <description>I2S Register Map</description>
      <groupName>I2S</groupName>
      <baseAddress>0x401A0000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x18</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>I2S_CTRL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2S_CTRL</displayName>
          <description>I2S Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>I2SEN</name>
              <description>I2S Controller Enable\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXEN</name>
              <description>Transmit Enable\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Data transmitting Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Data transmitting Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXEN</name>
              <description>Receive Enable\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Data receiving Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Data receiving Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MUTE</name>
              <description>Transmitting Mute Enable\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmit data in buffer to channel</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmit '0' to channel</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WORDWIDTH</name>
              <description>Word Width \nThis bit field indicates the bit-width of data word.\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>data word is 8-bit</description>
                    <value>0x0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>data word is 16-bit</description>
                    <value>0x1</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>data word is 24-bit</description>
                    <value>0x2</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>data word is 32-bit</description>
                    <value>0x3</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MONO</name>
              <description>Monaural Data Selection\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Data is stereo format</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Data is monaural format and gets the right channel data from I2S bus when this mode is enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FORMAT</name>
              <description>Data Format Selection\n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I2S data format</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>MSB justified data format</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLAVE</name>
              <description>Slave Mode Selection\nI2S can operate as master or Slave mode. For Master mode, I2S_BCLK and I2S_LRCLK pins are output mode and also outputs I2S_BCLK and I2S_LRCLK signals to the audio CODEC. When act as Slave mode, I2S_BCLK and I2S_LRCLK pins are input mode and I2S_BCLK and I2S_LRCLK signals are received from the outer audio CODEC chip.\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Master mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Slave mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXTH</name>
              <description>Transmit FIFO Threshold Level\nIf remain data word (32 bits) in transmitting FIFO is the same or less than threshold level then TXTHF flag is set.\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>1 word data in transmitting FIFO</description>
                    <value>0x0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>2 words data in transmitting FIFO</description>
                    <value>0x1</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>3 words data in transmitting FIFO</description>
                    <value>0x2</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>4 words data in transmitting FIFO</description>
                    <value>0x3</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>5 words data in transmitting FIFO</description>
                    <value>0x4</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>6 words data in transmitting FIFO</description>
                    <value>0x5</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>7 words data in transmitting FIFO</description>
                    <value>0x6</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>8 words data in transmitting FIFO</description>
                    <value>0x7</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXTH</name>
              <description>Receiving FIFO Threshold Level\nWhen received data word(s) in buffer is equal to or higher than threshold level then RXTHF flag is set.\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>1 word data in receiving FIFO</description>
                    <value>0x0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>2 words data in receiving FIFO</description>
                    <value>0x1</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>3 words data in receiving FIFO</description>
                    <value>0x2</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>4 words data in receiving FIFO</description>
                    <value>0x3</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>5 words data in receiving FIFO</description>
                    <value>0x4</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>6 words data in receiving FIFO</description>
                    <value>0x5</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>7 words data in receiving FIFO</description>
                    <value>0x6</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>8 words data in receiving FIFO</description>
                    <value>0x7</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MCLKEN</name>
              <description>Master Clock Enable\nEnable master MCLK timing output to the external audio codec device. The output frequency is according to MCLK_DIV[2:0] in the I2S_CLKDIV register.\n</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Master Clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Master Clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RCHZCEN</name>
              <description>Right Channel Zero Cross Detect Enable\nIf this bit is set to "1", when right channel data sign bit is changed or next shift data bits are all zero then RZCF flag in I2S_STATUS register is set to "1". It works on transmitting mode only.\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Right channel zero cross detection Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Right channel zero cross detection Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LCHZCEN</name>
              <description>Left Channel Zero Cross Detect Enable\nIf this bit is set to "1", when left channel data sign bit is changed or next shift data bits are all zero then LZCF flag in I2S_STATUS register is set to "1". It works on transmitting mode only.\n</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Left channel zero cross detection Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Left channel zero cross detection Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLR_TXFIFO</name>
              <description>Clear Transmit FIFO\nWrite "1" to clear transmitting FIFO, internal pointer is reset to FIFO start point,  TX_LEVEL[3:0] returns to zero and transmitting FIFO becomes empty but data in transmit FIFO is not changed. \nThis bit is clear by hardware automatically, read it return zero.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CLR_RXFIFO</name>
              <description>Clear Receiving FIFO\nWrite "1" to clear receiving FIFO, internal pointer is reset to FIFO start point, and RX_LEVEL[3:0] returns to zero and receiving FIFO becomes empty.\nThis bit is cleared by hardware automatically, and read it return zero.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXDMA</name>
              <description>Enable Transmit DMA\nWhen TX DMA is enabled, I2S requests PDMA to transfer data from memory to transmitting FIFO if FIFO is not full\n</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX DMA Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX DMA Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXDMA</name>
              <description>Enable Receive DMA\nWhen RX DMA is enabled, I2S requests PDMA to transfer data from receiving FIFO to memory if FIFO is not empty.\n</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX DMA Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX DMA Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2S_CLKDIV</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2S_CLKDIV</displayName>
          <description>I2S Clock Divider Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MCLK_DIV</name>
              <description>Master Clock Divider\nIf the external crystal frequency is (2xMCLK_DIV)*256fs then software can program these bits to generate 256fs clock frequency to audio CODEC chip. If MCLK_DIV is set to "0", MCLK is the same as external clock input.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BCLK_DIV</name>
              <description>Bit Clock Divider\nIf I2S is operated in Master mode, bit clock is provided by this chip. Software can program these bits to generate sampling rate clock frequency.\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2S_INTEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2S_INTEN</displayName>
          <description>I2S Interrupt Enable Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXUDFIE</name>
              <description>Receiving FIFO Underflow Interrupt Enable\nInterrupt occurs if this bit is set to "1" and receiving FIFO underflow flag is set to "1".\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXOVFIE</name>
              <description>Receiving FIFO Overflow Interrupt Enable\nInterrupt occurs if this bit is set to "1" and receiving FIFO overflow flag is set to "1"\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXTHIE</name>
              <description>Receiving FIFO Threshold Level Interrupt Enable\nInterrupt occurs if this bit is set to "1" and data words in receiving FIFO is less than RXTH[2:0].\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXUDFIE</name>
              <description>Transmitting FIFO Underflow Interrupt Enable\nInterrupt occurs if this bit is set to "1" and transmitting FIFO underflow flag is set to "1".\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXOVFIE</name>
              <description>Transmitting FIFO Overflow Interrupt Enable\nInterrupt occurs if this bit is set to "1" and transmitting FIFO overflow flag is set to "1"\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXTHIE</name>
              <description>Transmitting FIFO Threshold Level Interrupt Enable\nInterrupt occurs if this bit is set to "1" and data words in transmitting FIFO is less than TXTH[2:0].\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RZCIE</name>
              <description>Right Channel Zero Cross Interrupt Enable\nInterrupt occurs if this bit is set to "1" and right channel is zero crossing. \n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LZCIE</name>
              <description>Left Channel Zero Cross Interrupt Enable\nInterrupt occurs if this bit is set to "1" and left channel is zero crossing.\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2S_STATUS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2S_STATUS</displayName>
          <description>I2S Status Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00141000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>I2SINT</name>
              <description>I2S Interrupt Flag\nNote: This bit is read only and it is wire-OR of I2STXINT and I2SRXINT bits.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No I2S interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2S interrupt occurs</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>I2SRXINT</name>
              <description>I2S Receiving Interrupt\nNote: This bit is read only</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No receiving interrupt occurs</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receiving interrupt occurs</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>I2STXINT</name>
              <description>I2S Transmit Interrupt\nNote: This bit is read only</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No transmit interrupt occurs</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmit interrupt occurs</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RIGHT</name>
              <description>Right Channel\nThis bit indicates the current transmitting data is belong to right channel\nNote: This bit is read only</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Left channel</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Right channel</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXUDF</name>
              <description>Receiving FIFO Underflow Flag\nRead the receiving FIFO when it is empty, this bit set to "1" indicate underflow occur. \nNote: This bit is cleared by writing 1.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No underflow occur</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Underflow occurs</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXOVF</name>
              <description>Receiving FIFO Overflow Flag\nWhen the receiving FIFO is full and receiving hardware attempts to write data into receiving FIFO then this bit is set to "1". Data in 1st buffer is overwritten.\nNote: This bit is cleared by writing 1.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No overflow occur</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Overflow occurs</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXTHF</name>
              <description>Receiving FIFO Threshold Flag\nWhen data word(s) in the receiving FIFO is equal to or higher than threshold value set in RXTH[2:0], the RXTHF bit becomes to "1". It keeps at "1" till RX_LEVEL[3:0] less than RXTH[1:0] after software reads data from the RXFIFO register.\nNote: This bit is read only</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Data word(s) in receiving FIFO is lower than threshold level</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Data word(s) in receiving FIFO is equal to or higher than threshold level</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXFULL</name>
              <description>Receiving FIFO Full\nThis bit reflect data word number in the receiving FIFO is 8\nNote: This bit is read only</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Full</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Not full</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXEMPTY</name>
              <description>Receiving FIFO Empty\nThis bit reflect data word number in the receiving FIFO is zero\nNote: This bit is read only.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Not empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXUDF</name>
              <description>Transmitting FIFO Underflow Flag\nWhen the transmitting FIFO is empty and shift logic hardware read data from the data FIFO causes this set to "1". \nNote: This bit is cleared by writing 1.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No underflow</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Underflow</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXOVF</name>
              <description>Transmit FIFO Overflow Flag\nWrite data to the transmitting FIFO when it is full and this bit will set to "1"\nNote: This bit is cleared by writing 1.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No overflow</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Overflow</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXTHF</name>
              <description>Transmitting FIFO Threshold Flag\nWhen data word(s) in the transmitting FIFO is equal to or lower than threshold value set in TXTH[2:0],the TXTHF bit becomes to "1". It keeps at 1 till TX_LEVEL[3:0] is higher than TXTH[1:0] after software writes data into the TXFIFO register.\nNote: This bit is read only</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Data word(s) in transmitting FIFO is higher than threshold level</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Data word(s) in transmitting FIFO is equal or lower than threshold level</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXFULL</name>
              <description>Transmitting FIFO Full\nThis bit reflect data word number in the transmitting FIFO is 8\nNote: This bit is read only</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Full</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Not full</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXEMPTY</name>
              <description>Transmitting FIFO Empty\nThis bit reflect data word number in the transmitting FIFO is zero\nNote: This bit is read only.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Not empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXBUSY</name>
              <description>Transmitting Busy\nThis bit is clear to 0 when all data in the transmitting FIFO and shift buffer is shifted out. Set this bit to 1 when 1st data is loading to shift buffer. \nNote: This bit is read only.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmit shift buffer is empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmit shift buffer is busy</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RZCF</name>
              <description>Right Channel Zero Cross Flag \nIt indicates the data sign of right channel next sample data is changed or all data bits are zero.\nNote: This bit is cleared by writing 1.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No zero cross</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Right channel zero cross is detected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LZCF</name>
              <description>Left Channel Zero Cross Flag \nIt indicates the next sample data sign bit of left channel is changed or all data bits are zero.\nNote: This bit is cleared by writing 1.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No zero cross</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Left channel zero cross is detected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_LEVEL</name>
              <description>Receive FIFO Level\nThese bits indicate the number of data word(s) in the receiving FIFO.\n</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No data in the receiving FIFO</description>
                    <value>0x0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>1 word in the receiving FIFO</description>
                    <value>0x1</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>2 words in the receiving FIFO</description>
                    <value>0x2</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>8</name>
                    <description>8 words in the receiving FIFO</description>
                    <value>0x8</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_LEVEL</name>
              <description>Transmitting FIFO Level\nThese bits indicate the number of data word(s) in the transmitting FIFO.\n</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No data in the transmitting FIFO</description>
                    <value>0x0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>1 word in the transmitting FIFO</description>
                    <value>0x1</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>2 words in the transmitting FIFO</description>
                    <value>0x2</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>8</name>
                    <description>8 words in the transmitting FIFO</description>
                    <value>0x8</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2S_TXFIFO</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2S_TXFIFO</displayName>
          <description>I2S Transmit FIFO Register</description>
          <addressOffset>0x10</addressOffset>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXFIFO</name>
              <description>Transmitting FIFO Register\nI2S contains 8 words (8x32-bit) data buffer for data transmitting. Write data to this register in order to prepare data for transmitting. The remaining word number is indicated by TX_LEVEL[3:0] in the I2S_STATUS register. This register is write only.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2S_RXFIFO</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2S_RXFIFO</displayName>
          <description>I2S Receive FIFO Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXFIFO</name>
              <description>Receiving FIFO Register\nI2S contains 8 words (8x32-bit) data buffer for data receiving. Read this register to get data in FIFO. The remaining data word number is indicated by RX_LEVEL[3:0] in the I2S_STATUS register. This register is read only.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>USB</name>
      <description>USB Register Map</description>
      <groupName>USB</groupName>
      <baseAddress>0x40060000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1C</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x20</offset>
        <size>0xC</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x30</offset>
        <size>0xC</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x40</offset>
        <size>0xC</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x50</offset>
        <size>0xC</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x60</offset>
        <size>0xC</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x70</offset>
        <size>0xC</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0xA4</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>USB_CTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>USB_CTL</displayName>
          <description>USB Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000900</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>USB_EN</name>
              <description>USB Function Enable\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>USB Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>USB Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PHY_EN</name>
              <description>PHY Transceiver Enable\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PHY transceiver Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PHY transceiver Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWRDB</name>
              <description>Power Down PHY Transceiver, Low Active\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Power-down related circuit of PHY transceiver</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Turn-on related circuit of  PHY transceiver</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DPPU_EN</name>
              <description>Pull-Up Resistor On USB_DP Enable\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled the pull-up resistor in USB_DP bus</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Pull-up resistor in USB_DP bus will be active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DRVSE0</name>
              <description>Force USB PHY Transceiver To Drive SE0 (Single Ended Zero)\nThe Single Ended Zero is present when both lines (USB_DP, USB_DM) are being pulled low.\nThe default value is "1".</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>None</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Force USB PHY transceiver to drive SE0</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RWAKEUP</name>
              <description>Remote Wake-Up\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Don't force USB bus to K state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Force USB bus to K (USB_DP low, USB_DM: high) state, used for remote wake-up</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKEUP_EN</name>
              <description>Wake-Up Function Enable\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>USB wake-up function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>USB wake-up function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>USB_BUSSTS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>USB_BUSSTS</displayName>
          <description>USB Bus Status Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>USBRST</name>
              <description>USB Reset Status \n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bus reset when SE0 (single-ended 0) more than 2.5uS. It is read only</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>SUSPEND</name>
              <description>Suspend Status \n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bus idle more than 3mS, either cable is plugged off or host is sleeping. It is read only</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RESUME</name>
              <description>Resume Status\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Resume from suspend. It is read only</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TIMEOUT</name>
              <description>Time Out Flag\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bus no any response more than 18 bits time. It is read only</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>FLDET</name>
              <description>Device Floating Detection\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The controller didn't attach into the USB</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When the controller is attached into the USB, this bit will be set as "1"</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>USB_INTEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>USB_INTEN</displayName>
          <description>Interrupt Enable Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BUSEVT_IE</name>
              <description>Bus Event Interrupt Enable\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>BUS event interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>BUS event interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>USBEVT_IE</name>
              <description>USB Event Interrupt Enable\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>USB event interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>USB event interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FLDET_IE</name>
              <description>Floating Detect Interrupt Enable\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Floating detect Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Floating detect Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKEUP_IE</name>
              <description>USB Wake-Up Interrupt Enable\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Wake-up Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Wake-up Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>USB_INTSTS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>USB_INTSTS</displayName>
          <description>Interrupt Event Status Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BUS_STS</name>
              <description>BUS Interrupt Status\nThe BUS event means there is bus suspense or bus resume in the bus. This bit is used to indicate that there is one of events in the bus.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No BUS event is occurred</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>BUS event occurred; check USB_BUSSTS [3:0] to know which kind of bus event was occurred, cleared by write "1" to USB_INTSTS [0]</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>USB_STS</name>
              <description>USB Interrupt Status\nThe USB event means that there is Setup Token, IN token, OUT ACK, ISO IN, or ISO OUT event in the bus. This bit is used to indicate that there is one of events in the bus.\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No USB event is occurred</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>USB event occurred, check EPSTS0~5[3:0] in USB_EPSTS [31:8] to know which kind of USB event was occurred, cleared by write "1" to USB_INTSTS [1] or USB_INTSTS[31] or EPEVT0~5</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FLD_STS</name>
              <description>Floating Interrupt Status\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>There is not attached event in the USB</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>There is attached event in the USB and it is cleared by write "1" to USB_INTSTS [2]</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WKEUP_STS</name>
              <description>Wake-Up Interrupt Status\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No wake-up event is occurred</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Wake-up event occurred, cleared by write 1 to USB_INTSTS [3]</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EPEVT0</name>
              <description>USB Event Status On EP0\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No event occurred in Endpoint 0</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>USB event occurred on Endpoint 0, check USB_EPSTS[11:8] to know which kind of USB event was occurred, cleared by write "1" to USB_INTSTS [16] or USB_INTSTS [1]</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EPEVT1</name>
              <description>USB Event Status On EP1\n</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No event occurred in Endpoint 1</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>USB event occurred on Endpoint 1, check USB_EPSTS[15:12] to know which kind of USB event was occurred, cleared by write "1" to USB_INTSTS [17] or USB_INTSTS [1]</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EPEVT2</name>
              <description>USB Event Status On EP2\n</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No event occurred in Endpoint 2</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>USB event occurred on Endpoint 2, check USB_EPSTS[19:16] to know which kind of USB event was occurred, cleared by write "1" to USB_INTSTS [18] or USB_INTSTS [1]</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EPEVT3</name>
              <description>USB Event Status On EP3\n</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No event occurred in Endpoint 3</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>USB event occurred on Endpoint 3, check USB_EPSTS[23:20] to know which kind of USB event was occurred, cleared by write "1" to USB_INTSTS [19] or USB_INTSTS [1]</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EPEVT4</name>
              <description>USB Event Status On EP4\n</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No event occurred in Endpoint 4</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>USB event occurred on Endpoint 4, check USB_EPSTS[27:24] to know which kind of USB event was occurred, cleared by write "1" to USB_INTSTS [20] or USB_INTSTS [1]</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EPEVT5</name>
              <description>USB Event Status On EP5\n</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No event occurred in Endpoint 5</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>USB event occurred on Endpoint 5, check USB_EPSTS[31:28] to know which kind of USB event was occurred, cleared by write "1" to USB_INTSTS [21] or USB_INTSTS [1]</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SETUP</name>
              <description>Setup Event Status \n</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Setup event</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Setup event occurred, cleared by write "1" to USB_INTSTS[31]</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>USB_FADDR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>USB_FADDR</displayName>
          <description>Device Function Address Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FADDR</name>
              <description>USB device's function address</description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>USB_EPSTS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>USB_EPSTS</displayName>
          <description>Endpoint Status Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OVERRUN</name>
              <description>Overrun\nIt means the received data is over the maximum payload number or not.\n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No overrun</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Out Data more than the Max Payload in MXPLD register or the Setup Data more than 8 Bytes</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>EPSTS0</name>
              <description>Endpoint 0 Bus Status\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>EPSTS1</name>
              <description>Endpoint 1 Bus Status\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>EPSTS2</name>
              <description>Endpoint 2 Bus Status\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>EPSTS3</name>
              <description>Endpoint 3 Bus Status\n</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>EPSTS4</name>
              <description>Endpoint 4 Bus Status\n</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>EPSTS5</name>
              <description>Endpoint 5 Bus Status\n</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>USB_BUFSEG</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>USB_BUFSEG</displayName>
          <description>Setup Token Buffer Segmentation Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BUFSEG</name>
              <description></description>
              <bitOffset>3</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>USB_BUFSEG0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>USB_BUFSEG0</displayName>
          <description>Endpoint 0 Buffer Segmentation Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BUFSEG</name>
              <description>Refer to the section 5.4.3.3  for the endpoint SRAM structure and its description.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>USB_MXPLD0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>USB_MXPLD0</displayName>
          <description>Endpoint 0 Maximal Payload Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MXPLD</name>
              <description>Maximal Payload\nIt is used to define the length of data which is transmitted to host (IN token) or the actual length of data receiving from host (OUT token). It also used to indicate that the endpoint is ready to be transmitted in IN token or received in OUT token.\n(1). When the register is written by CPU, \nFor IN token, the value of MXPLD is used to define the length of data to be transmitted and indicate the data buffer is ready.\nFor OUT token, it means that the controller is ready to receive data from host and the value of MXPLD is the maximal data length comes from host.\n(2).  When the register is read by CPU,\nFor IN token, the value of MXPLD is indicated the length of data be transmitted to host\nFor OUT token, the value of MXPLD is indicated the actual length of data receiving from host.\nNote: Once MXPLD is written, the data packets will be transmitted/received immediately after IN/OUT token arrived.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>USB_CFG0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>USB_CFG0</displayName>
          <description>Endpoint 0 Configuration Register</description>
          <addressOffset>0x28</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EP_NUM</name>
              <description>Endpoint Number\nThese bits are used to define the endpoint number of the current endpoint</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ISOCH</name>
              <description>Isochronous Endpoint\nThis bit is used to set the endpoint as Isochronous endpoint, no handshake.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EPMODE</name>
              <description>Endpoint Mode\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DSQ_SYNC</name>
              <description>Data Sequence Synchronization\nIt is used to specify the DATA0 or DATA1 PID in the current transaction. It will toggle automatically in IN token after host response ACK. In the other tokens, the user shall take care of it to confirm the right PID in its transaction.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>DATA0 PID</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>DATA1 PID</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CSTALL</name>
              <description>Clear STALL Response\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled to the device to clear the STALL handshake in setup stage</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clear the device to response STALL handshake in setup stage</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SSTALL</name>
              <description>Set STALL Response\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled the device to response STALL</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Set the device to respond STALL automatically</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="USB_BUFSEG0">
          <name>USB_BUFSEG1</name>
          <displayName>USB_BUFSEG1</displayName>
          <description>Endpoint 1 Buffer Segmentation Register</description>
          <addressOffset>0x30</addressOffset>
       </register>
       <register derivedFrom="USB_MXPLD0">
          <name>USB_MXPLD1</name>
          <displayName>USB_MXPLD1</displayName>
          <description>Endpoint 1 Maximal Payload Register</description>
          <addressOffset>0x34</addressOffset>
       </register>
       <register derivedFrom="USB_CFG0">
          <name>USB_CFG1</name>
          <displayName>USB_CFG1</displayName>
          <description>Endpoint 1 Configuration Register</description>
          <addressOffset>0x38</addressOffset>
       </register>
       <register derivedFrom="USB_BUFSEG0">
          <name>USB_BUFSEG2</name>
          <displayName>USB_BUFSEG2</displayName>
          <description>Endpoint 2 Buffer Segmentation Register</description>
          <addressOffset>0x40</addressOffset>
       </register>
       <register derivedFrom="USB_MXPLD0">
          <name>USB_MXPLD2</name>
          <displayName>USB_MXPLD2</displayName>
          <description>Endpoint 2 Maximal Payload Register</description>
          <addressOffset>0x44</addressOffset>
       </register>
       <register derivedFrom="USB_CFG0">
          <name>USB_CFG2</name>
          <displayName>USB_CFG2</displayName>
          <description>Endpoint 2 Configuration Register</description>
          <addressOffset>0x48</addressOffset>
       </register>
       <register derivedFrom="USB_BUFSEG0">
          <name>USB_BUFSEG3</name>
          <displayName>USB_BUFSEG3</displayName>
          <description>Endpoint 3 Buffer Segmentation Register</description>
          <addressOffset>0x50</addressOffset>
       </register>
       <register derivedFrom="USB_MXPLD0">
          <name>USB_MXPLD3</name>
          <displayName>USB_MXPLD3</displayName>
          <description>Endpoint 3 Maximal Payload Register</description>
          <addressOffset>0x54</addressOffset>
       </register>
       <register derivedFrom="USB_CFG0">
          <name>USB_CFG3</name>
          <displayName>USB_CFG3</displayName>
          <description>Endpoint 3 Configuration Register</description>
          <addressOffset>0x58</addressOffset>
       </register>
       <register derivedFrom="USB_BUFSEG0">
          <name>USB_BUFSEG4</name>
          <displayName>USB_BUFSEG4</displayName>
          <description>Endpoint 4 Buffer Segmentation Register</description>
          <addressOffset>0x60</addressOffset>
       </register>
       <register derivedFrom="USB_MXPLD0">
          <name>USB_MXPLD4</name>
          <displayName>USB_MXPLD4</displayName>
          <description>Endpoint 4 Maximal Payload Register</description>
          <addressOffset>0x64</addressOffset>
       </register>
       <register derivedFrom="USB_CFG0">
          <name>USB_CFG4</name>
          <displayName>USB_CFG4</displayName>
          <description>Endpoint 4 Configuration Register</description>
          <addressOffset>0x68</addressOffset>
       </register>
       <register derivedFrom="USB_BUFSEG0">
          <name>USB_BUFSEG5</name>
          <displayName>USB_BUFSEG5</displayName>
          <description>Endpoint 5 Buffer Segmentation Register</description>
          <addressOffset>0x70</addressOffset>
       </register>
       <register derivedFrom="USB_MXPLD0">
          <name>USB_MXPLD5</name>
          <displayName>USB_MXPLD5</displayName>
          <description>Endpoint 5 Maximal Payload Register</description>
          <addressOffset>0x74</addressOffset>
       </register>
       <register derivedFrom="USB_CFG0">
          <name>USB_CFG5</name>
          <displayName>USB_CFG5</displayName>
          <description>Endpoint 5 Configuration Register</description>
          <addressOffset>0x78</addressOffset>
       </register>
       <register>
          <name>USB_PDMA</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>USB_PDMA</displayName>
          <description>USB PDMA Control Register</description>
          <addressOffset>0xA4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_RW</name>
              <description>PDMA_RW\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The PDMA will read data from memory to USB buffer</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The PDMA will read data from USB buffer to memory</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PDMA_TRG</name>
              <description>Active PDMA Function\nThis bit will be automatically cleared after PDMA transfer done.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The PDMA function is not active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The PDMA function in USB is active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BYTEM</name>
              <description>CPU Access USB SRAM Size Mode Select\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Word Mode: The size of the transfer from CPU to USB SRAM is Word order</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Byte Mode: The size of the transfer from CPU to USB SRAM is Byte order</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PDMA_RST</name>
              <description>PDMA Reset\nIt is used to reset the USB PDMA function into default state. \nNote: it is auto clear to 0 after the reset function done.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Reset PDMA Reset Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the PDMA function in this controller</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>ADC</name>
      <description>ADC Register Map</description>
      <groupName>ADC</groupName>
      <baseAddress>0x400E0000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x20</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x28</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x30</offset>
        <size>0x14</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x54</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x60</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>ADC_RESULT0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ADC_RESULT0</displayName>
          <description>A/D Result Register 0</description>
          <addressOffset>0x0</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RSLT</name>
              <description>A/D Conversion Result\nThis field contains 12 bits conversion result.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="ADC_RESULT0">
          <name>ADC_RESULT1</name>
          <displayName>ADC_RESULT1</displayName>
          <description>A/D Result Register 1</description>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="ADC_RESULT0">
          <name>ADC_RESULT2</name>
          <displayName>ADC_RESULT2</displayName>
          <description>A/D Result Register 2</description>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="ADC_RESULT0">
          <name>ADC_RESULT3</name>
          <displayName>ADC_RESULT3</displayName>
          <description>A/D Result Register 3</description>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="ADC_RESULT0">
          <name>ADC_RESULT4</name>
          <displayName>ADC_RESULT4</displayName>
          <description>A/D Result Register 4</description>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="ADC_RESULT0">
          <name>ADC_RESULT5</name>
          <displayName>ADC_RESULT5</displayName>
          <description>A/D Result Register 5</description>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="ADC_RESULT0">
          <name>ADC_RESULT6</name>
          <displayName>ADC_RESULT6</displayName>
          <description>A/D Result Register 6</description>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="ADC_RESULT0">
          <name>ADC_RESULT7</name>
          <displayName>ADC_RESULT7</displayName>
          <description>A/D Result Register 7</description>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="ADC_RESULT0">
          <name>ADC_RESULT10</name>
          <displayName>ADC_RESULT10</displayName>
          <description>A/D Result Register 10</description>
          <addressOffset>0x28</addressOffset>
       </register>
       <register>
          <name>ADCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ADCR</displayName>
          <description>A/D Control Register</description>
          <addressOffset>0x30</addressOffset>
          <access>read-write</access>
          <resetValue>0x00010000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADEN</name>
              <description>A/D Converter Enable\nBefore starting A/D conversion function, this bit should be set to 1. Clear it to 0 to disable A/D converter analog circuit power consumption.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADIE</name>
              <description>A/D Interrupt Enable\nA/D conversion end interrupt request is generated if ADIE bit is set to 1.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>A/D interrupt function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>A/D interrupt function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADMD</name>
              <description>A/D Converter Operation Mode\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Single conversion</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Single-cycle scan</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Continuous scan</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGS</name>
              <description>Hardware Trigger Source\nSoftware should disable TRGE and ADST before change TRGS. \nIn hardware trigger mode, the ADST bit is set by the external trigger from STADC, However software has the highest priority to set or cleared ADST bit at any time.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>A/D conversion is started by external STADC pin</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Reserved</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGCOND</name>
              <description>External Trigger Condition\nThese two bits decide external pin STADC trigger event is level or edge. The signal must be kept at stable state at least 8 PCLKs for level trigger and 4 PCLKs at high and low state.\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Low level</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>High level</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Falling edge</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Rising edge</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGEN</name>
              <description>External Trigger Enable\nEnable or disable triggering of A/D conversion by external STADC pin.\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PTEN</name>
              <description>PDMA Transfer Enable\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PDMA data transfer Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PDMA data transfer in ADC_RESULT 0~10 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADST</name>
              <description>A/D Conversion Start\nADST bit can be set to 1 from two sources: software write and external pin STADC. ADST is cleared to 0 by hardware automatically at the end of single mode and single-cycle scan mode on specified channels. In continuous scan mode, A/D conversion is continuously performed sequentially unless software writes 0 to this bit or chip reset.\nNote: After ADC conversion done, SW needs to wait at least one ADC clock before to set this bit high again.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Conversion stopped and A/D converter enter idle state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Conversion starts</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMSEL</name>
              <description>Select A/D Enable Time-Out Source \n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TMR0</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TMR1</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>TMR2</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>TMR3</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMTRGMOD</name>
              <description>Timer Event Trigger ADC Conversion\nsetting TMSEL to select timer event from timer0~3</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>This function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ADC Enabled by TIMER out event</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>REFSEL</name>
              <description>Reference Voltage Source Selection\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Select power as reference voltage</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Select VBG as reference voltage</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Select external voltage as reference voltage</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Ch7</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ADCHER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ADCHER</displayName>
          <description>A/D Channel Enable Register</description>
          <addressOffset>0x34</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CHEN0</name>
              <description>Analog Input Channel 0 Enable Control\nIf more than one channel in single mode is enabled by software, the least channel is converted and other enabled channels will be ignored.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CHEN1</name>
              <description>Analog Input Channel 1 Enable Control\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CHEN2</name>
              <description>Analog Input Channel 2 Enable Control\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CHEN3</name>
              <description>Analog Input Channel 3 Enable Control\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CHEN4</name>
              <description>Analog Input Channel 4 Enable Control\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CHEN5</name>
              <description>Analog Input Channel 5 Enable Control\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CHEN6</name>
              <description>Anaslog Input Channel 6 Enable Control\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CHEN7</name>
              <description>Analog Input Channel 7 Enable Control\n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CHEN10</name>
              <description>Analog Input Channel 10 Enable Control\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH10SEL</name>
              <description>Select Channel10 Input\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Select VTEMP as channel10 input</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Select AVDD as channel10 input</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Select AVSS as channel10 input</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ADCMPR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ADCMPR0</displayName>
          <description>A/D Compare Register 0</description>
          <addressOffset>0x38</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMPEN</name>
              <description>Compare Enable\nSet this bit to 1 to enable compare CMPD[11:0] with specified channel conversion result when converted data is loaded into ADC_RESULTx register.\nWhen this bit is set to 1, and CMPMATCNT is 0, the CMPF (ADSR[2,1]) will be set once the match is hit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Compare Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Compare Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPIE</name>
              <description>Compare Interrupt Enable\nIf the compare function is enabled and the compare condition matches the setting of CMPCOND and CMPMATCNT, CMPF (ADSR[2,1]) will be asserted, in the meanwhile, if CMPIE is set to 1, a compare interrupt request is generated.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Compare function interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Compare function interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPCOND</name>
              <description>Compare Condition\nNote: When the internal counter reaches the value to (CMPMATCNT +1), the CMPF (ADSR[2,1])  will be set.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Set the compare condition as that when a 12-bit A/D conversion result is less than the 12-bit CMPD (ADCMPRx[27:16]), the internal match counter will increase one</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Set the compare condition as that when a 12-bit A/D conversion result is greater or equal to the 12-bit CMPD (ADCMPRx[27:16]), the internal match counter will increase by one</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPCH</name>
              <description>Compare Channel Selection\nSet this field to select which channel's result to be compared.\nNote: Valid setting of this field is channel 0~10.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPMATCNT</name>
              <description>Compare Match Count\nWhen the specified A/D channel analog conversion result matches the compare condition defined by CMPCOND[2], the internal match counter will increase 1. When the internal counter reaches the value to (CMPMATCNT +1), the CMPF bit will be set.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPD</name>
              <description>Comparison Data\nThe 12 bits data is used to compare with conversion result of specified channel. Software can use it to monitor the external analog input pin voltage variation in scan mode without imposing a load on software.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>10</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="ADCMPR0">
          <name>ADCMPR1</name>
          <displayName>ADCMPR1</displayName>
          <description>A/D Compare Register 1</description>
          <addressOffset>0x3C</addressOffset>
       </register>
       <register>
          <name>ADSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ADSR</displayName>
          <description>A/D Status Register</description>
          <addressOffset>0x40</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADF</name>
              <description>A/D Conversion End Flag\nA status flag that indicates the end of A/D conversion.\nADF is set to 1 at these two conditions:\nWhen A/D conversion ends in single mode\nWhen A/D conversion ends on all specified channels in scan mode.\nThis flag can be cleared by writing 1 to it.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPF0</name>
              <description>Compare Flag\nWhen the selected channel A/D conversion result meets setting condition in ADCMPR0 then this bit is set to 1. And it is cleared by writing 1 to self.\nThis flag can be cleared by writing 1 to it.\nNote: when this flag is set, the matching counter will be reset to 0,and continue to count when user write 1 to clear CMPF0</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Conversion result in ADC_RESULTx does not meet ADCMPR0setting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Conversion result in ADC_RESULTx meets ADCMPR0setting</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPF1</name>
              <description>Compare Flag\nWhen the selected channel A/D conversion result meets setting condition in ADCMPR1 then this bit is set to 1. And it is cleared by writing 1 to self.\nThis flag can be cleared by writing 1 to it.\nNote: when this flag is set, the matching counter will be reset to 0,and continue to count when user write 1 to clear CMPF1</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Conversion result in ADC_RESULTx does not meet ADCMPR1 setting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Conversion result in ADC_RESULTx meets ADCMPR1 setting</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BUSY</name>
              <description>BUSY/IDLE\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>A/D converter is in idle state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>A/D converter is busy at conversion</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CHANNEL</name>
              <description>Current Conversion Channel (Read Only)\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>VALID15_8</name>
              <description>Data Valid Flag\nAfter ADC converts finish, this field will set to high.\nThis field will clear when ADC_RESULTx be read.\nNote: Those flags are for ADC_RESULT0~7</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VALID18</name>
              <description>Data Valid Flag\nAfter ADC converts finish, this field will set to high.\nThis field will clear when ADC_RESULTx be read.\nNote: This flag is for ADC_RESULT10</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERRUN27_24</name>
              <description>Over Run Flag\nWhen VALID is high and ADC converts finish, this field will set to high.\nNote: Those flag are for ADC_RESULT0~7</description>
              <bitOffset>20</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERRUN30</name>
              <description>Over Run Flag\nWhen VALID is high and ADC converts finish, this field will set to high.\nNote: This flag is for ADC_RESULT10</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ADFCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ADFCR</displayName>
          <description>A/D FPGA Control Register+</description>
          <addressOffset>0x54</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
          </fields>
       </register>
       <register>
          <name>ADPDMA</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ADPDMA</displayName>
          <description>A/D PDMA Current Transfer Data Register</description>
          <addressOffset>0x60</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AD_PDMA</name>
              <description>ADC PDMA Current Transfer Data Register (Read Only)\nWhen PDMA transferring, read this register can monitor current PDMA transfer data.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ADCDELSEL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ADCDELSEL</displayName>
          <description>PDMA Counter for Delay Time and PDMA Transfer Count and ADC Start Hold Counter</description>
          <addressOffset>0x64</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000AFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>En2StDelay</name>
              <description>A/D Delay Time Select Register\nSet this register to adjust the time interval (in PCLK unit )between start signal and enable signal of ADC\nNote: The time interval is En2StDelay+1 PCLK cycle</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TMPDMACNT</name>
              <description>PDMA Count\nWhen each time out event occur PDMA will transfer TMPDMACNT +1 ADC result in the amount of this register setting\nNote: The total amount of PDMA transferring data should be set in PDMA byte count register. When PDMA finish is set, ADC will not be enabled and start transfer even though the time out event occur</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADCSTHOLDCNT</name>
              <description>ADC Start Hold Time Counter\nThis ADC start is the start signal from ADC controller to analog ADC, not the ADST in ADCR[11],.\nIn Figure 517, when ADC start signal transition from high to low, the ADC reset signal will transition from low to high, at this moment the ADC hold the input analog single and stop holding when ADC start signal transition from low to high.\nThe interval of the holding time is programmable by setting this register. ADC need ADC start signal to keep low level at least 2 ADC CLOCK in order to get converting result more accurately. Setting this register will change the interval in ADC CLOCK unit</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
  </peripherals>
</device>
