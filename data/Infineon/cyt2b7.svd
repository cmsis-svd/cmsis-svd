<?xml version="1.0" encoding="utf-8"?>
<!-- Generator version: 1.5.0.1311 -->
<!-- Database revision: TVIIBE1M_WW1826_for_B0_CFR-1 -->
<device schemaVersion="1.3" xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" xs:noNamespaceSchemaLocation="CMSIS-SVD.xsd">
  <vendor>Cypress Semiconductor</vendor>
  <vendorID>Cypress</vendorID>
  <name>cyt2b7</name>
  <series>cyt2b7</series>
  <version>1.0</version>
  <description>CYT2B7</description>
  <licenseText>Copyright 2016-2019, Cypress Semiconductor Corporation.  All rights reserved.\n
    You may use this file only in accordance with the license, terms, conditions,\n
    disclaimers, and limitations in the end user license agreement accompanying\n
    the software package with which this file was provided.</licenseText>
  <addressUnitBits>8</addressUnitBits>
  <width>32</width>
  <resetValue>0x00000000</resetValue>
  <resetMask>0xFFFFFFFF</resetMask>
  <peripherals>
    <peripheral>
      <name>PERI</name>
      <description>Peripheral interconnect</description>
      <baseAddress>0x40000000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>TIMEOUT_CTL</name>
          <description>Timeout control</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFF</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>TIMEOUT</name>
              <description>This field specifies a number of peripheral group (clk_group) clock cycles. If an AHB-Lite bus transfer takes more than the specified number of cycles (timeout detection), the bus transfer is terminated with an AHB-Lite bus error and a fault is generated (and possibly recorded in the fault report structure(s)).
'0x0000'-'0xfffe': Number of peripheral group clock cycles.
'0xffff': This value is the default/reset value and specifies that no timeout detection is performed: a bus transfer will never be terminated and a fault will never be generated.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TR_CMD</name>
          <description>Trigger command</description>
          <addressOffset>0x220</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xE0001FFF</resetMask>
          <fields>
            <field>
              <name>TR_SEL</name>
              <description>Specifies the activated trigger when ACTIVATE is '1'. If the specified trigger is not present, the trigger activation has no effect.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GROUP_SEL</name>
              <description>Specifies the trigger group:
'0'-'15': trigger multiplexer groups.
'16'-'31': trigger 1-to-1 groups.</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_EDGE</name>
              <description>Specifies if the activated  trigger is treated as a level sensitive or edge sensitive sensitive trigger.
'0': level sensitive. The trigger reflects TR_CMD.ACTIVATE.
'1': edge sensitive trigger. The trigger is activated for two clk_peri cycles.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OUT_SEL</name>
              <description>Specifies whether trigger activation is for a specific input or ouput trigger of the trigger multiplexer. Activation of a specific input trigger, will result in activation of all output triggers that have the specific input trigger selected through their TR_OUT_CTL.TR_SEL  field. Activation of a specific output trigger, will result in activation of the specified TR_SEL output trigger only.
'0': TR_SEL selection and trigger activation is for an input trigger to the trigger multiplexer.
'1': TR_SEL selection and trigger activation is for an output trigger from the trigger multiplexer.

Note: this field is not used for trigger 1-to-1 groups.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACTIVATE</name>
              <description>SW sets this field to '1' to activate (set to '1') a trigger as identified by TR_SEL, TR_EDGE and OUT_SEL. HW sets this field to '0' for edge sensitive triggers AFTER the selected trigger is activated for two clk_peri cycles.

Note: when ACTIVATE is '1', SW should not modify the other register fields.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DIV_CMD</name>
          <description>Divider command</description>
          <addressOffset>0x400</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3FF03FF</resetValue>
          <resetMask>0xC3FF03FF</resetMask>
          <fields>
            <field>
              <name>DIV_SEL</name>
              <description>(TYPE_SEL, DIV_SEL) specifies the divider on which the command (DISABLE/ENABLE) is performed.
 
If DIV_SEL is '255' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock signal(s) are generated.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TYPE_SEL</name>
              <description>Specifies the divider type of the divider on which the command is performed:
0: 8.0 (integer) clock dividers.
1: 16.0 (integer) clock dividers.
2: 16.5 (fractional) clock dividers.
3: 24.5 (fractional) clock dividers.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PA_DIV_SEL</name>
              <description>(PA_TYPE_SEL, PA_DIV_SEL) specifies the divider to which phase alignment is performed for the clock enable command. Any enabled divider can be used as reference. This allows all dividers to be aligned with each other, even when they are enabled at different times.
 
If PA_DIV_SEL is '255' and PA_TYPE_SEL is '3', 'clk_peri' is used as reference.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PA_TYPE_SEL</name>
              <description>Specifies the divider type of the divider to which phase alignment is performed for the clock enable command:
0: 8.0 (integer) clock dividers.
1: 16.0 (integer) clock dividers.
2: 16.5 (fractional) clock dividers.
3: 24.5 (fractional) clock dividers.</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DISABLE</name>
              <description>Clock divider disable command (mutually exclusive with ENABLE). SW sets this field to '1' and HW sets this field to '0'.
 
The DIV_SEL and TYPE_SEL fields specify which divider is to be disabled.
 
The HW sets the DISABLE field to '0' immediately and the HW sets the DIV_XXX_CTL.EN field of the divider to '0' immediately.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Clock divider enable command (mutually exclusive with DISABLE). Typically, SW sets this field to '1' to enable a divider and HW sets this field to '0' to indicate that divider enabling has completed. When a divider is enabled, its integer and fractional (if present) counters are initialized to '0'. If a divider is to be re-enabled using different integer and fractional divider values, the SW should follow these steps:
0: Disable the divider using the DIV_CMD.DISABLE field.
1: Configure the divider's DIV_XXX_CTL register.
2: Enable the divider using the DIV_CMD_ENABLE field.
 
The DIV_SEL and TYPE_SEL fields specify which divider is to be enabled. The enabled divider may be phase aligned to either 'clk_peri' (typical usage) or to ANY enabled divider.
 
The PA_DIV_SEL and PA_TYPE_SEL fields specify the reference divider.
 
The HW sets the ENABLE field to '0' when the enabling is performed and the HW set the DIV_XXX_CTL.EN field of the divider to '1' when the enabling is performed. Note that enabling with phase alignment to a low frequency divider takes time. E.g. To align to a divider that generates a clock of 'clk_peri'/n (with n being the integer divider value INT_DIV+1), up to n cycles may be required to perform alignment. Phase alignment to 'clk_peri' takes affect immediately. SW can set this field to '0' during phase alignment to abort the enabling process.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>256</dim>
          <dimIncrement>4</dimIncrement>
          <name>CLOCK_CTL[%s]</name>
          <description>Clock control</description>
          <addressOffset>0xC00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3FF</resetValue>
          <resetMask>0x3FF</resetMask>
          <fields>
            <field>
              <name>DIV_SEL</name>
              <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
 
If DIV_SEL is '255' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
 
When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '255' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TYPE_SEL</name>
              <description>Specifies divider type:
0: 8.0 (integer) clock dividers.
1: 16.0 (integer) clock dividers.
2: 16.5 (fractional) clock dividers.
3: 24.5 (fractional) clock dividers.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>256</dim>
          <dimIncrement>4</dimIncrement>
          <name>DIV_8_CTL[%s]</name>
          <description>Divider control (for 8.0 divider)</description>
          <addressOffset>0x1000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF01</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
 
Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INT8_DIV</name>
              <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
 
For the generation of a divided clock, the integer division range is restricted to [2, 256].
 
For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is resticited to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>256</dim>
          <dimIncrement>4</dimIncrement>
          <name>DIV_16_CTL[%s]</name>
          <description>Divider control (for 16.0 divider)</description>
          <addressOffset>0x1400</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF01</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
 
Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INT16_DIV</name>
              <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
 
For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
 
For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[23:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>256</dim>
          <dimIncrement>4</dimIncrement>
          <name>DIV_16_5_CTL[%s]</name>
          <description>Divider control (for 16.5 divider)</description>
          <addressOffset>0x1800</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFF9</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
 
Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FRAC5_DIV</name>
              <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[7:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT16_DIV</name>
              <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
 
For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
 
For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[23:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>255</dim>
          <dimIncrement>4</dimIncrement>
          <name>DIV_24_5_CTL[%s]</name>
          <description>Divider control (for 24.5 divider)</description>
          <addressOffset>0x1C00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFF9</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
 
Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FRAC5_DIV</name>
              <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[7:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT24_DIV</name>
              <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
 
For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
 
For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[31:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ECC_CTL</name>
          <description>ECC control</description>
          <addressOffset>0x2000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x10000</resetValue>
          <resetMask>0xFF0507FF</resetMask>
          <fields>
            <field>
              <name>WORD_ADDR</name>
              <description>Specifies the word address where the parity is injected.
- On a 32-bit write access to this SRAM address and when ECC_INJ_EN bit is '1', the parity (PARITY) is injected.</description>
              <bitRange>[10:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_EN</name>
              <description>Enable ECC checking:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_INJ_EN</name>
              <description>Enable error injection for PERI protection structure SRAM.
When '1', the parity (PARITY) is used when a write is done to the WORD_ADDR word address of the SRAM.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY</name>
              <description>ECC parity to use for ECC error injection at address WORD_ADDR.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>10</dim>
          <dimIncrement>32</dimIncrement>
          <name>GR[%s]</name>
          <description>Peripheral group structure</description>
          <addressOffset>0x00004000</addressOffset>
          <register>
            <name>CLOCK_CTL</name>
            <description>Clock control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF00</resetMask>
            <fields>
              <field>
                <name>INT8_DIV</name>
                <description>Specifies a group clock divider (from the peripheral clock 'clk_peri' to the group clock 'clk_group[3/4/5/...15]'). Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. 
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SL_CTL</name>
            <description>Slave control</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xFFFF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ENABLED_0</name>
                <description>Peripheral group, slave 0 enable. If the slave is disabled, its clock is gated off (constant '0') and its resets are activated.

Note: For peripheral group 0 (the peripheral interconnect MMIO registers), this field is a constant '1' (SW: R): the slave can NOT be disabled.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_1</name>
                <description>Peripheral group, slave 1 enable. If the slave is disabled, its clock is gated off (constant '0') and its resets are activated.

Note: For peripheral group 0 (the peripheral interconnect, master interface MMIO registers), this field is a constant '1' (SW: R): the slave can NOT be disabled.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_2</name>
                <description>N/A</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_3</name>
                <description>N/A</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_4</name>
                <description>N/A</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_5</name>
                <description>N/A</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_6</name>
                <description>N/A</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_7</name>
                <description>N/A</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_8</name>
                <description>N/A</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_9</name>
                <description>N/A</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_10</name>
                <description>N/A</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_11</name>
                <description>N/A</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_12</name>
                <description>N/A</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_13</name>
                <description>N/A</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_14</name>
                <description>N/A</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_15</name>
                <description>N/A</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLED_0</name>
                <description>Peripheral group, slave 0 permanent disable. Setting this bit to 1 has the same effect as setting ENABLED_0 to 0.  However, once set to 1, this bit cannot be changed back to 0 anymore.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLED_1</name>
                <description>N/A</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLED_2</name>
                <description>N/A</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLED_3</name>
                <description>N/A</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLED_4</name>
                <description>N/A</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLED_5</name>
                <description>N/A</description>
                <bitRange>[21:21]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLED_6</name>
                <description>N/A</description>
                <bitRange>[22:22]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLED_7</name>
                <description>N/A</description>
                <bitRange>[23:23]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLED_8</name>
                <description>N/A</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLED_9</name>
                <description>N/A</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLED_10</name>
                <description>N/A</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLED_11</name>
                <description>N/A</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLED_12</name>
                <description>N/A</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLED_13</name>
                <description>N/A</description>
                <bitRange>[29:29]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLED_14</name>
                <description>N/A</description>
                <bitRange>[30:30]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLED_15</name>
                <description>N/A</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>11</dim>
          <dimIncrement>1024</dimIncrement>
          <name>TR_GR[%s]</name>
          <description>Trigger group</description>
          <addressOffset>0x00008000</addressOffset>
          <register>
            <dim>256</dim>
            <dimIncrement>4</dimIncrement>
            <name>TR_CTL[%s]</name>
            <description>Trigger control register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x13FF</resetMask>
            <fields>
              <field>
                <name>TR_SEL</name>
                <description>Specifies input trigger. This field is typically set during the setup of a chip use case scenario. Changing this field while activated triggers are present on the input triggers may result in unpredictable behavior. Note that input trigger 0 (default value) is typically connected to a constant signal level of '0', and as a result will not cause HW activation of the output trigger.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TR_INV</name>
                <description>Specifies if the output trigger is inverted.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TR_EDGE</name>
                <description>Specifies if the (inverted) output trigger is treated as a level sensitive or edge sensitive sensitive trigger.
'0': level sensitive.
'1': edge sensitive trigger. The (inverted) ouput trigger duration needs to be at least 2 cycles on the consumer clock. the(inverted) ouput trigger is synchronized to the consumer clock and a two cycle pulse is generated on the consumer clock.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DBG_FREEZE_EN</name>
                <description>Specifies if the output trigger is blocked in debug mode. When set high tr_dbg_freeze will block the output trigger generation.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>9</dim>
          <dimIncrement>1024</dimIncrement>
          <name>TR_1TO1_GR[%s]</name>
          <description>Trigger 1-to-1 group</description>
          <addressOffset>0x0000C000</addressOffset>
          <register>
            <dim>256</dim>
            <dimIncrement>4</dimIncrement>
            <name>TR_CTL[%s]</name>
            <description>Trigger control register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1301</resetMask>
            <fields>
              <field>
                <name>TR_SEL</name>
                <description>Specifies input trigger:
'0'': constant signal level '0'.
'1': input trigger.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TR_INV</name>
                <description>Specifies if the output trigger is inverted.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TR_EDGE</name>
                <description>Specifies if the (inverted) output trigger is treated as a level sensitive or edge sensitive sensitive trigger.
'0': level sensitive.
'1': edge sensitive trigger. The (inverted) ouput trigger duration needs to be at least 2 cycles on the consumer clock. the(inverted) ouput trigger is synchronized to the consumer clock and a two cycle pulse is generated on the consumer clock.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DBG_FREEZE_EN</name>
                <description>Specifies if the output trigger is blocked in debug mode. When set high tr_dbg_freeze will block the output trigger generation.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>PERI_MS</name>
      <description>Peripheral interconnect, master interface</description>
      <baseAddress>0x40010000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>16</dim>
          <dimIncrement>64</dimIncrement>
          <name>PPU_PR[%s]</name>
          <description>Programmable protection structure pair</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>SL_ADDR</name>
            <description>Slave region, base address</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>ADDR30</name>
                <description>This field specifies the base address of the slave region. The region size is defined by SL_SIZE.REGION_SIZE. A region of n Bytes must be n Byte aligned. Therefore, some of the lesser significant address bits of ADDR30 must be '0's. E.g., a 64 KB address region (REGION_SIZE is '15') must be 64 KByte aligned, and ADDR30[13:0] must be '0's.</description>
                <bitRange>[31:2]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SL_SIZE</name>
            <description>Slave region, size</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80000000</resetMask>
            <fields>
              <field>
                <name>REGION_SIZE</name>
                <description>This field specifies the size of the slave region:
'0': Undefined.
'1': 4 B region (this is the smallest region size).
'2': 8 B region
'3': 16 B region
'4': 32 B region
'5': 64 B region
'6': 128 B region
'7': 256 B region
'8': 512 B region
'9': 1 KB region
'10': 2 KB region
'11': 4 KB region
'12': 8 KB region
'13': 16 KB region
'14': 32 KB region
'15': 64 KB region
'16': 128 KB region
'17': 256 KB region
'18': 512 KB region
'19': 1 MB region
'20': 2 MB region
'21': 4 MB region
'22': 8 MB region
'23': 16 MB region
'24': 32 MB region
'25': 64 MB region
'26': 128 MB region
'27': 256 MB region
'28': 512 MB region
'29': 1 GB region
'30': 2 GB region
'31': 4 GB region</description>
                <bitRange>[28:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VALID</name>
                <description>Slave region enable:
'0': Disabled. A disabled region will never result in a match on the transfer address.
'1': Enabled.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SL_ATT0</name>
            <description>Slave attributes 0</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC0_UR</name>
                <description>Protection context 0, user read enable:
'0': Disabled (user, read acceses are NOT allowed).
'1': Enabled (user, read acceses are allowed).</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_UW</name>
                <description>Protection context 0, user write enable:
'0': Disabled (user, write acceses are NOT allowed).
'1': Enabled (user, write acceses are allowed).</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_PR</name>
                <description>Protection context 0, privileged read enable:
'0': Disabled (privileged, read acceses are NOT allowed).
'1': Enabled (privileged, read acceses are allowed).</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_PW</name>
                <description>Protection context 0, privileged write enable:
'0': Disabled (privileged, write acceses are NOT allowed).
'1': Enabled (privileged, write acceses are allowed).</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_NS</name>
                <description>Protection context 0, non-secure:
'0': Secure (secure accesses allowed, non-secure access NOT allowed).
'1': Non-secure (both secure and non-secure accesses allowed).</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC1_UR</name>
                <description>Protection context 1, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC1_UW</name>
                <description>Protection context 1, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC1_PR</name>
                <description>Protection context 1, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC1_PW</name>
                <description>Protection context 1, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC1_NS</name>
                <description>Protection context 1, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_UR</name>
                <description>Protection context 2, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_UW</name>
                <description>Protection context 2, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_PR</name>
                <description>Protection context 2, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_PW</name>
                <description>Protection context 2, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_NS</name>
                <description>Protection context 2, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_UR</name>
                <description>Protection context 3, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_UW</name>
                <description>Protection context 3, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_PR</name>
                <description>Protection context 3, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_PW</name>
                <description>Protection context 3, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_NS</name>
                <description>Protection context 3, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SL_ATT1</name>
            <description>Slave attributes 1</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC4_UR</name>
                <description>Protection context 4, user read enable.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC4_UW</name>
                <description>Protection context 4, user write enable.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC4_PR</name>
                <description>Protection context 4, privileged read enable.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC4_PW</name>
                <description>Protection context 4, privileged write enable.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC4_NS</name>
                <description>Protection context 4, non-secure.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_UR</name>
                <description>Protection context 5, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_UW</name>
                <description>Protection context 5, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_PR</name>
                <description>Protection context 5, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_PW</name>
                <description>Protection context 5, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_NS</name>
                <description>Protection context 5, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_UR</name>
                <description>Protection context 6, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_UW</name>
                <description>Protection context 6, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_PR</name>
                <description>Protection context 6, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_PW</name>
                <description>Protection context 6, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_NS</name>
                <description>Protection context 6, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_UR</name>
                <description>Protection context 7, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_UW</name>
                <description>Protection context 7, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_PR</name>
                <description>Protection context 7, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_PW</name>
                <description>Protection context 7, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_NS</name>
                <description>Protection context 7, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SL_ATT2</name>
            <description>Slave attributes 2</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC8_UR</name>
                <description>Protection context 8, user read enable.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC8_UW</name>
                <description>Protection context 8, user write enable.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC8_PR</name>
                <description>Protection context 8, privileged read enable.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC8_PW</name>
                <description>Protection context 8, privileged write enable.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC8_NS</name>
                <description>Protection context 8, non-secure.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_UR</name>
                <description>Protection context 9, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_UW</name>
                <description>Protection context 9, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_PR</name>
                <description>Protection context 9, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_PW</name>
                <description>Protection context 9, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_NS</name>
                <description>Protection context 9, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_UR</name>
                <description>Protection context 10, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_UW</name>
                <description>Protection context 10, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_PR</name>
                <description>Protection context 10, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_PW</name>
                <description>Protection context 10, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_NS</name>
                <description>Protection context 10, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_UR</name>
                <description>Protection context 11, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_UW</name>
                <description>Protection context 11, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_PR</name>
                <description>Protection context 11, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_PW</name>
                <description>Protection context 11, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_NS</name>
                <description>Protection context 11, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SL_ATT3</name>
            <description>Slave attributes 3</description>
            <addressOffset>0x1C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC12_UR</name>
                <description>Protection context 12, user read enable.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC12_UW</name>
                <description>Protection context 12, user write enable.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC12_PR</name>
                <description>Protection context 12, privileged read enable.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC12_PW</name>
                <description>Protection context 12, privileged write enable.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC12_NS</name>
                <description>Protection context 12, non-secure.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_UR</name>
                <description>Protection context 13, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_UW</name>
                <description>Protection context 13, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_PR</name>
                <description>Protection context 13, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_PW</name>
                <description>Protection context 13, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_NS</name>
                <description>Protection context 13, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_UR</name>
                <description>Protection context 14, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_UW</name>
                <description>Protection context 14, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_PR</name>
                <description>Protection context 14, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_PW</name>
                <description>Protection context 14, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_NS</name>
                <description>Protection context 14, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_UR</name>
                <description>Protection context 15, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_UW</name>
                <description>Protection context 15, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_PR</name>
                <description>Protection context 15, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_PW</name>
                <description>Protection context 15, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_NS</name>
                <description>Protection context 15, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS_ADDR</name>
            <description>Master region, base address</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFC0</resetMask>
            <fields>
              <field>
                <name>ADDR26</name>
                <description>This field specifies the base address of the master region. The base address of the region is the address of the SL_ADDR register.</description>
                <bitRange>[31:6]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS_SIZE</name>
            <description>Master region, size</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x85000000</resetValue>
            <resetMask>0x9F000000</resetMask>
            <fields>
              <field>
                <name>REGION_SIZE</name>
                <description>This field specifies the size of the master region:
'5': 64 B region

The master region includes the SL_ADDR, SL_SIZE, SL_ATT0, ..., SL_ATT3, MS_ADDR, MS_SIZE, MS_ATT0, ..., MS_ATT3 registers. Therefore, the access privileges for all these registers is determined by MS_ATT0, ..., MS_ATT3.</description>
                <bitRange>[28:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>VALID</name>
                <description>Master region enable:
'1': Enabled.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS_ATT0</name>
            <description>Master attributes 0</description>
            <addressOffset>0x30</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC0_UR</name>
                <description>Protection context 0, user read enable:
'0': Disabled (user, read acceses are NOT allowed).
'1': Enabled (user, read acceses are allowed).</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_UW</name>
                <description>Protection context 0, user write enable:
'0': Disabled (user, write acceses are NOT allowed).
'1': Enabled (user, write acceses are allowed).</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_PR</name>
                <description>Protection context 0, privileged read enable:
'0': Disabled (privileged, read acceses are NOT allowed).
'1': Enabled (privileged, read acceses are allowed).</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_PW</name>
                <description>Protection context 0, privileged write enable:
'0': Disabled (privileged, write acceses are NOT allowed).
'1': Enabled (privileged, write acceses are allowed).</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_NS</name>
                <description>Protection context 0, non-secure:
'0': Secure (secure accesses allowed, non-secure access NOT allowed).
'1': Non-secure (both secure and non-secure accesses allowed).</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC1_UR</name>
                <description>Protection context 1, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC1_UW</name>
                <description>Protection context 1, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC1_PR</name>
                <description>Protection context 1, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC1_PW</name>
                <description>Protection context 1, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC1_NS</name>
                <description>Protection context 1, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_UR</name>
                <description>Protection context 2, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC2_UW</name>
                <description>Protection context 2, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_PR</name>
                <description>Protection context 2, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC2_PW</name>
                <description>Protection context 2, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_NS</name>
                <description>Protection context 2, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_UR</name>
                <description>Protection context 3, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC3_UW</name>
                <description>Protection context 3, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_PR</name>
                <description>Protection context 3, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC3_PW</name>
                <description>Protection context 3, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_NS</name>
                <description>Protection context 3, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS_ATT1</name>
            <description>Master attributes 1</description>
            <addressOffset>0x34</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC4_UR</name>
                <description>Protection context 4, user read enable.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC4_UW</name>
                <description>Protection context 4, user write enable.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC4_PR</name>
                <description>Protection context 4, privileged read enable.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC4_PW</name>
                <description>Protection context 4, privileged write enable.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC4_NS</name>
                <description>Protection context 4, non-secure.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_UR</name>
                <description>Protection context 5, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC5_UW</name>
                <description>Protection context 5, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_PR</name>
                <description>Protection context 5, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC5_PW</name>
                <description>Protection context 5, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_NS</name>
                <description>Protection context 5, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_UR</name>
                <description>Protection context 6, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC6_UW</name>
                <description>Protection context 6, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_PR</name>
                <description>Protection context 6, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC6_PW</name>
                <description>Protection context 6, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_NS</name>
                <description>Protection context 6, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_UR</name>
                <description>Protection context 7, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC7_UW</name>
                <description>Protection context 7, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_PR</name>
                <description>Protection context 7, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC7_PW</name>
                <description>Protection context 7, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_NS</name>
                <description>Protection context 7, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS_ATT2</name>
            <description>Master attributes 2</description>
            <addressOffset>0x38</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC8_UR</name>
                <description>Protection context 8, user read enable.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC8_UW</name>
                <description>Protection context 8, user write enable.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC8_PR</name>
                <description>Protection context 8, privileged read enable.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC8_PW</name>
                <description>Protection context 8, privileged write enable.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC8_NS</name>
                <description>Protection context 8, non-secure.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_UR</name>
                <description>Protection context 9, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC9_UW</name>
                <description>Protection context 9, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_PR</name>
                <description>Protection context 9, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC9_PW</name>
                <description>Protection context 9, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_NS</name>
                <description>Protection context 9, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_UR</name>
                <description>Protection context 10, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC10_UW</name>
                <description>Protection context 10, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_PR</name>
                <description>Protection context 10, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC10_PW</name>
                <description>Protection context 10, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_NS</name>
                <description>Protection context 10, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_UR</name>
                <description>Protection context 11, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC11_UW</name>
                <description>Protection context 11, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_PR</name>
                <description>Protection context 11, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC11_PW</name>
                <description>Protection context 11, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_NS</name>
                <description>Protection context 11, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS_ATT3</name>
            <description>Master attributes 3</description>
            <addressOffset>0x3C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC12_UR</name>
                <description>Protection context 12, user read enable.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC12_UW</name>
                <description>Protection context 12, user write enable.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC12_PR</name>
                <description>Protection context 12, privileged read enable.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC12_PW</name>
                <description>Protection context 12, privileged write enable.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC12_NS</name>
                <description>Protection context 12, non-secure.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_UR</name>
                <description>Protection context 13, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC13_UW</name>
                <description>Protection context 13, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_PR</name>
                <description>Protection context 13, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC13_PW</name>
                <description>Protection context 13, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_NS</name>
                <description>Protection context 13, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_UR</name>
                <description>Protection context 14, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC14_UW</name>
                <description>Protection context 14, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_PR</name>
                <description>Protection context 14, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC14_PW</name>
                <description>Protection context 14, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_NS</name>
                <description>Protection context 14, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_UR</name>
                <description>Protection context 15, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC15_UW</name>
                <description>Protection context 15, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_PR</name>
                <description>Protection context 15, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC15_PW</name>
                <description>Protection context 15, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_NS</name>
                <description>Protection context 15, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>458</dim>
          <dimIncrement>64</dimIncrement>
          <name>PPU_FX[%s]</name>
          <description>Fixed protection structure pair</description>
          <addressOffset>0x00000800</addressOffset>
          <register>
            <name>SL_ADDR</name>
            <description>Slave region, base address</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFC</resetMask>
            <fields>
              <field>
                <name>ADDR30</name>
                <description>This field specifies the base address of the slave region. The region size is defined by SL_SIZE.REGION_SIZE. A region of n Bytes must be n Byte aligned. Therefore, some of the lesser significant address bits of ADDR30 must be '0's. E.g., a 64 KB address region (REGION_SIZE is '15') must be 64 KByte aligned, and ADDR30[13:0] must be '0's.</description>
                <bitRange>[31:2]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SL_SIZE</name>
            <description>Slave region, size</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x80000000</resetValue>
            <resetMask>0x9F000000</resetMask>
            <fields>
              <field>
                <name>REGION_SIZE</name>
                <description>This field specifies the size of the slave region:
'0': Undefined.
'1': 4 B region (this is the smallest region size).
'2': 8 B region
'3': 16 B region
'4': 32 B region
'5': 64 B region
'6': 128 B region
'7': 256 B region
'8': 512 B region
'9': 1 KB region
'10': 2 KB region
'11': 4 KB region
'12': 8 KB region
'13': 16 KB region
'14': 32 KB region
'15': 64 KB region
'16': 128 KB region
'17': 256 KB region
'18': 512 KB region
'19': 1 MB region
'20': 2 MB region
'21': 4 MB region
'22': 8 MB region
'23': 16 MB region
'24': 32 MB region
'25': 64 MB region
'26': 128 MB region
'27': 256 MB region
'28': 512 MB region
'29': 1 GB region
'30': 2 GB region
'31': 4 GB region</description>
                <bitRange>[28:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>VALID</name>
                <description>Slave region enable:
'0': Disabled. A disabled region will never result in a match on the transfer address.
'1': Enabled.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SL_ATT0</name>
            <description>Slave attributes 0</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC0_UR</name>
                <description>Protection context 0, user read enable:
'0': Disabled (user, read acceses are NOT allowed).
'1': Enabled (user, read acceses are allowed).</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_UW</name>
                <description>Protection context 0, user write enable:
'0': Disabled (user, write acceses are NOT allowed).
'1': Enabled (user, write acceses are allowed).</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_PR</name>
                <description>Protection context 0, privileged read enable:
'0': Disabled (privileged, read acceses are NOT allowed).
'1': Enabled (privileged, read acceses are allowed).</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_PW</name>
                <description>Protection context 0, privileged write enable:
'0': Disabled (privileged, write acceses are NOT allowed).
'1': Enabled (privileged, write acceses are allowed).</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_NS</name>
                <description>Protection context 0, non-secure:
'0': Secure (secure accesses allowed, non-secure access NOT allowed).
'1': Non-secure (both secure and non-secure accesses allowed).</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC1_UR</name>
                <description>Protection context 1, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC1_UW</name>
                <description>Protection context 1, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC1_PR</name>
                <description>Protection context 1, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC1_PW</name>
                <description>Protection context 1, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC1_NS</name>
                <description>Protection context 1, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_UR</name>
                <description>Protection context 2, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_UW</name>
                <description>Protection context 2, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_PR</name>
                <description>Protection context 2, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_PW</name>
                <description>Protection context 2, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_NS</name>
                <description>Protection context 2, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_UR</name>
                <description>Protection context 3, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_UW</name>
                <description>Protection context 3, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_PR</name>
                <description>Protection context 3, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_PW</name>
                <description>Protection context 3, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_NS</name>
                <description>Protection context 3, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SL_ATT1</name>
            <description>Slave attributes 1</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC4_UR</name>
                <description>Protection context 4, user read enable.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC4_UW</name>
                <description>Protection context 4, user write enable.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC4_PR</name>
                <description>Protection context 4, privileged read enable.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC4_PW</name>
                <description>Protection context 4, privileged write enable.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC4_NS</name>
                <description>Protection context 4, non-secure.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_UR</name>
                <description>Protection context 5, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_UW</name>
                <description>Protection context 5, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_PR</name>
                <description>Protection context 5, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_PW</name>
                <description>Protection context 5, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_NS</name>
                <description>Protection context 5, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_UR</name>
                <description>Protection context 6, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_UW</name>
                <description>Protection context 6, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_PR</name>
                <description>Protection context 6, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_PW</name>
                <description>Protection context 6, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_NS</name>
                <description>Protection context 6, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_UR</name>
                <description>Protection context 7, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_UW</name>
                <description>Protection context 7, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_PR</name>
                <description>Protection context 7, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_PW</name>
                <description>Protection context 7, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_NS</name>
                <description>Protection context 7, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SL_ATT2</name>
            <description>Slave attributes 2</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC8_UR</name>
                <description>Protection context 8, user read enable.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC8_UW</name>
                <description>Protection context 8, user write enable.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC8_PR</name>
                <description>Protection context 8, privileged read enable.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC8_PW</name>
                <description>Protection context 8, privileged write enable.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC8_NS</name>
                <description>Protection context 8, non-secure.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_UR</name>
                <description>Protection context 9, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_UW</name>
                <description>Protection context 9, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_PR</name>
                <description>Protection context 9, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_PW</name>
                <description>Protection context 9, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_NS</name>
                <description>Protection context 9, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_UR</name>
                <description>Protection context 10, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_UW</name>
                <description>Protection context 10, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_PR</name>
                <description>Protection context 10, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_PW</name>
                <description>Protection context 10, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_NS</name>
                <description>Protection context 10, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_UR</name>
                <description>Protection context 11, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_UW</name>
                <description>Protection context 11, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_PR</name>
                <description>Protection context 11, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_PW</name>
                <description>Protection context 11, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_NS</name>
                <description>Protection context 11, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SL_ATT3</name>
            <description>Slave attributes 3</description>
            <addressOffset>0x1C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC12_UR</name>
                <description>Protection context 12, user read enable.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC12_UW</name>
                <description>Protection context 12, user write enable.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC12_PR</name>
                <description>Protection context 12, privileged read enable.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC12_PW</name>
                <description>Protection context 12, privileged write enable.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC12_NS</name>
                <description>Protection context 12, non-secure.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_UR</name>
                <description>Protection context 13, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_UW</name>
                <description>Protection context 13, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_PR</name>
                <description>Protection context 13, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_PW</name>
                <description>Protection context 13, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_NS</name>
                <description>Protection context 13, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_UR</name>
                <description>Protection context 14, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_UW</name>
                <description>Protection context 14, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_PR</name>
                <description>Protection context 14, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_PW</name>
                <description>Protection context 14, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_NS</name>
                <description>Protection context 14, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_UR</name>
                <description>Protection context 15, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_UW</name>
                <description>Protection context 15, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_PR</name>
                <description>Protection context 15, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_PW</name>
                <description>Protection context 15, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_NS</name>
                <description>Protection context 15, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS_ADDR</name>
            <description>Master region, base address</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFC0</resetMask>
            <fields>
              <field>
                <name>ADDR26</name>
                <description>This field specifies the base address of the master region. The base address of the region is the address of the SL_ADDR register.</description>
                <bitRange>[31:6]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS_SIZE</name>
            <description>Master region, size</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x85000000</resetValue>
            <resetMask>0x9F000000</resetMask>
            <fields>
              <field>
                <name>REGION_SIZE</name>
                <description>This field specifies the size of the master region:
'5': 64 B region

The master region includes the SL_ADDR, SL_SIZE, SL_ATT0, ..., SL_ATT3, MS_ADDR, MS_SIZE, MS_ATT0, ..., MS_ATT3 registers. Therefore, the access privileges for all these registers is determined by MS_ATT0, ..., MS_ATT3.</description>
                <bitRange>[28:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>VALID</name>
                <description>Master region enable:
'1': Enabled.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS_ATT0</name>
            <description>Master attributes 0</description>
            <addressOffset>0x30</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC0_UR</name>
                <description>Protection context 0, user read enable:
'0': Disabled (user, read acceses are NOT allowed).
'1': Enabled (user, read acceses are allowed).</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_UW</name>
                <description>Protection context 0, user write enable:
'0': Disabled (user, write acceses are NOT allowed).
'1': Enabled (user, write acceses are allowed).</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_PR</name>
                <description>Protection context 0, privileged read enable:
'0': Disabled (privileged, read acceses are NOT allowed).
'1': Enabled (privileged, read acceses are allowed).</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_PW</name>
                <description>Protection context 0, privileged write enable:
'0': Disabled (privileged, write acceses are NOT allowed).
'1': Enabled (privileged, write acceses are allowed).</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_NS</name>
                <description>Protection context 0, non-secure:
'0': Secure (secure accesses allowed, non-secure access NOT allowed).
'1': Non-secure (both secure and non-secure accesses allowed).</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC1_UR</name>
                <description>Protection context 1, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC1_UW</name>
                <description>Protection context 1, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC1_PR</name>
                <description>Protection context 1, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC1_PW</name>
                <description>Protection context 1, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC1_NS</name>
                <description>Protection context 1, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_UR</name>
                <description>Protection context 2, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC2_UW</name>
                <description>Protection context 2, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_PR</name>
                <description>Protection context 2, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC2_PW</name>
                <description>Protection context 2, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_NS</name>
                <description>Protection context 2, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_UR</name>
                <description>Protection context 3, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC3_UW</name>
                <description>Protection context 3, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_PR</name>
                <description>Protection context 3, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC3_PW</name>
                <description>Protection context 3, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_NS</name>
                <description>Protection context 3, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS_ATT1</name>
            <description>Master attributes 1</description>
            <addressOffset>0x34</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC4_UR</name>
                <description>Protection context 4, user read enable.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC4_UW</name>
                <description>Protection context 4, user write enable.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC4_PR</name>
                <description>Protection context 4, privileged read enable.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC4_PW</name>
                <description>Protection context 4, privileged write enable.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC4_NS</name>
                <description>Protection context 4, non-secure.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_UR</name>
                <description>Protection context 5, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC5_UW</name>
                <description>Protection context 5, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_PR</name>
                <description>Protection context 5, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC5_PW</name>
                <description>Protection context 5, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_NS</name>
                <description>Protection context 5, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_UR</name>
                <description>Protection context 6, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC6_UW</name>
                <description>Protection context 6, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_PR</name>
                <description>Protection context 6, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC6_PW</name>
                <description>Protection context 6, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_NS</name>
                <description>Protection context 6, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_UR</name>
                <description>Protection context 7, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC7_UW</name>
                <description>Protection context 7, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_PR</name>
                <description>Protection context 7, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC7_PW</name>
                <description>Protection context 7, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_NS</name>
                <description>Protection context 7, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS_ATT2</name>
            <description>Master attributes 2</description>
            <addressOffset>0x38</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC8_UR</name>
                <description>Protection context 8, user read enable.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC8_UW</name>
                <description>Protection context 8, user write enable.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC8_PR</name>
                <description>Protection context 8, privileged read enable.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC8_PW</name>
                <description>Protection context 8, privileged write enable.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC8_NS</name>
                <description>Protection context 8, non-secure.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_UR</name>
                <description>Protection context 9, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC9_UW</name>
                <description>Protection context 9, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_PR</name>
                <description>Protection context 9, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC9_PW</name>
                <description>Protection context 9, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_NS</name>
                <description>Protection context 9, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_UR</name>
                <description>Protection context 10, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC10_UW</name>
                <description>Protection context 10, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_PR</name>
                <description>Protection context 10, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC10_PW</name>
                <description>Protection context 10, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_NS</name>
                <description>Protection context 10, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_UR</name>
                <description>Protection context 11, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC11_UW</name>
                <description>Protection context 11, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_PR</name>
                <description>Protection context 11, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC11_PW</name>
                <description>Protection context 11, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_NS</name>
                <description>Protection context 11, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS_ATT3</name>
            <description>Master attributes 3</description>
            <addressOffset>0x3C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC12_UR</name>
                <description>Protection context 12, user read enable.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC12_UW</name>
                <description>Protection context 12, user write enable.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC12_PR</name>
                <description>Protection context 12, privileged read enable.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC12_PW</name>
                <description>Protection context 12, privileged write enable.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC12_NS</name>
                <description>Protection context 12, non-secure.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_UR</name>
                <description>Protection context 13, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC13_UW</name>
                <description>Protection context 13, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_PR</name>
                <description>Protection context 13, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC13_PW</name>
                <description>Protection context 13, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_NS</name>
                <description>Protection context 13, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_UR</name>
                <description>Protection context 14, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC14_UW</name>
                <description>Protection context 14, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_PR</name>
                <description>Protection context 14, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC14_PW</name>
                <description>Protection context 14, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_NS</name>
                <description>Protection context 14, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_UR</name>
                <description>Protection context 15, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC15_UW</name>
                <description>Protection context 15, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_PR</name>
                <description>Protection context 15, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC15_PW</name>
                <description>Protection context 15, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_NS</name>
                <description>Protection context 15, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>CRYPTO</name>
      <description>Cryptography component</description>
      <baseAddress>0x40100000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTL</name>
          <description>Control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x10002</resetValue>
          <resetMask>0x800300F3</resetMask>
          <fields>
            <field>
              <name>P</name>
              <description>User/privileged access control:
'0': user mode.
'1': privileged mode.

This field is set with the user/privileged access control of the transaction that writes this register; i.e. the access control is inherited from the write transaction and not specified by the transaction write data.

All IP master transactions use the P field for the user/privileged access control ('hprot[1]').</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NS</name>
              <description>Secure/on-secure access control:
'0': secure.
'1': non-secure.

This field is set with the secure/non-secure access control of the transaction that writes this register; i.e. the access control is inherited from the write transaction and not specified by the transaction write data.

All IP master transactions use the NS field for the secure/non-secure access control ('hprot[4]').</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PC</name>
              <description>Protection context.

This field is set with the protection context of the transaction that writes this register; i.e. the context is inherited from the write transaction and not specified by the transaction write data.

All IP master transactions use the PC field for the protection context. There is one exception: the LOAD_DEV_KEY instruction IP master transactions are always performed with protection context '0'.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_EN</name>
              <description>Enable ECC checking:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_INJ_EN</name>
              <description>Enable parity injection for SRAM.
When '1', the parity (ECC_CTL.PARITY) is used when a full 32-bit write is done to the ECC_CTL.WORD_ADDR word address of the SRAM.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>IP enable:
'0': Disabled. All non-retention registers (command and status registers, instruct FIFO, internal component state machines) are reset to their default value when the IP is disabled. All retention registers retain their value when the IP is disabled.
'1': Enabled. When the the IP is enabled, the IP register buffer is set to '0'.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM_PWR_CTL</name>
          <description>SRAM power control</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>PWR_MODE</name>
              <description>Set power mode for memory buffer SRAM.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>See CM4_PWR_CTL</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD</name>
                  <description>undefined</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RETAINED</name>
                  <description>See CM4_PWR_CTL</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>See CM4_PWR_CTL</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM_PWR_DELAY_CTL</name>
          <description>SRAM power delay control</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x96</resetValue>
          <resetMask>0x3FF</resetMask>
          <fields>
            <field>
              <name>UP</name>
              <description>Number clock cycles delay needed after power domain power up</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ECC_CTL</name>
          <description>ECC control</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFE001FFF</resetMask>
          <fields>
            <field>
              <name>WORD_ADDR</name>
              <description>Specifies the word address where the parity is injected.
- On a 32-bit write access to this SRAM address and when CTL.ECC_INJ_EN bit is '1', the parity (PARITY) is injected.</description>
              <bitRange>[12:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY</name>
              <description>ECC parity to use for ECC error injection at address WORD_ADDR.</description>
              <bitRange>[31:25]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ERROR_STATUS0</name>
          <description>Error status 0</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA32</name>
              <description>Specifies error description information.
- For INSTR_OPC_ERROR/ INSTR_CC_ERROR/ INSTR_DEV_KEY_ERROR:
  - Violating instruction (from instruction FIFO).
- For BUS_ERROR:
  - Violating transfer, address.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ERROR_STATUS1</name>
          <description>Error status 1</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>DATA24</name>
              <description>Specifies error description information.
- For BUS_ERROR:
  - Violating transfer, read attribute (DATA[0]).
  - Violating transfer, size attribute (DATA[5:4]). '0': 8-bit transfer, '1': 16 bits transfer, '2': 32-bit transfer.</description>
              <bitRange>[23:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IDX</name>
              <description>Error source:
'0': INSTR_OPC_ERROR (instuction FIFO decoder error).
'1': INSTR_CC_ERROR (instruction FIFO decoder, VU CC error).
'2': BUS_ERROR (bus master interface AHB-Lite bus error).
'3': TR_AP_DETECT_ERROR.
'4': TR_RC_DETECT_ERROR.
'5': INSTR_DEV_KEY_ERROR.
'6'-'7': Undefined.</description>
              <bitRange>[26:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>VALID</name>
              <description>Specifies if ERROR_STATUS0 and ERROR_STATUS1 specify valid error information. No new error information is captured as long as VALID is '1'; i.e. the error information of the first detected error is NOT overwritten.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR</name>
          <description>Interrupt register</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F001F</resetMask>
          <fields>
            <field>
              <name>INSTR_FF_LEVEL</name>
              <description>This interrupt cause is activated (HW sets the field to '1') when the instruction FIFO event is activated.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INSTR_FF_OVERFLOW</name>
              <description>This interrupt cause is activated (HW sets the field to '1') when the instruction FIFO overflows (an attempt is made to write to a full FIFO).</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_INITIALIZED</name>
              <description>This interrupt cause is activated (HW sets the field to '1') when the true random number generator is initialized.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_DATA_AVAILABLE</name>
              <description>This interrupt cause is activated (HW sets the field to '1') when the true random number generator has generated a data value of the specified bit size.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PR_DATA_AVAILABLE</name>
              <description>This interrupt cause is activated (HW sets the field to '1') when the pseudo random number generator has generated a data value.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INSTR_OPC_ERROR</name>
              <description>This interrupt cause is activated (HW sets the field to '1') when the instruction decoder encounters an instruction with a non-defined operation code (opcode). 

When the interrupt cause is activated, HW sets INSTR_FF_CTL.CLEAR to '1'.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INSTR_CC_ERROR</name>
              <description>This interrupt cause is activated (HW sets the field to '1') when the instruction decoder encounters an instruction with a non-defined condition code. This error is only generated for VU instructions. 

When the interrupt cause is activated, HW sets INSTR_FF_CTL.CLEAR to '1'.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BUS_ERROR</name>
              <description>This interrupt cause is activated (HW sets the field to '1') when a AHB-Lite bus error is observed on the AHB-Lite master interface. 

When the interrupt cause is activated, HW sets INSTR_FF_CTL.CLEAR to '1'.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_AP_DETECT_ERROR</name>
              <description>This interrupt cause is activated (HW sets the field to '1') when the true random number generator monitor adaptive proportion test detects a repetition of a specific bit value.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_RC_DETECT_ERROR</name>
              <description>This interrupt cause is activated (HW sets the field to '1') when the true random number generator monitor adaptive proportion test detects a disproportionate occurrence of a specific bit value.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INSTR_DEV_KEY_ERROR</name>
              <description>This interrupt cause is activated (HW sets the field to '1') when the LOAD_DEV_KEY instruction tries to load a device key whose DEV_KEY_ADDR_CTL.VALID or DEV_KEY_CTL.ALLOWED is set to '0'.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SET</name>
          <description>Interrupt set register</description>
          <addressOffset>0x104</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F001F</resetMask>
          <fields>
            <field>
              <name>INSTR_FF_LEVEL</name>
              <description>SW writes a '1' to this field to set the corresponding field in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INSTR_FF_OVERFLOW</name>
              <description>SW writes a '1' to this field to set the corresponding field in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_INITIALIZED</name>
              <description>SW writes a '1' to this field to set the corresponding field in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_DATA_AVAILABLE</name>
              <description>SW writes a '1' to this field to set the corresponding field in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PR_DATA_AVAILABLE</name>
              <description>SW writes a '1' to this field to set the corresponding field in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INSTR_OPC_ERROR</name>
              <description>SW writes a '1' to this field to set the corresponding field in interrupt request register.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INSTR_CC_ERROR</name>
              <description>SW writes a '1' to this field to set the corresponding field in interrupt request register.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BUS_ERROR</name>
              <description>SW writes a '1' to this field to set the corresponding field in interrupt request register.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_AP_DETECT_ERROR</name>
              <description>SW writes a '1' to this field to set the corresponding field in interrupt request register.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_RC_DETECT_ERROR</name>
              <description>SW writes a '1' to this field to set the corresponding field in interrupt request register.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INSTR_DEV_KEY_ERROR</name>
              <description>SW writes a '1' to this field to set the corresponding field in interrupt request register.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASK</name>
          <description>Interrupt mask register</description>
          <addressOffset>0x108</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F001F</resetMask>
          <fields>
            <field>
              <name>INSTR_FF_LEVEL</name>
              <description>Mask bit for corresponding field in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INSTR_FF_OVERFLOW</name>
              <description>Mask bit for corresponding field in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_INITIALIZED</name>
              <description>Mask bit for corresponding field in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_DATA_AVAILABLE</name>
              <description>Mask bit for corresponding field in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PR_DATA_AVAILABLE</name>
              <description>Mask bit for corresponding field in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INSTR_OPC_ERROR</name>
              <description>Mask bit for corresponding field in interrupt request register.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INSTR_CC_ERROR</name>
              <description>Mask bit for corresponding field in interrupt request register.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BUS_ERROR</name>
              <description>Mask bit for corresponding field in interrupt request register.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_AP_DETECT_ERROR</name>
              <description>Mask bit for corresponding field in interrupt request register.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_RC_DETECT_ERROR</name>
              <description>Mask bit for corresponding field in interrupt request register.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INSTR_DEV_KEY_ERROR</name>
              <description>Mask bit for corresponding field in interrupt request register.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASKED</name>
          <description>Interrupt masked register</description>
          <addressOffset>0x10C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F001F</resetMask>
          <fields>
            <field>
              <name>INSTR_FF_LEVEL</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INSTR_FF_OVERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TR_INITIALIZED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TR_DATA_AVAILABLE</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PR_DATA_AVAILABLE</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INSTR_OPC_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INSTR_CC_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BUS_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TR_AP_DETECT_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TR_RC_DETECT_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INSTR_DEV_KEY_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PR_LFSR_CTL0</name>
          <description>Pseudo random LFSR control 0</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xD8959BC9</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LFSR32</name>
              <description>State of a 32-bit Linear Feedback Shift Registers (LFSR) that is used to generate a pseudo random bit sequence. This register needs to be initialized by SW. The initialization value should be different from '0'.

The three PR_LFSR_CTL registers represents the state of a 32-bit, 31-bit and 29-bit LFSR. Individually, these LFSRs generate a pseudo random bit sequence that repeats itself after (2^32)-1, (2^31)-1 and (2^29)-1 bits. The numbers (2^32)-1, (2^31)-1 and (2^29)-1 are relatively prime (their greatest common denominator is '1'). The three bit sequence are combined (XOR'd) into a single bitstream to create a pseudo random bit sequence that repeats itself after ((2^32)-1) * ((2^31)-1) * ((2*29)-1) bits.

The following polynomials are used:
- 32-bit irreducible polynomial: x^32+x^30+x^26+x^25+1.
- 31-bit irreducible polynomial: x^31+x^28+1.
- 29-bit irreducible polynomial: x^29+x^27+1.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PR_LFSR_CTL1</name>
          <description>Pseudo random LFSR control 1</description>
          <addressOffset>0x204</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2BB911F8</resetValue>
          <resetMask>0x7FFFFFFF</resetMask>
          <fields>
            <field>
              <name>LFSR31</name>
              <description>State of a 31-bit Linear Feedback Shift Registers (LFSR) that is used to generate a pseudo random bit sequence. See PR_LFSR_CTL0.</description>
              <bitRange>[30:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PR_LFSR_CTL2</name>
          <description>Pseudo random LFSR control 2</description>
          <addressOffset>0x208</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x60C31B7</resetValue>
          <resetMask>0x1FFFFFFF</resetMask>
          <fields>
            <field>
              <name>LFSR29</name>
              <description>State of a 29-bit Linear Feedback Shift Registers (LFSR) that is used to generate a pseudo random bit sequence. See PR_LFSR_CTL0.</description>
              <bitRange>[28:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PR_MAX_CTL</name>
          <description>Pseudo random maximum control</description>
          <addressOffset>0x20C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA32</name>
              <description>Maximum value of to be generated random number</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PR_CMD</name>
          <description>Pseudo random command</description>
          <addressOffset>0x210</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>START</name>
              <description>Pseudo random command. On a generated number, HW sets this field to '0' and sets INTR.PR_DATA_AVAILABLE to '1.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PR_RESULT</name>
          <description>Pseudo random result</description>
          <addressOffset>0x218</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA32</name>
              <description>Result of a pseudo random number generation operation. The resulting value DATA is in the range [0, PR_MAX_CTL.DATA32]. The PR_DATA_AVAILABLE interrupt cause is activated when the number is generated.

Note that SW can write this field. This functionality can be used prevent information leakage.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TR_CTL0</name>
          <description>True random control 0</description>
          <addressOffset>0x280</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x30000</resetValue>
          <resetMask>0x31FFFFFF</resetMask>
          <fields>
            <field>
              <name>SAMPLE_CLOCK_DIV</name>
              <description>Specifies the clock divider that is used to sample oscillator data. This clock divider is wrt. 'clk_sys'.
'0': sample clock is 'clk_sys'.
'1': sample clock is 'clk_sys'/2.
...
'255': sample clock is 'clk_sys'/256.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RED_CLOCK_DIV</name>
              <description>Specifies the clock divider that is used to produce reduced bits. 
'0': 1 reduced bit is produced for each sample.
'1': 1 reduced bit is produced for each 2 samples.
...
'255': 1 reduced bit is produced for each 256 samples.

The reduced bits are considered random bits and shifted into TR_RESULT0.DATA32.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INIT_DELAY</name>
              <description>Specifies an initialization delay: number of removed/dropped samples before reduced bits are generated. This field should be programmed in the range [1, 255]. After starting the oscillators, at least the first 2 samples should be removed/dropped to clear the state of internal synchronizers. In addition, it is advised to drop at least the second 2 samples from the oscillators (to circumvent the semi-predictable oscillator startup behavior). This result in the default field value of '3'. Field encoding is as follows:
'0': 1 sample is dropped.
'1': 2 samples are dropped.
...
'255': 256 samples are dropped.

The TR_INITIALIZED interrupt cause is set to '1', when the initialization delay is passed.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VON_NEUMANN_CORR</name>
              <description>Specifies if the 'von Neumann corrector' is disabled or enabled:
'0': disabled.
'1': enabled.
The 'von Neumann corrector' post-processes the reduced bits to remove a '0' or '1' bias. The corrector operates on reduced bit pairs ('oldest bit, newest bit'):
'00': no bit is produced.
'01': '0' bit is produced (oldest bit).
'10': '1' bit is produced (oldest bit).
'11': no bit is produced.
Note that the corrector produces bits at a random pace and at a frequency that is 1/4 of the reduced bit frequency (reduced bits are processed in pairs, and half of the pairs do NOT produce a bit).</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STOP_ON_AP_DETECT</name>
              <description>Specifies if TRNG functionality is stopped on an adaptive proportion test detection (when HW sets INTR.TR_AP_DETECT to '1'):
'0': Functionality is NOT stopped.
'1': Functionality is stopped (TR_CTL1 fields are set to '0' by HW).</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STOP_ON_RC_DETECT</name>
              <description>Specifies if TRNG functionality is stopped on a repetition count test detection (when HW sets INTR.TR_RC_DETECT to '1'):
'0': Functionality is NOT stopped.
'1': Functionality is stopped (TR_CTL1 fields are set to '0' by HW).</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TR_CTL1</name>
          <description>True random control 1</description>
          <addressOffset>0x284</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>RO11_EN</name>
              <description>FW sets this field to '1' to enable the ring oscillator with 11 inverters.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RO15_EN</name>
              <description>FW sets this field to '1' to enable the ring oscillator with 15 inverters.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GARO15_EN</name>
              <description>FW sets this field to '1' to enable the fixed Galois ring oscillator with 15 inverters.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GARO31_EN</name>
              <description>FW sets this field to '1' to enable the programmable Galois ring oscillator with up to 31 inverters. The TR_GARO_CTL register specifies the programmable polynomial.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FIRO15_EN</name>
              <description>FW sets this field to '1' to enable the fixed Fibonacci ring oscillator with 15 inverters.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FIRO31_EN</name>
              <description>FW sets this field to '1' to enable the programmable Fibonacci ring oscillator with up to 31 inverters. The TR_FIRO_CTL register specifies the programmable polynomial.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TR_CTL2</name>
          <description>True random control 2</description>
          <addressOffset>0x288</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>SIZE</name>
              <description>Bit size of generated random number in TR_RESULT. Legal range is in [0, 32].</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TR_STATUS</name>
          <description>True random status</description>
          <addressOffset>0x28C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>INITIALIZED</name>
              <description>Reflects the state of the true random number generator:
'0': Not initialized (TR_CTL0.INIT_DELAY has NOT passed).
'1': Initialized (TR_CTL0.INIT_DELAY has passed).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TR_CMD</name>
          <description>True random command</description>
          <addressOffset>0x290</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>START</name>
              <description>True random command. On a generated number, HW sets this field to '0' and sets INTR.TR_DATA_AVAILABLE to '1. 

Note: on a RC or AP error, HW sets this field to '0'.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TR_RESULT</name>
          <description>True random result</description>
          <addressOffset>0x298</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA32</name>
              <description>Generated true random number. HW generates the number in the least significant bit positions (TR_CTL2.SIZE) of this field. The TR_DATA_AVAILABLE interrupt cause is activated when the number is generated.

Note that SW can write this field. This functionality can be used prevent information leakage.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TR_GARO_CTL</name>
          <description>True random GARO control</description>
          <addressOffset>0x2A0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7FFFFFFF</resetMask>
          <fields>
            <field>
              <name>POLYNOMIAL31</name>
              <description>Polynomial for programmable Galois ring oscillator. The polynomial is represented WITHOUT the high order bit (this bit is always assumed '1'). The polynomial should be aligned such that the more significant bits (bit 30 and down) contain the polynomial and the less significant bits (bit 0 and up) contain padding '0's.</description>
              <bitRange>[30:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TR_FIRO_CTL</name>
          <description>True random FIRO control</description>
          <addressOffset>0x2A4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7FFFFFFF</resetMask>
          <fields>
            <field>
              <name>POLYNOMIAL31</name>
              <description>Polynomial for programmable Fibonacci ring oscillator. The polynomial is represented WITHOUT the high order bit (this bit is always assumed '1'). The polynomial should be aligned such that the more significant bits (bit 30 and down) contain the polynomial and the less significant bits (bit 0 and up) contain padding '0's.</description>
              <bitRange>[30:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TR_MON_CTL</name>
          <description>True random monitor control</description>
          <addressOffset>0x2C0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>BITSTREAM_SEL</name>
              <description>Selection of the bitstream:
'0': DAS bitstream.
'1': RED bitstream.
'2': TR bitstream.
'3': Undefined.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TR_MON_CMD</name>
          <description>True random monitor command</description>
          <addressOffset>0x2C8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>START_AP</name>
              <description>Adaptive proportion (AP) test enable:
'0': Stopped.
'1': Started.

On a AP detection, HW sets this field to '0' and sets INTR.TR_AP_DETECT to '1.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>START_RC</name>
              <description>Repetition count (RC) test enable:
'0': Disabled.
'1': Enabled.

On a RC detection, HW sets this field to '0' and sets INTR.TR_RC_DETECT to '1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TR_MON_RC_CTL</name>
          <description>True random monitor RC control</description>
          <addressOffset>0x2D0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFF</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>CUTOFF_COUNT8</name>
              <description>Cutoff count (legal range is [1, 255]):
'0': Illegal.
'1': 1 repetition.
...
'255': 255 repetitions.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TR_MON_RC_STATUS0</name>
          <description>True random monitor RC status 0</description>
          <addressOffset>0x2D8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>BIT</name>
              <description>Current active bit value:
'0': '0'.
'1': '1'.

This field is only valid when TR_MON_RC_STATUS1.REP_COUNT is NOT equal to '0'.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TR_MON_RC_STATUS1</name>
          <description>True random monitor RC status 1</description>
          <addressOffset>0x2DC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>REP_COUNT</name>
              <description>Number of repetitions of the current active bit counter:
'0': 0 repetitions.
...
'255': 255 repetitions.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TR_MON_AP_CTL</name>
          <description>True random monitor AP control</description>
          <addressOffset>0x2E0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CUTOFF_COUNT16</name>
              <description>Cutoff count (legal range is [1, 65535]).
'0': Illegal.
'1': 1 occurance.
...
'65535': 65535 occurances.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WINDOW_SIZE</name>
              <description>Window size (minus 1) :
'0': 1 bit.
...
'65535': 65536 bits.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TR_MON_AP_STATUS0</name>
          <description>True random monitor AP status 0</description>
          <addressOffset>0x2E8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>BIT</name>
              <description>Current active bit value:
'0': '0'.
'1': '1'.

This field is only valid when TR_MON_AP_STATUS1.OCC_COUNT is NOT equal to '0'.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TR_MON_AP_STATUS1</name>
          <description>True random monitor AP status 1</description>
          <addressOffset>0x2EC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OCC_COUNT</name>
              <description>Number of occurances of the current active bit counter:
'0': 0 occurances
...
'65535': 65535 occurances</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>WINDOW_INDEX</name>
              <description>Counter to keep track of the current index in the window (counts down from TR_MON_AP_CTL.WINDOW_SIZE to '0').</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>Status</description>
          <addressOffset>0x1004</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>BUSY</name>
              <description>Reflects the state of the IP:
'0': Idle/no busy.
'1': Busy:
  - Instruction is pending in the instruction FIFO.
  - Instruction is busy in a IP component.
  - Store FIFO is busy.
  - TR or PR command is busy.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INSTR_FF_CTL</name>
          <description>Instruction FIFO control</description>
          <addressOffset>0x1040</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x20000</resetValue>
          <resetMask>0x30007</resetMask>
          <fields>
            <field>
              <name>EVENT_LEVEL</name>
              <description>Event level. When the number of entries in the instruction FIFO is less than the amount of this field, an event is generated:
- 'event' = INSTR_FF_STATUS.USED &lt; EVENT_LEVEL.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLEAR</name>
              <description>When '1', the instruction FIFO is cleared/invalidated. Invalidation will last for as long as this field is '1'. If a quick clear/invalidation is required, the field should be set to '1' and be followed by a set to '0'. If a clear/invalidation is required for an extended time period, the field should be set to '1' during the complete time period.

HW sets this field to '1' on when a INSTR_OPC_ERROR, INSTR_CC_ERROR or BUS_ERROR interrupt cause is activated.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCK</name>
              <description>This field specifies the behavior when an instruction is written to a full FIFO (INSTR_FIFO_WR MMIO register):
'0': The write is ignored/dropped and the INTR.INSTR_FF_OVERFLOW interrupt cause is set to '1'.
'1': The write is blocked, resulting in AHB-Lite wait states and the INTR.INSTR_FF_OVERFLOW interrupt cause is set to '1' (this cause may be masked out). The instruction is written to the FIFO as soon as a FIFO entry becomes available. The maximum time is roughly the time of the execution of the slowest/longest instruction. Note that this setting may 'lock up' the CPU. When the CPU is 'locked up' it can not respond to interrupts. As a result, the interrupt latency is increased.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INSTR_FF_STATUS</name>
          <description>Instruction FIFO status</description>
          <addressOffset>0x1044</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1000F</resetMask>
          <fields>
            <field>
              <name>USED</name>
              <description>Number of instructions in the instruction FIFO. The value of this field ranges from 0 to 8.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EVENT</name>
              <description>Instruction FIFO  event.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INSTR_FF_WR</name>
          <description>Instruction FIFO write</description>
          <addressOffset>0x1048</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA32</name>
              <description>Instruction or instruction operand data that is written to the instruction FIFO.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LOAD0_FF_STATUS</name>
          <description>Load 0 FIFO status</description>
          <addressOffset>0x10C0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x8000001F</resetMask>
          <fields>
            <field>
              <name>USED5</name>
              <description>Number of Bytes in the FIFO. The value of this field is in the range [0, 19].</description>
              <bitRange>[4:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BUSY</name>
              <description>Reflects the state of the FIFO:
'0': FIFO load engine is idle and a new FIFO instruction can be accepted.
'1': FIFO load engine is busy and NO new FIFO instruction can be accepted.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LOAD1_FF_STATUS</name>
          <description>Load 1 FIFO status</description>
          <addressOffset>0x10D0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x8000001F</resetMask>
          <fields>
            <field>
              <name>USED5</name>
              <description>See LOAD1_FF_STATUS.USED.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BUSY</name>
              <description>See LOAD1_FF_STATUS.BUSY.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STORE_FF_STATUS</name>
          <description>Store FIFO status</description>
          <addressOffset>0x10F0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x8000001F</resetMask>
          <fields>
            <field>
              <name>USED5</name>
              <description>Number of Bytes in the FIFO. The value of this field is in the range [0, 16].</description>
              <bitRange>[4:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BUSY</name>
              <description>Reflects the state of the FIFO:
'0': FIFO store engine is idle and a new FIFO instruction can be accepted (USED is '0').
'1': FIFO store engine is busy and NO new FIFO instruction can be accepted.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AES_CTL</name>
          <description>AES control</description>
          <addressOffset>0x1100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>KEY_SIZE</name>
              <description>AES key size:
'0': 128-bit key, 10 rounds AES (inverse) cipher operation. 
'1': 192-bit key, 12 rounds AES (inverse) cipher operation. 
'2': 256-bit key, 14 rounds AES (inverse) cipher operation. 
'3': Undefined</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>AES128</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AES192</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AES256</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RESULT</name>
          <description>Result</description>
          <addressOffset>0x1180</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>BLOCK_CMP operation (DATA[0]):
'0': source 0 equals source 1.
'1': source 0 does NOT equal source 1.

CRC operation (DATA[31:0]). State of a 32-bit Linear Feedback Shift Registers (LFSR) that is used to implement CRC. This register needs to be initialized by SW to provide the CRC seed value.

The seed value should be aligned such that the more significant bits (bit 31 and down) contain the seed value and the less significant bits (bit 0 and up) contain padding '0's.  

Note that SW can write this field. This functionality can be used prevent information leakage.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_CTL</name>
          <description>CRC control</description>
          <addressOffset>0x1400</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x101</resetMask>
          <fields>
            <field>
              <name>DATA_REVERSE</name>
              <description>Specifies the bit order in which a data Byte is processed (reversal is performed after XORing):
'0': Most significant bit (bit 1) first.
'1': Least significant bit (bit 0) first.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REM_REVERSE</name>
              <description>Specifies whether the remainder is bit reversed (reversal is performed after XORing):
'0': No.
'1': Yes.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_DATA_CTL</name>
          <description>CRC data control</description>
          <addressOffset>0x1410</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>DATA_XOR</name>
              <description>Specifies a byte mask with which each data byte is XOR'd. The XOR is performed before data reversal.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_POL_CTL</name>
          <description>CRC polynomial control</description>
          <addressOffset>0x1420</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>POLYNOMIAL</name>
              <description>CRC polynomial. The polynomial is represented WITHOUT the high order bit (this bit is always assumed '1'). The polynomial should be aligned/shifted such that the more significant bits (bit 31 and down) contain the polynomial and the less significant bits (bit 0 and up) contain padding '0's. Some frequently used polynomials:
- CRC32: POLYNOMIAL is 0x04c11db7 (x^32 + x^26 + x^23 + x^22 + x^16 + x^12 + x^11 + x^10 + x^8 + x^7 + x^5 + x^4 + x^2 + x + 1).
- CRC16: POLYNOMIAL is 0x80050000 (x^16 + x^15 + x^2 + 1, shifted by 16 bit positions).
- CRC16 CCITT: POLYNOMIAL is 0x10210000 (x^16 + x^12 + x^5 + 1, shifted by 16 bit positions).</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_REM_CTL</name>
          <description>CRC remainder control</description>
          <addressOffset>0x1440</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REM_XOR</name>
              <description>Specifies a mask with which the CRC_LFSR_CTL.LFSR32 register is XOR'd to produce a remainder. The XOR is performed before remainder reversal.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_REM_RESULT</name>
          <description>CRC remainder result</description>
          <addressOffset>0x1448</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REM</name>
              <description>Remainder value. The alignment of the remainder depends on CRC_REM_CTL0.REM_REVERSE: 
'0': the more significant bits (bit 31 and down) contain the remainder.
'1': the less significant bits (bit 0 and up) contain the remainder. 

Note: This field is combinatorially derived from CRC_LFSR_CTL.LFSR32, CRC_REM_CTL0.REM_REVERSE and CRC_REM_CTL1.REM_XOR.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VU_CTL0</name>
          <description>Vector unit control 0</description>
          <addressOffset>0x1480</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>ALWAYS_EXECUTE</name>
              <description>Specifies if a conditional instruction is executed or not, when its condition code evaluates to false/'0'.
'0': The instruction is NOT executed. As a result, the instruction may be handled faster than when it is executed.
'1': The instruction is executed, but the execution result (including status field information) is not reflected in the IP. The instruction is handled just as fast as when it is executed.

Note: a conditional instruction with a condition code that evaluates to false/'0' does not affect the architectural state: VU_STATUS fields, memory or register-file data.

Note: Always execution is useful to prevent/complicate differential timing and differential power attacks.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VU_CTL1</name>
          <description>Vector unit control 1</description>
          <addressOffset>0x1484</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFF00</resetMask>
          <fields>
            <field>
              <name>ADDR24</name>
              <description>Specifies the memory address for the vector unit operand memory region. The register-file registers provide 13-bit word offsets witihin this memory region. Given ADDR[31:8], VU_VTL2.MASK[14:8] and a 13-bit word offset offset[14:2], a vector operand memory address VU_OPERAND_ADDR[31:0] is calculated as follows:
- VU_OPERAND_ADDR[31:15] = ADDR[31:15]
- VU_OPERAND_ADDR[14:8] = (ADDR[14:8] &amp; MASK[14:8]) | (offset[14:8] &amp; ~MASK[14:8])
- VU_OPERAND_ADDR[7:2] = offset[7:2]
- VU_OPERAND_ADDR[1:0] = 0 (always word aligned)

The vector unit operand memory region uses either the IP's memory buffer or system memory. For best performance, the IP's memory buffer should be used and ADDR should be set to MEM_BUFF and MASK should specify the IP memory buffer size. 

If a vector operand memory address is mapped on a memory hole, read accesses return a '0' and write accesses are ignored.</description>
              <bitRange>[31:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VU_CTL2</name>
          <description>Vector unit control 2</description>
          <addressOffset>0x1488</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x7F00</resetValue>
          <resetMask>0x7F00</resetMask>
          <fields>
            <field>
              <name>MASK</name>
              <description>Specifies the size of  the vector operand memory region. Legal values:
'0b0000000': 32 KB memory region (VU_VTL1.ADDR[14:8] ignored).
'0b1000000': 16 KB memory region (VU_VTL1.ADDR[13:8] ignored).
'0b1100000': 8 KB memory region (VU_VTL1.ADDR[12:8] ignored).
'0b1110000': 4 KB memory region (VU_VTL1.ADDR[11:8] ignored).
'0b1111000': 2 KB memory region (VU_VTL1.ADDR[10:8] ignored).
'0b1111100': 1 KB memory region (VU_VTL1.ADDR[9:8] ignored).
'0b1111110': 512 B memory region (VU_VTL1.ADDR[8] ignored).
'0b1111111': 256 B memory region.

Note: the default specifies a 256 B memory region.</description>
              <bitRange>[14:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VU_STATUS</name>
          <description>Vector unit status</description>
          <addressOffset>0x1490</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>CARRY</name>
              <description>STATUS CARRY field.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EVEN</name>
              <description>STATUS EVEN field.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ZERO</name>
              <description>STATUS ZERO field.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ONE</name>
              <description>STATUS ONE field.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>4</dimIncrement>
          <name>VU_RF_DATA[%s]</name>
          <description>Vector unit register-file</description>
          <addressOffset>0x14C0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA32</name>
              <description>Vector unit register-file data. A register-file register has the following layout:
DATA[28:16]: data (typically used as a word offset in vector unit operand memory).
DATA[12:0]: bit size minus 1.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DEV_KEY_ADDR0_CTL</name>
          <description>Device key address 0 control</description>
          <addressOffset>0x2000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Specifies if the address in the associated DEV_KEY_ADDR0 is valid:
'0': Address not valid; i.e. no device key specified.
'1': Address valid; i.e. device key specified.

Note: A LOAD_DEV_KEY instruction requires that the device key's valid field is '1'.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DEV_KEY_ADDR0</name>
          <description>Device key address 0</description>
          <addressOffset>0x2004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR32</name>
              <description>Specifies the memory address of the device key in memory. A LOAD_DEV_KEY instruction uses this address to load a device key from memory into the IP register buffer blocks 4 and 5.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DEV_KEY_ADDR1_CTL</name>
          <description>Device key address 1 control</description>
          <addressOffset>0x2020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>See DEV_KEY_ADDR0_CTL.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DEV_KEY_ADDR1</name>
          <description>Device key address 1 control</description>
          <addressOffset>0x2024</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR32</name>
              <description>See DEV_KEY_ADDR0.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DEV_KEY_STATUS</name>
          <description>Device key status</description>
          <addressOffset>0x2080</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>LOADED</name>
              <description>Specifies if a device key is present in the IP register buffer blocks 4 and 5.

HW sets this field to '1' on successful completion of a LOAD_DEV_KEY instruction.
HW clears this field to '0' when a CLEAR instruction is executed (the CLEAR instruciton also sets the IP register buffer to '0').</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DEV_KEY_CTL0</name>
          <description>Device key control 0</description>
          <addressOffset>0x2100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>ALLOWED</name>
              <description>Specifies if a LOAD_DEV_KEY instruction is allowed to use the device key in memory:
'0': Not allowed.
'1': Allowed.

Note: For successful completion of a LOAD_DEV_KEY instruction, both the associated DEV_KEY_ADDR_CTL.VALID and DEV_KEY_CTL.ALLOWED fields must be '1'. On successful instruction completion, DEV_KEY_STATUS.LOADED is set to '1'. On unsuccessful completion, the instruction FIFO is cleared and the IP is locked; an Active reset or an IP reset (CTL.ENABLED), which reinitializes the IP, is required.

Note: A LOAD_DEV_KEY loads the device key from memory with protection context '0'.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DEV_KEY_CTL1</name>
          <description>Device key control 1</description>
          <addressOffset>0x2120</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>ALLOWED</name>
              <description>See DEV_KEY_CTL0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>CPUSS</name>
      <description>CPU subsystem (CPUSS)</description>
      <baseAddress>0x40200000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>CPUIntIdx0</name>
        <description>CPU User Interrupt #0</description>
        <value>0</value>
      </interrupt>
      <interrupt>
        <name>CPUIntIdx1</name>
        <description>CPU User Interrupt #1</description>
        <value>1</value>
      </interrupt>
      <interrupt>
        <name>CPUIntIdx2</name>
        <description>CPU User Interrupt #2</description>
        <value>2</value>
      </interrupt>
      <interrupt>
        <name>CPUIntIdx3</name>
        <description>CPU User Interrupt #3</description>
        <value>3</value>
      </interrupt>
      <interrupt>
        <name>CPUIntIdx4</name>
        <description>CPU User Interrupt #4</description>
        <value>4</value>
      </interrupt>
      <interrupt>
        <name>CPUIntIdx5</name>
        <description>CPU User Interrupt #5</description>
        <value>5</value>
      </interrupt>
      <interrupt>
        <name>CPUIntIdx6</name>
        <description>CPU User Interrupt #6</description>
        <value>6</value>
      </interrupt>
      <interrupt>
        <name>CPUIntIdx7</name>
        <description>CPU User Interrupt #7</description>
        <value>7</value>
      </interrupt>
      <interrupt>
        <name>Internal0</name>
        <description>Internal SW Interrupt #0</description>
        <value>8</value>
      </interrupt>
      <interrupt>
        <name>Internal1</name>
        <description>Internal SW Interrupt #1</description>
        <value>9</value>
      </interrupt>
      <interrupt>
        <name>Internal2</name>
        <description>Internal SW Interrupt #2</description>
        <value>10</value>
      </interrupt>
      <interrupt>
        <name>Internal3</name>
        <description>Internal SW Interrupt #3</description>
        <value>11</value>
      </interrupt>
      <interrupt>
        <name>Internal4</name>
        <description>Internal SW Interrupt #4</description>
        <value>12</value>
      </interrupt>
      <interrupt>
        <name>Internal5</name>
        <description>Internal SW Interrupt #5</description>
        <value>13</value>
      </interrupt>
      <interrupt>
        <name>Internal6</name>
        <description>Internal SW Interrupt #6</description>
        <value>14</value>
      </interrupt>
      <interrupt>
        <name>Internal7</name>
        <description>Internal SW Interrupt #7</description>
        <value>15</value>
      </interrupt>
      <registers>
        <register>
          <name>IDENTITY</name>
          <description>Identity</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>P</name>
              <description>This field specifies the privileged setting ('0': user mode; '1': privileged mode) of the transfer that reads the register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NS</name>
              <description>This field specifies the security setting ('0': secure mode; '1': non-secure mode) of the transfer that reads the register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PC</name>
              <description>This field specifies the protection context of the transfer that reads the register.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MS</name>
              <description>This field specifies the bus master identifier of the transfer that reads the register.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_STATUS</name>
          <description>CM4 status</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x13</resetValue>
          <resetMask>0x13</resetMask>
          <fields>
            <field>
              <name>SLEEPING</name>
              <description>Specifies if the CPU is in Active, Sleep or DeepSleep power mode:
- Active power mode: SLEEPING is '0'.
- Sleep power mode: SLEEPING is '1' and SLEEPDEEP is '0'.
- DeepSleep power mode: SLEEPING is '1' and SLEEPDEEP is '1'.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SLEEPDEEP</name>
              <description>Specifies if the CPU is in Sleep or DeepSleep power mode. See SLEEPING field.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PWR_DONE</name>
              <description>After a PWR_MODE change this flag indicates if the new power mode has taken effect or not. 
Note: this flag can also change as a result of  a change in debug power up req</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_CLOCK_CTL</name>
          <description>CM4 clock control</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF00</resetMask>
          <fields>
            <field>
              <name>FAST_INT_DIV</name>
              <description>Specifies the fast clock divider (from the high frequency clock 'clk_hf' to the peripheral clock 'clk_fast'). Integer division by (1+FAST_INT_DIV). Allows for integer divisions in the range [1, 256] (FAST_INT_DIV is in the range [0, 255]).
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_CTL</name>
          <description>CM4 control</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x9F000000</resetMask>
          <fields>
            <field>
              <name>IOC_MASK</name>
              <description>CPU floating point unit (FPU) exception mask for the CPU's FPCSR.IOC 'invalid operation' exception condition:
'0': The CPU's exception condition does NOT activate the CPU's floating point interrupt. 
'1': the CPU's exception condition activates the CPU's floating point interrupt. 

Note: the ARM architecture does NOT support FPU exceptions; i.e. there is no precise FPU exception handler. Instead, FPU conditions are captured in the CPU's FPCSR register and the conditions are provided as CPU interface signals. The interface signals are 'masked' with the fields a provide by this register (CM7_0_CTL). The 'masked' signals are reduced/OR-ed into a single CPU floating point interrupt signal. The associated CPU interrupt handler allows for imprecise handling of FPU exception conditions.

Note: the CPU's FPCSR exception conditions are 'sticky'. Typically, the CPU FPU interrupt handler will clear the exception condition(s) to '0'.

Note: by default, the FPU exception masks are '0'. Therefore, FPU exception conditions will NOT activate the CPU's floating point interrupt.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DZC_MASK</name>
              <description>CPU FPU exception mask for the CPU's FPCSR.DZC 'divide by zero' exception condition:
'0': The CPU's exception condition does NOT activate the CPU's floating point interrupt. 
'1': the CPU's exception condition activates the CPU's floating point interrupt.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OFC_MASK</name>
              <description>CPU FPU exception mask for the CPU's FPCSR.OFC 'overflow' exception condition:
'0': The CPU's exception condition does NOT activate the CPU's floating point interrupt. 
'1': the CPU's exception condition activates the CPU's floating point interrupt.</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UFC_MASK</name>
              <description>CPU FPU exception mask for the CPU's FPCSR.UFC 'underflow' exception condition:
'0': The CPU's exception condition does NOT activate the CPU's floating point interrupt. 
'1': the CPU's exception condition activates the CPU's floating point interrupt.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IXC_MASK</name>
              <description>CPU FPU exception mask for the CPU's FPCSR.IXC 'inexact' exception condition:
'0': The CPU's exception condition does NOT activate the CPU's floating point interrupt. 
'1': the CPU's exception condition activates the CPU's floating point interrupt.

Note: the 'inexact' condition is set as a result of rounding. Rounding may occur frequently and is typically not an error condition. To prevent frequent CPU FPU interrupts as a result of rounding, this field is typically set to '0'.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IDC_MASK</name>
              <description>CPU FPU exception mask for the CPU's FPCSR.IDC 'input denormalized' exception condition:
'0': The CPU's exception condition does NOT activate the CPU's floating point interrupt. 
'1': the CPU's exception condition activates the CPU's floating point interrupt. 

Note: if the CPU FPCSR.FZ field is set to '1', denormalized inputs are 'flushed to zero'. Dependent on the FPU algorithm, this may or may not occur frequently. To prevent frequent CPU FPU interrupts as a result of denormalized inputs, this field may be set to '0'.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_INT0_STATUS</name>
          <description>CM4 interrupt 0 status</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM4 activated system interrupt index for CPU interrupt 0.

See description of CM0_INT0_STATUS.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>See description of CM0_INT0_STATUS.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_INT1_STATUS</name>
          <description>CM4 interrupt 1 status</description>
          <addressOffset>0x104</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM4 activated system interrupt index for CPU interrupt 1.

See description of CM0_INT0_STATUS.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>See description of CM0_INT0_STATUS.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_INT2_STATUS</name>
          <description>CM4 interrupt 2 status</description>
          <addressOffset>0x108</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM4 activated system interrupt index for CPU interrupt 2.

See description of CM0_INT0_STATUS.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>See description of CM0_INT0_STATUS.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_INT3_STATUS</name>
          <description>CM4 interrupt 3 status</description>
          <addressOffset>0x10C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM4 activated system interrupt index for CPU interrupt 3.

See description of CM0_INT0_STATUS.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>See description of CM0_INT0_STATUS.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_INT4_STATUS</name>
          <description>CM4 interrupt 4 status</description>
          <addressOffset>0x110</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM4 activated system interrupt index for CPU interrupt 4.

See description of CM0_INT0_STATUS.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>See description of CM0_INT0_STATUS.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_INT5_STATUS</name>
          <description>CM4 interrupt 5 status</description>
          <addressOffset>0x114</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM4 activated system interrupt index for CPU interrupt 5.

See description of CM0_INT0_STATUS.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>See description of CM0_INT0_STATUS.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_INT6_STATUS</name>
          <description>CM4 interrupt 6 status</description>
          <addressOffset>0x118</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM4 activated system interrupt index for CPU interrupt 6.

See description of CM0_INT0_STATUS.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>See description of CM0_INT0_STATUS.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_INT7_STATUS</name>
          <description>CM4 interrupt 7 status</description>
          <addressOffset>0x11C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM4 activated system interrupt index for CPU interrupt 7.

See description of CM0_INT0_STATUS.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>See description of CM0_INT0_STATUS.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_VECTOR_TABLE_BASE</name>
          <description>CM4 vector table base</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFC00</resetMask>
          <fields>
            <field>
              <name>ADDR22</name>
              <description>Address of CM4 vector table. This register is used for CM4 warm and cold boot purposes: the CM0+ CPU initializes the CM4_VECTOR_TABLE_BASE register and the CM4 boot code uses the register to initialize the CM4 internal VTOR register.

Note: the CM4 vector table is at an address that is a 1024 B multiple.</description>
              <bitRange>[31:10]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>4</dimIncrement>
          <name>CM4_NMI_CTL[%s]</name>
          <description>CM4 NMI control</description>
          <addressOffset>0x240</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3FF</resetValue>
          <resetMask>0x3FF</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>System interrupt select for CPU NMI. The reset value ('1023') ensures that the CPU NMI is NOT connected to any system interrupt after DeepSleep reset.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UDB_PWR_CTL</name>
          <description>UDB power control</description>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFA050001</resetValue>
          <resetMask>0xFFFF0003</resetMask>
          <fields>
            <field>
              <name>PWR_MODE</name>
              <description>Set Power mode for UDBs</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>See CM4_PWR_CTL</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RESET</name>
                  <description>See CM4_PWR_CTL</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RETAINED</name>
                  <description>See CM4_PWR_CTL</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>See CM4_PWR_CTL</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VECTKEYSTAT</name>
              <description>Register key (to prevent accidental writes).
- Should be written with a 0x05fa key value for the write to take effect.
- Always reads as 0xfa05.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UDB_PWR_DELAY_CTL</name>
          <description>UDB power control</description>
          <addressOffset>0x304</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x12C</resetValue>
          <resetMask>0x3FF</resetMask>
          <fields>
            <field>
              <name>UP</name>
              <description>Number clock cycles delay needed after power domain power up</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_CTL</name>
          <description>CM0+ control</description>
          <addressOffset>0x1000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFA050002</resetValue>
          <resetMask>0xFFFF0003</resetMask>
          <fields>
            <field>
              <name>SLV_STALL</name>
              <description>Processor debug access control:
'0': Access.
'1': Stall access.

This field is used to stall/delay debug accesses. This is useful to protect execution of code that needs to be protected from debug accesses.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>Processor enable:
'0': Disabled. Processor clock is turned off and reset is activated. After SW clears this field to '0', HW automatically sets this field to '1'. This effectively results in a CM0+ reset, followed by a CM0+ warm boot.
'1': Enabled.
Note: The intent is that this bit is modified only through an external probe or by the CM4 while the CM0+ is in Sleep or DeepSleep power mode. If this field is cleared to '0' by the CM0+ itself, it should be done under controlled conditions (such that undesirable side effects can be prevented).

Note: The CM0+ CPU has a AIRCR.SYSRESETREQ register field that allows the CM0+ to reset the complete device (ENABLED only disables/enables the CM0+), resulting in a warm boot. This CPU register field has similar 'built-in protection' as this CM0_CTL register to prevent accidental system writes (the upper 16-bits of the register need to be written with a 0x05fa key value; see CPU user manual for more details).</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VECTKEYSTAT</name>
              <description>Register key (to prevent accidental writes).
- Should be written with a 0x05fa key value for the write to take effect.
- Always reads as 0xfa05.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_STATUS</name>
          <description>CM0+ status</description>
          <addressOffset>0x1004</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>SLEEPING</name>
              <description>Specifies if the CPU is in Active, Sleep or DeepSleep power mode:
- Active power mode: SLEEPING is '0'.
- Sleep power mode: SLEEPING is '1' and SLEEPDEEP is '0'.
- DeepSleep power mode: SLEEPING is '1' and SLEEPDEEP is '1'.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SLEEPDEEP</name>
              <description>Specifies if the CPU is in Sleep or DeepSleep power mode. See SLEEPING field.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_CLOCK_CTL</name>
          <description>CM0+ clock control</description>
          <addressOffset>0x1008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF00FF00</resetMask>
          <fields>
            <field>
              <name>SLOW_INT_DIV</name>
              <description>Specifies the slow clock divider (from the peripheral clock 'clk_peri' to the slow clock 'clk_slow'). Integer division by (1+SLOW_INT_DIV). Allows for integer divisions in the range [1, 256] (SLOW_INT_DIV is in the range [0, 255]).
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PERI_INT_DIV</name>
              <description>Specifies the peripheral clock divider (from the high frequency clock 'clk_hf' to the peripheral clock 'clk_peri'). Integer division by (1+PERI_INT_DIV). Allows for integer divisions in the range [1, 256] (PERI_INT_DIV is in the range [0, 255]).
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.

Note that Fperi &lt;= Fperi_max. Fperi_max is likely to be smaller than Fhf_max. In other words, if Fhf = Fhf_max, PERI_INT_DIV should not be set to '0'.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_INT0_STATUS</name>
          <description>CM0+ interrupt 0 status</description>
          <addressOffset>0x1100</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM0+ activated system interrupt index for CPU interrupt 0.

Multiple system interrupts can be mapped on the same CPU interrupt.The selected system interrupt is the system interrupt with the lowest system interrupt index that has an activated interrupt request at the time of the fetch (system_interrupts[SYSTEM_INT_IDX] is '1'). 

The CPU interrupt handler SW can read SYSTEM_INT_IDX to determine the system interrupt that activated the handler.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>Valid indication for SYSTEM_INT_IDX. When '0', no system interrupt for CPU interrupt 0 is valid/activated.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_INT1_STATUS</name>
          <description>CM0+ interrupt 1 status</description>
          <addressOffset>0x1104</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM0+ activated system interrupt index for CPU interrupt 1.

See description of CM0_INT0_STATUS.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>See description of CM0_INT0_STATUS.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_INT2_STATUS</name>
          <description>CM0+ interrupt 2 status</description>
          <addressOffset>0x1108</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM0+ activated system interrupt index for CPU interrupt 2.

See description of CM0_INT0_STATUS.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>See description of CM0_INT0_STATUS.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_INT3_STATUS</name>
          <description>CM0+ interrupt 3 status</description>
          <addressOffset>0x110C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM0+ activated system interrupt index for CPU interrupt 3.

See description of CM0_INT0_STATUS.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>See description of CM0_INT0_STATUS.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_INT4_STATUS</name>
          <description>CM0+ interrupt 4 status</description>
          <addressOffset>0x1110</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM0+ activated system interrupt index for CPU interrupt 4.

See description of CM0_INT0_STATUS.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>See description of CM0_INT0_STATUS.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_INT5_STATUS</name>
          <description>CM0+ interrupt 5 status</description>
          <addressOffset>0x1114</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM0+ activated system interrupt index for CPU interrupt 5.

See description of CM0_INT0_STATUS.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>See description of CM0_INT0_STATUS.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_INT6_STATUS</name>
          <description>CM0+ interrupt 6 status</description>
          <addressOffset>0x1118</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM0+ activated system interrupt index for CPU interrupt 6.

See description of CM0_INT0_STATUS.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>See description of CM0_INT0_STATUS.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_INT7_STATUS</name>
          <description>CM0+ interrupt 7 status</description>
          <addressOffset>0x111C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM0+ activated system interrupt index for CPU interrupt 7.

See description of CM0_INT0_STATUS.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>See description of CM0_INT0_STATUS.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_VECTOR_TABLE_BASE</name>
          <description>CM0+ vector table base</description>
          <addressOffset>0x1120</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFF00</resetMask>
          <fields>
            <field>
              <name>ADDR24</name>
              <description>Address of CM0+ vector table. This register is used for CM0+ warm boot purposes: the CM0+ warm boot code uses the register to initialize the CM0+ internal VTOR register.

Note: the CM0+ vector table is at an address that is a 256 B multiple.</description>
              <bitRange>[31:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>4</dimIncrement>
          <name>CM0_NMI_CTL[%s]</name>
          <description>CM0+ NMI control</description>
          <addressOffset>0x1140</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3FF</resetValue>
          <resetMask>0x3FF</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>System interrupt select for CPU NMI. The reset value ('1023') ensures that the CPU NMI is NOT connected to any system interrupt after DeepSleep reset.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_PWR_CTL</name>
          <description>CM4 power control</description>
          <addressOffset>0x1200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFA050001</resetValue>
          <resetMask>0xFFFF0003</resetMask>
          <fields>
            <field>
              <name>PWR_MODE</name>
              <description>Power mode.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>Switch CM4 off
Power off, clock off, isolate, reset and no retain.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RESET</name>
                  <description>Reset CM4
Clock off, no isolated, no retain and reset.

Note: The CM4 CPU has a AIRCR.SYSRESETREQ register field that allows the CM4 to reset the complete device (RESET only resets the CM4), resulting in a warm boot.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RETAINED</name>
                  <description>Put CM4 in Retained mode
This can only become effective if CM4 is in SleepDeep mode. Check PWR_DONE flag to see if CM4 RETAINED state has been reached.
Power off, clock off, isolate, no reset and retain.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Switch CM4 on.
Power on, clock on, no isolate, no reset and no retain.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VECTKEYSTAT</name>
              <description>Register key (to prevent accidental writes).
- Should be written with a 0x05fa key value for the write to take effect.
- Always reads as 0xfa05.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_PWR_DELAY_CTL</name>
          <description>CM4 power control</description>
          <addressOffset>0x1204</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x12C</resetValue>
          <resetMask>0x3FF</resetMask>
          <fields>
            <field>
              <name>UP</name>
              <description>Number clock cycles delay needed after power domain power up</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM0_CTL0</name>
          <description>RAM 0 control</description>
          <addressOffset>0x1300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x30001</resetValue>
          <resetMask>0x70303</resetMask>
          <fields>
            <field>
              <name>SLOW_WS</name>
              <description>Memory wait states for the slow clock domain ('clk_slow'). The number of wait states is expressed in 'clk_hf' clock domain cycles.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FAST_WS</name>
              <description>Memory wait states for the fast clock domain ('clk_fast'). The number of wait states is expressed in 'clk_hf' clock domain cycles.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_EN</name>
              <description>Enable ECC checking:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_AUTO_CORRECT</name>
              <description>HW ECC autocorrect functionality:
'0': Disabled.
'1': Enabled. HW automatically writes back SRAM with corrected data when a recoverable ECC error is detected.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_INJ_EN</name>
              <description>Enable error injection for system SRAM 0.
When '1', the parity (ECC_CTL.PARITY) is used when a full 32-bit write is done to the ECC_CTL.WORD_ADDR word address of system SRAM 0.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM0_STATUS</name>
          <description>RAM 0 status</description>
          <addressOffset>0x1304</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x1</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>WB_EMPTY</name>
              <description>Write buffer empty. Thois information is used when entering DeepSleep power mode: WB_EMPTY must be '1' before a transition to system DeepSleep power mode.
'0': Write buffer NOT empty.
'1': Write buffer empty.

Note: the SRAM controller write buffer is only used when ECC checking is enabled. (RAMi_CTL.ECC_EN is '1').</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>4</dimIncrement>
          <name>RAM0_PWR_MACRO_CTL[%s]</name>
          <description>RAM 0 power control</description>
          <addressOffset>0x1340</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFA050003</resetValue>
          <resetMask>0xFFFF0003</resetMask>
          <fields>
            <field>
              <name>PWR_MODE</name>
              <description>Power mode.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>See CM4_PWR_CTL</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD</name>
                  <description>undefined</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RETAINED</name>
                  <description>See CM4_PWR_CTL</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>See CM4_PWR_CTL</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VECTKEYSTAT</name>
              <description>See CM4_PWR_CTL</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM1_CTL0</name>
          <description>RAM 1 control</description>
          <addressOffset>0x1380</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x30001</resetValue>
          <resetMask>0x70303</resetMask>
          <fields>
            <field>
              <name>SLOW_WS</name>
              <description>See RAM0_CTL.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FAST_WS</name>
              <description>See RAM0_CTL.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_EN</name>
              <description>See RAM0_CTL.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_AUTO_CORRECT</name>
              <description>See RAM0_CTL.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_INJ_EN</name>
              <description>See RAM0_CTL.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM1_STATUS</name>
          <description>RAM 1 status</description>
          <addressOffset>0x1384</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x1</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>WB_EMPTY</name>
              <description>See RAM0_STATUS.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM1_PWR_CTL</name>
          <description>RAM 1 power control</description>
          <addressOffset>0x1388</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFA050003</resetValue>
          <resetMask>0xFFFF0003</resetMask>
          <fields>
            <field>
              <name>PWR_MODE</name>
              <description>Power mode.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>See CM4_PWR_CTL</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD</name>
                  <description>undefined</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RETAINED</name>
                  <description>See CM4_PWR_CTL</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>See CM4_PWR_CTL</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VECTKEYSTAT</name>
              <description>See CM4_PWR_CTL</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM2_CTL0</name>
          <description>RAM 2 control</description>
          <addressOffset>0x13A0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x30001</resetValue>
          <resetMask>0x70303</resetMask>
          <fields>
            <field>
              <name>SLOW_WS</name>
              <description>See RAM0_CTL.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FAST_WS</name>
              <description>See RAM0_CTL.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_EN</name>
              <description>See RAM0_CTL.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_AUTO_CORRECT</name>
              <description>See RAM0_CTL.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_INJ_EN</name>
              <description>See RAM0_CTL.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM2_STATUS</name>
          <description>RAM 2 status</description>
          <addressOffset>0x13A4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x1</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>WB_EMPTY</name>
              <description>See RAM0_STATUS.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM2_PWR_CTL</name>
          <description>RAM 2 power control</description>
          <addressOffset>0x13A8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFA050003</resetValue>
          <resetMask>0xFFFF0003</resetMask>
          <fields>
            <field>
              <name>PWR_MODE</name>
              <description>Power mode.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>See CM4_PWR_CTL</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD</name>
                  <description>undefined</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RETAINED</name>
                  <description>See CM4_PWR_CTL</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>See CM4_PWR_CTL</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VECTKEYSTAT</name>
              <description>See CM4_PWR_CTL</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM_PWR_DELAY_CTL</name>
          <description>Power up delay used for all SRAM power domains</description>
          <addressOffset>0x13C0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x96</resetValue>
          <resetMask>0x3FF</resetMask>
          <fields>
            <field>
              <name>UP</name>
              <description>Number clock cycles delay needed after power domain power up</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ROM_CTL</name>
          <description>ROM control</description>
          <addressOffset>0x13C4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1</resetValue>
          <resetMask>0x303</resetMask>
          <fields>
            <field>
              <name>SLOW_WS</name>
              <description>Memory wait states for the slow clock domain ('clk_slow'). The number of wait states is expressed in 'clk_hf' clock domain cycles.

Timing paths to and from the memory have a (fixed) minimum duration  that always needs to be considered/met. The 'clk_hf' clock domain frequency determines this field's value such that the timing paths minimum duration is met. A table/formula will be provided for this field's values for different 'clk_hf' frequencies.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FAST_WS</name>
              <description>Memory wait states for the fast clock domain ('clk_fast'). The number of wait states is expressed in 'clk_hf' clock domain cycles.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ECC_CTL</name>
          <description>ECC control</description>
          <addressOffset>0x13C8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WORD_ADDR</name>
              <description>Specifies the word address where an error will be injected.
- On a write transfer to this SRAM address and when the corresponding RAM0/RAM1/RAM2/CM0/CM4_PWR_CTL_CTL.ECC_INJ_EN bit is '1', the parity (PARITY) is injected.</description>
              <bitRange>[24:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY</name>
              <description>ECC parity to use for ECC error injection at address WORD_ADDR.</description>
              <bitRange>[31:25]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PRODUCT_ID</name>
          <description>Product identifier and version (same as CoreSight RomTables)</description>
          <addressOffset>0x1400</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>FAMILY_ID</name>
              <description>Family ID a.k.a. Partnumber a.k.a. Silicon ID</description>
              <bitRange>[11:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MAJOR_REV</name>
              <description>Major Revision, starts with 1, increments with all layer tape-out (implemented with metal ECO-able  tie-off)</description>
              <bitRange>[19:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MINOR_REV</name>
              <description>Minir Revision, starts with 1, increments with metal layer only tape-out (implemented with metal ECO-able  tie-off)</description>
              <bitRange>[23:20]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DP_STATUS</name>
          <description>Debug port status</description>
          <addressOffset>0x1410</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x4</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>SWJ_CONNECTED</name>
              <description>Specifies if the SWJ debug port is connected; i.e. debug host interface is active:
'0': Not connected/not active.
'1': Connected/active.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SWJ_DEBUG_EN</name>
              <description>Specifies if SWJ debug is enabled, i.e. CDBGPWRUPACK is '1' and thus debug clocks are on:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SWJ_JTAG_SEL</name>
              <description>Specifies if the JTAG or SWD interface is selected. This signal is valid when DP_CTL.PTM_SEL is '0' (SWJ mode selected) and SWJ_CONNECTED is '1' (SWJ is connected).
'0': SWD selected.
'1': JTAG selected.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BUFF_CTL</name>
          <description>Buffer control</description>
          <addressOffset>0x1500</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>WRITE_BUFF</name>
              <description>Specifies if write transfer can be buffered in the bus infrastructure bridges:
'0': Write transfers are not buffered, independent of the transfer's bufferable attribute.
'1': Write transfers can be buffered, if the transfer's bufferable attribute indicates that the transfer is a bufferable/posted write.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SYSTICK_CTL</name>
          <description>SysTick timer control</description>
          <addressOffset>0x1600</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40000147</resetValue>
          <resetMask>0xC3FFFFFF</resetMask>
          <fields>
            <field>
              <name>TENMS</name>
              <description>Specifies the number of clock source cycles (minus 1) that make up 10 ms. E.g., for a 32,768 Hz reference clock, TENMS is 328 - 1 = 327.</description>
              <bitRange>[23:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLOCK_SOURCE</name>
              <description>Specifies an external clock source:
'0': The low frequency clock 'clk_lf' is selected. The precision of this clock depends on whether the low frequency clock source is a SRSS internal RC oscillator (imprecise) or a device external crystal oscillator (precise).
'1': The internal main oscillator (IMO) clock 'clk_imo' is selected. The MXS40 platform uses a fixed frequency IMO clock.
o '2': The external crystal oscillator (ECO) clock 'clk_eco' is selected.
'3': The SRSS 'clk_timer' is selected ('clk_timer' is a divided/gated version of 'clk_hf' or 'clk_imo').

Note: If NOREF is '1', the CLOCK_SOURCE value is NOT used.
Note: It is SW's responsibility to provide the correct NOREF, SKEW and TENMS field values for the selected clock source.</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SKEW</name>
              <description>Specifies the precision of the clock source and if the TENMS field represents exactly 10 ms (clock source frequency is a multiple of 100 Hz). This affects the suitability of the SysTick timer as a SW real-time clock:
'0': Precise.
'1': Imprecise.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOREF</name>
              <description>Specifies if an external clock source is provided:
'0': An external clock source is provided. 
'1': An external clock source is NOT provided and only the CPU internal clock can be used as SysTick timer clock source.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MBIST_STAT</name>
          <description>Memory BIST status</description>
          <addressOffset>0x1704</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>SFP_READY</name>
              <description>Flag indicating the BIST run is done. Note that after starting a BIST run this flag must be set before a new run can be started. For the first BIST run this will be 0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SFP_FAIL</name>
              <description>Report status of the BIST run, only valid if SFP_READY=1</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAL_SUP_SET</name>
          <description>Calibration support set and read</description>
          <addressOffset>0x1800</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Read without side effect, write 1 to set</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAL_SUP_CLR</name>
          <description>Calibration support clear and reset</description>
          <addressOffset>0x1804</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Read side effect: when read all bits are cleared, write 1 to clear a specific bit 
Note: no exception for the debug host, it also causes the read side effect</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_PC_CTL</name>
          <description>CM0+ protection context control</description>
          <addressOffset>0x2000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Valid fields for the protection context handler CM0_PCi_HANDLER registers:
Bit 0: Valid field for CM0_PC0_HANDLER.
Bit 1: Valid field for CM0_PC1_HANDLER.
Bit 2: Valid field for CM0_PC2_HANDLER.
Bit 3: Valid field for CM0_PC3_HANDLER.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_PC0_HANDLER</name>
          <description>CM0+ protection context 0 handler</description>
          <addressOffset>0x2040</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>Address of the protection context 0 handler. This field is used to detect entry to Cypress 'trusted' code through an exception/interrupt.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_PC1_HANDLER</name>
          <description>CM0+ protection context 1 handler</description>
          <addressOffset>0x2044</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>Address of the protection context 1 handler.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_PC2_HANDLER</name>
          <description>CM0+ protection context 2 handler</description>
          <addressOffset>0x2048</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>Address of the protection context 2 handler.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_PC3_HANDLER</name>
          <description>CM0+ protection context 3 handler</description>
          <addressOffset>0x204C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>Address of the protection context 3 handler.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PROTECTION</name>
          <description>Protection status</description>
          <addressOffset>0x20C4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>STATE</name>
              <description>Protection state:
'0': UNKNOWN.
'1': VIRGIN.
'2': NORMAL.
'3': SECURE.
'4': DEAD.

The following state transistions are allowed (and enforced by HW):
- UNKNOWN =&gt; VIRGIN/NORMAL/SECURE/DEAD
- NORMAL =&gt; DEAD
- SECURE =&gt; DEAD
An attempt to make a NOT allowed state transition will NOT affect this register field.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIM_ROM_CTL</name>
          <description>ROM trim control</description>
          <addressOffset>0x2100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TRIM</name>
              <description>N/A</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIM_RAM_CTL</name>
          <description>RAM trim control</description>
          <addressOffset>0x2104</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TRIM</name>
              <description>N/A</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>1023</dim>
          <dimIncrement>4</dimIncrement>
          <name>CM0_SYSTEM_INT_CTL[%s]</name>
          <description>CM0+ system interrupt control</description>
          <addressOffset>0x8000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>CPU_INT_IDX</name>
              <description>CPU interrupt index (legal range [0, 7]). This field specifies to which CPU interrupt the system interrupt is mapped. E.g., if CPU_INT_IDX is '6', the system interrupt is mapped to CPU interrupt '6'.

Note: it is possible to map multiple system interrupts to the same CPU interrupt. It is advised to assign different priorities to the CPU interrupts and to assign system interrupts to CPU interrupts accordingly.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPU_INT_VALID</name>
              <description>Interrupt enable:
'0': Disabled. The system interrupt will NOT be mapped to any CPU interrupt.
'1': Enabled. The system interrupt is mapped on CPU interrupt CPU_INT_IDX.

Note: the CPUs have dedicated XXX_SYSTEM_INT_CTL registers. In other words, the CPUs can use different CPU interrupts for the same system interrupt. However, typically only one of the CPUs will have the ENABLED field of a specific system interrupt set to '1'.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>1023</dim>
          <dimIncrement>4</dimIncrement>
          <name>CM4_SYSTEM_INT_CTL[%s]</name>
          <description>CM4 system interrupt control</description>
          <addressOffset>0xA000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>CPU_INT_IDX</name>
              <description>N/A</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPU_INT_VALID</name>
              <description>N/A</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>FAULT</name>
      <description>Fault structures</description>
      <baseAddress>0x40210000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>4</dim>
          <dimIncrement>256</dimIncrement>
          <name>STRUCT[%s]</name>
          <description>Fault structure</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>CTL</name>
            <description>Fault control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7</resetMask>
            <fields>
              <field>
                <name>TR_EN</name>
                <description>Trigger output enable:
'0': Disabled. The trigger output 'tr_fault' is '0'.
'1': Enabled. The trigger output 'tr_fault' reflects STATUS.VALID. The trigger can be used to initiate a Datawire transfer of the FAULT data (FAULT_DATA0 through FAULT_DATA3).</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT_EN</name>
                <description>IO output signal enable:
'0': Disabled. The IO output signal 'fault_out' is '0'. The IO output enable signal 'fault_out_en' is '0'.
'1': Enabled. The IO output signal 'fault_out' reflects STATUS.VALID. The IO output enable signal 'fault_out_en' is '1'.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RESET_REQ_EN</name>
                <description>Reset request enable:
'0': Disabled.
'1': Enabled. The output reset request signal 'fault_reset_req' reflects STATUS.VALID. This reset causes a warm/soft/core reset. This warm/soft/core reset does not affect the fault logic STATUS, DATA0, ..., DATA3 registers (allowing for post soft reset failure analysis).

The 'fault_reset_req' signals of the individual fault report structures are combined (logically OR'd) into a single SRSS 'fault_reset_req' signal.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>STATUS</name>
            <description>Fault status</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80000000</resetMask>
            <fields>
              <field>
                <name>IDX</name>
                <description>The fault source index for which fault information is captured in DATA0 through DATA3. The fault information is fault source specific and described below.

Note: this register field (and associated fault source data in DATA0 through DATA3) should only be considered valid, when VALID is '1'.</description>
                <bitRange>[6:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>MPU_0</name>
                    <description>Bus master 0 MPU/SMPU.
DATA0[31:0]: Violating address.
DATA1[0]: User read.
DATA1[1]: User write.
DATA1[2]: User execute.
DATA1[3]: Privileged read.
DATA1[4]: Privileged write.
DATA1[5]: Privileged execute.
DATA1[6]: Non-secure.
DATA1[11:8]: Master identifier.
DATA1[15:12]: Protection context identifier.
DATA1[31]: '0' MPU violation; '1': SMPU violation.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>MPU_1</name>
                    <description>Bus master 1 MPU. See MPU_0 description.</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>MPU_2</name>
                    <description>Bus master 2 MPU. See MPU_0 description.</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>MPU_3</name>
                    <description>Bus master 3 MPU. See MPU_0 description.</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>MPU_4</name>
                    <description>Bus master 4 MPU. See MPU_0 description.</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>MPU_5</name>
                    <description>Bus master 5 MPU. See MPU_0 description.</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>MPU_6</name>
                    <description>Bus master 6 MPU. See MPU_0 description.</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>MPU_7</name>
                    <description>Bus master 7 MPU. See MPU_0 description.</description>
                    <value>7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>MPU_8</name>
                    <description>Bus master 8 MPU. See MPU_0 description.</description>
                    <value>8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>MPU_9</name>
                    <description>Bus master 9 MPU. See MPU_0 description.</description>
                    <value>9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>MPU_10</name>
                    <description>Bus master 10 MPU. See MPU_0 description.</description>
                    <value>10</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>MPU_11</name>
                    <description>Bus master 11 MPU. See MPU_0 description.</description>
                    <value>11</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>MPU_12</name>
                    <description>Bus master 12 MPU. See MPU_0 description.</description>
                    <value>12</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>MPU_13</name>
                    <description>Bus master 13 MPU. See MPU_0 description.</description>
                    <value>13</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>MPU_14</name>
                    <description>Bus master 14 MPU. See MPU_0 description.</description>
                    <value>14</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>MPU_15</name>
                    <description>Bus master 15 MPU. See MPU_0 description.</description>
                    <value>15</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CM4_SYS_MPU</name>
                    <description>CM4 system bus AHB-Lite interface MPU. See MPU_0 description.</description>
                    <value>16</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CM4_CODE_MPU</name>
                    <description>CM4 code bus AHB-Lite interface MPU for non flash controller accesses. See MPU_0 description.</description>
                    <value>17</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CM4_CODE_FLASHC_MPU</name>
                    <description>CM4 code bus AHB-Lite interface MPU for flash controller accesses. See MPU_0 description.</description>
                    <value>18</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>MS_PPU_4</name>
                    <description>Peripheral interconnect, master interface 4 PPU. See MS_PPU_0 description.</description>
                    <value>25</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PERI_ECC</name>
                    <description>Peripheral interconnect, protection structures SRAM, correctable ECC error:
DATA0[10:0]: Violating address.
DATA1[7:0]: Syndrome of SRAM word.</description>
                    <value>26</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PERI_NC_ECC</name>
                    <description>Peripheral interconnect, protection structures SRAM, non-correctable ECC error. See PERI_ECC description.</description>
                    <value>27</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>MS_PPU_0</name>
                    <description>Peripheral interconnect, master interface 0 PPU.
DATA0[31:0]: Violating address.
DATA1[0]: User read.
DATA1[1]: User write.
DATA1[2]: User execute.
DATA1[3]: Privileged read.
DATA1[4]: Privileged write.
DATA1[5]: Privileged execute.
DATA1[6]: Non-secure.
DATA1[11:8]: Master identifier.
DATA1[15:12]: Protection context identifier.
DATA1[31:28]: '0': master interface, PPU violation, '1': timeout detected, '2': bus error, other: undefined.</description>
                    <value>28</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>MS_PPU_1</name>
                    <description>Peripheral interconnect, master interface 1 PPU. See MS_PPU_0 description.</description>
                    <value>29</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>MS_PPU_2</name>
                    <description>Peripheral interconnect, master interface 2 PPU. See MS_PPU_0 description.</description>
                    <value>30</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>MS_PPU_3</name>
                    <description>Peripheral interconnect, master interface 3 PPU. See MS_PPU_0 description.</description>
                    <value>31</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>GROUP_FAULT_0</name>
                    <description>Peripheral group 0 fault detection.
DATA0[31:0]: Violating address.
DATA1[0]: User read.
DATA1[1]: User write.
DATA1[2]: User execute.
DATA1[3]: Privileged read.
DATA1[4]: Privileged write.
DATA1[5]: Privileged execute.
DATA1[6]: Non-secure.
DATA1[11:8]: Master identifier.
DATA1[15:12]: Protection context identifier.
DATA1[31:28]: '0': decoder or peripheral bus error, other: undefined.</description>
                    <value>32</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>GROUP_FAULT_1</name>
                    <description>Peripheral group 1 fault detection. See GROUP_FAULT_0 description.</description>
                    <value>33</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>GROUP_FAULT_2</name>
                    <description>Peripheral group 2 fault detection. See GROUP_FAULT_0 description.</description>
                    <value>34</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>GROUP_FAULT_3</name>
                    <description>Peripheral group 3 fault detection. See GROUP_FAULT_0 description.</description>
                    <value>35</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>GROUP_FAULT_4</name>
                    <description>Peripheral group 4 fault detection. See GROUP_FAULT_0 description.</description>
                    <value>36</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>GROUP_FAULT_5</name>
                    <description>Peripheral group 5 fault detection. See GROUP_FAULT_0 description.</description>
                    <value>37</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>GROUP_FAULT_6</name>
                    <description>Peripheral group 6 fault detection. See GROUP_FAULT_0 description.</description>
                    <value>38</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>GROUP_FAULT_7</name>
                    <description>Peripheral group 7 fault detection. See GROUP_FAULT_0 description.</description>
                    <value>39</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>GROUP_FAULT_8</name>
                    <description>Peripheral group 8 fault detection. See GROUP_FAULT_0 description.</description>
                    <value>40</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>GROUP_FAULT_9</name>
                    <description>Peripheral group 9 fault detection. See GROUP_FAULT_0 description.</description>
                    <value>41</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>GROUP_FAULT_10</name>
                    <description>Peripheral group 10 fault detection. See GROUP_FAULT_0 description.</description>
                    <value>42</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>GROUP_FAULT_11</name>
                    <description>Peripheral group 11 fault detection. See GROUP_FAULT_0 description.</description>
                    <value>43</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>GROUP_FAULT_12</name>
                    <description>Peripheral group 12 fault detection. See GROUP_FAULT_0 description.</description>
                    <value>44</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>GROUP_FAULT_13</name>
                    <description>Peripheral group 13 fault detection. See GROUP_FAULT_0 description.</description>
                    <value>45</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>GROUP_FAULT_14</name>
                    <description>Peripheral group 14 fault detection. See GROUP_FAULT_0 description.</description>
                    <value>46</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>GROUP_FAULT_15</name>
                    <description>Peripheral group 15 fault detection. See GROUP_FAULT_0 description.</description>
                    <value>47</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FLASHC_MAIN_BUS_ERROR</name>
                    <description>Flash controller, main interface, bus error:
FAULT_DATA0[31:0]: Violating address.
FAULT_DATA1[11:8]: Master identifier.</description>
                    <value>48</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FLASHC_MAIN_C_ECC</name>
                    <description>Flash controller, main interface, correctable ECC error:
DATA[26:0]: Violating address.
DATA1[7:0]: Syndrome of 64-bit word (at address offset 0x00).
DATA1[15:8]: Syndrome of 64-bit word (at address offset 0x08).
DATA1[23:16]: Syndrome of 64-bit word (at address offset 0x10).
DATA1[31:24]: Syndrome of 64-bit word (at address offset 0x18).</description>
                    <value>49</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FLASHC_MAIN_NC_ECC</name>
                    <description>Flash controller, main interface, non-correctable ECC error.  See FLASHC_MAIN_C_ECC description.</description>
                    <value>50</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FLASHC_WORK_BUS_ERROR</name>
                    <description>Flash controller, work interface, bus error.
FAULT_DATA0[31:0]: Violating address.
FAULT_DATA1[11:8]: Master identifier.</description>
                    <value>51</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FLASHC_WORK_C_ECC</name>
                    <description>Flash controller, work interface, correctable ECC error:
DATA0[26:0]: Violating address.
DATA1[6:0]: Syndrome of 32-bit word.</description>
                    <value>52</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FLASHC_WORK_NC_ECC</name>
                    <description>Flash controller, work interface, non-correctable ECC error. See FLASHC_WORK_C_ECC description.</description>
                    <value>53</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FLASHC_CM0_CA_C_ECC</name>
                    <description>Flash controller, CM0+ cache, correctable ECC error:
DATA0[26:0]: Violating address.
DATA1[6:0]: Syndrome of 32-bit SRAM word (at address offset 0x0).
DATA1[14:8]: Syndrome of 32-bit SRAM word (at address offset 0x4).
DATA1[22:16]: Syndrome of 32-bit SRAM word (at address offset 0x8).
DATA1[30:24]: Syndrome of 32-bit SRAM word (at address offset 0xc).</description>
                    <value>54</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FLASHC_CM0_CA_NC_ECC</name>
                    <description>Flash controller, CM0+ cache, non-correctable ECC error.  See FLASHC_CM0_CA_C_ECC description.</description>
                    <value>55</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FLASHC_CM4_CA_C_ECC</name>
                    <description>Flash controller, CM4 cache, correctable ECC error. See FLASHC_CM0_CA_C_ECC description.</description>
                    <value>56</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FLASHC_CM4_CA_NC_ECC</name>
                    <description>Flash controller, CM4 cache, non-correctable ECC error. See FLASHC_CM0_CA_C_ECC description.</description>
                    <value>57</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RAMC0_C_ECC</name>
                    <description>System SRAM 0 correctable ECC error:
DATA0[31:0]: Violating address.
DATA1[6:0]: Syndrome of 32-bit SRAM code word.</description>
                    <value>58</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RAMC0_NC_ECC</name>
                    <description>System SRAM 0 non-correctable ECC error.  See RAMC0_C_ECC description.</description>
                    <value>59</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RAMC1_C_ECC</name>
                    <description>System SRAM 1 correctable ECC error. See RAMC0_C_ECC description.</description>
                    <value>60</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RAMC1_NC_ECC</name>
                    <description>System SRAM 1 non-correctable ECC error. See RAMC0_C_ECC description.</description>
                    <value>61</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RAMC2_C_ECC</name>
                    <description>System SRAM 2 correctable ECC error. See RAMC0_C_ECC description.</description>
                    <value>62</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RAMC2_NC_ECC</name>
                    <description>System SRAM 2 non-correctable ECC error. See RAMC0_C_ECC description.</description>
                    <value>63</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CRYPTO_C_ECC</name>
                    <description>Cryptography SRAM correctable ECC error.
DATA0[31:0]: Violating address.
DATA1[6:0]:   Syndrome of Least Significant 32-bit SRAM.
DATA1[14:8]: Syndrome of Most Significant 32-bit SRAM.</description>
                    <value>64</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CRYPTO_NC_ECC</name>
                    <description>Cryptography SRAM non-correctable ECC error. See CRYPTO_C_ECC description.</description>
                    <value>65</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DW0_C_ECC</name>
                    <description>DataWire 0 SRAM 1 correctable ECC error:
DATA0[11:0]: Violating DW SRAM address (word address, assuming byte addressible).
DATA1[6:0]: Syndrome of 32-bit SRAM code word.</description>
                    <value>70</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DW0_NC_ECC</name>
                    <description>DataWire 0 SRAM 1 non-correctable ECC error. See DW0_C_ECC description.</description>
                    <value>71</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DW1_C_ECC</name>
                    <description>DataWire 1 SRAM 1 correctable ECC error. See DW0_C_ECC description.</description>
                    <value>72</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DW1_NC_ECC</name>
                    <description>DataWire 1 SRAM 1 non-correctable ECC error. See DW0_C_ECC description.</description>
                    <value>73</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FM_SRAM_C_ECC</name>
                    <description>eCT Flash SRAM (for embedded operations) correctable ECC error:
DATA0[15:0]: Address location in the eCT Flash SRAM.
DATA1[6:0]: Syndrome of 32-bit SRAM word.</description>
                    <value>74</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FM_SRAM_NC_ECC</name>
                    <description>eCT Flash SRAM non-correctable ECC error: See FM_SRAM_C_ECC description.</description>
                    <value>75</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CAN0_C_ECC</name>
                    <description>CAN controller 0 MRAM correctable ECC error:
DATA0[15:0]: Violating address.
DATA0[22:16]: ECC violating data[38:32] from MRAM.
DATA0[27:24]: Master ID: 0-7 = CAN channel ID within mxttcanfd cluster, 8 = AHB I/F
DATA1[31:0]: ECC violating data[31:0] from MRAM.</description>
                    <value>80</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CAN0_NC_ECC</name>
                    <description>CAN controller 0 MRAM non-correctable ECC error:
DATA0[15:0]: Violating address.
DATA0[22:16]: ECC violating data[38:32] from MRAM (not for Address Error).
DATA0[27:24]: Master ID: 0-7 = CAN channel ID within mxttcanfd cluster, 8 = AHB I/F
DATA0[30]: Write access, only possible for Address Error 
DATA0[31]: Address Error: a CAN channel did an MRAM access above MRAM_SIZE
DATA1[31:0]: ECC violating data[31:0] from MRAM (not for Address Error).</description>
                    <value>81</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CAN1_C_ECC</name>
                    <description>CAN controller 1 MRAM correctable ECC error. See CAN0_C_ECC description.</description>
                    <value>82</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CAN1_NC_ECC</name>
                    <description>CAN controller 1 MRAM non-correctable ECC error. See CAN0_NC_ECC description.</description>
                    <value>83</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CAN2_C_ECC</name>
                    <description>CAN controller 2 MRAM correctable ECC error. See CAN0_C_ECC description.</description>
                    <value>84</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CAN2_NC_ECC</name>
                    <description>CAN controller 2 MRAM non-correctable ECC error. See CAN0_NC_ECC description.</description>
                    <value>85</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SRSS_CSV</name>
                    <description>SRSS Clock SuperVisor (CSV) violation detected. Multiple CSV can detect a violation at the same time.
DATA0[15:0]: CSV violation occurred on corresponding clk_hf* root clock
DATA0[24]: CSV violation occurred on reference clock for clk_hf CSVs
DATA0[25]: CSV violation occurred on clk_lf
DATA0[26]: CSV violation occurred on clk_ilo0</description>
                    <value>90</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SRSS_SSV</name>
                    <description>SRSS Supply SuperVisor (SSV) violation detected. Multiple SSV can detect a violation at the same time.
DATA0[0]: BOD detected on VDDA
DATA0[1]: OVD detected on VDDA
DATA0[16]: violation detected on LVD/HVD #1 
DATA0[17]: violation detected on LVD/HVD #2</description>
                    <value>91</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SRSS_MCWDT0</name>
                    <description>SRSS Multi-Counter Watch Dog Timer (MCWDT) #0 violation detected. Multiple counters can detect a violation at the same time.
DATA0[0]: MCWDT subcounter 0 LOWER_LIMIT
DATA0[1]: MCWDT subcounter 0 UPPER_LIMIT
DATA0[2]: MCWDT subcounter 1 LOWER_LIMIT
DATA0[3]: MCWDT subcounter 1 UPPER_LIMIT</description>
                    <value>92</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SRSS_MCWDT1</name>
                    <description>SRSS Multi-Counter Watch Dog Timer (MCWDT) #1 violation detected. See SRSS_MCWDT0 description.</description>
                    <value>93</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SRSS_MCWDT2</name>
                    <description>SRSS Multi-Counter Watch Dog Timer (MCWDT) #2 violation detected. See SRSS_MCWDT0 description.</description>
                    <value>94</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SRSS_MCWDT3</name>
                    <description>SRSS Multi-Counter Watch Dog Timer (MCWDT) #3 violation detected. See SRSS_MCWDT0 description.</description>
                    <value>95</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>VALID</name>
                <description>Valid indication:
'0': Invalid.
'1': Valid. STATUS.IDX, DATA0, ..., DATA3 specify the fault.

Note: Typically, HW sets this field to '1' (on an activated HW fault source that is 'enabled' by the MASK registers) and SW clears this field to '0' (typically by boot code SW (after a warm system reset, when the fault is handled). In this typical use case scenario, the HW source fault data is simultaneously captured into DATA0, ..., DATA3 when the VALID field is set to '1'. 

An exceptional SW use case scenario is identified as well. In this scenario, SW sets this field to '1' with a fault source index different to one of the defined HW fault sources. SW update is not restricted by the MASK registers). In both use case scenarios, the following holds:
- STATUS.IDX, DATA0, ..., DATA3 can only be written when STATUS.VALID is '0'; the fault structure is not in use yet. Writing STATUS.VALID to '1' effectively locks the fault structure (until SW clears STATUS.VALID to '0'). This restriction requires a SW update to sequentially update the DATA registers followed by an update of the STATUS register.

Note: For the exceptional SW use case, sequantial updates to the DATA and STATUS registers may be 'interrupted' by a HW fault capture. In this case, the SW DATA register updates are overwritten by the HW update (and the STATUS.IDX field will reflect the HW capture)</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>4</dim>
            <dimIncrement>4</dimIncrement>
            <name>DATA[%s]</name>
            <description>Fault data</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>Captured fault source data. 

Note: the DATA registers can only be written when STATUS.VALID is '0'.

Note: the fault source index STATUS.IDX specifies the format of the DATA registers.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PENDING0</name>
            <description>Fault pending 0</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>SOURCE</name>
                <description>This field specifies the following sources:
Bit 0: CM0 MPU.
Bit 1: CRYPTO MPU.
Bit 2: DW 0 MPU.
Bit 3: DW 1 MPU.
Bit 4: DMA controller MPU.
...
Bit 15: DAP MPU.
Bit 16: CM4 system bus MPU.
Bit 17: CM4 code bus MPU (for non FLASH controller accesses).
Bit 18: CM4 code bus MPU (for FLASH controller accesses).</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PENDING1</name>
            <description>Fault pending 1</description>
            <addressOffset>0x44</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>SOURCE</name>
                <description>This field specifies the following sources:
Bit 0: Peripheral group 0 PPU.
Bit 1: Peripheral group 1 PPU.
Bit 2: Peripheral group 2 PPU.
Bit 3: Peripheral group 3 PPU.
Bit 4: Peripheral group 4 PPU.
Bit 5: Peripheral group 5 PPU.
Bit 6: Peripheral group 6 PPU.
Bit 7: Peripheral group 7 PPU.
...
Bit 15: Peripheral group 15 PPU.

Bit 16 - 31: See STATUS register.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PENDING2</name>
            <description>Fault pending 2</description>
            <addressOffset>0x48</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>SOURCE</name>
                <description>This field specifies the following sources:
Bit 0 - 31: See STATUS register.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MASK0</name>
            <description>Fault mask 0</description>
            <addressOffset>0x50</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SOURCE</name>
                <description>Fault source enables:
Bits 31-0: Fault sources 31 to 0.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MASK1</name>
            <description>Fault mask 1</description>
            <addressOffset>0x54</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SOURCE</name>
                <description>Fault source enables:
Bits 31-0: Fault sources 63 to 32.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MASK2</name>
            <description>Fault mask 2</description>
            <addressOffset>0x58</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SOURCE</name>
                <description>Fault source enables:
Bits 31-0: Fault sources 95 to 64.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR</name>
            <description>Interrupt</description>
            <addressOffset>0xC0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>FAULT</name>
                <description>This interrupt cause field is activated (HW sets the field to '1') when an enabled (MASK0/MASK1/MASK2) pending fault source is captured:
- STATUS.VALID is set to '1'.
- STATUS.IDX specifies the fault source index.
- DATA0 through DATA3 captures the fault source data.

SW writes a '1' to this field to clear the interrupt cause to '0'. SW clear STATUS.VALID to '0' to enable capture of the next fault. Note that when there is an enabled pending fault source, the pending fault source is captured immediately and INTR.FAULT is immediately activated (set to '1').</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SET</name>
            <description>Interrupt set</description>
            <addressOffset>0xC4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>FAULT</name>
                <description>SW writes a '1' to this field to set the corresponding field in the INTR register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASK</name>
            <description>Interrupt mask</description>
            <addressOffset>0xC8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>FAULT</name>
                <description>Mask bit for corresponding field in the INTR register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASKED</name>
            <description>Interrupt masked</description>
            <addressOffset>0xCC</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>FAULT</name>
                <description>Logical and of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>IPC</name>
      <description>IPC</description>
      <baseAddress>0x40220000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>8</dim>
          <dimIncrement>32</dimIncrement>
          <name>STRUCT[%s]</name>
          <description>IPC structure</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>ACQUIRE</name>
            <description>IPC acquire</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80000000</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>User/privileged access control:
'0': user mode.
'1': privileged mode.

This field is set with the user/privileged access control of the access that successfully acquired the lock.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>NS</name>
                <description>Secure/on-secure access control:
'0': secure.
'1': non-secure.

This field is set with the secure/non-secure access control of the access that successfully acquired the lock.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC</name>
                <description>This field specifies the protection context that successfully acquired the lock.</description>
                <bitRange>[7:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>MS</name>
                <description>This field specifies the bus master identifier that successfully acquired the lock.</description>
                <bitRange>[11:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>SUCCESS</name>
                <description>Specifies if the lock is successfully acquired or not (reading the ACQUIRE register can have affect on SUCCESS and LOCK_STATUS.ACQUIRED):
'0': Not successfully acquired; i.e. the lock was already acquired by another read transaction and not released. The P, NS, PC and MS fields reflect the access attributes of the transaction that previously successfully acuired the lock; the fields are NOT affected by the current access.
'1': Successfully acquired. The P, NS, PC and MS fields reflect the access attributes of the current access.

Note that this field is NOT SW writable. A lock is released by writing to the associated RELEASE register (irrespective of the write value).</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RELEASE</name>
            <description>IPC release</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>write-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>INTR_RELEASE</name>
                <description>This field allows for the generation of release events to the IPC interrupt structures, but only when the lock is acquired (LOCK_STATUS.ACQUIRED is '1'). The IPC release cause fields associated with this IPC structure are set to '1', but only for those IPC interrupt structures for which the corresponding bit field in INTR_RELEASE[] is set to '1'. 

SW writes a '1' to the bit fields to generate a release event. Due to the transient nature of this event, SW always reads a '0' from this field.</description>
                <bitRange>[15:0]</bitRange>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>NOTIFY</name>
            <description>IPC notification</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>write-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>INTR_NOTIFY</name>
                <description>This field allows for the generation of notification events to the IPC interrupt structures. The IPC notification cause fields associated with this IPC structure are set to '1', but only for those IPC interrupt structures for which the corresponding bit field in INTR_NOTIFY[] is set to '1'. 

SW writes a '1' to the bit fields to generate a notify event. Due to the transient nature of this event, SW always reads a '0' from this field.</description>
                <bitRange>[15:0]</bitRange>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DATA0</name>
            <description>IPC data 0</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>This field holds a 32-bit data element that is associated with the IPC structure.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DATA1</name>
            <description>IPC data 1</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>This field holds a 32-bit data element that is associated with the IPC structure.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LOCK_STATUS</name>
            <description>IPC lock status</description>
            <addressOffset>0x1C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80000000</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>This field specifies the user/privileged access control:
'0': user mode.
'1': privileged mode.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>NS</name>
                <description>This field specifies the cecure/on-secure access control:
'0': secure.
'1': non-secure.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC</name>
                <description>This field specifies the protection context that successfully acquired the lock.</description>
                <bitRange>[7:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>MS</name>
                <description>This field specifies the bus master identifier that successfully acquired the lock.</description>
                <bitRange>[11:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>ACQUIRED</name>
                <description>Specifies if the lock is acquired. This field is set to '1', if a ACQUIRE read transfer successfully acquires the lock (the ACQUIRE read transfer returns ACQUIRE.SUCCESS as '1').</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>8</dim>
          <dimIncrement>32</dimIncrement>
          <name>INTR_STRUCT[%s]</name>
          <description>IPC interrupt structure</description>
          <addressOffset>0x00001000</addressOffset>
          <register>
            <name>INTR</name>
            <description>Interrupt</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RELEASE</name>
                <description>These interrupt cause fields are activated (HW sets the field to '1') when a IPC release event is detected. One bit field for each master. SW writes a '1' to these field to clear the interrupt cause.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NOTIFY</name>
                <description>These interrupt cause fields are activated (HW sets the field to '1') when a IPC notification event is detected. One bit field for each master. SW writes a '1' to these field to clear the interrupt cause.</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SET</name>
            <description>Interrupt set</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RELEASE</name>
                <description>SW writes a '1' to this field to set the corresponding field in the INTR register.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NOTIFY</name>
                <description>SW writes a '1' to this field to set the corresponding field in the INTR register.</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASK</name>
            <description>Interrupt mask</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RELEASE</name>
                <description>Mask bit for corresponding field in the INTR register.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NOTIFY</name>
                <description>Mask bit for corresponding field in the INTR register.</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASKED</name>
            <description>Interrupt masked</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RELEASE</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>NOTIFY</name>
                <description>Logical and of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[31:16]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>PROT</name>
      <description>Protection</description>
      <baseAddress>0x40230000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <name>SMPU</name>
          <description>SMPU</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>MS0_CTL</name>
            <description>Master 0 protection context control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>Privileged setting ('0': user mode; '1': privileged mode).

Notes:
This field is ONLY used for masters that do NOT provide their own user/privileged access control attribute.
The default/reset field value provides privileged mode access capabilities.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>Security setting ('0': secure mode; '1': non-secure mode).

Notes:
This field is ONLY used for masters that do NOT provide their own secure/non-escure access control attribute.
Note that the default/reset field value provides non-secure mode access capabilities to all masters.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>Device wide bus arbitration priority setting ('0': highest priority, '3': lowest priority).

Notes: 
The AHB-Lite interconnect performs arbitration on the individual  beats/transfers of a burst (this optimizes latency over locality/bandwidth).
The AXI-Lite interconnects performs a single arbitration for the complete burst (this optimizes locality/bandwidth over latency).
Masters with the same priority setting form a 'priority group'. Within a 'priority group', roundrobin arbitration is performed.</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>Protection context mask for protection context '0'. This field is a constant '0':
- PC_MASK_0 is '0': MPU MS_CTL.PC[3:0] can NOT be set to '0' and PC[3:0] is not changed. If the protection context of the write transfer is '0', protection is not applied and PC[3:0] can be changed.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>Protection context mask for protection contexts '15' downto '1'. Bit PC_MASK_15_TO_1[i] indicates if the MPU MS_CTL.PC[3:0] protection context field can be set to the value 'i+1':
- PC_MASK_15_TO_1[i] is '0': MPU MS_CTL.PC[3:0] can NOT be set to 'i+1'; and PC[3:0] is not changed. If the protection context of the write transfer is '0', protection is not applied and PC[3:0] can be changed.
- PC_MASK_15_TO_1[i] is '1': MPU MS_CTL.PC[3:0] can be set to 'i+1'.

Note: When CPUSS_CM0_PC_CTL.VALID[i] is '1' (the associated protection context handler is valid), write transfers to PC_MASK_15_TO_1[i-1] always write '0', regardless of data written. This ensures that when valid protection context handlers are used to enter protection contexts 1, 2 or 3 through (HW modifies MPU MS_CTL.PC[3:0] on entry of the handler), it is NOT possible for SW to enter those protection contexts (SW modifies MPU MS_CTL.PC[3:0]).</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS1_CTL</name>
            <description>Master 1 protection context control</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS2_CTL</name>
            <description>Master 2 protection context control</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS3_CTL</name>
            <description>Master 3 protection context control</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS4_CTL</name>
            <description>Master 4 protection context control</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS5_CTL</name>
            <description>Master 5 protection context control</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS6_CTL</name>
            <description>Master 6 protection context control</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS7_CTL</name>
            <description>Master 7 protection context control</description>
            <addressOffset>0x1C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS8_CTL</name>
            <description>Master 8 protection context control</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS9_CTL</name>
            <description>Master 9 protection context control</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS10_CTL</name>
            <description>Master 10 protection context control</description>
            <addressOffset>0x28</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS11_CTL</name>
            <description>Master 11 protection context control</description>
            <addressOffset>0x2C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS12_CTL</name>
            <description>Master 12 protection context control</description>
            <addressOffset>0x30</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS13_CTL</name>
            <description>Master 13 protection context control</description>
            <addressOffset>0x34</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS14_CTL</name>
            <description>Master 14 protection context control</description>
            <addressOffset>0x38</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS15_CTL</name>
            <description>Master 15 protection context control</description>
            <addressOffset>0x3C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <cluster>
            <dim>16</dim>
            <dimIncrement>64</dimIncrement>
            <name>SMPU_STRUCT[%s]</name>
            <description>SMPU structure</description>
            <addressOffset>0x00002000</addressOffset>
            <register>
              <name>ADDR0</name>
              <description>SMPU region address 0 (slave structure)</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x0</resetMask>
              <fields>
                <field>
                  <name>SUBREGION_DISABLE</name>
                  <description>This field is used to individually disabled the eight equally sized subregions in which a region is partitioned. Subregion disable:
Bit 0: subregion 0 disable.
Bit 1: subregion 1 disable.
Bit 2: subregion 2 disable.
Bit 3: subregion 3 disable.
Bit 4: subregion 4 disable.
Bit 5: subregion 5 disable.
Bit 6: subregion 6 disable.
Bit 7: subregion 7 disable.
E.g., a 64 KByte address region (ATT0.REGION_SIZE is '15') has eight 8 KByte subregions. The access control as defined by ATT0 applies if the bus transfer address is within the address region AND the addressed subregion is NOT disabled. Note that the smallest region size is 256 B and the smallest subregion size is 32 B.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ADDR24</name>
                  <description>This field specifies the most significant bits of the 32-bit address of an address region. The region size is defined by ATT0.REGION_SIZE. A region of n Byte is always n Byte aligned. As a result, some of the lesser significant address bits of ADDR24 may be ignored in determining whether a bus transfer address is within an address region. E.g., a 64 KByte address region (REGION_SIZE is '15') is 64 KByte aligned, and ADDR24[7:0] are ignored.</description>
                  <bitRange>[31:8]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>ATT0</name>
              <description>SMPU region attributes 0 (slave structure)</description>
              <addressOffset>0x4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x100</resetValue>
              <resetMask>0x80000100</resetMask>
              <fields>
                <field>
                  <name>UR</name>
                  <description>User read enable:
'0': Disabled (user, read acceses are NOT allowed).
'1': Enabled (user, read acceses are allowed).</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>UW</name>
                  <description>User write enable:
'0': Disabled (user, write acceses are NOT allowed).
'1': Enabled (user, write acceses are allowed).</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>UX</name>
                  <description>User execute enable:
'0': Disabled (user, execute acceses are NOT allowed).
'1': Enabled (user, execute acceses are allowed).</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PR</name>
                  <description>Privileged read enable:
'0': Disabled (privileged, read acceses are NOT allowed).
'1': Enabled (privileged, read acceses are allowed).</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PW</name>
                  <description>Privileged write enable:
'0': Disabled (privileged, write acceses are NOT allowed).
'1': Enabled (privileged, write acceses are allowed).</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PX</name>
                  <description>Privileged execute enable:
'0': Disabled (privileged, execute acceses are NOT allowed).
'1': Enabled (privileged, execute acceses are allowed).</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>NS</name>
                  <description>Non-secure:
'0': Secure (secure accesses allowed, non-secure access NOT allowed).
'1': Non-secure (both secure and non-secure accesses allowed).</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PC_MASK_0</name>
                  <description>This field specifies protection context identifier based access control for protection context '0'.</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PC_MASK_15_TO_1</name>
                  <description>This field specifies protection context identifier based access control.
Bit i: protection context i+1 enable. If '0', protection context i+1 access is disabled; i.e. not allowed. If '1', protection context i+1 access is enabled; i.e. allowed.</description>
                  <bitRange>[23:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>REGION_SIZE</name>
                  <description>This field specifies the region size:
'0'-'6': Undefined.
'7': 256 B region
'8': 512 B region
'9': 1 KB region
'10': 2 KB region
'11': 4 KB region
'12': 8 KB region
'13': 16 KB region
'14': 32 KB region
'15': 64 KB region
'16': 128 KB region
'17': 256 KB region
'18': 512 KB region
'19': 1 MB region
'20': 2 MB region
'21': 4 MB region
'22': 8 MB region
'23': 16 MB region
'24': 32 MB region
'25': 64 MB region
'26': 128 MB region
'27': 256 MB region
'28': 512 MB region
'39': 1 GB region
'30': 2 GB region
'31': 4 GB region</description>
                  <bitRange>[28:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PC_MATCH</name>
                  <description>This field specifies if the PC field participates in the 'matching' process or the 'access evaluation' process:
'0': PC field participates in 'access evalution'.
'1': PC field participates in 'matching'.

Note that it is possible to define different access control for multiple protection contexts by using multiple protection structures with the same address region and PC_MATCH set to '1'.</description>
                  <bitRange>[30:30]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ENABLED</name>
                  <description>Region enable:
'0': Disabled. A disabled region will never result in a match on the bus transfer address.
'1': Enabled.

Note: a disabled address region performs logic gating to reduce dynamic power consumption.</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>ADDR1</name>
              <description>SMPU region address 1 (master structure)</description>
              <addressOffset>0x20</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>SUBREGION_DISABLE</name>
                  <description>This field is used to individually disabled the eight equally sized subregions in which a region is partitioned. Subregion disable:
Bit 0: subregion 0 disable.
Bit 1: subregion 1 disable.
Bit 2: subregion 2 disable.
Bit 3: subregion 3 disable.
Bit 4: subregion 4 disable.
Bit 5: subregion 5 disable.
Bit 6: subregion 6 disable.
Bit 7: subregion 7 disable.

Two out of a total of eight 32 B subregions are enabled. These subregions includes region structures 0 and 1. 

Note: this field is read-only.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>ADDR24</name>
                  <description>This field specifies the most significant bits of the 32-bit address of an address region.

'ADDR_DEF1': base address of structure.

Note: this field is read-only.</description>
                  <bitRange>[31:8]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>ATT1</name>
              <description>SMPU region attributes 1 (master structure)</description>
              <addressOffset>0x24</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x7000109</resetValue>
              <resetMask>0x9F00012D</resetMask>
              <fields>
                <field>
                  <name>UR</name>
                  <description>User read enable:
'0': Disabled (user, read acceses are NOT allowed).
'1': Enabled (user, read acceses are allowed).

Note that this register is constant '1'; i.e. user read accesses are ALWAYS allowed.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>UW</name>
                  <description>User write enable:
'0': Disabled (user, write acceses are NOT allowed).
'1': Enabled (user, write acceses are allowed).</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>UX</name>
                  <description>User execute enable:
'0': Disabled (user, execute acceses are NOT allowed).
'1': Enabled (user, execute acceses are allowed).

Note that this register is constant '0'; i.e. user execute accesses are NEVER allowed.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PR</name>
                  <description>Privileged read enable:
'0': Disabled (privileged, read acceses are NOT allowed).
'1': Enabled (privileged, read acceses are allowed).

Note that this register is constant '1'; i.e. privileged read accesses are ALWAYS allowed.</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PW</name>
                  <description>Privileged write enable:
'0': Disabled (privileged, write acceses are NOT allowed).
'1': Enabled (privileged, write acceses are allowed).</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PX</name>
                  <description>Privileged execute enable:
'0': Disabled (privileged, execute acceses are NOT allowed).
'1': Enabled (privileged, execute acceses are allowed).

Note that this register is constant '0'; i.e. privileged execute accesses are NEVER allowed.</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>NS</name>
                  <description>Non-secure:
'0': Secure (secure accesses allowed, non-secure access NOT allowed).
'1': Non-secure (both secure and non-secure accesses allowed).</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PC_MASK_0</name>
                  <description>This field specifies protection context identifier based access control for protection context '0'.</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PC_MASK_15_TO_1</name>
                  <description>This field specifies protection context identifier based access control.
Bit i: protection context i+1 enable. If '0', protection context i+1 access is disabled; i.e. not allowed. If '1', protection context i+1 access is enabled; i.e. allowed.</description>
                  <bitRange>[23:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>REGION_SIZE</name>
                  <description>This field specifies the region size:
'7': 256 B region (8 32 B subregions)

Note: this field is read-only.</description>
                  <bitRange>[28:24]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PC_MATCH</name>
                  <description>This field specifies if the PC field participates in the 'matching' process or the 'access evaluation' process:
'0': PC field participates in 'access evalution'.
'1': PC field participates in 'matching'.

Note that it is possible to define different access control for multiple protection contexts by using multiple protection structures with the same address region and PC_MATCH set to '1'.</description>
                  <bitRange>[30:30]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ENABLED</name>
                  <description>Region enable:
'0': Disabled. A disabled region will never result in a match on the bus transfer address.
'1': Enabled.</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
          </cluster>
        </cluster>
        <cluster>
          <dim>16</dim>
          <dimIncrement>1024</dimIncrement>
          <name>MPU[%s]</name>
          <description>MPU</description>
          <addressOffset>0x00004000</addressOffset>
          <register>
            <name>MS_CTL</name>
            <description>Master control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF000F</resetMask>
            <fields>
              <field>
                <name>PC</name>
                <description>Active protection context (PC). Modifications to this field are constrained by the associated SMPU MS_CTL.PC_MASK_0 and MS_CTL.PC_MASK_15_TO_1[] fields. In addition, a write transfer with protection context '0' can change this field (protection context 0 has unrestricted access).

The CM0+ MPU MS_CTL register is special: the PC field is modifiable by BOTH HW and SW (for all other masters, the MPU MS_CTL.PC field is modifiable by SW ONLY. For CM0+ PC field HW modifications, the following holds:
* On entry of a CM0_PC0/1/2/3_HANDLER exception/interrupt handler:
   IF (the new PC is the same as MS_CTL.PC)
       PC is not affected; PC_SAVED is not affected.
   ELSE IF (CM0_PC_CTL.VALID[MS_CTL.PC])
       An AHB-Lite bus error is generated for the exception handler fetch;
       PC is not affected; PC_SAVED is not affected.
   ELSE
       PC = 'new PC'; PC_SAVED = PC (push operation).
* On entry of any other exception/interrupt handler:
   PC = PC_SAVED; PC_SAVED is not affected (pop operation).

Note: this field is NOT used by the DW controllers, DMA controller and CRYPTO component.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_SAVED</name>
                <description>Saved protection context. Modifications to this field are constrained by the associated SMPU MS_CTL.PC_MASK_0 and MS_CTL.PC_MASK_15_TO_1[] fields.

Note: this field is ONLY used by the CM0+.</description>
                <bitRange>[19:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <cluster>
            <dim>8</dim>
            <dimIncrement>32</dimIncrement>
            <name>MPU_STRUCT[%s]</name>
            <description>MPU structure</description>
            <addressOffset>0x00000200</addressOffset>
            <register>
              <name>ADDR</name>
              <description>MPU region address</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x0</resetMask>
              <fields>
                <field>
                  <name>SUBREGION_DISABLE</name>
                  <description>This field is used to individually disabled the eight equally sized subregions in which a region is partitioned. Subregion disable:
Bit 0: subregion 0 disable.
Bit 1: subregion 1 disable.
Bit 2: subregion 2 disable.
Bit 3: subregion 3 disable.
Bit 4: subregion 4 disable.
Bit 5: subregion 5 disable.
Bit 6: subregion 6 disable.
Bit 7: subregion 7 disable.
E.g., a 64 KByte address region (REGION_SIZE is '15') has eight 8 KByte subregions. The access control as defined by PPU_REGION_ATT applies if the bus transfer address is within the address region AND the addressed subregion is NOT disabled. Note that the smallest region size is 256 B and the smallest subregion size is 32 B.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ADDR24</name>
                  <description>This field specifies the most significant bits of the 32-bit address of an address region. The region size is defined by ATT.REGION_SIZE. A region of n Byte is always n Byte aligned. As a result, some of the lesser significant address bits of ADDR24 may be ignored in determining whether a bus transfer address is within an address region. E.g., a 64 KByte address region (REGION_SIZE is '15') is 64 KByte aligned, and ADDR24[7:0] are ignored.</description>
                  <bitRange>[31:8]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>ATT</name>
              <description>MPU region attrributes</description>
              <addressOffset>0x4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x80000000</resetMask>
              <fields>
                <field>
                  <name>UR</name>
                  <description>User read enable:
'0': Disabled (user, read acceses are NOT allowed).
'1': Enabled (user, read acceses are allowed).</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>UW</name>
                  <description>User write enable:
'0': Disabled (user, write acceses are NOT allowed).
'1': Enabled (user, write acceses are allowed).</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>UX</name>
                  <description>User execute enable:
'0': Disabled (user, execute acceses are NOT allowed).
'1': Enabled (user, execute acceses are allowed).</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PR</name>
                  <description>Privileged read enable:
'0': Disabled (privileged, read acceses are NOT allowed).
'1': Enabled (privileged, read acceses are allowed).</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PW</name>
                  <description>Privileged write enable:
'0': Disabled (privileged, write acceses are NOT allowed).
'1': Enabled (privileged, write acceses are allowed).</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PX</name>
                  <description>Privileged execute enable:
'0': Disabled (privileged, execute acceses are NOT allowed).
'1': Enabled (privileged, execute acceses are allowed).</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>NS</name>
                  <description>Non-secure:
'0': Secure (secure accesses allowed, non-secure access NOT allowed).
'1': Non-secure (both secure and non-secure accesses allowed).</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>REGION_SIZE</name>
                  <description>This field specifies the region size:
'0'-'6': Undefined.
'7': 256 B region
'8': 512 B region
'9': 1 KB region
'10': 2 KB region
'11': 4 KB region
'12': 8 KB region
'13': 16 KB region
'14': 32 KB region
'15': 64 KB region
'16': 128 KB region
'17': 256 KB region
'18': 512 KB region
'19': 1 MB region
'20': 2 MB region
'21': 4 MB region
'22': 8 MB region
'23': 16 MB region
'24': 32 MB region
'25': 64 MB region
'26': 128 MB region
'27': 256 MB region
'28': 512 MB region
'39': 1 GB region
'30': 2 GB region
'31': 4 GB region</description>
                  <bitRange>[28:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ENABLED</name>
                  <description>Region enable:
'0': Disabled. A disabled region will never result in a match on the bus transfer address.
'1': Enabled.

Note: a disabled address region performs logic gating to reduce dynamic power consumption.</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
          </cluster>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>FLASHC</name>
      <description>Flash controller</description>
      <baseAddress>0x40240000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>FLASH_CTL</name>
          <description>Control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x110000</resetValue>
          <resetMask>0x77330F</resetMask>
          <fields>
            <field>
              <name>MAIN_WS</name>
              <description>FLASH macro main interface wait states:
'0': 0 wait states.
...
'15': 15 wait states</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MAIN_MAP</name>
              <description>Specifies mapping of FLASH macro main array.
'0': Mapping A.
'1': Mapping B. 

This field is only used when MAIN_BANK_MODE is '1' (dual bank mode).</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WORK_MAP</name>
              <description>Specifies mapping of FLASH macro work array.
'0': Mapping A.
'1': Mapping B. 

This field is only used when WORK_BANK_MODE is '1' (dual bank mode).</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MAIN_BANK_MODE</name>
              <description>Specifies bank mode of FLASH macro main array.
'0': Single bank mode.
'1': Dual bank mode.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WORK_BANK_MODE</name>
              <description>Specifies bank mode of FLASH macro work array.
'0': Single bank mode.
'1': Dual bank mode.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MAIN_ECC_EN</name>
              <description>Enable ECC checking for FLASH main interface:
'0': Disabled. ECC checking/reporting on FLASH main interface is disabled. No correctable or non-correctable faults are reported.
'1': Enabled.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MAIN_ECC_INJ_EN</name>
              <description>Enable error injection for FLASH main interface.
When '1', the parity (ECC_CTL.PARITY[7:0]) is used for a load from the ECC_CTL.WORD_ADDR[23:0] word address.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MAIN_ERR_SILENT</name>
              <description>Specifies bus transfer behavior for a non-recoverable error on the FLASH macro main interface (either a non-correctable ECC error, a FLASH macro main interface internal error, a FLASH macro main interface memory hole access):
'0': Bus transfer has a bus error.
'1': Bus transfer does NOT have a bus error; i.e. the error is 'silent'
In either case, the erroneous FLASH macro data is returned by the bus master interface. The erroneous data is NOT placed in a bus master interface's cache and/or buffer.

This field is ONLY used by CPU bus transfers. Non-CPU bus transfers always have a bus transfer with a bus error, in case of a non-recoverable error.

Note: All CPU bus masters have dedicated status registers (CM0_STATUS and CM4_STATUS) to register the occurence of FLASH macro main interface internal errors (non-correctable ECC errors and memory hole errors are NOT registered).

Note: fault reporting can be used to identify the error that occured:
- FLASH macro main interface internal error. 
- FLASH macro main interface non-recoverable ECC error.
- FLASH macro main interface recoverable ECC error.
- FLASH macro main interface memory hole error.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WORK_ECC_EN</name>
              <description>Enable ECC checking for FLASH work interface:
'0': Disabled. ECC checking/reporting on FLASH work interface is disabled. No correctable or non-correctable faults are reported.
'1': Enabled.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WORK_ECC_INJ_EN</name>
              <description>Enable error injection for FLASH work interface.
When '1', the parity (ECC_CTL.PARITY[6:0]) is used for a load from the ECC_CTL.WORD_ADDR[23:0] word address.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WORK_ERR_SILENT</name>
              <description>Specifies bus transfer behavior for a non-recoverable error on the FLASH macro work interface (either a non-correctable ECC error, a FLASH macro work interface internal error, a FLASH macro work interface memory hole access):
'0': Bus transfer has a bus error.
'1': Bus transfer does NOT have a bus error; i.e. the error is 'silent'
In either case, the erroneous FLASH macro data is returned by the bus master interface. The erroneous data is NOT placed in a bus master interface's cache and/or buffer.

This field is ONLY used by CPU bus transfers. Non-CPU bus transfers always have a bus transfer with a bus error, in case of a non-recoverable error.

Note: All CPU bus masters have dedicated status registers (CM0_STATUS and CM4_STATUS) to register the occurence of FLASH macro work interface internal errors (non-correctable ECC errors and memory hole errors are NOT registered).

Note: fault reporting can be used to identify the error that occured:
- FLASH macro work interface internal error. 
- FLASH macro work interface non-recoverable ECC error.
- FLASH macro work interface recoverable ECC error.
- FLASH macro work interface memory hole error.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FLASH_PWR_CTL</name>
          <description>Flash power control</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>ENABLE</name>
              <description>Controls 'enable' pin of the Flash memory.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE_HV</name>
              <description>Controls 'enable_hv' pin of the Flash memory.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FLASH_CMD</name>
          <description>Command</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>INV</name>
              <description>Invalidation of ALL caches (for CM0+ and CM4) and ALL buffers. SW writes a '1' to clear the caches. HW sets this field to '0' when the operation is completed. The operation takes a maximum of three clock cycles on the slowest of the clk_slow and clk_fast clocks. The caches' LRU structures are also reset to their default state.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BUFF_INV</name>
              <description>Invalidation of ALL buffers (does not invalidate the caches). SW writes a '1' to clear the buffers. HW sets this field to '0' when the operation is completed. The operation takes a maximum of three clock cycles on the slowest of the clk_slow and clk_fast clocks.

Note: the caches only capture FLASH macro main array data. Therefore, invalidating just the buffers (BUFF_INV) does not invalidate captures main array data in the caches.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BIST_CTL</name>
          <description>BIST control</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x113FF</resetMask>
          <fields>
            <field>
              <name>OPCODE</name>
              <description>This field specifies how the data check should be performed after reading the data from Flash memory.
'0': Read the Flash and compare the output to BIST_DATA (R0).
'1': Read the Flash and compare the output to the binary complement of BIST_DATA (R1).
'2': Read the Flash and compare with BIST_DATA[] and compliment of BIST_DATA alternately (R01). The expected data of the first read is BIST_DATA, expected data of the second read is binary compliment of BIST_DATA, third read expected data is BIST_DATA, fourth read expected data is binary compliment of BIST_DATA and so on.
'3': Similar to '2', but enables checker board pattern (where as OPCODE = 2 gives column stripe pattern).
Note: OPCODE = 2 or 3 doesn;t support INCR_DECR_BOTH = 1 and ADDR_COMPLIMENT_ENABLED = 1.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UP</name>
              <description>Specifies direction in which Flash BIST steps through addresses:
''0': BIST steps through the Flash from the maximum row and column addresses (as specified by a design time configurtion parameter when ADDR_START_ENABLED is '0' and as specified by BIST_ADDR_START when ADDR_START_ENABLED is '1')  to the minimum row and column addresses. 
'1': BIST steps through the Flash from the minimum row and column addresses ('0' when ADDR_START_ENABLED is '0' and as specified by BIST_ADDR_START when ADDR_START_ENABLED is '1') to the maximum row and column addresses.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ROW_FIRST</name>
              <description>Specifies how the Flash BIST addresses are generated:
'0': Column address is incremented/decremented till it reaches its maximum/minimum value. Once it reach its maximum/minimum value, it is set to its mimimum/maximum value and only then is the row address incremented/decremented.
'1': Row address is incremented/decremented till it reaches its maximum/minimum value. Once it reach its maximum/minimum value, it is set to its mimimum/maximum value and only then is the column address incremented/decremented.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ADDR_START_ENABLED</name>
              <description>Specifies Flash BIST start addresses:
'0': Row and column addresses start with their maximum/minimum values.
'1': Row and column addresses start with their values as specified by BIST_ADDR_START.

This feature is supported only for simple increment/decrement patterns. It is not supported with address compliment pattern (BIST_CTL.ADDR_COMPLIMENT_ENABLED) or address pattern which increments/decrements both row address and column address (BIST_CTL.INCR_DECR_BOTH) for every read.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ADDR_COMPLIMENT_ENABLED</name>
              <description>Specifies to generate address compliment patterns.
'0': Generate normal increment/decrement patterns.
'1': Generate address patterns which interleaves compliment of previous address in between.
Example: The following is an exaple pattern, With UP=1 and ROW_FIRST =0
00_00
11_11
00_01
11_10
00_10
11_01
...</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INCR_DECR_BOTH</name>
              <description>Specifies to generate patterns where both column address and row address are incremented/decremented simultaneously.
'0': Generate normal increment/decrement patterns.
'1': Generate address patterns with both row and column address changing.
Example: With UP = 1 and ROW_FIRST = 0
00_00
01_01
10_10
11_11
00_01
01_10
10_11
11_00
00_10
...</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STOP_ON_ERROR</name>
              <description>Specifies the BIST to continue indefinitely, regardless of occurrence of errors or not.
'0': BIST controller doesn't stop on the data failures, it continues regardless of the errors.
'1': BIST controller stops on when the first data failure is encounted.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FM_REGION_TYPE</name>
              <description>Specifies the Flash macro region to be tested.
For eCT Flash
2'b00: Small sector region (SMS).
2'b01: Large sector region.
2'b1x: OTP region. This option is valid only when running BIST for eCT MAIN interface. Ignored when running BIST on WORK interface.
For SONOS Flash
2'b00: Main flash region
2'b01: EEPROM region
2'b1x: SFLASH region</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_EN</name>
              <description>Enable to test ECC data from Flash
0: ECC data output from Flash is not included for BIST test
1: ECC data output from Flash is included for BIST test</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ADDR_STOP_ENABLED</name>
              <description>Specifies Flash BIST stop addresses:
'0': Row and column addresses stop with their maximum/minimum values.
'1': Row and column addresses stop with their values as specified by BIST_ADDR_STOP.

This feature is supported only for simple increment/decrement patterns. It is not supported with address compliment pattern (BIST_CTL.ADDR_COMPLIMENT_ENABLED) or address pattern which increments/decrements both row address and column address (BIST_CTL.INCR_DECR_BOTH) for every read.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BIST_CMD</name>
          <description>BIST command</description>
          <addressOffset>0x204</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>MAIN_START</name>
              <description>1': Start FLASH MAIN BIST. Hardware set this field to '0' when BIST is completed.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WORK_START</name>
              <description>1': Start FLASH WORK BIST. Hardware set this field to '0' when BIST is completed.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BIST_ADDR_START</name>
          <description>BIST address start register</description>
          <addressOffset>0x208</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COL_ADDR_START</name>
              <description>Column start address. Useful to apply BIST to a part of an Flash. The value of this field should be in a legal range (a value outside of the legal range has an undefined result, and may lock up the BIST state machine). This legal range is dependent on the number of columns of the SRAM the BIST is applied to (as specified by BIST_CTL.SRAMS_ENABLED). E.g. for a Flash with n columns, the legal range is [0, n-1].</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ROW_ADDR_START</name>
              <description>Row start address. Useful to apply BIST to a part of an Flash.  The value of this field should be in a legal range (a value outside of the legal range has an undefined result, and may lock up the BIST state machine). This legal range is dependent on the number of rows of the SRAM the BIST is applied to (as specified by BIST_CTL.SRAMS_ENABLED). E.g. for a Flash with m columns, the legal range is [0, m-1].</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>8</dim>
          <dimIncrement>4</dimIncrement>
          <name>BIST_DATA[%s]</name>
          <description>BIST data register(s)</description>
          <addressOffset>0x20C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>BIST data register to store the expected value for data comparison.
For a 128-bit Flash memory, there will be 4 BIST_DATA registers to store 128-bit value.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>8</dim>
          <dimIncrement>4</dimIncrement>
          <name>BIST_MAIN_DATA_ACT[%s]</name>
          <description>BIST (main) data actual register(s)</description>
          <addressOffset>0x22C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>This field specified the actual Flash data output that caused the BIST failure.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>8</dim>
          <dimIncrement>4</dimIncrement>
          <name>BIST_MAIN_DATA_EXP[%s]</name>
          <description>BIST (main) data expected register(s)</description>
          <addressOffset>0x24C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>This field specified the expected Flash data output.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BIST_MAIN_DATA_ECC_ACT</name>
          <description>BIST (main) ECC data actual register</description>
          <addressOffset>0x26C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>This field specified the actual Flash ECC data output.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BIST_MAIN_DATA_ECC_EXP</name>
          <description>BIST (main) ECC data expected register</description>
          <addressOffset>0x270</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>This field specified the expected Flash ECC data output.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BIST_MAIN_ADDR</name>
          <description>BIST (main) address register</description>
          <addressOffset>0x274</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>COL_ADDR</name>
              <description>Current column address.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ROW_ADDR</name>
              <description>Current row address.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BIST_MAIN_STATUS</name>
          <description>BIST (main) status register</description>
          <addressOffset>0x278</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>FAIL</name>
              <description>0': BIST passed.
'1': BIST failed.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BIST_WORK_DATA_ACT</name>
          <description>BIST (work) data actual register</description>
          <addressOffset>0x27C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>This field specified the actual work Flash data output that caused the BIST failure.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BIST_WORK_DATA_EXP</name>
          <description>BIST (work) data expected register</description>
          <addressOffset>0x280</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>This field specified the expected work Flash data output.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BIST_WORK_DATA_ECC_ACT</name>
          <description>BIST (work) ECC data actual register</description>
          <addressOffset>0x284</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA_ECC</name>
              <description>This field specified the actual work Flash ECC data output.</description>
              <bitRange>[6:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BIST_WORK_DATA_ECC_EXP</name>
          <description>BIST (work) ECC data expected register</description>
          <addressOffset>0x288</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA_ECC</name>
              <description>This field specified the expected work Flash ECC data output.</description>
              <bitRange>[6:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BIST_WORK_ADDR</name>
          <description>BIST (work) address register</description>
          <addressOffset>0x28C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>COL_ADDR</name>
              <description>Current column address (work).</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ROW_ADDR</name>
              <description>Current row address (work).</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BIST_WORK_STATUS</name>
          <description>BIST (work) status register</description>
          <addressOffset>0x290</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>FAIL</name>
              <description>0': BIST (work) passed.
'1': BIST (work) failed.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BIST_ADDR_STOP</name>
          <description>BIST address stop register</description>
          <addressOffset>0x294</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COL_ADDR_STOP</name>
              <description>Column stop address. Useful to apply BIST to a part of an Flash. The value of this field should be in a legal range (a value outside of the legal range has an undefined result, and may lock up the BIST state machine). This legal range is dependent on the number of columns of the Flash the BIST is applied to. E.g. for a Flash with n columns, the legal range is [0, n-1].</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ROW_ADDR_STOP</name>
              <description>Row stop address. Useful to apply BIST to a part of an Flash.  The value of this field should be in a legal range (a value outside of the legal range has an undefined result, and may lock up the BIST state machine). This legal range is dependent on the number of rows of the Flash the BIST is applied to. E.g. for a Flash with m columns, the legal range is [0, m-1].</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ECC_CTL</name>
          <description>ECC control</description>
          <addressOffset>0x2A0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WORD_ADDR</name>
              <description>Specifies the word address where an error will be injected.
- For cache SRAM ECC, the word address WORD_ADDR[23:0] is device address A[25:2]. On a FLASH macro refill to this word address and when the corresponding CM0/4_CA_CTL.RAM_ECC_INJ_EN bit is '1', the parity (PARITY[6:0]) is injected and stored in the cache.
- For FLASH main interface ECC, the word address WORD_ADDR[23:0] is device address A[26:3]. On a FLASH main interface read and when FLASH_CTL.MAIN_ECC_INJ_EN bit is '1', the parity (PARITY[7:0]) replaces the FLASH macro parity (FLASH main interface read path is manipulated).
- For FLASH work interface ECC, the word address WORD_ADDR[23:0] is device address A[24:2]. On a FLASH work interface read and when FLASH_CTL.WORK_ECC_INJ_EN bit is '1', the parity (PARITY[6:0]) replaces the FLASH macro parity (FLASH work interface read path is manipulated).</description>
              <bitRange>[23:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY</name>
              <description>ECC parity to use for ECC error injection at address WORD_ADDR. 
- For cache SRAM ECC, the 7-bit parity PARITY[6:0] is for a 32-bit word.
- For FLASH main interface ECC, the 8-bit parity PARITY[7:0] is for a 64-bit word.
- For FLASH work interface ECC, the 7-bit parity PARITY[6:0] is for a 32-bit word.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FM_SRAM_ECC_CTL0</name>
          <description>eCT Flash SRAM ECC control 0</description>
          <addressOffset>0x2B0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ECC_INJ_DATA</name>
              <description>32-bit data for ECC error injection test of eCT Flash SRAM ECC logic.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FM_SRAM_ECC_CTL1</name>
          <description>eCT Flash SRAM ECC control 1</description>
          <addressOffset>0x2B4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7F</resetMask>
          <fields>
            <field>
              <name>ECC_INJ_PARITY</name>
              <description>7-bit parity for ECC error injection test of eCT Flash SRAM ECC logic.</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FM_SRAM_ECC_CTL2</name>
          <description>eCT Flash SRAM ECC control 2</description>
          <addressOffset>0x2B8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CORRECTED_DATA</name>
              <description>32-bit corrected data output of the ECC syndrome logic.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FM_SRAM_ECC_CTL3</name>
          <description>eCT Flash SRAM ECC control 3</description>
          <addressOffset>0x2BC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1</resetValue>
          <resetMask>0x111</resetMask>
          <fields>
            <field>
              <name>ECC_ENABLE</name>
              <description>ECC generation/check enable for eCT Flash SRAM memory.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_INJ_EN</name>
              <description>eCT Flash SRAM ECC error injection test enable. Follow the steps below for ECC logic test:
1. Write corrupted or uncorrupted 39-bit data to FM_SRAM_ECC_CTL0/1 registers.
2. Set the ECC_INJ_EN bit to '1'.
3. Confirm that the bit ECC_TEST_FAIL is '0'. If this is not the case, start over at item 1 because the eCT Flash was not idle.
4. Check the corrected data in FM_SRAM_ECC_CTL2.
5. Confirm that fault was reported to fault structure, and check syndrome (only applicable if
corrupted data was written in step 1).
6. If not finished, start over at 1 with different data.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_TEST_FAIL</name>
              <description>Status of ECC test.
1 : ECC test failed because eCT Flash macro is busy and using the SRAM.
0: ECC was performed.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_CA_CTL0</name>
          <description>CM0+ cache control</description>
          <addressOffset>0x400</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xC0000001</resetValue>
          <resetMask>0xC7030003</resetMask>
          <fields>
            <field>
              <name>RAM_ECC_EN</name>
              <description>Enable ECC checking for cache accesses:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RAM_ECC_INJ_EN</name>
              <description>Enable error injection for cache.
When '1', the parity (ECC_CTL.PARITY[6:0]) is used when a refill is done from the FLASH macro to the ECC_CTL.WORD_ADDR[23:0] word address.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WAY</name>
              <description>Specifies the cache way for which cache information is provided in CM0_CA_STATUS0/1/2.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_ADDR</name>
              <description>Specifies the cache set for which cache information is provided in CM0_CA_STATUS0/1/2.</description>
              <bitRange>[26:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PREF_EN</name>
              <description>Prefetch enable:
'0': Disabled.
'1': Enabled.

Prefetching requires the cache to be enabled; i.e. ENABLED is '1'.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CA_EN</name>
              <description>Cache enable:
'0': Disabled. The cache tag valid bits are reset to '0's and the cache LRU information is set to '1's (making way 0 the LRU way and way 3 the MRU way).
'1': Enabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_CA_CTL1</name>
          <description>CM0+ cache control</description>
          <addressOffset>0x404</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFA050003</resetValue>
          <resetMask>0xFFFF0003</resetMask>
          <fields>
            <field>
              <name>PWR_MODE</name>
              <description>Specifies power mode for CM0 cache.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>See CM4_PWR_CTL</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD</name>
                  <description>Undefined</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RETAINED</name>
                  <description>See CM4_PWR_CTL</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>See CM4_PWR_CTL</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VECTKEYSTAT</name>
              <description>Register key (to prevent accidental writes).
- Should be written with a 0x05fa key value for the write to take effect.
- Always reads as 0xfa05.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_CA_CTL2</name>
          <description>CM0+ cache control</description>
          <addressOffset>0x408</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x12C</resetValue>
          <resetMask>0x3FF</resetMask>
          <fields>
            <field>
              <name>PWRUP_DELAY</name>
              <description>Number clock cycles delay needed after power domain power up</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_CA_STATUS0</name>
          <description>CM0+ cache status 0</description>
          <addressOffset>0x440</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VALID32</name>
              <description>Sixteen valid bits of the cache line specified by CM0_CA_CTL.WAY and CM0_CA_CTL.SET_ADDR.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_CA_STATUS1</name>
          <description>CM0+ cache status 1</description>
          <addressOffset>0x444</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>TAG</name>
              <description>Cache line address of the cache line specified by CM0_CA_CTL.WAY and CM0_CA_CTL.SET_ADDR.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_CA_STATUS2</name>
          <description>CM0+ cache status 2</description>
          <addressOffset>0x448</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>LRU</name>
              <description>Six bit LRU representation of the cache set specified by CM0_CA_CTL.SET_ADDR. The encoding of the field is as follows ('X_LRU_Y' indicates that way X is Less Recently Used than way Y):
Bit 5: 0_LRU_1: way 0 less recently used than way 1.
Bit 4: 0_LRU_2.
Bit 3: 0_LRU_3.
Bit 2: 1_LRU_2.
Bit 1: 1_LRU_3.
Bit 0: 2_LRU_3.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_STATUS</name>
          <description>CM0+ interface status</description>
          <addressOffset>0x460</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>MAIN_INTERNAL_ERR</name>
              <description>Specifies/registers the occurence of a FLASH macro main interface internal error (typically the result of a read access while a program erase opertion is ongoing) as a result of a CM0+ access. 

SW clears this field to '0'. HW sets this field to '1' on a FLASH macro main interface internal error. Typically, SW reads this field after a code section to detect the occurence of an error.

Note: this field is independent of FLASH_CTL.MAIN_ERR_SILENT.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WORK_INTERNAL_ERR</name>
              <description>See CM0_STATUS.MAIN_INTERNAL_ERROR.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_CA_CTL0</name>
          <description>CM4 cache control</description>
          <addressOffset>0x480</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xC0000001</resetValue>
          <resetMask>0xC7030003</resetMask>
          <fields>
            <field>
              <name>RAM_ECC_EN</name>
              <description>See CM0_CA_CTL.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RAM_ECC_INJ_EN</name>
              <description>See CM0_CA_CTL.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WAY</name>
              <description>See CM0_CA_CTL.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_ADDR</name>
              <description>See CM0_CA_CTL.</description>
              <bitRange>[26:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PREF_EN</name>
              <description>See CM0_CA_CTL.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CA_EN</name>
              <description>See CM0_CA_CTL.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_CA_CTL1</name>
          <description>CM4 cache control</description>
          <addressOffset>0x484</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFA050003</resetValue>
          <resetMask>0xFFFF0003</resetMask>
          <fields>
            <field>
              <name>PWR_MODE</name>
              <description>Specifies power mode for CM4 cache.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>See CM4_PWR_CTL</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD</name>
                  <description>Undefined</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RETAINED</name>
                  <description>See CM4_PWR_CTL</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>See CM4_PWR_CTL</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VECTKEYSTAT</name>
              <description>Register key (to prevent accidental writes).
- Should be written with a 0x05fa key value for the write to take effect.
- Always reads as 0xfa05.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_CA_CTL2</name>
          <description>CM4 cache control</description>
          <addressOffset>0x488</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x12C</resetValue>
          <resetMask>0x3FF</resetMask>
          <fields>
            <field>
              <name>PWRUP_DELAY</name>
              <description>Number clock cycles delay needed after power domain power up</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_CA_STATUS0</name>
          <description>CM4 cache status 0</description>
          <addressOffset>0x4C0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VALID32</name>
              <description>See CM0_CA_STATUS0.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_CA_STATUS1</name>
          <description>CM4 cache status 1</description>
          <addressOffset>0x4C4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>TAG</name>
              <description>See CM0_CA_STATUS1.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_CA_STATUS2</name>
          <description>CM4 cache status 2</description>
          <addressOffset>0x4C8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>LRU</name>
              <description>See CM0_CA_STATUS2.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_STATUS</name>
          <description>CM4 interface status</description>
          <addressOffset>0x4E0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>MAIN_INTERNAL_ERR</name>
              <description>See CM0_STATUS.MAIN_INTERNAL_ERROR.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WORK_INTERNAL_ERR</name>
              <description>See CM0_STATUS.MAIN_INTERNAL_ERROR.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRYPTO_BUFF_CTL</name>
          <description>Cryptography buffer control</description>
          <addressOffset>0x500</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40000000</resetValue>
          <resetMask>0x40000000</resetMask>
          <fields>
            <field>
              <name>PREF_EN</name>
              <description>Prefetch enable:
'0': Disabled.
'1': Enabled.
A prefecth will be done when there is read 'hit' on the last 32-bit word of the buffer.
For eCT work Flash, prefetch will not be done.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DW0_BUFF_CTL</name>
          <description>Datawire 0 buffer control</description>
          <addressOffset>0x580</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40000000</resetValue>
          <resetMask>0x40000000</resetMask>
          <fields>
            <field>
              <name>PREF_EN</name>
              <description>See CRYPTO_BUFF_CTL.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DW1_BUFF_CTL</name>
          <description>Datawire 1 buffer control</description>
          <addressOffset>0x600</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40000000</resetValue>
          <resetMask>0x40000000</resetMask>
          <fields>
            <field>
              <name>PREF_EN</name>
              <description>See CRYPTO_BUFF_CTL.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_BUFF_CTL</name>
          <description>DMA controller buffer control</description>
          <addressOffset>0x680</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40000000</resetValue>
          <resetMask>0x40000000</resetMask>
          <fields>
            <field>
              <name>PREF_EN</name>
              <description>See CRYPTO_BUFF_CTL.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EXT_MS0_BUFF_CTL</name>
          <description>External master 0 buffer control</description>
          <addressOffset>0x700</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40000000</resetValue>
          <resetMask>0x40000000</resetMask>
          <fields>
            <field>
              <name>PREF_EN</name>
              <description>See CRYPTO_BUFF_CTL.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EXT_MS1_BUFF_CTL</name>
          <description>External master 1 buffer control</description>
          <addressOffset>0x780</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40000000</resetValue>
          <resetMask>0x40000000</resetMask>
          <fields>
            <field>
              <name>PREF_EN</name>
              <description>See CRYPTO_BUFF_CTL.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <name>FM_CTL_ECT</name>
          <description>Flash Macro Registers</description>
          <addressOffset>0x0000F000</addressOffset>
          <register>
            <name>FM_CTL</name>
            <description>Flash Macro Control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x8000001F</resetMask>
            <fields>
              <field>
                <name>FM_MODE</name>
                <description>Flash macro mode selection:
d0 - Read/Idle - Normal mode, read array enabled
d1 - Not Used - the 1st analog POR is done by enable/enable_hv
d2 - POR FUR Download - Downloads critical Flash initialization data from OTP (BG, rd, redu,etc...)
d3 - POR IRAM MMR Download - Downloads from OTP region the MMR / IRAM into to the 8051 RDL shadows
d4 - POR SW Download - Downloads from OTP region the SW code into to the 8051 MCU SRAM 
d5 - POR Code_Work Prepare - Loads the Code and Work Flash MG's to be ready for user mode operation
d6 - Not Used
d7 - Program 32b (WORK) - Used as program confirm command for  32 (Work) bits program
d8 - Program 64b (CODE) - Used as program confirm command for  64 (Code) bits program
d9 - Program 256b (CODE) - Used as program confirm command for  256 (Code) bits program
d10 - Program Page (CODE) - Used as program confirm command for page program for Code flash
d11 - Not Used
d12 - Sector Erase - Erase for all kinds of sectors (Code/Work/SMS)
d13 - Blank check Entry (UBC)
d14 - Blank Check Read 32bit (WORK) - Blank check mode
d15 - Blank check Exit
d16 - Not Used
d17 - Erase Suspend - Suspend command to the Erase operation
d18 - Erase Resume - Resume command to Erase suspended operation
d19 - Not Used
d20- Not Used
d21- Not Used
d22- Not Used
d23- Not Used
d24- Not Used
d25- Not Used
d26- Not Used
d27- Not Used
d28- Not Used
d29- Not Used
d30 - Not Used
d31 - Not Used</description>
                <bitRange>[4:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EMB_START</name>
                <description>'0': not active
'1': starts the actual embedded operation</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FM_CODE_MARGIN</name>
            <description>Flash Macro Margin Mode on Code Flash</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x3943</resetValue>
            <resetMask>0xE000FFFF</resetMask>
            <fields>
              <field>
                <name>MARGIN_DCS_TRIM</name>
                <description>see abive table to set the DCS reference current value to be used during Margin mode. (default set to 5uS = 0x143) which gives a Mrgin to the Erase side. 7uA would probably be used for Margin to the PGM side</description>
                <bitRange>[8:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MARGIN_DCS_TRIM_EN</name>
                <description>0 -  internal device defaults used from Margin reads reference current
1 -  MARGIN_DCS_TRIM configuration is used during Margin read</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MARGIN_RDREG_TRIM</name>
                <description>rdreg_c trim to be used in Margin mode if enabled by MARGIN_MODE_RDREG_CHNG_EN</description>
                <bitRange>[15:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MARGIN_PGM_ERS_B</name>
                <description>0 - ERS Margin is checked
1 - PGM Margin is checked</description>
                <bitRange>[29:29]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MARGIN_MODE_RDREG_CHNG_EN</name>
                <description>when set will also ise the MARGIN_RDREG_TRIM from above. Default is not to use</description>
                <bitRange>[30:30]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MARGIN_MODE_EN</name>
                <description>when set puts the s40ect Flash IP In Margin mode</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FM_ADDR</name>
            <description>Flash Macro Address</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>write-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FM_ADDR</name>
                <description>Code or Work Flash Address to be used during write operations (PGM/ERS)</description>
                <bitRange>[31:0]</bitRange>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GEOMTRY</name>
            <description>Flash Density Information</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x13</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>CODE_FLASH_DENSITY</name>
                <description>N/A</description>
                <bitRange>[2:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>WORK_FLASH_DENSITY</name>
                <description>N/A</description>
                <bitRange>[5:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CODE_FLASH_SMS_NUMBER</name>
                <description>0 - 16 sectors
1 - 32 sectors</description>
                <bitRange>[6:6]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>OTP_SIZE_KB</name>
                <description>0 - 32KB
1 - 64KB</description>
                <bitRange>[7:7]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR</name>
            <description>Interrupt</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>INTR</name>
                <description>Set to '1', when event is detected. Write INTR field with '1', to clear bit. Write INTR_SET field with '1', to set bit.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SET</name>
            <description>Interrupt Set</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>INTR_SET</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASK</name>
            <description>Interrupt Mask</description>
            <addressOffset>0x28</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>INTR_MASK</name>
                <description>Mask for corresponding field in the INTR register</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASKED</name>
            <description>Interrupt Masked</description>
            <addressOffset>0x2C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>INTR_MASKED</name>
                <description>Logical and of corresponding request and mask fields.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ECC_OVERRIDE</name>
            <description>ECC Data In override information and control bits</description>
            <addressOffset>0x30</addressOffset>
            <size>32</size>
            <access>write-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xC00000FF</resetMask>
            <fields>
              <field>
                <name>ECC_OVERRIDE_SYNDROME</name>
                <description>The override syndrome itself to be used in case one of the enables are set. It will take [7:0] in the case of Code flash and [6:0] in the case of work flash, to bypass the internal generated syndrome</description>
                <bitRange>[7:0]</bitRange>
                <access>write-only</access>
              </field>
              <field>
                <name>ECC_OVERRIDE_WORK</name>
                <description>0 - no override. Using internal ECC engine to calculate the ECC of the Work Flash</description>
                <bitRange>[30:30]</bitRange>
                <access>write-only</access>
              </field>
              <field>
                <name>ECC_OVERRIDE_CODE</name>
                <description>0 - no override. Using internal ECC engine to calculate the ECC of the Code Flash</description>
                <bitRange>[31:31]</bitRange>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FM_DATA</name>
            <description>Flash macro data_in[31 to 0] both Code and Work Flash</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <access>write-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FM_DATA</name>
                <description>Pgm command data in going to the internal write buffer (WBUF).</description>
                <bitRange>[31:0]</bitRange>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>BOOKMARK</name>
            <description>Bookmark register - keeps the current FW HV seq</description>
            <addressOffset>0x64</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>BOOKMARK</name>
                <description>Used by FW. Keeps the Current HV cycle sequence</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MAIN_FLASH_SAFETY</name>
            <description>Main (Code) Flash Security enable</description>
            <addressOffset>0x400</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>MAINFLASHWRITEENABLE</name>
                <description>'0': Main Flash embedded operations are blocked
'1': Main Flash embedded operations are enabled</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>STATUS</name>
            <description>Status read from Flash Macro</description>
            <addressOffset>0x404</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x80000000</resetValue>
            <resetMask>0xF800007F</resetMask>
            <fields>
              <field>
                <name>PGM_CODE</name>
                <description>Indicates if active PGM operation to the Code flash is taking place
'0': not running
'1': running</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PGM_WORK</name>
                <description>Indicates if active PGM operation to the Work flash is taking placec
'0': not running
'1': running</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>ERASE_CODE</name>
                <description>Indicates if active Erase operation to the Code flash is taking place
'0': not running
'1': running</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>ERASE_WORK</name>
                <description>Indicates if active Erase operation to the Work flash is taking place
'0': not running
'1': running</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>ERS_SUSPEND</name>
                <description>Indicates if Erase operation (Code/Work) is currently being suspended
'0': not suspended
'1': suspended</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>BLANK_CHECK_WORK</name>
                <description>Indicates if Blank Check mode is currently running on the work flash
'0': not running
'1': running</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>BLANK_CHCEK_PASS</name>
                <description>Indicates  the Blank check command result is PASS (Blank)
'0': Not Blank
'1': Blank (PASS)</description>
                <bitRange>[6:6]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>POR_1B_ECC_CORRECTED</name>
                <description>Indicates internal ECC found 1b error while downloading info in POR from NVM to VM and fixed it. 
Valid after 2nd, 3rd and 4th POR phases (FUR, IREM &amp; MMR, SW DOWNLOAD). If Set it is not cleaned till additional POR (rst_hf_ac_t)
'0': No error
'1': 1b ECC Error corrected in POR</description>
                <bitRange>[27:27]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>POR_2B_ECC_ERROR</name>
                <description>Indicates an internal ECC error of 2b while downloading info in POR from NVM to VM. 
Valid after 2nd, 3rd and 4th POR phases (FUR, IREM &amp; MMR, SW DOWNLOAD). If Set it is not cleaned till additional POR (rst_hf_ac_t)
'0': No error
'1': ECC 2b Error in POR</description>
                <bitRange>[28:28]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>NATIVE_POR</name>
                <description>Indicates a Native Flash state (UV) or sorted one.
Valid only after 2nd phase of POR (FUR DOWNLOAD). 
Comment: not a retained flop, therefore reset (rst_hf_act_n) puts it back to 0. If Set it is not cleaned till additional POR (rst_hf_ac_t)
'0': SORTED DEVICE (Non - Native)
'1': NATIVE</description>
                <bitRange>[29:29]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>HANG</name>
                <description>After embedded operation (pgm/erase) this flag will tell if it was successful or failed
'0': PASS
'1': FAIL</description>
                <bitRange>[30:30]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>BUSY</name>
                <description>Whenever the device is in embedded mode the RDY goes low. Should be the same as c_interrupt pin of the IP (but inverted)
'1': busy in embedded
'0': rdy (high also in erase suspend)</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>WORK_FLASH_SAFETY</name>
            <description>Work Flash Security enable</description>
            <addressOffset>0x500</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>WORKFLASHWRITEENABLE</name>
                <description>'0': Work Flash embedded operations are blocked
'1': Work Flash embedded operations are enabled</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>SRSS</name>
      <description>SRSS Core Registers (ver2)</description>
      <baseAddress>0x40260000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>PWR_LVD_STATUS</name>
          <description>High Voltage / Low Voltage Detector (HVLVD) Status Register</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>HVLVD1_OUT</name>
              <description>HVLVD1 output.
0: below voltage threshold
1: above voltage threshold</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_LVD_STATUS2</name>
          <description>High Voltage / Low Voltage Detector (HVLVD) Status Register #2</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>HVLVD2_OUT</name>
              <description>HVLVD2 output.
0: below voltage threshold
1: above voltage threshold</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>4</dimIncrement>
          <name>CLK_DSI_SELECT[%s]</name>
          <description>Clock DSI Select Register</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>DSI_MUX</name>
              <description>Selects a DSI source or low frequency clock for use in a clock path.  The output of this mux can be selected for clock PATH&lt;i&gt; using CLK_SELECT_PATH register.  Using the output of this mux as HFCLK source will result in undefined behavior.  It can be used to clocks to DSI or to the reference inputs of FLL/PLL, subject to the frequency limits of those circuits.  This mux is not glitch free, so do not change the selection while it is an actively selected clock.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DSI_OUT0</name>
                  <description>DSI0 - dsi_out[0]</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT1</name>
                  <description>DSI1 - dsi_out[1]</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT2</name>
                  <description>DSI2 - dsi_out[2]</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT3</name>
                  <description>DSI3 - dsi_out[3]</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT4</name>
                  <description>DSI4 - dsi_out[4]</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT5</name>
                  <description>DSI5 - dsi_out[5]</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT6</name>
                  <description>DSI6 - dsi_out[6]</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT7</name>
                  <description>DSI7 - dsi_out[7]</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT8</name>
                  <description>DSI8 - dsi_out[8]</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT9</name>
                  <description>DSI9 - dsi_out[9]</description>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT10</name>
                  <description>DSI10 - dsi_out[10]</description>
                  <value>10</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT11</name>
                  <description>DSI11 - dsi_out[11]</description>
                  <value>11</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT12</name>
                  <description>DSI12 - dsi_out[12]</description>
                  <value>12</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT13</name>
                  <description>DSI13 - dsi_out[13]</description>
                  <value>13</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT14</name>
                  <description>DSI14 - dsi_out[14]</description>
                  <value>14</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT15</name>
                  <description>DSI15 - dsi_out[15]</description>
                  <value>15</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ILO0</name>
                  <description>ILO0 - Internal Low-speed Oscillator #0</description>
                  <value>16</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WCO</name>
                  <description>WCO - Watch-Crystal Oscillator</description>
                  <value>17</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALTLF</name>
                  <description>ALTLF - Alternate Low-Frequency Clock</description>
                  <value>18</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PILO</name>
                  <description>PILO - Precision Internal Low-speed Oscillator</description>
                  <value>19</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ILO1</name>
                  <description>ILO1 - Internal Low-speed Oscillator #1, if present.</description>
                  <value>20</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_OUTPUT_FAST</name>
          <description>Fast Clock Output Select Register</description>
          <addressOffset>0x140</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFF0FFF</resetMask>
          <fields>
            <field>
              <name>FAST_SEL0</name>
              <description>Select signal for fast clock output #0</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NC</name>
                  <description>Disabled - output is 0.  For power savings, clocks are blocked before entering any muxes, including PATH_SEL0 and HFCLK_SEL0.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ECO</name>
                  <description>External Crystal Oscillator (ECO)</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXTCLK</name>
                  <description>External clock input (EXTCLK)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALTHF</name>
                  <description>Alternate High-Frequency (ALTHF) clock input to SRSS</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TIMERCLK</name>
                  <description>Timer clock.  It is grouped with the fast clocks because it may be a gated version of a fast clock, and therefore may have a short high pulse.</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH_SEL0</name>
                  <description>Selects the clock path chosen by PATH_SEL0 field</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HFCLK_SEL0</name>
                  <description>Selects the output of the HFCLK_SEL0 mux</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SLOW_SEL0</name>
                  <description>Selects the output of CLK_OUTPUT_SLOW.SLOW_SEL0</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PATH_SEL0</name>
              <description>Selects a clock path to use in fast clock output #0 logic.  For FLL path, it connects after the bypass mux.  For PLL path(s), it connects after the CLK_PLL_DDFT mux.
0: FLL output
1-15: PLL output on path1-path15 (if available)</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HFCLK_SEL0</name>
              <description>Selects a HFCLK tree for use in fast clock output #0</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FAST_SEL1</name>
              <description>Select signal for fast clock output #1</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NC</name>
                  <description>Disabled - output is 0.  For power savings, clocks are blocked before entering any muxes, including PATH_SEL1 and HFCLK_SEL1.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ECO</name>
                  <description>External Crystal Oscillator (ECO)</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXTCLK</name>
                  <description>External clock input (EXTCLK)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALTHF</name>
                  <description>Alternate High-Frequency (ALTHF) clock input to SRSS</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TIMERCLK</name>
                  <description>Timer clock.  It is grouped with the fast clocks because it may be a gated version of a fast clock, and therefore may have a short high pulse.</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH_SEL1</name>
                  <description>Selects the clock path chosen by PATH_SEL1 field</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HFCLK_SEL1</name>
                  <description>Selects the output of the HFCLK_SEL1 mux</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SLOW_SEL1</name>
                  <description>Selects the output of CLK_OUTPUT_SLOW.SLOW_SEL1</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PATH_SEL1</name>
              <description>Selects a clock path to use in fast clock output #1 logic.  For FLL path, it connects after the bypass mux.  For PLL path(s), it connects after the CLK_PLL_DDFT mux.
1-15: PLL output on path1-path15 (if available)</description>
              <bitRange>[23:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HFCLK_SEL1</name>
              <description>Selects a HFCLK tree for use in fast clock output #1 logic</description>
              <bitRange>[27:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_OUTPUT_SLOW</name>
          <description>Slow Clock Output Select Register</description>
          <addressOffset>0x144</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>SLOW_SEL0</name>
              <description>Select signal for slow clock output #0</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NC</name>
                  <description>Disabled - output is 0.  For power savings, clocks are blocked before entering any muxes.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ILO0</name>
                  <description>Internal Low Speed Oscillator (ILO0)</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WCO</name>
                  <description>Watch-Crystal Oscillator (WCO)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BAK</name>
                  <description>Root of the Backup domain clock tree (BAK)</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALTLF</name>
                  <description>Alternate low-frequency clock input to SRSS (ALTLF)</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LFCLK</name>
                  <description>Root of the low-speed clock tree (LFCLK)</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IMO</name>
                  <description>Internal Main Oscillator (IMO).  This is grouped with the slow clocks so it can be observed during DEEPSLEEP entry/exit.</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SLPCTRL</name>
                  <description>Sleep Controller clock (SLPCTRL).  This is grouped with the slow clocks so it can be observed during DEEPSLEEP entry/exit.</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PILO</name>
                  <description>Precision Internal Low Speed Oscillator (PILO)</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ILO1</name>
                  <description>Internal Low Speed Oscillator (ILO1), if present on the product.</description>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ECO_PRESCALER</name>
                  <description>ECO Prescaler (ECO_PRESCALER)</description>
                  <value>10</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLOW_SEL1</name>
              <description>Select signal for slow clock output #1</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NC</name>
                  <description>Disabled - output is 0.  For power savings, clocks are blocked before entering any muxes.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ILO0</name>
                  <description>Internal Low Speed Oscillator (ILO)</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WCO</name>
                  <description>Watch-Crystal Oscillator (WCO)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BAK</name>
                  <description>Root of the Backup domain clock tree (BAK)</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALTLF</name>
                  <description>Alternate low-frequency clock input to SRSS (ALTLF)</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LFCLK</name>
                  <description>Root of the low-speed clock tree (LFCLK)</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IMO</name>
                  <description>Internal Main Oscillator (IMO).  This is grouped with the slow clocks so it can be observed during DEEPSLEEP entry/exit.</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SLPCTRL</name>
                  <description>Sleep Controller clock (SLPCTRL).  This is grouped with the slow clocks so it can be observed during DEEPSLEEP entry/exit.</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PILO</name>
                  <description>Precision Internal Low Speed Oscillator (PILO)</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ILO1</name>
                  <description>Internal Low Speed Oscillator (ILO1), if present on the product.</description>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ECO_PRESCALER</name>
                  <description>ECO Prescaler (ECO_PRESCALER)</description>
                  <value>10</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_CAL_CNT1</name>
          <description>Clock Calibration Counter 1</description>
          <addressOffset>0x148</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80000000</resetValue>
          <resetMask>0x80FFFFFF</resetMask>
          <fields>
            <field>
              <name>CAL_COUNTER1</name>
              <description>Down-counter clocked on fast DDFT output #0 (see TST_DDFT_FAST_CTL). This register always reads as zero.  Counting starts internally when this register is written with a nonzero value.  CAL_COUNTER_DONE goes immediately low to indicate that the counter has started and will be asserted when the counters are done.  Do not write this field unless CAL_COUNTER_DONE==1.</description>
              <bitRange>[23:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CAL_COUNTER_DONE</name>
              <description>Status bit indicating that the internal counter #1 is finished counting and CLK_CAL_CNT2.COUNTER stopped counting up</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_CAL_CNT2</name>
          <description>Clock Calibration Counter 2</description>
          <addressOffset>0x14C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFF</resetMask>
          <fields>
            <field>
              <name>CAL_COUNTER2</name>
              <description>Up-counter clocked on fast DDFT output #1 (see TST_DDFT_FAST_CTL). When CLK_CAL_CNT1.CAL_COUNTER_DONE==1, the counter is stopped and can be read by SW.  Do not read this value unless CAL_COUNTER_DONE==1.  The expected final value is related to the ratio of clock frequencies used for the two counters and the value loaded into counter 1: CLK_CAL_CNT2.COUNTER=(F_cnt2/F_cnt1)*(CLK_CAL_CNT1.COUNTER)</description>
              <bitRange>[23:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SRSS_INTR</name>
          <description>SRSS Interrupt Register</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x26</resetMask>
          <fields>
            <field>
              <name>HVLVD1</name>
              <description>Interrupt for low voltage detector HVLVD1</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVLVD2</name>
              <description>Interrupt for low voltage detector HVLVD2</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_CAL</name>
              <description>Clock calibration counter is done</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SRSS_INTR_SET</name>
          <description>SRSS Interrupt Set Register</description>
          <addressOffset>0x204</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x26</resetMask>
          <fields>
            <field>
              <name>HVLVD1</name>
              <description>Set interrupt for low voltage detector HVLVD1</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVLVD2</name>
              <description>Set interrupt for low voltage detector HVLVD2</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_CAL</name>
              <description>Set interrupt for clock calibration counter done</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SRSS_INTR_MASK</name>
          <description>SRSS Interrupt Mask Register</description>
          <addressOffset>0x208</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x26</resetMask>
          <fields>
            <field>
              <name>HVLVD1</name>
              <description>Mask for low voltage detector HVLVD1</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVLVD2</name>
              <description>Mask for low voltage detector HVLVD2</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_CAL</name>
              <description>Mask for clock calibration done</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SRSS_INTR_MASKED</name>
          <description>SRSS Interrupt Masked Register</description>
          <addressOffset>0x20C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x26</resetMask>
          <fields>
            <field>
              <name>HVLVD1</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>HVLVD2</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CLK_CAL</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_CTL</name>
          <description>Power Mode Control</description>
          <addressOffset>0x1000</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x33</resetMask>
          <fields>
            <field>
              <name>POWER_MODE</name>
              <description>Current power mode of the device.  Note that this field cannot be read in all power modes on actual silicon.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RESET</name>
                  <description>System is resetting.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACTIVE</name>
                  <description>At least one CPU is running.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SLEEP</name>
                  <description>No CPUs are running.  Peripherals may be running.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DEEPSLEEP</name>
                  <description>Main high-frequency clock is off; low speed clocks are available.  Communication interface clocks may be present.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DEBUG_SESSION</name>
              <description>Indicates whether a debug session is active (CDBGPWRUPREQ signal is 1)</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_SESSION</name>
                  <description>No debug session active</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SESSION_ACTIVE</name>
                  <description>Debug session is active.  Power modes behave differently to keep the debug session active.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LPM_READY</name>
              <description>Indicates whether certain low power functions are ready.  The low current circuits take longer to startup after POR/XRES/BOD/HIBERNATE wakeup than the normal mode circuits.  HIBERNATE mode may be entered regardless of this bit.  ULP-only: This register is only reset by XRES/POR/BOD/OVP/HIBERNATE.
0: If a low power circuit operation is requested, it will stay in its normal operating mode until it is ready.  If DEEPSLEEP is requested by all processors WFI/WFE, the device will instead enter SLEEP.  When low power circuits are ready, device will automatically enter the originally requested mode.
1: Normal operation.  DEEPSLEEP and low power circuits operate as requested in other registers.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_CTL2</name>
          <description>Power Mode Control 2</description>
          <addressOffset>0x1004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x9F731117</resetMask>
          <fields>
            <field>
              <name>LINREG_DIS</name>
              <description>Disable the linear Core Regulator.  This is only legal when another source supplies vccd, but there is no special hardware protection for this case.  
ULP-only: This register is only reset by XRES/POR/BOD/OVP/HIBERNATE.
0: Linear regulator is on.
1: Linear regulator is off.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LINREG_OK</name>
              <description>Status of the linear Core Regulator.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>LINREG_LPMODE</name>
              <description>Control the power mode of the ULP Linear Regulator.  The value in this register is ignored and normal mode is used until LPM_READY==1.  This register is only reset by XRES/POR/BOD/OVP/HIBERNATE.
0: ULP Linear Regulator operates in normal mode.  Internal current consumption is 50uA and load current capability is 50mA to 300mA, depending on the number of regulator modules present in the product.
1: ULP Linear Regulator operates in low power mode.  Internal current consumption is 5uA and load current capability is 25mA.  Firmware must ensure the current is kept within the limit.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DPSLP_REG_DIS</name>
              <description>Disable the DeepSleep regulator.  This is only legal when another source supplies vccdpslp, but there is no special hardware protection for this case.  
ULP-only: This register is only reset by XRES/POR/BOD/OVP/HIBERNATE.
0: DeepSleep Regulator is on.
1: DeepSleep Regulator is off.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RET_REG_DIS</name>
              <description>Disable the Retention regulator.  This is only legal when another source supplies vccret, but there is no special hardware protection for this case.  
ULP-only: This register is only reset by XRES/POR/BOD/OVP/HIBERNATE.
0: Retention Regulator is on.
1: Retention Regulator is off.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NWELL_REG_DIS</name>
              <description>Disable the Nwell regulator.  This is only legal when another source supplies vnwell, but there is no special hardware protection for this case.  
ULP-only: This register is only reset by XRES/POR/BOD/OVP/HIBERNATE.
0: Nwell Regulator is on.
1: Nwell Regulator is off.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REFV_DIS</name>
              <description>Disables the voltage reference.  
ULP-only: This disables the Active voltage reference.  Firmware must ensure that LPM_READY==1 and BGREF_LPMODE==1 for at least 1us before disabling the Active Reference.  When enabling the Active Reference, use REFV_OK indicator to know when it is ready.  This register is only reset by XRES/POR/BOD/OVP/HIBERNATE.
HT-only: This bit is for testing only and is ignored when there is not a valid test key.  Do not disable the Active voltage reference during normal operation.
0: Voltage reference is enabled
1: Voltage reference is disabled</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REFV_OK</name>
              <description>Indicates that the normal mode of the voltage reference is ready.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>REFVBUF_DIS</name>
              <description>Disable the voltage reference buffer.  Firmware should only disable the buffer when there is no connected circuit that is using it.  SRSS circuits that require it are the PLL and ECO.  A particular product may have circuits outside the SRSS that use the buffer.  This register is only reset by XRES/POR/BOD/OVP/HIBERNATE.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REFVBUF_OK</name>
              <description>Indicates that the voltage reference buffer is ready.  Due to synchronization delays, it may take two IMO clock cycles for hardware to clear this bit after asserting REFVBUF_DIS=1.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>REFVBUF_LPMODE</name>
              <description>Control the power mode of the 800mV voltage reference buffer.  The value in this register is ignored and normal mode is used until LPM_READY==1.
0: ULP Voltage Reference Buffer operates in normal mode.  They work for vddd ramp rates of 100mV/us or less.  This register is only reset by XRES/POR/BOD/OVP/HIBERNATE.
1: ULP Voltage Reference Buffer operates in low power mode.  Power supply rejection is reduced to save current, and they work for vddd ramp rates of 10mV/us or less.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REFI_DIS</name>
              <description>Disable the current reference generator.  This bit is ignored when there is not a valid test key.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REFI_OK</name>
              <description>Indicates that the current reference is ready.  Due to synchronization delays, it may take two IMO clock cycles for hardware to clear this bit after asserting REFI_DIS=1.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>REFI_LPMODE</name>
              <description>Control the power mode of the reference current generator.  The value in this register is ignored and normal mode is used until LPM_READY==1.  This register is only reset by XRES/POR/BOD/OVP/HIBERNATE.
0: Current reference generator operates in normal mode.  It works for vddd ramp rates of 100mV/us or less.
1: Current reference generator operates in low power mode.  Response time is reduced to save current, and it works for vddd ramp rates of 10mV/us or less.</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PORBOD_LPMODE</name>
              <description>Control the power mode of the ULP POR/BOD circuits.  The value in this register is ignored and normal mode is used until LPM_READY==1.  This register is only reset by XRES/POR/BOD/OVP/HIBERNATE.
0: ULP POR/BOD circuits operate in normal mode.  They work for vddd ramp rates of 100mV/us or less.
1: ULP POR/BOD circuits operate in low power mode.  Response time is reduced to save current, and they work for vddd ramp rates of 10mV/us or less.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BGREF_LPMODE</name>
              <description>Control the circuit-level power mode of the Bandgap Reference circuits.   

ULP-products: Selects a second set of bandgap voltage and current generation circuits that are optimized for low current consumption.  The value in this register is ignored and higher-current mode is used until LPM_READY==1.   After this bit is set, the Active Reference circuit can be disabled to reduce current (ACT_REF_DIS=0).    Firmware is responsible to enable the Active Reference and ensure ACT_REF_OK==1 before changing back to higher current mode.  This register is only reset by XRES/POR/BOD/HIBERNATE.  The low-current circuits have less power supply rejection, and the customer must ensure vddd ramp rates of 10mV/us or less when BGREF_LPMODE==1.

HT-products: Current is reduced using a sample&amp;hold feature.  This requires ILO0 to be operating properly.  This register will not set unless CLK_ILO0_CONFIG.ILO0_ENABLE==1.  When changing back to continuous operation, keep ILO0 enabled for at least 5 cycles after clearing this bit to allow for internal synchronization.

0: Bandgap Reference circuits operate in higher current mode.
1: Bandgap Reference circuits operate in low power (see above for tradeoffs).</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PLL_LS_BYPASS</name>
              <description>Bypass level shifter inside the PLL.  Unused, if no PLL is present in the product.
0: Do not bypass the level shifter.  This setting is ok for all operational modes and vccd target voltage.
1: Bypass the level shifter.  This may reduce jitter on the PLL output clock, but can only be used when vccd is targeted to 1.1V nominal.  Otherwise, it can result in clock degradation and static current.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_HIBERNATE</name>
          <description>HIBERNATE Mode Register</description>
          <addressOffset>0x1008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xCFFEFFFF</resetMask>
          <fields>
            <field>
              <name>TOKEN</name>
              <description>Contains a 8-bit token that is retained through a HIBERNATE/WAKEUP sequence that can be used by firmware to differentiate WAKEUP from a general RESET event.  Note that waking up from HIBERNATE using XRES will reset this register.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNLOCK</name>
              <description>This byte must be set to 0x3A for FREEZE or HIBERNATE fields to operate.  Any other value in this register will cause FREEZE/HIBERNATE to have no effect, except as noted in the FREEZE description.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FREEZE</name>
              <description>Firmware sets this bit to freeze the configuration, mode and state of all GPIOs and SIOs in the system.  When entering HIBERNATE mode, the first write instructs DEEPSLEEP peripherals that they cannot ignore the upcoming freeze command.  This occurs even in the illegal condition where UNLOCK is not set.  If UNLOCK and HIBERNATE are properly set, the IOs actually freeze on the second write.  Supply supervision is disabled during HIBERNATE mode.  HIBERNATE peripherals ignore resets (excluding XRES) while FREEZE==1.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_HIBALARM</name>
              <description>When set, HIBERNATE will wakeup for a RTC interrupt</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_HIBWDT</name>
              <description>When set, HIBERNATE will wakeup for WDT interrupt</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>POLARITY_HIBPIN</name>
              <description>Each bit sets the active polarity of the corresponding wakeup pin.
0: Pin input of 0 will wakeup the part from HIBERNATE
1: Pin input of 1 will wakeup the part from HIBERNATE</description>
              <bitRange>[23:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_HIBPIN</name>
              <description>When set, HIBERNATE will wakeup if the corresponding pin input matches the POLARITY_HIBPIN setting.  Each bit corresponds to one of the wakeup pins.</description>
              <bitRange>[27:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HIBERNATE_DISABLE</name>
              <description>Hibernate disable bit.
0: Normal operation, HIBERNATE works as described
1: Further writes to this register are ignored
Note: This bit is a write-once bit until the next reset.  Avoid changing any other bits in this register while disabling HIBERNATE mode.  Also, it is recommended to clear the UNLOCK code, if it was previously written..</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HIBERNATE</name>
              <description>Firmware sets this bit to enter HIBERNATE mode.  The system will enter HIBERNATE mode immediately after writing to this bit and will wakeup only in response to XRES or WAKEUP event.  Both UNLOCK and FREEZE must have been set correctly in a previous write operations.  Otherwise, it will not enter HIBERNATE.  External supplies must have been stable for 250us before entering HIBERNATE mode.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_BUCK_CTL</name>
          <description>SIMO Buck Control Register</description>
          <addressOffset>0x1010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x5</resetValue>
          <resetMask>0xC0000007</resetMask>
          <fields>
            <field>
              <name>BUCK_OUT1_SEL</name>
              <description>Voltage output selection for vccbuck1 output.  This register is only reset by XRES/POR/BOD/OVP/HIBERNATE.  When increasing the voltage, it can take up to 200us for the output voltage to settle.  When decreasing the voltage, the settling time depends on the load current.
0: 0.85V
1: 0.875V
2: 0.90V
3: 0.95V
4: 1.05V
5: 1.10V
6: 1.15V
7: 1.20V</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BUCK_EN</name>
              <description>Master enable for buck converter.    This register is only reset by XRES/POR/BOD/OVP/HIBERNATE.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BUCK_OUT1_EN</name>
              <description>Enable for vccbuck1 output.  The value in this register is ignored unless PWR_BUCK_CTL.BUCK_EN==1.    This register is only reset by XRES/POR/BOD/OVP/HIBERNATE.  The regulator takes up to 600us to charge the external capacitor.  If there is additional load current while charging, this will increase the startup time.  The SAS specifies the required sequence when transitioning vccd from the LDO to SIMO Buck output #1.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_BUCK_CTL2</name>
          <description>SIMO Buck Control Register 2</description>
          <addressOffset>0x1014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC0000007</resetMask>
          <fields>
            <field>
              <name>BUCK_OUT2_SEL</name>
              <description>Voltage output selection for vccbuck2 output.  When increasing the voltage, it can take up to 200us for the output voltage to settle.  When decreasing the voltage, the settling time depends on the load current.
0: 1.15V
1: 1.20V
2: 1.25V
3: 1.30V
4: 1.35V
5: 1.40V
6: 1.45V
7: 1.50V</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BUCK_OUT2_HW_SEL</name>
              <description>Hardware control for vccbuck2 output.  When this bit is set, the value in BUCK_OUT2_EN is ignored and a hardware signal is used instead.  If the product has supporting hardware, it can directly control the enable signal for vccbuck2.  The same charging time in BUCK_OUT2_EN applies.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BUCK_OUT2_EN</name>
              <description>Enable for vccbuck2 output.  The value in this register is ignored unless PWR_BUCK_CTL.BUCK_EN==1.  The regulator takes up to 600us to charge the external capacitor.  If there is additional load current while charging, this will increase the startup time.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_SSV_CTL</name>
          <description>Supply Supervision Control Register</description>
          <addressOffset>0x1018</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x8080808</resetValue>
          <resetMask>0x9D909D9</resetMask>
          <fields>
            <field>
              <name>BODVDDD_VSEL</name>
              <description>Selects the voltage threshold for BOD on vddd.  Internally, this selects the proper trim code from PWR_TRIM_HT_BODVDDD_CTL.  The BOD does not reliably monitor the supply during the transition.
0: vddd&lt;2.7V
1: vddd&lt;3.0V</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BODVDDD_ENABLE</name>
              <description>Enable for BOD on vddd.  This is used for testing, and it cannot be changed unless a XRES DFT:SAFE key or PWR_SSV_TEST.UNLOCK key is present.  Clearing this bit triggers the action, unless blocked by XRES DFT:SAFE or PWR_SSV_TEST.BLOCK_SSV.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BODVDDA_VSEL</name>
              <description>Selects the voltage threshold for BOD on vdda.  Internally, this selects the proper trim code from PWR_TRIM_HT_BODVDDA_CTL.  Ensure BODVDDA_ENABLE==0 before changing this setting to prevent false triggers.
0: vdda&lt;2.7V
1: vdda&lt;3.0V</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BODVDDA_ACTION</name>
              <description>Action taken when the BOD on vdda triggers.</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NOTHING</name>
                  <description>No action</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FAULT</name>
                  <description>Generate a fault.  Cypress-only: if FAULT is selected, hardware can generate a fault when a XRES:DFT:SAFE key is present.  If this fault is not wanted, set BODVDDA_ACTION==NOTHING.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RESET</name>
                  <description>Reset the chip.  Cypress-only: hardware blocks BODVDDA reset when a XRES:DFT:SAFE key is present or unlocked PWR_SSV_TEST.BLOCK_SSV.</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BODVDDA_ENABLE</name>
              <description>Enable for BOD on vdda.  BODVDDA_ACTION will be triggered when the BOD is disabled.  If no action is desired when disabling, firmware must first write BODVDDA_ACTION=NOTHING in a separate write cycle.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BODVCCD_ENABLE</name>
              <description>Enable for BOD on vccd.  This is used for testing, and it cannot be changed unless a XRES DFT:SAFE key or PWR_SSV_TEST.UNLOCK key is present.  Clearing this bit triggers the action, unless blocked by XRES DFT:SAFE or PWR_SSV_TEST.BLOCK_SSV.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVDVDDD_VSEL</name>
              <description>Selects the voltage threshold for OVD on vddd.  Internally, this selects the proper trim code from PWR_TRIM_HT_OVDVDDD_CTL.    The OVD does not reliably monitor the supply during the transition.
0: vddd&gt;5.5V
1: vddd&gt;5.0V</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVDVDDD_ENABLE</name>
              <description>Enable for OVD on vddd.  This is used for testing, and it cannot be changed unless a XRES DFT:SAFE key or PWR_SSV_TEST.UNLOCK key is present.  Clearing this bit triggers the action, unless blocked by XRES DFT:SAFE or PWR_SSV_TEST.BLOCK_SSV.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVDVDDA_VSEL</name>
              <description>Selects the voltage threshold for OVD on vdda.  Internally, this selects the proper trim code from PWR_TRIM_HT_OVDVDDA_CTL.  Ensure OVDVDDA_ENABLE==0 before changing this setting to prevent false triggers.
0: vdda&gt;5.5V
1: vdda&gt;5.0V</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVDVDDA_ACTION</name>
              <description>Action taken when the OVD on vdda triggers.</description>
              <bitRange>[23:22]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NOTHING</name>
                  <description>No action</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FAULT</name>
                  <description>Generate a fault.  Cypress-only: if FAULT is selected, hardware can generate a fault when a XRES:DFT:SAFE key is present or when test_bootrow_ovd_off==1 .  If this fault is not wanted, set OVDVDDA_ACTION==NOTHING.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RESET</name>
                  <description>Reset the chip.  Cypress-only: hardware blocks OVDVDDA reset when a XRES:DFT:SAFE key is present, when test_bootrow_ovd_off_hv==1,  or  unlocked PWR_SSV_TEST.BLOCK_SSV.</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OVDVDDA_ENABLE</name>
              <description>Enable for OVD on vdda.  OVDVDDA_ACTION will be triggered when the OVD is disabled.  If no action is desired when disabling, firmware must first write OVDVDDA_ACTION=NOTHING in a separate write cycle.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVDVCCD_ENABLE</name>
              <description>Enable for OVD on vccd.  This is used for testing, and it cannot be changed unless a XRES DFT:SAFE key or PWR_SSV_TEST.UNLOCK key is present.  Clearing this bit triggers the action, unless blocked by XRES DFT:SAFE or PWR_SSV_TEST.BLOCK_SSV.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_SSV_STATUS</name>
          <description>Supply Supervision Status Register</description>
          <addressOffset>0x101C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x30505</resetValue>
          <resetMask>0x30707</resetMask>
          <fields>
            <field>
              <name>BODVDDD_OK</name>
              <description>BOD indicates vddd is ok.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BODVDDA_OK</name>
              <description>BOD indicates vdda is ok.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BODVCCD_OK</name>
              <description>BOD indicates vccd is ok.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OVDVDDD_OK</name>
              <description>OVD indicates vddd is ok.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OVDVDDA_OK</name>
              <description>OVD indicates vdda is ok.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OVDVCCD_OK</name>
              <description>OVD indicates vccd is ok.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OCD_ACT_LINREG_OK</name>
              <description>OCD indicates the current drawn from the linear Active Regulator is ok.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OCD_DPSLP_REG_OK</name>
              <description>OCD indicates the current drawn from the linear DeepSleep Regulator is ok.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_LVD_CTL</name>
          <description>High Voltage / Low Voltage Detector (HVLVD) Configuration Register</description>
          <addressOffset>0x1020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7DFFF</resetMask>
          <fields>
            <field>
              <name>HVLVD1_TRIPSEL</name>
              <description>Threshold selection for HVLVD1 for ULP products.  Disable the detector (HVLVD1_EN=0) before changing the threshold.
0: rise=1.225V (nom), fall=1.2V (nom)
1: rise=1.425V (nom), fall=1.4V (nom)
2: rise=1.625V (nom), fall=1.6V (nom)
3: rise=1.825V (nom), fall=1.8V (nom)
4: rise=2.025V (nom), fall=2V (nom)
5: rise=2.125V (nom), fall=2.1V (nom)
6: rise=2.225V (nom), fall=2.2V (nom)
7: rise=2.325V (nom), fall=2.3V (nom)
8: rise=2.425V (nom), fall=2.4V (nom)
9: rise=2.525V (nom), fall=2.5V (nom)
10: rise=2.625V (nom), fall=2.6V (nom)
11: rise=2.725V (nom), fall=2.7V (nom)
12: rise=2.825V (nom), fall=2.8V (nom)
13: rise=2.925V (nom), fall=2.9V (nom)
14: rise=3.025V (nom), fall=3.0V (nom)
15: rise=3.125V (nom), fall=3.1V (nom)</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVLVD1_SRCSEL</name>
              <description>Source selection for HVLVD1</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>VDDD</name>
                  <description>Select VDDD</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AMUXBUSA</name>
                  <description>Select AMUXBUSA (VDDD branch)</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VDDIO</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AMUXBUSB</name>
                  <description>Select AMUXBUSB (VDDD branch)</description>
                  <value>4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HVLVD1_EN</name>
              <description>Enable HVLVD1 voltage monitor.  HVLVD1 does not function during DEEPSLEEP, but it automatically returns to its configured setting after DEEPSLEEP wakeup.  Do not change other HVLVD1 settings when enabled.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVLVD1_TRIPSEL_HT</name>
              <description>N/A</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVLVD1_DPSLP_EN_HT</name>
              <description>Keep HVLVD1 voltage monitor enabled during DEEPSLEEP mode.  This field is only used when HVLVD1_EN_HT==1.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVLVD1_EN_HT</name>
              <description>Enable HVLVD1 voltage monitor.  This detector monitors vddd only.  Do not change other HVLVD1 settings when enabled.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVLVD1_EDGE_SEL</name>
              <description>Sets which edge(s) will trigger an action when the threshold is crossed.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLE</name>
                  <description>Disabled</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RISING</name>
                  <description>Rising edge</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FALLING</name>
                  <description>Falling edge</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BOTH</name>
                  <description>Both rising and falling edges</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HVLVD1_ACTION</name>
              <description>Action taken when the threshold is crossed in the programmed directions(s)</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INTERRUPT</name>
                  <description>Generate an interrupt</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FAULT</name>
                  <description>Generate a fault</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_LVD_CTL2</name>
          <description>High Voltage / Low Voltage Detector (HVLVD) Configuration Register #2</description>
          <addressOffset>0x1024</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7DF00</resetMask>
          <fields>
            <field>
              <name>HVLVD2_TRIPSEL_HT</name>
              <description>N/A</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVLVD2_DPSLP_EN_HT</name>
              <description>Keep HVLVD2 voltage monitor enabled during DEEPSLEEP mode.  This field is only used when HVLVD1_EN_HT==1.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVLVD2_EN_HT</name>
              <description>Enable HVLVD2 voltage monitor.  This detector monitors vddd only.  Do not change other HVLVD2 settings when enabled.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVLVD2_EDGE_SEL</name>
              <description>Sets which edge(s) will trigger an action when the threshold is crossed.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLE</name>
                  <description>Disabled</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RISING</name>
                  <description>Rising edge</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FALLING</name>
                  <description>Falling edge</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BOTH</name>
                  <description>Both rising and falling edges</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HVLVD2_ACTION</name>
              <description>Action taken when the threshold is crossed in the programmed directions(s)</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INTERRUPT</name>
                  <description>Generate an interrupt</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FAULT</name>
                  <description>Generate a fault</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>4</dimIncrement>
          <name>PWR_HIB_DATA[%s]</name>
          <description>HIBERNATE Data Register</description>
          <addressOffset>0x1040</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HIB_DATA</name>
              <description>Additional data that is retained through a HIBERNATE/WAKEUP sequence that can be used by firmware for any application-specific purpose.  Note that waking up from HIBERNATE using XRES will reset this register.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>4</dimIncrement>
          <name>CLK_PATH_SELECT[%s]</name>
          <description>Clock Path Select Register</description>
          <addressOffset>0x1200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>PATH_MUX</name>
              <description>Selects a source for clock PATH&lt;i&gt;.  Note that not all products support all clock sources.  Selecting a clock source that is not supported will result in undefined behavior.  It takes four cycles of the originally selected clock to switch away from it.  Do not disable the original clock during this time.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>IMO</name>
                  <description>IMO - Internal R/C Oscillator</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXTCLK</name>
                  <description>EXTCLK - External Clock Pin</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ECO</name>
                  <description>ECO - External-Crystal Oscillator</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALTHF</name>
                  <description>ALTHF - Alternate High-Frequency clock input (product-specific clock)</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_MUX</name>
                  <description>DSI_MUX - Output of DSI mux for this path.  Using a DSI source directly as root of HFCLK will result in undefined behavior.</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LPECO</name>
                  <description>N/A</description>
                  <value>5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>4</dimIncrement>
          <name>CLK_ROOT_SELECT[%s]</name>
          <description>Clock Root Select Register</description>
          <addressOffset>0x1240</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x8000003F</resetMask>
          <fields>
            <field>
              <name>ROOT_MUX</name>
              <description>Selects a clock path as the root of HFCLK&lt;k&gt; and for SRSS DSI input &lt;k&gt;.  Use CLK_SELECT_PATH[i] to configure the desired path.  Some paths may have FLL or PLL available (product-specific), and the control and bypass mux selections of these are in other registers.  Configure the FLL using CLK_FLL_CONFIG register.  Configure a PLL using the related CLK_PLL_CONFIG[k] register.  Note that not all products support all clock sources.  Selecting a clock source that is not supported will result in undefined behavior.  It takes four cycles of the originally selected clock to switch away from it.  Do not disable the original clock during this time.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PATH0</name>
                  <description>Select PATH0 (can be configured for FLL)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH1</name>
                  <description>Select PATH1 (can be configured for PLL0, if available in the product)</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH2</name>
                  <description>Select PATH2 (can be configured for PLL1, if available in the product)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH3</name>
                  <description>Select PATH3 (can be configured for PLL2, if available in the product)</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH4</name>
                  <description>Select PATH4 (can be configured for PLL3, if available in the product)</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH5</name>
                  <description>Select PATH5 (can be configured for PLL4, if available in the product)</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH6</name>
                  <description>Select PATH6 (can be configured for PLL5, if available in the product)</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH7</name>
                  <description>Select PATH7 (can be configured for PLL6, if available in the product)</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH8</name>
                  <description>Select PATH8 (can be configured for PLL7, if available in the product)</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH9</name>
                  <description>Select PATH9 (can be configured for PLL8, if available in the product)</description>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH10</name>
                  <description>Select PATH10 (can be configured for PLL9, if available in the product)</description>
                  <value>10</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH11</name>
                  <description>Select PATH11 (can be configured for PLL10, if available in the product)</description>
                  <value>11</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH12</name>
                  <description>Select PATH12 (can be configured for PLL11, if available in the product)</description>
                  <value>12</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH13</name>
                  <description>Select PATH13 (can be configured for PLL12, if available in the product)</description>
                  <value>13</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH14</name>
                  <description>Select PATH14 (can be configured for PLL13, if available in the product)</description>
                  <value>14</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH15</name>
                  <description>Select PATH15 (can be configured for PLL14, if available in the product)</description>
                  <value>15</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ROOT_DIV</name>
              <description>Selects predivider value for this clock root and DSI input.</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_DIV</name>
                  <description>Transparent mode, feed through selected clock source w/o dividing.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_2</name>
                  <description>Divide selected clock source by 2</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_4</name>
                  <description>Divide selected clock source by 4</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_8</name>
                  <description>Divide selected clock source by 8</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Enable for this clock root.  All clock roots default to disabled (ENABLE==0) except HFCLK0, which cannot be disabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <name>CSV_HF</name>
          <description>Clock Supervisor (CSV) registers for Root clocks</description>
          <headerStructName>CSV_HF</headerStructName>
          <addressOffset>0x00001400</addressOffset>
          <cluster>
            <dim>3</dim>
            <dimIncrement>16</dimIncrement>
            <name>CSV[%s]</name>
            <description>Active domain Clock Supervisor (CSV) registers</description>
            <headerStructName>CSV_HF_CSV</headerStructName>
            <addressOffset>0x00000000</addressOffset>
            <register>
              <name>REF_CTL</name>
              <description>Clock Supervision Reference Control</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xC000FFFF</resetMask>
              <fields>
                <field>
                  <name>STARTUP</name>
                  <description>Startup delay time -1 (in reference clock cycles), after enable or DeepSleep wakeup, from reference clock start to monitored clock start.
At a minimum (both clocks running): STARTUP &gt;= (PERIOD +3) * FREQ_RATIO - UPPER, with FREQ_RATIO = (Reference frequency / Monitored frequency)
On top of that the actual clock startup delay and the margin for accuracy of both clocks must be added.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CSV_ACTION</name>
                  <description>Specifies the action taken when an anomaly is detected on the monitored clock.  CSV in DeepSleep domain always do a Fault report (which also wakes up the system).</description>
                  <bitRange>[30:30]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>FAULT</name>
                      <description>Do a Fault report.</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RESET</name>
                      <description>Cause a power reset. This should only be used for clk_hf0.</description>
                      <value>1</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>CSV_EN</name>
                  <description>Enables clock supervision, both frequency and loss.    
CSV in Active domain: Clock supervision is reset during DeepSleep and Hibernate modes.  When enabled it begins operating automatically after a DeepSleep wakeup, but it must be reconfigured after Hibernate wakeup.  
CSV in DeepSleep domain: Clock supervision is reset during Hibernate mode.  It must be reconfigured after Hibernate wakeup.

A CSV error detection is reported to the Fault structure, or instead it can generate a power reset.</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>REF_LIMIT</name>
              <description>Clock Supervision Reference Limits</description>
              <addressOffset>0x4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>LOWER</name>
                  <description>Cycle time lower limit.  Set the lower limit -1, in reference clock cycles, before the next monitored clock event is allowed to happen.  If a monitored clock event happens before this limit is reached a CSV error is detected.
LOWER must be at least 1 less than UPPER. In case the clocks are asynchronous LOWER must be at least 3 less than UPPER.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>UPPER</name>
                  <description>Cycle time upper limit.  Set the upper limit -1, in reference clock cycles, before (or same time) the next monitored clock event must happen.  If a monitored clock event does not happen before this limit is reached, or does not happen at all (clock loss), a CSV error is detected.</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>MON_CTL</name>
              <description>Clock Supervision Monitor Control</description>
              <addressOffset>0x8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>PERIOD</name>
                  <description>Period time.  Set the Period -1, in monitored clock cycles, before the next monitored clock event happens. 
PERIOD &lt;=  (UPPER+1) / FREQ_RATIO -1, with FREQ_RATIO = (Reference frequency / Monitored frequency)
In case the clocks are asynchronous: PERIOD &lt;=  UPPER / FREQ_RATIO -1
Additionaly margin must be added for accuracy of both clocks.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
          </cluster>
        </cluster>
        <register>
          <name>CLK_SELECT</name>
          <description>Clock selection register</description>
          <addressOffset>0x1500</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF07</resetMask>
          <fields>
            <field>
              <name>LFCLK_SEL</name>
              <description>Select source for LFCLK.  Note that not all products support all clock sources.  Selecting a clock source that is not supported will result in undefined behavior.  Writes to this field are ignored unless the WDT is unlocked using WDT_LOCK register.  It takes four cycles of the originally selected clock to switch away from it.  Do not disable the original clock during this time.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ILO0</name>
                  <description>ILO0 - Internal Low-speed Oscillator #0.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WCO</name>
                  <description>WCO - Watch-Crystal Oscillator.  Requires Backup domain to be present and properly configured (including external watch crystal, if used).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALTLF</name>
                  <description>ALTLF - Alternate Low-Frequency Clock.  Capability is product-specific</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PILO</name>
                  <description>PILO - Precision ILO. If present, it works in DEEPSLEEP and higher modes.  Does not work in HIBERNATE mode.</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ILO1</name>
                  <description>ILO1 - Internal Low-speed Oscillator #1, if present.</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ECO_PRESCALE</name>
                  <description>ECO_PRESCALE - External-Crystal Oscillator after prescaling in CLK_ECO_PRESCALE.  Does not work in DEEPSLEEP or HIBERNATE modes.  Intended for applications that operate in ACTIVE/SLEEP modes only.  This option is only valid when an ECO present in the product.</description>
                  <value>5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PUMP_SEL</name>
              <description>Selects clock PATH&lt;k&gt;, where k=PUMP_SEL.  The output of this mux goes to the PUMP_DIV to make PUMPCLK  Each product has a specific number of available clock paths.  Selecting a path that is not implemented on a product will result in undefined behavior.  Note that this is not a glitch free mux.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PUMP_DIV</name>
              <description>Division ratio for PUMPCLK.  Uses selected PUMP_SEL clock as the source.</description>
              <bitRange>[14:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_DIV</name>
                  <description>Transparent mode, feed through selected clock source w/o dividing.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_2</name>
                  <description>Divide selected clock source by 2</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_4</name>
                  <description>Divide selected clock source by 4</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_8</name>
                  <description>Divide selected clock source by 8</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_16</name>
                  <description>Divide selected clock source by 16</description>
                  <value>4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PUMP_ENABLE</name>
              <description>Enable the pump clock.  PUMP_ENABLE and the PUMP_SEL mux are not glitch-free to minimize side-effects, avoid changing the PUMP_SEL and PUMP_DIV while changing PUMP_ENABLE.  To change the settings, do the following: 
1) If the pump clock is enabled, write PUMP_ENABLE=0 without changing PUMP_SEL and PUMP_DIV.  
2) Change PUMP_SEL and PUMP_DIV to desired settings with PUMP_ENABLE=0.  
3) Write PUMP_ENABLE=1 without changing PUMP_SEL and PUMP_DIV.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_TIMER_CTL</name>
          <description>Timer Clock Control Register</description>
          <addressOffset>0x1504</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x70000</resetValue>
          <resetMask>0x80FF0301</resetMask>
          <fields>
            <field>
              <name>TIMER_SEL</name>
              <description>Select source for TIMERCLK.  The output of this mux can be further divided using TIMER_DIV.  It takes four cycles of the originally selected clock to switch away from it.  Do not disable the original clock during this time.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>IMO</name>
                  <description>IMO - Internal Main Oscillator</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HF0_DIV</name>
                  <description>Select the output of the predivider configured by TIMER_HF0_DIV.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TIMER_HF0_DIV</name>
              <description>Predivider used when HF0_DIV is selected in TIMER_SEL.  If HFCLK0 frequency is less than 100MHz and has approximately 50 percent duty cycle, then no division is required (NO_DIV).  Otherwise, select a divide ratio of 2, 4, or 8 before selected HF0_DIV as the timer clock.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_DIV</name>
                  <description>Transparent mode, feed through selected clock source w/o dividing or correcting duty cycle.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_2</name>
                  <description>Divide HFCLK0 by 2.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_4</name>
                  <description>Divide HFCLK0 by 4.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_8</name>
                  <description>Divide HFCLK0 by 8.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TIMER_DIV</name>
              <description>Divide selected timer clock source by (1+TIMER_DIV).  The output of this divider is TIMERCLK  Allows for integer divisions in the range [1, 256].  Do not change this setting while the timer is enabled.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Enable for TIMERCLK.
0: TIMERCLK is off
1: TIMERCLK is enabled</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_ILO0_CONFIG</name>
          <description>ILO0 Configuration</description>
          <addressOffset>0x1508</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80000000</resetValue>
          <resetMask>0xC0000001</resetMask>
          <fields>
            <field>
              <name>ILO0_BACKUP</name>
              <description>This register indicates that ILO0 should stay enabled during XRES and HIBERNATE modes.  If backup voltage domain is implemented on the product, this bit also indicates if ILO0 should stay enabled through power-related resets on other supplies, eg. BOD on VDDD/VCCD.  Writes to this field are ignored unless the WDT is unlocked using WDT_LOCK register.  This register is reset when the backup logic resets.
0: ILO0 turns off during XRES, HIBERNATE, and power-related resets.  ILO0 configuration and trims are reset by these events.
1: ILO0 stays enabled, as described above.  ILO0 configuration and trims are not reset by these events.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ILO0_MON_ENABLE</name>
              <description>Cypress-internal: Enable the internal ILO0 clock monitoring circuit with automatic restart.  This is not offered to customers, because it is not guaranteed to produce a glitch-free clock upon restart.  Also, it does not have any status indicator that an error condition was discovered.  CSV is the recommended detection method.

Writes to this field are ignored unless the WDT is unlocked using WDT_LOCK register.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Master enable for ILO.  Writes to this field are ignored unless the WDT is unlocked using WDT_LOCK register.

HT-variant: This register will not clear unless PWR_CTL2.BGREF_LPMODE==0. After enabling, the first ILO0 cycle occurs within 12us and is +/-10 percent accuracy.  Thereafter, ILO0 is +/-5 percent accurate.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_ILO1_CONFIG</name>
          <description>ILO1 Configuration</description>
          <addressOffset>0x150C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC0000000</resetMask>
          <fields>
            <field>
              <name>ILO1_MON_ENABLE</name>
              <description>Cypress-internal: Enable the internal ILO1 clock monitoring circuit with automatic restart.  This is not offered to customers for same reasons as ILO0_MON_ENABLE.  CSV is the recommended detection method.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Master enable for ILO1.

HT-variant: After enabling, the first ILO1 cycle occurs within 12us and is +/-10 percent accuracy.  Thereafter, ILO1 is +/-5 percent accurate.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_IMO_CONFIG</name>
          <description>IMO Configuration</description>
          <addressOffset>0x1518</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80000000</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>ENABLE</name>
              <description>Master enable for IMO oscillator.  This bit must be high at all times for all functions to work properly.  Hardware will automatically disable the IMO during DEEPSLEEP, HIBERNATE, and XRES.

Cypress internal: IMO can be disabled for testing and diagnostic purposes, but various sequencers in the SRSS will no longer receive a clock.  If the IMO is re-enabled, its internal trim latches will not be initialized properly.  They can be forced to update by waiting 7us, then read CLK_TRIM_IMO_CTL and write the result back to the same register.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_ECO_CONFIG</name>
          <description>ECO Configuration Register</description>
          <addressOffset>0x151C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2</resetValue>
          <resetMask>0x98000002</resetMask>
          <fields>
            <field>
              <name>AGC_EN</name>
              <description>Automatic Gain Control (AGC) enable.  When set, the oscillation amplitude is controlled to the level selected by ECO_TRIM0.ATRIM.  When low, the amplitude is not explicitly controlled and will grow until it saturates to the supply rail (1.8V nom).  WARNING: use care when disabling AGC because driving a crystal beyond its rated limit can permanently damage the crystal.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECO_DIV_DISABLE</name>
              <description>ECO prescaler disable command (mutually exclusive with ECO_DIV_ENABLE). SW sets this field to '1' and HW sets this field to '0'.
 
HW sets ECO_DIV_DISABLE field to '0' immediately and HW sets CLK_ECO_PRESCALE.ECO_DIV_EN field to '0' immediately.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECO_DIV_ENABLE</name>
              <description>ECO prescaler enable command (mutually exclusive with ECO_DIV_DISABLE). ECO Prescaler only works in ACTIVE and SLEEP modes.  SW sets this field to '1' to enable the divider and HW sets this field to '0' to indicate that divider enabling has completed. When the divider is enabled, its integer and fractional counters are initialized to '0'. If a divider is to be re-enabled using different integer and fractional divider values, the SW should follow these steps:
0: Disable the divider using the ECO_DIV_DISABLE field.
1: Configure CLK_ECO_PRESCALE registers.
2: Enable the divider using the ECO_DIV_ENABLE field.
 
HW sets the ECO_DIV_ENABLE field to '0' when the enabling is performed and HW set CLK_ECO_PRESCALER.ENABLED to '1' when the enabling is performed.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECO_EN</name>
              <description>Master enable for ECO oscillator.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_ECO_PRESCALE</name>
          <description>ECO Prescaler Configuration Register</description>
          <addressOffset>0x1520</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FFFF01</resetMask>
          <fields>
            <field>
              <name>ECO_DIV_ENABLED</name>
              <description>ECO prescaler enabled. HW sets this field to '1' as a result of an CLK_ECO_CONFIG.ECO_DIV_ENABLE command. HW sets this field to '0' as a result on a CLK_ECO_CONFIG.ECO_DIV_DISABLE command.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ECO_FRAC_DIV</name>
              <description>8-bit fractional value, sufficient to get prescaler output within the +/-65ppm calibration range.  Do not change this setting when ECO Prescaler is enabled.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECO_INT_DIV</name>
              <description>10-bit integer value allows for ECO frequencies up to 33.55MHz.  Subtract one from the desired divide value when writing this field.  For example, to divide by 1, write ECO_INT_DIV=0.  Do not change this setting when ECO Prescaler is enabled.</description>
              <bitRange>[25:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_ECO_STATUS</name>
          <description>ECO Status Register</description>
          <addressOffset>0x1524</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>ECO_OK</name>
              <description>Indicates the ECO internal oscillator circuit has sufficient amplitude.  It may not meet the PPM accuracy or duty cycle spec.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ECO_READY</name>
              <description>Indicates the ECO internal oscillator circuit has fully stabilized.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_PILO_CONFIG</name>
          <description>Precision ILO Configuration Register</description>
          <addressOffset>0x1528</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80</resetValue>
          <resetMask>0xE00003FF</resetMask>
          <fields>
            <field>
              <name>PILO_FFREQ</name>
              <description>Fine frequency trim allowing +/-250ppm accuracy with periodic calibration.  The nominal step size of the LSB is 8Hz.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PILO_CLK_EN</name>
              <description>Enable the PILO clock output.  See PILO_EN field for required sequencing.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PILO_RESET_N</name>
              <description>Reset the PILO.  See PILO_EN field for required sequencing.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PILO_EN</name>
              <description>Enable PILO.  When enabling PILO, set PILO_EN=1, wait 1ms, then PILO_RESET_N=1 and PILO_CLK_EN=1.  When disabling PILO, clear PILO_EN=0, PILO_RESET_N=0, and PLO_CLK_EN=0 in the same write cycle.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_FLL_CONFIG</name>
          <description>FLL Configuration Register</description>
          <addressOffset>0x1530</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1000000</resetValue>
          <resetMask>0x8103FFFF</resetMask>
          <fields>
            <field>
              <name>FLL_MULT</name>
              <description>Multiplier to determine CCO frequency in multiples of the frequency of the selected reference clock (Fref).

Ffll = (FLL_MULT)  * (Fref / REFERENCE_DIV) / (OUTPUT_DIV+1)</description>
              <bitRange>[17:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FLL_OUTPUT_DIV</name>
              <description>Control bits for Output divider.  Set the divide value before enabling the FLL, and do not change it while FLL is enabled.
0: no division
1: divide by 2</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FLL_ENABLE</name>
              <description>Master enable for FLL.  Do not enable until the reference clock has stabilized.
0: Block is disabled.  The FLL must follow a disable procedure to ensure it enables properly the next time.  Shut down the FLL as follows: 1) switch all clock muxes to a different clock than FLL, 2) wait minimum 6 clk_fll cycles for the muxes to update, 3) change CLK_FLL_CONFIG3.BYPASS_SEL=0 (FLL_AUTO), 4) wait minimum 6 cycles of the reference clock to the FLL for it to update, 5) disable the FLL using this field.
1: Block is enabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_FLL_CONFIG2</name>
          <description>FLL Configuration Register 2</description>
          <addressOffset>0x1534</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x20001</resetValue>
          <resetMask>0xFFFF1FFF</resetMask>
          <fields>
            <field>
              <name>FLL_REF_DIV</name>
              <description>Control bits for reference divider.  Set the divide value before enabling the FLL, and do not change it while FLL is enabled.
0: illegal (undefined behavior)
1: divide by 1
...
8191: divide by 8191</description>
              <bitRange>[12:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCK_TOL</name>
              <description>Lock tolerance sets the error threshold for when the FLL output is considered locked to the reference input.  A high tolerance can be used to lock more quickly or allow less accuracy.  The tolerance is the allowed difference between the count value for the ideal formula and the measured value. 
0: tolerate error of 1 count value
1: tolerate error of 2 count values
...
255: tolerate error of 256 count values</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UPDATE_TOL</name>
              <description>Update tolerance sets the error threshold for when the FLL will update the CCO frequency settings.  The update tolerance is the allowed difference between the count value for the ideal formula and the measured value. UPDATE_TOL should be less than LOCK_TOL.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_FLL_CONFIG3</name>
          <description>FLL Configuration Register 3</description>
          <addressOffset>0x1538</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2800</resetValue>
          <resetMask>0x301FFFFF</resetMask>
          <fields>
            <field>
              <name>FLL_LF_IGAIN</name>
              <description>FLL Loop Filter Integral Gain Setting
0: 1/256
1: 1/128
2: 1/64
3: 1/32
4: 1/16
5: 1/8
6: 1/4
7: 1/2
8: 1.0
9: 2.0
10: 4.0
11: 8.0
&gt;=12: illegal</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FLL_LF_PGAIN</name>
              <description>FLL Loop Filter Proportional Gain Setting
0: 1/256
1: 1/128
2: 1/64
3: 1/32
4: 1/16
5: 1/8
6: 1/4
7: 1/2
8: 1.0
9: 2.0
10: 4.0
11: 8.0
&gt;=12: illegal</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SETTLING_COUNT</name>
              <description>Number of undivided reference clock cycles to wait after changing the CCO trim until the loop measurement restarts.  A delay allows the CCO output to settle and gives a more accurate measurement.  The default is tuned to an 8MHz reference clock since the IMO is expected to be the most common use case.
0: no settling time
1: wait one reference clock cycle
...
8191: wait 8191 reference clock cycles</description>
              <bitRange>[20:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BYPASS_SEL</name>
              <description>Bypass mux located just after FLL output.  This register can be written while the FLL is enabled.  When changing BYPASS_SEL, do not turn off the reference clock or CCO clock for five cycles (whichever is slower).</description>
              <bitRange>[29:28]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>AUTO</name>
                  <description>Automatic using lock indicator.  When unlocked, automatically selects FLL reference input (bypass mode).  When locked, automatically selects FLL output.  This can allow some processing to occur while the FLL is locking, such as after DEEPSLEEP wakeup.  It is incompatible with clock supervision, because the frequency changes based on the lock signal.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LOCKED_OR_NOTHING</name>
                  <description>Similar to AUTO, except the clock is gated off when unlocked.  This is compatible with clock supervision, because the supervisors allow no clock during startup (until a timeout occurs), and the clock targets the proper frequency whenever it is running.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FLL_REF</name>
                  <description>Select FLL reference input (bypass mode).  Ignores lock indicator</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FLL_OUT</name>
                  <description>Select FLL output.  Ignores lock indicator.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_FLL_CONFIG4</name>
          <description>FLL Configuration Register 4</description>
          <addressOffset>0x153C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFF</resetValue>
          <resetMask>0xC1FF07FF</resetMask>
          <fields>
            <field>
              <name>CCO_LIMIT</name>
              <description>Maximum CCO offset allowed (used to prevent FLL dynamics from selecting an CCO frequency that the logic cannot support)</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CCO_RANGE</name>
              <description>Frequency range of CCO</description>
              <bitRange>[10:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RANGE0</name>
                  <description>Target frequency is in range [48, 64) MHz</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RANGE1</name>
                  <description>Target frequency is in range [64, 85) MHz</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RANGE2</name>
                  <description>Target frequency is in range [85, 113) MHz</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RANGE3</name>
                  <description>Target frequency is in range [113, 150) MHz</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RANGE4</name>
                  <description>Target frequency is in range [150, 200] MHz</description>
                  <value>4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CCO_FREQ</name>
              <description>CCO frequency code.  This is updated by HW when the FLL is enabled.  It can be manually updated to use the CCO in an open loop configuration.  The meaning of each frequency code depends on the range.</description>
              <bitRange>[24:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CCO_HW_UPDATE_DIS</name>
              <description>Disable CCO frequency update by FLL hardware
0: Hardware update of CCO settings is allowed.  Use this setting for normal FLL operation.
1: Hardware update of CCO settings is disabled.  Use this setting for open-loop FLL operation.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CCO_ENABLE</name>
              <description>Enable the CCO.  It is required to enable the CCO before using the FLL.  
0: Block is powered off
1: Block is powered on</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_FLL_STATUS</name>
          <description>FLL Status Register</description>
          <addressOffset>0x1540</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>LOCKED</name>
              <description>FLL Lock Indicator</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UNLOCK_OCCURRED</name>
              <description>This bit sets whenever the FLL is enabled and goes out of lock.  This bit stays set until cleared by firmware.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CCO_READY</name>
              <description>This indicates that the CCO is internally settled and ready to use.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_ECO_CONFIG2</name>
          <description>ECO Configuration Register 2</description>
          <addressOffset>0x1544</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3</resetValue>
          <resetMask>0x7FF7</resetMask>
          <fields>
            <field>
              <name>WDTRIM</name>
              <description>Watch Dog Trim -  Delta voltage below stead state level
0x0 - 50mV
0x1 - 75mV
0x2 - 100mV
0x3 - 125mV
0x4 - 150mV
0x5 - 175mV
0x6 - 200mV
0x7 - 225mV</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ATRIM</name>
              <description>Amplitude trim to set the crystal drive level when ECO_CONFIG.AGC_EN=1.  WARNING: use care when setting this field because driving a crystal beyond its rated limit can permanently damage the crystal.
0x0 - 150mV
0x1 - 175mV
0x2 - 200mV
0x3 - 225mV
0x4 - 250mV
0x5 - 275mV
0x6 - 300mV
0x7 - 325mV
0x8 - 350mV
0x9 - 375mV
0xA - 400mV
0xB - 425mV
0xC - 450mV
0xD - 475mV
0xE - 500mV
0xF - 525mV</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FTRIM</name>
              <description>Filter Trim - 3rd harmonic oscillation</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RTRIM</name>
              <description>Feedback resistor Trim</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GTRIM</name>
              <description>Gain Trim - Startup time.
ULP-only: ULP ECO requires only two bits, so the two LSBs are used; the MSB is not used.</description>
              <bitRange>[14:12]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>15</dim>
          <dimIncrement>4</dimIncrement>
          <name>CLK_PLL_CONFIG[%s]</name>
          <description>PLL Configuration Register</description>
          <addressOffset>0x1600</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x20116</resetValue>
          <resetMask>0xBE1F1F7F</resetMask>
          <fields>
            <field>
              <name>FEEDBACK_DIV</name>
              <description>Control bits for feedback divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
0-21: illegal (undefined behavior)
22: divide by 22
...
112: divide by 112
&gt;112: illegal (undefined behavior)</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REFERENCE_DIV</name>
              <description>Control bits for reference divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
0: illegal (undefined behavior)
1: divide by 1
...
20: divide by 20
others: illegal (undefined behavior)</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OUTPUT_DIV</name>
              <description>Control bits for Output divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
0: illegal (undefined behavior)
1: illegal (undefined behavior) 
2: divide by 2.  Suitable for direct usage as HFCLK source.
...
16: divide by 16.  Suitable for direct usage as HFCLK source.
&gt;16: illegal (undefined behavior)</description>
              <bitRange>[20:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCK_DELAY</name>
              <description>Static phase error window.
0: 20.66ns
1: 31.38ns
2: 42.1ns
3: 52.9ns</description>
              <bitRange>[26:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PLL_LF_MODE</name>
              <description>VCO frequency range selection.  Configure this bit according to the targeted VCO frequency.  Do not change this setting while the PLL is enabled.
0: VCO frequency is [200MHz, 400MHz]
1: VCO frequency is [170MHz, 200MHz)</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BYPASS_SEL</name>
              <description>Bypass mux located just after PLL output.  This selection is glitch-free and can be changed while the PLL is running.  When changing BYPASS_SEL, do not turn off the reference clock or PLL clock for five cycles (whichever is slower).</description>
              <bitRange>[29:28]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>AUTO</name>
                  <description>Automatic using lock indicator.  When unlocked, automatically selects PLL reference input (bypass mode).  When locked, automatically selects PLL output.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LOCKED_OR_NOTHING</name>
                  <description>Similar to AUTO, except the clock is gated off when unlocked.  This is compatible with clock supervision, because the supervisors allow no clock during startup (until a timeout occurs), and the clock targets the proper frequency whenever it is running.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PLL_REF</name>
                  <description>Select PLL reference input (bypass mode).  Ignores lock indicator</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PLL_OUT</name>
                  <description>Select PLL output.  Ignores lock indicator.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Master enable for PLL.  Setup FEEDBACK_DIV, REFERENCE_DIV, and OUTPUT_DIV at least one cycle before setting ENABLE=1.   The PLL takes up to 4 cycles to disable.

Fpll = (FEEDBACK_DIV)  * (Fref / REFERENCE_DIV) / (OUTPUT_DIV)

0: Block is disabled
1: Block is enabled</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>15</dim>
          <dimIncrement>4</dimIncrement>
          <name>CLK_PLL_STATUS[%s]</name>
          <description>PLL Status Register</description>
          <addressOffset>0x1640</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>LOCKED</name>
              <description>PLL Lock Indicator</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UNLOCK_OCCURRED</name>
              <description>This bit sets whenever the PLL Lock bit goes low, and stays set until cleared by firmware.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSV_REF_SEL</name>
          <description>Select CSV Reference clock for Active domain</description>
          <addressOffset>0x1700</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>REF_MUX</name>
              <description>Selects a source for clock clk_ref_hf.  Note that not all products support all clock sources.  Selecting a clock source that is not supported will result in undefined behavior.   It takes four cycles of the originally selected clock to switch away from it.  Do not disable the original clock during this time.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>IMO</name>
                  <description>IMO - Internal R/C Oscillator</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXTCLK</name>
                  <description>EXTCLK - External Clock Pin</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ECO</name>
                  <description>ECO - External-Crystal Oscillator</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALTHF</name>
                  <description>ALTHF - Alternate High-Frequency clock input (product-specific clock)</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <cluster>
          <name>CSV_REF</name>
          <description>CSV registers for the CSV Reference clock</description>
          <headerStructName>CSV_REF</headerStructName>
          <addressOffset>0x00001710</addressOffset>
          <cluster>
            <name>CSV</name>
            <description>Active domain Clock Supervisor (CSV) registers for CSV Reference clock</description>
            <headerStructName>CSV_REF_CSV</headerStructName>
            <addressOffset>0x00000000</addressOffset>
            <register>
              <name>REF_CTL</name>
              <description>Clock Supervision Reference Control</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xC000FFFF</resetMask>
              <fields>
                <field>
                  <name>STARTUP</name>
                  <description>Startup delay time -1 (in reference clock cycles), after enable or DeepSleep wakeup, from reference clock start to monitored clock start.
At a minimum (both clocks running): STARTUP &gt;= (PERIOD +3) * FREQ_RATIO - UPPER, with FREQ_RATIO = (Reference frequency / Monitored frequency)
On top of that the actual clock startup delay and the margin for accuracy of both clocks must be added.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CSV_ACTION</name>
                  <description>Specifies the action taken when an anomaly is detected on the monitored clock.  CSV in DeepSleep domain always do a Fault report (which also wakes up the system).</description>
                  <bitRange>[30:30]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>FAULT</name>
                      <description>Do a Fault report.</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RESET</name>
                      <description>Cause a power reset. This should only be used for clk_hf0.</description>
                      <value>1</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>CSV_EN</name>
                  <description>Enables clock supervision, both frequency and loss.    
CSV in Active domain: Clock supervision is reset during DeepSleep and Hibernate modes.  When enabled it begins operating automatically after a DeepSleep wakeup, but it must be reconfigured after Hibernate wakeup.  
CSV in DeepSleep domain: Clock supervision is reset during Hibernate mode.  It must be reconfigured after Hibernate wakeup.

A CSV error detection is reported to the Fault structure, or instead it can generate a power reset.</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>REF_LIMIT</name>
              <description>Clock Supervision Reference Limits</description>
              <addressOffset>0x4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>LOWER</name>
                  <description>Cycle time lower limit.  Set the lower limit -1, in reference clock cycles, before the next monitored clock event is allowed to happen.  If a monitored clock event happens before this limit is reached a CSV error is detected.
LOWER must be at least 1 less than UPPER. In case the clocks are asynchronous LOWER must be at least 3 less than UPPER.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>UPPER</name>
                  <description>Cycle time upper limit.  Set the upper limit -1, in reference clock cycles, before (or same time) the next monitored clock event must happen.  If a monitored clock event does not happen before this limit is reached, or does not happen at all (clock loss), a CSV error is detected.</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>MON_CTL</name>
              <description>Clock Supervision Monitor Control</description>
              <addressOffset>0x8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>PERIOD</name>
                  <description>Period time.  Set the Period -1, in monitored clock cycles, before the next monitored clock event happens. 
PERIOD &lt;=  (UPPER+1) / FREQ_RATIO -1, with FREQ_RATIO = (Reference frequency / Monitored frequency)
In case the clocks are asynchronous: PERIOD &lt;=  UPPER / FREQ_RATIO -1
Additionaly margin must be added for accuracy of both clocks.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
          </cluster>
        </cluster>
        <cluster>
          <name>CSV_LF</name>
          <description>CSV registers for LF clock</description>
          <headerStructName>CSV_LF</headerStructName>
          <addressOffset>0x00001720</addressOffset>
          <cluster>
            <name>CSV</name>
            <description>LF clock Clock Supervisor registers</description>
            <headerStructName>CSV_LF_CSV</headerStructName>
            <addressOffset>0x00000000</addressOffset>
            <register>
              <name>REF_CTL</name>
              <description>Clock Supervision Reference Control</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x800000FF</resetMask>
              <fields>
                <field>
                  <name>STARTUP</name>
                  <description>Startup delay time -1 (in reference clock cycles), after DeepSleep wakeup, from reference clock start to monitored clock start.
At a minimum (both clocks running): STARTUP &gt;= (PERIOD +3) * FREQ_RATIO - UPPER, with FREQ_RATIO = (Reference frequency / Monitored frequency)
On top of that the actual clock startup delay and the margin for accuracy of both clocks must be added.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CSV_EN</name>
                  <description>Enables clock supervision, both frequency and loss.    
CSV in Active domain: Clock supervision is reset during DeepSleep and Hibernate modes.  When enabled it begins operating automatically after a DeepSleep wakeup, but it must be reconfigured after Hibernate wakeup.  
CSV in DeepSleep domain: Clock supervision is reset during Hibernate mode.  It must be reconfigured after Hibernate wakeup.

A CSV error detection is reported to the Fault structure, or instead it can generate a power reset.</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>REF_LIMIT</name>
              <description>Clock Supervision Reference Limits</description>
              <addressOffset>0x4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFF00FF</resetMask>
              <fields>
                <field>
                  <name>LOWER</name>
                  <description>Cycle time lower limit.  Set the lower limit -1, in reference clock cycles, before the next monitored clock event is allowed to happen.  If a monitored clock event happens before this limit is reached a CSV error is detected.
LOWER must be at least 1 less than UPPER. In case the clocks are asynchronous LOWER must be at least 3 less than UPPER.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>UPPER</name>
                  <description>Cycle time upper limit.  Set the upper limit -1, in reference clock cycles, before (or same time) the next monitored clock event must happen.  If a monitored clock event does not happen before this limit is reached, or does not happen at all (clock loss), a CSV error is detected.</description>
                  <bitRange>[23:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>MON_CTL</name>
              <description>Clock Supervision Monitor Control</description>
              <addressOffset>0x8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFF</resetMask>
              <fields>
                <field>
                  <name>PERIOD</name>
                  <description>Period time.  Set the Period -1, in monitored clock cycles, before the next monitored clock event happens. 
PERIOD &lt;=  (UPPER+1) / FREQ_RATIO -1, with FREQ_RATIO = (Reference frequency / Monitored frequency)
In case the clocks are asynchronous: PERIOD &lt;=  UPPER / FREQ_RATIO -1
Additionaly margin must be added for accuracy of both clocks.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
          </cluster>
        </cluster>
        <cluster>
          <name>CSV_ILO</name>
          <description>CSV registers for HVILO clock</description>
          <headerStructName>CSV_ILO</headerStructName>
          <addressOffset>0x00001730</addressOffset>
          <cluster>
            <name>CSV</name>
            <description>HVILO clock DeepSleep domain Clock Supervisor registers</description>
            <headerStructName>CSV_ILO_CSV</headerStructName>
            <addressOffset>0x00000000</addressOffset>
            <register>
              <name>REF_CTL</name>
              <description>Clock Supervision Reference Control</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x800000FF</resetMask>
              <fields>
                <field>
                  <name>STARTUP</name>
                  <description>Startup delay time -1 (in reference clock cycles), after DeepSleep wakeup, from reference clock start to monitored clock start.
At a minimum (both clocks running): STARTUP &gt;= (PERIOD +3) * FREQ_RATIO - UPPER, with FREQ_RATIO = (Reference frequency / Monitored frequency)
On top of that the actual clock startup delay and the margin for accuracy of both clocks must be added.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CSV_EN</name>
                  <description>Enables clock supervision, both frequency and loss.    
CSV in Active domain: Clock supervision is reset during DeepSleep and Hibernate modes.  When enabled it begins operating automatically after a DeepSleep wakeup, but it must be reconfigured after Hibernate wakeup.  
CSV in DeepSleep domain: Clock supervision is reset during Hibernate mode.  It must be reconfigured after Hibernate wakeup.

A CSV error detection is reported to the Fault structure, or instead it can generate a power reset.</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>REF_LIMIT</name>
              <description>Clock Supervision Reference Limits</description>
              <addressOffset>0x4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFF00FF</resetMask>
              <fields>
                <field>
                  <name>LOWER</name>
                  <description>Cycle time lower limit.  Set the lower limit -1, in reference clock cycles, before the next monitored clock event is allowed to happen.  If a monitored clock event happens before this limit is reached a CSV error is detected.
LOWER must be at least 1 less than UPPER. In case the clocks are asynchronous LOWER must be at least 3 less than UPPER.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>UPPER</name>
                  <description>Cycle time upper limit.  Set the upper limit -1, in reference clock cycles, before (or same time) the next monitored clock event must happen.  If a monitored clock event does not happen before this limit is reached, or does not happen at all (clock loss), a CSV error is detected.</description>
                  <bitRange>[23:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>MON_CTL</name>
              <description>Clock Supervision Monitor Control</description>
              <addressOffset>0x8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFF</resetMask>
              <fields>
                <field>
                  <name>PERIOD</name>
                  <description>Period time.  Set the Period -1, in monitored clock cycles, before the next monitored clock event happens. 
PERIOD &lt;=  (UPPER+1) / FREQ_RATIO -1, with FREQ_RATIO = (Reference frequency / Monitored frequency)
In case the clocks are asynchronous: PERIOD &lt;=  UPPER / FREQ_RATIO -1
Additionaly margin must be added for accuracy of both clocks.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
          </cluster>
        </cluster>
        <register>
          <name>RES_CAUSE</name>
          <description>Reset Cause Observation Register</description>
          <addressOffset>0x1800</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40000000</resetValue>
          <resetMask>0x71FF01FF</resetMask>
          <fields>
            <field>
              <name>RESET_WDT</name>
              <description>A basic WatchDog Timer (WDT) reset has occurred since last power cycle.  ULP products: This is a low-voltage cause bit that hardware clears when the low-voltage supply is initialized (see comments above).
HT products: This is a high-voltage cause bit that blocks recording of other high-voltage cause bits, except RESET_PORVDDD.  Hardware clears this bit during POR.  This bit is not blocked by other HV cause bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_ACT_FAULT</name>
              <description>Fault logging system requested a reset from its Active logic.  This is a low-voltage cause bit that hardware clears when the low-voltage supply is initialized (see comments above).</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_DPSLP_FAULT</name>
              <description>Fault logging system requested a reset from its DeepSleep logic.  This is a low-voltage cause bit that hardware clears when the low-voltage supply is initialized (see comments above).</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_TC_DBGRESET</name>
              <description>Test controller or debugger asserted reset. Only resets debug domain.  This is a low-voltage cause bit that hardware clears when the low-voltage supply is initialized (see comments above).</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_SOFT</name>
              <description>A CPU requested a system reset through it's SYSRESETREQ.  This can be done via a debugger probe or in firmware.  This is a low-voltage cause bit that hardware clears when the low-voltage supply is initialized (see comments above).</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_MCWDT0</name>
              <description>Multi-Counter Watchdog timer reset #0.  This is a low-voltage cause bit that hardware clears when the low-voltage supply is initialized (see comments above).</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_MCWDT1</name>
              <description>Multi-Counter Watchdog timer reset #1.  This is a low-voltage cause bit that hardware clears when the low-voltage supply is initialized (see comments above).</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_MCWDT2</name>
              <description>Multi-Counter Watchdog timer reset #2.  This is a low-voltage cause bit that hardware clears when the low-voltage supply is initialized (see comments above).</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_MCWDT3</name>
              <description>Multi-Counter Watchdog timer reset #3.  This is a low-voltage cause bit that hardware clears when the low-voltage supply is initialized (see comments above).</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_XRES</name>
              <description>External XRES pin was asserted.  This is a high-voltage cause bit that blocks recording of other high-voltage cause bits, except RESET_PORVDDD.  Hardware clears this bit during POR.  This bit is not blocked by other HV cause bits.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_BODVDDD</name>
              <description>External VDDD supply crossed brown-out limit.  Note that this cause will only be observable as long as the VDDD supply does not go below the POR (power on reset) detection limit.  Below this limit it is not possible to reliably retain information in the device.  This is a high-voltage cause bit that blocks recording of other high-voltage cause bits, except RESET_PORVDDD.  Hardware clears this bit during POR.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_BODVDDA</name>
              <description>External VDDA supply crossed the brown-out limit.  This is a high-voltage cause bit that blocks recording of other high-voltage cause bits, except RESET_PORVDDD.  Hardware clears this bit during POR.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_BODVCCD</name>
              <description>Internal VCCD core supply crossed the brown-out limit.  Note that this detector will detect gross issues with the internal core supply, but may not catch all brown-out conditions.  Functional and timing supervision (CSV, WDT) is provided to create fully failsafe internal crash detection.  This is a high-voltage cause bit that blocks recording of other high-voltage cause bits, except RESET_PORVDDD.  Hardware clears this bit during POR.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_OVDVDDD</name>
              <description>Overvoltage detection on the external VDDD supply.  This is a high-voltage cause bit that blocks recording of other high-voltage cause bits, except RESET_PORVDDD.  Hardware clears this bit during POR.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_OVDVDDA</name>
              <description>Overvoltage detection on the external VDDA supply.  This is a high-voltage cause bit that blocks recording of other high-voltage cause bits, except RESET_PORVDDD.  Hardware clears this bit during POR.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_OVDVCCD</name>
              <description>Overvoltage detection on the internal core VCCD supply.  This is a high-voltage cause bit that blocks recording of other high-voltage cause bits, except RESET_PORVDDD.  Hardware clears this bit during POR.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_OCD_ACT_LINREG</name>
              <description>Overcurrent detection on the internal VCCD supply when supplied by the ACTIVE power mode linear regulator.  This is a high-voltage cause bit that blocks recording of other high-voltage cause bits, except RESET_PORVDDD.  Hardware clears this bit during POR.</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_OCD_DPSLP_LINREG</name>
              <description>Overcurrent detection on the internal VCCD supply when supplied by the DEEPSLEEP power mode linear regulator.  This is a high-voltage cause bit that blocks recording of other high-voltage cause bits, except RESET_PORVDDD.  Hardware clears this bit during POR.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_PXRES</name>
              <description>PXRES triggered.  This is a high-voltage cause bit that blocks recording of other high-voltage cause bits, except RESET_PORVDDD.  Hardware clears this bit during POR.  This bit is not blocked by other HV cause bits.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_STRUCT_XRES</name>
              <description>Structural reset was asserted.  This is a high-voltage cause bit that blocks recording of other high-voltage cause bits, except RESET_PORVDDD.  Hardware clears this bit during POR.  This bit is not blocked by other HV cause bits.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_PORVDDD</name>
              <description>Indicator that a POR occurred.  This is a high-voltage cause bit, and hardware clears the other bits when this one is set.  It does not block further recording of other high-voltage causes.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RES_CAUSE2</name>
          <description>Reset Cause Observation Register 2</description>
          <addressOffset>0x1804</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1FFFF</resetMask>
          <fields>
            <field>
              <name>RESET_CSV_HF</name>
              <description>Clock supervision logic requested a reset due to loss or frequency violation of a high-frequency clock.  Each bit index K corresponds to a HFCLK&lt;K&gt;.  Unimplemented clock bits return zero.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_CSV_REF</name>
              <description>Clock supervision logic requested a reset due to loss or frequency violation of the reference clock source that is used to monitor the other HF clock sources.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TST_XRES_KEY</name>
          <description>XRES DFT Key firmware controlled test mode entry register</description>
          <addressOffset>0x2050</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x4F07</resetMask>
          <fields>
            <field>
              <name>KEY_IN</name>
              <description>Connected to the XRES DFT key shift register input.  Value of this bit must be set before change KEY_CLK from low to high.  Value may be changed on the same cycle that changes KEY_CLK from high to low.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>KEY_CLK</name>
              <description>Connected to the XRES DFT key shift register clock.  Must be toggled low to high and back for each key bit to be shifted in.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>KEY_START</name>
              <description>This field is used to start the state machine controlling firmware-initiated key entry.  Write this field high when the 128b key is being sent, and otherwise keep it low.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>KEY_MODE</name>
              <description>'Declares' the test mode that firmware is going to shift into the key register using KEY_IN/KEY_CLK.  This field must maintain the proper test mode value for a firmware-initiated test mode key to be effective.  If this field is changed (or reset), the firmware-initiated test mode is exited immediately.  This field has no effect on XRES or PWR_DDFT_XRES initiated test modes.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DISABLE</name>
              <description>Disables the firmware key entry capability until next reset.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TST_XRES_SECURE</name>
          <description>SECURE TEST and FIRMWARE TEST Key control register</description>
          <addressOffset>0x2054</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xE00F0FFF</resetMask>
          <fields>
            <field>
              <name>DATA8</name>
              <description>Data byte to be set into eithe SECURE TEST or FIRMWARE TEST key.  Must not be changed in the same write that is toggling any of the *_WR bits below,</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FW_WR</name>
              <description>Latch enables for each of the 4 bytes in the 32-bit FIRMWARE TEST key.  Must be toggled high and then low while keeping DATA8 to the correct value.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SECURE_WR</name>
              <description>Latch enables for each of the 4 bytes in the 32-bit SECURE TEST key.  Must be toggled high and then low while keeping DATA8 to the correct value.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FW_KEY_OK</name>
              <description>Indicates that the 32-bit FIRMWARE TEST key is observing the correct key.  Firmware key is reset by (A)XRES and STRUCT_XRES.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SECURE_KEY_OK</name>
              <description>Indicates that the 32-bit SECURE TEST key is observing the correct key.  Secure key is not reset, but it will establish low after a deep power cycle that causes it to lose its written state.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SECURE_DISABLE</name>
              <description>Disables the SECURE TEST key entry capability until next reset.   Must not be set in the same write when any of the above *_WR bits are set or toggling.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RES_PXRES_CTL</name>
          <description>Programmable XRES Control Register</description>
          <addressOffset>0x207C</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>PXRES_TRIGGER</name>
              <description>Triggers PXRES.  This causes a full-scope reset and reboot.</description>
              <bitRange>[0:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_TRIM_WAKE_CTL</name>
          <description>Wakeup Trim Register</description>
          <addressOffset>0x3008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>WAKE_DELAY</name>
              <description>Wakeup holdoff specifies the number of IMO cycles for power system settling before continuing the wakeup sequence.  Fastest wakeup is achieved by using the smallest number allowed for the product.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_TRIM_ILO0_CTL</name>
          <description>ILO0 Trim Register</description>
          <addressOffset>0x3014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x52C</resetValue>
          <resetMask>0xF3F</resetMask>
          <fields>
            <field>
              <name>ILO0_FTRIM</name>
              <description>ILO0 frequency trims.  LSB step size is 1.5 percent (typical) of the frequency.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ILO0_MONTRIM</name>
              <description>ILO0 internal monitor trim.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_TRIM_PWRSYS_CTL</name>
          <description>Power System Trim Register</description>
          <addressOffset>0x3108</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x17</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>ACT_REG_TRIM</name>
              <description>Trim for the Active-Regulator.  This sets the output voltage level.  This register is only reset by XRES/POR/BOD/OVP/HIBERNATE.  The nominal output voltage is vccd=812.5mV + ACT_REG_TRIM*12.5mV.  The actual output voltage will vary depending on conditions and load.  The following settings are explicitly shown for convenience, and other values may be calculated using the formula:
5'h07: 900mV (nominal)
5'h17: 1100mV (nominal)</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACT_REG_BOOST</name>
              <description>Controls the tradeoff between output current and internal operating current for the Active Regulator.  The maximum output current depends on the silicon implementation, but an application may limit its maximum current to less than that.  This may allow a reduction in the internal operating current of the regulator.  The regulator internal operating current depends on the boost setting:
2'b00: 50uA
2'b01: 100uA
2'b10: 150uA
2'b11: 200uA

The allowed setting is a lookup table based on the chip-specific maximum (set in factory) and an application-specific maximum (set by customer).  The defaults are set assuming the application consumes the maximum allowed by the chip.
50mA chip: 2'b00 (default);
100mA chip: 2'b00 (default);
150mA chip: 50..100mA app =&gt; 2'b00, 150mA app =&gt; 2'b01 (default);
200mA chip: 50mA app =&gt; 2'b00, 100..150mA app =&gt; 2'b01,  200mA app =&gt; 2'b10 (default);
250mA chip: 50mA app =&gt; 2'b00, 100..150mA app =&gt; 2'b01,  200..250mA app =&gt; 2'b10 (default);
300mA chip: 50mA app =&gt; 2'b00, 100..150mA app =&gt; 2'b01, 200..250mA app =&gt; 2'b10, 300mA app =&gt; 2'b11 (default);

This register is only reset by XRES/POR/BOD/OVP/HIBERNATE.</description>
              <bitRange>[31:30]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_TRIM_PILO_CTL</name>
          <description>PILO Trim Register</description>
          <addressOffset>0x3114</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x108500F</resetValue>
          <resetMask>0x7DFF703F</resetMask>
          <fields>
            <field>
              <name>PILO_CFREQ</name>
              <description>Coarse frequency trim to meet 32.768kHz +/-2 percent across PVT without calibration.  The nominal step size of the LSB is 1kHz.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PILO_OSC_TRIM</name>
              <description>Trim for current in oscillator block.</description>
              <bitRange>[14:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PILO_COMP_TRIM</name>
              <description>Trim for comparator bias current.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PILO_NBIAS_TRIM</name>
              <description>Trim for biasn by trimming sub-Vth NMOS width in beta-multiplier</description>
              <bitRange>[19:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PILO_RES_TRIM</name>
              <description>Trim for beta-multiplier branch current</description>
              <bitRange>[24:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PILO_ISLOPE_TRIM</name>
              <description>Trim for beta-multiplier current slope</description>
              <bitRange>[27:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PILO_VTDIFF_TRIM</name>
              <description>Trim for VT-DIFF output (internal power supply)</description>
              <bitRange>[30:28]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_TRIM_PILO_CTL2</name>
          <description>PILO Trim Register 2</description>
          <addressOffset>0x3118</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xDA10E0</resetValue>
          <resetMask>0xFF1FFF</resetMask>
          <fields>
            <field>
              <name>PILO_VREF_TRIM</name>
              <description>Trim for voltage reference</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PILO_IREFBM_TRIM</name>
              <description>Trim for beta-multiplier current reference</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PILO_IREF_TRIM</name>
              <description>Trim for current reference</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_TRIM_PILO_CTL3</name>
          <description>PILO Trim Register 3</description>
          <addressOffset>0x311C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x4800</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>PILO_ENGOPT</name>
              <description>Engineering options for PILO circuits
0: Short vdda to vpwr
1: Beta:mult current change
2: Iref generation Ptat current addition
3: Disable current path in secondary Beta:mult startup circuit
4: Double oscillator current
5: Switch between deep:sub:threshold and sub:threshold stacks in Vref generation block
6: Spare
7: Ptat component increase in Iref
8: vpwr_rc and vpwr_dig_rc shorting testmode
9: Switch b/w psub connection for cascode nfet for vref generation
10: Switch between sub:threshold and deep:sub:threshold stacks in comparator.
15-11: Frequency fine trim.  See AKK-444 for an overview of the trim strategy.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_TRIM_ILO1_CTL</name>
          <description>ILO1 Trim Register</description>
          <addressOffset>0x3220</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x52C</resetValue>
          <resetMask>0xF3F</resetMask>
          <fields>
            <field>
              <name>ILO1_FTRIM</name>
              <description>ILO1 frequency trims.  LSB step size is 1.5 percent (typical) of the frequency.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ILO1_MONTRIM</name>
              <description>ILO1 internal monitor trim.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>2</dim>
          <dimIncrement>256</dimIncrement>
          <name>MCWDT[%s]</name>
          <description>Multi-Counter Watchdog Timer</description>
          <headerStructName>MCWDT</headerStructName>
          <addressOffset>0x00008000</addressOffset>
          <cluster>
            <dim>2</dim>
            <dimIncrement>32</dimIncrement>
            <name>CTR[%s]</name>
            <description>MCWDT Configuration for Subcounter 0 and 1</description>
            <headerStructName>MCWDT_CTR</headerStructName>
            <addressOffset>0x00000000</addressOffset>
            <register>
              <name>CTL</name>
              <description>MCWDT Subcounter Control Register</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x80000001</resetMask>
              <fields>
                <field>
                  <name>ENABLED</name>
                  <description>Indicates actual state of this subcounter.  May lag ENABLE by up to two clk_lf cycles.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>ENABLE</name>
                  <description>Enable subcounter.  May take up to 2 clk_lf cycles to take effect.  When ENABLE changes from 1-&gt;0, the counter is cleared.
0: Counter is disabled (not clocked)
1: Counter is enabled (counting up)</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LOWER_LIMIT</name>
              <description>MCWDT Subcounter Lower Limit Register</description>
              <addressOffset>0x4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>LOWER_LIMIT</name>
                  <description>Lower limit for this MCWDT subcounter.  See LOWER_ACTION.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>UPPER_LIMIT</name>
              <description>MCWDT Subcounter Upper Limit Register</description>
              <addressOffset>0x8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>UPPER_LIMIT</name>
                  <description>Upper limit for this MCWDT subcounter.  See UPPER_ACTION.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>WARN_LIMIT</name>
              <description>MCWDT Subcounter Warn Limit Register</description>
              <addressOffset>0xC</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>WARN_LIMIT</name>
                  <description>Warn limit for this MCWDT subcounter.  See WARN_ACTION.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>CONFIG</name>
              <description>MCWDT Subcounter Configuration Register</description>
              <addressOffset>0x10</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xD0001133</resetMask>
              <fields>
                <field>
                  <name>LOWER_ACTION</name>
                  <description>Action taken if this watchdog is serviced before LOWER_LIMIT is reached.  LOWER_ACTION is ignored (ie. treated as NOTHING) when a debugger is connected and/or when the corresponding processor is in SLEEPDEEP.</description>
                  <bitRange>[1:0]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>NOTHING</name>
                      <description>Do nothing</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FAULT</name>
                      <description>Trigger a fault.  It can take up to 3 clk_lf cycles for the fault to be transferred to the fault manager.
For LOWER_LIMIT &gt;= 1: The action is triggered on same edge when it meets this condition.
For LOWER_LIMIT == 0: No action is triggered.</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FAULT_THEN_RESET</name>
                      <description>Trigger a fault.  Further, trigger a system-wide reset if the fault is not serviced and the watchdog is not cleared within 6 clk_lf cycles.  It can take up to 3 clk_lf cycles for the fault to be transferred to the fault manager, which gives at least 3 clk_lf cycles for software to respond.
For LOWER_LIMIT &gt;= 1: The action is triggered on same edge when it meets this condition.
For LOWER_LIMIT == 0: No action is triggered.</description>
                      <value>2</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>UPPER_ACTION</name>
                  <description>Action taken if this watchdog is not serviced before UPPER_LIMIT is reached.  The counter stops counting when UPPER_LIMIT is reached, regardless of UPPER_ACTION setting.  UPPER_ACTION is ignored (ie. treated as NOTHING) when a debugger is connected.</description>
                  <bitRange>[5:4]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>NOTHING</name>
                      <description>Do nothing</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FAULT</name>
                      <description>Trigger a fault.
For UPPER_LIMIT &gt;= 2: The action is triggered on same edge when it meets this condition.
For UPPER_LIMIT &lt; 2: The action may take up to one extra clk_lf cycle to trigger.</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FAULT_THEN_RESET</name>
                      <description>Trigger a fault.  Further, trigger a system-wide reset if the fault is not serviced and the watchdog is not cleared within 6 clk_lf cycles.  It can take up to 3 clk_lf cycles for the fault to be transferred to the fault manager, which gives at least 3 clk_lf cycles for software to respond.
For UPPER_LIMIT &gt;= 2: The action is triggered on same edge when it meets this condition.
For UPPER_LIMIT &lt; 2: The action may take up to one extra clk_lf cycle to trigger.</description>
                      <value>2</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>WARN_ACTION</name>
                  <description>Action taken when the count value reaches WARN_LIMIT.  The minimum setting to achieve a periodic interrupt is WARN_LIMIT==1.  A setting of zero will trigger once but not periodically.
For WARN_LIMIT &gt;= 2: The action is triggered on same edge when it meets this condition.
For WARN_LIMIT == [0,1]  : The action may take up to one extra clk_lf cycle to trigger.</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>NOTHING</name>
                      <description>Do nothing</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>INT</name>
                      <description>Trigger an interrupt.</description>
                      <value>1</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>AUTO_SERVICE</name>
                  <description>Automatically service when the count value reaches WARN_LIMIT.  This allows creation of a periodic interrupt if this counter is not needed as a watchdog.  This field is ignored when LOWER_ACTION&lt;&gt;NOTHING or when UPPER_ACTION&lt;&gt;NOTHING.</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DEBUG_TRIGGER_EN</name>
                  <description>Enables the trigger input for this MCWDT to pause the counter during debug mode.  To pause at a breakpoint while debugging, configure the trigger matrix to connect the related CPU halted signal to the trigger input for this MCWDT, and then set this bit.  It takes up to two clk_lf cycles for the trigger signal to be processed.  Triggers that are less than two clk_lf cycles may be missed.  Synchronization errors can accumulate each time it is halted.
0: Pauses the counter whenever a debug probe is connected.
1: Pauses the counter whenever a debug probe is connected and the trigger input is high.</description>
                  <bitRange>[28:28]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SLEEPDEEP_PAUSE</name>
                  <description>Pauses/runs this counter when the corresponding processor is in SLEEPDEEP.  Note it may take up to two clk_lf cycles for the counter to pause and up to two clk_lf cycles for it to unpause, due to internal synchronization.  After wakeup, the LOWER_ACTION is ignored until after the first service.  This prevents an unintentional trigger of the LOWER_ACTION before the firmware realigns the servicing period.  After the first service, LOWER_ACTION behaves as configured.
0: Counter runs normally regardless of processor mode.
1: Counter pauses when corresponding processor is in SLEEPDEEP.</description>
                  <bitRange>[30:30]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DEBUG_RUN</name>
                  <description>Pauses/runs this counter while a debugger is connected.  Other behaviors are unchanged during debugging, including service, configuration updates and enable/disable.  Note it may take up to two clk_lf cycles for the counter to pause, due to internal synchronization.  

When (DEBUG_RUN==1 or DEBUG_TRIGGER_EN==0) and the debugger is connected for at least two clk_lf cycles, the LOWER_ACTION is ignored until after the first service after the debugger is disconnected.  After the debugger is disconnected, the LOWER_ACTION is ignored until after the first service.  This prevents an unintentional trigger of the LOWER_ACTION before the firmware realigns the servicing period.  After the first service, LOWER_ACTION behaves as configured.  If the debugger is disconnected before two clk_lf cycles, the LOWER_ACTION may or may not be ignored.

0: When debugger connected, counter pauses incrementing as configured in DEBUG_TRIGGER_EN.  
1: When debugger connected, counter increments normally, but reset generation is blocked.</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>CNT</name>
              <description>MCWDT Subcounter Count Register</description>
              <addressOffset>0x14</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>CNT</name>
                  <description>Current value of subcounter for this MCWDT.  This field may lag the actual count value by up to one clk_lf cycle, due to internal synchronization.  When this subcounter is disabled and unlocked, the count value can be written for verification and debugging purposes.  Software writes are always ignored when the subcounter is enabled.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
          </cluster>
          <register>
            <name>CPU_SELECT</name>
            <description>MCWDT CPU selection register</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3</resetMask>
            <fields>
              <field>
                <name>CPU_SEL</name>
                <description>Assigns this MCWDT to a CPU.  This selects which CPU SLEEPDEEP signal is used for SLEEPDEEP_PAUSE.</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CTR2_CTL</name>
            <description>MCWDT Subcounter 2 Control register</description>
            <addressOffset>0x80</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80000001</resetMask>
            <fields>
              <field>
                <name>ENABLED</name>
                <description>Indicates actual state of this subcounter.  May lag ENABLE by up to two clk_lf cycles.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>ENABLE</name>
                <description>Enable subcounter.  May take up to 2 clk_lf cycles to take effect.  When ENABLE changes from 1-&gt;0, the counter is cleared.
0: Counter is disabled (not clocked)
1: Counter is enabled (counting up)</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CTR2_CONFIG</name>
            <description>MCWDT Subcounter 2 Configuration register</description>
            <addressOffset>0x84</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xD01F0001</resetMask>
            <fields>
              <field>
                <name>ACTION</name>
                <description>Action taken when the specified BIT toggles.
Action will be triggered on the same edge where BITS to observe toggle.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>NOTHING</name>
                    <description>Do nothing</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INT</name>
                    <description>Trigger an interrupt</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BITS</name>
                <description>Bit to observe for a toggle:
0: Do ACTION after CNT[0] toggles (ie. every tick)
..
31: Do ACTION after CNT[31] toggles (ie. every 2^31 ticks)</description>
                <bitRange>[20:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DEBUG_TRIGGER_EN</name>
                <description>Enables the trigger input for this MCWDT to pause the counter during debug mode.  To pause at a breakpoint while debugging, configure the trigger matrix to connect the related CPU halted signal to the trigger input for this MCWDT, and then set this bit.  It takes up to two clk_lf cycles for the trigger signal to be processed.  Triggers that are less than two clk_lf cycles may be missed.  Synchronization errors can accumulate each time it is halted.
0: Pauses the counter whenever a debug probe is connected.
1: Pauses the counter whenever a debug probe is connected and the trigger input is high.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLEEPDEEP_PAUSE</name>
                <description>Pauses/runs this counter when the corresponding processor is in SLEEPDEEP.  Note it may take up to two clk_lf cycles for the counter to pause and up to two clk_lf cycles for it to unpause, due to internal synchronization.  
0: Counter runs normally regardless of processor mode.
1: Counter pauses when corresponding processor is in SLEEPDEEP.</description>
                <bitRange>[30:30]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DEBUG_RUN</name>
                <description>Pauses/runs this counter while a debugger is connected.  Other behaviors are unchanged during debugging, including service, configuration updates and enable/disable.  Note it may take up to two clk_lf cycles for the counter to pause and another two cycles to unpause, due to internal synchronization.  
0: When debugger connected, counter pauses incrementing as configured in DEBUG_TRIGGER_EN.  
1: When debugger connected, counter increments normally, but reset generation is blocked.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CTR2_CNT</name>
            <description>MCWDT Subcounter 2 Count Register</description>
            <addressOffset>0x88</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CNT2</name>
                <description>Current value of subcounter 2 for this MCWDT.  This field may lag the actual count value by up to one clk_lf cycle, due to internal synchronization.  When this subcounter is disabled and unlocked, the count value can be written for verification and debugging purposes.  Software writes are always ignored when the subcounter is enabled.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LOCK</name>
            <description>MCWDT Lock Register</description>
            <addressOffset>0x90</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3</resetMask>
            <fields>
              <field>
                <name>MCWDT_LOCK</name>
                <description>Prohibits writing control and configuration registers related to this MCWDT when not equal 0 (as specified in the other register descriptions).  Requires at least two different writes to unlock.
Note that this field is 2 bits to force multiple writes only.  Each MCWDT has a separate local lock.</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>NO_CHG</name>
                    <description>No effect</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLR0</name>
                    <description>Clears bit 0</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLR1</name>
                    <description>Clears bit 1</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SET01</name>
                    <description>Sets both bits 0 and 1</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>SERVICE</name>
            <description>MCWDT Service Register</description>
            <addressOffset>0x94</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3</resetMask>
            <fields>
              <field>
                <name>CTR0_SERVICE</name>
                <description>Services subcounter 0.  This resets the count value for subcounter 0 to zero.  This may take up to three clk_lf cycles to take effect.  Hardware clears this bit, after necessary synchronization.  To ensure a pending CTR0_SERVICE write is reflected, firmware should wait until this bit reads low before attempting to write CTR0_SERVICE=1.  If subcounter 0 is disabled, CTR0_SERVICE will not trigger a LOWER_ACTION and will not clear a preloaded count value.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CTR1_SERVICE</name>
                <description>Services subcounter 1.  This resets the count value for subcounter 1 to zero.  This may take up to three clk_lf cycles to take effect.  Hardware clears this bit, after necessary synchronization.  To ensure a pending CTR1_SERVICE write is reflected, firmware should wait until this bit reads low before attempting to write CTR1_SERVICE=1.  If subcounter 1 is disabled, CTR1_SERVICE will not trigger a LOWER_ACTION and will not clear a preloaded count value.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR</name>
            <description>MCWDT Interrupt Register</description>
            <addressOffset>0xA0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7</resetMask>
            <fields>
              <field>
                <name>CTR0_INT</name>
                <description>MCWDT Interrupt Request for sub-counter 0.  This bit is set by hardware as configured by this registers.  This bit must be cleared by firmware.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CTR1_INT</name>
                <description>MCWDT Interrupt Request for sub-counter 1.  This bit is set by hardware as configured by this registers.  This bit must be cleared by firmware.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CTR2_INT</name>
                <description>MCWDT Interrupt Request for sub-counter 2.  This bit is set by hardware as configured by this registers.  This bit must be cleared by firmware.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SET</name>
            <description>MCWDT Interrupt Set Register</description>
            <addressOffset>0xA4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7</resetMask>
            <fields>
              <field>
                <name>CTR0_INT</name>
                <description>Set interrupt for MCWDT_INT0</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CTR1_INT</name>
                <description>Set interrupt for MCWDT_INT1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CTR2_INT</name>
                <description>Set interrupt for MCWDT_INT2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASK</name>
            <description>MCWDT Interrupt Mask Register</description>
            <addressOffset>0xA8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7</resetMask>
            <fields>
              <field>
                <name>CTR0_INT</name>
                <description>Mask for sub-counter 0 for warning interrupt</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CTR1_INT</name>
                <description>Mask for sub-counter 1 for warning interrupt</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CTR2_INT</name>
                <description>Mask for sub-counter 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASKED</name>
            <description>MCWDT Interrupt Masked Register</description>
            <addressOffset>0xAC</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7</resetMask>
            <fields>
              <field>
                <name>CTR0_INT</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CTR1_INT</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CTR2_INT</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <name>WDT</name>
          <description>Watchdog Timer</description>
          <headerStructName>WDT</headerStructName>
          <addressOffset>0x0000C000</addressOffset>
          <register>
            <name>CTL</name>
            <description>WDT Control Register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x80000001</resetValue>
            <resetMask>0x80000001</resetMask>
            <fields>
              <field>
                <name>ENABLED</name>
                <description>Indicates actual state of watchdog.  May lag ENABLE by up to three clk_ilo0 cycles.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>ENABLE</name>
                <description>Enable watchdog.  May take up to three clk_ilo0 cycles to take effect.  When ENABLE changes from 1-&gt;0, the counter is cleared.  Do not enter DEEPSLEEP or HIBERNATE mode if ENABLE&lt;&gt;ENABLED.  This can be done by waiting until ENABLE==ENABLED whenever ENABLE is changed.
0: Counter is disabled (not clocked).
1: Counter is enabled (counting up)</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LOWER_LIMIT</name>
            <description>WDT Lower Limit Register</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LOWER_LIMIT</name>
                <description>Lower limit for watchdog.  See LOWER_ACTION.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UPPER_LIMIT</name>
            <description>WDT Upper Limit Register</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x8000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>UPPER_LIMIT</name>
                <description>Upper limit for watchdog.  See UPPER_ACTION.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>WARN_LIMIT</name>
            <description>WDT Warn Limit Register</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>WARN_LIMIT</name>
                <description>Warn limit for watchdog.  See WARN_ACTION.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CONFIG</name>
            <description>WDT Configuration Register</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x10</resetValue>
            <resetMask>0xF0001111</resetMask>
            <fields>
              <field>
                <name>LOWER_ACTION</name>
                <description>Action taken if this watchdog is serviced before LOWER_LIMIT is reached.  LOWER_ACTION is ignored (ie. treated as NOTHING) when a debugger is connected and/or when the chip is in DEEPSLEEP/HIBERNATE modes.
For LOWER_LIMIT &gt;= 1: The action is triggered on same edge when it meets this condition.
For LOWER_LIMIT == 0: No action is triggered.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>NOTHING</name>
                    <description>Do nothing</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RESET</name>
                    <description>Trigger a reset.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UPPER_ACTION</name>
                <description>Action taken if this watchdog is not serviced before UPPER_LIMIT is reached.  The counter stops counting when UPPER_LIMIT is reached, regardless of UPPER_ACTION setting.   UPPER_ACTION is ignored (ie. treated as NOTHING) when a debugger is connected.
For UPPER_LIMIT &gt;= 2: The action is triggered on same edge when it meets this condition.
For UPPER_LIMIT &lt; 2: The action may take up to one extra clk_ilo0 cycle to trigger.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>NOTHING</name>
                    <description>Do nothing</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RESET</name>
                    <description>Trigger a reset.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WARN_ACTION</name>
                <description>Action taken when the count value reaches WARN_LIMIT.  The minimum setting to achieve a periodic interrupt is WARN_LIMIT==1.  A setting of zero will trigger once but not periodically.
For WARN_LIMIT &gt;= 2: The action is triggered on same edge when it meets this condition.
For WARN_LIMIT &lt; 2  : The action may take up to one extra clk_ilo0 cycle to trigger.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>NOTHING</name>
                    <description>Do nothing</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INT</name>
                    <description>Trigger an interrupt.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AUTO_SERVICE</name>
                <description>Automatically service when the count value reaches WARN_LIMIT.  This allows creation of a periodic interrupt if this counter is not needed as a watchdog.  This field is ignored when LOWER_ACTION&lt;&gt;NOTHING or when UPPER_ACTION&lt;&gt;NOTHING.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DEBUG_TRIGGER_EN</name>
                <description>Enables the trigger input for WDT to pause the counter during debug mode.  To pause at a breakpoint while debugging, configure the trigger matrix to connect the related CPU halted signal to the trigger input for this WDT, and then set this bit.  It takes up to two clk_ilo0 cycles for the trigger signal to be processed.  Triggers that are less than two clk_ilo0 cycles may be missed.  Synchronization error can accumulate each time it is halted.
0: Pauses the counter whenever a debug probe is connected.
1: Pauses the counter whenever a debug probe is connected and the trigger input is high.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DPSLP_PAUSE</name>
                <description>Pauses/runs this counter when the system is in DEEPSLEEP.  Note it may take up to two clk_ilo0 cycles for the counter to pause, due to internal synchronization.  During DEEPSLEEP wakeup, the pause request is removed when clk_hf0 starts clocking, and then it may take up to two clk_ilo0 cycles for the counter to start.  After wakeup, the LOWER_ACTION is ignored until after the first service.  This prevents an unintentional trigger of the LOWER_ACTION before the firmware realigns the servicing period.  After the first service, LOWER_ACTION behaves as configured.
0: Counter behaves normally during DEEPSLEEP.
1: Counter pauses during DEEPSLEEP.</description>
                <bitRange>[29:29]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>HIB_PAUSE</name>
                <description>Pauses/runs this counter when the system is in HIBERNATE.  Note it may take up to two clk_ilo0 cycles for the counter to pause, due to internal synchronization.  After wakeup, the LOWER_ACTION is ignored until after the first service.  This prevents an unintentional trigger of the LOWER_ACTION before the firmware realigns the servicing period.  After the first service, LOWER_ACTION behaves as configured.
0: Counter behaves normally during HIBERNATE.
1: Counter pauses during HIBERNATE.</description>
                <bitRange>[30:30]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DEBUG_RUN</name>
                <description>Pauses/runs this counter while a debugger is connected.  Other behaviors are unchanged during debugging, including service, configuration updates and enable/disable.  Note it may take up to two clk_ilo0 cycles for the counter to pause and another two cycles to unpause, due to internal synchronization.  If the debugger is connected for at least two clk_ilo0 cycles, the LOWER_ACTION is ignored until after the first service after the debugger is disconnected.  This prevents an unintentional trigger of the LOWER_ACTION before the firmware realigns the servicing period.  After the first service, LOWER_ACTION behaves as configured.  If the debugger is disconnected before two clk_ilo0 cycles, the LOWER_ACTION may or may not be ignored.
0: When debugger connected, counter pauses incrementing as configured in DEBUG_TRIGGER_EN.
1: When debugger connected, counter increments normally, but reset generation is blocked.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CNT</name>
            <description>WDT Count Register</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CNT</name>
                <description>Current value of subcounter for this WDT.  This field may lag the actual count value by up to one clk_ilo0 cycle, due to internal synchronization.  When this subcounter is disabled and unlocked, the count value can be written for verification and debugging purposes.  Software writes are always ignored when the subcounter is enabled.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LOCK</name>
            <description>WDT Lock register</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x3</resetValue>
            <resetMask>0x3</resetMask>
            <fields>
              <field>
                <name>WDT_LOCK</name>
                <description>Prohibits writing control and configuration registers related to this WDT when not equal 0 (as specified in the other register descriptions).  Requires at least two different writes to unlock.
Note that this field is 2 bits to force multiple writes only.  This register also locks the clk_ilo0 settings.</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>NO_CHG</name>
                    <description>No effect</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLR0</name>
                    <description>Clears bit 0</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLR1</name>
                    <description>Clears bit 1</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SET01</name>
                    <description>Sets both bits 0 and 1</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>SERVICE</name>
            <description>WDT Service register</description>
            <addressOffset>0x44</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>SERVICE</name>
                <description>Services the watchdog.  This resets the count value to zero.  This may take up to three clk_ilo0 cycle to take effect.  Hardware clears this bit, after necessary synchronization.  To ensure a pending SERVICE write is reflected, firmware should wait until this bit reads low before attempting to write SERVICE=1.  If WDT is disabled, SERVICE will not trigger a LOWER_ACTION and will not clear a preloaded count value.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR</name>
            <description>WDT Interrupt Register</description>
            <addressOffset>0x50</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>WDT</name>
                <description>WDT Interrupt Request.  This bit is set as configured by WDT action and limits.  Due to internal synchronization, it takes up to 8 SYSCLK cycles to update after a W1C or reading this register and during this time AHB bus is stalled.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SET</name>
            <description>WDT Interrupt Set Register</description>
            <addressOffset>0x54</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>WDT</name>
                <description>Set interrupt.
Due to internal synchronization, it takes up to 8 SYSCLK cycles to update after a W1S or reading from this register and during this time AHB bus is stalled.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASK</name>
            <description>WDT Interrupt Mask Register</description>
            <addressOffset>0x58</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>WDT</name>
                <description>Mask for watchdog timer.  Clearing this bit will not forward the interrupt to the CPU.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASKED</name>
            <description>WDT Interrupt Masked Register</description>
            <addressOffset>0x5C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>WDT</name>
                <description>Logical and of corresponding request and mask bits.
Due to internal synchronization, it takes up to 8 SYSCLK cycles to read from this register.  During this time AHB bus is stalled.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>BACKUP</name>
      <description>SRSS Backup Domain (ver2)</description>
      <baseAddress>0x40270000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTL</name>
          <description>Control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF0F3308</resetMask>
          <fields>
            <field>
              <name>WCO_EN</name>
              <description>Watch-crystal oscillator (WCO) enable.  If there is a write in progress when this bit is cleared, the WCO will be internally kept on until the write completes.
After enabling the WCO software must wait until STATUS.WCO_OK=1 before configuring any component that depends on clk_lf/clk_bak, like for example RTC or WDTs.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_SEL</name>
              <description>Clock select for RTC clock</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>WCO</name>
                  <description>Watch-crystal oscillator input, available in Active, DeepSleep and Hibernate</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALTBAK</name>
                  <description>This allows to use the LFCLK selection as an alternate backup domain clock. Note that LFCLK is only available in Active and DeepSleep power modes.
Note that LFCLK clock glitches can propagate into the backup logic when the clock is stopped.  For this reason, if the WCO or ILO is intended as the clock source then choose it directly instead of routing through LFCLK.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ILO</name>
                  <description>Internal Low frequency Oscillator, available in Active, DeepSleep and Hibernate.
For Hibernate operation CLK_ILO_CONFIG. ILO_BACKUP must be set.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRESCALER</name>
              <description>N/A</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WCO_BYPASS</name>
              <description>Configures the WCO for different board-level connections to the WCO pins.  For example, this can be used to connect an external watch crystal oscillator instead of a watch crystal.   In all cases, the two related GPIO pins (WCO input and output pins) must be configured as analog connections using GPIO registers, and they must be hooked at the board level as described below.  Configure this field before enabling the WCO, and do not change this setting when WCO_EN=1.
0: Watch crystal.  Connect a 32.768 kHz watch crystal between WCO input and output pins.
1: Clock signal, either a square wave or sine wave.  See PRESCALER field for connection information.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VDDBAK_CTL</name>
              <description>Controls the behavior of the switch that generates vddbak from vbackup or vddd.
0: automatically select vddd if its brownout detector says it is valid.  If the brownout says its not valid, then use vmax which is the highest of vddd or vbackup.
1,2,3: force vddbak and vmax to select vbackup, regardless of its voltage.</description>
              <bitRange>[18:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VBACKUP_MEAS</name>
              <description>Connect vbackup supply to the vbackup_meas output for measurement by an ADC attached to amuxbusa_adft_vddd.  The vbackup_meas signal is scaled by 40 percent so it is within the supply range of the ADC.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_CHARGE_KEY</name>
              <description>When set to 3C, the supercap charger circuit is enabled.  Any other code disables the supercap charger.  THIS CHARGING CIRCUIT IS FOR A SUPERCAP ONLY AND CANNOT SAFELY CHARGE A BATTERY.  DO NOT WRITE THIS KEY WHEN VBACKUP IS CONNECTED TO A BATTERY.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RTC_RW</name>
          <description>RTC Read Write register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>READ</name>
              <description>Read bit
When this bit is set the RTC registers will be copied to user registers and frozen so that a coherent RTC value can safely be read. The RTC will keep on running.
Do not set the read bit if the RTC is still busy with a previous update (see RTC_BUSY bit) or if the Write bit is set. Do not set the Read bit at the same time that the Write bit is cleared.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WRITE</name>
              <description>Write bit
Only when this bit is set can the RTC registers be written to (otherwise writes are ignored). This bit cannot be set if the RTC is still busy with a previous update (see RTC_BUSY bit) or if the Read bit is set or getting set. 
The user writes to the RTC user registers, when the Write bit is cleared by the user then the user registers content is copied to the actual RTC registers. 
Only user RTC registers that were written to will get copied, others will not be affected. 
When the SECONDS field is updated then TICKS will also be reset (WDT is not affected).
When the Write bit is cleared by a reset (brown out/DeepSleep) then the RTC update will be ignored/lost.
Do not set the Write bit if the RTC if the RTC is still busy with a previous update (see RTC_BUSY).  Do not set the Write bit at the same time that the Read bit is cleared.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAL_CTL</name>
          <description>Oscillator calibration for absolute frequency</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xB000007F</resetMask>
          <fields>
            <field>
              <name>CALIB_VAL</name>
              <description>Calibration value for absolute frequency (at a fixed temperature).  Each step causes 128 ticks to be added or removed each hour.  Effectively that means that each step is 1.085ppm (= 128/(60*60*32,768)).
Positive values 0x01-0x3c (1..60) add pulses, negative values remove pulses, thus giving a range of +/-65.1 ppm (limited by 60 minutes per hour, not the range of this field)

Calibration is performed hourly, starting at 59 minutes and 59 seconds, and applied as 64 ticks every 30 seconds until there have been 2*CALIB_VAL adjustments.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CALIB_SIGN</name>
              <description>Calibration sign:
0= Negative sign: remove pulses (it takes more clock ticks to count one second)
1= Positive sign: add pulses (it takes less clock ticks to count one second)</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CAL_SEL</name>
              <description>Select calibration wave output signal</description>
              <bitRange>[29:28]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CAL512</name>
                  <description>512Hz wave, not affected by calibration setting (not supported for 50/60Hz input clock: CTL.PRESCALER!=0)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CAL2</name>
                  <description>2Hz wave, includes the effect of the calibration setting, (not supported for 50/60Hz input clock: CTL.PRESCALER!=0)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CAL1</name>
                  <description>1Hz wave, includes the effect of the calibration setting (supported for all input clocks)</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CAL_OUT</name>
              <description>Output enable for wave signal for calibration and allow CALIB_VAL to be written.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>Status</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x5</resetMask>
          <fields>
            <field>
              <name>RTC_BUSY</name>
              <description>pending RTC write</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>WCO_OK</name>
              <description>Indicates that output has transitioned.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RTC_TIME</name>
          <description>Calendar Seconds, Minutes, Hours, Day of Week</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1000000</resetValue>
          <resetMask>0x75F3F3F</resetMask>
          <fields>
            <field>
              <name>RTC_SEC</name>
              <description>Calendar seconds, 0-59</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RTC_MIN</name>
              <description>Calendar minutes, 0-59</description>
              <bitRange>[13:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RTC_HOUR</name>
              <description>Calendar hours, value depending on 12/24HR mode
0=24HR: [20:16]=0-23
1=12HR: [20]:0=AM, 1=PM, [19:16]=1-12</description>
              <bitRange>[20:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CTRL_12HR</name>
              <description>Select 12/24HR mode: 1=12HR, 0=24HR</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RTC_DAY</name>
              <description>Calendar Day of the week, 1-7
It is up to the user to define the meaning of the values, but 1=Monday is recommended</description>
              <bitRange>[26:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RTC_DATE</name>
          <description>Calendar Day of Month, Month,  Year</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x101</resetValue>
          <resetMask>0x7F0F1F</resetMask>
          <fields>
            <field>
              <name>RTC_DATE</name>
              <description>Calendar Day of the Month, 1-31
Automatic Leap Year Correction</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RTC_MON</name>
              <description>Calendar Month, 1-12</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RTC_YEAR</name>
              <description>Calendar year, 0-99</description>
              <bitRange>[22:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ALM1_TIME</name>
          <description>Alarm 1 Seconds, Minute, Hours, Day of Week</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1000000</resetValue>
          <resetMask>0x879FBFBF</resetMask>
          <fields>
            <field>
              <name>ALM_SEC</name>
              <description>Alarm seconds, 0-59</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_SEC_EN</name>
              <description>Alarm second enable: 0=ignore, 1=match</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_MIN</name>
              <description>Alarm minutes, 0-59</description>
              <bitRange>[13:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_MIN_EN</name>
              <description>Alarm minutes enable: 0=ignore, 1=match</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_HOUR</name>
              <description>Alarm hours, value depending on 12/24HR mode
24HR: [4:0]=0-23
12HR: [4]:0=AM, 1=PM, [3:0]=1-12</description>
              <bitRange>[20:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_HOUR_EN</name>
              <description>Alarm hour enable: 0=ignore, 1=match</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_DAY</name>
              <description>Alarm Day of the week, 1-7
It is up to the user to define the meaning of the values, but 1=Monday is recommended</description>
              <bitRange>[26:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_DAY_EN</name>
              <description>Alarm Day of the Week enable: 0=ignore, 1=match</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ALM1_DATE</name>
          <description>Alarm 1 Day of Month, Month</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x101</resetValue>
          <resetMask>0x80008F9F</resetMask>
          <fields>
            <field>
              <name>ALM_DATE</name>
              <description>Alarm Day of the Month, 1-31
Leap Year corrected</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_DATE_EN</name>
              <description>Alarm Day of the Month enable: 0=ignore, 1=match</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_MON</name>
              <description>Alarm Month, 1-12</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_MON_EN</name>
              <description>Alarm Month enable: 0=ignore, 1=match</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_EN</name>
              <description>Master enable for alarm 1.
0: Alarm 1 is disabled.  Fields for date and time are ignored.
1: Alarm 1 is enabled.  If none of the date and time fields are enabled, then this alarm triggers once every second.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ALM2_TIME</name>
          <description>Alarm 2 Seconds, Minute, Hours, Day of Week</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1000000</resetValue>
          <resetMask>0x879FBFBF</resetMask>
          <fields>
            <field>
              <name>ALM_SEC</name>
              <description>Alarm seconds, 0-59</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_SEC_EN</name>
              <description>Alarm second enable: 0=ignore, 1=match</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_MIN</name>
              <description>Alarm minutes, 0-59</description>
              <bitRange>[13:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_MIN_EN</name>
              <description>Alarm minutes enable: 0=ignore, 1=match</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_HOUR</name>
              <description>Alarm hours, value depending on 12/24HR mode
24HR: [4:0]=0-23
12HR: [4]:0=AM, 1=PM, [3:0]=1-12</description>
              <bitRange>[20:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_HOUR_EN</name>
              <description>Alarm hour enable: 0=ignore, 1=match</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_DAY</name>
              <description>Alarm Day of the week, 1-7
It is up to the user to define the meaning of the values, but 1=Monday is recommended</description>
              <bitRange>[26:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_DAY_EN</name>
              <description>Alarm Day of the Week enable: 0=ignore, 1=match</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ALM2_DATE</name>
          <description>Alarm 2 Day of Month, Month</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x101</resetValue>
          <resetMask>0x80008F9F</resetMask>
          <fields>
            <field>
              <name>ALM_DATE</name>
              <description>Alarm Day of the Month, 1-31
Leap Year corrected</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_DATE_EN</name>
              <description>Alarm Day of the Month enable: 0=ignore, 1=match</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_MON</name>
              <description>Alarm Month, 1-12</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_MON_EN</name>
              <description>Alarm Month enable: 0=ignore, 1=match</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_EN</name>
              <description>Master enable for alarm 2.
0: Alarm 2 is disabled.  Fields for date and time are ignored.
1: Alarm 2 is enabled.  If none of the date and time fields are enabled, then this alarm triggers once every second.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR</name>
          <description>Interrupt request register</description>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>ALARM1</name>
              <description>Alarm 1 Interrupt</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALARM2</name>
              <description>Alarm 2 Interrupt</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CENTURY</name>
              <description>Century overflow interrupt</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SET</name>
          <description>Interrupt set request register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>ALARM1</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALARM2</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CENTURY</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASK</name>
          <description>Interrupt mask register</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>ALARM1</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALARM2</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CENTURY</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASKED</name>
          <description>Interrupt masked request register</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>ALARM1</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ALARM2</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CENTURY</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMIC_CTL</name>
          <description>PMIC control register</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xA0000000</resetValue>
          <resetMask>0xE001FF00</resetMask>
          <fields>
            <field>
              <name>UNLOCK</name>
              <description>This byte must be set to 0x3A for PMIC to be disabled.  When the UNLOCK code is not present: writes to PMIC_EN field are ignored and the hardware ignores the value in PMIC_EN.  Do not change PMIC_EN in the same write cycle as setting/clearing the UNLOCK code; do these in separate write cycles.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>POLARITY</name>
              <description>N/A</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PMIC_EN_OUTEN</name>
              <description>Output enable for the output driver in the PMIC_EN pad.
0: Output pad is tristate for PMIC_EN pin.  This can allow this pin to be used for another purpose. Tristate condition is kept only if the UNLOCK key (0x3A) is present
1: Output pad is enabled for PMIC_EN pin.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PMIC_ALWAYSEN</name>
              <description>Override normal PMIC controls to prevent accidentally turning off the PMIC by errant firmware.
0: Normal operation, PMIC_EN and PMIC_OUTEN work as described
1: PMIC_EN and PMIC_OUTEN are ignored and the output pad is forced enabled.
Note: This bit is a write-once bit until the next backup reset.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PMIC_EN</name>
              <description>Enable for external PMIC that supplies vddd (if present).  This bit will only clear if UNLOCK was written correctly in a previous write operation and PMIC_ALWAYSEN=0.  When PMIC_EN=0, the system functions normally until vddd is no longer present (OFF w/Backup mode).  Firmware can set this bit, if it does so before vddd is actually removed.  This bit is also set by any RTC alarm or PMIC pin wakeup event regardless of UNLOCK setting.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RESET</name>
          <description>Backup reset register</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>RESET</name>
              <description>Writing 1 to this register resets the backup logic.  Hardware clears it when the reset is complete.  After setting this register, firmware should confirm it reads as 0 before attempting to write other backup registers.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>64</dim>
          <dimIncrement>4</dimIncrement>
          <name>BREG[%s]</name>
          <description>Backup register region</description>
          <addressOffset>0x1000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BREG</name>
              <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>DW0</name>
      <description>Datawire Controller</description>
      <headerStructName>DW</headerStructName>
      <baseAddress>0x40280000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTL</name>
          <description>Control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1</resetValue>
          <resetMask>0x80000003</resetMask>
          <fields>
            <field>
              <name>ECC_EN</name>
              <description>Enable ECC checking:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_INJ_EN</name>
              <description>Enable parity injection for SRAM.
When '1', the parity (ECC_CTL.PARITY) is used when a full 32-bit write is done to the ECC_CTL.WORD_ADDR word address of the SRAM.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>N/A</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>Status</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF0000000</resetMask>
          <fields>
            <field>
              <name>P</name>
              <description>Active channel, user/privileged access control:
'0': user mode.
'1': privileged mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NS</name>
              <description>Active channel, secure/non-secure access control:
'0': secure.
'1': non-secure.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>B</name>
              <description>Active channel, non-bufferable/bufferable access control:
'0': non-bufferable
'1': bufferable.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PC</name>
              <description>Active channel protection context.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PRIO</name>
              <description>Active channel priority.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>Active channel preemptable.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CH_IDX</name>
              <description>Active channel index.</description>
              <bitRange>[24:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STATE</name>
              <description>State of the DW controller. 
'0': Default/inactive state.
'1': Loading descriptor.
'2': Loading data element from source location.
'3': Storing data element to destination location.
'4': CRC functionality (only used for CRC transfer descriptor type).
'5': Update of active control information (e.g. source and destination addresses) and wait for trigger de-activation.
'6': Error.</description>
              <bitRange>[30:28]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ACTIVE</name>
              <description>Active channel present: 
'0': No.
'1': Yes.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ACT_DESCR_CTL</name>
          <description>Active descriptor control</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>N/A</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ACT_DESCR_SRC</name>
          <description>Active descriptor source</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>N/A</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ACT_DESCR_DST</name>
          <description>Active descriptor destination</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>N/A</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ACT_DESCR_X_CTL</name>
          <description>Active descriptor X loop control</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>N/A</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ACT_DESCR_Y_CTL</name>
          <description>Active descriptor Y loop control</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>N/A</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ACT_DESCR_NEXT_PTR</name>
          <description>Active descriptor next pointer</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>N/A</description>
              <bitRange>[31:2]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ACT_SRC</name>
          <description>Active source</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>SRC_ADDR</name>
              <description>N/A</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ACT_DST</name>
          <description>Active destination</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DST_ADDR</name>
              <description>N/A</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ECC_CTL</name>
          <description>ECC control</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFE0003FF</resetMask>
          <fields>
            <field>
              <name>WORD_ADDR</name>
              <description>Specifies the word address where an error will be injected.
- On a write transfer to this SRAM word address and when CTL.ECC_INJ_EN bit is '1', the parity (PARITY) is injected.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY</name>
              <description>ECC parity to use for ECC error injection at address WORD_ADDR.</description>
              <bitRange>[31:25]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_CTL</name>
          <description>CRC control</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x101</resetMask>
          <fields>
            <field>
              <name>DATA_REVERSE</name>
              <description>Specifies the bit order in which a data Byte is processed (reversal is performed after XORing):
'0': Most significant bit (bit 1) first.
'1': Least significant bit (bit 0) first.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REM_REVERSE</name>
              <description>Specifies whether the remainder is bit reversed (reversal is performed after XORing):
'0': No.
'1': Yes.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_DATA_CTL</name>
          <description>CRC data control</description>
          <addressOffset>0x110</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>DATA_XOR</name>
              <description>Specifies a byte mask with which each data byte is XOR'd. The XOR is performed before data reversal.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_POL_CTL</name>
          <description>CRC polynomial control</description>
          <addressOffset>0x120</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>POLYNOMIAL</name>
              <description>CRC polynomial. The polynomial is represented WITHOUT the high order bit (this bit is always assumed '1'). The polynomial should be aligned/shifted such that the more significant bits (bit 31 and down) contain the polynomial and the less significant bits (bit 0 and up) contain padding '0's. Some frequently used polynomials:
- CRC32: POLYNOMIAL is 0x04c11db7 (x^32 + x^26 + x^23 + x^22 + x^16 + x^12 + x^11 + x^10 + x^8 + x^7 + x^5 + x^4 + x^2 + x + 1).
- CRC16: POLYNOMIAL is 0x80050000 (x^16 + x^15 + x^2 + 1, shifted by 16 bit positions).
- CRC16 CCITT: POLYNOMIAL is 0x10210000 (x^16 + x^12 + x^5 + 1, shifted by 16 bit positions).</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_LFSR_CTL</name>
          <description>CRC LFSR control</description>
          <addressOffset>0x130</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LFSR32</name>
              <description>State of a 32-bit Linear Feedback Shift Registers (LFSR) that is used to implement CRC. This register needs to be initialized by SW to provide the CRC seed value.

The seed value should be aligned such that the more significant bits (bit 31 and down) contain the seed value and the less significant bits (bit 0 and up) contain padding '0's.  

Note that SW can write this field. This functionality can be used prevent information leakage (through either CRC_LFSR_CTL or CRC_REM_RESULT).</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_REM_CTL</name>
          <description>CRC remainder control</description>
          <addressOffset>0x140</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REM_XOR</name>
              <description>Specifies a mask with which the CRC_LFSR_CTL.LFSR32 register is XOR'd to produce a remainder. The XOR is performed before remainder reversal.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_REM_RESULT</name>
          <description>CRC remainder result</description>
          <addressOffset>0x148</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REM</name>
              <description>Remainder value. The alignment of the remainder depends on CRC_REM_CTL0.REM_REVERSE: 
'0': the more significant bits (bit 31 and down) contain the remainder.
'1': the less significant bits (bit 0 and up) contain the remainder. 

Note: This field is combinatorially derived from CRC_LFSR_CTL.LFSR32, CRC_CTL.REM_REVERSE and CRC_REM_CTL.REM_XOR.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>89</dim>
          <dimIncrement>64</dimIncrement>
          <name>CH_STRUCT[%s]</name>
          <description>DW channel structure</description>
          <addressOffset>0x00008000</addressOffset>
          <register>
            <name>CH_CTL</name>
            <description>Channel control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x2</resetValue>
            <resetMask>0x80000BF7</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>N/A</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>N/A</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>B</name>
                <description>N/A</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC</name>
                <description>N/A</description>
                <bitRange>[7:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>N/A</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PREEMPTABLE</name>
                <description>N/A</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED</name>
                <description>N/A</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CH_STATUS</name>
            <description>Channel status</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>INTR_CAUSE</name>
                <description>N/A</description>
                <bitRange>[3:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PENDING</name>
                <description>N/A</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CH_IDX</name>
            <description>Channel current indices</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>X_IDX</name>
                <description>N/A</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>Y_IDX</name>
                <description>N/A</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CH_CURR_PTR</name>
            <description>Channel current descriptor pointer</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>ADDR</name>
                <description>N/A</description>
                <bitRange>[31:2]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR</name>
            <description>Interrupt</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>CH</name>
                <description>N/A</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SET</name>
            <description>Interrupt set</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>CH</name>
                <description>N/A</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASK</name>
            <description>Interrupt mask</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>CH</name>
                <description>N/A</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASKED</name>
            <description>Interrupt masked</description>
            <addressOffset>0x1C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>CH</name>
                <description>N/A</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SRAM_DATA0</name>
            <description>SRAM data 0</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>N/A</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SRAM_DATA1</name>
            <description>SRAM data 1</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>N/A</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TR_CMD</name>
            <description>Channel software trigger</description>
            <addressOffset>0x28</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>ACTIVATE</name>
                <description>Software trigger. When written with '1', a trigger is generated which sets 'trigger pending' (only if the channel is enabled). A read always returns a 0.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral derivedFrom="DW0">
      <name>DW1</name>
      <baseAddress>0x40290000</baseAddress>
    </peripheral>
    <peripheral>
      <name>DMAC</name>
      <description>DMAC</description>
      <baseAddress>0x402A0000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTL</name>
          <description>Control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>IP enable:
'0': Disabled. All non-retention registers (command and status registers) are reset to their default value when the IP is disabled. All retention registers retain their value when the IP is disabled.
'1': Enabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ACTIVE</name>
          <description>Active channels</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>ACTIVE</name>
              <description>Specifies active channels; i.e. enabled channels whose trigger got activated.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>4</dim>
          <dimIncrement>256</dimIncrement>
          <name>CH[%s]</name>
          <description>DMA controller channel</description>
          <addressOffset>0x00001000</addressOffset>
          <register>
            <name>CTL</name>
            <description>Channel control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x2</resetValue>
            <resetMask>0x800003F7</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>User/privileged access control:
'0': user mode.
'1': privileged mode.

This field is set with the user/privileged access control of the transaction that writes this register; i.e. the access control is inherited from the write transaction and not specified by the transaction write data.

All transactions for this channel use the P field for the user/privileged access control ('hprot[1]').</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>Secure/on-secure access control:
'0': secure.
'1': non-secure.

This field is set with the secure/non-secure access control of the transaction that writes this register; i.e. the access control is inherited from the write transaction and not specified by the transaction write data.

All transactions for this channel use the NS field for the secure/non-secure access control ('hprot[4]').</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>B</name>
                <description>Non-bufferable/bufferable access control:
'0': non-bufferable.
'1': bufferable.

This field is used to indicate to an AMBA bridge that a write transaction can complete without waiting for the destination to accept the write transaction data.

All transactions for this channel uses the B field for the non-bufferable/bufferable access control ('hprot[2]').</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC</name>
                <description>Protection context.

This field is set with the protection context of the transaction that writes this register; i.e. the context is inherited from the write transaction and not specified by the transaction write data.

All transactions for this channel uses the PC field for the protection context.</description>
                <bitRange>[7:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>Channel priority:
'0': highest priority.
'1'
'2'
'3': lowest priority.

Channels with the same priority constitute a priority group. Priority decoding determines the highest priority pending channel. This channel is determined as follows. First, the highest priority group with pending channels is identified. Second, within this priority group, roundrobin arbitration is applied. Roundrobin arbitration (within a priority group) gives the highest priority to the lower channel indices (within the priority group).</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED</name>
                <description>Channel enable:
'0': Disabled. The channel's trigger is ignored and the channel cannot be made pending and therefore cannot be made active. If a pending channel is disabled, the channel is made non pending. If the activate channel is disabled, the channel is de-activated (bus transactions are completed). 
'1': Enabled.

SW sets this field to '1' to enable a specific channel.

HW sets this field to '0' when an error interrupt cause is activated.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>IDX</name>
            <description>Channel current indices</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>X</name>
                <description>Specifies the X loop index. In the range of [0, X_COUNT], with X_COUNT taken from the current descriptor. 

Note: HW sets this field to '0' when it loads a descriptor.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>Y</name>
                <description>Specifies the Y loop index, with X_COUNT taken from the current descriptor. 

Note: HW sets this field to '0' when it loads a descriptor..</description>
                <bitRange>[31:16]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SRC</name>
            <description>Channel current source address</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>ADDR</name>
                <description>Current address of source location.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DST</name>
            <description>Channel current destination address</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>ADDR</name>
                <description>Current address of source location.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CURR</name>
            <description>Channel current descriptor pointer</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>PTR</name>
                <description>Address of current descriptor. When this field is '0', there is no valid descriptor.

Note: HW updates the current descriptor pointer CH_CURR_PTR with DESCR_NEXT_PTR after execution of the current descriptor.</description>
                <bitRange>[31:2]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TR_CMD</name>
            <description>Channle software trigger</description>
            <addressOffset>0x28</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>ACTIVATE</name>
                <description>Software trigger. When written with '1', a trigger is generated which sets 'trigger pending' (only if the channel is enabled). A read always returns a 0.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DESCR_STATUS</name>
            <description>Channel descriptor status</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80000000</resetMask>
            <fields>
              <field>
                <name>VALID</name>
                <description>Status of descriptor information in CH_DESCR_CTL, ..., CH_DESCR_NEXT_PTR.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DESCR_CTL</name>
            <description>Channel descriptor control</description>
            <addressOffset>0x60</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>WAIT_FOR_DEACT</name>
                <description>N/A</description>
                <bitRange>[1:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>INTR_TYPE</name>
                <description>N/A</description>
                <bitRange>[3:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TR_OUT_TYPE</name>
                <description>N/A</description>
                <bitRange>[5:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TR_IN_TYPE</name>
                <description>N/A</description>
                <bitRange>[7:6]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DATA_PREFETCH</name>
                <description>N/A</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DATA_SIZE</name>
                <description>N/A</description>
                <bitRange>[17:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CH_DISABLE</name>
                <description>N/A</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>SRC_TRANSFER_SIZE</name>
                <description>N/A</description>
                <bitRange>[26:26]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DST_TRANSFER_SIZE</name>
                <description>N/A</description>
                <bitRange>[27:27]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DESCR_TYPE</name>
                <description>N/A</description>
                <bitRange>[30:28]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DESCR_SRC</name>
            <description>Channel descriptor source</description>
            <addressOffset>0x64</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>ADDR</name>
                <description>N/A</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DESCR_DST</name>
            <description>Channel descriptor destination</description>
            <addressOffset>0x68</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>ADDR</name>
                <description>N/A</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DESCR_X_SIZE</name>
            <description>Channel descriptor X size</description>
            <addressOffset>0x6C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>X_COUNT</name>
                <description>N/A</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DESCR_X_INCR</name>
            <description>Channel descriptor X increment</description>
            <addressOffset>0x70</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>SRC_X</name>
                <description>N/A</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DST_X</name>
                <description>N/A</description>
                <bitRange>[31:16]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DESCR_Y_SIZE</name>
            <description>Channel descriptor Y size</description>
            <addressOffset>0x74</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>Y_COUNT</name>
                <description>N/A</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DESCR_Y_INCR</name>
            <description>Channel descriptor Y increment</description>
            <addressOffset>0x78</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>SRC_Y</name>
                <description>N/A</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DST_Y</name>
                <description>N/A</description>
                <bitRange>[31:16]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DESCR_NEXT</name>
            <description>Channel descriptor next pointer</description>
            <addressOffset>0x7C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>PTR</name>
                <description>N/A</description>
                <bitRange>[31:2]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR</name>
            <description>Interrupt</description>
            <addressOffset>0x80</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>COMPLETION</name>
                <description>Activated (set to '1') on completion of data transfer(s) as specified by the descriptor's CH_DESCR_CTL.INTR_TYPE.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SRC_BUS_ERROR</name>
                <description>Activated (set to '1') on a bus error for a load from the source.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DST_BUS_ERROR</name>
                <description>Activated (set to '1') on a bus error for a store to the destination.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SRC_MISAL</name>
                <description>Activated (set to '1') on a misalignment of the source address.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DST_MISAL</name>
                <description>Activated (set to '1') on a misalignment of the destination address.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CURR_PTR_NULL</name>
                <description>Activated (set to '1') when the channel is enabled (CH_CTL.ENABLED is '1') and CH_CURR_PTR is '0'.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ACTIVE_CH_DISABLED</name>
                <description>Activated (set to '1') when the channel is disabled and the data transfer engine is busy.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DESCR_BUS_ERROR</name>
                <description>Activated (set to '1') on a bus error for a load of the descriptor.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SET</name>
            <description>Interrupt set</description>
            <addressOffset>0x84</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>COMPLETION</name>
                <description>Write this field with '1' to set corresponding INTR field to '1' (a write of '0' has no effect).</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SRC_BUS_ERROR</name>
                <description>N/A</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DST_BUS_ERROR</name>
                <description>N/A</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SRC_MISAL</name>
                <description>N/A</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DST_MISAL</name>
                <description>N/A</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CURR_PTR_NULL</name>
                <description>N/A</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ACTIVE_CH_DISABLED</name>
                <description>N/A</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DESCR_BUS_ERROR</name>
                <description>N/A</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASK</name>
            <description>Interrupt mask</description>
            <addressOffset>0x88</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>COMPLETION</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SRC_BUS_ERROR</name>
                <description>N/A</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DST_BUS_ERROR</name>
                <description>N/A</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SRC_MISAL</name>
                <description>N/A</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DST_MISAL</name>
                <description>N/A</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CURR_PTR_NULL</name>
                <description>N/A</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ACTIVE_CH_DISABLED</name>
                <description>N/A</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DESCR_BUS_ERROR</name>
                <description>N/A</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASKED</name>
            <description>Interrupt masked</description>
            <addressOffset>0x8C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>COMPLETION</name>
                <description>Logical and of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>SRC_BUS_ERROR</name>
                <description>N/A</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DST_BUS_ERROR</name>
                <description>N/A</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>SRC_MISAL</name>
                <description>N/A</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DST_MISAL</name>
                <description>N/A</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CURR_PTR_NULL</name>
                <description>N/A</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>ACTIVE_CH_DISABLED</name>
                <description>N/A</description>
                <bitRange>[6:6]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DESCR_BUS_ERROR</name>
                <description>N/A</description>
                <bitRange>[7:7]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>EFUSE</name>
      <description>EFUSE MXS40 registers</description>
      <baseAddress>0x402C0000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>512</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTL</name>
          <description>Control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>IP enable:
'0': Disabled. All non-retention registers (command and status registers) are reset to their default value when the IP is disabled. All retention registers retain their value when the IP is disabled.
'1': Enabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TEST</name>
          <description>Test</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>MARG_READ</name>
              <description>Margin Read</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>LOWR</name>
                  <description>Low Resistance: -50 percent from nominal</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DEFAULTR</name>
                  <description>Nominal resistance (Default read condition)</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HIGHR</name>
                  <description>High Resistance: +50 percent from nominal</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HIGHERR</name>
                  <description>Higher Resistance: +100 percent from nominal</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CMD</name>
          <description>Command</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1</resetValue>
          <resetMask>0x800F1F71</resetMask>
          <fields>
            <field>
              <name>BIT_DATA</name>
              <description>Bit data. This field specifies the bit value that is to be programmed into the eFUSE macro array. The address of the bit is specified by the BIT_ADDR, BYTE_ADDR, and MACRO_ADDR fields. This bit is a don't care for the MXS40 Macro.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BIT_ADDR</name>
              <description>Bit address. This field specifies a bit within a Byte.</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BYTE_ADDR</name>
              <description>Byte address. This field specifies a Byte within a eFUSE macro (each macro has 32 B).</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MACRO_ADDR</name>
              <description>Macro address. This field specifies an eFUSE macro.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>START</name>
              <description>FW sets this field to '1' to start a program operation. HW sets this field to '0' to indicate that the operation has completed.

Note: it is good practice to verify the result of a program operation by reading back a programmed eFUSE memory location. Programming can only change an eFUSE memory bit from '0' to '1'; i.e. a programming operation is a 'one-off' operation for each eFUSE memory bit: once a bit is changed to '1', it can NEVER be changed back to '0' as a hardware fuse is blown.

Programming a memory bit to '1' requires blowing a fuse and requires an eFUSE macro operation. Therefore, this programmiong operation takes time (as specified by the SEQ_PROGRAM_CTL reguisters). Programming amemory bit to '0' does not require an eFUSE macro operation (it is the default eFUSE macro state). Therefore, this programming operation is almost instantaneous.

Note: during a program operation, a read operation can not be performed. An AHB-Lite read transfer to the eFUSE memory during a program operation results in an AHB-Lite bus error.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_DEFAULT</name>
          <description>Sequencer Default value</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1D0000</resetValue>
          <resetMask>0x7F0000</resetMask>
          <fields>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_READ_CTL_0</name>
          <description>Sequencer read control 0</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80560001</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_READ_CTL_1</name>
          <description>Sequencer read control 1</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x540004</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_READ_CTL_2</name>
          <description>Sequencer read control 2</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x560001</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_READ_CTL_3</name>
          <description>Sequencer read control 3</description>
          <addressOffset>0x4C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x540003</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_READ_CTL_4</name>
          <description>Sequencer read control 4</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80150001</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_READ_CTL_5</name>
          <description>Sequencer read control 5</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x310004</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_PROGRAM_CTL_0</name>
          <description>Sequencer program control 0</description>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x200001</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_a</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_PROGRAM_CTL_1</name>
          <description>Sequencer program control 1</description>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x220020</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_a</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_PROGRAM_CTL_2</name>
          <description>Sequencer program control 2</description>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x200001</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_a</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_PROGRAM_CTL_3</name>
          <description>Sequencer program control 3</description>
          <addressOffset>0x6C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x310005</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_a</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_PROGRAM_CTL_4</name>
          <description>Sequencer program control 4</description>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80350006</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_a</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_PROGRAM_CTL_5</name>
          <description>Sequencer program control 5</description>
          <addressOffset>0x74</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x803D0019</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_a</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>EFUSE_DATA</name>
      <description>eFUSE memory</description>
      <baseAddress>0x402C0800</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>512</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>SECURE_HASH_WORD0</name>
          <description>Secure HASH word 0</description>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HASH_WORD0</name>
              <description>Secure HASH word 0</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SECURE_HASH_WORD1</name>
          <description>Secure HASH word 1</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HASH_WORD1</name>
              <description>Secure HASH word 1</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SECURE_HASH_WORD2</name>
          <description>Secure HASH word 2</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HASH_WORD2</name>
              <description>Secure HASH word 2</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SECURE_HASH_WORD3</name>
          <description>Secure HASH word 3</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HASH_WORD3</name>
              <description>Secure HASH word 3</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SECURE_ACCESS_RESTRICT</name>
          <description>Secure access restrictions</description>
          <addressOffset>0x3C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AP_CTL_CM0_DISABLE</name>
              <description>goes to CPUSS.AP_CTL</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>AP_CTL_CM4_DISABLE</name>
              <description>goes to CPUSS.AP_CTL</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>AP_CTL_SYS_DISABLE</name>
              <description>goes to CPUSS.AP_CTL</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SYS_AP_MPU_ENABLE</name>
              <description>goes to SYS DAP MPU</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DIRECT_EXECUTE_DISABLE</name>
              <description>used by ROM boot</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FLASH_ALLOWED</name>
              <description>goes to SYS DAP MPU</description>
              <bitRange>[10:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SRAM_ALLOWED</name>
              <description>goes to SYS DAP MPU</description>
              <bitRange>[13:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WORK_FLASH_ALLOWED</name>
              <description>goes to SYS DAP MPU</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SFLASH_ALLOWED</name>
              <description>goes to SYS DAP MPU</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MMIO_ALLOWED</name>
              <description>goes to SYS DAP MPU</description>
              <bitRange>[19:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SMIF_XIP_ENABLE</name>
              <description>goes to SYS DAP MPU</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESEREVED</name>
              <description>N/A</description>
              <bitRange>[31:21]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SECURE_DEAD_ACCESS_RESTRICT_ZEROS</name>
          <description>Dead access restriction in SECURE lifecycle and number of zeros for Secure fuse group</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF1FFFFF</resetMask>
          <fields>
            <field>
              <name>AP_CTL_CM0_DISABLE</name>
              <description>goes to CPUSS.AP_CTL</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>AP_CTL_CM4_DISABLE</name>
              <description>goes to CPUSS.AP_CTL</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>AP_CTL_SYS_DISABLE</name>
              <description>goes to CPUSS.AP_CTL</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SYS_AP_MPU_ENABLE</name>
              <description>goes to SYS DAP MPU</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DIRECT_EXECUTE_DISABLE</name>
              <description>used by ROM boot</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FLASH_ALLOWED</name>
              <description>goes to SYS DAP MPU</description>
              <bitRange>[10:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SRAM_ALLOWED</name>
              <description>goes to SYS DAP MPU</description>
              <bitRange>[13:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WORK_FLASH_ALLOWED</name>
              <description>goes to SYS DAP MPU</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SFLASH_ALLOWED</name>
              <description>goes to SYS DAP MPU</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MMIO_ALLOWED</name>
              <description>goes to SYS DAP MPU</description>
              <bitRange>[19:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SMIF_XIP_ENABLE</name>
              <description>goes to SYS DAP MPU</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SECURE_GROUP_ZEROS</name>
              <description>number of zeros for Secure fuse group covers secure hash, secure access restriction, secure hash zeros, secure dead access restriction</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>6</dim>
          <dimIncrement>4</dimIncrement>
          <name>CUSTOMER_DATA[%s]</name>
          <description>Customer Data</description>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA_BYTE</name>
              <description>Customer Data</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>HSIOM</name>
      <description>High Speed IO Matrix (HSIOM)</description>
      <baseAddress>0x40300000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>16384</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>24</dim>
          <dimIncrement>16</dimIncrement>
          <name>PRT[%s]</name>
          <description>HSIOM port registers</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>PORT_SEL0</name>
            <description>Port selection 0</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>IO0_SEL</name>
                <description>Selects connection for IO pin 0 route.</description>
                <bitRange>[4:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>GPIO</name>
                    <description>GPIO controls 'out'</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>GPIO_DSI</name>
                    <description>GPIO controls 'out', DSI controls 'output enable'</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DSI_DSI</name>
                    <description>DSI controls 'out' and 'output enable'</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DSI_GPIO</name>
                    <description>DSI controls 'out', GPIO controls 'output enable'</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>AMUXA</name>
                    <description>Analog mux bus A</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>AMUXB</name>
                    <description>Analog mux bus B</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>AMUXA_DSI</name>
                    <description>Analog mux bus A, DSI control</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>AMUXB_DSI</name>
                    <description>Analog mux bus B, DSI control</description>
                    <value>7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_0</name>
                    <description>Active functionality 0</description>
                    <value>8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_1</name>
                    <description>Active functionality 1</description>
                    <value>9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_2</name>
                    <description>Active functionality 2</description>
                    <value>10</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_3</name>
                    <description>Active functionality 3</description>
                    <value>11</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_0</name>
                    <description>DeepSleep functionality 0</description>
                    <value>12</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_1</name>
                    <description>DeepSleep functionality 1</description>
                    <value>13</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_2</name>
                    <description>DeepSleep functionality 2</description>
                    <value>14</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_3</name>
                    <description>DeepSleep functionality 3</description>
                    <value>15</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_4</name>
                    <description>Active functionality 4</description>
                    <value>16</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_5</name>
                    <description>Active functionality 5</description>
                    <value>17</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_6</name>
                    <description>Active functionality 6</description>
                    <value>18</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_7</name>
                    <description>Active functionality 7</description>
                    <value>19</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_8</name>
                    <description>Active functionality 8</description>
                    <value>20</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_9</name>
                    <description>Active functionality 9</description>
                    <value>21</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_10</name>
                    <description>Active functionality 10</description>
                    <value>22</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_11</name>
                    <description>Active functionality 11</description>
                    <value>23</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_12</name>
                    <description>Active functionality 12</description>
                    <value>24</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_13</name>
                    <description>Active functionality 13</description>
                    <value>25</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_14</name>
                    <description>Active functionality 14</description>
                    <value>26</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_15</name>
                    <description>Active functionality 15</description>
                    <value>27</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_4</name>
                    <description>DeepSleep functionality 4</description>
                    <value>28</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_5</name>
                    <description>DeepSleep functionality 5</description>
                    <value>29</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_6</name>
                    <description>DeepSleep functionality 6</description>
                    <value>30</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_7</name>
                    <description>DeepSleep functionality 7</description>
                    <value>31</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IO1_SEL</name>
                <description>Selects connection for IO pin 1 route.</description>
                <bitRange>[12:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IO2_SEL</name>
                <description>Selects connection for IO pin 2 route.</description>
                <bitRange>[20:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IO3_SEL</name>
                <description>Selects connection for IO pin 3 route.</description>
                <bitRange>[28:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PORT_SEL1</name>
            <description>Port selection 1</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>IO4_SEL</name>
                <description>Selects connection for IO pin 4 route.
See PORT_SEL0 for connection details.</description>
                <bitRange>[4:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IO5_SEL</name>
                <description>Selects connection for IO pin 5 route.</description>
                <bitRange>[12:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IO6_SEL</name>
                <description>Selects connection for IO pin 6 route.</description>
                <bitRange>[20:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IO7_SEL</name>
                <description>Selects connection for IO pin 7 route.</description>
                <bitRange>[28:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <dim>64</dim>
          <dimIncrement>4</dimIncrement>
          <name>AMUX_SPLIT_CTL[%s]</name>
          <description>AMUX splitter cell control</description>
          <addressOffset>0x2000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x77</resetMask>
          <fields>
            <field>
              <name>SWITCH_AA_SL</name>
              <description>T-switch control for Left AMUXBUSA switch:
'0': switch open.
'1': switch closed.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SWITCH_AA_SR</name>
              <description>T-switch control for Right AMUXBUSA switch:
'0': switch open.
'1': switch closed.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SWITCH_AA_S0</name>
              <description>T-switch control for AMUXBUSA vssa/ground switch:
'0': switch open.
'1': switch closed.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SWITCH_BB_SL</name>
              <description>T-switch control for Left AMUXBUSB switch.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SWITCH_BB_SR</name>
              <description>T-switch control for Right AMUXBUSB switch.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SWITCH_BB_S0</name>
              <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MONITOR_CTL_0</name>
          <description>Power/Ground Monitor cell control 0</description>
          <addressOffset>0x2200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MONITOR_EN</name>
              <description>control for switch, which connects the power/ground supply to AMUXBUS_A/B respectively when switch is closed:
'0': switch open.
'1': switch closed.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MONITOR_CTL_1</name>
          <description>Power/Ground Monitor cell control 1</description>
          <addressOffset>0x2204</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MONITOR_EN</name>
              <description>control for switch, which connects the power/ground supply to AMUXBUS_A/B respectively when switch is closed:
'0': switch open.
'1': switch closed.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MONITOR_CTL_2</name>
          <description>Power/Ground Monitor cell control 2</description>
          <addressOffset>0x2208</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MONITOR_EN</name>
              <description>control for switch, which connects the power/ground supply to AMUXBUS_A/B respectively when switch is closed:
'0': switch open.
'1': switch closed.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MONITOR_CTL_3</name>
          <description>Power/Ground Monitor cell control 3</description>
          <addressOffset>0x220C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MONITOR_EN</name>
              <description>control for switch, which connects the power/ground supply to AMUXBUS_A/B respectively when switch is closed:
'0': switch open.
'1': switch closed.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ALT_JTAG_EN</name>
          <description>Alternate JTAG IF selection register</description>
          <addressOffset>0x2240</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>ENABLE</name>
              <description>Provides the selection for alternate JTAG IF connectivity.
0: Primary JTAG interface is selected
1: Secondary (alternate) JTAG interface is selected.

This connectivity works ONLY in ACTIVE mode.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>GPIO</name>
      <description>GPIO port control/configuration</description>
      <baseAddress>0x40310000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>24</dim>
          <dimIncrement>128</dimIncrement>
          <name>PRT[%s]</name>
          <description>GPIO port registers</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>OUT</name>
            <description>Port output data register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>OUT0</name>
                <description>IO output data for pin 0
'0': Output state set to '0'
'1': Output state set to '1'</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT1</name>
                <description>IO output data for pin 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT2</name>
                <description>IO output data for pin 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT3</name>
                <description>IO output data for pin 3</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT4</name>
                <description>IO output data for pin 4</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT5</name>
                <description>IO output data for pin 5</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT6</name>
                <description>IO output data for pin 6</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT7</name>
                <description>IO output data for pin 7</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>OUT_CLR</name>
            <description>Port output data set register</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>OUT0</name>
                <description>IO clear output for pin 0:
'0': Output state not affected.
'1': Output state set to '0'.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT1</name>
                <description>IO clear output for pin 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT2</name>
                <description>IO clear output for pin 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT3</name>
                <description>IO clear output for pin 3</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT4</name>
                <description>IO clear output for pin 4</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT5</name>
                <description>IO clear output for pin 5</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT6</name>
                <description>IO clear output for pin 6</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT7</name>
                <description>IO clear output for pin 7</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>OUT_SET</name>
            <description>Port output data clear register</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>OUT0</name>
                <description>IO set output for pin 0:
'0': Output state not affected.
'1': Output state set to '1'.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT1</name>
                <description>IO set output for pin 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT2</name>
                <description>IO set output for pin 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT3</name>
                <description>IO set output for pin 3</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT4</name>
                <description>IO set output for pin 4</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT5</name>
                <description>IO set output for pin 5</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT6</name>
                <description>IO set output for pin 6</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT7</name>
                <description>IO set output for pin 7</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>OUT_INV</name>
            <description>Port output data invert register</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>OUT0</name>
                <description>IO invert output for pin 0:
'0': Output state not affected.
'1': Output state inverted ('0' =&gt; '1', '1' =&gt; '0').</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT1</name>
                <description>IO invert output for pin 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT2</name>
                <description>IO invert output for pin 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT3</name>
                <description>IO invert output for pin 3</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT4</name>
                <description>IO invert output for pin 4</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT5</name>
                <description>IO invert output for pin 5</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT6</name>
                <description>IO invert output for pin 6</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT7</name>
                <description>IO invert output for pin 7</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>IN</name>
            <description>Port input state register</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>IN0</name>
                <description>IO pin state for pin 0
'0': Low logic level present on pin.
'1': High logic level present on pin.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN1</name>
                <description>IO pin state for pin 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN2</name>
                <description>IO pin state for pin 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN3</name>
                <description>IO pin state for pin 3</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN4</name>
                <description>IO pin state for pin 4</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN5</name>
                <description>IO pin state for pin 5</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN6</name>
                <description>IO pin state for pin 6</description>
                <bitRange>[6:6]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN7</name>
                <description>IO pin state for pin 7</description>
                <bitRange>[7:7]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>FLT_IN</name>
                <description>Reads of this register return the logical state of the filtered pin as selected in the INTR_CFG.FLT_SEL register.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR</name>
            <description>Port interrupt status register</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF01FF</resetMask>
            <fields>
              <field>
                <name>EDGE0</name>
                <description>Edge detect for IO pin 0
'0': No edge was detected on pin.
'1': An edge was detected on pin.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE1</name>
                <description>Edge detect for IO pin 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE2</name>
                <description>Edge detect for IO pin 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE3</name>
                <description>Edge detect for IO pin 3</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE4</name>
                <description>Edge detect for IO pin 4</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE5</name>
                <description>Edge detect for IO pin 5</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE6</name>
                <description>Edge detect for IO pin 6</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE7</name>
                <description>Edge detect for IO pin 7</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FLT_EDGE</name>
                <description>Edge detected on filtered pin selected by INTR_CFG.FLT_SEL</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IN_IN0</name>
                <description>IO pin state for pin 0</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN_IN1</name>
                <description>IO pin state for pin 1</description>
                <bitRange>[17:17]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN_IN2</name>
                <description>IO pin state for pin 2</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN_IN3</name>
                <description>IO pin state for pin 3</description>
                <bitRange>[19:19]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN_IN4</name>
                <description>IO pin state for pin 4</description>
                <bitRange>[20:20]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN_IN5</name>
                <description>IO pin state for pin 5</description>
                <bitRange>[21:21]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN_IN6</name>
                <description>IO pin state for pin 6</description>
                <bitRange>[22:22]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN_IN7</name>
                <description>IO pin state for pin 7</description>
                <bitRange>[23:23]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>FLT_IN_IN</name>
                <description>Filtered pin state for pin selected by INTR_CFG.FLT_SEL</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASK</name>
            <description>Port interrupt mask register</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>EDGE0</name>
                <description>Masks edge interrupt on IO pin 0
'0': Pin interrupt forwarding disabled
'1': Pin interrupt forwarding enabled</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE1</name>
                <description>Masks edge interrupt on IO pin 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE2</name>
                <description>Masks edge interrupt on IO pin 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE3</name>
                <description>Masks edge interrupt on IO pin 3</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE4</name>
                <description>Masks edge interrupt on IO pin 4</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE5</name>
                <description>Masks edge interrupt on IO pin 5</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE6</name>
                <description>Masks edge interrupt on IO pin 6</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE7</name>
                <description>Masks edge interrupt on IO pin 7</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FLT_EDGE</name>
                <description>Masks edge interrupt on filtered pin selected by INTR_CFG.FLT_SEL</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASKED</name>
            <description>Port interrupt masked status register</description>
            <addressOffset>0x1C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>EDGE0</name>
                <description>Edge detected AND masked on IO pin 0
'0': Interrupt was not forwarded to CPU
'1': Interrupt occurred and was forwarded to CPU</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EDGE1</name>
                <description>Edge detected and masked on IO pin 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EDGE2</name>
                <description>Edge detected and masked on IO pin 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EDGE3</name>
                <description>Edge detected and masked on IO pin 3</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EDGE4</name>
                <description>Edge detected and masked on IO pin 4</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EDGE5</name>
                <description>Edge detected and masked on IO pin 5</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EDGE6</name>
                <description>Edge detected and masked on IO pin 6</description>
                <bitRange>[6:6]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EDGE7</name>
                <description>Edge detected and masked on IO pin 7</description>
                <bitRange>[7:7]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>FLT_EDGE</name>
                <description>Edge detected and masked on filtered pin selected by INTR_CFG.FLT_SEL</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SET</name>
            <description>Port interrupt set register</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>EDGE0</name>
                <description>Sets edge detect interrupt for IO pin 0
'0': Interrupt state not affected
'1': Interrupt set</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE1</name>
                <description>Sets edge detect interrupt for IO pin 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE2</name>
                <description>Sets edge detect interrupt for IO pin 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE3</name>
                <description>Sets edge detect interrupt for IO pin 3</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE4</name>
                <description>Sets edge detect interrupt for IO pin 4</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE5</name>
                <description>Sets edge detect interrupt for IO pin 5</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE6</name>
                <description>Sets edge detect interrupt for IO pin 6</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE7</name>
                <description>Sets edge detect interrupt for IO pin 7</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FLT_EDGE</name>
                <description>Sets edge detect interrupt for filtered pin selected by INTR_CFG.FLT_SEL</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_CFG</name>
            <description>Port interrupt configuration register</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FFFFF</resetMask>
            <fields>
              <field>
                <name>EDGE0_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pin 0</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLE</name>
                    <description>Disabled</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RISING</name>
                    <description>Rising edge</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING</name>
                    <description>Falling edge</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH</name>
                    <description>Both rising and falling edges</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EDGE1_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pin 1</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE2_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pin 2</description>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE3_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pin 3</description>
                <bitRange>[7:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE4_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pin 4</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE5_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pin 5</description>
                <bitRange>[11:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE6_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pin 6</description>
                <bitRange>[13:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE7_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pin 7</description>
                <bitRange>[15:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FLT_EDGE_SEL</name>
                <description>Sets which edge will trigger an IRQ for the glitch filtered pin (selected by INTR_CFG.FLT_SEL</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLE</name>
                    <description>Disabled</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RISING</name>
                    <description>Rising edge</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING</name>
                    <description>Falling edge</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH</name>
                    <description>Both rising and falling edges</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FLT_SEL</name>
                <description>Selects which pin is routed through the 50ns glitch filter to provide a glitch-safe interrupt.</description>
                <bitRange>[20:18]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CFG</name>
            <description>Port configuration register</description>
            <addressOffset>0x44</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DRIVE_MODE0</name>
                <description>The GPIO drive mode for IO pin 0. Resistive pull-up and pull-down is selected in the drive mode.
Note: when initializing IO's that are connected to a live bus (such as I2C), make sure the peripheral and HSIOM (HSIOM_PRT_SELx) is properly configured  before turning the IO on here to avoid producing glitches on the bus.
Note: that peripherals other than GPIO &amp; UDB/DSI directly control both the output and output-enable of the output buffer (peripherals can drive strong 0 or strong 1 in any mode except OFF='0').  
Note: D_OUT, D_OUT_EN are pins of GPIO cell.</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>HIGHZ</name>
                    <description>Output buffer is off creating a high impedance input
D_OUT = '0': High Impedance
D_OUT = '1': High Impedance</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RSVD</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PULLUP</name>
                    <description>Resistive pull up

For GPIO &amp; UDB/DSI peripherals:
When D_OUT_EN = 1:
   D_OUT = '0': Strong pull down
   D_OUT = '1': Weak/resistive pull up
When D_OUT_EN = 0:
   D_OUT = '0': High impedance
   D_OUT = '1': High impedance

For peripherals other than GPIO &amp; UDB/DSI:
When D_OUT_EN = 1:
   D_OUT = '0': Strong pull down
   D_OUT = '1': Strong pull up
When D_OUT_EN = 0:
   D_OUT = '0': Weak/resistive pull up
   D_OUT = '1': Weak/resistive pull up</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PULLDOWN</name>
                    <description>Resistive pull down

For GPIO &amp; UDB/DSI peripherals:
When D_OUT_EN = 1:
   D_OUT = '0': Weak/resistive pull down
   D_OUT = '1': Strong pull up
When D_OUT_EN = 0:
   D_OUT = '0': High impedance
   D_OUT = '1': High impedance

For peripherals other than GPIO &amp; UDB/DSI:
When D_OUT_EN = 1:
   D_OUT = '0': Strong pull down
   D_OUT = '1': Strong pull up
When D_OUT_EN = 0:
   D_OUT = '0': Weak/resistive pull down
   D_OUT = '1': Weak/resistive pull down</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>OD_DRIVESLOW</name>
                    <description>Open drain, drives low

For GPIO &amp; UDB/DSI peripherals:
When D_OUT_EN = 1:
   D_OUT = '0': Strong pull down
   D_OUT = '1': High Impedance
When D_OUT_EN = 0:
   D_OUT = '0': High impedance
   D_OUT = '1': High impedance

For peripherals other than GPIO &amp; UDB/DSI:
When D_OUT_EN = 1:
   D_OUT = '0': Strong pull down
   D_OUT = '1': Strong pull up
When D_OUT_EN = 0:
   D_OUT = '0': High Impedance
   D_OUT = '1': High Impedance</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>OD_DRIVESHIGH</name>
                    <description>Open drain, drives high

For GPIO &amp; UDB/DSI peripherals:
When D_OUT_EN = 1:
   D_OUT = '0': High Impedance
   D_OUT = '1': Strong pull up
When D_OUT_EN = 0:
   D_OUT = '0': High impedance
   D_OUT = '1': High impedance

For peripherals other than GPIO &amp; UDB/DSI:
When D_OUT_EN = 1:
   D_OUT = '0': Strong pull down
   D_OUT = '1': Strong pull up
When D_OUT_EN = 0:
   D_OUT = '0': High Impedance
   D_OUT = '1': High Impedance</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STRONG</name>
                    <description>Strong D_OUTput buffer

For GPIO &amp; UDB/DSI peripherals:
When D_OUT_EN = 1:
   D_OUT = '0': Strong pull down
   D_OUT = '1': Strong pull up
When D_OUT_EN = 0:
   D_OUT = '0': High impedance
   D_OUT = '1': High impedance

For peripherals other than GPIO &amp; UDB/DSI:
When D_OUT_EN = 1:
   D_OUT = '0': Strong pull down
   D_OUT = '1': Strong pull up
When D_OUT_EN = 0:
   D_OUT = '0': High Impedance
   D_OUT = '1': High Impedance</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PULLUP_DOWN</name>
                    <description>Pull up or pull down

For GPIO &amp; UDB/DSI peripherals:
When D_OUT_EN = '0':
    GPIO_DSI_OUT = '0': Weak/resistive pull down
    GPIO_DSI_OUT = '1': Weak/resistive pull up
where 'GPIO_DSI_OUT' is a function of PORT_SEL, OUT &amp; DSI_DATA_OUT.

For peripherals other than GPIO &amp; UDB/DSI:
When D_OUT_EN = 1:
   D_OUT = '0': Strong pull down
   D_OUT = '1': Strong pull up
When D_OUT_EN = 0:
    D_OUT = '0': Weak/resistive pull down
    D_OUT = '1': Weak/resistive pull up</description>
                    <value>7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IN_EN0</name>
                <description>Enables the input buffer for IO pin 0.  This bit should be cleared when analog signals are present on the pin to avoid crowbar currents.  The output buffer can be used to drive analog signals high or low without issue.
'0': Input buffer disabled
'1': Input buffer enabled</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_MODE1</name>
                <description>The GPIO drive mode for IO pin 1</description>
                <bitRange>[6:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IN_EN1</name>
                <description>Enables the input buffer for IO pin 1</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_MODE2</name>
                <description>The GPIO drive mode for IO pin 2</description>
                <bitRange>[10:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IN_EN2</name>
                <description>Enables the input buffer for IO pin 2</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_MODE3</name>
                <description>The GPIO drive mode for IO pin 3</description>
                <bitRange>[14:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IN_EN3</name>
                <description>Enables the input buffer for IO pin 3</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_MODE4</name>
                <description>The GPIO drive mode for IO pin4</description>
                <bitRange>[18:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IN_EN4</name>
                <description>Enables the input buffer for IO pin 4</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_MODE5</name>
                <description>The GPIO drive mode for IO pin 5</description>
                <bitRange>[22:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IN_EN5</name>
                <description>Enables the input buffer for IO pin 5</description>
                <bitRange>[23:23]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_MODE6</name>
                <description>The GPIO drive mode for IO pin 6</description>
                <bitRange>[26:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IN_EN6</name>
                <description>Enables the input buffer for IO pin 6</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_MODE7</name>
                <description>The GPIO drive mode for IO pin 7</description>
                <bitRange>[30:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IN_EN7</name>
                <description>Enables the input buffer for IO pin 7</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CFG_IN</name>
            <description>Port input buffer configuration register</description>
            <addressOffset>0x48</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>VTRIP_SEL0_0</name>
                <description>Configures the pin 0 input buffer mode (trip points and hysteresis)</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>CMOS</name>
                    <description>Input buffer compatible with CMOS and I2C interfaces</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>TTL</name>
                    <description>Input buffer compatible with TTL and MediaLB interfaces</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>VTRIP_SEL1_0</name>
                <description>Configures the pin 1 input buffer mode (trip points and hysteresis)</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL2_0</name>
                <description>Configures the pin 2 input buffer mode (trip points and hysteresis)</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL3_0</name>
                <description>Configures the pin 3 input buffer mode (trip points and hysteresis)</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL4_0</name>
                <description>Configures the pin 4 input buffer mode (trip points and hysteresis)</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL5_0</name>
                <description>Configures the pin 5 input buffer mode (trip points and hysteresis)</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL6_0</name>
                <description>Configures the pin 6 input buffer mode (trip points and hysteresis)</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL7_0</name>
                <description>Configures the pin 7 input buffer mode (trip points and hysteresis)</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CFG_OUT</name>
            <description>Port output buffer configuration register</description>
            <addressOffset>0x4C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF00FF</resetMask>
            <fields>
              <field>
                <name>SLOW0</name>
                <description>Enables slow slew rate for IO pin 0
'0': Fast slew rate
'1': Slow slew rate</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLOW1</name>
                <description>Enables slow slew rate for IO pin 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLOW2</name>
                <description>Enables slow slew rate for IO pin 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLOW3</name>
                <description>Enables slow slew rate for IO pin 3</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLOW4</name>
                <description>Enables slow slew rate for IO pin 4</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLOW5</name>
                <description>Enables slow slew rate for IO pin 5</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLOW6</name>
                <description>Enables slow slew rate for IO pin 6</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLOW7</name>
                <description>Enables slow slew rate for IO pin 7</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_SEL0</name>
                <description>Sets the GPIO drive strength for IO pin 0</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>FULL_DRIVE</name>
                    <description>Full drive strength: GPIO drives current at its max rated spec.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ONE_HALF_DRIVE</name>
                    <description>1/2 drive strength: GPIO drives current at 1/2 of its max rated spec</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ONE_QUARTER_DRIVE</name>
                    <description>1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ONE_EIGHTH_DRIVE</name>
                    <description>1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DRIVE_SEL1</name>
                <description>Sets the GPIO drive strength for IO pin 1</description>
                <bitRange>[19:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_SEL2</name>
                <description>Sets the GPIO drive strength for IO pin 2</description>
                <bitRange>[21:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_SEL3</name>
                <description>Sets the GPIO drive strength for IO pin 3</description>
                <bitRange>[23:22]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_SEL4</name>
                <description>Sets the GPIO drive strength for IO pin 4</description>
                <bitRange>[25:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_SEL5</name>
                <description>Sets the GPIO drive strength for IO pin 5</description>
                <bitRange>[27:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_SEL6</name>
                <description>Sets the GPIO drive strength for IO pin 6</description>
                <bitRange>[29:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_SEL7</name>
                <description>Sets the GPIO drive strength for IO pin 7</description>
                <bitRange>[31:30]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CFG_SIO</name>
            <description>Port SIO configuration register</description>
            <addressOffset>0x50</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>VREG_EN01</name>
                <description>The regulated output mode is selected ONLY if the CFG.DRIVE_MODE bits are set to the strong pull up (Z_1 = '5') mode If the CFG.DRIVE_MODE bits are set to any other mode the regulated output buffer will be disabled and the standard CMOS output buffer is used.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IBUF_SEL01</name>
                <description>N/A</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL01</name>
                <description>N/A</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VREF_SEL01</name>
                <description>N/A</description>
                <bitRange>[4:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VOH_SEL01</name>
                <description>Selects trip-point of input buffer. In single ended input buffer mode (IBUF01_SEL = '0'):
0: input buffer functions as a CMOS input buffer.
1: input buffer functions as a LVTTL input buffer.
In differential input buffer mode (IBUF01_SEL = '1'):                                                                  VTRIP_SEL=0:                                                                                                                                a) VREF_SEL=00, VOH_SEL=X -&gt; Trip point=50 percent of vddio
b) VREF_SEL=01, VOH_SEL=000 -&gt; Trip point=Vohref (buffered)
c) VREF_SEL=01, VOH_SEL=[1-7] -&gt; Input buffer functions as CMOS input buffer.                                                                                                                                             
d) VREF_SEL=10/11, VOH_SEL=000 -&gt; Trip_point=Amuxbus_a/b (buffered)
e) VREF_SEL=10/11, VOH_SEL=[1-7]  -&gt;  Input buffer functions as CMOS input buffer.                                                                                                                                             VTRIP_SEL=1:                                                                                                                                a) VREF_SEL=00, VOH_SEL=X -&gt; Trip point=40 percent of vddio
b) VREF_SEL=01, VOH_SEL=000 -&gt; Trip point=0.5*Vohref
c) VREF_SEL=01, VOH_SEL=[1-7] -&gt; Input buffer functions as LVTTL input buffer.                                                                                                                                            d) VREF_SEL=10/11, VOH_SEL=000 -&gt; Trip_point=0.5*Amuxbus_a/b (buffered)
e) VREF_SEL=10/11, VOH_SEL=[1-7]  -&gt; Input buffer functions as LVTTL input buffer.</description>
                <bitRange>[7:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VREG_EN23</name>
                <description>N/A</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IBUF_SEL23</name>
                <description>N/A</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL23</name>
                <description>N/A</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VREF_SEL23</name>
                <description>N/A</description>
                <bitRange>[12:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VOH_SEL23</name>
                <description>N/A</description>
                <bitRange>[15:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VREG_EN45</name>
                <description>N/A</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IBUF_SEL45</name>
                <description>N/A</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL45</name>
                <description>N/A</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VREF_SEL45</name>
                <description>N/A</description>
                <bitRange>[20:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VOH_SEL45</name>
                <description>N/A</description>
                <bitRange>[23:21]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VREG_EN67</name>
                <description>N/A</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IBUF_SEL67</name>
                <description>N/A</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL67</name>
                <description>N/A</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VREF_SEL67</name>
                <description>N/A</description>
                <bitRange>[28:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VOH_SEL67</name>
                <description>N/A</description>
                <bitRange>[31:29]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CFG_IN_AUTOLVL</name>
            <description>Port GPIO5V input buffer configuration register</description>
            <addressOffset>0x58</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>VTRIP_SEL0_1</name>
                <description>Configures the input buffer mode (trip points and hysteresis) for GPIO5V upper bit.  Lower bit is still selected by CFG_IN.VTRIP_SEL0_0 field.  This field is used along with CFG_IN.VTRIP_SEL0_0 field as below:
{CFG_IN_GPIO5V.VTRIP_SEL0_1,CFG_IN.VTRIP_SEL0_0}:
0,0: CMOS
0,1: TTL
1,0: input buffer is compatible with automative.
1,1: input buffer is compatible with MediaLB.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>CMOS_OR_TTL</name>
                    <description>Input buffer compatible with CMOS/TTL interfaces as described in CFG_IN.VTRIP_SEL0_0.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>AUTO_OR_MediaLB</name>
                    <description>Input buffer compatible with AUTO/MedaiLB (elevated Vil) interfaces when used along with CFG_IN.VTRIP_SEL0_0.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>VTRIP_SEL1_1</name>
                <description>Input buffer compatible with automotive (elevated Vil) interfaces.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL2_1</name>
                <description>Input buffer compatible with automotive (elevated Vil) interfaces.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL3_1</name>
                <description>Input buffer compatible with automotive (elevated Vil) interfaces.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL4_1</name>
                <description>Input buffer compatible with automotive (elevated Vil) interfaces.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL5_1</name>
                <description>Input buffer compatible with automotive (elevated Vil) interfaces.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL6_1</name>
                <description>Input buffer compatible with automotive (elevated Vil) interfaces.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL7_1</name>
                <description>Input buffer compatible with automotive (elevated Vil) interfaces.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>INTR_CAUSE0</name>
          <description>Interrupt port cause register 0</description>
          <addressOffset>0x4000</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PORT_INT</name>
              <description>Each IO port has an associated bit field in this register. The bit field reflects the IO port's interrupt line (bit field i reflects 'gpio_interrupts[i]' for IO port i). The register is used when the system uses a combined interrupt line 'gpio_interrupt'. The software ISR reads the register to determine which IO port(s) is responsible for the combined interrupt line. Once, the IO port(s) is determined, the IO port's GPIO_PRT_INTR register is read to determine the IO pin(s) in the IO port that caused the interrupt.
'0': Port has no pending interrupt
'1': Port has pending interrupt</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_CAUSE1</name>
          <description>Interrupt port cause register 1</description>
          <addressOffset>0x4004</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PORT_INT</name>
              <description>Each IO port has an associated bit field in this register. The bit field reflects the IO port's interrupt line (bit field i reflects 'gpio_interrupts[i]' for IO port i). The register is used when the system uses a combined interrupt line 'gpio_interrupt'. The software ISR reads the register to deternine which IO port(s) is responsible for the combined interrupt line. Once, the IO port(s) is determined, the IO port's GPIO_PORT_INTR register is read to determine the IO pin(s) in the IO port that caused the interrupt.
'0': Port has no pending interrupt
'1': Port has pending interrupt</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_CAUSE2</name>
          <description>Interrupt port cause register 2</description>
          <addressOffset>0x4008</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PORT_INT</name>
              <description>Each IO port has an associated bit field in this register. The bit field reflects the IO port's interrupt line (bit field i reflects 'gpio_interrupts[i]' for IO port i). The register is used when the system uses a combined interrupt line 'gpio_interrupt'. The software ISR reads the register to deternine which IO port(s) is responsible for the combined interrupt line. Once, the IO port(s) is determined, the IO port's GPIO_PORT_INTR register is read to determine the IO pin(s) in the IO port that caused the interrupt.
'0': Port has no pending interrupt
'1': Port has pending interrupt</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_CAUSE3</name>
          <description>Interrupt port cause register 3</description>
          <addressOffset>0x400C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PORT_INT</name>
              <description>Each IO port has an associated bit field in this register. The bit field reflects the IO port's interrupt line (bit field i reflects 'gpio_interrupts[i]' for IO port i). The register is used when the system uses a combined interrupt line 'gpio_interrupt'. The software ISR reads the register to deternine which IO port(s) is responsible for the combined interrupt line. Once, the IO port(s) is determined, the IO port's GPIO_PORT_INTR register is read to determine the IO pin(s) in the IO port that caused the interrupt.
'0': Port has no pending interrupt
'1': Port has pending interrupt</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VDD_ACTIVE</name>
          <description>Extern power supply detection register</description>
          <addressOffset>0x4010</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC000FFFF</resetMask>
          <fields>
            <field>
              <name>VDDIO_ACTIVE</name>
              <description>Indicates presence or absence of VDDIO supplies (i.e. other than VDDD, VDDA) on the device (supplies are numbered 0..n-1).  Note that VDDIO supplies have basic (crude) supply detectors only.  If separate, robust, brown-out detection is desired on IO supplies, on-chip or off-chip analog resources need to provide it.  For these bits to work reliable, the supply must be within valid spec range (per datasheet) or held at ground.  Any in-between voltage has an undefined result.
'0': Supply is not present
'1': Supply is present

When multiple VDDIO supplies are present, they will be assigned in alphanumeric ascending order to these bits during implementation.
For example 'vddusb, vddio_0, vddio_a, vbackup, vddio_r, vddio_1' are present then they will be assigned to these bits as below:
0: vbackup, 
1: vddio_0, 
2: vddio_1,
3: vddio_a,
4: vddio_r,
5: vddusb'</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>VDDA_ACTIVE</name>
              <description>Same as VDDIO_ACTIVE for the analog supply VDDA.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>VDDD_ACTIVE</name>
              <description>This bit indicates presence of the VDDD supply.  This bit will always read-back 1.  The VDDD supply has robust brown-out protection monitoring and it is not possible to read back this register without a valid supply. (This bit is used in certain test-modes to observe the brown-out detector status.)</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VDD_INTR</name>
          <description>Supply detection interrupt register</description>
          <addressOffset>0x4014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC000FFFF</resetMask>
          <fields>
            <field>
              <name>VDDIO_ACTIVE</name>
              <description>Supply state change detected.
'0': No change to supply detected
'1': Change to supply detected</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VDDA_ACTIVE</name>
              <description>Same as VDDIO_ACTIVE for the analog supply VDDA.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VDDD_ACTIVE</name>
              <description>The VDDD supply is always present during operation so a supply transition can not occur. This bit will always read back '1'.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VDD_INTR_MASK</name>
          <description>Supply detection interrupt mask register</description>
          <addressOffset>0x4018</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC000FFFF</resetMask>
          <fields>
            <field>
              <name>VDDIO_ACTIVE</name>
              <description>Masks supply interrupt on VDDIO.
'0': VDDIO interrupt forwarding disabled
'1': VDDIO interrupt forwarding enabled</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VDDA_ACTIVE</name>
              <description>Same as VDDIO_ACTIVE for the analog supply VDDA.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VDDD_ACTIVE</name>
              <description>Same as VDDIO_ACTIVE for the digital supply VDDD.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VDD_INTR_MASKED</name>
          <description>Supply detection interrupt masked register</description>
          <addressOffset>0x401C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC000FFFF</resetMask>
          <fields>
            <field>
              <name>VDDIO_ACTIVE</name>
              <description>Supply transistion detected AND masked
'0': Interrupt was not forwarded to CPU
'1': Interrupt occurred and was forwarded to CPU</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>VDDA_ACTIVE</name>
              <description>Same as VDDIO_ACTIVE for the analog supply VDDA.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>VDDD_ACTIVE</name>
              <description>Same as VDDIO_ACTIVE for the digital supply VDDD.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VDD_INTR_SET</name>
          <description>Supply detection interrupt set register</description>
          <addressOffset>0x4020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC000FFFF</resetMask>
          <fields>
            <field>
              <name>VDDIO_ACTIVE</name>
              <description>Sets supply interrupt.
'0': Interrupt state not affected
'1': Interrupt set</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VDDA_ACTIVE</name>
              <description>Same as VDDIO_ACTIVE for the analog supply VDDA.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VDDD_ACTIVE</name>
              <description>Same as VDDIO_ACTIVE for the digital supply VDDD.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SMARTIO</name>
      <description>Programmable IO configuration</description>
      <baseAddress>0x40320000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>18</dim>
          <dimIncrement>256</dimIncrement>
          <name>PRT[%s]</name>
          <description>Programmable IO port registers</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>CTL</name>
            <description>Control register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x2001400</resetValue>
            <resetMask>0x82001F00</resetMask>
            <fields>
              <field>
                <name>BYPASS</name>
                <description>Bypass of the programmable IO, one bit for each IO pin: BYPASS[i] is for IO pin i. When ENABLED is '1', this field is used. When ENABLED is '0', this field is NOT used and SMARTIO fabric is always bypassed.
'0': No bypass (programmable SMARTIO fabric is exposed). 
'1': Bypass (programmable SMARTIOIO fabric is hidden).</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CLOCK_SRC</name>
                <description>Clock ('clk_fabric') and reset ('rst_fabric_n') source selection:
'0': io_data_in[0]/'1'.
...
'7': io_data_in[7]/'1'.
'8': chip_data[0]/'1'.
...
'15': chip_data[7]/'1'.
'16': clk_smartio/rst_sys_act_n. Used for both Active functionality synchronous logic on 'clk_smartio'. This selection is intended for synchronous operation on a PCLK specified clock frequency ('clock_smartio_pos_en'). Note that the fabric's clocked elements are frequency aligned, but NOT phase aligned to 'clk_sys'. 
'17': clk_smartio/rst_sys_dpslp_n. Used for both DeepSleep functionality synchronous logic on 'clk_smartio' (note that 'clk_smartio' is NOT available in DeepSleep and Hibernate power modes).  This selection is intended for synchronous operation on a PCLK specified clock frequency ('clock_smartio_pos_en'). Note that the fabric's clocked elements are frequency aligned, but NOT phase aligned to 'clk_sys'. 
'18': Same as '17'. Note that the M0S8 SMARTIO version used the Hibernate reset for this value, but the MXS40 SMARTIO version does not support Hibernate functionality.  
'19': clk_lf/rst_lf_dpslp_n (note that 'clk_lf' is available in DeepSleep power mode). This selection is intended for synchronous operation on'clk_lf'. Note that the fabric's clocked elements are frequency aligned, but NOT phase aligned to other 'clk_lf' clocked elements.
'20'-'30': Clock source is constant '0'. Any of these clock sources should be selected when the IP is disabled to ensure low power consumption.
'31': asynchronous mode/'1'.  Select this when clockless operation is configured.

NOTE: Two positive edges of the selected clock are required for the block to be enabled (to deactivate reset).  In asynchronous (clockless) mode clk_sys is used to enable the block, but is not available for clocking.</description>
                <bitRange>[12:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>HLD_OVR</name>
                <description>IO cell hold override functionality. In DeepSleep power mode, the HSIOM holds the IO cell output and output enable signals if Active functionality is connected to the IO pads. This is undesirable if the SMARTIO is supposed to deliver DeepSleep output functionality on these IO pads. This field is used to control the hold override functionality from the SMARTIO:
'0': The HSIOM controls the IO cell hold override functionality ('hsiom_hld_ovr').
'1': The SMARTIO controls the IO cel hold override functionality:
- In bypass mode (ENABLED is '0' or BYPASS[i] is '1'), the HSIOM control is used.
- In NON bypass mode (ENABLED is '1' and BYPASS[i] is '0'), the SMARTIO sets hold override to 'pwr_hld_ovr_hib' to enable SMARTIO functionality in DeepSleep power mode (but disables it in Hibernate or Stop power mode).</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PIPELINE_EN</name>
                <description>Enable for pipeline register:
'0': Disabled (register is bypassed).
'1': Enabled.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED</name>
                <description>Enable for programmable IO. Should only be set to '1' when the programmable IO is completely configured:
'0': Disabled (signals are bypassed; behavior as if BYPASS is 0xFF). When disabled, the fabric (data unit and LUTs) reset is activated.

If the IP is disabled:
- The PIPELINE_EN register field should be set to '1', to ensure low power consumption by preventing combinatorial loops.
- The CLOCK_SRC register field should be set to '20'-'30' (clock is constant '0'), to ensure low power consumption.

'1': Enabled. Once enabled, it takes 3 'clk_fabric' clock cycles till the fabric reset is de-activated and the fabric becomes fully functional. This ensures that the IO pins' input synchronizer states are flushed when the fabric is fully functional.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SYNC_CTL</name>
            <description>Synchronization control register</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>IO_SYNC_EN</name>
                <description>Synchronization of the IO pin input signals to 'clk_fabric', one bit for each IO pin: IO_SYNC_EN[i] is for IO pin i.
'0': No synchronization.
'1': Synchronization.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CHIP_SYNC_EN</name>
                <description>Synchronization of the chip input signals to 'clk_fabric', one bit for each input: CHIP_SYNC_EN[i] is for input i.
'0': No synchronization.
'1': Synchronization.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>8</dim>
            <dimIncrement>4</dimIncrement>
            <name>LUT_SEL[%s]</name>
            <description>LUT component input selection</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>LUT_TR0_SEL</name>
                <description>LUT input signal 'tr0_in' source selection:
'0': Data unit output.
'1': LUT 1 output.
'2': LUT 2 output.
'3': LUT 3 output.
'4': LUT 4 output.
'5': LUT 5 output.
'6': LUT 6 output.
'7': LUT 7 output.
'8': chip_data[0] (for LUTs 0, 1, 2, 3); chip_data[4] (for LUTs 4, 5, 6, 7).
'9': chip_data[1] (for LUTs 0, 1, 2, 3); chip_data[5] (for LUTs 4, 5, 6, 7).
'10': chip_data[2] (for LUTs 0, 1, 2, 3); chip_data[6] (for LUTs 4, 5, 6, 7).
'11': chip_data[3] (for LUTs 0, 1, 2, 3); chip_data[7] (for LUTs 4, 5, 6, 7).
'12': io_data_in[0] (for LUTs 0, 1, 2, 3); io_data_in[4] (for LUTs 4, 5, 6, 7).
'13': io_data_in[1] (for LUTs 0, 1, 2, 3); io_data_in[5] (for LUTs 4, 5, 6, 7).
'14': io_data_in[2] (for LUTs 0, 1, 2, 3); io_data_in[6] (for LUTs 4, 5, 6, 7).
'15': io_data_in[3] (for LUTs 0, 1, 2, 3); io_data_in[7] (for LUTs 4, 5, 6, 7).</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LUT_TR1_SEL</name>
                <description>LUT input signal 'tr1_in' source selection:
'0': LUT 0 output.
'1': LUT 1 output.
'2': LUT 2 output.
'3': LUT 3 output.
'4': LUT 4 output.
'5': LUT 5 output.
'6': LUT 6 output.
'7': LUT 7 output.
'8': chip_data[0] (for LUTs 0, 1, 2, 3); chip_data[4] (for LUTs 4, 5, 6, 7).
'9': chip_data[1] (for LUTs 0, 1, 2, 3); chip_data[5] (for LUTs 4, 5, 6, 7).
'10': chip_data[2] (for LUTs 0, 1, 2, 3); chip_data[6] (for LUTs 4, 5, 6, 7).
'11': chip_data[3] (for LUTs 0, 1, 2, 3); chip_data[7] (for LUTs 4, 5, 6, 7).
'12': io_data_in[0] (for LUTs 0, 1, 2, 3); io_data_in[4] (for LUTs 4, 5, 6, 7).
'13': io_data_in[1] (for LUTs 0, 1, 2, 3); io_data_in[5] (for LUTs 4, 5, 6, 7).
'14': io_data_in[2] (for LUTs 0, 1, 2, 3); io_data_in[6] (for LUTs 4, 5, 6, 7).
'15': io_data_in[3] (for LUTs 0, 1, 2, 3); io_data_in[7] (for LUTs 4, 5, 6, 7).</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LUT_TR2_SEL</name>
                <description>LUT input signal 'tr2_in' source selection. Encoding is the same as for LUT_TR1_SEL.</description>
                <bitRange>[19:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>8</dim>
            <dimIncrement>4</dimIncrement>
            <name>LUT_CTL[%s]</name>
            <description>LUT component control register</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>LUT</name>
                <description>LUT configuration. Depending on the LUT opcode LUT_OPC, the internal state lut_reg (captured in a flip-flop) and the LUT input signals tr0_in, tr1_in, tr2_in, the LUT configuration is used to determine the LUT output signal and the next sequential state (lut_reg).</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LUT_OPC</name>
                <description>LUT opcode specifies the LUT operation:
'0': Combinatoral output, no feedback.
   tr_out   = LUT[{tr2_in, tr1_in, tr0_in}].
'1': Combinatorial output, feedback.
   tr_out   = LUT[{lut_reg, tr1_in, tr0_in}].
On clock:
    lut_reg &lt;= tr_in2.
'2': Sequential output, no feedback.
   temp    = LUT[{tr2_in, tr1_in, tr0_in}].
   tr_out   = lut_reg.
On clock:
   lut_reg &lt;= temp.
'3': Register with asynchronous set and reset.
   tr_out           = lut_reg.
   enable          = (tr2_in ^ LUT[4]) | LUT[5].
   set               = enable &amp; (tr1_in ^ LUT[2]) &amp; LUT[3].
   clr                = enable &amp; (tr0_in ^ LUT[0]) &amp; LUT[1].
Asynchronously (no clock required):
   lut_reg         &lt;= if (clr) '0' else if (set) '1'</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DU_SEL</name>
            <description>Data unit component input selection</description>
            <addressOffset>0xC0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DU_TR0_SEL</name>
                <description>Data unit input signal 'tr0_in' source selection:
'0': Constant '0'.
'1': Constant '1'.
'2': Data unit output.
'10-3': LUT 7 - 0 outputs.
Otherwise: Undefined.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DU_TR1_SEL</name>
                <description>Data unit input signal 'tr1_in' source selection. Encoding is the same as for DU_TR0_SEL.</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DU_TR2_SEL</name>
                <description>Data unit input signal 'tr2_in' source selection. Encoding is the same as for DU_TR0_SEL.</description>
                <bitRange>[19:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DU_DATA0_SEL</name>
                <description>Data unit input data 'data0_in' source selection:
'0': Constant '0'.
'1': chip_data[7:0].
'2': io_data_in[7:0].
'3': DATA.DATA MMIO register field.</description>
                <bitRange>[25:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DU_DATA1_SEL</name>
                <description>Data unit input data 'data1_in' source selection. Encoding is the same as for DU_DATA0_SEL.</description>
                <bitRange>[29:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DU_CTL</name>
            <description>Data unit component control register</description>
            <addressOffset>0xC4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DU_SIZE</name>
                <description>Size/width of the data unit data operands (in bits) is DU_SIZE+1. E.g., if DU_SIZE is 7, the width is 8 bits.</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DU_OPC</name>
                <description>Data unit opcode specifies the data unit operation:
'1': INCR
'2': DECR
'3': INCR_WRAP
'4': DECR_WRAP
'5': INCR_DECR
'6': INCR_DECR_WRAP
'7': ROR
'8': SHR
'9': AND_OR
'10': SHR_MAJ3
'11': SHR_EQL.
Otherwise: Undefined.</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DATA</name>
            <description>Data register</description>
            <addressOffset>0xF0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>Data unit input data source.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>TCPWM0</name>
      <description>Timer/Counter/PWM</description>
      <headerStructName>TCPWM</headerStructName>
      <baseAddress>0x40380000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>131072</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>3</dim>
          <dimIncrement>32768</dimIncrement>
          <name>GRP[%s]</name>
          <description>Group of counters</description>
          <addressOffset>0x00000000</addressOffset>
          <cluster>
            <dim>63</dim>
            <dimIncrement>128</dimIncrement>
            <name>CNT[%s]</name>
            <description>Timer/Counter/PWM Counter Module</description>
            <addressOffset>0x00000000</addressOffset>
            <register>
              <name>CTRL</name>
              <description>Counter control register</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xF0</resetValue>
              <resetMask>0xC73737FF</resetMask>
              <fields>
                <field>
                  <name>AUTO_RELOAD_CC0</name>
                  <description>Specifies switching of the CC0 and buffered CC0 values. This field has a function in TIMER, QUAD (QUAD_RANGE0_CMP, QUAD_RANGE1_CMP range modes), SR, PWM, PWM_DT and PWM_PR modes.
Timer, QUAD, SR modes:
'0': never switch.
'1': switch on a compare match 0 event.
PWM, PWM_DT, PWM_PR modes: 
'0: never switch.
'1': switch on a terminal count event with an actively pending switch event.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>AUTO_RELOAD_CC1</name>
                  <description>Specifies switching of the CC1 and buffered CC1 values. This field has a function in TIMER, QUAD (QUAD_RANGE0_CMP, QUAD_RANGE1_CMP range modes), SR, PWM, PWM_DT and PWM_PR modes.
Timer, QUAD, SR modes:
'0': never switch.
'1': switch on a compare match 1 event.
PWM, PWM_DT, PWM_PR modes: 
'0: never switch.
'1': switch on a terminal count event with an actively pending switch event.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>AUTO_RELOAD_PERIOD</name>
                  <description>Specifies switching of the PERIOD and buffered PERIOD values. This field has a function in PWM and PWM_DT modes.
'0': never switch.
'1': switch on a terminal count event with and actively pending switch event.

In QUAD mode, QUAD_RANGE0_CMP range mode this field is used to select the index / wrap-around capture function.
'0': Captures on index (reload) event. The counter value is copied to the PERIOD register on an index (reload) event.
'1': Captures when COUNTER equals 0 or 0xffff. The counter value is copied to the PERIOD register when COUNTER equals 0 or 0xffff.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>AUTO_RELOAD_LINE_SEL</name>
                  <description>Specifies switching of the LINE_SEL and LINE_BUFF_SEL values. This field has a function in PWM and PWM_PR modes.
'0': never switch.
'1': switch on a terminal count event with and actively pending switch event.</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CC0_MATCH_UP_EN</name>
                  <description>Enables / disables the compare match 0 event generation (COUNTER equals CC0 register) when counting up (STATUS.DOWN = 0) in CNT_UPDN1/2 mode.
'0': compare match 0 event generation disabled when counting up
'1': compare match 0 event generation enabled when counting up

This field has a function in PWM and PWM_DT modes only.</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CC0_MATCH_DOWN_EN</name>
                  <description>Enables / disables the compare match 0 event generation (COUNTER equals CC0 register) when counting down (STATUS.DOWN = 1) in CNT_UPDN1/2 mode.
'0': compare match 0 event generation disabled when counting down
'1': compare match 0 event generation enabled when counting down

This field has a function in PWM and PWM_DT modes only.</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CC1_MATCH_UP_EN</name>
                  <description>Enables / disables the compare match 1 event generation (COUNTER equals CC0 register) when counting up (STATUS.DOWN = 0) in CNT_UPDN1/2 mode.
'0': compare match 1 event generation disabled when counting up
'1': compare match 1 event generation enabled when counting up

This field has a function in PWM and PWM_DT modes only.</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CC1_MATCH_DOWN_EN</name>
                  <description>Enables / disables the compare match 1 event generation (COUNTER equals CC0 register) when counting down (STATUS.DOWN = 1) in CNT_UPDN1/2 mode.
'0': compare match 1 event generation disabled when counting down
'1': compare match 1 event generation enabled when counting down

This field has a function in PWM and PWM_DT modes only.</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PWM_IMM_KILL</name>
                  <description>Specifies whether the kill event immediately deactivates the 'dt_line_out' and 'dt_line_compl_out' signals or with the next module clock ('active count' pre-scaled 'clk_counter').
'0': synchronous kill activation. Deactivates the 'dt_line_out' and 'dt_line_compl_out' signals with the next module clock ('active count' pre-scaled 'clk_counter').
'1': immediate kill activation. Immediately deactivates the 'dt_line_out' and 'dt_line_compl_out' signals.

This field has a function in PWM, PWM_DT and PWM_PR modes only.</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PWM_STOP_ON_KILL</name>
                  <description>Specifies whether the counter stops on a kill events:
'0': kill event does NOT stop counter.
'1': kill event stops counter.

This field has a function in PWM, PWM_DT and PWM_PR modes only.</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PWM_SYNC_KILL</name>
                  <description>Specifies asynchronous/synchronous kill behavior:
'1': synchronous kill mode: the kill event disables the 'dt_line_out' and 'dt_line_compl_out' signals till the next terminal count event (synchronous kill). In synchronous kill mode, STOP_EDGE should  be RISING_EDGE.
'0': asynchronous kill mode: the kill event only disables the 'dt_line_out' and 'dt_line_compl_out' signals when present. In asynchronous kill mode, STOP_EDGE should be NO_EDGE_DET. 

This field has a function in PWM and PWM_DT modes only. This field is only used when PWM_STOP_ON_KILL is '0'.</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PWM_DISABLE_MODE</name>
                  <description>Specifies the behavior of the PWM outputs 'line_out' and 'line_compl_out' while the TCPWM counter is disabled (CTL.ENABLED='0') or stopped.

Note: The output signal of this selection can be further modified by the immediate kill logic and line_out polarity settings (CTRL.QUAD_ENCODING_MODE).</description>
                  <bitRange>[13:12]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>Z</name>
                      <description>The behavior is the same is in previous mxtcpwm (version 1).

When the counter is disabled the PWM outputs 'line_out' and 'line_compl_out' are NOT driven by the TCPWM. Instead the port default level configuration applies, e.g. 'Z' (high impedance).
Note: This is realized by driving the TCPWM output 'line_out_en' to 0.

When the counter is stopped upon a stop event the PWM outputs are deactivated (to the polarity defined by CTL.QUAD_ENCODING_MODE).</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RETAIN</name>
                      <description>When the counter is disabled the PWM outputs 'line_out' and 'line_compl_out' are driven by the TCPWM.
When the counter is disabled or stopped upon a stop event the PWM outputs are retained (keep their previous levels). 
While the counter is disabled or stopped the PWM outputs can be changed via LINE_SEL (when parameter GRP_SMC_PRESENT = 1).</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>L</name>
                      <description>When the counter is disabled the PWM outputs 'line_out' and 'line_compl_out' are driven by the TCPWM. 
When the counter is disabled or stopped upon a stop event the PWM output 'line_out' is driven as a fixed '0' and the PWM output 'line_compl_out' is driven as a fixed '1'.</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>H</name>
                      <description>When the counter is disabled the PWM outputs 'line_out' and 'line_compl_out' are driven by the TCPWM. 
When the counter is disabled or stopped upon a stop event the PWM output 'line_out' is driven as a fixed '1' and the PWM output 'line_compl_out' is driven as a fixed '0'.</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>UP_DOWN_MODE</name>
                  <description>Determines counter direction.

In QUAD mode this field acts as QUAD_RANGE_MODE field selecting between different counter range, reload value and compare / capture behavior.</description>
                  <bitRange>[17:16]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>COUNT_UP</name>
                      <description>Count up (to PERIOD). An overflow event is generated when the counter changes from a state in which COUNTER equals PERIOD. A terminal count event is generated when the counter changes from a state in which COUNTER equals PERIOD.</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>COUNT_DOWN</name>
                      <description>Count down (to '0'). An underflow event is generated when  the counter changes from a state in which COUNTER equals '0'. A terminal count event is generated when the counter changes from a state in which COUNTER equals '0'.</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>COUNT_UPDN1</name>
                      <description>Count up (to PERIOD), then count down (to '0'). An overflow event is generated when the counter changes from a state in which COUNTER equals PERIOD. An underflow event is generated when the counter changes from a state in which COUNTER equals '0'. A terminal count event is generated when the counter changes from a state in which COUNTER equals '0'.</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>COUNT_UPDN2</name>
                      <description>Count up (to PERIOD), then count down (to '0'). An overflow event is generated when the counter changes from a state in which COUNTER equals PERIOD. An underflow event is generated when the counter changes from a state in which COUNTER equals '0'. A terminal count event is generated when the counter changes from a state in which COUNTER equals '0' AND when the counter changes from a state in which COUNTER equals PERIOD (this counter direction can be used for PWM functionality with asymmetrical updates).</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>ONE_SHOT</name>
                  <description>When '0', counter runs continuous. When '1', counter is turned off by hardware when a terminal count event is generated.</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>QUAD_ENCODING_MODE</name>
                  <description>In QUAD mode this field selects the quadrature encoding mode (X1/X2/X4) or the Up / Down rotary counting mode.
In PWM, PWM_DT and PWM_PR modes, these two bits can be used to invert 'dt_line_out' and 'dt_line_compl_out'.  Inversion is the last step in generation of 'dt_line_out' and 'dt_line_compl_out'; i.e. a disabled output line 'dt_line_out' has the value QUAD_ENCODING_MODE[0] and a disabled output line 'dt_line_compl_out' has the value QUAD_ENCODING_MODE[1].</description>
                  <bitRange>[21:20]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>X1</name>
                      <description>X1 encoding (QUAD mode)
This encoding is identical with an up / down counting functionality of the following way: Rising edges of input phiA increment or decrement the counter depending on the state of input phiB (direction input).</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>X2</name>
                      <description>X2 encoding (QUAD mode)</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>X4</name>
                      <description>X4 encoding (QUAD mode)</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>UP_DOWN</name>
                      <description>Up / Down rotary counting mode. Input phiA increments the counter, input phiB decrements the counter. The trigger edge detection settings apply.</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>MODE</name>
                  <description>Counter mode.</description>
                  <bitRange>[26:24]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>TIMER</name>
                      <description>Timer mode</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD1</name>
                      <description>N/A</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CAPTURE</name>
                      <description>Capture mode</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>QUAD</name>
                      <description>Quadrature mode

Different encoding modes can be selected by QUAD_ENCODING_MODE including up/down count functionality.
Different counter range, reload value and capture behavior can be selected by QUAD_RANGE_MODE (overloaded field UP_DOWN_MODE).</description>
                      <value>3</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>PWM</name>
                      <description>Pulse width modulation (PWM) mode</description>
                      <value>4</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>PWM_DT</name>
                      <description>PWM with deadtime insertion mode</description>
                      <value>5</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>PWM_PR</name>
                      <description>Pseudo random pulse width modulation</description>
                      <value>6</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SR</name>
                      <description>Shift register mode.</description>
                      <value>7</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>DBG_FREEZE_EN</name>
                  <description>Specifies the counter behavior in debug mode.
'0': The counter operation continues in debug mode.
'1': The counter operation freezes in debug mode.</description>
                  <bitRange>[30:30]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ENABLED</name>
                  <description>Counter enable.
'0': counter disabled.
'1': counter enabled.
Counter static configuration information (e.g. CTRL.MODE, all TR_IN_SEL, TR_IN_EDGE_SEL, TR_PWM_CTRL and TR_OUT_SEL register fields) should only be modified when the counter is disabled. When a counter is disabled, command and status information associated to the counter is cleared by HW, this includes:
- the associated counter triggers in the CMD register are set to '0'.
- the counter's interrupt cause fields in counter's INTR register.
- the counter's status fields in counter's STATUS register..
- the counter's trigger outputs ('tr_out0' and tr_out1').
- the counter's line outputs ('line_out' and 'line_compl_out').</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>STATUS</name>
              <description>Counter status register</description>
              <addressOffset>0x4</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x20</resetValue>
              <resetMask>0xFFFF8FF1</resetMask>
              <fields>
                <field>
                  <name>DOWN</name>
                  <description>When '0', counter is counting up. When '1', counter is counting down. In QUAD mode, this field indicates the direction of the latest counter change: '0' when last incremented and '1' when last decremented.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TR_CAPTURE0</name>
                  <description>Indicates the actual level of the selected capture 0 trigger.</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TR_COUNT</name>
                  <description>Indicates the actual level of the selected count trigger.</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TR_RELOAD</name>
                  <description>Indicates the actual level of the selected reload trigger.</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TR_STOP</name>
                  <description>Indicates the actual level of the selected stop trigger.</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TR_START</name>
                  <description>Indicates the actual level of the selected start trigger.</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TR_CAPTURE1</name>
                  <description>Indicates the actual level of the selected capture 1 trigger.</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>LINE_OUT</name>
                  <description>Indicates the actual level of the PWM line output signal.</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>LINE_COMPL_OUT</name>
                  <description>Indicates the actual level of the complementary PWM line output signal.</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RUNNING</name>
                  <description>When '0', the counter is NOT running. When '1', the counter is running. 

This field is used to indicate that the counter is running after a start/reload event and that the counter is stopped after a stop event.
When a running counter operation is paused in debug state (see CTRL.DBG_PAUSE) then the RUNNING bit is still '1'.</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>DT_CNT_L</name>
                  <description>Generic 8-bit counter field. In PWM_DT mode, this counter is used for dead time insertion (8bit dead time counter or low byte of 16-bit dead time counter). 
In all other modes, this counter is used for pre-scaling the selected counter clock. PWM_DT mode can NOT use prescaled clock functionality.</description>
                  <bitRange>[23:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>DT_CNT_H</name>
                  <description>High byte of 16-bit dead time counter. In PWM_DT mode, this counter is used for dead time insertion.
In all other modes, this field has no effect.

Note: This field only exists when parameter GRP_AMC_PRESENT for advanced motor control is set to 1. Otherwise the dead time is only 8bit wide and the only the field DT_CNT_L is used as dead time counter.</description>
                  <bitRange>[31:24]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>COUNTER</name>
              <description>Counter count register</description>
              <addressOffset>0x8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>COUNTER</name>
                  <description>16-bit / 32-bit counter value. It is advised to not write to this field when the counter is running.</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>CC0</name>
              <description>Counter compare/capture 0 register</description>
              <addressOffset>0x10</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xFFFFFFFF</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>CC</name>
                  <description>In CAPTURE mode, captures the counter value. In other modes, compared to counter value.</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>CC0_BUFF</name>
              <description>Counter buffered compare/capture 0 register</description>
              <addressOffset>0x14</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xFFFFFFFF</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>CC</name>
                  <description>Additional buffer for counter CC register.</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>CC1</name>
              <description>Counter compare/capture 1 register</description>
              <addressOffset>0x18</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xFFFFFFFF</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>CC</name>
                  <description>In CAPTURE mode, captures the counter value. In other modes, compared to counter value.</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>CC1_BUFF</name>
              <description>Counter buffered compare/capture 1 register</description>
              <addressOffset>0x1C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xFFFFFFFF</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>CC</name>
                  <description>Additional buffer for counter CC1 register.</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PERIOD</name>
              <description>Counter period register</description>
              <addressOffset>0x20</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xFFFFFFFF</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>PERIOD</name>
                  <description>Period value: upper value of the counter. When the counter should count for n cycles, this field should be set to n-1.</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PERIOD_BUFF</name>
              <description>Counter buffered period register</description>
              <addressOffset>0x24</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xFFFFFFFF</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>PERIOD</name>
                  <description>Additional buffer for counter PERIOD register.

In PWM_PR mode PEROD_BUFF defines the LFSR polynomial. Each bit represents a tap of the shift register which can be feed back to the MSB via an XOR tree. 
Examples for GRP_CNT_WIDTH = 16: 
- Maximum length 16bit LFSR
  - polynomial x^16 + x^14 + x^13 + x^11 + 1
  - taps 0,2,3,5 -&gt; PERIOD = 0x002d
  - period is 2^16-1 = 65535 cycles
- Maximum length 8bit LFSR: 
  - polynomial x^8 + x^6 + x^5 + x^4 + 1
  - taps 8,10,11,12 (realized in 8 MSBs of 16bit LFSR)
  - period is 2^8-1 = 255 cycles

In SR mode PERIOD_BUFF defines which tap of the shift register generates the PWM output signals. For a delay of n cycles (from capture event to PWM output) the bit CNT_WIDTH-n should be set to '1'. For a shift register function only one tap should be use, i.e. a one-hot value must be written to PERIOD_BUFF. If multiple bits in PERIOD_BUFF are set then the taps are XOR combined.</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LINE_SEL</name>
              <description>Counter line selection register</description>
              <addressOffset>0x28</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x32</resetValue>
              <resetMask>0x77</resetMask>
              <fields>
                <field>
                  <name>OUT_SEL</name>
                  <description>Selects the source for the output signal 'line_out'. Default setting is the PWM signal 'line'. Other settings are useful for Stepper Motor Control.
This field has a function in PWM and PWM_PR modes only.

Note: The output signal of this selection can be further modified by the stop / kill logic and line_out polarity setting (CTRL.QUAD_ENCODING_MODE[0]).</description>
                  <bitRange>[2:0]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>L</name>
                      <description>fixed '0'</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>H</name>
                      <description>fixed '1'</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>PWM</name>
                      <description>PWM signal 'line'</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>PWM_INV</name>
                      <description>inverted PWM signal 'line'</description>
                      <value>3</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>Z</name>
                      <description>The output 'line_out' is not driven by the TCPWM. Instead the port default level configuration applies, e.g. 'Z' (high impedance).

Note: This is realized by driving the output 'line_out_en' to 0.</description>
                      <value>4</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD5</name>
                      <description>N/A</description>
                      <value>5</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD6</name>
                      <description>N/A</description>
                      <value>6</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD7</name>
                      <description>N/A</description>
                      <value>7</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>COMPL_OUT_SEL</name>
                  <description>Selects the source for the output signal 'line_compl_out'. Default setting is the inverted PWM signal 'line'. Other settings are useful for Stepper Motor Control.
This field has a function in PWM and PWM_PR modes only.

Note: The output signal of this selection can be further modified by the stop / kill logic and line_compl_out polarity setting (CTRL.QUAD_ENCODING_MODE[1]).</description>
                  <bitRange>[6:4]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>L</name>
                      <description>fixed '0'</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>H</name>
                      <description>fixed '1'</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>PWM</name>
                      <description>PWM signal 'line'</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>PWM_INV</name>
                      <description>inverted PWM signal 'line'</description>
                      <value>3</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>Z</name>
                      <description>The output 'line_compl_out' is not driven by the TCPWM. Instead the port default level configuration applies, e.g. 'Z' (high impedance).

Note: This is realized by driving the output 'line_compl_out_en' to 0.</description>
                      <value>4</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD5</name>
                      <description>N/A</description>
                      <value>5</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD6</name>
                      <description>N/A</description>
                      <value>6</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD7</name>
                      <description>N/A</description>
                      <value>7</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
              </fields>
            </register>
            <register>
              <name>LINE_SEL_BUFF</name>
              <description>Counter buffered line selection register</description>
              <addressOffset>0x2C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x32</resetValue>
              <resetMask>0x77</resetMask>
              <fields>
                <field>
                  <name>OUT_SEL</name>
                  <description>Buffer for LINE_SEL.OUT_SEL.
Can be exchanged with LINE_SEL.LINE_OUT_SEL on a terminal count event with an actively pending switch event.

This field has a function in PWM and PWM_PR modes only.</description>
                  <bitRange>[2:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>COMPL_OUT_SEL</name>
                  <description>Buffer for LINE_SEL.COMPL.OUT_SEL.
Can be exchanged with LINE_SEL.LINE_COMPL_OUT_SEL on a terminal count event with an actively pending switch event.

This field has a function in PWM and PWM_PR modes only.</description>
                  <bitRange>[6:4]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>DT</name>
              <description>Counter PWM dead time register</description>
              <addressOffset>0x30</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>DT_LINE_OUT_L</name>
                  <description>In PWM_DT mode, this field is used to determine the low byte of the dead time before activating the PWM line output signal 'line_out': amount of dead time cycles in the counter clock domain. 
In all other modes, the lower 3 bits of this field determine pre-scaling of the selected counter clock.

Note: This field determines the low byte of the 16-bit dead time before activating 'line_out' when parameter GRP_AMC_PRESENT for advanced motor control is set to 1. Otherwise the dead time is only 8 bit wide and the same dead time specified by this DT_LINE_OUT_L field is used before activating 'line_out' and 'line_compl_out'.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>DIVBY1</name>
                      <description>Divide by 1 (other-than-PWM_DT mode)</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>DIVBY2</name>
                      <description>Divide by 2 (other-than-PWM_DT mode)</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>DIVBY4</name>
                      <description>Divide by 4 (other-than-PWM_DT mode)</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>DIVBY8</name>
                      <description>Divide by 8 (other-than-PWM_DT mode)</description>
                      <value>3</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>DIVBY16</name>
                      <description>Divide by 16 (other-than-PWM_DT mode)</description>
                      <value>4</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>DIVBY32</name>
                      <description>Divide by 32 (other-than-PWM_DT mode)</description>
                      <value>5</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>DIVBY64</name>
                      <description>Divide by 64 (other-than-PWM_DT mode)</description>
                      <value>6</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>DIVBY128</name>
                      <description>Divide by 128 (other-than-PWM_DT mode)</description>
                      <value>7</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>DT_LINE_OUT_H</name>
                  <description>In PWM_DT mode, this field is used to determine the high byte of the dead time before activating the PWM line output signal 'line_out': amount of dead time cycles in the counter clock domain.
In all other modes, this field field has no effect.

Note: This field only exists when parameter GRP_AMC_PRESENT for advanced motor control is set to 1. Otherwise the dead time is only 8 bit wide and the same dead time specified by field DT_LINE_OUT_L is used before activating 'line_out' and 'line_compl_out'.</description>
                  <bitRange>[15:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DT_LINE_COMPL_OUT</name>
                  <description>In PWM_DT mode, this field is used to determine the dead time before activating the complementary PWM line output signal 'line_compl_out': amount of dead time cycles in the counter clock domain. 
In all other modes, this field field has no effect.

Note: This field only exists when parameter GRP_AMC_PRESENT for advanced motor control is set to 1. Otherwise the dead time is only 8 bit wide and the same dead time specified by field DT_LINE_OUT_L is used before activating 'line_out' and 'line_compl_out'.</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TR_CMD</name>
              <description>Counter trigger command register</description>
              <addressOffset>0x40</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3D</resetMask>
              <fields>
                <field>
                  <name>CAPTURE0</name>
                  <description>SW capture 0 trigger. When written with '1', a capture 0 trigger is generated and the HW sets the field to '0' when the SW trigger has taken effect. It should be noted that the HW operates on the counter frequency. If the counter is disabled through CTRL.ENABLED, the field is immediately set to '0'.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RELOAD</name>
                  <description>SW reload trigger. For HW behavior, see COUNTER_CAPTURE0 field.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>STOP</name>
                  <description>SW stop trigger. For HW behavior, see COUNTER_CAPTURE0 field.</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>START</name>
                  <description>SW start trigger. For HW behavior, see COUNTER_CAPTURE0 field.</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CAPTURE1</name>
                  <description>SW capture 1 trigger. For HW behavior, see COUNTER_CAPTURE0 field.</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TR_IN_SEL0</name>
              <description>Counter input trigger selection register 0</description>
              <addressOffset>0x44</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x100</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>CAPTURE0_SEL</name>
                  <description>Selects one of the up to 256 input triggers as a capture0 trigger. Input trigger 0 is always '0' and input trigger 1 is always '1'. If existing, the one-to-one trigger inputs 'tr_one_cnt_in' (different to each counter) are selected by setting 2 and above. The settings above are used for the general purpose trigger inputs 'tr_all_cnt_in' connected to all counters selected.
In the PWM, PWM_DT and PWM_PR modes this trigger is used to switch the values if the compare and period registers with their buffer counterparts.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>COUNT_SEL</name>
                  <description>Selects one of the 256 input triggers as a count trigger. 
In QUAD mode, this is the first phase (phi A). Default setting selects input trigger 1, which is always '1'.</description>
                  <bitRange>[15:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RELOAD_SEL</name>
                  <description>Selects one of the 256 input triggers as a reload trigger. 
In QUAD mode, this is the index or revolution pulse. In these modes, it will update the counter with 0x8000 (counter midpoint) or 0x0000 depending on the QUAD_RANGE_MODE.</description>
                  <bitRange>[23:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>STOP_SEL</name>
                  <description>Selects one of the 256 input triggers as a stop trigger. 
In PWM, PWM_DT and PWM_PR modes, this is the kill trigger. In these modes, the kill trigger is used to either temporarily block the PWM outputs (PWM_STOP_ON_KILL is '0') or stop the functionality (PWM_STOP_ON_KILL is '1'). For the PWM and PWM_DT modes, the blocking of the output signals can be  asynchronous (STOP_EDGE should be NO_EDGE_DET) in which case the blocking is as long as the trigger is '1' or synchronous (STOP_EDGE should be RISING_EDGE) in which case it extends till the next terminal count event.</description>
                  <bitRange>[31:24]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TR_IN_SEL1</name>
              <description>Counter input trigger selection register 1</description>
              <addressOffset>0x48</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>START_SEL</name>
                  <description>Selects one of the 256 input triggers as a start trigger. In QUAD mode, this is the second phase (phi B).</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CAPTURE1_SEL</name>
                  <description>Selects one of the 256 input triggers as a capture 1 trigger.</description>
                  <bitRange>[15:8]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TR_IN_EDGE_SEL</name>
              <description>Counter input trigger edge selection register</description>
              <addressOffset>0x4C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xFFF</resetValue>
              <resetMask>0xFFF</resetMask>
              <fields>
                <field>
                  <name>CAPTURE0_EDGE</name>
                  <description>A capture 0 event will copy the counter value into the CC0 register.</description>
                  <bitRange>[1:0]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>RISING_EDGE</name>
                      <description>Rising edge. Any rising edge generates an event.</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FALLING_EDGE</name>
                      <description>Falling edge. Any falling edge generates an event.</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>ANY_EDGE</name>
                      <description>Rising AND falling edge. Any odd amount of edges generates an event.</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>NO_EDGE_DET</name>
                      <description>No edge detection, use trigger as is.</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>COUNT_EDGE</name>
                  <description>A counter event will increase or decrease the counter by '1'.</description>
                  <bitRange>[3:2]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>RISING_EDGE</name>
                      <description>Rising edge. Any rising edge generates an event.</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FALLING_EDGE</name>
                      <description>Falling edge. Any falling edge generates an event.</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>ANY_EDGE</name>
                      <description>Rising AND falling edge. Any odd amount of edges generates an event.</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>NO_EDGE_DET</name>
                      <description>No edge detection, use trigger as is.</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>RELOAD_EDGE</name>
                  <description>A reload event will initialize the counter. When counting up, the counter is initialized to '0'. When counting down, the counter is initialized with PERIOD.</description>
                  <bitRange>[5:4]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>RISING_EDGE</name>
                      <description>Rising edge. Any rising edge generates an event.</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FALLING_EDGE</name>
                      <description>Falling edge. Any falling edge generates an event.</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>ANY_EDGE</name>
                      <description>Rising AND falling edge. Any odd amount of edges generates an event.</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>NO_EDGE_DET</name>
                      <description>No edge detection, use trigger as is.</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>STOP_EDGE</name>
                  <description>A stop event, will stop the counter; i.e. it will no longer be running. Stopping will NOT disable the counter.</description>
                  <bitRange>[7:6]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>RISING_EDGE</name>
                      <description>Rising edge. Any rising edge generates an event.</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FALLING_EDGE</name>
                      <description>Falling edge. Any falling edge generates an event.</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>ANY_EDGE</name>
                      <description>Rising AND falling edge. Any odd amount of edges generates an event.</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>NO_EDGE_DET</name>
                      <description>No edge detection, use trigger as is.</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>START_EDGE</name>
                  <description>A start event will start the counter; i.e. the counter will become running. Starting does NOT enable the counter. A start event will not initialize the counter whereas the reload event does.</description>
                  <bitRange>[9:8]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>RISING_EDGE</name>
                      <description>Rising edge. Any rising edge generates an event.</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FALLING_EDGE</name>
                      <description>Falling edge. Any falling edge generates an event.</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>ANY_EDGE</name>
                      <description>Rising AND falling edge. Any odd amount of edges generates an event.</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>NO_EDGE_DET</name>
                      <description>No edge detection, use trigger as is.</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>CAPTURE1_EDGE</name>
                  <description>A capture 1 event will copy the counter value into the CC1 register.</description>
                  <bitRange>[11:10]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>RISING_EDGE</name>
                      <description>Rising edge. Any rising edge generates an event.</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FALLING_EDGE</name>
                      <description>Falling edge. Any falling edge generates an event.</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>ANY_EDGE</name>
                      <description>Rising AND falling edge. Any odd amount of edges generates an event.</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>NO_EDGE_DET</name>
                      <description>No edge detection, use trigger as is.</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
              </fields>
            </register>
            <register>
              <name>TR_PWM_CTRL</name>
              <description>Counter trigger PWM control register</description>
              <addressOffset>0x50</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xFF</resetValue>
              <resetMask>0xFF</resetMask>
              <fields>
                <field>
                  <name>CC0_MATCH_MODE</name>
                  <description>Determines the effect of a compare match 0 event (COUNTER equals CC0 register) on the 'line_out' output signals.  Note that INVERT is especially useful for center aligned pulse width modulation.
To generate a duty cycle of 0 percent, the counter CC0 register should be set to '0'. For a 100 percent duty cycle, the counter CC0 register should be set to larger than the counter PERIOD register.</description>
                  <bitRange>[1:0]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>SET</name>
                      <description>Set to '1'</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CLEAR</name>
                      <description>Set to '0'</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>INVERT</name>
                      <description>Invert</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>NO_CHANGE</name>
                      <description>No Change</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>OVERFLOW_MODE</name>
                  <description>Determines the effect of a counter overflow event (COUNTER reaches PERIOD) on the 'line_out' output signals.</description>
                  <bitRange>[3:2]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>SET</name>
                      <description>Set to '1'</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CLEAR</name>
                      <description>Set to '0'</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>INVERT</name>
                      <description>Invert</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>NO_CHANGE</name>
                      <description>No Change</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>UNDERFLOW_MODE</name>
                  <description>Determines the effect of a counter underflow event (COUNTER reaches '0') on the 'line_out' output signals.</description>
                  <bitRange>[5:4]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>SET</name>
                      <description>Set to '1'</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CLEAR</name>
                      <description>Set to '0'</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>INVERT</name>
                      <description>Invert</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>NO_CHANGE</name>
                      <description>No Change</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>CC1_MATCH_MODE</name>
                  <description>Determines the effect of a compare match 1 event (COUNTER equals CC1 register) on the 'line_out' output signals.</description>
                  <bitRange>[7:6]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>SET</name>
                      <description>Set to '1'</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CLEAR</name>
                      <description>Set to '0'</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>INVERT</name>
                      <description>Invert</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>NO_CHANGE</name>
                      <description>No Change</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
              </fields>
            </register>
            <register>
              <name>TR_OUT_SEL</name>
              <description>Counter output trigger selection register</description>
              <addressOffset>0x54</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x32</resetValue>
              <resetMask>0x77</resetMask>
              <fields>
                <field>
                  <name>OUT0</name>
                  <description>Selects one of the internal events to generate the output trigger 0. Default setting selects the terminal count event.</description>
                  <bitRange>[2:0]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>OVERFLOW</name>
                      <description>Overflow event</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>UNDERFLOW</name>
                      <description>Underflow event</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>TC</name>
                      <description>Terminal count event (default selection)</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CC0_MATCH</name>
                      <description>Compare match 0 event</description>
                      <value>3</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CC1_MATCH</name>
                      <description>Compare match 1 event</description>
                      <value>4</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>LINE_OUT</name>
                      <description>PWM output signal 'line_out'</description>
                      <value>5</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD6</name>
                      <description>N/A</description>
                      <value>6</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>Disabled</name>
                      <description>Output trigger disabled.</description>
                      <value>7</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>OUT1</name>
                  <description>Selects one of the internal events to generate the output trigger 1. Default setting selects the compare match 0 event.</description>
                  <bitRange>[6:4]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>OVERFLOW</name>
                      <description>Overflow event</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>UNDERFLOW</name>
                      <description>Underflow event</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>TC</name>
                      <description>Terminal count event</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CC0_MATCH</name>
                      <description>Compare match 0 event (default selection)</description>
                      <value>3</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CC1_MATCH</name>
                      <description>Compare match 1 event</description>
                      <value>4</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>LINE_OUT</name>
                      <description>PWM output signal 'line_out'</description>
                      <value>5</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD6</name>
                      <description>N/A</description>
                      <value>6</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>Disabled</name>
                      <description>Output trigger disabled.</description>
                      <value>7</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
              </fields>
            </register>
            <register>
              <name>INTR</name>
              <description>Interrupt request register</description>
              <addressOffset>0x70</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7</resetMask>
              <fields>
                <field>
                  <name>TC</name>
                  <description>Terminal count event. Set to '1', when event is detected. Write with '1' to clear bit.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CC0_MATCH</name>
                  <description>Counter matches CC0 register event. Set to '1', when event is detected. Write with '1' to clear bit.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CC1_MATCH</name>
                  <description>Counter matches CC1 register event. Set to '1', when event is detected. Write with '1' to clear bit.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>INTR_SET</name>
              <description>Interrupt set request register</description>
              <addressOffset>0x74</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7</resetMask>
              <fields>
                <field>
                  <name>TC</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CC0_MATCH</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CC1_MATCH</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>INTR_MASK</name>
              <description>Interrupt mask register</description>
              <addressOffset>0x78</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7</resetMask>
              <fields>
                <field>
                  <name>TC</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CC0_MATCH</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CC1_MATCH</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>INTR_MASKED</name>
              <description>Interrupt masked request register</description>
              <addressOffset>0x7C</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7</resetMask>
              <fields>
                <field>
                  <name>TC</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>CC0_MATCH</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>CC1_MATCH</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
          </cluster>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>EVTGEN0</name>
      <description>Event generator</description>
      <headerStructName>EVTGEN</headerStructName>
      <baseAddress>0x403F0000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>4096</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTL</name>
          <description>Control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>IP enable:
'0': Disabled. All non-retention registers (command and status registers) are reset to their default value when the IP is disabled. All retention registers retain their value when the IP is disabled.
'1': Enabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>COMP0_STATUS</name>
          <description>Comparator structures comparator 0 status</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>COMP0_OUT</name>
              <description>Active comparator 'comp0_out[]' outputs.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>COMP1_STATUS</name>
          <description>Comparator structures comparator 1 status</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>COMP1_OUT</name>
              <description>DeepSleep comparator 'comp1_out_lf[]' outputs (synchronized from clk_lf to the IP clock).</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>COUNTER_STATUS</name>
          <description>Counter status</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Active counter validity:
'0': Invalid.
'1': Valid.

The COUNTER register field INT32 is only valid when VALID is '1'. 

The COUNTER_STATUS and COUNTER registers are non-retention registers; i.e. the COUNTER_STATUS and COUNTER registers are reset during DeepSleep power mode. After entering the Active power mode, the Active counter is initialized with the DeepSleep counter. This initialization may take up to 1 clk_lf cycle.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>COUNTER</name>
          <description>Counter</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>INT32</name>
              <description>Active counter 'counter_int[31:0]' on clk_ref_div.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RATIO_CTL</name>
          <description>Ratio control</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC0070000</resetMask>
          <fields>
            <field>
              <name>DYNAMIC_MODE</name>
              <description>Weighted average calculation (only used when DYNAMIC is '1'):
'0': new RATIO value = (RATIO + measurement + 1) / 2.
'1': new RATIO value = (3*RATIO + measurement + 2) / 4.
'2': new RATIO value = (7*RATIO + measurement + 4) / 8.
'3': new RATIO value = (15*RATIO + measurement + 8) / 16.
'4': new RATIO value = (31*RATIO + measurement + 16) / 32.
'5': new RATIO value = (63*RATIO + measurement + 32) / 64.
'6': new RATIO value = (127*RATIO + measurement + 64) / 128.
'7': new RATIO value = (255*RATIO + measurement + 128) / 256.

Note: 'measurement' (integer component only) is defined as: 256 * 'number of measured clk_ref_div cycles per clk_lf cycle'. The RATIO value (integer and fractional component) is defined as: 256*RATIO.INT16 + RATIO.FRAC8 (RATIO.INT16 = RATIO &gt;&gt; 8 and RATIO.FRAC8 = RATIO  percent 256).</description>
              <bitRange>[18:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DYNAMIC</name>
              <description>Specifies if RATIO_CTL.VALID and RATIO are under SW or HW control:
'0': SW control.
'1: HW control. Auto calibration is used to derive the RATIO value. HW measures the number of clk_ref_div cycles per clk_lf cycle. This measurement is combined with the current ratio value to calculate a new ratio value.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VALID</name>
              <description>Ratio value valid:
'0': Invalid.
'1': Valid.

The RATIO register fields INT16 and FRAC8 are only valid when VALID is '1'.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RATIO</name>
          <description>Ratio</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>FRAC8</name>
              <description>Fractional component of ratio value.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT16</name>
              <description>Integer component of ratio value.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>REF_CLOCK_CTL</name>
          <description>Reference clock control</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>INT_DIV</name>
              <description>Divider control for clk_ref_div:
'0': Divide by 1.
...
'255': Divide by '256'.

Fclk_ref_div = Fclk_ref / (INT_DIV + 1)</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR</name>
          <description>Interrupt</description>
          <addressOffset>0x700</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>COMP0</name>
              <description>This interrupt cause field is activated (HW sets the field to '1') when a comparator 0 event is generated (Active counter 'counter_int[31:0]' becomes greater or equal to COMP0.INT[31:0]).</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SET</name>
          <description>Interrupt set</description>
          <addressOffset>0x704</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>COMP0</name>
              <description>SW writes a '1' to this field to set the corresponding field in the INTR register.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASK</name>
          <description>Interrupt mask</description>
          <addressOffset>0x708</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>COMP0</name>
              <description>Mask bit for corresponding field in the INTR register.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASKED</name>
          <description>Interrupt masked</description>
          <addressOffset>0x70C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>COMP0</name>
              <description>Logical and of corresponding INTR and INTR_MASK fields.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_DPSLP</name>
          <description>DeepSleep interrupt</description>
          <addressOffset>0x710</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>COMP1</name>
              <description>This interrupt cause field is activated (HW sets the field to '1') when a comparator 1 event is generated (DeepSleep counter 'counter_int_lf[31:0]' becomes greater or equal to COMP1.INT[31:0]).</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_DPSLP_SET</name>
          <description>DeepSleep interrupt set</description>
          <addressOffset>0x714</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>COMP1</name>
              <description>SW writes a '1' to this field to set the corresponding field in the INTR register.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_DPSLP_MASK</name>
          <description>DeepSleep interrupt mask</description>
          <addressOffset>0x718</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>COMP1</name>
              <description>Mask bit for corresponding field in the INTR register.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_DPSLP_MASKED</name>
          <description>DeepSleep interrupt masked</description>
          <addressOffset>0x71C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>COMP1</name>
              <description>Logical and of corresponding INTR and INTR_MASK fields.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>11</dim>
          <dimIncrement>32</dimIncrement>
          <name>COMP_STRUCT[%s]</name>
          <description>Comparator structure</description>
          <addressOffset>0x00000800</addressOffset>
          <register>
            <name>COMP_CTL</name>
            <description>Comparator control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80010003</resetMask>
            <fields>
              <field>
                <name>COMP0_EN</name>
                <description>Active comparator (COMP0) enable:
'0': Disabled. The comparator output 'comp0_out' is '0'.
'1': Enabled.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>COMP1_EN</name>
                <description>DeepSleep comparator (COMP1) enable:
'0': Disabled. The comparator output 'comp1_out_lf' is '0'.
'1': Enabled.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TR_OUT_EDGE</name>
                <description>Specifies the 'tr_out' output trigger:
'0': The trigger is a level sensitive trigger. The Active comparator output ('comp0_out') is reflected on 'tr_out'.
'1': The trigger is an edge sensitive trigger. Activation of the Active comparator output (rising edge on 'comp0_out') results in a two cycle '1'/high pulse on 'tr_out'.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED</name>
                <description>Comparator structure enable:
'0': Disabled.
'1': Enabled.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>COMP0</name>
            <description>Comparator 0 (Active functionality)</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>INT32</name>
                <description>This value is a 32-bit unsigned integer in the range [0, 2^32-1]. The comparator 'comp0_out' output is activated when the Active counter 'counter_int[31:0]' becomes greater or equal to COMP0.

Note: SW must ensure that COMP_CTL.COMP_EN[0] is '0' when COMP0 is written.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>COMP1</name>
            <description>Comparator 1 (DeepSleep functionality)</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>INT32</name>
                <description>This value is a 32-bit unsigned integer in the range [0, 2^32-1]. The comparator 'comp1_out_lf' output is activated when the DeepSleep counter 'counter_int_lf[31:0]' becomes greater or equal to COMP1.

Note: SW must ensure that COMP_CTL.COMP_EN[1] is '0' when COMP1 is written.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>LIN0</name>
      <description>LIN</description>
      <headerStructName>LIN</headerStructName>
      <baseAddress>0x40500000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>ERROR_CTL</name>
          <description>Error control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80EF001F</resetMask>
          <fields>
            <field>
              <name>CH_IDX</name>
              <description>Specifies the channel index of the channel to which HW  injected channel transmitter errors applies.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_SYNC_ERROR</name>
              <description>The synchronization field is changed from 0x55 to 0x00.

At the receiver, this should result in INTR.RX_HEADER_SYNC_ERROR activation.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_SYNC_STOP_ERROR</name>
              <description>The synchronization field STOP bits are inverted to '0'.

At the receiver, this should result in INTR.RX_HEADER_SYNC_ERROR or INTR.RX_HEADER_FRAME_ERROR activation.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_PARITY_ERROR</name>
              <description>In LIN mode, the PID parity bit P[1] is inverted from !(ID[5] ^ ID[4] ^ ID[3] ^ ID[1]) to (ID[5] ^ ID[4] ^ ID[3] ^ ID[1]).

At the receiver, this should result in INTR.RX_HEADER_PARITY_ERROR activation.

In UART mode, a data field's parity bit is inverted.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_PID_STOP_ERROR</name>
              <description>The PID field STOP bits are inverted to '0'.

At the receiver, this should result in INTR.RX_HEADER_FRAME_ERROR activation.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_DATA_STOP_ERROR</name>
              <description>The data field STOP bits are inverted to '0'.

At the receiver, this should result in INTR.RX_RESPONSE_FRAME_ERROR activation.

Note: Used in UART mode.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_CHECKSUM_ERROR</name>
              <description>The checksum field is inverted.

At the receiver, this should result in INTR.RX_RESPONSE_CHECKSUM_ERROR activation.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_CHECKSUM_STOP_ERROR</name>
              <description>The checksum field STOP bits are inverted to '0'.

At the receiver, this should result in INTR.RX_RESPONSE_FRAME_ERROR activation.</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>Error injection enable:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TEST_CTL</name>
          <description>Test control</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x8001001F</resetMask>
          <fields>
            <field>
              <name>CH_IDX</name>
              <description>Specifies the channel index of the channel to which test applies. The channel IO signals of channel indices CH_IDX and CH_NR-1 are connected as specified by MODE. CH_IDX should be in the range [0, CH_NR-2], as channel index CH_NR-1 is always involved in test and cannot be connected to itself. The test mode allows BOTH of the two connected channels to be tested.

Note: this testing functionality simplifies SW development, but may also be used in the field to verify correct channel functionality.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>Test mode:
'0': Partial disconnect from IOSS. This mode's isolation allows for device test without relying on an external LIN transceiver. The IOSS 'tx' IO cell can be used to observe messages outside of the device.
- tx_in[CH_IDX] = IOSS lin_tx_in[CH_IDX].
- tx_in[CH_NR-1] = IOSS lin_tx_in[CH_IDX].
- rx_in[CH_IDX] = IOSS lin_tx_in[CH_IDX].
- rx_in[CH_NR-1] = IOSS lin_tx_in[CH_IDX].
- lin_tx_out[CH_IDX] = tx_out[CH_IDX] &amp; tx_out[CH_NR-1].
- lin_tx_out[CH_NR-1] = tx_out[CH_IDX] &amp; tx_out[CH_NR-1].

'1': Full disconnect from IOSS (the IOSS/HSIOM should disconnect 'tx_out' from the 'tx' IO cell). This mode's isolation allows for device test without effecting an operational LIN cluster.
- tx_in[CH_IDX] = lin_tx_out[CH_IDX].
- tx_in[CH_NR-1] = lin_tx_out[CH_IDX].
- rx_in[CH_IDX] = lin_tx_out[CH_IDX].
- rx_in[CH_NR-1] = lin_tx_out[CH_IDX].
- lin_tx_out[CH_IDX] = tx_out[CH_IDX] &amp; tx_out[CH_NR-1].
- lin_tx_out[CH_NR-1] = tx_out[CH_IDX] &amp; tx_out[CH_NR-1].</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>Test enable:
'0': Disabled. Functional mode.
- tx_in[CH_IDX] = IOSS lin_tx_in[CH_IDX].
- tx_in[CH_NR-1] = IOSS lin_tx_in[CH_NR-1].
- rx_in[CH_IDX] = IOSS lin_rx_in[CH_IDX].
- rx_in[CH_NR-1] = IOSS lin_rx_in[CH_NR-1].
- lin_tx_out[CH_IDX] = tx_out[CH_IDX].
- lin_tx_out[CH_NR-1] = tx_out[CH_NR-1].
'1': Enabled. Test mode, specific test mode is specified by MODE.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>8</dim>
          <dimIncrement>256</dimIncrement>
          <name>CH[%s]</name>
          <description>LIN channel structure</description>
          <addressOffset>0x00008000</addressOffset>
          <register>
            <name>CTL0</name>
            <description>Control 0</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x400C0101</resetValue>
            <resetMask>0xF91F0313</resetMask>
            <fields>
              <field>
                <name>STOP_BITS</name>
                <description>STOP bit periods:
'0': 1/2 bit period.
'1': 1 bit period.
'2': 1 1/2 bit period.
'3': 2 bit periods.


In LIN mode, this field should be set to '1' (the default value) or '3'. 

In UART mode, theis field can be programmed as desired.

Note: receiver STOP bit frame errors can only be detected if the number of STOP bit periods is 1 or more bit period.</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>AUTO_EN</name>
                <description>LIN transceiver auto enable:
'0': Disabled.
'1': Enabled. The TX_RX_STATUS.EN_OUT field is controlled by HW.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BREAK_DELIMITER_LENGTH</name>
                <description>In LIN mode, this field specifies the break delimiter length:
(used in header transmission, not used in header reception).
'0': 1 bit period.
'1': 2 bit periods (default value).
'2': 3 bit periods.
'3': 4 bit periods.

In UART mode, this field specifies the data field size:
'0': 5 bit data field.
'1': 6 bit data field.
'2': 7 bit data field.
'3': 8 bit data field.
When the data field size is less than 8 bits, the most siginficant (unused) bits of the DATAx.DATAy[7:0] fields should be set to '0' for the transmitter.</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BREAK_WAKEUP_LENGTH</name>
                <description>Break/wakeup length (minus 1) in bit periods:
'0': 1 bit period.
...
'10': 11 bit periods (break length for slave nodes)
...
'12': 13 bit periods (break length for master nodes)
...
'30': 31 bit periods.
'31': Illegal (should NOT be used!!!)

This field is used for transmission/reception of BOTH break and wakeup signals. Note that these functions are mutually exclusive:
- When CMD.TX_HEADER is '1', the field specifies the transmitted break field.
- When CMD.TX_WAKEUP is '1', the field specifies the transmitted wakeup field.
- When CMD.RX_HEADER is '1', the field specifies the to be received break field.
- Otherwise, the field specifies the to be received wakeup field.

Per the standard, the master wakeup duration is between 250 us and 5 ms. To support uncalibrated slaves, a slave has a detection threshold of 150 us (3 bit periods at 20 kbps). After transmission of a break or wakeup signal, the INTR.TX_BREAK_WAKEUP_DONE interrupt cause is activated. After reception of a wakeup signal, the INTR.RX_BREAK_WAKEUP_DONE interrupt cause is activated.

To specify longer wakeup signals in terms of absolute time (us/ms rather than bit periods), the associated PERI clock divider value can be (temporarily) increased to make the LIN bit period longer.

Note: entering bus sleep mode is achieved with the 'go-to-sleep' command.</description>
                <bitRange>[20:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MODE</name>
                <description>Mode of operation:
'0': LIN mode.
'1': UART mode.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>LIN</name>
                    <description>LIN mode.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>UART</name>
                    <description>UART mode.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BIT_ERROR_IGNORE</name>
                <description>Specifies behavior on a detected bit error during header or response transmission:
'0': Message transfer is aborted.
'1': Message transfer is NOT aborted.

Note: this field does NOT effect the reporting of the bit error through INTR/STATUS.TX_HEADER/RESPONSE_BIT_ERROR; i.e. bit errors are always reported.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PARITY</name>
                <description>Parity mode:
'0': Even parity: even number of '1' bits (including parity).
'1': Odd parity.

Note: Used in UART mode only.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PARITY_EN</name>
                <description>Parity generation enable:
'0': Disabled. No parity bit is transferred.
'1': Enabled. The parity bit is transferred after the last (most siginficant) data field bit.

Note: Used in UART mode only.</description>
                <bitRange>[29:29]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FILTER_EN</name>
                <description>RX filter (for 'lin_rx_in'):
'0': No filter.
'1': Median 3 (default value) operates on the last three 'lin_rx_in' values. The sequences '000', '001', '010' and '100' result in a filtered value '0'. The sequences '111', '110', '101' and '011' result in a filtered value '1'.</description>
                <bitRange>[30:30]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED</name>
                <description>Channel enable:
'0': Disabled. If a channel is disabled, all non-retained MMIO registers (e.g. the CMD, STATUS, and INTR registers) have their fields reset to their default value.
'1': Enabled.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CTL1</name>
            <description>Control 1</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3000000</resetMask>
            <fields>
              <field>
                <name>DATA_NR</name>
                <description>Number of data fields (minus 1) in the response (not including the checksum):
'0': 1 data field.
'1': 2 data fields.
...
'7': 8 data fields.

Note: master and slave nodes need to agree upon the number of data fields before message transfer.
In RX_RESPONSE case, When PID (header) is received, firmware has the time of one response data byte, to modify CTL1.DATA_NR.</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CHECKSUM_ENHANCED</name>
                <description>Checksum mode:
'0': Classic mode. PID field is NOT included in the checksum calculation.
'1': Enhanced mode. PID field is included in the checksum calculation. This mode requires special attention when the master node transmits the header and a (different) slave node transmits the response: the slave node will use the calculated partial checksum over the received PID field as a starting point for the calculation over the to be transmitted data fields.

Note: If the frame identifier ID[5:0] is 0x3c or 0x3d, the classic mode will ALWAYS be used for transmisssion and assumed for reception, independent of the CHECKSUM_ENHANCED value.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FRAME_TIMEOUT</name>
                <description>Specifies the maximum allowed length (timeout value) for a frame, frame header or frame response in bit periods. The LIN specification prescribes to set the maximum length to 1.4x the nominal length (Theader_max = 1.4 x Theader_nom and Tresponse_max = 1.4 x Tresponse_nom). The nominal header length Theader_nom is 34 bit periods and the nominal response length Tresponse_nom is 10 * (data_nr + 1) bit periods (data_nr is the number of data fields) 

Note: the LIN specification specifies the following: 'Tools and tests shall check the Tframe_max (= Theader_max + Tresponse_max). Nodes shall not check this time. The receiving node of the frame shall accept the frame up to the next frame slot (i.e. next break field), even if it is longer then Tframe_max).'</description>
                <bitRange>[23:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FRAME_TIMEOUT_SEL</name>
                <description>Specifies the frame timeout mode:
'0': No timeout functionality (default value).
'1': Frame mode: detects timeout from the start of break field to checksum field STOP bits (inclusive). The minimum FRAME_TIMEOUT value is 34+20 bit periods (header and a response with 1 data field).
'2': Frame header mode: detects timeout from the start of break field to PID field STOP bits (inclusive). The minimum FRAME_TIMEOUT value is 34 bit periods (header).
'3': Frame response mode: detects timeout from the PID field STOP bits (exclusive) to checksum field STOP bits (the response space is included in the frame response). The minimum FRAME_TIMEOUT value is 20 bit periods (response with 1 data field).</description>
                <bitRange>[25:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>STATUS</name>
            <description>Status</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F03333F</resetMask>
            <fields>
              <field>
                <name>DATA_IDX</name>
                <description>Number of transferred data and checksum fields in the response (also acts as an index/address into response data field and checksum field registers (DATA0, DATA1, PID_CHECKSUM)) :
'0': No data fields transferred.
'1': Data field 1 transferred.
...
'7': Data fields 1, 2, 3, ... and 7 transferred.
'8':  Data fields 1, 2, 3, ... and 8 transferred.
'9': Data fields 1, 2, 3, ..., 8 and checksum field transferred.
'10'-'15': Unused.

Set to '0' on the start of a TX_HEADER or RX_HEADER command.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>HEADER_RESPONSE</name>
                <description>Frame header / response identifier (only valid when TX_BUSY or RX_BUSY is '1'):
'0': Frame header being transferred.
'1': Frame response being transffered.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_DATA0_FRAME_ERROR</name>
                <description>Frame response, first data field frame error. HW sets this field to '1'  when the received STOP bits of the first response data field have an unexpected value (only after a RX_HEADER command), and this data byte is 0x00. HW clears this field to '0' at the falling edge of SYNC start bit (after INTR.RX_HEADER_BREAK_WAKEUP_DONE). This field is used together with INTR.RX_RESPONSE_FRAME_ERROR to distinguish 'no response', 'error response' and 'correct response' scenarios.

Note: The ongoing message transfer is NOT aborted.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TX_BUSY</name>
                <description>Transmitter busy.
- Set to '1' on the start of the following commands: TX_HEADER, TX_RESPONSE, TX_WAKEUP.
- Set to '0' on successful completion of previous commands or when an error is detected.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_BUSY</name>
                <description>Receiver busy.
- Set to '1' on the start of the following commands: RX_HEADER, RX_RESPONSE.
   in RX_HEADER case, set at Break filed rising edge.
   in RX_RESPONSE case, set at the start bit falling edge in the first response data byte.

- Set to '0' on successful completion of previous commands or when an error is detected.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TX_DONE</name>
                <description>Transmitter done:
- Set to '0' on the start of a new command.
- Set to '1' on successful completion of the following commmand sequences (if CTL.AUTO_EN is '1', this includes the 4-bit period external transceiver disable post-amble):
- TX_HEADER.
- TX_HEADER, TX_RESPONSE.
- RX_HEADER, TX_RESPONSE.
- TX_WAKEUP.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_DONE</name>
                <description>Receiver done:
- Set to '0' on the start of a new command.
- Set to '1' on successful completion of the following commmand sequences (if CTL.AUTO_EN is '1', this includes the 4-bit period external transceiver disable post-amble):
- RX_HEADER, RX_RESPONSE.
- TX_HEADER, RX_RESPONSE.</description>
                <bitRange>[13:13]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TX_HEADER_BIT_ERROR</name>
                <description>Copy of INTR.TX_HEADER_BIT_ERROR.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TX_RESPONSE_BIT_ERROR</name>
                <description>Copy of INTR.TX_RESPONSE_BIT_ERROR.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_HEADER_FRAME_ERROR</name>
                <description>Copy of INTR.RX_HEADER_FRAME_ERROR.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_HEADER_SYNC_ERROR</name>
                <description>Copy of INTR.RX_HEADER_SYNC_ERROR.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_HEADER_PARITY_ERROR</name>
                <description>Copy of INTR.RX_HEADER_PARITY_ERROR.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_RESPONSE_FRAME_ERROR</name>
                <description>Copy of INTR.RX_RESPONSE_FRAME_ERROR.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_RESPONSE_CHECKSUM_ERROR</name>
                <description>Copy of INTR.RX_RESPONSE_CHECKSUM_ERROR.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CMD</name>
            <description>Command</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x307</resetMask>
            <fields>
              <field>
                <name>TX_HEADER</name>
                <description>SW sets this field to '1' to transmit a header. HW sets this field to '0' on successful completion of ANY of the following legal command sequences (also set to '0' when an error is detected):
- TX_HEADER
- TX_HEADER, TX_RESPONSE.
- TX_HEADER, RX_RESPONSE.
- RX_HEADER, TX_RESPONSE.
- RX_HEADER, RX_RESPONSE.
- TX_WAKEUP.

The header is transmitted when the PID field STOP bits are transmitted (INTR.TX_HEADER_DONE).

HW sets this field to '1', when the 'tr_cmd_tx_header' input trigger is activated. This allows for time triggered LIN message transfer. HW driven time triggered transfer eliminates the jitter that is typically associated with SW driven transfer.

In UART mode, a single data field (DATA0.DATA1) is transmitted.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_RESPONSE</name>
                <description>SW sets this field to '1' to transmit a response. HW sets this field to '0' on successful completion of ANY of the legal command sequences (also set to '0' when an error is detected).

The reponse is transmitted when the checksum field STOP bits are transmitted (INTR.TX_RESPONSE_DONE).</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_WAKEUP</name>
                <description>SW sets this field to '1' to transmit a wakeup signal. HW sets this field to '0' on successful completion of ANY of the legal command sequences (also set to '0' when an error is detected).

The command generates CTL.BREAK_WAKEUP_LENGTH bit periods in the dominant state (low/'0') and transitions to the recessive state (high/'1') (INTR.TX_WAKEUP_DONE).</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER</name>
                <description>SW sets this field to '1' to receive a header. HW sets this field to '0' on successful completion of the ANY of the legal command sequences (NOT set to '0' when an error is detected in LIN mode).

The header is received when the PID field STOP bits are received (INTR.RX_HEADER_DONE).

Typically, a slave node SW sets both RX_HEADER and RX_RESPONSE to '1', anticipating a transfer of a response from the master node to this slave node. After receipt of the header PID field (INTR.RX_HEADER_PID_DONE is activated), the slave node may decide to set TX_RESPONSE to '1' (which has a higher priority than RX_RESPONSE) to transmit a response.

the Break detection is performed regardless of CMD.RX_HEADER.
INTR.RX_BREAK_WAKEUP_DONE will trigger at LIN_RX rising edge, when the low pulse meet CTL0.BREAK_WAKEUP_LENGTH. when Break is detected, HW check CMD.RX_HEADER before entering SYNC byte processing state. when RX_HEADER is cleared, SW has at least 11 bit times to set RX_HEADER again, before next Break is detected (RX_BREAK_WAKEUP_DONE). in this case, there is no gap, Break will never be missed.


In UART mode, a single data field in received (in DATA0.DATA1). HW set this field to '0' when the data field is received, or when an error is detected.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_RESPONSE</name>
                <description>SW sets this field to '1' to receive a response. HW sets this field to '0' on successful completion of ANY of the legal command sequences (NOT set to '0' when an error is detected).

The response is received when the checksum field STOP bits are received (INTR.RX_RESPONSE_DONE).</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TX_RX_STATUS</name>
            <description>TX/RX status</description>
            <addressOffset>0x60</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x5000000</resetValue>
            <resetMask>0x5000000</resetMask>
            <fields>
              <field>
                <name>SYNC_COUNTER</name>
                <description>Synchronization counter in LIN channel clock periods. After the receipt of a synchronization field, this fields reflects the duration of the synchronization field. Ideally, SYNC_COUNTER = 8*16 = 128 (the synchronization fiels consists of eight bit period of 16 LIN channel clock periods each).
- If SYNC_COUNTER is less than 128, the LIN channel clock is too slow and the PERI/PCLK divider value should be decreased.
- If SYNC_COUNTER is greater than 128, the LIN channel clock is too fast and the PERI/PCLK divider value should be increased.

The biggest master-slave clock discrepancy occurs when the master is slow and the slave is fast or vice versa. At a 0.5 percent master inaccuracy and a 14 percent slave inaccuracy, this results in the extreme synchronization values of (.86 * 128) / 1.005 = 109.5 and (1.14 *128) / 0.995 = 146.6. We add a little margin for a valid range of [106, 152].

Note: Only slave nodes with imprecise clocks require clock resychronization. Master and slave nodes with precise clocks do NOT require clock resynchronization.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TX_IN</name>
                <description>LIN transmitter input ('tx_in', 'lin_tx_in' in functional mode). TX_IN and RX_IN can be used to determine a wakeup source. Note that wakeup source detection relies on the external transceiver functionality.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_IN</name>
                <description>LIN receiver input ('rx_in', 'lin_rx_in' in functional mode).</description>
                <bitRange>[17:17]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TX_OUT</name>
                <description>LIN transmitter output ('tx_out', 'lin_tx_out').</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EN_OUT</name>
                <description>LIN transceiver enable ('en_out', 'lin_en_out'). This field controls the enable (or low active sleep enable) of the external transceiver:
'0': Disabled.
'1': Enabled.

If CTL.AUTO_EN is '0', SW controls this field to enable the external transceiver. If CTL.AUTO_EN is '1', HW controls this field to enable the external transceiver:
- Before a legal command sequence, HW sets this field to '1', if it is '0'. The start of the command sequence is effectively postponed by a 4-bit period preamble.
- After a legal command sequence, HW clears this field to '0'. The end of the command sequence is effectively postponed by a 4-bit period postamble.

Note: external transceivers require a 'power up' or 'power down' period of 1 or 2 bit periods, so a 4-bit period suffices for all known transceivers.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PID_CHECKSUM</name>
            <description>PID and checksum</description>
            <addressOffset>0x80</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>PID</name>
                <description>Header protected identifier (PID). 
- Bits 5 downto 0: frame identifier ID[5:0].
Frame identifier 0x3c is for a 'master request' frame, 0x3d is for a 'slave response' frame, 0x3e and 0x3f are for future LIN enhancements. Frame identifier ID[5:4] is optionally used for length control; i.e. specifies the number of response data fields.
- Bits 1 downto 0: parity bits P[1] and P[0].
  - P[1] = ! (ID[5] ^ ID[4] ^ ID[3] ^ ID[1])
  - P[0] = (ID[4] ^ ID[2] ^ ID[1] ^ ID[0])

Transmission: To be transmitted PID field. SW needs to calculate the PID field parity bits P[1] and P[0].

Reception: Received PID field. Slave node SW uses the PID field to determine how to handle the response for a received frame header: TX_RESPONSE or  RX_RESPONSE.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CHECKSUM</name>
                <description>Checksum.

Transmission: HW calculated checksum (SW does not need to calculate the checksum) over the transmitted PID field (optional per CTL.CHECKSUM_ENHANCED) and data fields.

Reception: Received checksum. Note that in case of a RX_CHECKSUM_ERROR, SW can use the received PID field and the  received data fields to calculate the correct checksum value.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DATA0</name>
            <description>Response data 0</description>
            <addressOffset>0x84</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DATA1</name>
                <description>Data field 1. 

Transmission: To be transmitted data field. SW provides data field.

Reception: Received data field. SW uses the data field.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA2</name>
                <description>Data field 2.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA3</name>
                <description>Data field 3.</description>
                <bitRange>[23:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA4</name>
                <description>Data field 4.</description>
                <bitRange>[31:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DATA1</name>
            <description>Response data 1</description>
            <addressOffset>0x88</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DATA5</name>
                <description>Data field 5.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA6</name>
                <description>Data field 6.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA7</name>
                <description>Data field 7.</description>
                <bitRange>[23:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA8</name>
                <description>Data field 8.</description>
                <bitRange>[31:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR</name>
            <description>Interrupt</description>
            <addressOffset>0xC0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F036F07</resetMask>
            <fields>
              <field>
                <name>TX_HEADER_DONE</name>
                <description>HW sets this field to '1', when a frame header (break field, synchronization field and PID field) is transmitted (the CMD.TX_HEADER is completed). Specifically:
- When followed by CMD.TX_RESPONSE or CMD.RX_RESPONSE, this field is set to '1' after completion of the frame header transfer.
- When not followed by a response command, this field is set to '1' after completion of the frame header transfer. If CTL.AUTO_EN is '1', this includes the 4-bit period external transceiver disable post-amble.

Note: used in UART mode.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_RESPONSE_DONE</name>
                <description>HW sets this field to '1', when a frame response (data fields and checkum field) is transmitted (the CMD.TX_RESPONSE is completed). If CTL.AUTO_EN is '1', this includes the 4-bit period external transceiver disable post-amble.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_WAKEUP_DONE</name>
                <description>HW sets this field to '1', when a wakeup signal is transmitted (per CTL.BREAK_WAKEUP_LENGTH). This cause is activated on a transition from dominant/'0' state to recessive/'1' state; i.e. at the end of the wakeup signal.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER_DONE</name>
                <description>HW sets this field to '1', when a frame header (break field, synchronization field and PID field) is received (the CMD.RX_HEADER is completed). Specifically:
- When followed by CMD.TX_RESPONSE or CMD.RX_RESPONSE, this field is set to '1' after completion of the frame header transfer.
- When not followed by a response command, this field is set to '1' after completion of the frame header transfer. If CTL.AUTO_EN is '1', this includes the 4-bit period external transceiver disable post-amble.

Note: used in UART mode.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_RESPONSE_DONE</name>
                <description>HW sets this field to '1', when a frame response (data fields and checkum field) is received (the CMD.RX_RESPONSE is completed). If CTL.AUTO_EN is '1', this includes the 4-bit period external transceiver disable post-amble.

Note: activation implies that RX_RESPONSE_FRAME_ERROR and RX_RESPONSE_CHECKSUM_ERROR are not activated during response reception</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_BREAK_WAKEUP_DONE</name>
                <description>HW sets this field to '1', when a break or wakeup signal is received (per CTL.BREAK_WAKEUP_LENGTH). This cause is activated on a transition from dominant/'0' state to recessive/'1' state; i.e. at the end of the wakeup signal.

The break or wakeup detection is always enabled, regardless of CMD register setting.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER_SYNC_DONE</name>
                <description>HW sets this field to '1', when a synchronization field is received (including trailing STOP bits).</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_NOISE_DETECT</name>
                <description>HW sets this field to '1', when isolated '0' or '1' 'in_rx_in' values are observed or when during sampling the last three 'lin_rx_in' values do NOT all have the same value. This mismatch is an indication of noise on the LIN line.

Note: The ongoing frame transfer is NOT aborted.

Note: Used in UART mode.</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TIMEOUT</name>
                <description>HW sets this field to '1', when a frame, frame header or frame response timeout is detected (per CTL.FRAME_TIMEOUT_SEL).

Note: The ongoing frame transfer is NOT aborted.</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_HEADER_BIT_ERROR</name>
                <description>HW sets this field to '1', when a transmitted 'lin_tx_out' value does NOT match a received 'lin_rx_in' value (during header transmission). This specific test allows for delay through the external transceiver. This mismatch is an indication of bus collisions on the LIN line.

The match is performed for the Wakeup, Break, SYNC and the PID fields (for the START bit, data Byte and STOP bit).

Note: When CTL.BIT_ERROR_IGNORE is '0', the ongoing message transfer is aborted (INTR.TX_HEADER_DONE is NOT activated) and the TX_HEADER, TX_RESPONSE and TX_WAKEUP commands are set to '0'. 

Note: Used in UART mode.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_RESPONSE_BIT_ERROR</name>
                <description>HW sets this field to '1', when a transmitted 'lin_tx_out' value does NOT match a received 'lin_rx_in' value (during response transmission).

The match is performed for the data fields and the checksum field (for the START bit, data Byte and STOP bit).

Note: When CTL.BIT_ERROR_IGNORE is '0', the ongoing message transfer is aborted (INTR.TX_RESPONSE_DONE is NOT activated) and the TX_HEADER, TX_RESPONSE and TX_WAKEUP commands are set to '0'.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER_FRAME_ERROR</name>
                <description>HW sets this field to '1', when the received START or STOP bits have an unexpected value (during header reception).

Note: The ongoing message transfer is aborted (INTR.RX_HEADER_DONE is NOT activated) and the TX_HEADER, TX_RESPONSE and TX_WAKEUP commands are set to '0'. 

Note: Used in UART mode.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER_SYNC_ERROR</name>
                <description>HW sets this field to '1', when the received synchronization field is not received within the synchronization counter range [106, 152] (see TX_RX_STATUS.SYNC_COUNTER). 

Note: The ongoing message transfer is aborted (INTR.RX_HEADER_SYNC_DONE is NOT activated) and the TX_HEADER, TX_RESPONSE and TX_WAKEUP commands are set to '0'.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER_PARITY_ERROR</name>
                <description>HW sets this field to '1', when the received PID field has a parity error. 

Note: The ongoing message transfer is aborted (INTR.RX_PID_DONE is NOT activated) and the TX_HEADER, TX_RESPONSE and TX_WAKEUP commands are set to '0'. 

+G119 HW sets this field to '1', when the received data field has a parity error (when CTL0.PARITY_EN is '1').</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_RESPONSE_FRAME_ERROR</name>
                <description>HW sets this field to '1', when the received START or STOP bits have an unexpected value (during response reception). HW does NOT use this field for the STOP bits of the first data field after a RX_HEADER command, if the received data byte is 0x00. (STATUS.RX_DATA0_FRAME_ERROR is used instead).

Note: The ongoing message transfer is aborted (INTR.RX_RESPONSE_DONE is NOT activated) and the TX_HEADER, TX_RESPONSE and TX_WAKEUP commands are set to '0'.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_RESPONSE_CHECKSUM_ERROR</name>
                <description>HW sets this field to '1', when the calculated checksum over the received PID and data fields is not the same as the received checksum. 

Note: The ongoing message transfer is aborted (INTR.RX_RESPONSE_DONE is NOT activated) and the TX_HEADER, TX_RESPONSE and TX_WAKEUP commands are set to '0'.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SET</name>
            <description>Interrupt set</description>
            <addressOffset>0xC4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F036F07</resetMask>
            <fields>
              <field>
                <name>TX_HEADER_DONE</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_RESPONSE_DONE</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_WAKEUP_DONE</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER_DONE</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_RESPONSE_DONE</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_BREAK_WAKEUP_DONE</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER_SYNC_DONE</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_NOISE_DETECT</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TIMEOUT</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_HEADER_BIT_ERROR</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_RESPONSE_BIT_ERROR</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER_FRAME_ERROR</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER_SYNC_ERROR</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER_PARITY_ERROR</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_RESPONSE_FRAME_ERROR</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_RESPONSE_CHECKSUM_ERROR</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASK</name>
            <description>Interrupt mask</description>
            <addressOffset>0xC8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F036F07</resetMask>
            <fields>
              <field>
                <name>TX_HEADER_DONE</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_RESPONSE_DONE</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_WAKEUP_DONE</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER_DONE</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_RESPONSE_DONE</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_BREAK_WAKEUP_DONE</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER_SYNC_DONE</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_NOISE_DETECT</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TIMEOUT</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_HEADER_BIT_ERROR</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_RESPONSE_BIT_ERROR</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER_FRAME_ERROR</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER_SYNC_ERROR</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER_PARITY_ERROR</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_RESPONSE_FRAME_ERROR</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_RESPONSE_CHECKSUM_ERROR</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASKED</name>
            <description>Interrupt masked</description>
            <addressOffset>0xCC</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F036F07</resetMask>
            <fields>
              <field>
                <name>TX_HEADER_DONE</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TX_RESPONSE_DONE</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TX_WAKEUP_DONE</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_HEADER_DONE</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_RESPONSE_DONE</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_BREAK_WAKEUP_DONE</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_HEADER_SYNC_DONE</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_NOISE_DETECT</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[13:13]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TIMEOUT</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[14:14]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TX_HEADER_BIT_ERROR</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TX_RESPONSE_BIT_ERROR</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_HEADER_FRAME_ERROR</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_HEADER_SYNC_ERROR</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_HEADER_PARITY_ERROR</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_RESPONSE_FRAME_ERROR</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_RESPONSE_CHECKSUM_ERROR</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>CANFD0</name>
      <description>CAN Controller</description>
      <headerStructName>CANFD</headerStructName>
      <baseAddress>0x40520000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>131072</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>3</dim>
          <dimIncrement>512</dimIncrement>
          <name>CH[%s]</name>
          <description>FIFO wrapper around M_TTCAN 3PIP, to enable DMA</description>
          <addressOffset>0x00000000</addressOffset>
          <cluster>
            <name>M_TTCAN</name>
            <description>TTCAN 3PIP, includes FD</description>
            <addressOffset>0x00000000</addressOffset>
            <register>
              <name>CREL</name>
              <description>Core Release Register</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>DAY</name>
                  <description>Time Stamp Day_x000D_
Two digits, BCD-coded. This field is set by generic parameter on M_TTCAN synthesis.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>MON</name>
                  <description>Time Stamp Month_x000D_
Two digits, BCD-coded. This field is set by generic parameter on M_TTCAN synthesis.</description>
                  <bitRange>[15:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>YEAR</name>
                  <description>Time Stamp Year_x000D_
One digit, BCD-coded. This field is set by generic parameter on M_TTCAN synthesis.</description>
                  <bitRange>[19:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SUBSTEP</name>
                  <description>Sub-step of Core Release_x000D_
One digit, BCD-coded.</description>
                  <bitRange>[23:20]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>STEP</name>
                  <description>Step of Core Release_x000D_
One digit, BCD-coded.</description>
                  <bitRange>[27:24]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>REL</name>
                  <description>Core Release_x000D_
One digit, BCD-coded.</description>
                  <bitRange>[31:28]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>ENDN</name>
              <description>Endian Register</description>
              <addressOffset>0x4</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x87654321</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>ETV</name>
                  <description>Endianness Test Value_x000D_
The endianness test value is 0x87654321.</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>DBTP</name>
              <description>Data Bit Timing &amp; Prescaler Register</description>
              <addressOffset>0xC</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xA33</resetValue>
              <resetMask>0x9F1FFF</resetMask>
              <fields>
                <field>
                  <name>DSJW</name>
                  <description>Data (Re)Synchronization Jump Width_x000D_
0x0-0xF Valid values are 0 to 15. The actual interpretation by the hardware of this value is_x000D_
such that one more than the value programmed here is used.</description>
                  <bitRange>[3:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DTSEG2</name>
                  <description>Data time segment after sample point_x000D_
0x0-0xF Valid values are 0 to 15. The actual interpretation by the hardware of this value is_x000D_
such that one more than the programmed value is used.</description>
                  <bitRange>[7:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DTSEG1</name>
                  <description>Data time segment before sample point_x000D_
0x00-0x1F Valid values are 0 to 31. The actual interpretation by the hardware of this value is_x000D_
such that one more than the programmed value is used.</description>
                  <bitRange>[12:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DBRP</name>
                  <description>Data Bit Rate Prescaler_x000D_
0x00-0x1F The value by which the oscillator frequency is divided for generating the bit time_x000D_
quanta. The bit time is built up from a multiple of this quanta. Valid values for the Bit_x000D_
Rate Prescaler are 0 to 31. The actual interpretation by the hardware of this value is_x000D_
such that one more than the value programmed here is used.</description>
                  <bitRange>[20:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TDC</name>
                  <description>Transmitter Delay Compensation_x000D_
0= Transmitter Delay Compensation disabled_x000D_
1= Transmitter Delay Compensation enabled</description>
                  <bitRange>[23:23]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TEST</name>
              <description>Test Register</description>
              <addressOffset>0x10</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7F</resetMask>
              <fields>
                <field>
                  <name>TAM</name>
                  <description>ASC is not supported by M_TTCAN
Test ASC Multiplexer Control
Controls output pin m_ttcan_ascm in test mode, ORed with the signal from the FSE
0= Level at pin m_ttcan_ascm controlled by FSE
1= Level at pin m_ttcan_ascm = '1'</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TAT</name>
                  <description>ASC is not supported by M_TTCAN
Test ASC Transmit Control
Controls output pin m_ttcan_asct in test mode, ORed with the signal from the FSE
0= Level at pin m_ttcan_asct controlled by FSE
1= Level at pin m_ttcan_asct = '1'</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CAM</name>
                  <description>ASC is not supported by M_TTCAN
Check ASC Multiplexer Control
Monitors level at output pin m_ttcan_ascm.
0= Output pin m_ttcan_ascm = '0'
1= Output pin m_ttcan_ascm = '1'</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CAT</name>
                  <description>ASC is not supported by M_TTCAN
Check ASC Transmit Control
Monitors level at output pin m_ttcan_asct.
0= Output pin m_ttcan_asct = '0'</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LBCK</name>
                  <description>Loop Back Mode_x000D_
0= Reset value, Loop Back Mode is disabled_x000D_
1= Loop Back Mode is enabled (see Section 3.1.9, Test Modes)</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TX</name>
                  <description>Control of Transmit Pin_x000D_
00 Reset value, m_ttcan_tx controlled by the CAN Core, updated at the end of the CAN bit time_x000D_
01 Sample Point can be monitored at pin m_ttcan_tx_x000D_
10 Dominant ('0') level at pin m_ttcan_tx_x000D_
11 Recessive ('1') at pin m_ttcan_tx</description>
                  <bitRange>[6:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RX</name>
                  <description>Receive Pin_x000D_
Monitors the actual value of pin m_ttcan_rx_x000D_
0= The CAN bus is dominant (m_ttcan_rx = '0')_x000D_
1= The CAN bus is recessive (m_ttcan_rx = '1')</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RWD</name>
              <description>RAM Watchdog</description>
              <addressOffset>0x14</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>WDC</name>
                  <description>Watchdog Configuration_x000D_
Start value of the Message RAM Watchdog Counter. With the reset value of '00' the counter is_x000D_
disabled.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>WDV</name>
                  <description>Watchdog Value_x000D_
Actual Message RAM Watchdog Counter Value.</description>
                  <bitRange>[15:8]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>CCCR</name>
              <description>CC Control Register</description>
              <addressOffset>0x18</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x1</resetValue>
              <resetMask>0xF3FF</resetMask>
              <fields>
                <field>
                  <name>INIT</name>
                  <description>Initialization_x000D_
0= Normal Operation_x000D_
1= Initialization is started</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CCE</name>
                  <description>Configuration Change Enable_x000D_
0= The CPU has no write access to the protected configuration registers_x000D_
1= The CPU has write access to the protected configuration registers (while CCCR.INIT = '1')</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ASM</name>
                  <description>Restricted Operation Mode
Bit ASM can only be set by the Host when both CCE and INIT are set to '1'. The bit can be reset by
the Host at any time. For a description of the Restricted Operation Mode see Section 3.1.5.
0= Normal CAN operation
1= Restricted Operation Mode active</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CSA</name>
                  <description>Clock Stop Acknowledge_x000D_
0= No clock stop acknowledged_x000D_
1= M_TTCAN may be set in power down by stopping m_ttcan_hclk and m_ttcan_cclk_x000D_</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CSR</name>
                  <description>Clock Stop Request, not supported by M_TTCAN use CTL.STOP_REQ at the group level instead.
0= No clock stop is requested
1= Clock stop requested. When clock stop is requested, first INIT and then CSA will be set after
all pending transfer requests have been completed and the CAN bus reached idle.</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MON_</name>
                  <description>Bus Monitoring Mode
Bit MON can only be set by the Host when both CCE and INIT are set to '1'. The bit can be reset by
the Host at any time.
0= Bus Monitoring Mode is disabled
1= Bus Monitoring Mode is enabled</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DAR</name>
                  <description>Disable Automatic Retransmission_x000D_
0= Automatic retransmission of messages not transmitted successfully enabled_x000D_
1= Automatic retransmission disabled_x000D_</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEST</name>
                  <description>Test Mode Enable_x000D_
0= Normal operation, register TEST holds reset values_x000D_
1= Test Mode, write access to register TEST enabled</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FDOE</name>
                  <description>FD Operation Enable_x000D_
0= FD operation disabled_x000D_
1= FD operation enabled</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BRSE</name>
                  <description>Bit Rate Switch Enable_x000D_
0= Bit rate switching for transmissions disabled_x000D_
1= Bit rate switching for transmissions enabled</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PXHD</name>
                  <description>Protocol Exception Handling Disable_x000D_
0= Protocol exception handling enabled_x000D_
1= Protocol exception handling disabled</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EFBI</name>
                  <description>Edge Filtering during Bus Integration_x000D_
0= Edge filtering disabled_x000D_
1= Two consecutive dominant tq required to detect an edge for hard synchronization</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXP</name>
                  <description>Transmit Pause_x000D_
If this bit is set, the M_TTCAN pauses for two CAN bit times before starting the next transmission_x000D_
after itself has successfully transmitted a frame (see Section 3.5)._x000D_
0= Transmit pause disabled_x000D_
1= Transmit pause enabled</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>NISO</name>
                  <description>Non ISO Operation_x000D_
If this bit is set, the M_TTCAN uses the CAN FD frame format as specified by the Bosch CAN FD_x000D_
Specification V1.0._x000D_
0= CAN FD frame format according to ISO 11898-1:2015_x000D_
1= CAN FD frame format according to Bosch CAN FD Specification V1.0 addressing the non-ISO CAN FD</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>NBTP</name>
              <description>Nominal Bit Timing &amp; Prescaler Register</description>
              <addressOffset>0x1C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x6000A03</resetValue>
              <resetMask>0xFFFFFF7F</resetMask>
              <fields>
                <field>
                  <name>NTSEG2</name>
                  <description>Nominal Time segment after sample point_x000D_
0x01-0x7F Valid values are 1 to 127. The actual interpretation by the hardware of this value is_x000D_
such that one more than the programmed value is used.</description>
                  <bitRange>[6:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>NTSEG1</name>
                  <description>Nominal Time segment before sample point_x000D_
0x01-0xFF Valid values are 1 to 255. The actual interpretation by the hardware of this value is_x000D_
such that one more than the programmed value is used.</description>
                  <bitRange>[15:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>NBRP</name>
                  <description>Nominal Bit Rate Prescaler_x000D_
0x000-0x1FFThe value by which the oscillator frequency is divided for generating the bit time_x000D_
quanta. The bit time is built up from a multiple of this quanta. Valid values for the Bit_x000D_
Rate Prescaler are 0 to 511. The actual interpretation by the hardware of this value is_x000D_
such that one more than the value programmed here is used.</description>
                  <bitRange>[24:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>NSJW</name>
                  <description>Nominal (Re)Synchronization Jump Width_x000D_
0x00-0x7F Valid values are 0 to 127. The actual interpretation by the hardware of this value is_x000D_
such that one more than the value programmed here is used.</description>
                  <bitRange>[31:25]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TSCC</name>
              <description>Timestamp Counter Configuration</description>
              <addressOffset>0x20</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xF0003</resetMask>
              <fields>
                <field>
                  <name>TSS</name>
                  <description>Timestamp Select, should always be set to external timestamp counter
00= Timestamp counter value always 0x0000
01= Timestamp counter value incremented according to TCP
10= External timestamp counter value used
11= Same as '00'</description>
                  <bitRange>[1:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TCP</name>
                  <description>Timestamp Counter Prescaler (still used for TOCC)
0x0-0xF Configures the timestamp and timeout counters time unit in multiples of CAN bit times
[1...16]. The actual interpretation by the hardware of this value is such that one more
than the value programmed here is used.</description>
                  <bitRange>[19:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TSCV</name>
              <description>Timestamp Counter Value</description>
              <addressOffset>0x24</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>TSC</name>
                  <description>Timestamp Counter, not used for M_TTCAN
The internal/external Timestamp Counter value is captured on start of frame (both Rx and Tx).
When TSCC.TSS = '01', the Timestamp Counter is incremented in multiples of CAN bit times
[1...16] depending on the configuration of TSCC.TCP. Awr ap around sets interrupt flag IR.TSW.
Write access resets the counter to zero. When TSCC.TSS = '10', TSC reflects the external
Timestamp Counter value. A write access has no impact.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TOCC</name>
              <description>Timeout Counter Configuration</description>
              <addressOffset>0x28</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xFFFF0000</resetValue>
              <resetMask>0xFFFF0007</resetMask>
              <fields>
                <field>
                  <name>ETOC</name>
                  <description>Enable Timeout Counter_x000D_
0= Timeout Counter disabled_x000D_
1= Timeout Counter enabled</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TOS</name>
                  <description>Timeout Select_x000D_
When operating in Continuous mode, a write to TOCV presets the counter to the value configured_x000D_
by TOCC.TOP and continues down-counting. When the Timeout Counter is controlled by one of the_x000D_
FIFOs, an empty FIFO presets the counter to the value configured by TOCC.TOP. Down-counting_x000D_
is started when the first FIFO element is stored._x000D_
00= Continuous operation_x000D_
01= Timeout controlled by Tx Event FIFO_x000D_
10= Timeout controlled by Rx FIFO 0_x000D_
11= Timeout controlled by Rx FIFO 1</description>
                  <bitRange>[2:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TOP</name>
                  <description>Timeout Period_x000D_
Start value of the Timeout Counter (down-counter). Configures the Timeout Period.</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TOCV</name>
              <description>Timeout Counter Value</description>
              <addressOffset>0x2C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xFFFF</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>TOC</name>
                  <description>Timeout Counter_x000D_
The Timeout Counter is decremented in multiples of CAN bit times [1...16] depending on the_x000D_
configuration of TSCC.TCP. When decremented to zero, interrupt flag IR.TOO is set and the_x000D_
Timeout Counter is stopped. Start and reset/restart conditions are configured via TOCC.TOS.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>ECR</name>
              <description>Error Counter Register</description>
              <addressOffset>0x40</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFF</resetMask>
              <fields>
                <field>
                  <name>TEC</name>
                  <description>Transmit Error Counter_x000D_
Actual state of the Transmit Error Counter, values between 0 and 255</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>REC</name>
                  <description>Receive Error Counter_x000D_
Actual state of the Receive Error Counter, values between 0 and 127</description>
                  <bitRange>[14:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RP</name>
                  <description>Receive Error Passive_x000D_
0= The Receive Error Counter is below the error passive level of 128_x000D_
1= The Receive Error Counter has reached the error passive level of 128</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>CEL</name>
                  <description>CAN Error Logging_x000D_
The counter is incremented each time when a CAN protocol error causes the Transmit Error Counter_x000D_
or the Receive Error Counter to be incremented. It is reset by read access to CEL. The counter stops_x000D_
at 0xFF; the next increment of TEC or REC sets interrupt flag IR.ELO.</description>
                  <bitRange>[23:16]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PSR</name>
              <description>Protocol Status Register</description>
              <addressOffset>0x44</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x707</resetValue>
              <resetMask>0x7F7FFF</resetMask>
              <fields>
                <field>
                  <name>LEC</name>
                  <description>Last Error Code,
Set on Read0
The LEC indicates the type of the last error to occur on the CAN bus. This field will be cleared to '0'
when a message has been transferred (reception or transmission) without error.

0= No Error: No error occurred since LEC has been reset by successful reception or transmission.
1= Stuff Error: More than 5 equal bits in a sequence have occurred in a part of a received message where this is not allowed.
2= Form Error: A fixed format part of a received frame has the wrong format.
3= AckError: The message transmitted by the M_TTCAN was not acknowledged by another node.
4= Bit1Error: During the transmission of a message (with the exception of the arbitration field),
the device wanted to send a recessive level (bit of logical value '1'), but the monitored bus
 value was dominant. 
5= Bit0Error: During the transmission of a message (or acknowledge bit, or active error flag, or
overload flag), the device wanted to send a dominant level (data or identifier bit logical value
0'), but the monitored bus value was recessive. During Bus_Off recovery this status is set
each time a sequence of 11 recessive bits has been monitored. This enables the CPU to
monitor the proceeding of the Bus_Off recovery sequence (indicating the bus is not stuck at
dominant or continuously disturbed).
6= CRCError: The CRC check sum of a received message was incorrect. The CRC of an incoming
message does not match with the CRC calculated from the received data.
7= NoChange: Any read access to the Protocol Status Register re-initializes the LEC to '7'.
When the LEC shows the value '7', no CAN bus event was detected since the last CPU read
access to the Protocol Status Register.</description>
                  <bitRange>[2:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>ACT</name>
                  <description>Activity
Monitors the module's CAN communication state.
00= Synchronizing - node is synchronizing on CAN communication
01= Idle - node is neither receiver nor transmitter
10= Receiver - node is operating as receiver
11= Transmitter - node is operating as transmitter</description>
                  <bitRange>[4:3]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>EP</name>
                  <description>Error Passive
0= The M_CAN is in the Error_Active state. It normally takes part in bus communication and sends an active error flag when an error has been detected
1= The M_CAN is in the Error_Passive state</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>EW</name>
                  <description>Warning Status
0= Both error counters are below the Error_Warning limit of 96
1= At least one of error counter has reached the Error_Warning limit of 96</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>BO</name>
                  <description>Bus_Off Status
0= The M_CAN is not Bus_Off
1= The M_CAN is in Bus_Off state</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>DLEC</name>
                  <description>Data Phase Last Error Code_x000D_, Set on Read
Type of last error that occurred in the data phase of a CAN FD format frame with its BRS flag set. Coding is the same as for LEC. This field will be cleared to zero when a CAN FD format frame with its BRS flag set has been transferred (reception or transmission) without error.</description>
                  <bitRange>[10:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RESI</name>
                  <description>ESI flag of last received CAN FD Message_x000D_, Reset on Read
This bit is set together with RFDF, independent of acceptance filtering.
0= Last received CAN FD message did not have its ESI flag set
1= Last received CAN FD message had its ESI flag set</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RBRS</name>
                  <description>BRS flag of last received CAN FD Message_x000D_, Reset on Read
This bit is set together with RFDF, independent of acceptance filtering.
0= Last received CAN FD message did not have its BRS flag set
1= Last received CAN FD message had its BRS flag set</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RFDF</name>
                  <description>Received a CAN FD Message_x000D_, Reset on Read
This bit is set independent of acceptance filtering.
0= Since this bit was reset by the CPU, no CAN FD message has been received
1= Message in CAN FD format with FDF flag set has been received</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PXE</name>
                  <description>Protocol Exception Event_x000D_, Reset on Read
0= No protocol exception event occurred since last read access
1= Protocol exception event occurred</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TDCV</name>
                  <description>Transmitter Delay Compensation Value
0x00-0x7F Position of the secondary sample point, defined by the sum of the measured delay from m_can_tx to m_can_rx and TDCR.TDCO. The SSP position is, in the data phase, the number of mtq between the start of the transmitted bit and the secondary sample point. Valid values are 0 to 127 mtq.</description>
                  <bitRange>[22:16]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TDCR</name>
              <description>Transmitter Delay Compensation Register</description>
              <addressOffset>0x48</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7F7F</resetMask>
              <fields>
                <field>
                  <name>TDCF</name>
                  <description>Transmitter Delay Compensation Filter Window Length_x000D_
0x00-0x7F Defines the minimum value for the SSP position, dominant edges on m_ttcan_rx_x000D_
that would result in an earlier SSP position are ignored for transmitter delay measurement.
The feature is enabled when TDCF is configured to a value greater than
TDCO. Valid values are 0 to 127 mtq</description>
                  <bitRange>[6:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TDCO</name>
                  <description>Transmitter Delay Compensation Offset_x000D_
0x00-0x7F Offset value defining the distance between the measured delay from m_ttcan_tx to_x000D_
m_ttcan_rx and the secondary sample point. Valid values are 0 to 127 mtq.</description>
                  <bitRange>[14:8]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>IR</name>
              <description>Interrupt Register</description>
              <addressOffset>0x50</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3FFFFFFF</resetMask>
              <fields>
                <field>
                  <name>RF0N</name>
                  <description>Rx FIFO 0 New Message_x000D_
0= No new message written to Rx FIFO 0_x000D_
1= New message written to Rx FIFO 0_x000D_</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF0W</name>
                  <description>Rx FIFO 0 Watermark Reached_x000D_
0= Rx FIFO 0 fill level below watermark_x000D_
1= Rx FIFO 0 fill level reached watermark</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF0F</name>
                  <description>Rx FIFO 0 Full_x000D_
0= Rx FIFO 0 not full_x000D_
1= Rx FIFO 0 full</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF0L_</name>
                  <description>Rx FIFO 0 Message Lost_x000D_
0= No Rx FIFO 0 message lost_x000D_
1= Rx FIFO 0 message lost, also set after write attempt to Rx FIFO 0 of size zero</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1N</name>
                  <description>Rx FIFO 1 New Message_x000D_
0= No new message written to Rx FIFO 1_x000D_
1= New message written to Rx FIFO 1</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1W</name>
                  <description>Rx FIFO 1 Watermark Reached_x000D_
0= Rx FIFO 1 fill level below watermark_x000D_
1= Rx FIFO 1 fill level reached watermark</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1F</name>
                  <description>Rx FIFO 1 Full_x000D_
0= Rx FIFO 1 not full_x000D_
1= Rx FIFO 1 full</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1L_</name>
                  <description>Rx FIFO 1 Message Lost_x000D_
0= No Rx FIFO 1 message lost_x000D_
1= Rx FIFO 1 message lost, also set after write attempt to Rx FIFO 1 of size zero</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>HPM</name>
                  <description>High Priority Message_x000D_
0= No high priority message received_x000D_
1= High priority message received</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TC</name>
                  <description>Transmission Completed_x000D_
0= No transmission completed_x000D_
1= Transmission completed</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TCF</name>
                  <description>Transmission Cancellation Finished_x000D_
0= No transmission cancellation finished_x000D_
1= Transmission cancellation finished</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TFE</name>
                  <description>Tx FIFO Empty_x000D_
0= Tx FIFO non-empty_x000D_
1= Tx FIFO empty</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFN</name>
                  <description>Tx Event FIFO New Entry_x000D_
0= Tx Event FIFO unchanged_x000D_
1= Tx Handler wrote Tx Event FIFO element</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFW</name>
                  <description>Tx Event FIFO Watermark Reached_x000D_
0= Tx Event FIFO fill level below watermark_x000D_
1= Tx Event FIFO fill level reached watermark</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFF</name>
                  <description>Tx Event FIFO Full_x000D_
0= Tx Event FIFO not full_x000D_
1= Tx Event FIFO full</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFL_</name>
                  <description>Tx Event FIFO Element Lost_x000D_
0= No Tx Event FIFO element lost_x000D_
1= Tx Event FIFO element lost, also set after write attempt to Tx Event FIFO of size zero</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TSW</name>
                  <description>Timestamp Wraparound_x000D_
0= No timestamp counter wrap-around_x000D_
1= Timestamp counter wrapped around</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MRAF</name>
                  <description>Message RAM Access Failure
The flag is set, when the Rx Handler
- has not completed acceptance filtering or storage of an accepted message until the arbitration field of the following message has been received. In this case acceptance filtering or message storage is aborted and the Rx Handler starts processing of the following message.
- was not able to write a message to the Message RAM. In this case message storage is aborted.
In both cases the FIFO put index is not updated resp. the New Data flag for a dedicated Rx Buffer is not set, a partly stored message is overwritten when the next message is stored to this location.
The flag is also set when the Tx Handler was not able to read a message from the Message RAM
in time. In this case message transmission is aborted. In case of a Tx Handler access failure the
M_TTCAN is switched into Restricted Operation Mode (see Section 3.1.5). To leave Restricted
Operation Mode, the Host CPU has to reset CCCR.ASM.
0= No Message RAM access failure occurred
1= Message RAM access failure occurred</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TOO</name>
                  <description>Timeout Occurred_x000D_
0= No timeout_x000D_
1= Timeout reached</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DRX</name>
                  <description>Message stored to Dedicated Rx Buffer_x000D_
The flag is set whenever a received message has been stored into a dedicated Rx Buffer._x000D_
0= No Rx Buffer updated_x000D_
1= At least one received message stored into a Rx Buffer</description>
                  <bitRange>[19:19]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BEC</name>
                  <description>M_TTCAN reports correctable ECC fault to the generic fault structure, this bit always reads as 0.
Bit Error Corrected
Message RAM bit error detected and corrected. Controlled by input signal m_ttcan_aeim_berr[0]
generated by an optional external parity / ECC logic attached to the Message RAM.
0= No bit error detected when reading from Message RAM
1= Bit error detected and corrected (e.g. ECC)</description>
                  <bitRange>[20:20]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BEU</name>
                  <description>Bit Error Uncorrected_x000D_
Message RAM bit error detected, uncorrected. Controlled by input signal m_ttcan_aeim_berr[1]_x000D_
generated by an optional external parity / ECC logic attached to the Message RAM. An uncorrected_x000D_
Message RAM bit error sets CCCR.INIT to '1'. This is done to avoid transmission of corrupted data._x000D_
0= No bit error detected when reading from Message RAM_x000D_
1= Bit error detected, uncorrected (e.g. parity logic)</description>
                  <bitRange>[21:21]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ELO</name>
                  <description>Error Logging Overflow_x000D_
0= CAN Error Logging Counter did not overflow_x000D_
1= Overflow of CAN Error Logging Counter occurred</description>
                  <bitRange>[22:22]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EP_</name>
                  <description>Error Passive_x000D_
0= Error_Passive status unchanged_x000D_
1= Error_Passive status changed</description>
                  <bitRange>[23:23]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EW_</name>
                  <description>Warning Status_x000D_
0= Error_Warning status unchanged_x000D_
1= Error_Warning status changed</description>
                  <bitRange>[24:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BO_</name>
                  <description>Bus_Off Status_x000D_
0= Bus_Off status unchanged_x000D_
1= Bus_Off status changed</description>
                  <bitRange>[25:25]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>WDI</name>
                  <description>Watchdog Interrupt_x000D_
0= No Message RAM Watchdog event occurred_x000D_
1= Message RAM Watchdog event due to missing READY</description>
                  <bitRange>[26:26]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PEA</name>
                  <description>Protocol Error in Arbitration Phase (Nominal Bit Time is used)_x000D_
0= No protocol error in arbitration phase_x000D_
1= Protocol error in arbitration phase detected (PSR.LEC != 0,7)</description>
                  <bitRange>[27:27]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PED</name>
                  <description>Protocol Error in Data Phase (Data Bit Time is used)_x000D_
0= No protocol error in data phase_x000D_
1= Protocol error in data phase detected (PSR.DLEC != 0,7)</description>
                  <bitRange>[28:28]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ARA</name>
                  <description>N/A</description>
                  <bitRange>[29:29]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>IE</name>
              <description>Interrupt Enable</description>
              <addressOffset>0x54</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3FFFFFFF</resetMask>
              <fields>
                <field>
                  <name>RF0NE</name>
                  <description>Rx FIFO 0 New Message Interrupt Enable_x000D_</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF0WE</name>
                  <description>Rx FIFO 0 Watermark Reached Interrupt Enable</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF0FE</name>
                  <description>Rx FIFO 0 Full Interrupt Enable</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF0LE</name>
                  <description>Rx FIFO 0 Message Lost Interrupt Enable</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1NE</name>
                  <description>Rx FIFO 1 New Message Interrupt Enable</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1WE</name>
                  <description>Rx FIFO 1 Watermark Reached Interrupt Enable</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1FE</name>
                  <description>Rx FIFO 1 Full Interrupt Enable</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1LE</name>
                  <description>Rx FIFO 1 Message Lost Interrupt Enable</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>HPME</name>
                  <description>High Priority Message Interrupt Enable</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TCE</name>
                  <description>Transmission Completed Interrupt Enable</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TCFE</name>
                  <description>Transmission Cancellation Finished Interrupt Enable</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TFEE</name>
                  <description>Tx FIFO Empty Interrupt Enable</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFNE</name>
                  <description>Tx Event FIDO New Entry Interrupt Enable</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFWE</name>
                  <description>Tx Event FIFO Watermark Reached Interrupt Enable</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFFE</name>
                  <description>Tx Event FIFO Full Interrupt Enable</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFLE</name>
                  <description>Tx Event FIFO Event Lost Interrupt Enable</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TSWE</name>
                  <description>Timestamp Wraparound Interrupt Enable</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MRAFE</name>
                  <description>Message RAM Access Failure Interrupt Enable</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TOOE</name>
                  <description>Timeout Occurred Interrupt Enable</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DRXE</name>
                  <description>Message stored to Dedicated Rx Buffer Interrupt Enable</description>
                  <bitRange>[19:19]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BECE</name>
                  <description>Bit Error Corrected Interrupt Enable (not used in M_TTCAN)</description>
                  <bitRange>[20:20]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BEUE</name>
                  <description>Bit Error Uncorrected Interrupt Enable</description>
                  <bitRange>[21:21]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ELOE</name>
                  <description>Error Logging Overflow Interrupt Enable</description>
                  <bitRange>[22:22]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EPE</name>
                  <description>Error Passive Interrupt Enable</description>
                  <bitRange>[23:23]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EWE</name>
                  <description>Warning Status Interrupt Enable</description>
                  <bitRange>[24:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BOE</name>
                  <description>Bus_Off Status Interrupt Enable</description>
                  <bitRange>[25:25]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>WDIE</name>
                  <description>Watchdog Interrupt Enable</description>
                  <bitRange>[26:26]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PEAE</name>
                  <description>Protocol Error in Arbitration Phase Enable</description>
                  <bitRange>[27:27]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PEDE</name>
                  <description>Protocol Error in Data Phase Enable</description>
                  <bitRange>[28:28]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ARAE</name>
                  <description>N/A</description>
                  <bitRange>[29:29]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>ILS</name>
              <description>Interrupt Line Select</description>
              <addressOffset>0x58</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3FFFFFFF</resetMask>
              <fields>
                <field>
                  <name>RF0NL</name>
                  <description>Rx FIFO 0 New Message Interrupt Line</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF0WL</name>
                  <description>Rx FIFO 0 Watermark Reached Interrupt Line</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF0FL</name>
                  <description>Rx FIFO 0 Full Interrupt Line</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF0LL</name>
                  <description>Rx FIFO 0 Message Lost Interrupt Line</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1NL</name>
                  <description>Rx FIFO 1 New Message Interrupt Line</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1WL</name>
                  <description>Rx FIFO 1 Watermark Reached Interrupt Line</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1FL</name>
                  <description>Rx FIFO 1 Full Interrupt Line</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1LL</name>
                  <description>Rx FIFO 1 Message Lost Interrupt Line</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>HPML</name>
                  <description>High Priority Message Interrupt Line</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TCL</name>
                  <description>Transmission Completed Interrupt Line</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TCFL</name>
                  <description>Transmission Cancellation Finished Interrupt Line</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TFEL</name>
                  <description>Tx FIFO Empty Interrupt Line</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFNL</name>
                  <description>Tx Event FIFO New Entry Interrupt Line</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFWL</name>
                  <description>Tx Event FIFO Watermark Reached Interrupt Line</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFFL</name>
                  <description>Tx Event FIFO Full Interrupt Line</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFLL</name>
                  <description>Tx Event FIFO Event Lost Interrupt Line</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TSWL</name>
                  <description>Timestamp Wraparound Interrupt Line</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MRAFL</name>
                  <description>Message RAM Access Failure Interrupt Line</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TOOL</name>
                  <description>Timeout Occurred Interrupt Line</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DRXL</name>
                  <description>Message stored to Dedicated Rx Buffer Interrupt Line</description>
                  <bitRange>[19:19]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BECL</name>
                  <description>Bit Error Corrected Interrupt Line  (not used in M_TTCAN)</description>
                  <bitRange>[20:20]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BEUL</name>
                  <description>Bit Error Uncorrected Interrupt Line</description>
                  <bitRange>[21:21]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ELOL</name>
                  <description>Error Logging Overflow Interrupt Line</description>
                  <bitRange>[22:22]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EPL</name>
                  <description>Error Passive Interrupt Line</description>
                  <bitRange>[23:23]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EWL</name>
                  <description>Warning Status Interrupt Line</description>
                  <bitRange>[24:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BOL</name>
                  <description>Bus_Off Status Interrupt Line</description>
                  <bitRange>[25:25]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>WDIL</name>
                  <description>Watchdog Interrupt Line</description>
                  <bitRange>[26:26]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PEAL</name>
                  <description>Protocol Error in Arbitration Phase Line</description>
                  <bitRange>[27:27]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PEDL</name>
                  <description>Protocol Error in Data Phase Line</description>
                  <bitRange>[28:28]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ARAL</name>
                  <description>N/A</description>
                  <bitRange>[29:29]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>ILE</name>
              <description>Interrupt Line Enable</description>
              <addressOffset>0x5C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3</resetMask>
              <fields>
                <field>
                  <name>EINT0</name>
                  <description>Enable Interrupt Line 0_x000D_
0= Interrupt line m_ttcan_int0 disabled_x000D_
1= Interrupt line m_ttcan_int0 enabled</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EINT1</name>
                  <description>Enable Interrupt Line 1_x000D_
0= Interrupt line m_ttcan_int1 disabled_x000D_
1= Interrupt line m_ttcan_int1 enabled</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GFC</name>
              <description>Global Filter Configuration</description>
              <addressOffset>0x80</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3F</resetMask>
              <fields>
                <field>
                  <name>RRFE</name>
                  <description>Reject Remote Frames Extended_x000D_
0= Filter remote frames with 29-bit extended IDs_x000D_
1= Reject all remote frames with 29-bit extended IDs</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RRFS</name>
                  <description>Reject Remote Frames Standard_x000D_
0= Filter remote frames with 11-bit standard IDs_x000D_
1= Reject all remote frames with 11-bit standard IDs</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ANFE</name>
                  <description>Accept Non-matching Frames Extended_x000D_
Defines how received messages with 29-bit IDs that do not match any element of the filter list are_x000D_
treated._x000D_
00= Accept in Rx FIFO 0_x000D_
01= Accept in Rx FIFO 1_x000D_
10= Reject_x000D_
11= Reject</description>
                  <bitRange>[3:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ANFS</name>
                  <description>Accept Non-matching Frames Standard_x000D_
Defines how received messages with 11-bit IDs that do not match any element of the filter list are_x000D_
treated._x000D_
00= Accept in Rx FIFO 0_x000D_
01= Accept in Rx FIFO 1_x000D_
10= Reject_x000D_
11= Reject</description>
                  <bitRange>[5:4]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>SIDFC</name>
              <description>Standard ID Filter Configuration</description>
              <addressOffset>0x84</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFC</resetMask>
              <fields>
                <field>
                  <name>FLSSA</name>
                  <description>Filter List Standard Start Address_x000D_
Start address of standard Message ID filter list (32-bit word address, see Figure 2).</description>
                  <bitRange>[15:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LSS</name>
                  <description>List Size Standard_x000D_
0= No standard Message ID filter_x000D_
1-128= Number of standard Message ID filter elements_x000D_
128= Values greater than 128 are interpreted as 128</description>
                  <bitRange>[23:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>XIDFC</name>
              <description>Extended ID Filter Configuration</description>
              <addressOffset>0x88</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7FFFFC</resetMask>
              <fields>
                <field>
                  <name>FLESA</name>
                  <description>Filter List Extended Start Address_x000D_
Start address of extended Message ID filter list (32-bit word address, see Figure 2).</description>
                  <bitRange>[15:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LSE</name>
                  <description>List Size Extended_x000D_
0= No extended Message ID filter_x000D_
1-64= Number of extended Message ID filter elements_x000D_
64= Values greater than 64 are interpreted as 64</description>
                  <bitRange>[22:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>XIDAM</name>
              <description>Extended ID AND Mask</description>
              <addressOffset>0x90</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x1FFFFFFF</resetMask>
              <fields>
                <field>
                  <name>EIDM</name>
                  <description>Extended ID Mask_x000D_
For acceptance filtering of extended frames the Extended ID AND Mask is ANDed with the Message_x000D_
ID of a received frame. Intended for masking of 29-bit IDs in SAE J1939. With the reset value of all_x000D_
bits set to one the mask is not active.</description>
                  <bitRange>[28:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>HPMS</name>
              <description>High Priority Message Status</description>
              <addressOffset>0x94</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>BIDX</name>
                  <description>Buffer Index_x000D_
Index of Rx FIFO element to which the message was stored. Only valid when MSI[1] = '1'.</description>
                  <bitRange>[5:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>MSI</name>
                  <description>Message Storage Indicator_x000D_
00= No FIFO selected_x000D_
01= FIFO message lost_x000D_
10= Message stored in FIFO 0_x000D_
11= Message stored in FIFO 1</description>
                  <bitRange>[7:6]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>FIDX</name>
                  <description>Filter Index_x000D_
Index of matching filter element. Range is 0 to SIDFC.LSS - 1 resp. XIDFC.LSE - 1.</description>
                  <bitRange>[14:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>FLST</name>
                  <description>Filter List_x000D_
Indicates the filter list of the matching filter element._x000D_
0= Standard Filter List_x000D_
1= Extended Filter List</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>NDAT1</name>
              <description>New Data 1</description>
              <addressOffset>0x98</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>ND</name>
                  <description>New Data_x000D_
The register holds the New Data flags of Rx Buffers 0 to 31. The flags are set when the respective_x000D_
Rx Buffer has been updated from a received frame. The flags remain set until the Host clears them._x000D_
Aflag is cleared by writing a '1' to the corresponding bit position. Writing a '0' has no effect. Ahard_x000D_
reset will clear the register._x000D_
0= Rx Buffer not updated_x000D_
1= Rx Buffer updated from new message</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>NDAT2</name>
              <description>New Data 2</description>
              <addressOffset>0x9C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>ND</name>
                  <description>New Data_x000D_
The register holds the New Data flags of Rx Buffers 32 to 63. The flags are set when the respective_x000D_
Rx Buffer has been updated from a received frame. The flags remain set until the Host clears them._x000D_
Aflag is cleared by writing a '1' to the corresponding bit position. Writing a '0' has no effect. Ahard_x000D_
reset will clear the register._x000D_
0= Rx Buffer not updated_x000D_
1= Rx Buffer updated from new message</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RXF0C</name>
              <description>Rx FIFO 0 Configuration</description>
              <addressOffset>0xA0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFF7FFFFC</resetMask>
              <fields>
                <field>
                  <name>F0SA</name>
                  <description>Rx FIFO 0 Start Address_x000D_
Start address of Rx FIFO 0 in Message RAM (32-bit word address, see Figure 2).</description>
                  <bitRange>[15:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>F0S</name>
                  <description>Rx FIFO 0 Size_x000D_
0= No Rx FIFO 0_x000D_
1-64= Number of Rx FIFO 0 elements_x000D_
64= Values greater than 64 are interpreted as 64_x000D_
The Rx FIFO 0 elements are indexed from 0 to F0S-1</description>
                  <bitRange>[22:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>F0WM</name>
                  <description>Rx FIFO 0 Watermark_x000D_
0= Watermark interrupt disabled_x000D_
1-64= Level for Rx FIFO 0 watermark interrupt (IR.RF0W)_x000D_
64= Watermark interrupt disabled</description>
                  <bitRange>[30:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>F0OM</name>
                  <description>FIFO 0 Operation Mode_x000D_
FIFO 0 can be operated in blocking or in overwrite mode (see Section 3.4.2)._x000D_
0= FIFO 0 blocking mode_x000D_
1= FIFO 0 overwrite mode</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RXF0S</name>
              <description>Rx FIFO 0 Status</description>
              <addressOffset>0xA4</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x33F3F7F</resetMask>
              <fields>
                <field>
                  <name>F0FL</name>
                  <description>Rx FIFO 0 Fill Level_x000D_
Number of elements stored in Rx FIFO 0, range 0 to 64.</description>
                  <bitRange>[6:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>F0GI</name>
                  <description>Rx FIFO 0 Get Index
Rx FIFO 0 read index pointer, range 0 to 63.
This field is updated by the software writing to RxF0A.F0AI</description>
                  <bitRange>[13:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>F0PI</name>
                  <description>Rx FIFO 0 Put Index_x000D_
Rx FIFO 0 write index pointer, range 0 to 63.</description>
                  <bitRange>[21:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>F0F</name>
                  <description>Rx FIFO 0 Full_x000D_
0= Rx FIFO 0 not full_x000D_
1= Rx FIFO 0 full</description>
                  <bitRange>[24:24]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RF0L</name>
                  <description>Rx FIFO 0 Message Lost_x000D_
This bit is a copy of interrupt flag IR.RF0L. When IR.RF0L is reset, this bit is also reset._x000D_
0= No Rx FIFO 0 message lost_x000D_
1= Rx FIFO 0 message lost, also set after write attempt to Rx FIFO 0 of size zero</description>
                  <bitRange>[25:25]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RXF0A</name>
              <description>Rx FIFO 0 Acknowledge</description>
              <addressOffset>0xA8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3F</resetMask>
              <fields>
                <field>
                  <name>F0AI</name>
                  <description>Rx FIFO 0 Acknowledge Index_x000D_
After the Host has read a message or a sequence of messages from Rx FIFO 0 it has to write the_x000D_ buffer index of the last element read from Rx FIFO 0 to F0AI. This will set the Rx FIFO 0 Get Index_x000D_ RXF0S.F0GI to F0AI + 1 and update the FIFO 0 Fill Level RXF0S.F0FL.</description>
                  <bitRange>[5:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RXBC</name>
              <description>Rx Buffer Configuration</description>
              <addressOffset>0xAC</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFC</resetMask>
              <fields>
                <field>
                  <name>RBSA</name>
                  <description>Rx Buffer Start Address_x000D_
Configures the start address of the Rx Buffers section in the Message RAM (32-bit word address)._x000D_
Also used to reference debug messages A,B,C.</description>
                  <bitRange>[15:2]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RXF1C</name>
              <description>Rx FIFO 1 Configuration</description>
              <addressOffset>0xB0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFF7FFFFC</resetMask>
              <fields>
                <field>
                  <name>F1SA</name>
                  <description>Rx FIFO 1 Start Address_x000D_
Start address of Rx FIFO 1 in Message RAM (32-bit word address, see Figure 2).</description>
                  <bitRange>[15:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>F1S</name>
                  <description>Rx FIFO 1 Size_x000D_
0= No Rx FIFO 1_x000D_
1-64= Number of Rx FIFO 1 elements_x000D_
64= Values greater than 64 are interpreted as 64_x000D_
The Rx FIFO 1 elements are indexed from 0 to F1S - 1</description>
                  <bitRange>[22:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>F1WM</name>
                  <description>Rx FIFO 1 Watermark_x000D_
0= Watermark interrupt disabled_x000D_
1-64= Level for Rx FIFO 1 watermark interrupt (IR.RF1W)_x000D_
64= Watermark interrupt disabled</description>
                  <bitRange>[30:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>F1OM</name>
                  <description>FIFO 1 Operation Mode_x000D_
FIFO 1 can be operated in blocking or in overwrite mode (see Section 3.4.2)._x000D_
0= FIFO 1 blocking mode_x000D_
1= FIFO 1 overwrite mode</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RXF1S</name>
              <description>Rx FIFO 1 Status</description>
              <addressOffset>0xB4</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xC33F3F7F</resetMask>
              <fields>
                <field>
                  <name>F1FL</name>
                  <description>Rx FIFO 1 Fill Level_x000D_
Number of elements stored in Rx FIFO 1, range 0 to 64.</description>
                  <bitRange>[6:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>F1GI</name>
                  <description>Rx FIFO 1 Get Index
Rx FIFO 1 read index pointer, range 0 to 63.
This field is updated by the software writing to RxF1A.FAI</description>
                  <bitRange>[13:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>F1PI</name>
                  <description>Rx FIFO 1 Put Index_x000D_
Rx FIFO 1 write index pointer, range 0 to 63.</description>
                  <bitRange>[21:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>F1F</name>
                  <description>Rx FIFO 1 Full_x000D_
0= Rx FIFO 1 not full_x000D_
1= Rx FIFO 1 full</description>
                  <bitRange>[24:24]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RF1L</name>
                  <description>Rx FIFO 1 Message Lost_x000D_
This bit is a copy of interrupt flag IR.RF1L. When IR.RF1L is reset, this bit is also reset._x000D_
0= No Rx FIFO 1 message lost_x000D_
1= Rx FIFO 1 message lost, also set after write attempt to Rx FIFO 1 of size zero</description>
                  <bitRange>[25:25]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>DMS</name>
                  <description>Debug Message Status_x000D_
00= Idle state, wait for reception of debug messages, DMA request is cleared_x000D_
01= Debug message A received_x000D_
10= Debug messages A, B received_x000D_
11= Debug messages A, B, C received, DMA request is set</description>
                  <bitRange>[31:30]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RXF1A</name>
              <description>Rx FIFO 1 Acknowledge</description>
              <addressOffset>0xB8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3F</resetMask>
              <fields>
                <field>
                  <name>F1AI</name>
                  <description>Rx FIFO 1 Acknowledge Index_x000D_
After the Host has read a message or a sequence of messages from Rx FIFO 1 it has to write the_x000D_ buffer index of the last element read from Rx FIFO 1 to F1AI. This will set the Rx FIFO 1 Get Index_x000D_ RXF1S.F1GI to F1AI + 1 and update the FIFO 1 Fill Level RXF1S.F1FL.</description>
                  <bitRange>[5:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RXESC</name>
              <description>Rx Buffer / FIFO Element Size Configuration</description>
              <addressOffset>0xBC</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x777</resetMask>
              <fields>
                <field>
                  <name>F0DS</name>
                  <description>N/A</description>
                  <bitRange>[2:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>F1DS</name>
                  <description>Rx FIFO 1 Data Field Size_x000D_
000= 8 byte data field_x000D_
001= 12 byte data field_x000D_
010= 16 byte data field_x000D_
011= 20 byte data field_x000D_
100= 24 byte data field_x000D_
101= 32 byte data field_x000D_
110= 48 byte data field_x000D_
111= 64 byte data field</description>
                  <bitRange>[6:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RBDS</name>
                  <description>Rx Buffer Data Field Size_x000D_
000= 8 byte data field_x000D_
001= 12 byte data field_x000D_
010= 16 byte data field_x000D_
011= 20 byte data field_x000D_
100= 24 byte data field_x000D_
101= 32 byte data field_x000D_
110= 48 byte data field_x000D_
111= 64 byte data field</description>
                  <bitRange>[10:8]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXBC</name>
              <description>Tx Buffer Configuration</description>
              <addressOffset>0xC0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7F3FFFFC</resetMask>
              <fields>
                <field>
                  <name>TBSA</name>
                  <description>Tx Buffers Start Address_x000D_
Start address of Tx Buffers section in Message RAM (32-bit word address, see Figure 2).</description>
                  <bitRange>[15:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>NDTB</name>
                  <description>Number of Dedicated Transmit Buffers_x000D_
0= No Dedicated Tx Buffers_x000D_
1-32= Number of Dedicated Tx Buffers_x000D_
32= Values greater than 32 are interpreted as 32</description>
                  <bitRange>[21:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TFQS</name>
                  <description>Transmit FIFO/Queue Size_x000D_
0= No Tx FIFO/Queue_x000D_
1-32= Number of Tx Buffers used for Tx FIFO/Queue_x000D_
32= Values greater than 32 are interpreted as 32</description>
                  <bitRange>[29:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TFQM</name>
                  <description>Tx FIFO/Queue Mode_x000D_
0= Tx FIFO operation_x000D_
1= Tx Queue operation</description>
                  <bitRange>[30:30]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXFQS</name>
              <description>Tx FIFO/Queue Status</description>
              <addressOffset>0xC4</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3F1F3F</resetMask>
              <fields>
                <field>
                  <name>TFFL</name>
                  <description>Tx FIFO Free Level_x000D_
Number of consecutive free Tx FIFO elements starting from TFGI, range 0 to 32. Read as zero when_x000D_
Tx Queue operation is configured (TXBC.TFQM = '1')</description>
                  <bitRange>[5:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TFGI</name>
                  <description>Tx FIFO Get Index_x000D_
Tx FIFO read index pointer, range 0 to 31. Read as zero when Tx Queue operation is configured_x000D_
TXBC.TFQM = '1').</description>
                  <bitRange>[12:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TFQPI</name>
                  <description>Tx FIFO/Queue Put Index_x000D_
Tx FIFO/Queue write index pointer, range 0 to 31.</description>
                  <bitRange>[20:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TFQF</name>
                  <description>Tx FIFO/Queue Full_x000D_
0= Tx FIFO/Queue not full_x000D_
1= Tx FIFO/Queue full</description>
                  <bitRange>[21:21]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXESC</name>
              <description>Tx Buffer Element Size Configuration</description>
              <addressOffset>0xC8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7</resetMask>
              <fields>
                <field>
                  <name>TBDS</name>
                  <description>Tx Buffer Data Field Size_x000D_
000= 8 byte data field_x000D_
001= 12 byte data field_x000D_
010= 16 byte data field_x000D_
011= 20 byte data field_x000D_
100= 24 byte data field_x000D_
101= 32 byte data field_x000D_
110= 48 byte data field_x000D_
111= 64 byte data field</description>
                  <bitRange>[2:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXBRP</name>
              <description>Tx Buffer Request Pending</description>
              <addressOffset>0xCC</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>TRP</name>
                  <description>Transmission Request Pending_x000D_
Each Tx Buffer has its own Transmission Request Pending bit. The bits are set via register TXBAR._x000D_
The bits are reset after a requested transmission has completed or has been cancelled via register_x000D_
TXBCR._x000D_
TXBRP bits are set only for those Tx Buffers configured via TXBC. After a TXBRP bit has been set,_x000D_
a Tx scan (see Section 3.5, Tx Handling) is started to check for the pending Tx request with the_x000D_
highest priority (Tx Buffer with lowest Message ID)._x000D_
Acancellation request resets the corresponding transmission request pending bit of register_x000D_
TXBRP. In case a transmission has already been started when a cancellation is requested, this is_x000D_
done at the end of the transmission, regardless whether the transmission was successful or not. The_x000D_
cancellation request bits are reset directly after the corresponding TXBRP bit has been reset._x000D_
After a cancellation has been requested, a finished cancellation is signalled via TXBCF_x000D_
after successful transmission together with the corresponding TXBTO bit_x000D_
when the transmission has not yet been started at the point of cancellation_x000D_
when the transmission has been aborted due to lost arbitration_x000D_
when an error occurred during frame transmission_x000D_
In DAR mode all transmissions are automatically cancelled if they are not successful. The_x000D_
corresponding TXBCF bit is set for all unsuccessful transmissions._x000D_
0= No transmission request pending_x000D_
1= Transmission request pending</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXBAR</name>
              <description>Tx Buffer Add Request</description>
              <addressOffset>0xD0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>AR</name>
                  <description>Add Request_x000D_
Each Tx Buffer has its own Add Request bit. Writing a '1' will set the corresponding Add Request_x000D_
bit; writing a '0' has no impact. This enables the Host to set transmission requests for multiple Tx_x000D_
Buffers with one write to TXBAR. TXBAR bits are set only for those Tx Buffers configured via TXBC._x000D_
When no Tx scan is running, the bits are reset immediately, else the bits remain set until the Tx scan_x000D_
process has completed._x000D_
0= No transmission request added_x000D_
1= Transmission requested added</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXBCR</name>
              <description>Tx Buffer Cancellation Request</description>
              <addressOffset>0xD4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>CR</name>
                  <description>Cancellation Request_x000D_
Each Tx Buffer has its own Cancellation Request bit. Writing a '1' will set the corresponding_x000D_
Cancellation Request bit; writing a '0' has no impact. This enables the Host to set cancellation_x000D_
requests for multiple Tx Buffers with one write to TXBCR. TXBCR bits are set only for those Tx_x000D_
Buffers configured via TXBC. The bits remain set until the corresponding bit of TXBRP is reset._x000D_
0= No cancellation pending_x000D_
1= Cancellation pending</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXBTO</name>
              <description>Tx Buffer Transmission Occurred</description>
              <addressOffset>0xD8</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>TO</name>
                  <description>Transmission Occurred_x000D_
Each Tx Buffer has its own Transmission Occurred bit. The bits are set when the corresponding_x000D_
TXBRP bit is cleared after a successful transmission. The bits are reset when a new transmission_x000D_
is requested by writing a '1' to the corresponding bit of register TXBAR._x000D_
0= No transmission occurred_x000D_
1= Transmission occurred</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXBCF</name>
              <description>Tx Buffer Cancellation Finished</description>
              <addressOffset>0xDC</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>CF</name>
                  <description>Cancellation Finished_x000D_
Each Tx Buffer has its own Cancellation Finished bit. The bits are set when the corresponding_x000D_
TXBRP bit is cleared after a cancellation was requested via TXBCR. In case the corresponding_x000D_
TXBRP bit was not set at the point of cancellation, CF is set immediately. The bits are reset when a_x000D_
new transmission is requested by writing a '1' to the corresponding bit of register TXBAR._x000D_
0= No transmit buffer cancellation_x000D_
1= Transmit buffer cancellation finished</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXBTIE</name>
              <description>Tx Buffer Transmission Interrupt Enable</description>
              <addressOffset>0xE0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>TIE</name>
                  <description>Transmission Interrupt Enable_x000D_
Each Tx Buffer has its own Transmission Interrupt Enable bit._x000D_
0= Transmission interrupt disabled_x000D_
1= Transmission interrupt enable</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXBCIE</name>
              <description>Tx Buffer Cancellation Finished Interrupt Enable</description>
              <addressOffset>0xE4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>CFIE</name>
                  <description>Cancellation Finished Interrupt Enable_x000D_
Each Tx Buffer has its own Cancellation Finished Interrupt Enable bit._x000D_
0= Cancellation finished interrupt disabled_x000D_
1= Cancellation finished interrupt enabled</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXEFC</name>
              <description>Tx Event FIFO Configuration</description>
              <addressOffset>0xF0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3F3FFFFC</resetMask>
              <fields>
                <field>
                  <name>EFSA</name>
                  <description>Event FIFO Start Address_x000D_
Start address of Tx Event FIFO in Message RAM (32-bit word address, see Figure 2).</description>
                  <bitRange>[15:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EFS</name>
                  <description>Event FIFO Size_x000D_
0= Tx Event FIFO disabled_x000D_
1-32= Number of Tx Event FIFO elements_x000D_
32= Values greater than 32 are interpreted as 32_x000D_
The Tx Event FIFO elements are indexed from 0 to EFS-1</description>
                  <bitRange>[21:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EFWM</name>
                  <description>Event FIFO Watermark_x000D_
0= Watermark interrupt disabled_x000D_
1-32= Level for Tx Event FIFO watermark interrupt (IR.TEFW)_x000D_
32= Watermark interrupt disabled</description>
                  <bitRange>[29:24]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXEFS</name>
              <description>Tx Event FIFO Status</description>
              <addressOffset>0xF4</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x31F1F3F</resetMask>
              <fields>
                <field>
                  <name>EFFL</name>
                  <description>Event FIFO Fill Level_x000D_
Number of elements stored in Tx Event FIFO, range 0 to 32.</description>
                  <bitRange>[5:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>EFGI</name>
                  <description>Event FIFO Get Index_x000D_
Tx Event FIFO read index pointer, range 0 to 31.</description>
                  <bitRange>[12:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>EFPI</name>
                  <description>Event FIFO Put Index_x000D_
Tx Event FIFO write index pointer, range 0 to 31.</description>
                  <bitRange>[20:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>EFF</name>
                  <description>Event FIFO Full_x000D_
0= Tx Event FIFO not full_x000D_
1= Tx Event FIFO full</description>
                  <bitRange>[24:24]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TEFL</name>
                  <description>Tx Event FIFO Element Lost_x000D_
This bit is a copy of interrupt flag IR.TEFL. When IR.TEFL is reset, this bit is also reset._x000D_
0= No Tx Event FIFO element lost_x000D_
1= Tx Event FIFO element lost, also set after write attempt to Tx Event FIFO of size zero.</description>
                  <bitRange>[25:25]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXEFA</name>
              <description>Tx Event FIFO Acknowledge</description>
              <addressOffset>0xF8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x1F</resetMask>
              <fields>
                <field>
                  <name>EFAI</name>
                  <description>Event FIFO Acknowledge Index_x000D_
After the Host has read an element or a sequence of elements from the Tx Event FIFO it has to write_x000D_
the index of the last element read from Tx Event FIFO to EFAI. This will set the Tx Event FIFO Get_x000D_
Index TXEFS.EFGI to EFAI + 1 and update the Event FIFO Fill Level TXEFS.EFFL.</description>
                  <bitRange>[4:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTTMC</name>
              <description>TT Trigger Memory Configuration</description>
              <addressOffset>0x100</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7FFFFC</resetMask>
              <fields>
                <field>
                  <name>TMSA</name>
                  <description>Trigger Memory Start Address_x000D_
Start address of Trigger Memory in Message RAM (32-bit word address, see Figure 2).</description>
                  <bitRange>[15:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TME</name>
                  <description>Trigger Memory Elements_x000D_
0= No Trigger Memory_x000D_
1-64= Number of Trigger Memory elements_x000D_
64= Values greater than 64 are interpreted as 64</description>
                  <bitRange>[22:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTRMC</name>
              <description>TT Reference Message Configuration</description>
              <addressOffset>0x104</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xDFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>RID</name>
                  <description>Reference Identifier_x000D_
Identifier transmitted with reference message and used for reference message filtering. Standard or_x000D_
extended reference identifier depending on bit XTD. Astandard identifier has to be written to_x000D_
ID[28:18].</description>
                  <bitRange>[28:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>XTD</name>
                  <description>Extended Identifier_x000D_
0= 11-bit standard identifier_x000D_
1= 29-bit extended identifier</description>
                  <bitRange>[30:30]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RMPS</name>
                  <description>Reference Message Payload Select_x000D_
Ignored in case of time slaves._x000D_
0= Reference message has no additional payload_x000D_
1= The following elements are taken from Tx Buffer 0:_x000D_
Message Marker MM, Event FIFO Control EFC, Data Length Code DLC, Data Bytes DB_x000D_
Level 1: bytes 2-8, Level 0,2: bytes 5-8)</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTOCF</name>
              <description>TT Operation Configuration</description>
              <addressOffset>0x108</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x10000</resetValue>
              <resetMask>0x7FFFFFB</resetMask>
              <fields>
                <field>
                  <name>OM</name>
                  <description>Operation Mode_x000D_
00= Event-driven CAN communication, default_x000D_
01= TTCAN level 1_x000D_
10= TTCAN level 2_x000D_
11= TTCAN level 0</description>
                  <bitRange>[1:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GEN</name>
                  <description>Gap Enable_x000D_
0= Strictly time-triggered operation_x000D_
1= External event-synchronized time-triggered operation</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TM</name>
                  <description>Time Master_x000D_
0= Time Master function disabled_x000D_
1= Potential Time Master</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LDSDL</name>
                  <description>LD of Synchronization Deviation Limit_x000D_
The Synchronization Deviation Limit SDL is configured by its dual logarithm LDSDL with SDL =_x000D_
2(LDSDL + 5). It should not exceed the clock tolerance given by the CAN bit timing configuration._x000D_
0x0-7 LD of Synchronization Deviation Limit (SDL &lt;= 32...4096)</description>
                  <bitRange>[7:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>IRTO</name>
                  <description>Initial Reference Trigger Offset_x000D_
0x00-7F Positive offset, range from 0 to 127</description>
                  <bitRange>[14:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EECS</name>
                  <description>Enable External Clock Synchronization_x000D_
If enabled, TUR configuration (TURCF.NCL only) may be updated during TTCAN operation._x000D_
0= External clock synchronization in TTCAN Level 0,2 disabled_x000D_
1= External clock synchronization in TTCAN Level 0,2 enabled</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>AWL</name>
                  <description>Application Watchdog Limit_x000D_
The application watchdog can be disabled by programming AWL to 0x00._x000D_
0x00-FF Maximum time after which the application has to serve the application watchdog._x000D_
The application watchdog is incremented once each 256 NTUs.</description>
                  <bitRange>[23:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EGTF</name>
                  <description>Enable Global Time Filtering_x000D_
0= Global time filtering in TTCAN Level 0,2 is disabled_x000D_
1= Global time filtering in TTCAN Level 0,2 is enabled</description>
                  <bitRange>[24:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ECC</name>
                  <description>Enable Clock Calibration_x000D_
0= Automatic clock calibration in TTCAN Level 0,2 is disabled_x000D_
1= Automatic clock calibration in TTCAN Level 0,2 is enabled</description>
                  <bitRange>[25:25]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EVTP</name>
                  <description>Event Trigger Polarity
0= Rising edge trigger
1= Falling edge trigger</description>
                  <bitRange>[26:26]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTMLM</name>
              <description>TT Matrix Limits</description>
              <addressOffset>0x10C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFF0FFF</resetMask>
              <fields>
                <field>
                  <name>CCM</name>
                  <description>N/A</description>
                  <bitRange>[5:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CSS</name>
                  <description>N/A</description>
                  <bitRange>[7:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXEW</name>
                  <description>Tx Enable Window_x000D_
0x0-F Length of Tx enable window, 1-16 NTU cycles</description>
                  <bitRange>[11:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ENTT</name>
                  <description>Expected Number of Tx Triggers_x000D_
0x000-FFF Expected number of Tx Triggers in one Matrix Cycle</description>
                  <bitRange>[27:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TURCF</name>
              <description>TUR Configuration</description>
              <addressOffset>0x110</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x10000000</resetValue>
              <resetMask>0xBFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>NCL</name>
                  <description>Numerator Configuration Low_x000D_
Write access to the TUR Numerator Configuration Low is only possible during configuration with_x000D_
TURCF.ELT = '0' or if TTOCF.EECS (external clock synchronization enabled) is set. When a new_x000D_
value for NCL is written outside TT Configuration Mode, the new value takes effect when_x000D_
TTOST.WECS is cleared to '0'. NCL is locked TTOST.WECS is '1'._x000D_
0x0000-FFFF Numerator Configuration Low</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DC</name>
                  <description>Denominator Configuration_x000D_
0x0000 Illegal value_x000D_
0x0001-3FFF Denominator Configuration</description>
                  <bitRange>[29:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ELT</name>
                  <description>Enable Local Time_x000D_
0= Local time is stopped, default_x000D_
1= Local time is enabled</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTOCN</name>
              <description>TT Operation Control</description>
              <addressOffset>0x114</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xBFFF</resetMask>
              <fields>
                <field>
                  <name>SGT</name>
                  <description>Set Global time_x000D_
Writing a '1' to SGT sets TTOST.WGDT if the node is the actual Time Master. SGT is reset after one_x000D_
Host clock period. The global time preset takes effect when the node transmits the next reference_x000D_
message with the Master_Ref_Mark modified by the preset value written to TTGTP._x000D_</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ECS</name>
                  <description>External Clock Synchronization_x000D_
Writing a '1' to ECS sets TTOST.WECS if the node is the actual Time Master. ECS is reset after one_x000D_
Host clock period. The external clock synchronization takes effect at the start of the next basic cycle.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SWP</name>
                  <description>Stop Watch Polarity
0= Rising edge trigger
1= Falling edge trigger</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SWS</name>
                  <description>Stop Watch Source
00= Stop Watch disabled
01= Actual value of cycle time is copied to TTCPT.SWV
10= Actual value of local time is copied to TTCPT.SWV
11= Actual value of global time is copied to TTCPT.SWV</description>
                  <bitRange>[4:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RTIE</name>
                  <description>Register Time Mark Interrupt Pulse Enable
Register time mark interrupts are configured by register TTTMK. Aregister time mark interrupt pulse
with the length of one NTU is generated when the time referenced by TTOCN.TMC (cycle, local, or
global) equals TTTMK.TM, independent of the synchronization state.
0= Register Time Mark Interrupt output m_ttcan_rtp disabled
1= Register Time Mark Interrupt output m_ttcan_rtp enabled</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TMC</name>
                  <description>Register Time Mark Compare
00= No Register Time Mark Interrupt generated
01= Register Time Mark Interrupt if Time Mark = cycle time
10= Register Time Mark Interrupt if Time Mark = local time
11= Register Time Mark Interrupt if Time Mark = global time</description>
                  <bitRange>[7:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TTIE</name>
                  <description>Trigger Time Mark Interrupt Pulse Enable
External time mark events are configured by trigger memory element TMEX (see Section 2.4.7). A
trigger time mark interrupt pulse is generated when the trigger memory element becomes active,
and the M_TTCAN is in synchronization state In_Schedule or In_Gap.
0= Trigger Time Mark Interrupt output m_ttcan_tmp disabled
1= Trigger Time Mark Interrupt output m_ttcan_tmp enabled</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GCS</name>
                  <description>Gap Control Select
0= Gap control independent from m_ttcan_evt
1= Gap control by input pin m_ttcan_evt</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FGP</name>
                  <description>Finish Gap_x000D_
Set by the CPU, reset by each reference message_x000D_
0= No reference message requested_x000D_
1= Application requested start of reference message</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TMG</name>
                  <description>Time Mark Gap_x000D_
0= Reset by each reference message_x000D_
1= Next reference message started when Register Time Mark interrupt TTIR.RTMI is activated</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>NIG</name>
                  <description>Next is Gap_x000D_
This bit can only be set when the M_TTCAN is the actual Time Master and when it is configured for_x000D_
external event-synchronized time-triggered operation (TTOCF.GEN = '1')_x000D_
0= No action, reset by reception of any reference message_x000D_
1= Transmit next reference message with Next_is_Gap = '1'</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ESCN</name>
                  <description>External Synchronization Control
If enabled the M_TTCAN synchronizes its cycle time phase to an external event signalled by a rising
edge at pin m_ttcan_evt (see Section 4.11).
0= External synchronization disabled
1= External synchronization enabled</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LCKC</name>
                  <description>TT Operation Control Register Locked_x000D_
Set by a write access to register TTOCN. Reset when the updated configuration has been_x000D_
synchronized into the CAN clock domain._x000D_
0= Write access to TTOCN enabled_x000D_
1= Write access to TTOCN locked</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTGTP</name>
              <description>TT Global Time Preset</description>
              <addressOffset>0x118</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>TP</name>
                  <description>N/A</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CTP</name>
                  <description>Cycle Time Target Phase
CTP is write-protected while TTOCN.ESCN or TTOST.SPL are set (see Section 4.11).
0x0000-FFFF Defines target value of cycle time when a rising edge of m_ttcan_evt is expected</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTTMK</name>
              <description>TT Time Mark</description>
              <addressOffset>0x11C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x807FFFFF</resetMask>
              <fields>
                <field>
                  <name>TM_</name>
                  <description>Time Mark_x000D_
0x0000-FFFF Time Mark</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TICC</name>
                  <description>Time Mark Cycle Code_x000D_
Cycle count for which the time mark is valid._x000D_
0b000000x valid for all cycles_x000D_
0b000001c valid every second cycle at cycle count mod2 = c_x000D_
0b00001cc valid every fourth cycle at cycle count mod4 = cc_x000D_
0b0001ccc valid every eighth cycle at cycle count mod8 = ccc_x000D_
0b001cccc valid every sixteenth cycle at cycle count mod16 = cccc_x000D_
0b01ccccc valid every thirty-second cycle at cycle count mod32 = ccccc_x000D_
0b1cccccc valid every sixty-fourth cycle at cycle count mod64 = cccccc</description>
                  <bitRange>[22:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LCKM</name>
                  <description>TT Time Mark Register Locked_x000D_
Always set by a write access to registers TTOCN. Set by write access to register TTTMK when_x000D_
TTOCN.TMC != '00'. Reset when the registers have been synchronized into the CAN clock domain._x000D_
0= Write access to TTTMK enabled_x000D_
1= Write access to TTTMK locked</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTIR</name>
              <description>TT Interrupt Register</description>
              <addressOffset>0x120</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7FFFF</resetMask>
              <fields>
                <field>
                  <name>SBC</name>
                  <description>Start of Basic Cycle_x000D_
0= No Basic Cycle started since bit has been reset_x000D_
1= Basic Cycle started_x000D_</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SMC</name>
                  <description>Start of Matrix Cycle_x000D_
0= No Matrix Cycle started since bit has been reset_x000D_
1= Matrix Cycle started</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CSM_</name>
                  <description>Change of Synchronization Mode_x000D_
0= No change in master to slave relation or schedule synchronization_x000D_
1= Master to slave relation or schedule synchronization changed,_x000D_
also set when TTOST.SPL is reset</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SOG</name>
                  <description>Start of Gap_x000D_
0= No reference message seen with Next_is_Gap bit set_x000D_
1= Reference message with Next_is_Gap bit set becomes valid</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RTMI</name>
                  <description>Register Time Mark Interrupt_x000D_
Set when time referenced by TTOCN.TMC (cycle, local, or global) equals TTTMK.TM, independent_x000D_
of the synchronization state._x000D_
0= Time mark not reached_x000D_
1= Time mark reached</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TTMI</name>
                  <description>Trigger Time Mark Event Internal_x000D_
Internal time mark events are configured by trigger memory element TMIN (see Section 2.4.7). Set_x000D_
when the trigger memory element becomes active, and the M_TTCAN is in synchronization state_x000D_
In_Gap or In_Schedule._x000D_
0= Time mark not reached_x000D_
1= Time mark reached (Level 0: cycle time TTOCF.IRTO * 0x200)</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SWE</name>
                  <description>Stop Watch Event
0= No rising/falling edge at stop watch trigger pin m_ttcan_swt detected
1= Rising/falling edge at stop watch trigger pin m_ttcan_swt detected</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GTW</name>
                  <description>Global Time Wrap_x000D_
0= No global time wrap occurred_x000D_
1= Global time wrap from 0xFFFF to 0x0000 occurred</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GTD</name>
                  <description>Global Time Discontinuity_x000D_
0= No discontinuity of global time_x000D_
1= Discontinuity of global time</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GTE</name>
                  <description>Global Time Error_x000D_
Synchronization deviation SD exceeds limit specified by TTOCF.LDSDL, TTCAN Level 0,2 only._x000D_
0= Synchronization deviation within limit_x000D_
1= Synchronization deviation exceeded limit</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXU</name>
                  <description>Tx Count Underflow_x000D_
0= Number of Tx Trigger as expected_x000D_
1= Less Tx trigger than expected in one matrix cycle</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXO</name>
                  <description>Tx Count Overflow_x000D_
0= Number of Tx Trigger as expected_x000D_
1= More Tx trigger than expected in one matrix cycle</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SE1</name>
                  <description>Scheduling Error 1_x000D_
0= No scheduling error 1_x000D_
1= Scheduling error 1 occurred</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SE2</name>
                  <description>Scheduling Error 2_x000D_
0= No scheduling error 2_x000D_
1= Scheduling error 2 occurred</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ELC</name>
                  <description>Error Level Changed_x000D_
Not set when error level changed during initialization._x000D_
0= No change in error level_x000D_
1= Error level changed</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>IWT</name>
                  <description>Initialization Watch Trigger_x000D_
The initialization is restarted by resetting IWT._x000D_
0= No missing reference message during system startup_x000D_
1= No system startup due to missing reference message</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>WT</name>
                  <description>Watch Trigger_x000D_
0= No missing reference message_x000D_
1= Missing reference message (Level 0: cycle time 0xFF00)</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>AW</name>
                  <description>Application Watchdog_x000D_
0= Application watchdog served in time_x000D_
1= Application watchdog not served in time</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CER</name>
                  <description>Configuration Error_x000D_
Trigger out of order._x000D_
0= No error found in trigger list_x000D_
1= Error found in trigger list</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTIE</name>
              <description>TT Interrupt Enable</description>
              <addressOffset>0x124</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7FFFF</resetMask>
              <fields>
                <field>
                  <name>SBCE</name>
                  <description>Start of Basic Cycle Interrupt Enable</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SMCE</name>
                  <description>Start of Matrix Cycle Interrupt Enable</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CSME</name>
                  <description>Change of Synchronization Mode Interrupt Enable</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SOGE</name>
                  <description>Start of Gap Interrupt Enable</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RTMIE</name>
                  <description>Register Time Mark Interrupt Enable</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TTMIE</name>
                  <description>Trigger Time Mark Event Internal Enable</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SWEE</name>
                  <description>Stop Watch Event Interrupt Enable</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GTWE</name>
                  <description>Global Time Wrap Interrupt Enable</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GTDE</name>
                  <description>Global Time Discontinuity Interrupt Enable</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GTEE</name>
                  <description>Global Time Error Interrupt Enable</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXUE</name>
                  <description>Tx Count Underflow Interrupt Enable</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXOE</name>
                  <description>Tx Count Overflow Interrupt Enable</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SE1E</name>
                  <description>Scheduling Error 1 Interrupt Enable</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SE2E</name>
                  <description>Scheduling Error 2 Interrupt Enable</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ELCE</name>
                  <description>Change Error Level Interrupt Enable</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>IWTE</name>
                  <description>Initialization Watch Trigger Interrupt Enable</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>WTE</name>
                  <description>Watch Trigger Interrupt Enable</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>AWE_</name>
                  <description>Application Watchdog Interrupt Enable</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CERE</name>
                  <description>Configuration Error Interrupt Enable</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTILS</name>
              <description>TT Interrupt Line Select</description>
              <addressOffset>0x128</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7FFFF</resetMask>
              <fields>
                <field>
                  <name>SBCL</name>
                  <description>Start of Basic Cycle Interrupt Line</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SMCL</name>
                  <description>Start of Matrix Cycle Interrupt Line</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CSML</name>
                  <description>Change of Synchronization Mode Interrupt Line</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SOGL</name>
                  <description>Start of Gap Interrupt Line</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RTMIL</name>
                  <description>Register Time Mark Interrupt Line</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TTMIL</name>
                  <description>Trigger Time Mark Event Internal Line</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SWEL</name>
                  <description>Stop Watch Event Interrupt Line</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GTWL</name>
                  <description>Global Time Wrap Interrupt Line</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GTDL</name>
                  <description>Global Time Discontinuity Interrupt Line</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GTEL</name>
                  <description>Global Time Error Interrupt Line</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXUL</name>
                  <description>Tx Count Underflow Interrupt Line</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXOL</name>
                  <description>Tx Count Overflow Interrupt Line</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SE1L</name>
                  <description>Scheduling Error 1 Interrupt Line</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SE2L</name>
                  <description>Scheduling Error 2 Interrupt Line</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ELCL</name>
                  <description>Change Error Level Interrupt Line</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>IWTL</name>
                  <description>Initialization Watch Trigger Interrupt Line</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>WTL</name>
                  <description>Watch Trigger Interrupt Line</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>AWL_</name>
                  <description>Application Watchdog Interrupt Line</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CERL</name>
                  <description>Configuration Error Interrupt Line</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTOST</name>
              <description>TT Operation Status</description>
              <addressOffset>0x12C</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFC0FFFF</resetMask>
              <fields>
                <field>
                  <name>EL</name>
                  <description>Error Level_x000D_
00= Severity 0 - No Error_x000D_
01= Severity 1 - Warning_x000D_
10= Severity 2 - Error_x000D_
11= Severity 3 - Severe Error_x000D_</description>
                  <bitRange>[1:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>MS</name>
                  <description>Master State_x000D_
00= Master_Off, no master properties relevant_x000D_
01= Operating as Time Slave_x000D_
10= Operating as Backup Time Master_x000D_
11= Operating as current Time Master</description>
                  <bitRange>[3:2]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SYS</name>
                  <description>Synchronization State_x000D_
00= Out of Synchronization_x000D_
01= Synchronizing to TTCAN communication_x000D_
10= Schedule suspended by Gap (In_Gap)_x000D_
11= Synchronized to schedule (In_Schedule)</description>
                  <bitRange>[5:4]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>QGTP</name>
                  <description>Quality of Global Time Phase_x000D_
Only relevant in TTCAN Level 0 and Level 2, otherwise fixed to '0'._x000D_
0= Global time not valid_x000D_
1= Global time in phase with Time Master</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>QCS</name>
                  <description>Quality of Clock Speed_x000D_
Only relevant in TTCAN Level 0 and Level 2, otherwise fixed to '1'._x000D_
0= Local clock speed not synchronized to Time Master clock speed_x000D_
1= Synchronization Deviation &lt;= SDL</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RTO</name>
                  <description>Reference Trigger Offset_x000D_
The Reference Trigger Offset value is a signed integer with a range from -127 (0x81) to 127 (0x7F)._x000D_
There is no notification when the lower limit of -127 is reached. In case the M_TTCAN becomes_x000D_
Time Master (MS[1:0] = '11'), the reset of RTO is delayed due to synchronization between Host and_x000D_
CAN clock domain. For time slaves the value configured by TTOCF.IRTO is read._x000D_
0x00-FF Actual Reference Trigger offset value</description>
                  <bitRange>[15:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>WGTD</name>
                  <description>Wait for Global Time Discontinuity_x000D_
0= No global time preset pending_x000D_
1= Node waits for the global time preset to take effect. The bit is reset when the node has transmitted_x000D_
a reference message with Disc_Bit = '1' or after it received a reference message.</description>
                  <bitRange>[22:22]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>GFI</name>
                  <description>Gap Finished Indicator_x000D_
Set when the CPU writes TTOCN.FGP, or by a time mark interrupt if TMG = '1', or via input pin_x000D_
m_ttcan_evt if TTOCN.GCS = '1'. Not set by Ref_Trigger_Gap or when Gap is finished by another_x000D_
node sending a reference message._x000D_
0= Reset at the end of each reference message_x000D_
1= Gap finished by M_TTCAN</description>
                  <bitRange>[23:23]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TMP</name>
                  <description>Time Master Priority_x000D_
0x0-7 Priority of actual Time Master</description>
                  <bitRange>[26:24]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>GSI</name>
                  <description>Gap Started Indicator_x000D_
0= No Gap in schedule, reset by each reference message and for all time slaves_x000D_
1= Gap time after Basic Cycle has started</description>
                  <bitRange>[27:27]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>WFE</name>
                  <description>Wait for Event_x000D_
0= No Gap announced, reset by a reference message with Next_is_Gap = '0'_x000D_
1= Reference message with Next_is_Gap = '1' received</description>
                  <bitRange>[28:28]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>AWE</name>
                  <description>Application Watchdog Event_x000D_
The application watchdog is served by reading TTOST. When the watchdog is not served in time,_x000D_
bit AWE is set, all TTCAN communication is stopped, and the M_TTCAN is set into Bus Monitoring_x000D_
Mode._x000D_
0= Application Watchdog served in time_x000D_
1= Failed to serve Application Watchdog in time</description>
                  <bitRange>[29:29]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>WECS</name>
                  <description>Wait for External Clock Synchronization_x000D_
0= No external clock synchronization pending_x000D_
1= Node waits for external clock synchronization to take effect. The bit is reset at the start of the_x000D_
next basic cycle.</description>
                  <bitRange>[30:30]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SPL</name>
                  <description>Schedule Phase Lock
The bit is valid only when external synchronization is enabled (TTOCN.ESCN = '1'). In this case it
signals that the difference between cycle time configured by TTGTP.CTP and the cycle time at the
rising edge at pin m_ttcan_evt is less or equal 9 NTU (see Section 4.11).
0= Phase outside range
1= Phase inside range</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TURNA</name>
              <description>TUR Numerator Actual</description>
              <addressOffset>0x130</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x10000</resetValue>
              <resetMask>0x3FFFF</resetMask>
              <fields>
                <field>
                  <name>NAV</name>
                  <description>N/A</description>
                  <bitRange>[17:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTLGT</name>
              <description>TT Local &amp; Global Time</description>
              <addressOffset>0x134</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>LT</name>
                  <description>Local Time_x000D_
Non-fractional part of local time, incremented once each local NTU (see Section 4.5)._x000D_
0x0000-FFFF Local time value of TTCAN node</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>GT</name>
                  <description>Global Time_x000D_
Non-fractional part of the sum of the node's local time and its local offset (see Section 4.5)._x000D_
0x0000-FFFF Global time value of TTCAN network</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTCTC</name>
              <description>TT Cycle Time &amp; Count</description>
              <addressOffset>0x138</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x3F0000</resetValue>
              <resetMask>0x3FFFFF</resetMask>
              <fields>
                <field>
                  <name>CT</name>
                  <description>Cycle Time_x000D_
Non-fractional part of the difference of the node's local time and Ref_Mark (see Section 4.5)._x000D_
0x0000-FFFF Cycle time value of TTCAN Basic Cycle</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>CC</name>
                  <description>Cycle Count_x000D_
0x00-3F Number of actual Basic Cycle in the System Matrix</description>
                  <bitRange>[21:16]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTCPT</name>
              <description>TT Capture Time</description>
              <addressOffset>0x13C</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF003F</resetMask>
              <fields>
                <field>
                  <name>CCV</name>
                  <description>Cycle Count Value
Cycle count value captured together with SWV.
0x00-3F Captured cycle count value</description>
                  <bitRange>[5:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SWV</name>
                  <description>Stop Watch Value
On a rising/falling edge (as configured via TTOCN.SWP) at the Stop Watch Trigger pin m_ttcan_swt, when TTOCN.SWS is != '00' and TTIR.SWE is '0', the actual time value as selected
by TTOCN.SWS (cycle, local, global) is copied to SWV and TTIR.SWE will be set to '1'. Capturing of the next stop watch value is enabled by resetting TTIR.SWE.
0x0000-FFFF Captured Stop Watch value</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTCSM</name>
              <description>TT Cycle Sync Mark</description>
              <addressOffset>0x140</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>CSM</name>
                  <description>Cycle Sync Mark_x000D_
The Cycle Sync Mark is measured</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
          </cluster>
          <register>
            <name>RXFTOP_CTL</name>
            <description>Receive FIFO Top control</description>
            <addressOffset>0x180</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3</resetMask>
            <fields>
              <field>
                <name>F0TPE</name>
                <description>FIFO 0 Top Pointer Enable. 
This enables the FIFO top pointer logic to set the FIFO Top Address (FnTA) and message word counter.
This logic is also disabled when the IP is being reconfigured (CCCR.CCE=1).
When this logic is disabled a Read from RXFTOP0_DATA is undefined.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>F1TPE</name>
                <description>FIFO 1 Top Pointer Enable.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RXFTOP0_STAT</name>
            <description>Receive FIFO 0 Top Status</description>
            <addressOffset>0x1A0</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>F0TA</name>
                <description>Current FIFO 0 Top Address.
This is a pointer to the next word in the message buffer defined by the FIFO Start Address (FnSA), Get Index (FnGI), the FIFO message size (FnDS) and the message word counter (FnMWC)
FnTA = FnSA + FnGI * msg_size[FnDS] + FnMWC</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RXFTOP0_DATA</name>
            <description>Receive FIFO 0 Top Data</description>
            <addressOffset>0x1A8</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>F0TD</name>
                <description>When enabled (F0TPE=1) read data from MRAM at location FnTA. This register can have a read side effect if the following conditions are met:
- M_TTCAN not being reconfigured (CCCR.CCE=0)
- FIFO Top Pointer logic is enabled (FnTPE=1)
- FIFO is not empty (FnFL!=0)
The read side effect is as follows:
- if FnMWC pointed to the last word of the message (as indicated by FnDS) then the corresponding message index (FnGI) is automatically acknowledge by a write to FnAI
- FnMWC is incremented (or restarted if FnMWC pointed to the last word of the message)
- the FIFO top address FnTA is incremented (with FIFO wrap around) 
When this logic is disabled (F0TPE=0) a Read from this register returns undefined data.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RXFTOP1_STAT</name>
            <description>Receive FIFO 1 Top Status</description>
            <addressOffset>0x1B0</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>F1TA</name>
                <description>See F0TA description</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RXFTOP1_DATA</name>
            <description>Receive FIFO 1 Top Data</description>
            <addressOffset>0x1B8</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>F1TD</name>
                <description>See F0TD description</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>CTL</name>
          <description>Global CAN control register</description>
          <addressOffset>0x1000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x800000FF</resetMask>
          <fields>
            <field>
              <name>STOP_REQ</name>
              <description>Clock Stop Request for each TTCAN IP .
The m_ttcan_clkstop_req of each TTCAN IP is directly driven by these bits.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MRAM_OFF</name>
              <description>MRAM off
'0': Default MRAM on (with MRAM retained in DeepSleep).
'1': Switch MRAM off (not retained) to save power. Before setting this bit all the CAN channels have to be powered down using the STOP_REQ/ACK bits.
When the MRAM is off any access attempt to it is considered an address error (as if MRAM_SIZE=0).
After switching the MRAM on again software needs to allow for a certain power up time before MRAM can be used, i.e. before STOP_REQ can be de-asserted. The power up time is equivalent to the system SRAM power up time specified in the CPUSS.RAM_PWR_DELAY_CTL register.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>Global CAN status register</description>
          <addressOffset>0x1004</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>STOP_ACK</name>
              <description>Clock Stop Acknowledge for each TTCAN IP.
These bits are directly driven by m_ttcan_clkstop_ack of each TTCAN IP.
When this bit is set the corresponding TTCAN IP clocks will be gated off, except HCLK will enabled for each AHB write</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR0_CAUSE</name>
          <description>Consolidated interrupt0 cause register</description>
          <addressOffset>0x1010</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>INT0</name>
              <description>Show pending m_ttcan_int0 of each channel</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR1_CAUSE</name>
          <description>Consolidated interrupt1 cause register</description>
          <addressOffset>0x1014</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>INT1</name>
              <description>Show pending m_ttcan_int1 of each channel</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TS_CTL</name>
          <description>Time Stamp control register</description>
          <addressOffset>0x1020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x8000FFFF</resetMask>
          <fields>
            <field>
              <name>PRESCALE</name>
              <description>Time Stamp counter prescale value. 
When enabled divide the Host clock (HCLK) by PRESCALE+1 to create Time Stamp clock ticks.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>Counter enable bit
0 = Count disabled. Stop counting up and keep the counter value
1 = Count enabled. Start counting up from the current value</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TS_CNT</name>
          <description>Time Stamp counter value</description>
          <addressOffset>0x1024</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>VALUE</name>
              <description>The counter value of the Time Stamp Counter.
When enabled this counter will count Time Stamp clock ticks from the pre-scaler.
When written this counter and the pre-scaler will reset to 0 (write data is ignored).</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ECC_CTL</name>
          <description>ECC control</description>
          <addressOffset>0x1080</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x10000</resetMask>
          <fields>
            <field>
              <name>ECC_EN</name>
              <description>Enable ECC for CANFD SRAM
When disabled also all error injection functionality is disabled.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ECC_ERR_INJ</name>
          <description>ECC error injection</description>
          <addressOffset>0x1084</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFC</resetValue>
          <resetMask>0x7F10FFFC</resetMask>
          <fields>
            <field>
              <name>ERR_ADDR</name>
              <description>Specifies the address of the word where an error will be injected on write or an non-correctable error will be suppressed.
When the ERR_EN bit is set an error parity (ERR_PAR) is injected when any write, from bus or a CAN channel, is done to this address.
When the ERR_EN bit is set and the access address matches ERR_ADDR then a non-correctable ECC error or an Address error will NOT result in a bus error or CAN channel shutdown.
Note that error reporting to the fault structure cannot be supressed.</description>
              <bitRange>[15:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_EN</name>
              <description>Enable error injection (ECC_EN must be 1).
When this bit is set the error parity (ERR_PAR) will be used when when an AHB write is done to the ERR_ADDR address.
When the error word is read a single or double error will be reported to the fault structure just like for a real ECC error (even if this bit is no longer set).
When this bit is set (and ECC_EN=1) a non-correctable error (ECC or address error) for the ERR_ADDR will not be reported back to the CAN channel or  AHB bus.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_PAR</name>
              <description>ECC Parity bits to use for ECC error injection at address ERR_ADDR.</description>
              <bitRange>[30:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="CANFD0">
      <name>CANFD1</name>
      <baseAddress>0x40540000</baseAddress>
    </peripheral>
    <peripheral>
      <name>SCB0</name>
      <description>Serial Communications Block (SPI/UART/I2C)</description>
      <headerStructName>SCB</headerStructName>
      <baseAddress>0x40600000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTRL</name>
          <description>Generic control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x300400F</resetValue>
          <resetMask>0x9303D70F</resetMask>
          <fields>
            <field>
              <name>OVS</name>
              <description>N/A</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EC_AM_MODE</name>
              <description>This field specifies the clocking for the address matching (I2C) or slave selection detection logic (SPI)
'0': Internally clocked mode 
'1': Externally clocked mode 

In internally clocked mode, the serial interface protocols run off the SCB clock. In externally clocked mode, the serial interface protocols run off the clock as provided by the serial interface.

The clocking for the rest of the logic is determined by CTRL.EC_OP_MODE.

Externally clocked mode is only used for synchronous serial interface protocols (SPI and I2C) in slave mode. In SPI mode, only Motorola submode (all Motorola modes: 0, 1, 2, 3) is supported.

In UART mode this field should be '0'.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EC_OP_MODE</name>
              <description>This field specifies the clocking for the SCB block
'0': Internally clocked mode 
'1': externally clocked mode
 In internally clocked mode, the serial interface protocols run off the SCB clock. In externally clocked mode, the serial interface protocols run off the clock as provided by the serial interface. 

Externally clocked operation mode is only used for synchronous serial interface protocols (SPI and I2C) in slave mode AND EZ mode. In SPI mode, only Motorola submode (all Motorola modes: 0, 1, 2, 3) is supported. The maximum SPI slave, EZ mode bitrate is 48 Mbps (transmission and IO delays outside the IP will degrade the effective bitrate).

In UART mode this field should be '0'.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_MODE</name>
              <description>Non EZ mode ('0') or EZ mode ('1').
In EZ mode, a meta protocol is applied to the serial interface protocol. This meta protocol adds meaning to the data frames transferred by the serial interface protocol: a data frame can represent a memory address, a write memory data element or a read memory data element. EZ mode is only used for synchronous serial interface protocols: SPI and I2C. In SPI mode, only Motorola submode (all Motorola modes: 0, 1, 2, 3) is supported and the transmitter should use continuous data frames; i.e. data frames not seperated by slave deselection. This mode is only applicable to slave functionality. In EZ mode, the slave can read from and write to an addressable memory structure of 32 bytes. In EZ mode, data frames should 8-bit in size and should be transmitted and received with the Most Significant Bit (MSB) first.

In UART mode this field should be '0'.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMD_RESP_MODE</name>
              <description>N/A</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MEM_WIDTH</name>
              <description>N/A</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADDR_ACCEPT</name>
              <description>Determines whether a received matching address is accepted in the RX FIFO ('1') or not ('0').

In I2C mode, this field is used to allow the slave to put the received slave address or general call address in the RX FIFO. Note that a received matching address is put in the RX FIFO when this bit is '1' for both I2C read and write transfers.

In multi-processor UART receiver mode, this field is used to allow the receiver to put the received address in the RX FIFO. Note: non-matching addresses are never put in the RX FIFO.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCK</name>
              <description>Only used in externally clocked mode. If the externally clocked logic and the internal CPU accesses to EZ memory coincide/collide, this bit determines whether the CPU access should block and result in bus wait states ('BLOCK is 1') or not (BLOCK is '0'). IF BLOCK is '0' and the accesses collide, CPU read operations return 0xffff:ffff and CPU write operations are ignored. Colliding accesses are registered as interrupt causes: INTR_TX.BLOCKED and INTR_RX.BLOCKED.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>N/A</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>I2C</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SPI</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EC_ACCESS</name>
              <description>N/A</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>SCB block is enabled ('1') or not ('0'). The proper order in which to initialize SCB is as follows:
- Program protocol specific information using SPI_CTRL, UART_CTRL (and UART_TX_CTRL and UART_RX_CTRL) or I2C_CTRL registers. This includes selection of a submode, master/slave functionality and transmitter/receiver functionality when applicable.
- Program generic transmitter (TX_CTRL) and receiver (RX_CTRL) information. This includes enabling of the transmitter and receiver functionality.
- Program transmitter FIFO (TX_FIFO_CTRL) and receiver FIFO (RX_FIFO_CTRL) information.
- Program CTRL register to enable SCB, select the specific operation mode and oversampling factor.
When this block is enabled, no control information should be changed. Changes should be made AFTER disabling this block, e.g. to modify the operation mode (from I2C to SPI) or to go from externally to internally clocked. The change takes effect after the block is re-enabled. Note that disabling the block will cause re-initialization of the design and associated state is lost (e.g. FIFO content).</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>Generic status</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>EC_BUSY</name>
              <description>Inidicates whether the externally clocked logic is potentially accessing the EZ memory (this is only possible in EZ mode). This bit can be used by SW to determine whether it is safe to issue a SW access to the EZ memory (without bus wait states (a blocked SW access) or bus errors being generated). Note that the INTR_TX.BLOCKED and INTR_RX.BLOCKED interrupt causes are used to indicate whether a SW access was actually blocked by externally clocked logic.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMD_RESP_CTRL</name>
          <description>Command/response control</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1FF01FF</resetMask>
          <fields>
            <field>
              <name>BASE_RD_ADDR</name>
              <description>I2C/SPI read base address for CMD_RESP mode. At the start of a read transfer this BASE_RD_ADDR is copied to CMD_RESP_STATUS.CURR_RD_ADDR. This field should not be modified during ongoing bus transfers.</description>
              <bitRange>[8:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BASE_WR_ADDR</name>
              <description>I2C/SPI write base address for CMD_RESP mode. At the start of a write transfer this BASE_WR_ADDR is copied to CMD_RESP_STATUS.CURR_WR_ADDR. This field should not be modified during ongoing bus transfers.</description>
              <bitRange>[24:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMD_RESP_STATUS</name>
          <description>Command/response status</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>CURR_RD_ADDR</name>
              <description>I2C/SPI read current address for CMD_RESP mode. HW increments the field after a read access to the memory buffer. However, when the last memory buffer address is reached, the address is NOT incremented (but remains at the maximim memory buffer address). 

The field is used to determine how many bytes have been read (# bytes = CURR_RD_ADDR - CMD_RESP_CTRL.BASE_RD_ADDR). 

This field is reliable when there is no bus transfer. This field is potentially unreliable when there is a ongoing bus transfer, i.e. when CMD_RESP_EC_BUSY is '0', the field is reliable.</description>
              <bitRange>[8:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CURR_WR_ADDR</name>
              <description>I2C/SPI write current address for CMD_RESP mode. HW increments the field after a write access to the memory buffer. However, when the last memory buffer address is reached, the address is NOT incremented (but remains at the maximim memory buffer address).

The field is used to determine how many bytes have been written (# bytes = CURR_WR_ADDR - CMD_RESP_CTRL.BASE_WR_ADDR).

This field is reliable when there is no bus transfer. This field is potentially unreliable when there is a ongoing bus transfer, i.e when CMD_RESP_EC_BUSY is '0', the field is reliable.</description>
              <bitRange>[24:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CMD_RESP_EC_BUS_BUSY</name>
              <description>Indicates whether there is an ongoing bus transfer to the IP.
'0': no ongoing bus transfer.
'1': ongoing bus transfer.

For SPI, the field is '1' when slave mode is selected.

For I2C, the field is set to '1' at a I2C START/RESTART. In case of an address match, the  field is set to '0' on a I2C STOP. In case of NO address match, the field is set to '0' after the failing address match.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CMD_RESP_EC_BUSY</name>
              <description>N/A</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_CTRL</name>
          <description>SPI control</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3000010</resetValue>
          <resetMask>0x8F017F3F</resetMask>
          <fields>
            <field>
              <name>SSEL_CONTINUOUS</name>
              <description>Continuous SPI data transfers enabled ('1') or not ('0'). This field is used in master mode. In slave mode, both continuous and non-continuous SPI data transfers are supported independent of this field.

When continuous transfers are enabled individual data frame transfers are not necessarily seperated by slave deselection (as indicated by the level or pulse on the SELECT line): if the TX FIFO has multiple data frames, data frames are send out without slave deselection.

When continuous transfers are not enabled individual data frame transfers are always seperated by slave deselection: independent of the availability of TX FIFO data frames, data frames are sent out with slave deselection.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SELECT_PRECEDE</name>
              <description>Only used in SPI Texas Instruments' submode.

When '1', the data frame start indication is a pulse on the Slave SELECT line that precedes the transfer of the first data frame bit.

When '0', the data frame start indication is a pulse on the Slave SELECT line that coincides with the transfer of the first data frame bit.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPHA</name>
              <description>N/A</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPOL</name>
              <description>N/A</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LATE_MISO_SAMPLE</name>
              <description>Changes the SCLK edge on which MISO is captured. Only used in master mode.

When '0', the default applies (
for Motorola as determined by CPOL and CPHA, 
for Texas Instruments on the falling edge of SCLK and 
for National Semiconductors on the rising edge of SCLK). 

When '1', the alternate clock edge is used (which comes half a SPI SCLK period later). Late sampling addresses the round trip delay associated with transmitting SCLK from the master to the slave and transmitting MISO from the slave to the master.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SCLK_CONTINUOUS</name>
              <description>N/A</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_POLARITY0</name>
              <description>N/A</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_POLARITY1</name>
              <description>N/A</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_POLARITY2</name>
              <description>N/A</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_POLARITY3</name>
              <description>N/A</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_SETUP_DEL</name>
              <description>N/A</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_HOLD_DEL</name>
              <description>N/A</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_INTER_FRAME_DEL</name>
              <description>N/A</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOOPBACK</name>
              <description>Local loopback control (does NOT affect the information on the pins). Only used in master mode. Not used in National Semiconductors submode.
'0': No local loopback
'1': the SPI master MISO line is connected to the SPI master MOSI line. In other words, in loopback mode the SPI master receives on MISO what it transmits on MOSI.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>N/A</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SPI_MOTOROLA</name>
                  <description>SPI Motorola submode. In master mode, when not transmitting data (Slave SELECT is inactive), SCLK is stable at CPOL. In slave mode, when not selected, SCLK is ignored; i.e. it can be either stable or clocking. In master mode, when there is no data to transmit (TX FIFO is empty), Slave SELECT is inactive.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SPI_TI</name>
                  <description>SPI Texas Instruments submode. In master mode, when not transmitting data, SCLK is stable at '0'. In slave mode, when not selected, SCLK is ignored; i.e. it can be either stable or clocking. In master mode, when there is no data to transmit (TX FIFO is empty), Slave SELECT is inactive; i.e. no pulse is generated.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SPI_NS</name>
                  <description>SPI National Semiconducturs submode. In master mode, when not transmitting data, SCLK is stable at '0'. In slave mode, when not selected, SCLK is ignored; i.e. it can be either stable or clocking. In master mode, when there is no data to transmit (TX FIFO is empty), Slave SELECT is inactive.</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SSEL</name>
              <description>Selects one of the four incoming/outgoing SPI slave select signals:
- 0: Slave 0, SSEL[0].
- 1: Slave 1, SSEL[1].
- 2: Slave 2, SSEL[2].
- 3: Slave 3, SSEL[3].
SCB block should be disabled when changes are made to this field.</description>
              <bitRange>[27:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASTER_MODE</name>
              <description>N/A</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_STATUS</name>
          <description>SPI status</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>BUS_BUSY</name>
              <description>SPI bus is busy. The bus is considered busy ('1') during an ongoing transaction. For Motorola and National submodes, the busy bit is '1', when the slave selection is activated. For TI submode, the busy bit is '1' from the time the preceding/coinciding slave select is activated for the first transmitted data frame, till the last MOSI/MISO bit of the last data frame is transmitted.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_EC_BUSY</name>
              <description>Inidicates whether the externally clocked logic is potentially accessing the EZ memory and/or updating BASE_ADDR or CURR_ADDR (this is only possible in EZ mode). This bit can be used by SW to determine whether BASE_ADDR and CURR_ADDR are reliable.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CURR_EZ_ADDR</name>
              <description>SPI current EZ address. Current address pointer. This field is only reliable in internally clocked mode. In externally clocked mode the field may be unreliable (during an ongoing transfer when SPI_EC_BUSY is '1'), as clock domain synchronization is not performed in the design.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BASE_EZ_ADDR</name>
              <description>SPI base EZ address. Address as provided by a SPI write transfer. This field is only reliable in internally clocked mode. In externally clocked mode the field may be unreliable, as clock domain synchronization is not performed in the design.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_TX_CTRL</name>
          <description>SPI transmitter control</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x30</resetMask>
          <fields>
            <field>
              <name>PARITY</name>
              <description>Parity bit. When '0', the transmitter generates an even parity. When '1', the transmitter generates an odd parity. Only supported for internally clocked SPI operation.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ENABLED</name>
              <description>Parity generation enabled ('1') or not ('0'). Only supported for internally clocked SPI operation.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_RX_CTRL</name>
          <description>SPI receiver control</description>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x130</resetMask>
          <fields>
            <field>
              <name>PARITY</name>
              <description>Parity bit. When '0', the receiver expects an even parity. When '1', the receiver expects an odd parity. Only supported for internally clocked SPI operation.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ENABLED</name>
              <description>Parity checking enabled ('1') or not ('0'). Only supported for internally clocked SPI operation.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DROP_ON_PARITY_ERROR</name>
              <description>Behaviour when a parity check fails. When '0', received data is send to the RX FIFO. When '1', received data is dropped and lost. Only supported for internally clocked SPI operation.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_CTRL</name>
          <description>UART control</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3000000</resetValue>
          <resetMask>0x3010000</resetMask>
          <fields>
            <field>
              <name>LOOPBACK</name>
              <description>Local loopback control (does NOT affect the information on the pins). 
0: Loopback is not enabled
1: UART_TX is connected to UART_RX. UART_RTS is connected to UART_CTS.
This allows a SCB UART transmitter to communicate with its receiver counterpart.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>N/A</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>UART_STD</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART_SMARTCARD</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART_IRDA</name>
                  <description>Infrared Data Association (IrDA) submode. Return to Zero modulation scheme. In this mode, the oversampling factor should be 16, that is OVS should be set to 15.</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_TX_CTRL</name>
          <description>UART transmitter control</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2</resetValue>
          <resetMask>0x137</resetMask>
          <fields>
            <field>
              <name>STOP_BITS</name>
              <description>Stop bits. STOP_BITS + 1 is the duration of the stop period in terms of halve bit periods. Valid range is [1, 7]; i.e. a stop period should last at least one bit period.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY</name>
              <description>Parity bit. When '0', the transmitter generates an even parity. When '1', the transmitter generates an odd parity. Only applicable in standard UART and SmartCard submodes.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ENABLED</name>
              <description>Parity generation enabled ('1') or not ('0'). Only applicable in standard UART submodes. In SmartCard submode, parity generation is always enabled through hardware. In IrDA submode, parity generation is always disabled through hardware</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RETRY_ON_NACK</name>
              <description>When '1', a data frame is retransmitted when a negative acknowledgement is received. Only applicable to the SmartCard submode.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_RX_CTRL</name>
          <description>UART receiver control</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xA0002</resetValue>
          <resetMask>0x10F3777</resetMask>
          <fields>
            <field>
              <name>STOP_BITS</name>
              <description>N/A</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY</name>
              <description>N/A</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ENABLED</name>
              <description>N/A</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>POLARITY</name>
              <description>Inverts incoming RX line signal. Inversion is after local loopback. This functionality is intended for IrDA receiver functionality.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DROP_ON_PARITY_ERROR</name>
              <description>Behaviour when a parity check fails. 
When '0', received data is sent to the RX FIFO. 
When '1', received data is dropped and lost. 
Only applicable in standard UART and SmartCard submodes (negatively acknowledged SmartCard data frames may be dropped with this field).</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DROP_ON_FRAME_ERROR</name>
              <description>Behaviour when an error is detected in a start or stop period. 
When '0', received data is sent to the RX FIFO.
 When '1', received data is dropped and lost.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MP_MODE</name>
              <description>N/A</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_MODE</name>
              <description>Only applicable in standard UART submode. When '1', the receiver performs break detection and baud rate detection on the incoming data. First, break detection counts the amount of bit periods that have a line value of '0'. BREAK_WIDTH specifies the minum required amount of bit periods. Successful break detection sets the INTR_RX.BREAK_DETECT interrupt cause to '1'. Second, baud rate detection counts the amount of peripheral clock periods that are use to receive the synchronization byte (0x55; least significant bit first). The count is available through UART_RX_STATUS.BR_COUNTER. Successful baud rate detection sets the INTR_RX.BAUD_DETECT interrupt cause to '1' (BR_COUNTER is reliable). This functionality is used to synchronize/refine the receiver clock to the transmitter clock. The receiver software can use the BR_COUNTER value to set the right IP clock (from the programmable clock IP) to guarantee successful receipt of the first LIN data frame (Protected Identifier Field) after the synchronization byte.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SKIP_START</name>
              <description>N/A</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BREAK_WIDTH</name>
              <description>N/A</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BREAK_LEVEL</name>
              <description>N/A</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_RX_STATUS</name>
          <description>UART receiver status</description>
          <addressOffset>0x4C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>BR_COUNTER</name>
              <description>Amount of SCB clock periods that constitute the transmission of a 0x55 data frame (sent least signficant bit first) as determined by the receiver. BR_COUNTER / 8 is the amount of SCB clock periods that constitute a bit period. This field has valid data when INTR_RX.BAUD_DETECT is set to '1'.</description>
              <bitRange>[11:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_FLOW_CTRL</name>
          <description>UART flow control</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x30100FF</resetMask>
          <fields>
            <field>
              <name>TRIGGER_LEVEL</name>
              <description>Trigger level. When the receiver FIFO has less entries than the amount of this field, a Ready To Send (RTS) output signal is activated. By setting this field to '0', flow control is effectively disabled (may be useful for debug purposes).</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RTS_POLARITY</name>
              <description>Polarity of the RTS output signal:
'0': RTS is active low; 
'1': RTS is active high; 

During SCB reset (Hibernate system power mode), RTS output signal is '1'. This represents an inactive state assuming an active low polarity.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CTS_POLARITY</name>
              <description>Polarity of the CTS input signal
'0': CTS is active low ; 
'1': CTS is active high;</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CTS_ENABLED</name>
              <description>Enable use of CTS input signal by the UART transmitter:
'0': Disabled. The UART transmitter ignores the CTS input signal and transmits when a data frame is available for transmission in the TX FIFO or the TX shift register.
'1': Enabled. The UART transmitter uses CTS input signal to qualify the transmission of data. It transmits when CTS input signal is active and a data frame is available for transmission in the TX FIFO or the TX shift register.

If UART_CTRL.LOOPBACK is '1', the CTS input signal is driven by the RTS output signal locally in SCB (both signals are subjected to signal polarity changes are indicated by RTS_POLARITY and CTS_POLARITY).</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_CTRL</name>
          <description>I2C control</description>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFB88</resetValue>
          <resetMask>0xC001FBFF</resetMask>
          <fields>
            <field>
              <name>HIGH_PHASE_OVS</name>
              <description>Serial I2C interface high phase oversampling factor. HIGH_PHASE_OVS + 1 SCB clock periods constitute the high phase of a bit period. The valid range is [5, 15] with input signal median filtering and [4, 15] without input signal median filtering.

The field is only used in master mode. In slave mode, the field is NOT used. However, there is a frequency requirement for the SCB clock wrt. the regular interface (IF) high time to guarantee functional correct behavior. With input signal median filtering, the IF high time should be &gt;= 6 SCB clock cycles and &lt;= 16 SCB clock cycles. Without input signal median filtering, the IF high time should be &gt;= 5 SCB clock cycles and &lt;= 16 SCB clock cycles.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOW_PHASE_OVS</name>
              <description>Serial I2C interface low phase oversampling factor. LOW_PHASE_OVS + 1 SCB clock periods constitute the low phase of a bit period. The valid range is [7, 15] with input signal median filtering and [6, 15] without input signal median filtering. 

The field is only used in master mode. In slave mode, the field is NOT used. However, there is a frequency requirement for the SCB clock wrt. the regular (no stretching) interface (IF) low time to guarantee functionally correct behavior. With input signal median filtering, the IF low time should be &gt;= 8 SCB clock cycles and &lt;= 16 IP clock cycles. Without input signal median filtering, the IF low time should be &gt;= 7 SCB clock cycles and &lt;= 16 SCB clock cycles.

in slave mode, this field is used to define number of clk_scb cycles for tSU-DAT timing (from ACK/NACK/data ready, to SCL rising edge (released from I2C slave clock stretching))</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_READY_DATA_ACK</name>
              <description>N/A</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_NOT_READY_DATA_NACK</name>
              <description>N/A</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_GENERAL_IGNORE</name>
              <description>N/A</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_READY_ADDR_ACK</name>
              <description>N/A</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_READY_DATA_ACK</name>
              <description>N/A</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_NOT_READY_ADDR_NACK</name>
              <description>This field is used during an address match or general call address in internally clocked mode 
Only used when:
 - EC_AM_MODE is '0', EC_OP_MODE is '0', S_GENERAL_IGNORE is '0] and non EZ mode.
Functionality is as follows:
- 1: a received (matching) slave address is immediately NACK'd when the receiver FIFO is full.
- 0: clock stretching is performed (till the receiver FIFO is no longer full). 

For externally clocked logic (EC_AM is '1') on an address match or general call address (and S_GENERAL_IGNORE is '0'). Only used when (NOT used when EC_AM is '1' and EC_OP is '1' and address match and EZ mode):
- EC_AM is '1' and EC_OP is '0'.
- EC_AM is '1' and general call address match.
- EC_AM is '1' and non EZ mode.
Functionality is as follows:
- 1: a received (matching or general) slave address is always immediately NACK'd. There are two possibilities:
       1). the SCB clock is available (in Active system power mode) and it handles the rest of the current transfer. In this case the I2C master will not observe the NACK. 
       2).SCB clock is not present (in DeepSleep system power mode). In this case the I2C master will observe the NACK and may retry the transfer in the future (which gives the internally clocked logic the time to wake up from DeepSleep system power mode). 
- 0: clock stretching is performed (till the SCB clock is available). The logic will handle the ongoing transfer as soon as the clock is enabled.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_NOT_READY_DATA_NACK</name>
              <description>Only used when:
- non EZ mode
Functionality is as follows:
- 1: a received data element byte the slave is immediately NACK'd when the receiver FIFO is full.
- 0: clock stretching is performed (till the receiver FIFO is no longer full).</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOOPBACK</name>
              <description>Local loopback control (does NOT affect the information on the pins). Only applicable in master/slave mode. 
When '0', no loopback
When '1', loopback is enabled internally in the peripheral, and as a result unaffected by other I2C devices. This allows a SCB I2C peripheral to address itself.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SLAVE_MODE</name>
              <description>N/A</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASTER_MODE</name>
              <description>N/A</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_STATUS</name>
          <description>I2C status</description>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x35</resetMask>
          <fields>
            <field>
              <name>BUS_BUSY</name>
              <description>I2C bus is busy. The bus is considered busy ('1'), from the time a START is detected or from the time the SCL line is '0'. The bus is considered idle ('0'), from the time a STOP is detected. If SCB block is disabled, BUS_BUSY is '0'. After enabling the block, it takes time for the BUS_BUSY to detect a busy bus. This time is the maximum high time of the SCL line. For a 100 kHz interface frequency, this maximum high time may last roughly 5 us (half a bit period).

For single master systems, BUS_BUSY does not have to be used to detect an idle bus before a master starts a transfer using I2C_M_CMD.M_START (no bus collisions).

For multi-master systems, BUS_BUSY can be used to detect an idle bus before a master starts a transfer using I2C_M_CMD.M_START_ON_IDLE (to prevent bus collisions).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_EC_BUSY</name>
              <description>N/A</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2CS_IC_BUSY</name>
              <description>N/A</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>S_READ</name>
              <description>N/A</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>M_READ</name>
              <description>N/A</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CURR_EZ_ADDR</name>
              <description>N/A</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BASE_EZ_ADDR</name>
              <description>N/A</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_M_CMD</name>
          <description>I2C master command</description>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>M_START</name>
              <description>When '1', transmit a START or REPEATED START. Whether a START or REPEATED START is transmitted depends on the state of the master state machine. A START is only transmitted when the master state machine is in the default state. A REPEATED START is transmitted when the master state machine is not in the default state, but is working on an ongoing transaction. The REPEATED START can only be transmitted after a NACK or ACK has been received for a transmitted data element or after a NACK has been transmitted for a received data element. When this action is performed, the hardware sets this field to '0'.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_START_ON_IDLE</name>
              <description>When '1', transmit a START as soon as the bus is idle (I2C_STATUS.BUS_BUSY is '0', note that BUSY has a default value of '0'). For bus idle detection the hardware relies on STOP detection. As a result, bus idle detection is only functional after at least one I2C bus transfer has been detected on the bus (default/reset value of BUSY is '0') . A START is only transmitted when the master state machine is in the default state. When this action is performed, the hardware sets this field to '0'.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_ACK</name>
              <description>When '1', attempt to transmit an acknowledgement (ACK). When this action is performed, the hardware sets this field to '0'.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_NACK</name>
              <description>When '1', attempt to transmit a negative acknowledgement (NACK). When this action is performed, the hardware sets this field to '0'.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_STOP</name>
              <description>When '1', attempt to transmit a STOP. When this action is performed, the hardware sets this field to '0'. 
 I2C_M_CMD.M_START has a higher priority than this command: in situations where both a STOP and a REPEATED START could be transmitted, M_START takes precedence over M_STOP.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_S_CMD</name>
          <description>I2C slave command</description>
          <addressOffset>0x6C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>S_ACK</name>
              <description>When '1', attempt to transmit an acknowledgement (ACK). When this action is performed, the hardware sets this field to '0'. In EZ mode, this field should be set to '0' (it is only to be used in non EZ mode).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_NACK</name>
              <description>When '1', attempt to transmit a negative acknowledgement (NACK). When this action is performed, the hardware sets this field to '0'.  In EZ mode, this field should be set to '0' (it is only to be used in non EZ mode). This command has a higher priority than I2C_S_CMD.S_ACK, I2C_CTRL.S_READY_ADDR_ACK or I2C_CTRL.S_READY_DATA_ACK.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_CFG</name>
          <description>I2C configuration</description>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2A1013</resetValue>
          <resetMask>0x303F1313</resetMask>
          <fields>
            <field>
              <name>SDA_IN_FILT_TRIM</name>
              <description>Trim settings for the 50ns glitch filter on the SDA input. Default setting meets the I2C glitch rejections specs. Programmability available if required</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_IN_FILT_SEL</name>
              <description>Enable for 50ns glitch filter on SDA input
'0': 0 ns.
'1: 50 ns (filter enabled).</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SCL_IN_FILT_TRIM</name>
              <description>Trim settings for the 50ns glitch filter on the SDA input. Default setting meets the I2C glitch rejections specs. Programmability available if required</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SCL_IN_FILT_SEL</name>
              <description>Enable for 50ns glitch filter on SCL input
'0': 0 ns.
'1: 50 ns (filter enabled).</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_OUT_FILT0_TRIM</name>
              <description>Trim settings for the 50ns delay filter on SDA output used to gurantee tHD_DAT I2C parameter. Default setting meets the I2C spec. Programmability available if required</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_OUT_FILT1_TRIM</name>
              <description>Trim settings for the 50ns delay filter on SDA output used to gurantee tHD_DAT I2C parameter. Default setting meets the I2C spec. Programmability available if required</description>
              <bitRange>[19:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_OUT_FILT2_TRIM</name>
              <description>Trim settings for the 50ns delay filter on SDA output used to gurantee tHD_DAT I2C parameter. Default setting meets the I2C spec. Programmability available if required</description>
              <bitRange>[21:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_OUT_FILT_SEL</name>
              <description>Selection of cumulative filter delay on SDA output to meet tHD_DAT parameter
'0': 0 ns.
'1': 50 ns (filter 0 enabled).
'2': 100 ns (filters 0 and 1 enabled).
'3': 150 ns (filters 0, 1 and 2 enabled).</description>
              <bitRange>[29:28]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DDFT_CTRL</name>
          <description>Digital DfT control</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x770011</resetMask>
          <fields>
            <field>
              <name>DDFT_IN0_SEL</name>
              <description>Specifies signal that is connected to 'ddft_in[0]' (digital DfT input signal 0):
'0': not used
'1': used as 'i2c_scl_in' in I2C mode, as 'spi_clk_in' in SPI mode</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DDFT_IN1_SEL</name>
              <description>Specifies signal that is connected to 'ddft_in[1]' (digital DfT input signal 0):
'0': not used
'1': used as 'i2c_sda_in' in I2C mode, as 'spi_mosi_in' in SPI mode</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DDFT_OUT0_SEL</name>
              <description>Specifies signal that is connected to 'ddft_out[0]' (digital DfT output signal 0):
In I2C mode (CTRL.MODE=0),
'0': Constant '0'. 
'1': 'ec_busy_pp'.
'2': 'rst_i2c_start_stop_n'.
'3': 'rst_i2c_start_stop_n'.
'4': 'i2c_scl_in_qual'.
'5': 'i2c_sda_out_prel'.
'6'-'7': Undefined.
in SPI mode (CTRL.MODE=1),
'0': Constant '0'. 
'1': 'rst_spi_n'
'2': 'rst_spi_stop_n'
'3'-'7': Undefined.</description>
              <bitRange>[18:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DDFT_OUT1_SEL</name>
              <description>Specifies signal that is connected to 'ddft_out[1]' (digital DfT output signal 1):
In I2C mode (CTRL.MODE=0),
'0': Constant '0'. 
'1': 'clk_ff_sram'.
'2': 'rst_i2c_n'.
'3': 'rst_i2c_stop_n'.
'4': 'i2c_sda_in_qual'.
'5': 'i2c_sda_out'.
'6': 'event_i2c_ec_wake_up_ddft' from I2CS_IC
'7': Undefined.
In SPI mode (CTRL.MODE=1),
'0': Constant '0'. 
'1': 'spi_start_detect'
'2': 'spi_stop_detect'
'3'-'7': Undefined.</description>
              <bitRange>[22:20]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_CTRL</name>
          <description>Transmitter control</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x107</resetValue>
          <resetMask>0x1011F</resetMask>
          <fields>
            <field>
              <name>DATA_WIDTH</name>
              <description>Dataframe width. DATA_WIDTH + 1 is the amount of bits in a transmitted data frame. This number does not include start, parity and stop bits. For UART mode, the valid range is [3, 8]. For SPI, the valid range is [3, 31]. For I2C the only valid value is 7.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MSB_FIRST</name>
              <description>Least significant bit first ('0') or most significant bit first ('1'). For I2C, this field should be '1'.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OPEN_DRAIN</name>
              <description>Each IO cell 'xxx' has two associated IP output signals 'xxx_out_en' and 'xxx_out'.
'0': Normal operation mode. Typically, this operation mode is used for IO cells that are connected to (board) wires/lines that are driven by a single IO cell. In this operation mode, for an IO cell 'xxx' that is used as an output, the 'xxx_out_en' output enable signal is typically constant '1' the 'xxx_out' output is the outputted value. In other words, in normal operation mode, the 'xxx_out' output is used to control the IO cell output value: 'xxx_out' is '0' to drive an IO cell output value of '0' and 'xxx_out' is '1' to drive an IO cell output value of '1'.
'1': Open drain operation mode. Typically this operation mode is used for IO cells that are connected to (board) wires/lines that are driven by multiple IO cells (possibly on multiple chips). In this operation mode, for and IO cell 'xxx' that is used as an output, the 'xxx_out_en' output controls the outputted value. Typically, open drain operation mode drives low/'0' and the 'xxx_out' output is constant '1'. In other words, in open drain operation mode, the 'xxx_out_en' output is used to control the IO cell output value: in drive low/'0' mode: 'xxx_out_en' is '1' (drive enabled) to drive an IO cell output value of '0' and 'xxx_out_en' is '1' (drive disabled) to not drive an IO cell output value (another IO cell can drive the wire/line or a pull up results in a wire/line value '1').

The open drain mode is supported for:
- I2C mode, 'i2c_scl' and 'i2c_sda' IO cells.
- UART mode, 'uart_tx' IO cell (SPI slave).
- SPI mode, 'spi_miso' IO cell.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_FIFO_CTRL</name>
          <description>Transmitter FIFO control</description>
          <addressOffset>0x204</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x300FF</resetMask>
          <fields>
            <field>
              <name>TRIGGER_LEVEL</name>
              <description>Trigger level. When the transmitter FIFO has less entries than the number of this field, a transmitter trigger event is generated.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLEAR</name>
              <description>When '1', the transmitter FIFO and transmitter shift register are cleared/invalidated. Invalidation will last for as long as this field is '1'. If a quick clear/invalidation is required, the field should be set to '1' and be followed by a set to '0'. If a clear/invalidation is required for an extended time period, the field should be set to '1' during the complete time period.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FREEZE</name>
              <description>When '1', hardware reads from the transmitter FIFO do not remove FIFO entries. Freeze will not advance the TX FIFO read pointer.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_FIFO_STATUS</name>
          <description>Transmitter FIFO status</description>
          <addressOffset>0x208</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF81FF</resetMask>
          <fields>
            <field>
              <name>USED</name>
              <description>Amount of enties in the transmitter FIFO. The value of this field ranges from 0 to FF_DATA_NR.</description>
              <bitRange>[8:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SR_VALID</name>
              <description>Indicates whether the TX shift registers holds a valid data frame ('1') or not ('0'). The shift register can be considered the top of the TX FIFO (the data frame is not included in the USED field of the TX FIFO). The shift register is a working register and holds the data frame that is currently transmitted (when the protocol state machine is transmitting a data frame) or the data frame that is tranmitted next (when the protocol state machine is not transmitting a data frame).</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RD_PTR</name>
              <description>FIFO read pointer: FIFO location from which a data frame is read by the hardware.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>WR_PTR</name>
              <description>FIFO write pointer: FIFO location at which a new data frame is written.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_FIFO_WR</name>
          <description>Transmitter FIFO write</description>
          <addressOffset>0x240</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Data frame written into the transmitter FIFO. Behavior is similar to that of a PUSH operation. Note that when CTRL.MEM_WIDTH is '0', only DATA[7:0] are used and when CTRL.MEM_WIDTH is '1', only DATA[15:0] are used.

A write to a full TX FIFO sets INTR_TX.OVERFLOW to '1'.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_CTRL</name>
          <description>Receiver control</description>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x107</resetValue>
          <resetMask>0x31F</resetMask>
          <fields>
            <field>
              <name>DATA_WIDTH</name>
              <description>Dataframe width. DATA_WIDTH + 1 is the expected amount of bits in received data frame. This number does not include start, parity and stop bits. For UART mode, the valid range is [3, 8]. For SPI, the valid range is [3, 31]. For I2C the only valid value is 7. In EZ mode (for both SPI and I2C), the only valid value is 7.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MSB_FIRST</name>
              <description>Least significant bit first ('0') or most significant bit first ('1'). For I2C, this field should be '1'.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MEDIAN</name>
              <description>Median filter. When '1', a digital 3 taps median filter is performed on input interface lines. This filter should reduce the susceptability to errors. However, its requires higher oversampling values. For UART IrDA submode, this field should always be '1'.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_FIFO_CTRL</name>
          <description>Receiver FIFO control</description>
          <addressOffset>0x304</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x300FF</resetMask>
          <fields>
            <field>
              <name>TRIGGER_LEVEL</name>
              <description>Trigger level. When the receiver FIFO has more entries than the number of this field, a receiver trigger event is generated.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLEAR</name>
              <description>When '1', the receiver FIFO and receiver shift register are cleared/invalidated. Invalidation will last for as long as this field is '1'. If a quick clear/invalidation is required, the field should be set to '1' and be followed by a set to '0'. If a clear/invalidation is required for an extended time period, the field should be set to '1' during the complete time period.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FREEZE</name>
              <description>When '1', hardware writes to the receiver FIFO have no effect. Freeze will not advance the RX FIFO write pointer.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_FIFO_STATUS</name>
          <description>Receiver FIFO status</description>
          <addressOffset>0x308</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF81FF</resetMask>
          <fields>
            <field>
              <name>USED</name>
              <description>Amount of enties in the receiver FIFO. The value of this field ranges from 0 to FF_DATA_NR.</description>
              <bitRange>[8:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SR_VALID</name>
              <description>Indicates whether the RX shift registers holds a (partial) valid data frame ('1') or not ('0'). The shift register can be considered the bottom of the RX FIFO (the data frame is not included in the USED field of the RX FIFO). The shift register is a working register and holds the data frame that is currently being received (when the protocol state machine is receiving a data frame).</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RD_PTR</name>
              <description>FIFO read pointer: FIFO location from which a data frame is read.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>WR_PTR</name>
              <description>FIFO write pointer: FIFO location at which a new data frame is written by the hardware.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_MATCH</name>
          <description>Slave address and mask</description>
          <addressOffset>0x310</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF00FF</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>N/A</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK</name>
              <description>Slave device address mask. This field is a mask that specifies which of the slave address bits take part in the matching. MATCH = ((ADDR &amp; MASK) == ('slave address' &amp; MASK)).</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_FIFO_RD</name>
          <description>Receiver FIFO read</description>
          <addressOffset>0x340</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Data read from the receiver FIFO. Reading a data frame will remove the data frame from the FIFO; i.e. behavior is similar to that of a POP operation. Note that when CTRL.MEM_WIDTH is '0', only DATA[7:0] are used and when CTRL.MEM_WIDTH is '1', only DATA[15:0] are used

A read from an empty RX FIFO sets INTR_RX.UNDERFLOW to '1'.

When this register is read through the debugger, the data frame will not be removed from the FIFO. Similar in operation to RX_FIFO_RD_SILENT</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_FIFO_RD_SILENT</name>
          <description>Receiver FIFO read silent</description>
          <addressOffset>0x344</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Data read from the receiver FIFO. Reading a data frame will NOT remove the data frame from the FIFO; i.e. behavior is similar to that of a PEEK operation. Note that when CTRL.MEM_WIDTH is '0', only DATA[7:0] are used and when CTRL.MEM_WIDTH is '1', only DATA[15:0] are used

A read from an empty RX FIFO sets INTR_RX.UNDERFLOW to '1'.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_CAUSE</name>
          <description>Active clocked interrupt signal</description>
          <addressOffset>0xE00</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>M</name>
              <description>Master interrupt active ('interrupt_master'): INTR_M_MASKED != 0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>S</name>
              <description>Slave interrupt active ('interrupt_slave'): INTR_S_MASKED != 0.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TX</name>
              <description>Transmitter interrupt active ('interrupt_tx'): INTR_TX_MASKED != 0.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RX</name>
              <description>Receiver interrupt active ('interrupt_rx'): INTR_RX_MASKED != 0.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_EC</name>
              <description>Externally clock I2C interrupt active ('interrupt_i2c_ec'): INTR_I2C_EC_MASKED != 0.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_EC</name>
              <description>Externally clocked SPI interrupt active ('interrupt_spi_ec'): INTR_SPI_EC_MASKED != 0.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_I2C_EC</name>
          <description>Externally clocked I2C interrupt request</description>
          <addressOffset>0xE80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Wake up request. Active on incoming slave request (with address match).

Only used when CTRL.EC_AM_MODE is '1'.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>STOP detection. Activated on the end of a every transfer (I2C STOP).

Only available for a slave request with an address match, in EZ and CMD_RESP modes, when CTRL.EC_OP_MODE is '1'.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>STOP detection after a write transfer occurred. Activated on the end of a write transfer (I2C STOP). This event is an indication that a buffer memory location has been written to. For EZ mode: a  transfer that only writes the base address does NOT activate this event. 

Only available for a slave request with an address match, in EZ and CMD_RESP modes, when CTRL.EC_OP_MODE is '1'.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>STOP detection after a read transfer occurred. Activated on the end of a read transfer (I2C STOP). This event is an indication that a buffer memory location has been read from.

Only available for a slave request with an address match, in EZ and CMD_RESP modes, when CTRL.EC_OP_MODE is '1'.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_I2C_EC_MASK</name>
          <description>Externally clocked I2C interrupt mask</description>
          <addressOffset>0xE88</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_I2C_EC_MASKED</name>
          <description>Externally clocked I2C interrupt masked</description>
          <addressOffset>0xE8C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SPI_EC</name>
          <description>Externally clocked SPI interrupt request</description>
          <addressOffset>0xEC0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Wake up request. Active on incoming slave request when externally clocked selection is '1'.

Only used when CTRL.EC_AM_MODE is '1'.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>STOP detection. Activated on the end of a every transfer (SPI deselection).

Only available in EZ and CMD_RESP mode and when CTRL.EC_OP_MODE is '1'.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>STOP detection after a write transfer occurred. Activated on the end of a write transfer (SPI deselection). This event is an indication that a buffer memory location has been written to. For EZ mode: a  transfer that only writes the base address does NOT activate this event. 

Only used in EZ and CMD_RESP modes and when CTRL.EC_OP_MODE is '1'.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>STOP detection after a read transfer occurred. Activated on the end of a read transfer (SPI deselection). This event is an indication that a buffer memory location has been read from.

Only used in EZ and CMD_RESP modes and when CTRL.EC_OP_MODE is '1'.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SPI_EC_MASK</name>
          <description>Externally clocked SPI interrupt mask</description>
          <addressOffset>0xEC8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SPI_EC_MASKED</name>
          <description>Externally clocked SPI interrupt masked</description>
          <addressOffset>0xECC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_M</name>
          <description>Master interrupt request</description>
          <addressOffset>0xF00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x317</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>I2C master lost arbitration: the value driven by the master on the SDA line is not the same as the value observed on the SDA line.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>I2C master negative acknowledgement. Set to '1', when the master receives a NACK (typically after the master transmitted the slave address or TX data).</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>I2C master acknowledgement. Set to '1', when the master receives a ACK (typically after the master transmitted the slave address or TX data).</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>I2C master STOP. Set to '1', when the master has transmitted a STOP.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>I2C master bus error (unexpected detection of START or STOP condition).</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_DONE</name>
              <description>SPI master transfer done event: all data frames in the transmit FIFO are sent, the transmit FIFO is empty (both TX FIFO and transmit shifter register are empty), and SPI select output pin is deselected.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_M_SET</name>
          <description>Master interrupt set request</description>
          <addressOffset>0xF04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x317</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_DONE</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_M_MASK</name>
          <description>Master interrupt mask</description>
          <addressOffset>0xF08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x317</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_DONE</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_M_MASKED</name>
          <description>Master interrupt masked request</description>
          <addressOffset>0xF0C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x317</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_DONE</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_S</name>
          <description>Slave interrupt request</description>
          <addressOffset>0xF40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>I2C slave lost arbitration: the value driven on the SDA line is not the same as the value observed on the SDA line (while the SCL line is '1'). This should not occur, it represents erroneous I2C bus behavior. In case of lost arbitration, the I2C slave state machine aborts the ongoing transfer. The Firmware may decide to clear the TX and RX FIFOs in case of this error.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>N/A</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>N/A</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_WRITE_STOP</name>
              <description>N/A</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>N/A</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_START</name>
              <description>I2C slave START received. Set to '1', when START or REPEATED START event is detected.

In the case of externally clocked address matching (CTRL.EC_AM_MODE is '1') AND clock stretching is performed (I2C_CTRL.S_NOT_READY_ADDR_NACK is '0'), this field is NOT set. The Firmware should use INTR_S_EC.WAKE_UP, INTR_S.I2C_ADDR_MATCH and INTR_S.I2C_GENERAL.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ADDR_MATCH</name>
              <description>N/A</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_GENERAL</name>
              <description>N/A</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>N/A</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_EZ_WRITE_STOP</name>
              <description>N/A</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_EZ_STOP</name>
              <description>N/A</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_BUS_ERROR</name>
              <description>N/A</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_S_SET</name>
          <description>Slave interrupt set request</description>
          <addressOffset>0xF44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_WRITE_STOP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_START</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ADDR_MATCH</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_GENERAL</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_EZ_WRITE_STOP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_EZ_STOP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_BUS_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_S_MASK</name>
          <description>Slave interrupt mask</description>
          <addressOffset>0xF48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_WRITE_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_START</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ADDR_MATCH</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_GENERAL</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_EZ_WRITE_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_EZ_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_BUS_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_S_MASKED</name>
          <description>Slave interrupt masked request</description>
          <addressOffset>0xF4C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_WRITE_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_START</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_ADDR_MATCH</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_GENERAL</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_EZ_WRITE_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_EZ_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_BUS_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_TX</name>
          <description>Transmitter interrupt request</description>
          <addressOffset>0xF80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7F3</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>N/A</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_FULL</name>
              <description>N/A</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMPTY</name>
              <description>N/A</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>N/A</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Attempt to read from an empty TX FIFO. This happens when SCB is ready to transfer data and EMPTY is '1'.

Only used in FIFO mode.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>SW cannot get access to the EZ memory (EZ data access), due to an externally clocked EZ access. This may happen when STATUS.EC_BUSY is '1'.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_NACK</name>
              <description>N/A</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_DONE</name>
              <description>N/A</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_ARB_LOST</name>
              <description>N/A</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_TX_SET</name>
          <description>Transmitter interrupt set request</description>
          <addressOffset>0xF84</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7F3</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_FULL</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMPTY</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_NACK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_DONE</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_ARB_LOST</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_TX_MASK</name>
          <description>Transmitter interrupt mask</description>
          <addressOffset>0xF88</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7F3</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_FULL</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMPTY</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_NACK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_DONE</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_ARB_LOST</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_TX_MASKED</name>
          <description>Transmitter interrupt masked request</description>
          <addressOffset>0xF8C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7F3</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NOT_FULL</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EMPTY</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UART_NACK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UART_DONE</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UART_ARB_LOST</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_RX</name>
          <description>Receiver interrupt request</description>
          <addressOffset>0xFC0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFED</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>N/A</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_EMPTY</name>
              <description>N/A</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FULL</name>
              <description>N/A</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>N/A</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>N/A</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>SW cannot get access to the EZ memory (EZ_DATA accesses), due to an externally clocked EZ access. This may happen when STATUS.EC_BUSY is '1'.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FRAME_ERROR</name>
              <description>N/A</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ERROR</name>
              <description>N/A</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BAUD_DETECT</name>
              <description>N/A</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BREAK_DETECT</name>
              <description>N/A</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_RX_SET</name>
          <description>Receiver interrupt set request</description>
          <addressOffset>0xFC4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFED</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_EMPTY</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FULL</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FRAME_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BAUD_DETECT</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BREAK_DETECT</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_RX_MASK</name>
          <description>Receiver interrupt mask</description>
          <addressOffset>0xFC8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFED</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_EMPTY</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FULL</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FRAME_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BAUD_DETECT</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BREAK_DETECT</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_RX_MASKED</name>
          <description>Receiver interrupt masked request</description>
          <addressOffset>0xFCC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFED</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NOT_EMPTY</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FULL</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FRAME_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PARITY_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BAUD_DETECT</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BREAK_DETECT</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="SCB0">
      <name>SCB1</name>
      <baseAddress>0x40610000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="SCB0">
      <name>SCB2</name>
      <baseAddress>0x40620000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="SCB0">
      <name>SCB3</name>
      <baseAddress>0x40630000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="SCB0">
      <name>SCB4</name>
      <baseAddress>0x40640000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="SCB0">
      <name>SCB5</name>
      <baseAddress>0x40650000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="SCB0">
      <name>SCB6</name>
      <baseAddress>0x40660000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="SCB0">
      <name>SCB7</name>
      <baseAddress>0x40670000</baseAddress>
    </peripheral>
    <peripheral>
      <name>SAR0</name>
      <description>SAR ADC with Sequencer for S40E</description>
      <headerStructName>SAR</headerStructName>
      <baseAddress>0x40900000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>4096</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTL</name>
          <description>Analog control register.</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xE00007FF</resetMask>
          <fields>
            <field>
              <name>PWRUP_TIME</name>
              <description>Number cycles to wait to power up after IDLE_PWRDWN.
Check the STATUS.PWRUP_BUSY flag to see if the delay is still in progress.
The power up delay is 1 us.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IDLE_PWRDWN</name>
              <description>When idle automatcially power down the analog.
After an automatic power down a new trigger will power up the analog, however it will take PWRUP_TIME cycles before the first acquisition can be started. Note that re-arbitration happens at that time, i.e. the trigger that caused the power up may not get handled first.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MSB_STRETCH</name>
              <description>When set use 2 cycles for the Most Significant Bit (MSB)
- 0: Use 1 clock cycle for MSB
- 1: Use 2 clock cycles for MSB</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HALF_LSB</name>
              <description>When set take an extra cycle to convert the half LSB and add it to 12-bit result for Missing Code Recovery
This bit should always be set to '1'
- 0: disable half LSB conversion (not recommended)
- 1: enable half LSB conversion</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SARMUX_EN</name>
              <description>Enable the SARMUX (only valid if ENABLED=1)
- 0: SARMUX disabled (put analog in power down)
- 1: SARMUX enabled.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_EN</name>
              <description>Enable the SAR ADC and SAR sequencer (only valid if ENABLED=1)
- 0: SARADC and SARSEQ are disabled (put SARADC analog in power down and stop clocks), also clears all pending triggers.
- 1: SAR ADC and SARSEQ are enabled.
To enable ADC0 to borrow SARMUX1-3 the corresponding ADC_EN must  be set to 0.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>- 0: SAR IP disabled (put analog in power down and stop clocks), also clears all pending triggers.
- 1: SAR IP enabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DIAG_CTL</name>
          <description>Diagnostic Reference control register.</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x8000000F</resetMask>
          <fields>
            <field>
              <name>DIAG_SEL</name>
              <description>Select Diagnostic Reference function</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>VREFL</name>
                  <description>DiagOut = VrefL</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VREFH_1DIV8</name>
                  <description>DiagOut = VrefH * 1/8</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VREFH_2DIV8</name>
                  <description>DiagOut = VrefH * 2/8</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VREFH_3DIV8</name>
                  <description>DiagOut = VrefH * 3/8</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VREFH_4DIV8</name>
                  <description>DiagOut = VrefH * 4/8</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VREFH_5DIV8</name>
                  <description>DiagOut = VrefH * 5/8</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VREFH_6DIV8</name>
                  <description>DiagOut = VrefH * 6/8</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VREFH_7DIV8</name>
                  <description>DiagOut = VrefH * 7/8</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VREFH</name>
                  <description>DiagOut = VrefH</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VREFX</name>
                  <description>DiagOut = VrefX = VrefH * 199/200</description>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VBG</name>
                  <description>DiagOut = Vbg from SRSS</description>
                  <value>10</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VIN1</name>
                  <description>DiagOut = Vin1</description>
                  <value>11</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VIN2</name>
                  <description>DiagOut = Vin2</description>
                  <value>12</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VIN3</name>
                  <description>DiagOut = Vin3</description>
                  <value>13</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I_SOURCE</name>
                  <description>DiagOut = Isource (10uA)</description>
                  <value>14</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I_SINK</name>
                  <description>DiagOut = Isink (10uA)</description>
                  <value>15</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DIAG_EN</name>
              <description>Diagnostic Reference enable (only valid if ENABLED=1)
- 0: Diagnostic Reference disabled (powered down resistor ladder and current mirrors, DiagOut = Vssa).
- 1: Diagnostic Reference enabled, output signal select according to DIAG_SEL (note also EPASS_MMIO.PASS_CTL.REFBUF_EN must be set).</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PRECOND_CTL</name>
          <description>Preconditioning control register.</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>PRECOND_TIME</name>
              <description>Number ADC clock cycles that Preconditioning is done before the sample window starts. If OVERLAP_EN=0 there will be 1 additional break before make cycle between preconditioning and sampling.
Note that the minimum value is 1 (0 gives the same result as 1).</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ANA_CAL</name>
          <description>Current analog calibration values</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1F00FF</resetMask>
          <fields>
            <field>
              <name>AOFFSET</name>
              <description>Analog offset correction</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>AGAIN</name>
              <description>Analog gain correction</description>
              <bitRange>[20:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DIG_CAL</name>
          <description>Current digital calibration values</description>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F0FFF</resetMask>
          <fields>
            <field>
              <name>DOFFSET</name>
              <description>Digital offset correction
Subtract DOFFSET from ADC output.</description>
              <bitRange>[11:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DGAIN</name>
              <description>Digital gain correction.
Signed value to correct +/- 30 codes for the maximum input voltage.
Corrected = (D - DOFFSET) + ( (D - DOFFSET) * DGAIN + 0x800) / 0x1000</description>
              <bitRange>[21:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ANA_CAL_ALT</name>
          <description>Alternate analog calibration values</description>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1F00FF</resetMask>
          <fields>
            <field>
              <name>AOFFSET</name>
              <description>See corresponding ANA_CAL field</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>AGAIN</name>
              <description>See corresponding ANA_CAL field</description>
              <bitRange>[20:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DIG_CAL_ALT</name>
          <description>Alternate digital calibration values</description>
          <addressOffset>0x94</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F0FFF</resetMask>
          <fields>
            <field>
              <name>DOFFSET</name>
              <description>See corresponding DIG_CAL field</description>
              <bitRange>[11:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DGAIN</name>
              <description>See corresponding DIG_CAL field</description>
              <bitRange>[21:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAL_UPD_CMD</name>
          <description>Calibration update command</description>
          <addressOffset>0x98</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>UPDATE</name>
              <description>Calibration update command: coherently copy values from alternate calibration regs to current calibration regs.
Software sets this bit when the alternate calibration values have been set with the new values. Hardware will do the calibration update as soon as the ADC is idle or a 'continuous' triggered group completes. This ensures that all acquisitions within a group scan (even if preempted) are done with the same calibration values.
This bit is cleared at the same time the calibration update is done. By clearing this bit software can cancel a requested update.
Note: if the ADC is always busy with acquisitions for non continuously triggered groups/channels then the calibration update will remain pending forever. In such a case the software can either  do a non coherent update by writing directly to the current calibration registers, or software can force the ADC to idle by disabling some or all channels.
Software can check/poll this bit to see if the calibration update has taken effect.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TR_PEND</name>
          <description>Trigger pending status</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TR_PEND</name>
              <description>Trigger Pending. 
Hardware will set this bit if a hardware trigger is received.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WORK_VALID</name>
          <description>Channel working data register 'valid' bits</description>
          <addressOffset>0x180</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WORK_VALID</name>
              <description>If set the corresponding WORK register is valid, i.e. was already acquired during the current group scan. If this bit is low then either the channel is not enabled, not yet acquired or it is used as a pulse detect channel.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WORK_RANGE</name>
          <description>Range detected</description>
          <addressOffset>0x184</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RANGE</name>
              <description>N/A</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WORK_RANGE_HI</name>
          <description>Range detect above Hi flag</description>
          <addressOffset>0x188</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ABOVE_HI</name>
              <description>Out of range was detected and the value was above the Hi threshold</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WORK_PULSE</name>
          <description>Pulse detected</description>
          <addressOffset>0x18C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PULSE</name>
              <description>N/A</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RESULT_VALID</name>
          <description>Channel result data register 'valid' bits</description>
          <addressOffset>0x1A0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RESULT_VALID</name>
              <description>If set the corresponding RESULT register is valid, i.e. was acquired during the preceding group scan. If this bit is low, after a group scan completed, then either the channel is not enabled or is used as a pulse  detect channel.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RESULT_RANGE_HI</name>
          <description>Channel Range above Hi flags</description>
          <addressOffset>0x1A4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ABOVE_HI</name>
              <description>Out of range was detected and the value was above the Hi threshold</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>Current status of internal SAR registers (mostly for debug)</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xE000371F</resetMask>
          <fields>
            <field>
              <name>CUR_CHAN</name>
              <description>current channel being acquired, only valid if BUSY.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CUR_PRIO</name>
              <description>priority of current group/channel, only valid if BUSY.</description>
              <bitRange>[10:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CUR_PREEMPT_TYPE</name>
              <description>Preempting type of current group/channel, only valid if BUSY.</description>
              <bitRange>[13:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DBG_FREEZE</name>
              <description>If high then the SAR is prevented from starting a new acquisition, see DBG_FREEZE_EN.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PWRUP_BUSY</name>
              <description>If high then the SAR is waiting for PWRUP_TIME due to IDLE_PWRDWN</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BUSY</name>
              <description>If high then the SAR is busy with a conversion.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AVG_STAT</name>
          <description>Current averaging status (for debug)</description>
          <addressOffset>0x204</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF0FFFFF</resetMask>
          <fields>
            <field>
              <name>CUR_AVG_ACCU</name>
              <description>the current value of the averaging accumulator</description>
              <bitRange>[19:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CUR_AVG_CNT</name>
              <description>the current value of the averaging counter. Note that the value shown is updated after the sample window and therefore runs ahead of the accumulator update.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>32</dim>
          <dimIncrement>64</dimIncrement>
          <name>CH[%s]</name>
          <description>Channel structure</description>
          <addressOffset>0x00000800</addressOffset>
          <register>
            <name>TR_CTL</name>
            <description>Trigger control.</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x800</resetValue>
            <resetMask>0x80000B77</resetMask>
            <fields>
              <field>
                <name>SEL</name>
                <description>Trigger select</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OFF</name>
                    <description>Use for channels in group, except the first channel</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>TCPWM</name>
                    <description>Trigger from corresponding TCPWM channel</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>GENERIC0</name>
                    <description>Generic trigger input 0</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>GENERIC1</name>
                    <description>N/A</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>GENERIC2</name>
                    <description>N/A</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>GENERIC3</name>
                    <description>N/A</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>GENERIC4</name>
                    <description>N/A</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CONTINUOUS</name>
                    <description>Always triggered (also called idle), can only be used for at most 1 channel</description>
                    <value>7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PRIO</name>
                <description>Channel priority:
'0': highest priority.
'1'
...
'6'
'7': lowest priority.

Channels with the same priority constitute a priority level. Priority decoding determines the highest priority pending channel. This channel is determined as follows. First, the highest priority level with pending channels is identified. Second, within this priority level, roundrobin arbitration is applied. Roundrobin arbitration (within a priority level) gives the highest priority to the lower channel indices (within the priority level).</description>
                <bitRange>[6:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PREEMPT_TYPE</name>
                <description>Preemption type allow for this group</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>ABORT_CANCEL</name>
                    <description>Abort ongoing acquisition, do not return
Clear pending trigger for aborted group and set Cancelled interrupt.
Also 'Abort' whenever this group (do not pend the trigger) is not immediately scheduled for acquisition after a new trigger arrives. 
For this preemption type only, only a positive edge on the trigger can trigger the channel, i.e. CONTINUOUS or level high operation is not supported (to avoid continuous Cancelled interrupts).
In case CTL.IDLE_PWRDWN is used and the analog is powered down, the group cannot be immediately scheduled for acquisition and therefore a trigger for a group with this preemption type will power up the analog, but the group will ABORT and set the Cancelled interrupt</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ABORT_RESTART</name>
                    <description>Abort ongoing acquisition, up on return Restart group from first channel.</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ABORT_RESUME</name>
                    <description>Abort ongoing acquisition, up on return Resume group from aborted channel
If averaging, discard averaging results so far and restart averaging.</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FINISH_RESUME</name>
                    <description>Complete ongoing acquisition (including averaging), up on return Resume group from next channel</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>GROUP_END</name>
                <description>0: continue group with next channel
1: last channel of a group.

Note that for the channel with the highest index (SAR_CH_NR) this always needs to be set</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DONE_LEVEL</name>
                <description>select level or pusle for 'tr_ch_done' trigger output 
Also see POST_CTL.TR_DONE_GRP_VIO</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>PULSE</name>
                    <description>tr_ch_done generates a 2 cycle pulse (clk_sys), no need to read the result to clear (also no ch_overflow detection)</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>LEVEL</name>
                    <description>tr_ch_done  is a level output until the result register is read (typical for DW usage, this also enables ch_overflow detection when DW is too slow)</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>SAMPLE_CTL</name>
            <description>Sample control.</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>PIN_ADDR</name>
                <description>N/A</description>
                <bitRange>[5:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PORT_ADDR</name>
                <description>Select the physical port. This field is only valid for ADC0.
ADC0 can control and connect to the SARMUX of the neighboring ADC1-3. This requires the corresponding ADC to be off while the SARMUX is left on.
When ADC0 controls another SARMUX it uses the PIN_ADDR, EXT_MUX_EN/SEL of this channel to control the other SARMUX.</description>
                <bitRange>[7:6]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>SARMUX0</name>
                    <description>ADC uses it's own SARMUX</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SARMUX1</name>
                    <description>ADC0 uses SARMUX1 (only valid for ADC0, undefined result if used for ADC1-3)</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SARMUX2</name>
                    <description>ADC0 uses SARMUX2 (only valid for ADC0, undefined result if used for ADC1-3)</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SARMUX3</name>
                    <description>ADC0 uses SARMUX3 (only valid for ADC0, undefined result if used for ADC1-3)</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EXT_MUX_SEL</name>
                <description>External analog mux select</description>
                <bitRange>[10:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EXT_MUX_EN</name>
                <description>External analog mux enable.
This enable can  be used as enable (chip select) for the external analog mux (this enable is not used as enable for the GPIO output driver).
This enable also prevents unnecessary toggle activity on the select signals of the external analog mux. When this enable is low EXT_MUX_SEL value will be ignored and the previous value will be maintained.  
Note that an external analog mux can only be used in combination with a pin input, i.e. PIN_ADDR&lt;32 or Vmotor. If an internal signal is selected this enable should be 0.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRECOND_MODE</name>
                <description>Select preconditioning mode.
Preconditioning (dis)charges the SAR sample capacitor to the selected reference voltage for PRECOND_TIME (global) cycles, a break before make cycle will be inserted before sampling starts (SAMPLE_TIME).</description>
                <bitRange>[13:12]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OFF</name>
                    <description>No preconditioning</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>VREFL</name>
                    <description>Discharge to VREFL</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>VREFH</name>
                    <description>Charge to VREFH</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DIAG</name>
                    <description>Connect the Diagnostic reference output during preconditioning. The Diagnostic reference should be configured to output a reference voltage.
Note: this selection is mutual exclusive with using the Diagnostic reference to supply an ibias current for OVERLAP.</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OVERLAP_DIAG</name>
                <description>Select Overlap mode or SARMUX Diagnostics, in both cases the Diagnostic reference is used.
With Overlap the Diagnostic reference typically sources or sinks a small current which is connected at the same time as the analog signal being sampled.
For SARMUX Diagnostics the Diagnostic reference should provide a reference voltage which is selected at the SARMUX input instead of the normal analog signal being sampled.</description>
                <bitRange>[15:14]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OFF</name>
                    <description>No overlap or SARMUX Diagnostics</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>HALF</name>
                    <description>Sample the selected analog input for 2 SAMPLE_TIME periods. During the first period use overlap sampling, i.e. connect both the analog input and Diagnostic reference. During second period only connect the analog input.</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FULL</name>
                    <description>Like normal sample the selected analog input for a single SAMPLE_TIME period but use overlap sampling, i.e. connect both the analog input and Diagnostic reference.</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>MUX_DIAG</name>
                    <description>Select Diagnostic reference instead of analog signal at the input of the SARMUX. This enables a functional safety check of the SARMUX analog connections.</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SAMPLE_TIME</name>
                <description>Sample time (aperture) in ADC clock cycles. Minimum is 1 (0 gives the same result as 1), minimum time needed for proper settling is at least 300ns, i.e. 6 clock cycles at the max frequency of 20MHz.</description>
                <bitRange>[27:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ALT_CAL</name>
                <description>Use alternate calibration values instead of the current calibration values.
This allows the firmware to allocate one or more channels to quietly re-calibrate the ADC in the background of regular processing.
0 = use regular calibration values (ANA/DIG_CAL)
1 = use alternate calibration values (ANA/DIG_CAL_ALT)
Note: typically calibration measurements select VrefL (PIN_ADDR=62) or VrefH (PIN_ADDR=63)</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>POST_CTL</name>
            <description>Post processing control</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>POST_PROC</name>
                <description>Post processing</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>NONE</name>
                    <description>No postprocessing</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>AVG</name>
                    <description>Averaging</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>AVG_RANGE</name>
                    <description>Averaging followed by Range detect</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RANGE</name>
                    <description>Range detect</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RANGE_PULSE</name>
                    <description>Range detect followed by pulse detect</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RSVD0</name>
                    <description>N/A</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RSVD1</name>
                    <description>N/A</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RSVD2</name>
                    <description>N/A</description>
                    <value>7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>LEFT_ALIGN</name>
                <description>Left or right align data in result[15:0]. 
0: the data is right aligned in result[11:0], with sign extension to 16 bits if enabled
1: the data is left aligned in result[15:4] with the lower nibble 0. Caveat if the result was more than 12 bits (e.g. after averaging) then the bits above 12 will be discarded.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SIGN_EXT</name>
                <description>Output data is sign extended</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>UNSIGNED</name>
                    <description>Default: result data is unsigned (zero extended if needed)</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SIGNED</name>
                    <description>Result data is signed (sign extended if needed)</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AVG_CNT</name>
                <description>Either averaging count (minus 1) or Pulse positive reload value

Averaging Count for channels that have averaging enabled. A channel will be sampled (AVG_CNT+1) = [1..256] times.
The signal will be acquired back to back  (1st order accumulate and dump filter), the average result is calculated and stored and then the next enabled channel is sampled.
If more than 16 sample are taken (AVG_CNT&gt;=16) then AVG_SHIFT must be set so that the result after shifting fits in 16 bits

Pulse detect positive reload value PULSE_POS_RL[7:0]</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SHIFT_R</name>
                <description>Either Shift Right (no pulse detection) or Pulse nagative reload value (if pulse detection is enabled)

Shift right SHIFT_R[3:0] = [0..12]: the result (typically after averaging) is shifted right as specified here. Software has to make sure that the result fits in less than 16 bits. 
Any value &gt;12 will be treated as 12, bit [4] is always ignored. This can also be used to fit the 12-bit result in 8 bits.

Pulse detect negative reload value PULSE_NEG_RL[4:0]</description>
                <bitRange>[20:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RANGE_MODE</name>
                <description>Range detect mode</description>
                <bitRange>[23:22]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>BELOW_LO</name>
                    <description>Below Low threshold (result &lt; Lo)</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INSIDE_RANGE</name>
                    <description>Inside range (Lo &lt;= result &lt; Hi)</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ABOVE_HI</name>
                    <description>Above high threshold (Hi &lt;= result)</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>OUTSIDE_RANGE</name>
                    <description>Outside range (result &lt; Lo || Hi &lt;= result)</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TR_DONE_GRP_VIO</name>
                <description>Select tr_sar_ch_done mode for last channel of a group, ignored for all other channels
Also see TR_CTL.DONE_LEVEL</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DONE</name>
                    <description>Default: tr_sar_ch_done is set when the group is done</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>GRP_RANGE_VIO</name>
                    <description>tr_sar_ch_done  is only set if any of the channels in the group has a Range Violation. This mode is ignored if this is not the last channel in the group.
Note that if none of the channels in the group have Range detection enabled then the trigger will never get set.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>RANGE_CTL</name>
            <description>Range thresholds</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>RANGE_LO</name>
                <description>Range detect low threshold (Lo)</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RANGE_HI</name>
                <description>Range detect high threshold (Hi)</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR</name>
            <description>Interrupt request register.</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x707</resetMask>
            <fields>
              <field>
                <name>GRP_DONE</name>
                <description>Done Interrupt: hardware sets this interrupt for the last channel of a group if the group scan is done. Write with '1' to clear bit.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>GRP_CANCELLED</name>
                <description>Cancelled Interrupt: hardware sets this interrupt for the last channel of a group if the group scan was preempted and CANCELLED. Note that it is possible that also the GRP_DONE interrupt is set. If that is the case one or more new triggers were detected while the group was already busy, i.e. triggers are too fast.   Write with '1' to clear bit.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>GRP_OVERFLOW</name>
                <description>Overflow Interrupt: hardware sets this interrupt for the last channel of a group if the group scan is done and the Done interrupt is already (still) pending. Write with '1' to clear bit.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CH_RANGE</name>
                <description>Range detect Interrupt: hardware sets this interrupt for each channel if the conversion result (after averaging) of that channel met the condition specified by the SAR_RANGE registers. This interrupt is mutual exclusive with Pulse detect interrupt. Write with '1' to clear bit.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CH_PULSE</name>
                <description>Pulse detect Interrupt: hardware sets this interrupt for each channel if the positive pulse counter reaches zero. This interrupt is mutual exclusive with Range detect interrupt. Write with '1' to clear bit.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CH_OVERFLOW</name>
                <description>Channel overflow Interrupt: hardware sets this interrupt for each channel if a new Pulse or Range interrupt is detected while the interrupt is still pending or when DW did not acknowledge data pickup. Write with '1' to clear bit.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SET</name>
            <description>Interrupt set request register</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x707</resetMask>
            <fields>
              <field>
                <name>GRP_DONE_SET</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>GRP_CANCELLED_SET</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>GRP_OVERFLOW_SET</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CH_RANGE_SET</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CH_PULSE_SET</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CH_OVERFLOW_SET</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASK</name>
            <description>Interrupt mask register.</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x707</resetMask>
            <fields>
              <field>
                <name>GRP_DONE_MASK</name>
                <description>Mask bit for corresponding bit in interrupt request register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>GRP_CANCELLED_MASK</name>
                <description>Mask bit for corresponding bit in interrupt request register.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>GRP_OVERFLOW_MASK</name>
                <description>Mask bit for corresponding bit in interrupt request register.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CH_RANGE_MASK</name>
                <description>Mask bit for corresponding bit in interrupt request register.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CH_PULSE_MASK</name>
                <description>Mask bit for corresponding bit in interrupt request register.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CH_OVERFLOW_MASK</name>
                <description>Mask bit for corresponding bit in interrupt request register.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASKED</name>
            <description>Interrupt masked request register</description>
            <addressOffset>0x1C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x707</resetMask>
            <fields>
              <field>
                <name>GRP_DONE_MASKED</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>GRP_CANCELLED_MASKED</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>GRP_OVERFLOW_MASKED</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CH_RANGE_MASKED</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CH_PULSE_MASKED</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CH_OVERFLOW_MASKED</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>WORK</name>
            <description>Working data register</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF0000000</resetMask>
            <fields>
              <field>
                <name>WORK</name>
                <description>SAR conversion working data of the channel. The data is written here right after sampling this channel.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>ABOVE_HI_MIR</name>
                <description>mirror bit of the corresponding ABOVE_HI bit</description>
                <bitRange>[28:28]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RANGE_MIR</name>
                <description>mirror bit of corresponding bit in WORK_RANGE register</description>
                <bitRange>[29:29]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PULSE_MIR</name>
                <description>mirror bit of corresponding bit in WORK_PULSE register</description>
                <bitRange>[30:30]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>VALID_MIR</name>
                <description>mirror bit of corresponding bit in WORK_VALID register</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RESULT</name>
            <description>Result data register</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF0000000</resetMask>
            <fields>
              <field>
                <name>RESULT</name>
                <description>SAR conversion result of the channel. The data is copied here from the WORK field after all enabled channels in this scan have been sampled.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>ABOVE_HI_MIR</name>
                <description>mirror bit of the corresponding ABOVE_HI bit</description>
                <bitRange>[28:28]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RANGE_INTR_MIR</name>
                <description>mirror bit of INTR.CH_RANGE bit</description>
                <bitRange>[29:29]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PULSE_INTR_MIR</name>
                <description>mirror bit of INTR.CH_PULSE bit</description>
                <bitRange>[30:30]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>VALID_MIR</name>
                <description>mirror bit of the corresponding bit in RESULT_VALID register</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GRP_STAT</name>
            <description>Group status register</description>
            <addressOffset>0x28</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x10707</resetMask>
            <fields>
              <field>
                <name>GRP_COMPLETE</name>
                <description>Group acquisition complete. 
This is a copy of the INTR.GRP_DONE bit.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>GRP_CANCELLED</name>
                <description>Group Cancelled. 
This is a copy of the INTR.GRP_CANCELLED bit.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>GRP_OVERFLOW</name>
                <description>Group Overflow. 
This is a copy of the INTR.GRP_OVERFLOW bit.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CH_RANGE_COMPLETE</name>
                <description>Channel Range complete. 
This is a copy of the INTR.CH_RANGE bit.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CH_PULSE_COMPLETE</name>
                <description>Channel Pulse complete. 
This is a copy of the INTR.CH_PULSE bit.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CH_OVERFLOW</name>
                <description>Channel Overflow. 
This is a copy of the INTR.CH_OVERFLOW bit.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>GRP_BUSY</name>
                <description>Group acquisition busy. 
This is a copy of the TR_PENDING bit of the first channel of the group.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ENABLE</name>
            <description>Enable register</description>
            <addressOffset>0x38</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>CHAN_EN</name>
                <description>Channel enable. 
- 0: the corresponding channel is disabled. Corresponding trigger will be reset immediately.
- 1: the corresponding channel is enabled.

Note: To disable a group either stop the trigger first or begin with disabling the lowest channel first. To enable a group either start with enabling the last channel first and the first channel last, or start the trigger after all channels are enabled. If these rules are not followed the result is undefined.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TR_CMD</name>
            <description>Software triggers</description>
            <addressOffset>0x3C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>START</name>
                <description>Software start trigger. When written with '1', a start trigger is generated which sets the corresponding TR_PEND bit (only if the channel is enabled). A read always returns a 0.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral derivedFrom="SAR0">
      <name>SAR1</name>
      <baseAddress>0x40901000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="SAR0">
      <name>SAR2</name>
      <baseAddress>0x40902000</baseAddress>
    </peripheral>
    <peripheral>
      <name>PASS</name>
      <description>PASS top-level MMIO (Generic Triggers)</description>
      <baseAddress>0x409F0000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>4096</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>PASS_CTL</name>
          <description>PASS control register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF0600033</resetMask>
          <fields>
            <field>
              <name>SUPPLY_MON_EN_A</name>
              <description>Supply monitor enable for AMUXBUS_A (amuxbus_a_mon)</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SUPPLY_MON_LVL_A</name>
              <description>Supply monitor level select for AMUXBUS_A</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>VRL</name>
                  <description>amuxbus_a_mon = VRL</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VRH</name>
                  <description>amuxbus_a_mon = VRH</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SUPPLY_MON_EN_B</name>
              <description>Supply monitor enable for AMUXBUS_B (amuxbus_b_mon)</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SUPPLY_MON_LVL_B</name>
              <description>Supply monitor level select for AMUXBUS_B</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>VRL</name>
                  <description>amuxbus_b_mon = VRL</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VRH</name>
                  <description>amuxbus_b_mon = VRH</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>REFBUF_MODE</name>
              <description>Reference mode.
The reference needs to be present when using TEMP sensor or diagnostic reference (in addition to SAR.DIAG_CTL.DIAG_EN). 
Note that setting this mode is not required for the ADC operation itself.</description>
              <bitRange>[22:21]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>No reference</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ON</name>
                  <description>Reference = buffered Vbg from SRSS</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD</name>
                  <description>undefined</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BYPASS</name>
                  <description>Reference = unbuffered Vbg from SRSS</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DBG_FREEZE_EN</name>
              <description>Debug pause enable, 1 per ADC.
When set a high tr_debug_freeze trigger will prevent the scheduler from starting acquistions on a new channel. Note that averaging for an already started channel will be completed.</description>
              <bitRange>[31:28]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>4</dimIncrement>
          <name>SAR_TR_IN_SEL[%s]</name>
          <description>per SAR generic input trigger select</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x43210</resetValue>
          <resetMask>0xFFFFF</resetMask>
          <fields>
            <field>
              <name>IN0_SEL</name>
              <description>Select generic trigger for SAR generic trigger input 0</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IN1_SEL</name>
              <description>Select generic trigger for SAR generic trigger input 1</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IN2_SEL</name>
              <description>Select generic trigger for SAR generic trigger input 2</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IN3_SEL</name>
              <description>Select generic trigger for SAR generic trigger input 3</description>
              <bitRange>[15:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IN4_SEL</name>
              <description>Select generic trigger for SAR generic trigger input 4</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>4</dimIncrement>
          <name>SAR_TR_OUT_SEL[%s]</name>
          <description>per SAR generic output trigger select</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x100</resetValue>
          <resetMask>0x3F3F</resetMask>
          <fields>
            <field>
              <name>OUT0_SEL</name>
              <description>Select SAR output trigger for generic trigger output 0
0-31: selects a tr_sar_ch_done trigger
32-63: selects a tr_sar_ch_rangvio trigger</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OUT1_SEL</name>
              <description>Select SAR output trigger for generic trigger output 1</description>
              <bitRange>[13:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
  </peripherals>
</device>