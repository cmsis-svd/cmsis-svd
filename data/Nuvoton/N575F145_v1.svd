<?xml version="1.0" encoding="utf-8"?>
<device schemaVersion="1.1" xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" xs:noNamespaceSchemaLocation="CMSIS-SVD_Schema_1_1.xsd" >
  <name>N575F145_v1</name>
  <version>1.0</version>
  <description>N575F145_v1 SVD file</description>
  <!-- Bus Interface Properties -->
  <!-- Cortex-M0 is byte addressable -->
  <addressUnitBits>8</addressUnitBits>
  <!-- the maximum data bit width accessible within a single transfer is 32bits -->
  <width>32</width>

  <!-- Register Default Properties -->
  <!-- the size of the registers is set to a bit width of 32. This can be overruled for individual peripherals and/or registers -->
  <size>32</size>
  <!-- the access to all registers is set to be readable and writeable. This can be overruled for individual peripherals and/or registers -->
  <access>read-write</access>
  <!-- for demonstration purposes the resetValue for all registers of the device is set to be 0. This can be overruled within the description -->
  <resetValue>0</resetValue>
  <!-- the resetMask = 0 specifies that by default no register of this device has a defined reset value -->
  <resetMask>0</resetMask>

  <peripherals>
    <peripheral>
      <name>GCR</name>
      <description>GCR Register Map</description>
      <groupName>GCR</groupName>
      <baseAddress>0x50000000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x4</offset>
        <size>0xC</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x30</offset>
        <size>0x10</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x54</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x100</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x110</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>RSTSRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>RSTSRC</displayName>
          <description>System Reset Source Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFF00</resetMask>
          <fields>
            <field>
              <name>RSTS_CORE</name>
              <description>Reset Source From CORE\nThe RSTS_CORE flag is set if the core has been reset. Possible sources of reset are a Power-On Reset (POR), RESETn Pin Reset or PMU reset. \nThis bit is cleared by writing 1 to itself.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No reset from CORE</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Core was reset by hardware block</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RSTS_WDG</name>
              <description>Reset Source From WDG\nThe RSTS_WDG flag is set if pervious reset source originates from the Watch-Dog module.\nThis bit is cleared by writing 1 to itself.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No reset from Watch-Dog</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The Watch-Dog module issued the reset signal to reset the system</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RSTS_SYS</name>
              <description>Reset Source From MCU\nThe RSTS_SYS flag is set if the previous reset source originates from the Cortex_M0 kernel.\nThis bit is cleared by writing 1 to itself.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No reset from MCU</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The Cortex_M0 MCU issued a reset signal to reset the system by software writing 1 to bit SYSRESTREQ(AIRCR[2], Application Interrupt and Reset Control Register) in system control registers of Cortex_M0 kernel</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RSTS_PMU</name>
              <description>Reset Source From PMU\nThe RSTS_PMU flag is set if the PMU.\nThis bit is cleared by writing 1 to itself.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No reset from PMU</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PMU reset the system from a power down/standby event</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RSTS_CPU</name>
              <description>Reset Source From CPU\nThe RSTS_CPU flag is set by hardware if software writes CPU_RST (IPRSTCR1[1]) with a "1" to reset Cortex-M0 CPU kernel and Flash memory controller (FMC).\nThis bit is cleared by writing 1 to itself.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No reset from CPU</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The Cortex-M0 CPU kernel and FMC has been reset by software setting CPU_RST to 1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>IPRSTC1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IPRSTC1</displayName>
          <description>IP Reset Control Resister1</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CHIP_RST</name>
              <description>CHIP One Shot Reset\nSet this bit will reset the whole chip, this bit will automatically return to "0" after the 2 clock cycles.\nCHIP_RST has same behavior as POR reset, all the chip modules are reset and the chip configuration settings from flash are reloaded.\nThis bit is a protected bit, to program first issue the unlock sequence (see Protected Register Lock Key Register (REGLOCK))\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Normal</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset CHIP</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CPU_RST</name>
              <description>CPU Kernel One Shot Reset\nSetting this bit will reset the CPU kernel and Flash Memory Controller(FMC), this bit will automatically return to "0" after the 2 clock cycles\nThis bit is a protected bit, to program first issue the unlock sequence (see Protected Register Lock Key Register (REGLOCK))\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Normal</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset CPU</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PDMA_RST</name>
              <description>PDMA Controller Reset\nSet "1" will generate a reset signal to the PDMA Block. User needs to set this bit to "0" to release from the reset state\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PDMA IP reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>IPRSTC2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IPRSTC2</displayName>
          <description>IP Reset Control Resister2</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TMR0_RST</name>
              <description>Timer0 Controller Reset\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Normal Operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR1_RST</name>
              <description>Timer1 Controller Reset\n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Normal Operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C0_RST</name>
              <description>I2C0 Controller Reset\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Normal Operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI0_RST</name>
              <description>SPI0 Controller Reset\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Normal Operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DPWM_RST</name>
              <description>DPWM Speaker Driver Reset\n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Normal Operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>UART0_RST</name>
              <description>UART0 Controller Reset\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Normal Operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BIQ_RST</name>
              <description>Biquad Filter Block Reset\n</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Normal Operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CRC_RST</name>
              <description>CRC Generation Block Reset\n</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Normal Operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM10_RST</name>
              <description>PWM10 controller Reset\n</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Normal Operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ACMP_RST</name>
              <description>Analog Comparator Reset\n</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Normal Operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_RST</name>
              <description>ADC Controller Reset\n</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Normal Operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>I2S_RST</name>
              <description>I2S Controller Reset\n</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Normal Operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ANA_RST</name>
              <description>Analog Block Control Reset\n</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Normal Operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPA_INP</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPA_INP</displayName>
          <description>GPIOA input type control register</description>
          <addressOffset>0x30</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCHMITT16</name>
              <description>Schmitt Trigger\nThis register controls whether the GPIO input buffer Schmitt trigger is enabled.\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOA[15:0] I/O input Schmitt Trigger disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOA[15:0] I/O input Schmitt Trigger  enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SCHMITT17</name>
              <description>Schmitt Trigger\nThis register controls whether the GPIO input buffer Schmitt trigger is enabled.\n</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOA[15:0] I/O input Schmitt Trigger disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOA[15:0] I/O input Schmitt Trigger  enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SCHMITT18</name>
              <description>Schmitt Trigger\nThis register controls whether the GPIO input buffer Schmitt trigger is enabled.\n</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOA[15:0] I/O input Schmitt Trigger disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOA[15:0] I/O input Schmitt Trigger  enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SCHMITT19</name>
              <description>Schmitt Trigger\nThis register controls whether the GPIO input buffer Schmitt trigger is enabled.\n</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOA[15:0] I/O input Schmitt Trigger disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOA[15:0] I/O input Schmitt Trigger  enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SCHMITT20</name>
              <description>Schmitt Trigger\nThis register controls whether the GPIO input buffer Schmitt trigger is enabled.\n</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOA[15:0] I/O input Schmitt Trigger disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOA[15:0] I/O input Schmitt Trigger  enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SCHMITT21</name>
              <description>Schmitt Trigger\nThis register controls whether the GPIO input buffer Schmitt trigger is enabled.\n</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOA[15:0] I/O input Schmitt Trigger disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOA[15:0] I/O input Schmitt Trigger  enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SCHMITT22</name>
              <description>Schmitt Trigger\nThis register controls whether the GPIO input buffer Schmitt trigger is enabled.\n</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOA[15:0] I/O input Schmitt Trigger disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOA[15:0] I/O input Schmitt Trigger  enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SCHMITT23</name>
              <description>Schmitt Trigger\nThis register controls whether the GPIO input buffer Schmitt trigger is enabled.\n</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOA[15:0] I/O input Schmitt Trigger disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOA[15:0] I/O input Schmitt Trigger  enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SCHMITT24</name>
              <description>Schmitt Trigger\nThis register controls whether the GPIO input buffer Schmitt trigger is enabled.\n</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOA[15:0] I/O input Schmitt Trigger disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOA[15:0] I/O input Schmitt Trigger  enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SCHMITT25</name>
              <description>Schmitt Trigger\nThis register controls whether the GPIO input buffer Schmitt trigger is enabled.\n</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOA[15:0] I/O input Schmitt Trigger disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOA[15:0] I/O input Schmitt Trigger  enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SCHMITT26</name>
              <description>Schmitt Trigger\nThis register controls whether the GPIO input buffer Schmitt trigger is enabled.\n</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOA[15:0] I/O input Schmitt Trigger disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOA[15:0] I/O input Schmitt Trigger  enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SCHMITT27</name>
              <description>Schmitt Trigger\nThis register controls whether the GPIO input buffer Schmitt trigger is enabled.\n</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOA[15:0] I/O input Schmitt Trigger disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOA[15:0] I/O input Schmitt Trigger  enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SCHMITT28</name>
              <description>Schmitt Trigger\nThis register controls whether the GPIO input buffer Schmitt trigger is enabled.\n</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOA[15:0] I/O input Schmitt Trigger disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOA[15:0] I/O input Schmitt Trigger  enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SCHMITT29</name>
              <description>Schmitt Trigger\nThis register controls whether the GPIO input buffer Schmitt trigger is enabled.\n</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOA[15:0] I/O input Schmitt Trigger disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOA[15:0] I/O input Schmitt Trigger  enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SCHMITT30</name>
              <description>Schmitt Trigger\nThis register controls whether the GPIO input buffer Schmitt trigger is enabled.\n</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOA[15:0] I/O input Schmitt Trigger disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOA[15:0] I/O input Schmitt Trigger  enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SCHMITT31</name>
              <description>Schmitt Trigger\nThis register controls whether the GPIO input buffer Schmitt trigger is enabled.\n</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOA[15:0] I/O input Schmitt Trigger disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOA[15:0] I/O input Schmitt Trigger  enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPB_INP</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPB_INP</displayName>
          <description>GPIOB input type control register</description>
          <addressOffset>0x34</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCHMITT16</name>
              <description>Schmitt Trigger\nThis register controls whether the GPIO input buffer Schmitt trigger is enabled.\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOB(port 0 ~ port 7) I/O input Schmitt Trigger disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOB(port 0 ~ port 7) I/O input Schmitt Trigger  enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SCHMITT17</name>
              <description>Schmitt Trigger\nThis register controls whether the GPIO input buffer Schmitt trigger is enabled.\n</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOB(port 0 ~ port 7) I/O input Schmitt Trigger disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOB(port 0 ~ port 7) I/O input Schmitt Trigger  enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SCHMITT18</name>
              <description>Schmitt Trigger\nThis register controls whether the GPIO input buffer Schmitt trigger is enabled.\n</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOB(port 0 ~ port 7) I/O input Schmitt Trigger disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOB(port 0 ~ port 7) I/O input Schmitt Trigger  enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SCHMITT19</name>
              <description>Schmitt Trigger\nThis register controls whether the GPIO input buffer Schmitt trigger is enabled.\n</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOB(port 0 ~ port 7) I/O input Schmitt Trigger disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOB(port 0 ~ port 7) I/O input Schmitt Trigger  enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SCHMITT20</name>
              <description>Schmitt Trigger\nThis register controls whether the GPIO input buffer Schmitt trigger is enabled.\n</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOB(port 0 ~ port 7) I/O input Schmitt Trigger disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOB(port 0 ~ port 7) I/O input Schmitt Trigger  enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SCHMITT21</name>
              <description>Schmitt Trigger\nThis register controls whether the GPIO input buffer Schmitt trigger is enabled.\n</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOB(port 0 ~ port 7) I/O input Schmitt Trigger disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOB(port 0 ~ port 7) I/O input Schmitt Trigger  enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SCHMITT22</name>
              <description>Schmitt Trigger\nThis register controls whether the GPIO input buffer Schmitt trigger is enabled.\n</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOB(port 0 ~ port 7) I/O input Schmitt Trigger disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOB(port 0 ~ port 7) I/O input Schmitt Trigger  enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SCHMITT23</name>
              <description>Schmitt Trigger\nThis register controls whether the GPIO input buffer Schmitt trigger is enabled.\n</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOB(port 0 ~ port 7) I/O input Schmitt Trigger disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOB(port 0 ~ port 7) I/O input Schmitt Trigger  enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPA_ALT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPA_ALT</displayName>
          <description>GPIOA multiple function control register</description>
          <addressOffset>0x38</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPA0</name>
              <description>Alternate Function Setting For GPA1\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI_MOSI0</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>MCLK</description>
                    <value>#10</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA1</name>
              <description>Alternate Function Setting For GPA2\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI_SCLK</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>I2C_SCL</description>
                    <value>#10</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA2</name>
              <description>Alternate Function Setting For GPA3\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI_SSB0</description>
                    <value>#01</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA3</name>
              <description>Alternate Function Setting For GPA3\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI_MISO0</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>I2C_SDA</description>
                    <value>#10</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA4</name>
              <description>Alternate Function Setting For GPA4\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2S_FS</description>
                    <value>#01</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA5</name>
              <description>Alternate Function Setting For GPA5\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2S_BCLK</description>
                    <value>#01</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA6</name>
              <description>Alternate Function Setting For GPA6\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2S_SDI</description>
                    <value>#01</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA7</name>
              <description>Alternate Function Setting For GPA7\n</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2S_SDO</description>
                    <value>#01</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA8</name>
              <description>Alternate Function Setting For GPA8\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART_TX</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>I2S_FS</description>
                    <value>#10</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA9</name>
              <description>Alternate Function Setting For GPA9\n</description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART_RX</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>I2S_BCLK</description>
                    <value>#10</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA10</name>
              <description>Alternate Function Setting For GPA10\n</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2C_SDA</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>I2S_SDI</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>UART_RTSn</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA11</name>
              <description>Alternate Function Setting For GPA11\n</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2C_SCL</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>I2S_SDO</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>UART_CTSn</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA12</name>
              <description>Alternate Function Setting For GPA12\n</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM0</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>SPKP</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>I2S_FS</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA13</name>
              <description>Alternate Function Setting For GPA13\n</description>
              <bitOffset>26</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM1</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>SPKM</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>I2S_BCLK</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA14</name>
              <description>Alternate Function Setting For GPA14\n</description>
              <bitOffset>28</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TM0</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>SDCLK</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>SDCLKn</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA15</name>
              <description>Alternate Function Setting For GPA15\n</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TM1</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>SDIN</description>
                    <value>#10</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPB_ALT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPB_ALT</displayName>
          <description>GPIOB multiple function control register</description>
          <addressOffset>0x3C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPB0</name>
              <description>Alternate Function Setting For GPB0\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI_SSB1</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>CMP0</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>SPI_SSB0</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPB1</name>
              <description>Alternate Function Setting For GPB1\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>MCLK</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>CMP1</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>SPI_SSB1</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPB2</name>
              <description>Alternate Function Setting For GPB2\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2C_SCL</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>CMP2</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>SPI_SCLK</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPB3</name>
              <description>Alternate Function Setting For GPB3\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2C_SDA</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>CMP3</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>SPI_MISO0</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPB4</name>
              <description>Alternate Function Setting For GPB4\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM0B</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>CMP4</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>SPI_MOSI0</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPB5</name>
              <description>Alternate Function Setting For GPB5\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM1B</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>CMP5</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>SPI_MISO1</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPB6</name>
              <description>Alternate Function Setting For GPB6\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2S_SDI</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>CMP6</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>SPI_MOSI1</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPB7</name>
              <description>Alternate Function Setting For GPB7\n</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2S_SDO</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>CMP7</description>
                    <value>#10</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>WAKECR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>WAKECR</displayName>
          <description>WAKEUP pin control register</description>
          <addressOffset>0x54</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000006</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WAKE_DIN</name>
              <description>State Of Wakeup Pin\nRead only.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKE_TRI</name>
              <description>Wakeup Pin Pull-up Control\nThis signal is latched in deep power down and preserved.\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>pull-up enable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>tristate (default)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKE_OENB</name>
              <description>Wakeup Pin Output Enable Bar\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>drive WAKE_DOUT to pin</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>tristate (default)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKE_DOUT</name>
              <description>Wakeup Output State\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>drive Low if the corresponding output mode bit is set (default)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>drive High if the corresponding output mode bit is set</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>REGLOCK</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>REGLOCK</displayName>
          <description>Register Lock Key Address register</description>
          <addressOffset>0x100</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RegUnLock</name>
              <description>Protected Register Unlock Register\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Protected registers are locked. Any write to the target register is ignored</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Protected registers are unlocked</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>OSCTRIM</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>OSCTRIM</displayName>
          <description>Oscillator Frequency Adjustment control register</description>
          <addressOffset>0x110</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>OSCTRIM0_TRIM</name>
              <description>8 Bit Trim For Oscillator\nTRIM[7:5] are 8 coarse trim ranges which overlap in frequency. TRIM[4:0] are 32 fine trim steps of approximately 0.5% resolution.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OSCTRIM0_RANGE</name>
              <description>Range Bit For Oscillator\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>high range</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>low range</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>OSCTRIM1_TRIM</name>
              <description>8 Bit Trim For Oscillator\nTRIM[7:5] are 8 coarse trim ranges which overlap in frequency. TRIM[4:0] are 32 fine trim steps of approximately 0.5% resolution.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OSCTRIM1_RANGE</name>
              <description>Range Bit For Oscillator\n</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>high range</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>low range</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>OSC16K</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>OSC16K</displayName>
          <description>16K Oscillator trim register</description>
          <addressOffset>0x114</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SCS</name>
      <description>SCS Register Map</description>
      <groupName>SCS</groupName>
      <baseAddress>0xE000E000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x10</offset>
        <size>0xC</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x100</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x180</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x200</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x280</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x400</offset>
        <size>0x20</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0xD00</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0xD0C</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0xD1C</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>CTRL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CTRL</displayName>
          <description>SysTick Control and Status Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000004</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ENABLE</name>
              <description>ENABLE\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The counter is disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The counter will operate in a multi-shot manner</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TICKINT</name>
              <description>Enables SysTick Exception Request\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Counting down to 0 does not cause the SysTick exception to be pended. Software can use COUNTFLAG to determine if a count to zero has occurred</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Counting down to 0 will cause SysTick exception to be pended. Clearing the SysTick Current Value register by a register write in software will not cause SysTick to be pended</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLKSRC</name>
              <description>Clock Source\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Core clock unused</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Core clock used for SysTick, this bit will read as 1 and ignore writes</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>COUNTFLAG</name>
              <description>Count Flag\nReturns 1 if timer counted to 0 since last time this register was read.\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Cleared on read or by a write to the Current Value register</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Set by a count transition from 1 to 0</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>LOAD</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>LOAD</displayName>
          <description>SysTick Reload value Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>RELOAD</name>
              <description>SysTick Reload\nValue to load into the Current Value register when the counter reaches 0.\nTo generate a multi-shot timer with a period of N processor clock cycles, use a RELOAD value of N-1. For example, if the SysTick interrupt is required every 200 clock pulses, set RELOAD to 199.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>VAL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>VAL</displayName>
          <description>SysTick Current value Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>CURRENT</name>
              <description>Current Counter Value\nThis is the value of the counter at the time it is sampled. The counter does not provide read-modify-write protection. The register is write-clear. A software write of any value will clear the register to 0 and also clear the COUNTFLAG bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_ISER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_ISER</displayName>
          <description>IRQ0 ~ IRQ31 Set-Enable Control Register</description>
          <addressOffset>0x100</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SETENA</name>
              <description>Set-Enable Control\nEnable one or more interrupts within a group of 32. Each bit represents an interrupt number from IRQ0 ~ IRQ31 (Vector number from 16 ~ 47). \nWriting 1 will enable the associated interrupt.\nWriting 0 has no effect.\nThe register reads back the current enable state.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_ICER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_ICER</displayName>
          <description>IRQ0 ~ IRQ31 Clear-Enable Control Register</description>
          <addressOffset>0x180</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLRENA</name>
              <description>Clear-Enable Control\nDisable one or more interrupts within a group of 32. Each bit represents an interrupt number from IRQ0 ~ IRQ31 (Vector number from 16 ~ 47). \nWriting 1 will disable the associated interrupt.\nWriting 0 has no effect.\nThe register reads back with the current enable state.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_ISPR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_ISPR</displayName>
          <description>IRQ0 ~ IRQ31 Set-Pending Control Register</description>
          <addressOffset>0x200</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SETPEND</name>
              <description>Set-Pending Control\nWriting 1 to a bit forces pending state of the associated interrupt under software control. Each bit represents an interrupt number from IRQ0 ~ IRQ31 (Vector number from 16 ~ 47).\nWriting 0 has no effect.\nThe register reads back with the current pending state.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_ICPR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_ICPR</displayName>
          <description>IRQ0 ~ IRQ31 Clear-Pending Control Register</description>
          <addressOffset>0x280</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLRPEND</name>
              <description>Clear-Pending Control\nWriting 1 to a bit to clear the pending state of associated interrupt under software control. Each bit represents an interrupt number from IRQ0 ~ IRQ31 (Vector number from 16 ~ 47).\nWriting 0 has no effect.\nThe register reads back with the current pending state.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_IPR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_IPR0</displayName>
          <description>IRQ0 ~ IRQ3 Priority Control Register</description>
          <addressOffset>0x400</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_0</name>
              <description>Priority of IRQ0\n"0" denotes the highest priority and "3" denotes lowest priority</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_1</name>
              <description>Priority of IRQ1\n"0" denotes the highest priority and "3" denotes lowest priority</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_2</name>
              <description>Priority of IRQ2\n"0" denotes the highest priority and "3" denotes lowest priority</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_3</name>
              <description>Priority of IRQ3\n"0" denotes the highest priority and "3" denotes lowest priority</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_IPR1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_IPR1</displayName>
          <description>IRQ4 ~ IRQ7 Priority Control Register</description>
          <addressOffset>0x404</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_4</name>
              <description>Priority of IRQ4\n"0" denotes the highest priority and "3" denotes lowest priority</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_5</name>
              <description>Priority of IRQ5\n"0" denotes the highest priority and "3" denotes lowest priority</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_6</name>
              <description>Priority of IRQ6\n"0" denotes the highest priority and "3" denotes lowest priority</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_7</name>
              <description>Priority of IRQ7\n"0" denotes the highest priority and "3" denotes lowest priority</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_IPR2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_IPR2</displayName>
          <description>IRQ8 ~ IRQ11 Priority Control Register</description>
          <addressOffset>0x408</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_8</name>
              <description>Priority of IRQ8\n"0" denotes the highest priority and "3" denotes lowest priority</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_9</name>
              <description>Priority of IRQ9\n"0" denotes the highest priority and "3" denotes lowest priority</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_10</name>
              <description>Priority of IRQ10\n"0" denotes the highest priority and "3" denotes lowest priority</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_11</name>
              <description>Priority of IRQ11\n"0" denotes the highest priority and "3" denotes lowest priority</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_IPR3</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_IPR3</displayName>
          <description>IRQ12 ~ IRQ15 Priority Control Register</description>
          <addressOffset>0x40C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_12</name>
              <description>Priority of IRQ12\n"0" denotes the highest priority and "3" denotes lowest priority</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_13</name>
              <description>Priority of IRQ13\n"0" denotes the highest priority and "3" denotes lowest priority</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_14</name>
              <description>Priority of IRQ14\n"0" denotes the highest priority and "3" denotes lowest priority</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_15</name>
              <description>Priority of IRQ15\n"0" denotes the highest priority and "3" denotes lowest priority</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_IPR4</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_IPR4</displayName>
          <description>IRQ16 ~ IRQ19 Priority Control Register</description>
          <addressOffset>0x410</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_16</name>
              <description>Priority of IRQ16\n"0" denotes the highest priority and "3" denotes lowest priority</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_17</name>
              <description>Priority of IRQ17\n"0" denotes the highest priority and "3" denotes lowest priority</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_18</name>
              <description>Priority of IRQ18\n"0" denotes the highest priority and "3" denotes lowest priority</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_19</name>
              <description>Priority of IRQ19\n"0" denotes the highest priority and "3" denotes lowest priority</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_IPR5</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_IPR5</displayName>
          <description>IRQ20 ~ IRQ23 Priority Control Register</description>
          <addressOffset>0x414</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_20</name>
              <description>Priority of IRQ20\n"0" denotes the highest priority and "3" denotes lowest priority</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_21</name>
              <description>Priority of IRQ21\n"0" denotes the highest priority and "3" denotes lowest priority</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_22</name>
              <description>Priority of IRQ22\n"0" denotes the highest priority and "3" denotes lowest priority</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_23</name>
              <description>Priority of IRQ23\n"0" denotes the highest priority and "3" denotes lowest priority</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_IPR6</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_IPR6</displayName>
          <description>IRQ24 ~ IRQ27 Priority Control Register</description>
          <addressOffset>0x418</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_24</name>
              <description>Priority of IRQ24\n"0" denotes the highest priority and "3" denotes lowest priority</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_25</name>
              <description>Priority of IRQ25\n"0" denotes the highest priority and "3" denotes lowest priority</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_26</name>
              <description>Priority of IRQ26\n"0" denotes the highest priority and "3" denotes lowest priority</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_27</name>
              <description>Priority of IRQ27\n"0" denotes the highest priority and "3" denotes lowest priority</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_IPR7</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_IPR7</displayName>
          <description>IRQ28 ~ IRQ31 Priority Control Register</description>
          <addressOffset>0x41C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_28</name>
              <description>Priority of IRQ28\n"0" denotes the highest priority and "3" denotes lowest priority</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_29</name>
              <description>Priority of IRQ29\n"0" denotes the highest priority and "3" denotes lowest priority</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_30</name>
              <description>Priority of IRQ30\n"0" denotes the highest priority and "3" denotes lowest priority</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_31</name>
              <description>Priority of IRQ31\n"0" denotes the highest priority and "3" denotes lowest priority</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CPUID</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CPUID</displayName>
          <description>CPUID Base Register</description>
          <addressOffset>0xD00</addressOffset>
          <access>read-only</access>
          <resetValue>0x410CC200</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REVISION</name>
              <description>Revision\nReads as 0x0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PARTNO</name>
              <description>Part Number\nReads as 0xC20.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PART</name>
              <description>ARMv6-M Parts\nReads as 0xC for ARMv6-M parts</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>IMPLEMENTER</name>
              <description>Implementer Code Assigned By ARM\nARM = 0x41.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ICSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ICSR</displayName>
          <description>Interrupt Control State Register</description>
          <addressOffset>0xD04</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VECTACTIVE</name>
              <description>Vector Active\n0: Thread mode\nValue &gt; 1: the exception number for the current executing exception.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VECTPENDING</name>
              <description>Vector Pending\nIndicates the exception number for the highest priority pending exception. The pending state includes the effect of memory-mapped enable and mask registers. It does not include the PRIMASK special-purpose register qualifier. A value of zero indicates no pending exceptions.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRPENDING</name>
              <description>ISR Pending\nIndicates if an external configurable (NVIC generated) interrupt is pending.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRPREEMPT</name>
              <description>ISR Preemptive\nIf set, a pending exception will be serviced on exit from the debug halt state.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PENDSTCLR</name>
              <description>Clear A pending SysTick\nWrite 1 to clear a pending SysTick.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PENDSTSET</name>
              <description>Set A pending SysTick\nReads back with current state (1 if Pending, 0 if not).</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PENDSVCLR</name>
              <description>Clear A Pending PendSV Interrupt\nWrite 1 to clear a pending PendSV interrupt.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PENDSVSET</name>
              <description>Set A Pending PendSV Interrupt\nThis is normally used to request a context switch. Reads back with current state (1 if Pending, 0 if not).</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NMIPENDSET</name>
              <description>NMI Pending Set Control\nSetting this bit will activate an NMI. Since NMI is the highest priority exception, it will activate as soon as it is registered. Reads back with current state (1 if Pending, 0 if not).</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>AIRCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>AIRCR</displayName>
          <description>Application Interrupt and Reset Control Register</description>
          <addressOffset>0xD0C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VECTCLRACTIVE</name>
              <description>Clear All Active Vector\nClears all active state information for fixed and configurable exceptions.\nThe effect of writing a 1 to this bit if the processor is not halted in Debug, is UNPREDICTABLE.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>do not clear state information</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>clear state information</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SYSRESETREQ</name>
              <description>System Reset Request\nWriting 1 to this bit asserts a signal to request a reset by the external system.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>do not request a reset</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>request reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ENDIANESS</name>
              <description>Endianess\nRead Only. Reads 0 indicating little endian machine.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VECTKEY</name>
              <description>Vector Key\nThe value 0x05FA must be written to this register, otherwise\na write to register is UNPREDICTABLE.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SCR</displayName>
          <description>System Control Register</description>
          <addressOffset>0xD10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SLEEPONEXIT</name>
              <description>Sleep On Exception\nWhen set to 1, the core can enter a sleep state on an exception return to Thread mode. This is the mode and exception level entered at reset, the base level of execution. Setting this bit to 1 enables an interrupt driven application to avoid returning to an empty main application.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SLEEPDEEP</name>
              <description>Sleep Deep Control\nControls whether the processor uses sleep or deep sleep as its low power mode:\nThe SLEEPDEEP flag is also used in conjunction with PWRCON register to enter deeper power-down states than purely core sleep states.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>sleep</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>deep sleep</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SEVONPEND</name>
              <description>Send Event On Pending Bit\nWhen enabled, interrupt transitions from Inactive to Pending are included in the list of wakeup events for the WFE instruction.\nWhen an event or interrupt enters pending state, the event signal wakes up the processor from WFE. If the processor is not waiting for an event, the event is registered and affects the next WFE.\nThe processor also wakes up on execution of an SEV instruction.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>only enabled interrupts or events can wake-up the processor, disabled interrupts are excluded</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>enabled events and all interrupts, including disabled interrupts, can wake-up the processor</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SHPR2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SHPR2</displayName>
          <description>System Handler Priority Register 2</description>
          <addressOffset>0xD1C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_11</name>
              <description>Priority Of System Handler 11 - SVCall\n"0" denotes the highest priority and "3" denotes lowest priority</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SHPR3</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SHPR3</displayName>
          <description>System Handler Priority Register 3</description>
          <addressOffset>0xD20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_14</name>
              <description>Priority Of System Handler 14 - PendSV\n"0" denotes the highest priority and "3" denotes lowest priority</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_15</name>
              <description>Priority Of System Handler 15 - SysTick\n"0" denotes the highest priority and "3" denotes lowest priority</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>INT</name>
      <description>INT Register Map</description>
      <groupName>INT</groupName>
      <baseAddress>0x50000300</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x88</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>IRQ0_SRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IRQ0_SRC</displayName>
          <description>IRQ0 (BOD) Interrupt Source Identity Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>INT_SRC</name>
              <description>Interrupt Source Identity\nBit2: 0\nBit1: 0\nBit0: BOD_INT</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>IRQ1_SRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IRQ1_SRC</displayName>
          <description>IRQ1 (WDT) Interrupt Source Identity Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>INT_SRC</name>
              <description>Interrupt Source Identity\nBit2: 0\nBit1: 0\nBit0: WDT_INT</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>IRQ2_SRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IRQ2_SRC</displayName>
          <description>IRQ2 (EINT0) Interrupt Source Identity Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>INT_SRC</name>
              <description>Interrupt Source Identity\nBit2: 0\nBit1: 0\nBit0: INT0_INT</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>IRQ3_SRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IRQ3_SRC</displayName>
          <description>IRQ3 (EINT1) Interrupt Source Identity Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>INT_SRC</name>
              <description>Interrupt Source Identity\nBit2: 0\nBit1: 0\nBit0: INT0_INT</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>IRQ4_SRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IRQ4_SRC</displayName>
          <description>IRQ4 (GPA/B) Interrupt Source Identity Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>INT_SRC</name>
              <description>Interrupt Source Identity\nBit2: 0\nBit1: GPB_INT\nBit0: GPA_INT</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>IRQ5_SRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IRQ5_SRC</displayName>
          <description>IRQ5 (ALC) Interrupt Source Identity Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>INT_SRC</name>
              <description>Interrupt Source Identity\nBit2: 0\nBit1: 0\nBit0: ALC_INT</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>IRQ6_SRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IRQ6_SRC</displayName>
          <description>IRQ6 (PWMA) Interrupt Source Identity Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>INT_SRC</name>
              <description>Interrupt Source Identity\nBit2: 0\nBit1: 0\nBit0: PWMA_INT</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>IRQ7_SRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IRQ7_SRC</displayName>
          <description>IRQ7 (Reserved) Interrupt Source Identity Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
          </fields>
       </register>
       <register>
          <name>IRQ8_SRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IRQ8_SRC</displayName>
          <description>IRQ8 (TMR0) Interrupt Source Identity Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>INT_SRC</name>
              <description>Interrupt Source Identity\nBit2: 0\nBit1: 0\nBit0: TMR0_INT</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>IRQ9_SRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IRQ9_SRC</displayName>
          <description>IRQ9 (TMR1) Interrupt Source Identity Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>INT_SRC</name>
              <description>Interrupt Source Identity\nBit2: 0\nBit1: 0\nBit0: TMR1_INT</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>IRQ10_SRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IRQ10_SRC</displayName>
          <description>IRQ10 (Reserved) Interrupt Source Identity Register</description>
          <addressOffset>0x28</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
          </fields>
       </register>
       <register>
          <name>IRQ11_SRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IRQ11_SRC</displayName>
          <description>IRQ11 (Reserved) Interrupt Source Identity Register</description>
          <addressOffset>0x2C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
          </fields>
       </register>
       <register>
          <name>IRQ12_SRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IRQ12_SRC</displayName>
          <description>IRQ12 (UART0) Interrupt Source Identity Register</description>
          <addressOffset>0x30</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>INT_SRC</name>
              <description>Interrupt Source Identity\nBit2: 0\nBit1: 0\nBit0: UART0_INT</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>IRQ13_SRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IRQ13_SRC</displayName>
          <description>IRQ13 (Reserved) Interrupt Source Identity Register</description>
          <addressOffset>0x34</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
          </fields>
       </register>
       <register>
          <name>IRQ14_SRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IRQ14_SRC</displayName>
          <description>IRQ14 (SPI0) Interrupt Source Identity Register</description>
          <addressOffset>0x38</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>INT_SRC</name>
              <description>Interrupt Source Identity\nBit2: 0\nBit1: 0\nBit0: SPI0_INT</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>IRQ15_SRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IRQ15_SRC</displayName>
          <description>IRQ15 (Reserved) Interrupt Source Identity Register</description>
          <addressOffset>0x3C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
          </fields>
       </register>
       <register>
          <name>IRQ16_SRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IRQ16_SRC</displayName>
          <description>IRQ16 (Reserved) Interrupt Source Identity Register</description>
          <addressOffset>0x40</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
          </fields>
       </register>
       <register>
          <name>IRQ17_SRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IRQ17_SRC</displayName>
          <description>IRQ17 (Reserved) Interrupt Source Identity Register</description>
          <addressOffset>0x44</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
          </fields>
       </register>
       <register>
          <name>IRQ18_SRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IRQ18_SRC</displayName>
          <description>IRQ18 (I2C0) Interrupt Source Identity Register</description>
          <addressOffset>0x48</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>INT_SRC</name>
              <description>Interrupt Source Identity\nBit2: 0\nBit1: 0\nBit0: I2C0_INT</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>IRQ19_SRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IRQ19_SRC</displayName>
          <description>IRQ19 (Reserved) Interrupt Source Identity Register</description>
          <addressOffset>0x4C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
          </fields>
       </register>
       <register>
          <name>IRQ20_SRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IRQ20_SRC</displayName>
          <description>IRQ20 (Reserved) Interrupt Source Identity Register</description>
          <addressOffset>0x50</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
          </fields>
       </register>
       <register>
          <name>IRQ21_SRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IRQ21_SRC</displayName>
          <description>IRQ21 (TALARM) Interrupt Source Identity Register</description>
          <addressOffset>0x54</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>INT_SRC</name>
              <description>Interrupt Source Identity\nBit2: 0\nBit1: 0\nBit0: TALARM_INT</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>IRQ22_SRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IRQ22_SRC</displayName>
          <description>IRQ22 (Reserved ) Interrupt Source Identity Register</description>
          <addressOffset>0x58</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
          </fields>
       </register>
       <register>
          <name>IRQ23_SRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IRQ23_SRC</displayName>
          <description>IRQ23 (Reserved) Interrupt Source Identity Register</description>
          <addressOffset>0x5C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
          </fields>
       </register>
       <register>
          <name>IRQ24_SRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IRQ24_SRC</displayName>
          <description>IRQ24 (Reserved) Interrupt Source Identity Register</description>
          <addressOffset>0x60</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
          </fields>
       </register>
       <register>
          <name>IRQ25_SRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IRQ25_SRC</displayName>
          <description>IRQ25 (ACMP) Interrupt Source Identity Register</description>
          <addressOffset>0x64</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>INT_SRC</name>
              <description>Interrupt Source Identity\nBit2: 0\nBit1: 0\nBit0: TALARM_INT</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>IRQ26_SRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IRQ26_SRC</displayName>
          <description>IRQ26 (PDMA) Interrupt Source Identity Register</description>
          <addressOffset>0x68</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>INT_SRC</name>
              <description>Interrupt Source Identity\nBit2: 0\nBit1: 0\nBit0: PDMA_INT</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>IRQ27_SRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IRQ27_SRC</displayName>
          <description>IRQ27 (I2S) Interrupt Source Identity Register</description>
          <addressOffset>0x6C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>INT_SRC</name>
              <description>Interrupt Source Identity\nBit2: 0\nBit1: 0\nBit0: I2S_INT</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>IRQ28_SRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IRQ28_SRC</displayName>
          <description>IRQ28 (CAPS) Interrupt Source Identity Register</description>
          <addressOffset>0x70</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>INT_SRC</name>
              <description>Interrupt Source Identity\nBit2: 0\nBit1: 0\nBit0: CAPS_INT</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>IRQ29_SRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IRQ29_SRC</displayName>
          <description>IRQ29 (ADC) Interrupt Source Identity Register</description>
          <addressOffset>0x74</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>INT_SRC</name>
              <description>Interrupt Source Identity\nBit2: 0\nBit1: 0\nBit0: ADC_INT</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>IRQ30_SRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IRQ30_SRC</displayName>
          <description>IRQ30 (Reserved) Interrupt Source Identity Register</description>
          <addressOffset>0x78</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
          </fields>
       </register>
       <register>
          <name>IRQ31_SRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IRQ31_SRC</displayName>
          <description>IRQ31 (RTC) Interrupt Source Identity Register</description>
          <addressOffset>0x7C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>INT_SRC</name>
              <description>Interrupt Source Identity\nBit2: 0\nBit1: 0\nBit0: RTC_INT</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NMI_SEL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NMI_SEL</displayName>
          <description>NMI Source Interrupt Select Control Register</description>
          <addressOffset>0x80</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NMI_SEL</name>
              <description>NMI Source Interrupt Select\nThe NMI interrupt to Cortex-M0 can be selected from one of the interrupt[31:0]\nThe NMI_SEL bit[4:0] used to select the NMI interrupt source</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IRQ_TM</name>
              <description>IRQ Test Mode\nIf set to 1 then peripheral IRQ signals (0-31) are replaced by the value in the MCU_IRQ register. This is a protected register to program first issue the unlock sequence (see Protected Register Lock Key Register (REGLOCK))</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>MCU_IRQ</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>MCU_IRQ</displayName>
          <description>MCU IRQ Number Identify Register</description>
          <addressOffset>0x84</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MCU_IRQ</name>
              <description>MCU IRQ Source Test Mode\nIn Normal mode (NMI_SEL register bit [7] = 0) The device collects interrupts from each peripheral and synchronizes them to interrupt the Cortex-M0.\nIn Test mode (NMI_SEL register bit [7] = 1), the interrupts from peripherals are blocked, and the interrupts are replaces by MCU_IRQ[31:0]. \nWhen MCU_IRQ[n] is "0" : Writing MCU_IRQ[n] "1" will generate an interrupt to Cortex_M0 NVIC[n].\nWhen MCU_IRQ[n] is "1" (meaning an interrupt is asserted) writing MCU_bit[n] '1' will clear the interrupt\nWriting MCU_IRQ[n] "0" : has no effect.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>CLK</name>
      <description>CLK Register Map</description>
      <groupName>CLK</groupName>
      <baseAddress>0x50000200</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x2C</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>PWRCON</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWRCON</displayName>
          <description>System Power Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000006</resetValue>
          <resetMask>0x00FFFFFF</resetMask>
          <fields>
            <field>
              <name>XTAL32K_EN</name>
              <description>External 32.768 kHz Crystal Enable Bit\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>disable (default)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>OSC49M_EN</name>
              <description>OSC49M Oscillator Enable Bit\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>enable (default)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>OSC16K_EN</name>
              <description>OSC16K Oscillator Enable Bit\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>enable (default)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>STOP</name>
              <description>Stop\nReserved - do not set to '1'</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STANDBY_PD</name>
              <description>Standby Power Down (SPD) Bit\nSet to '1' and issue WFI/WFE instruction to enter SPD mode.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DEEP_PD</name>
              <description>Deep Power Down (DPD) Bit\nSet to '1' and issue WFI/WFE instruction to enter DPD mode.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PIN_ENB</name>
              <description>Wakeup Pin Enabled Control\nDetermines whether WAKEUP pin is enabled in DPD mode.\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>OSC16K_ENB</name>
              <description>OSC16K Enabled Control\nDetermines whether OSC16K is enabled in DPD mode. If OSC16K is disabled, device cannot wake from DPD with TIMER_SEL delay.\n</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMER_SEL</name>
              <description>Select Wakeup Timer\nTIMER_SEL[0] = 1: WAKEUP after 128 OSC16K clocks (12.8 ms)\nTIMER_SEL[1] = 1: WAKEUP after 256 OSC16K clocks (25.6 ms)\nTIMER_SEL[2] = 1: WAKEUP after 512 OSC16K clocks (51.2 ms)\nTIMER_SEL[3] = 1: WAKEUP after 1024 OSC16K clocks (102.4ms)</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PIN_WAKE</name>
              <description>Pin Wakeup Flag\nRead Only. This flag indicates that wakeup of device was requested with a high to low transition of the WAKEUP pin. Flag is cleared when DPD mode is entered.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMER_WAKE</name>
              <description>Timer Wakeup Flag\nRead Only. This flag indicates that wakeup of device was requested with TIMER count of the 16Khz oscillator. Flag is cleared when DPD mode is entered.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>POI_WAKE</name>
              <description>POI Wakeup Flag\nRead Only. This flag indicates that wakeup of device was requested with a power-on reset. Flag is cleared when DPD mode is entered.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMER_SEL_RD</name>
              <description>Current Wakeup Timer Setting\nRead-Only. Read back of the current WAKEUP timer setting. This value is updated with TIMER_SEL upon entering DPD mode.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>AHBCLK</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>AHBCLK</displayName>
          <description>AHB Device Clock Enable Control Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000005</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CPU_EN</name>
              <description>CPU Clock Enable (HCLK)\nMust be left as '1' for normal operation.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PDMA_EN</name>
              <description>PDMA Controller Clock Enable Control\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>To disable the PDMA engine clock</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>To enable the PDMA engine clock</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISP_EN</name>
              <description>Flash ISP Controller Clock Enable Control\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>To disable the Flash ISP engine clock</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>To enable the Flash ISP engine clock</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>APBCLK</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>APBCLK</displayName>
          <description>APB Device Clock Enable Control Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WDG_EN</name>
              <description>Watchdog  Clock Enable Control\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RTC_EN</name>
              <description>Real-Time-Clock APB Interface Clock Control\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR0_EN</name>
              <description>Timer0 Clock Enable Control\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR1_EN</name>
              <description>Timer1 Clock Enable Control\n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C0_EN</name>
              <description>I2C0 Clock Enable Control\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI0_EN</name>
              <description>SPI0 Clock Enable Control\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DPWM_EN</name>
              <description>Differential PWM Speaker Driver Clock Enable Control\n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>UART0_EN</name>
              <description>UART0 Clock Enable Control\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BIQALC_EN</name>
              <description>Biquad Filter And Automatic Level Control Block Clock Enable Control\n</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CRC_EN</name>
              <description>Cyclic Redundancy Check Block Clock Enable Control\n</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM01_EN</name>
              <description>PWM Block Clock Enable Control\n</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ACMP_EN</name>
              <description>Analog Comparator Clock Enable Control\n</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SBRAM_EN</name>
              <description>Standby RAM Clock Enable Control\n</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_EN</name>
              <description>Audio Analog-Digital-Converter (ADC) Clock Enable Control\n</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>I2S_EN</name>
              <description>I2S Clock Enable Control\n</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ANA_EN</name>
              <description>Analog Block Clock Enable Control\n</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>DPDSTATE</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>DPDSTATE</displayName>
          <description>Deep Power Down State Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFF00FF</resetMask>
          <fields>
            <field>
              <name>DPD_STATE_WR</name>
              <description>DPD State Write\nTo set the DPDSTATE register, write value to this register. Data is latched on next DPD event.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DPD_STATE_RD</name>
              <description>DPD State Read Back\nRead back of DPDSTATE register. This register was preserved from last DPD event .</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CLKSEL0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CLKSEL0</displayName>
          <description>Clock Source Select Control Register 0</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000038</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HCLK_S</name>
              <description>HCLK Clock Source Select\nEnsure that related clock sources (pre-select and new-select) are enabled before updating register.\nThese bits are protected, to write to bits first perform the unlock sequence (see Protected Register Lock Key Register (REGLOCK))\n000 = clock source from internal OSC48M oscillator. \n001 = clock source from external 32kHz crystal clock \n010 = clock source from internal 16 kHz oscillator clock\nOthers = reserved</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STCLK_S</name>
              <description>MCU Cortex_M0 SysTick Clock Source Select\nThese bits are protected, to write to bits first perform the unlock sequence (see Protected Register Lock Key Register (REGLOCK))\n000 = clock source from 16 kHz internal clock \n001 = clock source from external 32kHz crystal clock\n010 = clock source from 16 kHz internal oscillator divided by 2\n011 = clock source from OSC49M internal oscillator divided by 2\n1xx = clock source from HCLK / 2 (Default)\nNote that to use STCLK_S as source of SysTic timer the CLKSRC bit of SysTick-&gt;CTRL must be set to 0.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OSCFSel</name>
              <description>OSC48M Frequency Select\nDetermines which trim setting to use for OSC48M internal oscillator. Oscillator is factory trimmed within 1% to:\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>49.152MHz (Default)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>32.768MHz</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CLKSEL1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CLKSEL1</displayName>
          <description>Clock Source Select Control Register 1</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x3300771F</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WDG_S</name>
              <description>WDG CLK Clock Source Select\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>clock source from internal OSC48M oscillator clock</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>clock source from external 32kHz crystal clock</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>clock source from HCLK/2048 clock</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>clock source from internal 16 kHz oscillator clock</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DPWM_S</name>
              <description>Differential Speaker Driver PWM Clock Source Select\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>OSC48M clock</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>2x OSC48M clock</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR0_S</name>
              <description>TIMER0 Clock Source Select\n000 = clock source from internal 16 kHz oscillator\n001 = clock source from external 32kHz crystal clock\n010 = clock source from HCLK\n011 = clock source from external pin (GPIOA[14])\n1xx = clock source from internal OSC48M oscillator clock</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR1_S</name>
              <description>TIMER1 Clock Source Select\n000 = clock source from internal 16 kHz oscillator\n001 = clock source from external 32kHz crystal clock\n010 = clock source from HCLK\n011 = clock source from external pin (GPIOA[15])\n1xx = clock source from internal OSC48M oscillator clock</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM01_S</name>
              <description>PWM0 And PWM1 Clock Source Select\nPWM0 and PWM1 uses the same clock source, and prescaler\n</description>
              <bitOffset>28</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>clock source from internal 16 kHz oscillator</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>clock source from external 32kHz crystal clock</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>clock source from HCLK</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>clock source from internal OSC48M oscillator clock</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CLKDIV</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CLKDIV</displayName>
          <description>Clock Divider Number Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HCLK_N</name>
              <description>HCLK Clock Divide Number From HCLK Clock Source\nThe HCLK clock frequency = (HCLK clock source frequency) / (HCLK_N + 1)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_N</name>
              <description>UART Clock Divide Number From UART Clock Source\nThe UART clock frequency = (UART clock source frequency ) / (UART_N + 1)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_N</name>
              <description>ADC Clock Divide Number From ADC Clock Source\nThe ADC clock frequency = (ADC clock source frequency ) / (ADC_N + 1)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CLKSEL2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CLKSEL2</displayName>
          <description>Clock Source Select Control Register 2</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-write</access>
          <resetValue>0xFFFFFFF0</resetValue>
          <resetMask>0xFFFFFFF0</resetMask>
          <fields>
            <field>
              <name>I2S_S</name>
              <description>I2S Clock Source Select\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>clock source from internal 16 kHz oscillator</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>clock source from external 32kHz crystal clock</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>clock source from HCLK</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>clock source from internal OSC48M oscillator clock</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CLKSLEEP</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CLKSLEEP</displayName>
          <description>Sleep Clock Source Select  Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CPU_EN</name>
              <description>CPU Clock Sleep Enable (HCLK)\nMust be left as '1' for normal operation.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PDMA_EN</name>
              <description>PDMA Controller Sleep Clock Enable Control\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISP_EN</name>
              <description>Flash ISP Controller Sleep Clock Enable Control\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WDG_EN</name>
              <description>Watchdog  Sleep Clock Enable Control\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RTC_EN</name>
              <description>Real-Time- Sleep Clock APB Interface Clock Control\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR0_EN</name>
              <description>Timer0 Sleep Clock Enable Control\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR1_EN</name>
              <description>Timer1 Sleep Clock Enable Control\n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C0_EN</name>
              <description>I2C0 Sleep Clock Enable Control\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI0_EN</name>
              <description>SPI0 Sleep Clock Enable Control\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DPWM_EN</name>
              <description>Differential PWM Speaker Driver Sleep Clock Enable Control\n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>UART0_EN</name>
              <description>UART0 Sleep Clock Enable Control\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BIQALC_EN</name>
              <description>Biquad filter/ALC block Sleep Clock Enable Control\n</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CRC_EN</name>
              <description>Cyclic Redundancy Check Sleep Block Clock Enable Control\n</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM01_EN</name>
              <description>PWM Block Sleep Clock Enable Control\n</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ACMP_EN</name>
              <description>Analog Comparator Sleep Clock Enable Control\n</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SBRAM_EN</name>
              <description>Standby RAM Sleep Clock Enable Control\n</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_EN</name>
              <description>Audio Analog-Digital-Converter (ADC) Sleep Clock Enable Control\n</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>I2S_EN</name>
              <description>I2S Sleep Clock Enable Control\n</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ANA_EN</name>
              <description>Analog Block Sleep Clock Enable Control\n</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PFLAGCON</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PFLAGCON</displayName>
          <description>Power State Flag Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DS_FLAG</name>
              <description>Deep Sleep Flag\nThis flag is set if core logic was placed in Deep Sleep mode. Write '1' to clear flag.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STOP_FLAG</name>
              <description>Stop Flag\nThis flag is set if core logic was stopped but not powered down. Write '1' to clear flag.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_FLAG</name>
              <description>Powered Down Flag\nThis flag is set if core logic was powered down to Standby (SPD). Write '1' to clear flag.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>DBGPD</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>DBGPD</displayName>
          <description>Debug Port Power Down Disable Register</description>
          <addressOffset>0x28</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFF00</resetMask>
          <fields>
            <field>
              <name>DISABLE_PD</name>
              <description>Disable Power Down\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Enable power down requests</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Disable power down requests</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ICE_CLK</name>
              <description>ICE_CLK Pin State\nRead Only. Current state of ICE_CLK pin.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ICE_DAT</name>
              <description>ICE_DAT Pin State\nRead Only. Current state of ICE_DAT pin.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>GP</name>
      <description>GPIO Register Map</description>
      <groupName>GPIO</groupName>
      <baseAddress>0x50004000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x24</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x40</offset>
        <size>0x24</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x180</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>GPIOA_PMD</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPIOA_PMD</displayName>
          <description>GPIO Port A Pin I/O Mode Control</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PMD0</name>
              <description>GPIOx I/O Pin[n] Mode Control\nDetermine each I/O type of GPIOx pins.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in INPUT mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in OUTPUT mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-Drain mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD1</name>
              <description>GPIOx I/O Pin[n] Mode Control\nDetermine each I/O type of GPIOx pins.\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in INPUT mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in OUTPUT mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-Drain mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD2</name>
              <description>GPIOx I/O Pin[n] Mode Control\nDetermine each I/O type of GPIOx pins.\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in INPUT mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in OUTPUT mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-Drain mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD3</name>
              <description>GPIOx I/O Pin[n] Mode Control\nDetermine each I/O type of GPIOx pins.\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in INPUT mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in OUTPUT mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-Drain mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD4</name>
              <description>GPIOx I/O Pin[n] Mode Control\nDetermine each I/O type of GPIOx pins.\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in INPUT mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in OUTPUT mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-Drain mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD5</name>
              <description>GPIOx I/O Pin[n] Mode Control\nDetermine each I/O type of GPIOx pins.\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in INPUT mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in OUTPUT mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-Drain mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD6</name>
              <description>GPIOx I/O Pin[n] Mode Control\nDetermine each I/O type of GPIOx pins.\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in INPUT mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in OUTPUT mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-Drain mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD7</name>
              <description>GPIOx I/O Pin[n] Mode Control\nDetermine each I/O type of GPIOx pins.\n</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in INPUT mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in OUTPUT mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-Drain mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD8</name>
              <description>GPIOx I/O Pin[n] Mode Control\nDetermine each I/O type of GPIOx pins.\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in INPUT mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in OUTPUT mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-Drain mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD9</name>
              <description>GPIOx I/O Pin[n] Mode Control\nDetermine each I/O type of GPIOx pins.\n</description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in INPUT mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in OUTPUT mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-Drain mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD10</name>
              <description>GPIOx I/O Pin[n] Mode Control\nDetermine each I/O type of GPIOx pins.\n</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in INPUT mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in OUTPUT mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-Drain mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD11</name>
              <description>GPIOx I/O Pin[n] Mode Control\nDetermine each I/O type of GPIOx pins.\n</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in INPUT mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in OUTPUT mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-Drain mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD12</name>
              <description>GPIOx I/O Pin[n] Mode Control\nDetermine each I/O type of GPIOx pins.\n</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in INPUT mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in OUTPUT mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-Drain mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD13</name>
              <description>GPIOx I/O Pin[n] Mode Control\nDetermine each I/O type of GPIOx pins.\n</description>
              <bitOffset>26</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in INPUT mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in OUTPUT mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-Drain mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD14</name>
              <description>GPIOx I/O Pin[n] Mode Control\nDetermine each I/O type of GPIOx pins.\n</description>
              <bitOffset>28</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in INPUT mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in OUTPUT mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-Drain mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD15</name>
              <description>GPIOx I/O Pin[n] Mode Control\nDetermine each I/O type of GPIOx pins.\n</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in INPUT mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in OUTPUT mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-Drain mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPIOA_INDIS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPIOA_INDIS</displayName>
          <description>GPIO Port A Pin Digital Input Disable</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INDIS16</name>
              <description>GPIOx Pin[n] OFF Digital Input Path Enable\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Enable IO digital input path (Default)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Disable IO digital input path (low leakage mode)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INDIS17</name>
              <description>GPIOx Pin[n] OFF Digital Input Path Enable\n</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Enable IO digital input path (Default)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Disable IO digital input path (low leakage mode)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INDIS18</name>
              <description>GPIOx Pin[n] OFF Digital Input Path Enable\n</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Enable IO digital input path (Default)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Disable IO digital input path (low leakage mode)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INDIS19</name>
              <description>GPIOx Pin[n] OFF Digital Input Path Enable\n</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Enable IO digital input path (Default)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Disable IO digital input path (low leakage mode)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INDIS20</name>
              <description>GPIOx Pin[n] OFF Digital Input Path Enable\n</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Enable IO digital input path (Default)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Disable IO digital input path (low leakage mode)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INDIS21</name>
              <description>GPIOx Pin[n] OFF Digital Input Path Enable\n</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Enable IO digital input path (Default)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Disable IO digital input path (low leakage mode)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INDIS22</name>
              <description>GPIOx Pin[n] OFF Digital Input Path Enable\n</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Enable IO digital input path (Default)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Disable IO digital input path (low leakage mode)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INDIS23</name>
              <description>GPIOx Pin[n] OFF Digital Input Path Enable\n</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Enable IO digital input path (Default)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Disable IO digital input path (low leakage mode)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INDIS24</name>
              <description>GPIOx Pin[n] OFF Digital Input Path Enable\n</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Enable IO digital input path (Default)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Disable IO digital input path (low leakage mode)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INDIS25</name>
              <description>GPIOx Pin[n] OFF Digital Input Path Enable\n</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Enable IO digital input path (Default)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Disable IO digital input path (low leakage mode)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INDIS26</name>
              <description>GPIOx Pin[n] OFF Digital Input Path Enable\n</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Enable IO digital input path (Default)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Disable IO digital input path (low leakage mode)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INDIS27</name>
              <description>GPIOx Pin[n] OFF Digital Input Path Enable\n</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Enable IO digital input path (Default)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Disable IO digital input path (low leakage mode)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INDIS28</name>
              <description>GPIOx Pin[n] OFF Digital Input Path Enable\n</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Enable IO digital input path (Default)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Disable IO digital input path (low leakage mode)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INDIS29</name>
              <description>GPIOx Pin[n] OFF Digital Input Path Enable\n</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Enable IO digital input path (Default)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Disable IO digital input path (low leakage mode)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INDIS30</name>
              <description>GPIOx Pin[n] OFF Digital Input Path Enable\n</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Enable IO digital input path (Default)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Disable IO digital input path (low leakage mode)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INDIS31</name>
              <description>GPIOx Pin[n] OFF Digital Input Path Enable\n</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Enable IO digital input path (Default)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Disable IO digital input path (low leakage mode)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPIOA_DOUT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPIOA_DOUT</displayName>
          <description>GPIO Port A Data Output Value</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x0000FFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DOUT0</name>
              <description>GPIOx Pin[n] Output Value\nEach of these bits controls the status of a GPIO pin when the GPIO pin is configured as output, open-drain or quasi-bidirectional mode.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B] Pin[n] will drive Low if the corresponding output mode bit is set</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B] Pin[n] will drive High if the corresponding output mode bit is set</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT1</name>
              <description>GPIOx Pin[n] Output Value\nEach of these bits controls the status of a GPIO pin when the GPIO pin is configured as output, open-drain or quasi-bidirectional mode.\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B] Pin[n] will drive Low if the corresponding output mode bit is set</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B] Pin[n] will drive High if the corresponding output mode bit is set</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT2</name>
              <description>GPIOx Pin[n] Output Value\nEach of these bits controls the status of a GPIO pin when the GPIO pin is configured as output, open-drain or quasi-bidirectional mode.\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B] Pin[n] will drive Low if the corresponding output mode bit is set</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B] Pin[n] will drive High if the corresponding output mode bit is set</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT3</name>
              <description>GPIOx Pin[n] Output Value\nEach of these bits controls the status of a GPIO pin when the GPIO pin is configured as output, open-drain or quasi-bidirectional mode.\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B] Pin[n] will drive Low if the corresponding output mode bit is set</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B] Pin[n] will drive High if the corresponding output mode bit is set</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT4</name>
              <description>GPIOx Pin[n] Output Value\nEach of these bits controls the status of a GPIO pin when the GPIO pin is configured as output, open-drain or quasi-bidirectional mode.\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B] Pin[n] will drive Low if the corresponding output mode bit is set</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B] Pin[n] will drive High if the corresponding output mode bit is set</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT5</name>
              <description>GPIOx Pin[n] Output Value\nEach of these bits controls the status of a GPIO pin when the GPIO pin is configured as output, open-drain or quasi-bidirectional mode.\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B] Pin[n] will drive Low if the corresponding output mode bit is set</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B] Pin[n] will drive High if the corresponding output mode bit is set</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT6</name>
              <description>GPIOx Pin[n] Output Value\nEach of these bits controls the status of a GPIO pin when the GPIO pin is configured as output, open-drain or quasi-bidirectional mode.\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B] Pin[n] will drive Low if the corresponding output mode bit is set</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B] Pin[n] will drive High if the corresponding output mode bit is set</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT7</name>
              <description>GPIOx Pin[n] Output Value\nEach of these bits controls the status of a GPIO pin when the GPIO pin is configured as output, open-drain or quasi-bidirectional mode.\n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B] Pin[n] will drive Low if the corresponding output mode bit is set</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B] Pin[n] will drive High if the corresponding output mode bit is set</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT8</name>
              <description>GPIOx Pin[n] Output Value\nEach of these bits controls the status of a GPIO pin when the GPIO pin is configured as output, open-drain or quasi-bidirectional mode.\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B] Pin[n] will drive Low if the corresponding output mode bit is set</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B] Pin[n] will drive High if the corresponding output mode bit is set</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT9</name>
              <description>GPIOx Pin[n] Output Value\nEach of these bits controls the status of a GPIO pin when the GPIO pin is configured as output, open-drain or quasi-bidirectional mode.\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B] Pin[n] will drive Low if the corresponding output mode bit is set</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B] Pin[n] will drive High if the corresponding output mode bit is set</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT10</name>
              <description>GPIOx Pin[n] Output Value\nEach of these bits controls the status of a GPIO pin when the GPIO pin is configured as output, open-drain or quasi-bidirectional mode.\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B] Pin[n] will drive Low if the corresponding output mode bit is set</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B] Pin[n] will drive High if the corresponding output mode bit is set</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT11</name>
              <description>GPIOx Pin[n] Output Value\nEach of these bits controls the status of a GPIO pin when the GPIO pin is configured as output, open-drain or quasi-bidirectional mode.\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B] Pin[n] will drive Low if the corresponding output mode bit is set</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B] Pin[n] will drive High if the corresponding output mode bit is set</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT12</name>
              <description>GPIOx Pin[n] Output Value\nEach of these bits controls the status of a GPIO pin when the GPIO pin is configured as output, open-drain or quasi-bidirectional mode.\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B] Pin[n] will drive Low if the corresponding output mode bit is set</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B] Pin[n] will drive High if the corresponding output mode bit is set</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT13</name>
              <description>GPIOx Pin[n] Output Value\nEach of these bits controls the status of a GPIO pin when the GPIO pin is configured as output, open-drain or quasi-bidirectional mode.\n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B] Pin[n] will drive Low if the corresponding output mode bit is set</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B] Pin[n] will drive High if the corresponding output mode bit is set</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT14</name>
              <description>GPIOx Pin[n] Output Value\nEach of these bits controls the status of a GPIO pin when the GPIO pin is configured as output, open-drain or quasi-bidirectional mode.\n</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B] Pin[n] will drive Low if the corresponding output mode bit is set</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B] Pin[n] will drive High if the corresponding output mode bit is set</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT15</name>
              <description>GPIOx Pin[n] Output Value\nEach of these bits controls the status of a GPIO pin when the GPIO pin is configured as output, open-drain or quasi-bidirectional mode.\n</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B] Pin[n] will drive Low if the corresponding output mode bit is set</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B] Pin[n] will drive High if the corresponding output mode bit is set</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPIOA_DMASK</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPIOA_DMASK</displayName>
          <description>GPIO Port A Data Output Write Mask</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>DMASK0</name>
              <description>Port [A/B] Data Output Write Mask\nThese bits are used to protect the corresponding register of GPIOx_DOUT bit[n] . When set the DMASK bit[n] to "1", the corresponding DOUTn bit is write protected. \n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The corresponding GPIO_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The corresponding GPIO_DOUT[n] bit is read only</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK1</name>
              <description>Port [A/B] Data Output Write Mask\nThese bits are used to protect the corresponding register of GPIOx_DOUT bit[n] . When set the DMASK bit[n] to "1", the corresponding DOUTn bit is write protected. \n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The corresponding GPIO_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The corresponding GPIO_DOUT[n] bit is read only</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK2</name>
              <description>Port [A/B] Data Output Write Mask\nThese bits are used to protect the corresponding register of GPIOx_DOUT bit[n] . When set the DMASK bit[n] to "1", the corresponding DOUTn bit is write protected. \n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The corresponding GPIO_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The corresponding GPIO_DOUT[n] bit is read only</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK3</name>
              <description>Port [A/B] Data Output Write Mask\nThese bits are used to protect the corresponding register of GPIOx_DOUT bit[n] . When set the DMASK bit[n] to "1", the corresponding DOUTn bit is write protected. \n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The corresponding GPIO_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The corresponding GPIO_DOUT[n] bit is read only</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK4</name>
              <description>Port [A/B] Data Output Write Mask\nThese bits are used to protect the corresponding register of GPIOx_DOUT bit[n] . When set the DMASK bit[n] to "1", the corresponding DOUTn bit is write protected. \n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The corresponding GPIO_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The corresponding GPIO_DOUT[n] bit is read only</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK5</name>
              <description>Port [A/B] Data Output Write Mask\nThese bits are used to protect the corresponding register of GPIOx_DOUT bit[n] . When set the DMASK bit[n] to "1", the corresponding DOUTn bit is write protected. \n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The corresponding GPIO_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The corresponding GPIO_DOUT[n] bit is read only</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK6</name>
              <description>Port [A/B] Data Output Write Mask\nThese bits are used to protect the corresponding register of GPIOx_DOUT bit[n] . When set the DMASK bit[n] to "1", the corresponding DOUTn bit is write protected. \n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The corresponding GPIO_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The corresponding GPIO_DOUT[n] bit is read only</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK7</name>
              <description>Port [A/B] Data Output Write Mask\nThese bits are used to protect the corresponding register of GPIOx_DOUT bit[n] . When set the DMASK bit[n] to "1", the corresponding DOUTn bit is write protected. \n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The corresponding GPIO_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The corresponding GPIO_DOUT[n] bit is read only</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK8</name>
              <description>Port [A/B] Data Output Write Mask\nThese bits are used to protect the corresponding register of GPIOx_DOUT bit[n] . When set the DMASK bit[n] to "1", the corresponding DOUTn bit is write protected. \n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The corresponding GPIO_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The corresponding GPIO_DOUT[n] bit is read only</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK9</name>
              <description>Port [A/B] Data Output Write Mask\nThese bits are used to protect the corresponding register of GPIOx_DOUT bit[n] . When set the DMASK bit[n] to "1", the corresponding DOUTn bit is write protected. \n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The corresponding GPIO_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The corresponding GPIO_DOUT[n] bit is read only</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK10</name>
              <description>Port [A/B] Data Output Write Mask\nThese bits are used to protect the corresponding register of GPIOx_DOUT bit[n] . When set the DMASK bit[n] to "1", the corresponding DOUTn bit is write protected. \n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The corresponding GPIO_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The corresponding GPIO_DOUT[n] bit is read only</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK11</name>
              <description>Port [A/B] Data Output Write Mask\nThese bits are used to protect the corresponding register of GPIOx_DOUT bit[n] . When set the DMASK bit[n] to "1", the corresponding DOUTn bit is write protected. \n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The corresponding GPIO_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The corresponding GPIO_DOUT[n] bit is read only</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK12</name>
              <description>Port [A/B] Data Output Write Mask\nThese bits are used to protect the corresponding register of GPIOx_DOUT bit[n] . When set the DMASK bit[n] to "1", the corresponding DOUTn bit is write protected. \n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The corresponding GPIO_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The corresponding GPIO_DOUT[n] bit is read only</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK13</name>
              <description>Port [A/B] Data Output Write Mask\nThese bits are used to protect the corresponding register of GPIOx_DOUT bit[n] . When set the DMASK bit[n] to "1", the corresponding DOUTn bit is write protected. \n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The corresponding GPIO_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The corresponding GPIO_DOUT[n] bit is read only</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK14</name>
              <description>Port [A/B] Data Output Write Mask\nThese bits are used to protect the corresponding register of GPIOx_DOUT bit[n] . When set the DMASK bit[n] to "1", the corresponding DOUTn bit is write protected. \n</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The corresponding GPIO_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The corresponding GPIO_DOUT[n] bit is read only</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK15</name>
              <description>Port [A/B] Data Output Write Mask\nThese bits are used to protect the corresponding register of GPIOx_DOUT bit[n] . When set the DMASK bit[n] to "1", the corresponding DOUTn bit is write protected. \n</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The corresponding GPIO_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The corresponding GPIO_DOUT[n] bit is read only</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPIOA_PIN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPIOA_PIN</displayName>
          <description>GPIO Port A Pin Value</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFF0000</resetMask>
          <fields>
            <field>
              <name>PIN0</name>
              <description>Port [A/B] Pin Values\nThe value read from each of these bit reflects the actual status of the respective GPIO pin</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN1</name>
              <description>Port [A/B] Pin Values\nThe value read from each of these bit reflects the actual status of the respective GPIO pin</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN2</name>
              <description>Port [A/B] Pin Values\nThe value read from each of these bit reflects the actual status of the respective GPIO pin</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN3</name>
              <description>Port [A/B] Pin Values\nThe value read from each of these bit reflects the actual status of the respective GPIO pin</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN4</name>
              <description>Port [A/B] Pin Values\nThe value read from each of these bit reflects the actual status of the respective GPIO pin</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN5</name>
              <description>Port [A/B] Pin Values\nThe value read from each of these bit reflects the actual status of the respective GPIO pin</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN6</name>
              <description>Port [A/B] Pin Values\nThe value read from each of these bit reflects the actual status of the respective GPIO pin</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN7</name>
              <description>Port [A/B] Pin Values\nThe value read from each of these bit reflects the actual status of the respective GPIO pin</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN8</name>
              <description>Port [A/B] Pin Values\nThe value read from each of these bit reflects the actual status of the respective GPIO pin</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN9</name>
              <description>Port [A/B] Pin Values\nThe value read from each of these bit reflects the actual status of the respective GPIO pin</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN10</name>
              <description>Port [A/B] Pin Values\nThe value read from each of these bit reflects the actual status of the respective GPIO pin</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN11</name>
              <description>Port [A/B] Pin Values\nThe value read from each of these bit reflects the actual status of the respective GPIO pin</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN12</name>
              <description>Port [A/B] Pin Values\nThe value read from each of these bit reflects the actual status of the respective GPIO pin</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN13</name>
              <description>Port [A/B] Pin Values\nThe value read from each of these bit reflects the actual status of the respective GPIO pin</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN14</name>
              <description>Port [A/B] Pin Values\nThe value read from each of these bit reflects the actual status of the respective GPIO pin</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN15</name>
              <description>Port [A/B] Pin Values\nThe value read from each of these bit reflects the actual status of the respective GPIO pin</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPIOA_DBEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPIOA_DBEN</displayName>
          <description>GPIO Port A De-bounce Enable</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>DBEN0</name>
              <description>Port [A/B] Input Signal De-bounce Enable\nDBEN[n]used to enable the de-bounce function for each corresponding bit. For an edge triggered interrupt to be generated, input signal must be valid for two consecutive de-bounce periods. The de-bounce time is controlled by the DBNCECON register.  \nThe DBEN[n] is used for "edge-trigger" interrupt only; it is ignored for "level trigger" interrupt\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The bit[n] de-bounce function is disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The bit[n] de-bounce function is enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN1</name>
              <description>Port [A/B] Input Signal De-bounce Enable\nDBEN[n]used to enable the de-bounce function for each corresponding bit. For an edge triggered interrupt to be generated, input signal must be valid for two consecutive de-bounce periods. The de-bounce time is controlled by the DBNCECON register.  \nThe DBEN[n] is used for "edge-trigger" interrupt only; it is ignored for "level trigger" interrupt\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The bit[n] de-bounce function is disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The bit[n] de-bounce function is enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN2</name>
              <description>Port [A/B] Input Signal De-bounce Enable\nDBEN[n]used to enable the de-bounce function for each corresponding bit. For an edge triggered interrupt to be generated, input signal must be valid for two consecutive de-bounce periods. The de-bounce time is controlled by the DBNCECON register.  \nThe DBEN[n] is used for "edge-trigger" interrupt only; it is ignored for "level trigger" interrupt\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The bit[n] de-bounce function is disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The bit[n] de-bounce function is enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN3</name>
              <description>Port [A/B] Input Signal De-bounce Enable\nDBEN[n]used to enable the de-bounce function for each corresponding bit. For an edge triggered interrupt to be generated, input signal must be valid for two consecutive de-bounce periods. The de-bounce time is controlled by the DBNCECON register.  \nThe DBEN[n] is used for "edge-trigger" interrupt only; it is ignored for "level trigger" interrupt\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The bit[n] de-bounce function is disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The bit[n] de-bounce function is enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN4</name>
              <description>Port [A/B] Input Signal De-bounce Enable\nDBEN[n]used to enable the de-bounce function for each corresponding bit. For an edge triggered interrupt to be generated, input signal must be valid for two consecutive de-bounce periods. The de-bounce time is controlled by the DBNCECON register.  \nThe DBEN[n] is used for "edge-trigger" interrupt only; it is ignored for "level trigger" interrupt\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The bit[n] de-bounce function is disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The bit[n] de-bounce function is enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN5</name>
              <description>Port [A/B] Input Signal De-bounce Enable\nDBEN[n]used to enable the de-bounce function for each corresponding bit. For an edge triggered interrupt to be generated, input signal must be valid for two consecutive de-bounce periods. The de-bounce time is controlled by the DBNCECON register.  \nThe DBEN[n] is used for "edge-trigger" interrupt only; it is ignored for "level trigger" interrupt\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The bit[n] de-bounce function is disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The bit[n] de-bounce function is enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN6</name>
              <description>Port [A/B] Input Signal De-bounce Enable\nDBEN[n]used to enable the de-bounce function for each corresponding bit. For an edge triggered interrupt to be generated, input signal must be valid for two consecutive de-bounce periods. The de-bounce time is controlled by the DBNCECON register.  \nThe DBEN[n] is used for "edge-trigger" interrupt only; it is ignored for "level trigger" interrupt\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The bit[n] de-bounce function is disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The bit[n] de-bounce function is enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN7</name>
              <description>Port [A/B] Input Signal De-bounce Enable\nDBEN[n]used to enable the de-bounce function for each corresponding bit. For an edge triggered interrupt to be generated, input signal must be valid for two consecutive de-bounce periods. The de-bounce time is controlled by the DBNCECON register.  \nThe DBEN[n] is used for "edge-trigger" interrupt only; it is ignored for "level trigger" interrupt\n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The bit[n] de-bounce function is disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The bit[n] de-bounce function is enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN8</name>
              <description>Port [A/B] Input Signal De-bounce Enable\nDBEN[n]used to enable the de-bounce function for each corresponding bit. For an edge triggered interrupt to be generated, input signal must be valid for two consecutive de-bounce periods. The de-bounce time is controlled by the DBNCECON register.  \nThe DBEN[n] is used for "edge-trigger" interrupt only; it is ignored for "level trigger" interrupt\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The bit[n] de-bounce function is disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The bit[n] de-bounce function is enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN9</name>
              <description>Port [A/B] Input Signal De-bounce Enable\nDBEN[n]used to enable the de-bounce function for each corresponding bit. For an edge triggered interrupt to be generated, input signal must be valid for two consecutive de-bounce periods. The de-bounce time is controlled by the DBNCECON register.  \nThe DBEN[n] is used for "edge-trigger" interrupt only; it is ignored for "level trigger" interrupt\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The bit[n] de-bounce function is disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The bit[n] de-bounce function is enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN10</name>
              <description>Port [A/B] Input Signal De-bounce Enable\nDBEN[n]used to enable the de-bounce function for each corresponding bit. For an edge triggered interrupt to be generated, input signal must be valid for two consecutive de-bounce periods. The de-bounce time is controlled by the DBNCECON register.  \nThe DBEN[n] is used for "edge-trigger" interrupt only; it is ignored for "level trigger" interrupt\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The bit[n] de-bounce function is disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The bit[n] de-bounce function is enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN11</name>
              <description>Port [A/B] Input Signal De-bounce Enable\nDBEN[n]used to enable the de-bounce function for each corresponding bit. For an edge triggered interrupt to be generated, input signal must be valid for two consecutive de-bounce periods. The de-bounce time is controlled by the DBNCECON register.  \nThe DBEN[n] is used for "edge-trigger" interrupt only; it is ignored for "level trigger" interrupt\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The bit[n] de-bounce function is disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The bit[n] de-bounce function is enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN12</name>
              <description>Port [A/B] Input Signal De-bounce Enable\nDBEN[n]used to enable the de-bounce function for each corresponding bit. For an edge triggered interrupt to be generated, input signal must be valid for two consecutive de-bounce periods. The de-bounce time is controlled by the DBNCECON register.  \nThe DBEN[n] is used for "edge-trigger" interrupt only; it is ignored for "level trigger" interrupt\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The bit[n] de-bounce function is disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The bit[n] de-bounce function is enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN13</name>
              <description>Port [A/B] Input Signal De-bounce Enable\nDBEN[n]used to enable the de-bounce function for each corresponding bit. For an edge triggered interrupt to be generated, input signal must be valid for two consecutive de-bounce periods. The de-bounce time is controlled by the DBNCECON register.  \nThe DBEN[n] is used for "edge-trigger" interrupt only; it is ignored for "level trigger" interrupt\n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The bit[n] de-bounce function is disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The bit[n] de-bounce function is enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN14</name>
              <description>Port [A/B] Input Signal De-bounce Enable\nDBEN[n]used to enable the de-bounce function for each corresponding bit. For an edge triggered interrupt to be generated, input signal must be valid for two consecutive de-bounce periods. The de-bounce time is controlled by the DBNCECON register.  \nThe DBEN[n] is used for "edge-trigger" interrupt only; it is ignored for "level trigger" interrupt\n</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The bit[n] de-bounce function is disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The bit[n] de-bounce function is enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN15</name>
              <description>Port [A/B] Input Signal De-bounce Enable\nDBEN[n]used to enable the de-bounce function for each corresponding bit. For an edge triggered interrupt to be generated, input signal must be valid for two consecutive de-bounce periods. The de-bounce time is controlled by the DBNCECON register.  \nThe DBEN[n] is used for "edge-trigger" interrupt only; it is ignored for "level trigger" interrupt\n</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The bit[n] de-bounce function is disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The bit[n] de-bounce function is enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPIOA_IMD</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPIOA_IMD</displayName>
          <description>GPIO Port A Interrupt Mode Control</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>IMD0</name>
              <description>Port [A/B] Edge Or Level Detection Interrupt Control\nIMD[n] used to control whether the interrupt mode is level triggered or edge triggered. If the interrupt mode is edge triggered, edge de-bounce is controlled by the DBEN register. If the interrupt mode is level triggered, the input source is sampled each clock to generate an interrupt.\nIf level triggered interrupt is selected, then only one level can be selected in the  GPIOX_IEN register. If both levels are set no interrupt will occur.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge triggered interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level triggered interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD1</name>
              <description>Port [A/B] Edge Or Level Detection Interrupt Control\nIMD[n] used to control whether the interrupt mode is level triggered or edge triggered. If the interrupt mode is edge triggered, edge de-bounce is controlled by the DBEN register. If the interrupt mode is level triggered, the input source is sampled each clock to generate an interrupt.\nIf level triggered interrupt is selected, then only one level can be selected in the  GPIOX_IEN register. If both levels are set no interrupt will occur.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge triggered interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level triggered interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD2</name>
              <description>Port [A/B] Edge Or Level Detection Interrupt Control\nIMD[n] used to control whether the interrupt mode is level triggered or edge triggered. If the interrupt mode is edge triggered, edge de-bounce is controlled by the DBEN register. If the interrupt mode is level triggered, the input source is sampled each clock to generate an interrupt.\nIf level triggered interrupt is selected, then only one level can be selected in the  GPIOX_IEN register. If both levels are set no interrupt will occur.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge triggered interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level triggered interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD3</name>
              <description>Port [A/B] Edge Or Level Detection Interrupt Control\nIMD[n] used to control whether the interrupt mode is level triggered or edge triggered. If the interrupt mode is edge triggered, edge de-bounce is controlled by the DBEN register. If the interrupt mode is level triggered, the input source is sampled each clock to generate an interrupt.\nIf level triggered interrupt is selected, then only one level can be selected in the  GPIOX_IEN register. If both levels are set no interrupt will occur.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge triggered interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level triggered interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD4</name>
              <description>Port [A/B] Edge Or Level Detection Interrupt Control\nIMD[n] used to control whether the interrupt mode is level triggered or edge triggered. If the interrupt mode is edge triggered, edge de-bounce is controlled by the DBEN register. If the interrupt mode is level triggered, the input source is sampled each clock to generate an interrupt.\nIf level triggered interrupt is selected, then only one level can be selected in the  GPIOX_IEN register. If both levels are set no interrupt will occur.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge triggered interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level triggered interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD5</name>
              <description>Port [A/B] Edge Or Level Detection Interrupt Control\nIMD[n] used to control whether the interrupt mode is level triggered or edge triggered. If the interrupt mode is edge triggered, edge de-bounce is controlled by the DBEN register. If the interrupt mode is level triggered, the input source is sampled each clock to generate an interrupt.\nIf level triggered interrupt is selected, then only one level can be selected in the  GPIOX_IEN register. If both levels are set no interrupt will occur.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge triggered interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level triggered interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD6</name>
              <description>Port [A/B] Edge Or Level Detection Interrupt Control\nIMD[n] used to control whether the interrupt mode is level triggered or edge triggered. If the interrupt mode is edge triggered, edge de-bounce is controlled by the DBEN register. If the interrupt mode is level triggered, the input source is sampled each clock to generate an interrupt.\nIf level triggered interrupt is selected, then only one level can be selected in the  GPIOX_IEN register. If both levels are set no interrupt will occur.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge triggered interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level triggered interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD7</name>
              <description>Port [A/B] Edge Or Level Detection Interrupt Control\nIMD[n] used to control whether the interrupt mode is level triggered or edge triggered. If the interrupt mode is edge triggered, edge de-bounce is controlled by the DBEN register. If the interrupt mode is level triggered, the input source is sampled each clock to generate an interrupt.\nIf level triggered interrupt is selected, then only one level can be selected in the  GPIOX_IEN register. If both levels are set no interrupt will occur.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge triggered interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level triggered interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD8</name>
              <description>Port [A/B] Edge Or Level Detection Interrupt Control\nIMD[n] used to control whether the interrupt mode is level triggered or edge triggered. If the interrupt mode is edge triggered, edge de-bounce is controlled by the DBEN register. If the interrupt mode is level triggered, the input source is sampled each clock to generate an interrupt.\nIf level triggered interrupt is selected, then only one level can be selected in the  GPIOX_IEN register. If both levels are set no interrupt will occur.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge triggered interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level triggered interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD9</name>
              <description>Port [A/B] Edge Or Level Detection Interrupt Control\nIMD[n] used to control whether the interrupt mode is level triggered or edge triggered. If the interrupt mode is edge triggered, edge de-bounce is controlled by the DBEN register. If the interrupt mode is level triggered, the input source is sampled each clock to generate an interrupt.\nIf level triggered interrupt is selected, then only one level can be selected in the  GPIOX_IEN register. If both levels are set no interrupt will occur.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge triggered interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level triggered interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD10</name>
              <description>Port [A/B] Edge Or Level Detection Interrupt Control\nIMD[n] used to control whether the interrupt mode is level triggered or edge triggered. If the interrupt mode is edge triggered, edge de-bounce is controlled by the DBEN register. If the interrupt mode is level triggered, the input source is sampled each clock to generate an interrupt.\nIf level triggered interrupt is selected, then only one level can be selected in the  GPIOX_IEN register. If both levels are set no interrupt will occur.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge triggered interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level triggered interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD11</name>
              <description>Port [A/B] Edge Or Level Detection Interrupt Control\nIMD[n] used to control whether the interrupt mode is level triggered or edge triggered. If the interrupt mode is edge triggered, edge de-bounce is controlled by the DBEN register. If the interrupt mode is level triggered, the input source is sampled each clock to generate an interrupt.\nIf level triggered interrupt is selected, then only one level can be selected in the  GPIOX_IEN register. If both levels are set no interrupt will occur.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge triggered interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level triggered interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD12</name>
              <description>Port [A/B] Edge Or Level Detection Interrupt Control\nIMD[n] used to control whether the interrupt mode is level triggered or edge triggered. If the interrupt mode is edge triggered, edge de-bounce is controlled by the DBEN register. If the interrupt mode is level triggered, the input source is sampled each clock to generate an interrupt.\nIf level triggered interrupt is selected, then only one level can be selected in the  GPIOX_IEN register. If both levels are set no interrupt will occur.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge triggered interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level triggered interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD13</name>
              <description>Port [A/B] Edge Or Level Detection Interrupt Control\nIMD[n] used to control whether the interrupt mode is level triggered or edge triggered. If the interrupt mode is edge triggered, edge de-bounce is controlled by the DBEN register. If the interrupt mode is level triggered, the input source is sampled each clock to generate an interrupt.\nIf level triggered interrupt is selected, then only one level can be selected in the  GPIOX_IEN register. If both levels are set no interrupt will occur.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge triggered interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level triggered interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD14</name>
              <description>Port [A/B] Edge Or Level Detection Interrupt Control\nIMD[n] used to control whether the interrupt mode is level triggered or edge triggered. If the interrupt mode is edge triggered, edge de-bounce is controlled by the DBEN register. If the interrupt mode is level triggered, the input source is sampled each clock to generate an interrupt.\nIf level triggered interrupt is selected, then only one level can be selected in the  GPIOX_IEN register. If both levels are set no interrupt will occur.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge triggered interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level triggered interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD15</name>
              <description>Port [A/B] Edge Or Level Detection Interrupt Control\nIMD[n] used to control whether the interrupt mode is level triggered or edge triggered. If the interrupt mode is edge triggered, edge de-bounce is controlled by the DBEN register. If the interrupt mode is level triggered, the input source is sampled each clock to generate an interrupt.\nIf level triggered interrupt is selected, then only one level can be selected in the  GPIOX_IEN register. If both levels are set no interrupt will occur.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge triggered interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level triggered interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPIOA_IEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPIOA_IEN</displayName>
          <description>GPIO Port A Interrupt Enable</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IF_EN0</name>
              <description>Port [A/B] Interrupt Enable by Input Falling Edge or Input Level Low\nIF_EN[n] is used to enable the falling/low interrupt for each of the corresponding GPIO pins. It also enables the pin wakeup function.\nIf the interrupt is configured in level trigger mode, a level "low" will generate an interrupt.\nIf the interrupt is configured in edge trigger mode, a state change from "high-to-low" will generate an interrupt.\nGPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable GPIOx[n] for low-level or high-to-low interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable GPIOx[n] for low-level or high-to-low interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN1</name>
              <description>Port [A/B] Interrupt Enable by Input Falling Edge or Input Level Low\nIF_EN[n] is used to enable the falling/low interrupt for each of the corresponding GPIO pins. It also enables the pin wakeup function.\nIf the interrupt is configured in level trigger mode, a level "low" will generate an interrupt.\nIf the interrupt is configured in edge trigger mode, a state change from "high-to-low" will generate an interrupt.\nGPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable GPIOx[n] for low-level or high-to-low interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable GPIOx[n] for low-level or high-to-low interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN2</name>
              <description>Port [A/B] Interrupt Enable by Input Falling Edge or Input Level Low\nIF_EN[n] is used to enable the falling/low interrupt for each of the corresponding GPIO pins. It also enables the pin wakeup function.\nIf the interrupt is configured in level trigger mode, a level "low" will generate an interrupt.\nIf the interrupt is configured in edge trigger mode, a state change from "high-to-low" will generate an interrupt.\nGPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable GPIOx[n] for low-level or high-to-low interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable GPIOx[n] for low-level or high-to-low interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN3</name>
              <description>Port [A/B] Interrupt Enable by Input Falling Edge or Input Level Low\nIF_EN[n] is used to enable the falling/low interrupt for each of the corresponding GPIO pins. It also enables the pin wakeup function.\nIf the interrupt is configured in level trigger mode, a level "low" will generate an interrupt.\nIf the interrupt is configured in edge trigger mode, a state change from "high-to-low" will generate an interrupt.\nGPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable GPIOx[n] for low-level or high-to-low interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable GPIOx[n] for low-level or high-to-low interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN4</name>
              <description>Port [A/B] Interrupt Enable by Input Falling Edge or Input Level Low\nIF_EN[n] is used to enable the falling/low interrupt for each of the corresponding GPIO pins. It also enables the pin wakeup function.\nIf the interrupt is configured in level trigger mode, a level "low" will generate an interrupt.\nIf the interrupt is configured in edge trigger mode, a state change from "high-to-low" will generate an interrupt.\nGPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable GPIOx[n] for low-level or high-to-low interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable GPIOx[n] for low-level or high-to-low interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN5</name>
              <description>Port [A/B] Interrupt Enable by Input Falling Edge or Input Level Low\nIF_EN[n] is used to enable the falling/low interrupt for each of the corresponding GPIO pins. It also enables the pin wakeup function.\nIf the interrupt is configured in level trigger mode, a level "low" will generate an interrupt.\nIf the interrupt is configured in edge trigger mode, a state change from "high-to-low" will generate an interrupt.\nGPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable GPIOx[n] for low-level or high-to-low interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable GPIOx[n] for low-level or high-to-low interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN6</name>
              <description>Port [A/B] Interrupt Enable by Input Falling Edge or Input Level Low\nIF_EN[n] is used to enable the falling/low interrupt for each of the corresponding GPIO pins. It also enables the pin wakeup function.\nIf the interrupt is configured in level trigger mode, a level "low" will generate an interrupt.\nIf the interrupt is configured in edge trigger mode, a state change from "high-to-low" will generate an interrupt.\nGPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable GPIOx[n] for low-level or high-to-low interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable GPIOx[n] for low-level or high-to-low interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN7</name>
              <description>Port [A/B] Interrupt Enable by Input Falling Edge or Input Level Low\nIF_EN[n] is used to enable the falling/low interrupt for each of the corresponding GPIO pins. It also enables the pin wakeup function.\nIf the interrupt is configured in level trigger mode, a level "low" will generate an interrupt.\nIf the interrupt is configured in edge trigger mode, a state change from "high-to-low" will generate an interrupt.\nGPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.\n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable GPIOx[n] for low-level or high-to-low interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable GPIOx[n] for low-level or high-to-low interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN8</name>
              <description>Port [A/B] Interrupt Enable by Input Falling Edge or Input Level Low\nIF_EN[n] is used to enable the falling/low interrupt for each of the corresponding GPIO pins. It also enables the pin wakeup function.\nIf the interrupt is configured in level trigger mode, a level "low" will generate an interrupt.\nIf the interrupt is configured in edge trigger mode, a state change from "high-to-low" will generate an interrupt.\nGPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable GPIOx[n] for low-level or high-to-low interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable GPIOx[n] for low-level or high-to-low interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN9</name>
              <description>Port [A/B] Interrupt Enable by Input Falling Edge or Input Level Low\nIF_EN[n] is used to enable the falling/low interrupt for each of the corresponding GPIO pins. It also enables the pin wakeup function.\nIf the interrupt is configured in level trigger mode, a level "low" will generate an interrupt.\nIf the interrupt is configured in edge trigger mode, a state change from "high-to-low" will generate an interrupt.\nGPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable GPIOx[n] for low-level or high-to-low interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable GPIOx[n] for low-level or high-to-low interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN10</name>
              <description>Port [A/B] Interrupt Enable by Input Falling Edge or Input Level Low\nIF_EN[n] is used to enable the falling/low interrupt for each of the corresponding GPIO pins. It also enables the pin wakeup function.\nIf the interrupt is configured in level trigger mode, a level "low" will generate an interrupt.\nIf the interrupt is configured in edge trigger mode, a state change from "high-to-low" will generate an interrupt.\nGPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable GPIOx[n] for low-level or high-to-low interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable GPIOx[n] for low-level or high-to-low interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN11</name>
              <description>Port [A/B] Interrupt Enable by Input Falling Edge or Input Level Low\nIF_EN[n] is used to enable the falling/low interrupt for each of the corresponding GPIO pins. It also enables the pin wakeup function.\nIf the interrupt is configured in level trigger mode, a level "low" will generate an interrupt.\nIf the interrupt is configured in edge trigger mode, a state change from "high-to-low" will generate an interrupt.\nGPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable GPIOx[n] for low-level or high-to-low interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable GPIOx[n] for low-level or high-to-low interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN12</name>
              <description>Port [A/B] Interrupt Enable by Input Falling Edge or Input Level Low\nIF_EN[n] is used to enable the falling/low interrupt for each of the corresponding GPIO pins. It also enables the pin wakeup function.\nIf the interrupt is configured in level trigger mode, a level "low" will generate an interrupt.\nIf the interrupt is configured in edge trigger mode, a state change from "high-to-low" will generate an interrupt.\nGPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable GPIOx[n] for low-level or high-to-low interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable GPIOx[n] for low-level or high-to-low interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN13</name>
              <description>Port [A/B] Interrupt Enable by Input Falling Edge or Input Level Low\nIF_EN[n] is used to enable the falling/low interrupt for each of the corresponding GPIO pins. It also enables the pin wakeup function.\nIf the interrupt is configured in level trigger mode, a level "low" will generate an interrupt.\nIf the interrupt is configured in edge trigger mode, a state change from "high-to-low" will generate an interrupt.\nGPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.\n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable GPIOx[n] for low-level or high-to-low interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable GPIOx[n] for low-level or high-to-low interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN14</name>
              <description>Port [A/B] Interrupt Enable by Input Falling Edge or Input Level Low\nIF_EN[n] is used to enable the falling/low interrupt for each of the corresponding GPIO pins. It also enables the pin wakeup function.\nIf the interrupt is configured in level trigger mode, a level "low" will generate an interrupt.\nIf the interrupt is configured in edge trigger mode, a state change from "high-to-low" will generate an interrupt.\nGPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.\n</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable GPIOx[n] for low-level or high-to-low interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable GPIOx[n] for low-level or high-to-low interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN15</name>
              <description>Port [A/B] Interrupt Enable by Input Falling Edge or Input Level Low\nIF_EN[n] is used to enable the falling/low interrupt for each of the corresponding GPIO pins. It also enables the pin wakeup function.\nIf the interrupt is configured in level trigger mode, a level "low" will generate an interrupt.\nIf the interrupt is configured in edge trigger mode, a state change from "high-to-low" will generate an interrupt.\nGPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.\n</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable GPIOx[n] for low-level or high-to-low interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable GPIOx[n] for low-level or high-to-low interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN0</name>
              <description>Port [A/B] Interrupt Enable by Input Rising Edge or Input Level High\nIR_EN[n] is used to enable the rising/high interrupt for each of the corresponding GPIO pins. It also enables the pin wakeup function.\nIf the interrupt is configured in level trigger mode, a level "high" will generate an interrupt.\nIf the interrupt is configured in edge trigger mode, a state change from "low-to-high" will generate an interrupt.\nGPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable GPIOx[n] for level-high or low-to-high interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable GPIOx[n] for level-high or low-to-high interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN1</name>
              <description>Port [A/B] Interrupt Enable by Input Rising Edge or Input Level High\nIR_EN[n] is used to enable the rising/high interrupt for each of the corresponding GPIO pins. It also enables the pin wakeup function.\nIf the interrupt is configured in level trigger mode, a level "high" will generate an interrupt.\nIf the interrupt is configured in edge trigger mode, a state change from "low-to-high" will generate an interrupt.\nGPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.\n</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable GPIOx[n] for level-high or low-to-high interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable GPIOx[n] for level-high or low-to-high interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN2</name>
              <description>Port [A/B] Interrupt Enable by Input Rising Edge or Input Level High\nIR_EN[n] is used to enable the rising/high interrupt for each of the corresponding GPIO pins. It also enables the pin wakeup function.\nIf the interrupt is configured in level trigger mode, a level "high" will generate an interrupt.\nIf the interrupt is configured in edge trigger mode, a state change from "low-to-high" will generate an interrupt.\nGPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.\n</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable GPIOx[n] for level-high or low-to-high interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable GPIOx[n] for level-high or low-to-high interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN3</name>
              <description>Port [A/B] Interrupt Enable by Input Rising Edge or Input Level High\nIR_EN[n] is used to enable the rising/high interrupt for each of the corresponding GPIO pins. It also enables the pin wakeup function.\nIf the interrupt is configured in level trigger mode, a level "high" will generate an interrupt.\nIf the interrupt is configured in edge trigger mode, a state change from "low-to-high" will generate an interrupt.\nGPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.\n</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable GPIOx[n] for level-high or low-to-high interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable GPIOx[n] for level-high or low-to-high interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN4</name>
              <description>Port [A/B] Interrupt Enable by Input Rising Edge or Input Level High\nIR_EN[n] is used to enable the rising/high interrupt for each of the corresponding GPIO pins. It also enables the pin wakeup function.\nIf the interrupt is configured in level trigger mode, a level "high" will generate an interrupt.\nIf the interrupt is configured in edge trigger mode, a state change from "low-to-high" will generate an interrupt.\nGPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.\n</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable GPIOx[n] for level-high or low-to-high interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable GPIOx[n] for level-high or low-to-high interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN5</name>
              <description>Port [A/B] Interrupt Enable by Input Rising Edge or Input Level High\nIR_EN[n] is used to enable the rising/high interrupt for each of the corresponding GPIO pins. It also enables the pin wakeup function.\nIf the interrupt is configured in level trigger mode, a level "high" will generate an interrupt.\nIf the interrupt is configured in edge trigger mode, a state change from "low-to-high" will generate an interrupt.\nGPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.\n</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable GPIOx[n] for level-high or low-to-high interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable GPIOx[n] for level-high or low-to-high interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN6</name>
              <description>Port [A/B] Interrupt Enable by Input Rising Edge or Input Level High\nIR_EN[n] is used to enable the rising/high interrupt for each of the corresponding GPIO pins. It also enables the pin wakeup function.\nIf the interrupt is configured in level trigger mode, a level "high" will generate an interrupt.\nIf the interrupt is configured in edge trigger mode, a state change from "low-to-high" will generate an interrupt.\nGPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.\n</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable GPIOx[n] for level-high or low-to-high interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable GPIOx[n] for level-high or low-to-high interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN7</name>
              <description>Port [A/B] Interrupt Enable by Input Rising Edge or Input Level High\nIR_EN[n] is used to enable the rising/high interrupt for each of the corresponding GPIO pins. It also enables the pin wakeup function.\nIf the interrupt is configured in level trigger mode, a level "high" will generate an interrupt.\nIf the interrupt is configured in edge trigger mode, a state change from "low-to-high" will generate an interrupt.\nGPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.\n</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable GPIOx[n] for level-high or low-to-high interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable GPIOx[n] for level-high or low-to-high interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN8</name>
              <description>Port [A/B] Interrupt Enable by Input Rising Edge or Input Level High\nIR_EN[n] is used to enable the rising/high interrupt for each of the corresponding GPIO pins. It also enables the pin wakeup function.\nIf the interrupt is configured in level trigger mode, a level "high" will generate an interrupt.\nIf the interrupt is configured in edge trigger mode, a state change from "low-to-high" will generate an interrupt.\nGPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.\n</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable GPIOx[n] for level-high or low-to-high interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable GPIOx[n] for level-high or low-to-high interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN9</name>
              <description>Port [A/B] Interrupt Enable by Input Rising Edge or Input Level High\nIR_EN[n] is used to enable the rising/high interrupt for each of the corresponding GPIO pins. It also enables the pin wakeup function.\nIf the interrupt is configured in level trigger mode, a level "high" will generate an interrupt.\nIf the interrupt is configured in edge trigger mode, a state change from "low-to-high" will generate an interrupt.\nGPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.\n</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable GPIOx[n] for level-high or low-to-high interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable GPIOx[n] for level-high or low-to-high interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN10</name>
              <description>Port [A/B] Interrupt Enable by Input Rising Edge or Input Level High\nIR_EN[n] is used to enable the rising/high interrupt for each of the corresponding GPIO pins. It also enables the pin wakeup function.\nIf the interrupt is configured in level trigger mode, a level "high" will generate an interrupt.\nIf the interrupt is configured in edge trigger mode, a state change from "low-to-high" will generate an interrupt.\nGPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.\n</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable GPIOx[n] for level-high or low-to-high interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable GPIOx[n] for level-high or low-to-high interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN11</name>
              <description>Port [A/B] Interrupt Enable by Input Rising Edge or Input Level High\nIR_EN[n] is used to enable the rising/high interrupt for each of the corresponding GPIO pins. It also enables the pin wakeup function.\nIf the interrupt is configured in level trigger mode, a level "high" will generate an interrupt.\nIf the interrupt is configured in edge trigger mode, a state change from "low-to-high" will generate an interrupt.\nGPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.\n</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable GPIOx[n] for level-high or low-to-high interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable GPIOx[n] for level-high or low-to-high interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN12</name>
              <description>Port [A/B] Interrupt Enable by Input Rising Edge or Input Level High\nIR_EN[n] is used to enable the rising/high interrupt for each of the corresponding GPIO pins. It also enables the pin wakeup function.\nIf the interrupt is configured in level trigger mode, a level "high" will generate an interrupt.\nIf the interrupt is configured in edge trigger mode, a state change from "low-to-high" will generate an interrupt.\nGPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.\n</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable GPIOx[n] for level-high or low-to-high interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable GPIOx[n] for level-high or low-to-high interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN13</name>
              <description>Port [A/B] Interrupt Enable by Input Rising Edge or Input Level High\nIR_EN[n] is used to enable the rising/high interrupt for each of the corresponding GPIO pins. It also enables the pin wakeup function.\nIf the interrupt is configured in level trigger mode, a level "high" will generate an interrupt.\nIf the interrupt is configured in edge trigger mode, a state change from "low-to-high" will generate an interrupt.\nGPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.\n</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable GPIOx[n] for level-high or low-to-high interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable GPIOx[n] for level-high or low-to-high interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN14</name>
              <description>Port [A/B] Interrupt Enable by Input Rising Edge or Input Level High\nIR_EN[n] is used to enable the rising/high interrupt for each of the corresponding GPIO pins. It also enables the pin wakeup function.\nIf the interrupt is configured in level trigger mode, a level "high" will generate an interrupt.\nIf the interrupt is configured in edge trigger mode, a state change from "low-to-high" will generate an interrupt.\nGPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.\n</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable GPIOx[n] for level-high or low-to-high interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable GPIOx[n] for level-high or low-to-high interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN15</name>
              <description>Port [A/B] Interrupt Enable by Input Rising Edge or Input Level High\nIR_EN[n] is used to enable the rising/high interrupt for each of the corresponding GPIO pins. It also enables the pin wakeup function.\nIf the interrupt is configured in level trigger mode, a level "high" will generate an interrupt.\nIf the interrupt is configured in edge trigger mode, a state change from "low-to-high" will generate an interrupt.\nGPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.\n</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable GPIOx[n] for level-high or low-to-high interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable GPIOx[n] for level-high or low-to-high interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPIOA_ISRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPIOA_ISRC</displayName>
          <description>GPIO Port A Interrupt Trigger Source Indicator</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ISRC0</name>
              <description>Port [A/B] Interrupt Trigger Source Indicator\nRead :\n1 = Indicates GPIOx[n] generated an interrupt\n0 = No interrupt from GPIOx[n]\nWrite :\n1 = Clear the corresponding pending interrupt.\n0 = No action</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC1</name>
              <description>Port [A/B] Interrupt Trigger Source Indicator\nRead :\n1 = Indicates GPIOx[n] generated an interrupt\n0 = No interrupt from GPIOx[n]\nWrite :\n1 = Clear the corresponding pending interrupt.\n0 = No action</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC2</name>
              <description>Port [A/B] Interrupt Trigger Source Indicator\nRead :\n1 = Indicates GPIOx[n] generated an interrupt\n0 = No interrupt from GPIOx[n]\nWrite :\n1 = Clear the corresponding pending interrupt.\n0 = No action</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC3</name>
              <description>Port [A/B] Interrupt Trigger Source Indicator\nRead :\n1 = Indicates GPIOx[n] generated an interrupt\n0 = No interrupt from GPIOx[n]\nWrite :\n1 = Clear the corresponding pending interrupt.\n0 = No action</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC4</name>
              <description>Port [A/B] Interrupt Trigger Source Indicator\nRead :\n1 = Indicates GPIOx[n] generated an interrupt\n0 = No interrupt from GPIOx[n]\nWrite :\n1 = Clear the corresponding pending interrupt.\n0 = No action</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC5</name>
              <description>Port [A/B] Interrupt Trigger Source Indicator\nRead :\n1 = Indicates GPIOx[n] generated an interrupt\n0 = No interrupt from GPIOx[n]\nWrite :\n1 = Clear the corresponding pending interrupt.\n0 = No action</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC6</name>
              <description>Port [A/B] Interrupt Trigger Source Indicator\nRead :\n1 = Indicates GPIOx[n] generated an interrupt\n0 = No interrupt from GPIOx[n]\nWrite :\n1 = Clear the corresponding pending interrupt.\n0 = No action</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC7</name>
              <description>Port [A/B] Interrupt Trigger Source Indicator\nRead :\n1 = Indicates GPIOx[n] generated an interrupt\n0 = No interrupt from GPIOx[n]\nWrite :\n1 = Clear the corresponding pending interrupt.\n0 = No action</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC8</name>
              <description>Port [A/B] Interrupt Trigger Source Indicator\nRead :\n1 = Indicates GPIOx[n] generated an interrupt\n0 = No interrupt from GPIOx[n]\nWrite :\n1 = Clear the corresponding pending interrupt.\n0 = No action</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC9</name>
              <description>Port [A/B] Interrupt Trigger Source Indicator\nRead :\n1 = Indicates GPIOx[n] generated an interrupt\n0 = No interrupt from GPIOx[n]\nWrite :\n1 = Clear the corresponding pending interrupt.\n0 = No action</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC10</name>
              <description>Port [A/B] Interrupt Trigger Source Indicator\nRead :\n1 = Indicates GPIOx[n] generated an interrupt\n0 = No interrupt from GPIOx[n]\nWrite :\n1 = Clear the corresponding pending interrupt.\n0 = No action</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC11</name>
              <description>Port [A/B] Interrupt Trigger Source Indicator\nRead :\n1 = Indicates GPIOx[n] generated an interrupt\n0 = No interrupt from GPIOx[n]\nWrite :\n1 = Clear the corresponding pending interrupt.\n0 = No action</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC12</name>
              <description>Port [A/B] Interrupt Trigger Source Indicator\nRead :\n1 = Indicates GPIOx[n] generated an interrupt\n0 = No interrupt from GPIOx[n]\nWrite :\n1 = Clear the corresponding pending interrupt.\n0 = No action</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC13</name>
              <description>Port [A/B] Interrupt Trigger Source Indicator\nRead :\n1 = Indicates GPIOx[n] generated an interrupt\n0 = No interrupt from GPIOx[n]\nWrite :\n1 = Clear the corresponding pending interrupt.\n0 = No action</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC14</name>
              <description>Port [A/B] Interrupt Trigger Source Indicator\nRead :\n1 = Indicates GPIOx[n] generated an interrupt\n0 = No interrupt from GPIOx[n]\nWrite :\n1 = Clear the corresponding pending interrupt.\n0 = No action</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC15</name>
              <description>Port [A/B] Interrupt Trigger Source Indicator\nRead :\n1 = Indicates GPIOx[n] generated an interrupt\n0 = No interrupt from GPIOx[n]\nWrite :\n1 = Clear the corresponding pending interrupt.\n0 = No action</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="GPIOA_PMD">
          <name>GPIOB_PMD</name>
          <addressOffset>0x40</addressOffset>
       </register>
       <register derivedFrom="GPIOA_INDIS">
          <name>GPIOB_INDIS</name>
          <addressOffset>0x44</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DOUT">
          <name>GPIOB_DOUT</name>
          <addressOffset>0x48</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DMASK">
          <name>GPIOB_DMASK</name>
          <addressOffset>0x4C</addressOffset>
       </register>
       <register derivedFrom="GPIOA_PIN">
          <name>GPIOB_PIN</name>
          <addressOffset>0x50</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DBEN">
          <name>GPIOB_DBEN</name>
          <addressOffset>0x54</addressOffset>
       </register>
       <register derivedFrom="GPIOA_IMD">
          <name>GPIOB_IMD</name>
          <addressOffset>0x58</addressOffset>
       </register>
       <register derivedFrom="GPIOA_IEN">
          <name>GPIOB_IEN</name>
          <addressOffset>0x5C</addressOffset>
       </register>
       <register derivedFrom="GPIOA_ISRC">
          <name>GPIOB_ISRC</name>
          <addressOffset>0x60</addressOffset>
       </register>
       <register>
          <name>DBNCECON</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>DBNCECON</displayName>
          <description>Interrupt De-bounce Control</description>
          <addressOffset>0x180</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000020</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DBCLKSEL</name>
              <description>De-bounce Sampling Cycle Selection. \nFor edge level interrupt GPIO state is sampled every 2^(DBCLKSEL) de-bounce clocks. For example if DBCLKSRC = 6, then interrupt is sampled every 2^6 = 64 de-bounce clocks. If DBCLKSRC is 16KHz oscillator this would be a 64ms debounce.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DBCLKSRC</name>
              <description>De-bounce Counter Clock Source Select\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>De-bounce counter clock source is HCLK</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>De-bounce counter clock source is the internal 16 kHz clock</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ICLK_ON</name>
              <description>Interrupt Clock On Mode\nSet this bit "0" will gate the clock to the interrupt generation circuit if the GPIOx[n] interrupt is disabled.\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>disable the clock if the GPIOx[n] interrupt is disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt generation clock always active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>BOD</name>
      <description>BOD Register Map</description>
      <groupName>BOD</groupName>
      <baseAddress>0x40084000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x14</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>BOD_SEL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BOD_SEL</displayName>
          <description>Brown Out Detector Select Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BOD_LVL</name>
              <description>BOD Voltage Level\n111b =	4.6V\n110b =	3.0V\n101b =	2.8V\n100b =	2.625V\n011b =	2.5V\n010b =	2.4V\n001b =	2.2V\n000b =	2.1V</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BOD_HYS</name>
              <description>BOD Hysteresis\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Hysteresis Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable Hysteresis of BOD detection</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>BOD_EN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BOD_EN</displayName>
          <description>Brown Out Detector Enable Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFF00</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>BOD Enable\n1xb =	Enable continuous BOD detection.\n01b =	Enable time multiplexed BOD detection. See DET_TIMER register.\n00b =	Disable BOD Detection.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IE</name>
              <description>BOD Interrupt Enable\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable BOD Interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable BOD Interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INT</name>
              <description>Current Status Of Interrupt\nLatched whenever a BOD event occurs and IE = 1. Write '1' to clear.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BOD_OUT</name>
              <description>Output of BOD Detection Block\nThis signal can be monitored to determine the current state of the BOD comparator. Read '1' implies that VCC is less than BOD_LVL.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TALARM_SEL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TALARM_SEL</displayName>
          <description>Temperature Alarm Select Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LVL</name>
              <description>Temperature Alarm Sense Level\n0000:105C\n0001:115C\n0010:125C\n0100:135C\n1000:145C</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TALARM_EN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TALARM_EN</displayName>
          <description>Temperature Alarm Enable Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFF00</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>TALARM Enable\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable TALARM Detection</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable TALARM Detection</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TALARM</name>
              <description>Output of TALARM Block\nCan be polled to determine whether TALARM active (be 1).</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IE</name>
              <description>TALARM Interrupt Enable\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable TALARM Interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable TALARM Interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INT</name>
              <description>Current status of interrupt\nLatched whenever a Temperature Sense event occurs and IE = 1. Write '1' to clear.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>DET_TIMER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>DET_TIMER</displayName>
          <description>Brown Out Detector Timer Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x000303E3</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OFF_DUR</name>
              <description>Time BOD Detector Is Off\n (OFF_DUR+1)*100us . Minimum value is 7. (default is 99.6ms)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ON_DUR</name>
              <description>Time BOD Detector Is Active\n(ON_DUR+1) * 100us. Minimum value is 1. (default is 400us)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>I2C</name>
      <description>I2C Register Map</description>
      <groupName>I2C</groupName>
      <baseAddress>0x40020000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x34</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>CON</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CON</displayName>
          <description>I2C Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AA</name>
              <description>Assert Acknowledge Control Bit\n1. A slave is acknowledging the address sent from master, \n2. The receiver devices are acknowledging the data sent by transmitter. \nWhen AA = 0 prior to address or data received, a Not acknowledged (high level to SDA) will be returned during the acknowledge clock pulse on the SCL line.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SI</name>
              <description>I2C Interrupt Flag\nWhen a new SIO state is present in the I2C-&gt;STATUS register, the SI flag is set by hardware, and if bit EI (I2C-&gt;CON[7]) is set, the I2C interrupt is requested. SI must be cleared by software. Clear SI is by writing one to this bit.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STO</name>
              <description>I2C STOP Control Bit\nIn master mode, set STO to transmit a STOP condition to bus. I2C hardware will check the bus condition, when a STOP condition is detected this bit will be cleared by hardware automatically. In slave mode, setting STO resets I2C hardware to the defined "not addressed" slave mode. This means it is NO LONGER in the slave receiver mode able receive data from the master transmit device.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STA</name>
              <description>I2C START Control Bit\nSetting STA to logic 1 will enter master mode, the I2C hardware sends a START or repeat START condition to bus when the bus is free.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENSI</name>
              <description>I2C Controller Enable Bit\nSet to enable I2C serial function block.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EI</name>
              <description>Enable Interrupt\n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable interrupt CPU</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ADDR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ADDR0</displayName>
          <description>I2C Slave address Register0</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GC</name>
              <description>General Call Function\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable General Call Function</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable General Call Function</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADDR</name>
              <description>I2C Address Register\nThe content of this register is irrelevant when I2C is in master mode. In the slave mode, the seven most significant bits must be loaded with the MCU's own address. The I2C hardware will react if any of the addresses are matched.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>DATA</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>DATA</displayName>
          <description>I2C DATA Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>I2C Data Register\nDuring master or slave transmit mode, data to be transmitted is written to this register. During master or slave receive mode, data that has been received may be read from this register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>STATUS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>STATUS</displayName>
          <description>I2C Status Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>STATUS</name>
              <description>I2C Status Register\nThe status register of I2C:\nThe three least significant bits are always 0. The five most significant bits contain the status code. There are 26 possible status codes. When I2C-&gt;STATUS contains F8H, no serial interrupt is requested. All other I2C-&gt;STATUS values correspond to defined I2C states. When each of these states is entered, a status interrupt is requested (SI  = 1). A valid status code is present in I2C-&gt;STATUS one PCLK cycle after SI is set by hardware and is still present one PCLK cycle after SI has been reset by software. In addition, states 00H stands for a Bus Error. A Bus Error occurs when a START or STOP condition is present at an illegal position in the frame. Example of illegal position are during the serial transfer of an address byte, a data byte or an acknowledge bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CLK</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CLK</displayName>
          <description>I2C clock divided Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLK</name>
              <description>I2C Clock Divided Register\nThe I2C clock rate bits: Data Baud Rate of I2C = PCLK /(4x(I2C-&gt;CLK+1)).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TOC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TOC</displayName>
          <description>I2C Time out control Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TIF</name>
              <description>Time-Out Flag\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No time-out</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time-out flag is set by H/W. It can interrupt CPU. Write 1 to clear.</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DIV4</name>
              <description>Time-Out Counter Input Clock Divide By 4 \nWhen enabled, the time-out clock is PCLK/4.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ENTI</name>
              <description>Time-out Counter Control Bit\nWhen enabled, the 14 bit time-out counter will start counting when SI is clear. Setting flag SI to high will reset counter and re-start up counting after SI is cleared.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="ADDR0">
          <name>ADDR1</name>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="ADDR0">
          <name>ADDR2</name>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="ADDR0">
          <name>ADDR3</name>
          <addressOffset>0x20</addressOffset>
       </register>
       <register>
          <name>ADM0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ADM0</displayName>
          <description>I2C Slave address Mask Register0</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADMx1</name>
              <description>I2C Address Mask register\nI2C bus controllers support multiple-address recognition with four address mask registers. Bits in this field mask the ADDRx registers masking bits from the address comparison.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Mask disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Mask enable (the received corresponding address bit is don't care.)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADMx2</name>
              <description>I2C Address Mask register\nI2C bus controllers support multiple-address recognition with four address mask registers. Bits in this field mask the ADDRx registers masking bits from the address comparison.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Mask disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Mask enable (the received corresponding address bit is don't care.)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADMx3</name>
              <description>I2C Address Mask register\nI2C bus controllers support multiple-address recognition with four address mask registers. Bits in this field mask the ADDRx registers masking bits from the address comparison.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Mask disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Mask enable (the received corresponding address bit is don't care.)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADMx4</name>
              <description>I2C Address Mask register\nI2C bus controllers support multiple-address recognition with four address mask registers. Bits in this field mask the ADDRx registers masking bits from the address comparison.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Mask disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Mask enable (the received corresponding address bit is don't care.)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADMx5</name>
              <description>I2C Address Mask register\nI2C bus controllers support multiple-address recognition with four address mask registers. Bits in this field mask the ADDRx registers masking bits from the address comparison.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Mask disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Mask enable (the received corresponding address bit is don't care.)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADMx6</name>
              <description>I2C Address Mask register\nI2C bus controllers support multiple-address recognition with four address mask registers. Bits in this field mask the ADDRx registers masking bits from the address comparison.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Mask disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Mask enable (the received corresponding address bit is don't care.)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADMx7</name>
              <description>I2C Address Mask register\nI2C bus controllers support multiple-address recognition with four address mask registers. Bits in this field mask the ADDRx registers masking bits from the address comparison.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Mask disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Mask enable (the received corresponding address bit is don't care.)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="ADM0">
          <name>ADM1</name>
          <addressOffset>0x28</addressOffset>
       </register>
       <register derivedFrom="ADM0">
          <name>ADM2</name>
          <addressOffset>0x2C</addressOffset>
       </register>
       <register derivedFrom="ADM0">
          <name>ADM3</name>
          <addressOffset>0x30</addressOffset>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PWMA</name>
      <description>PWMA Register Map</description>
      <groupName>PWMA</groupName>
      <baseAddress>0x40040000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x24</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x40</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x50</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x58</offset>
        <size>0x10</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x78</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>PPR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PPR</displayName>
          <description>PWM Prescaler Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CP01</name>
              <description>Clock Pre-scaler\nClock input is divided by (CP01 + 1). \nIf CP01 = 0, then the pre-scaler output clock will be stopped.\nThis implies PWM counter 0 and 1 will also be stopped.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DZI01</name>
              <description>Dead Zone Interval Register For Pair Of PWM0 And PWM1\nThese 8 bits determine dead zone length.\nThe unit time of dead zone length is that from clock selector 0.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CSR</displayName>
          <description>PWM Clock Select Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CSR0</name>
              <description>Timer 0 Clock Source Selection\n (Table is as CSR1)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CSR1</name>
              <description>Timer 1 Clock Source Selection\nValue          :           Input clock divided by\n0              :                           2\n1              :                           4\n2              :                           8\n3              :                          16\n4              :                            1</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PCR</displayName>
          <description>PWM Control Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH0EN</name>
              <description>PWM-Timer 0 Enable/Disable Start Run\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Stop PWM-Timer 0 Running</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable PWM-Timer 0 Start/Run</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH0INV</name>
              <description>PWM-Timer 0 Output Inverter ON/OFF\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inverter OFF</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverter ON</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH0MOD</name>
              <description>PWM-Timer 0 Auto-reload/One-Shot Mode\nNote: A rising transition of this bit will cause CNR0 and CMR0 to be cleared.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One-Shot Mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-reload Mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DZEN01</name>
              <description>Dead-Zone 0 Generator Enable/Disable\nNote: When Dead-Zone Generator is enabled, the pair of PWM0 and PWM1 become a complementary pair.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH1EN</name>
              <description>PWM-Timer 1 Enable/Disable Start Run\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Stop PWM-Timer 1</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable PWM-Timer 1 Start/Run</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH1INV</name>
              <description>PWM-Timer 1 Output Inverter ON/OFF\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inverter OFF</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverter ON</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH1MOD</name>
              <description>PWM-Timer 1 Auto-reload/One-Shot Mode\nNote: A rising transition of this bit will cause CNR1 and CMR1 to be cleared.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One-Shot Mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-load Mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CNR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CNR0</displayName>
          <description>PWM Counter Register 0</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNR</name>
              <description>PWM Counter/Timer Reload Value\nCNR determines the PWM period.\nPWM frequency = PWM01_CLK/(prescale+1)*(clock divider)/(CNR+1); \nDuty ratio = (CMR+1)/(CNR+1).\nCMR &gt; = CNR: PWM output is always high.\nCMR &lt; CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.\nCMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit\n(Unit = one PWM clock cycle)\nNote: \nAny write to CNR will take effect in next PWM cycle.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CMR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CMR0</displayName>
          <description>PWM Comparator Register 0</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMR</name>
              <description>PWM Comparator Register\nCMR determines the PWM duty cycle.\nPWM frequency = PWM01_CLK/(prescale+1)*(clock divider)/(CNR+1); \nDuty Cycle = (CMR+1)/(CNR+1).\nCMR &gt; = CNR: PWM output is always high.\nCMR &lt; CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.\nCMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit\n(Unit = one PWM clock cycle)\nNote: Any write to CMR will take effect in next PWM cycle.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDR0</displayName>
          <description>PWM Data Register 0</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDR</name>
              <description>PWM Data Register\nReports the current value of the 16-bit down counter.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="CNR0">
          <name>CNR1</name>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="CMR0">
          <name>CMR1</name>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDR0">
          <name>PDR1</name>
          <addressOffset>0x20</addressOffset>
       </register>
       <register>
          <name>PIER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PIER</displayName>
          <description>PWM Interrupt Enable Register</description>
          <addressOffset>0x40</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PWMIE0</name>
              <description>PWM Timer 0 Interrupt Enable\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMIE1</name>
              <description>PWM Timer 1 Interrupt Enable\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PIFR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PIFR</displayName>
          <description>PWM Interrupt Flag Register</description>
          <addressOffset>0x44</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PWMIF0</name>
              <description>PWM Timer 0 Interrupt Flag\nFlag is set by hardware when PWM0 down counter reaches zero, software can clear this bit by writing '1' to it.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMIF1</name>
              <description>PWM Timer 1 Interrupt Flag\nFlag is set by hardware when PWM1 down counter reaches zero, software can clear this bit by writing '1' to it.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CCR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CCR0</displayName>
          <description>Capture Control Register 0</description>
          <addressOffset>0x50</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INV0</name>
              <description>Channel 0 Inverter ON/OFF\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inverter OFF</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverter ON. Reverse the input signal from GPIO before Capture timer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CRL_IE0</name>
              <description>Channel 0 Rising Latch Interrupt Enable ON/OFF\nWhen enabled, capture block generates an interrupt on rising edge of input.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable rising latch interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable rising latch interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CFL_IE0</name>
              <description>Channel 0 Falling Latch Interrupt Enable ON/OFF\nWhen enabled, capture block generates an interrupt on falling edge of input.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable falling latch interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable falling latch interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPCH0EN</name>
              <description>Capture Channel 0 transition Enable/Disable\nWhen enabled, Capture function latches the PMW-counter to CRLR (Rising latch) and CFLR (Falling latch) registers on input edge transition.\nWhen disabled, Capture function is inactive as is interrupt.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable capture function on channel 0</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable capture function on channel 0</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPIF0</name>
              <description>Capture0 Interrupt Indication Flag\nIf channel 0 rising latch interrupt is enabled (CRL_IE0 = 1), a rising transition at input channel 0 will result in CAPIF0 to high; Similarly, a falling transition will cause CAPIF0 to be set high if channel 0 falling latch interrupt is enabled (CFL_IE0 = 1). This flag is cleared by software writing a '1' to it.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CRLRI0</name>
              <description>CRLR0 Latched Indicator Bit\nWhen input channel 0 has a rising transition, CRLR0 was latched with the value of PWM down-counter and this bit is set by hardware, software can clear this bit by writing a zero to it.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CFLRI0</name>
              <description>CFLR0 Latched Indicator Bit\nWhen input channel 0 has a falling transition, CFLR0 was latched with the value of PWM down-counter and this bit is set by hardware, software can clear this bit by writing a zero to it.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INV1</name>
              <description>Channel 1 Inverter ON/OFF\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inverter OFF</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverter ON. Reverse the input signal from GPIO before Capture timer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CRL_IE1</name>
              <description>Channel 1 Rising Latch Interrupt Enable \nWhen enabled, capture block generates an interrupt on rising edge of input.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable rising edge latch interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable rising edge latch interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CFL_IE1</name>
              <description>Channel 1 Falling Latch Interrupt Enable \nWhen enabled, capture block generates an interrupt on falling edge of input.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable falling edge  latch interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable falling edge latch interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPCH1EN</name>
              <description>Capture Channel 1 Transition Enable/Disable\nWhen enabled, Capture function latches the PMW-counter to CRLR (Rising latch) and CFLR (Falling latch) registers on input edge transition.\nWhen disabled, Capture function is inactive as is interrupt.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable capture function on channel 1</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable capture function on channel 1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPIF1</name>
              <description>Capture1 Interrupt Indication Flag\nIf channel 1 rising latch interrupt is enabled (CRL_IE1 = 1), a rising transition at input channel 1 will result in CAPIF1 to high; Similarly, a falling transition will cause CAPIF1 to be set high if channel 1 falling latch interrupt is enabled (CFL_IE1 = 1). This flag is cleared by software writing a '1' to it.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CRLRI1</name>
              <description>CRLR1 Latched Indicator Bit\nWhen input channel 1 has a rising transition, CRLR1 was latched with the value of PWM down-counter and this bit is set by hardware, software can clear this bit by writing a zero to it.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CFLRI1</name>
              <description>CFLR1 Latched Indicator Bit\nWhen input channel 1 has a falling transition, CFLR1 was latched with the value of PWM down-counter and this bit is set by hardware, software can clear this bit by writing a zero to it.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CRLR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CRLR0</displayName>
          <description>Capture Rising Latch Register (Channel 0)</description>
          <addressOffset>0x58</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CRLR</name>
              <description>Capture Rising Latch Register\nIn Capture mode, this register is latched with the value of the PWM counter on a rising edge of the input signal.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CFLR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CFLR0</displayName>
          <description>Capture Falling Latch Register (Channel 0)</description>
          <addressOffset>0x5C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CFLR</name>
              <description>Capture Falling Latch Register\nIn Capture mode, this register is latched with the value of the PWM counter on a falling edge of the input signal.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="CRLR0">
          <name>CRLR1</name>
          <addressOffset>0x60</addressOffset>
       </register>
       <register derivedFrom="CFLR0">
          <name>CFLR1</name>
          <addressOffset>0x64</addressOffset>
       </register>
       <register>
          <name>CAPENR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAPENR</displayName>
          <description>Capture Input Enable Register</description>
          <addressOffset>0x78</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CAPENR</name>
              <description>Capture Input Enable Register\n0 : OFF (GPA[13:12] pin input disconnected from Capture block)\n1 : ON (GPA[13:12] pin, if in PWM alternative function, will be configured as an input and fed to capture function)\nCAPENR[1:0]\nBit 10\nBit x1  :  Capture channel 0 is from GPA [12] \nBit 1x  :  Capture channel 1 is from GPA [13]</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>POE</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>POE</displayName>
          <description>PWM Output Enable Register for PWM0~PWM1</description>
          <addressOffset>0x7C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PWM0</name>
              <description>PWM0 Output Enable Register\nNote: The corresponding GPIO pin also must be switched to PWM function (refer to GPA_ALT Table 57)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable PWM0 output to pin</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable PWM0 output to pin</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM1</name>
              <description>PWM1 Output Enable Register\nNote: The corresponding GPIO pin also must be switched to PWM function (refer to GPA_ALT Table 57)</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable PWM1 output to pin</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable PWM1 output to pin</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>RTC</name>
      <description>RTC Register Map</description>
      <groupName>RTC</groupName>
      <baseAddress>0x40008000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x34</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>INIR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>INIR</displayName>
          <description>RTC Initialization Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>Active</name>
              <description>RTC Active Status (Read only)\n0: RTC is in reset state\n1: RTC is in normal active state.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>INIR</name>
              <description>RTC Initialization\nAfter a power-on reset (POR) RTC block should be initialized by writing 0xA5EB1357 to INIR. This will force a hardware reset then release all logic and counters.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>AER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>AER</displayName>
          <description>RTC Access Enable Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AER</name>
              <description>RTC Register Access Enable Password (Write only)\n 0xA965 = Enable RTC access \n Others = Disable RTC access</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ENF</name>
              <description>RTC Register Access Enable Flag (Read only)\nThis bit will be set after AER[15:0] register is set to 0xA965, it will clear automatically in 512 RTC clock cycles or AER[15:0] ! = 0xA965. The effect of AER.ENF on access to each register is given Table 572.\nTable 572 AER.ENF Register Access Effect.\nRegister     :    ENF = 1  :    ENF = 0\nINIR        :          R/W     :     R/W\nFCR        :          R/W     :       -\nTLR         :         R/W      :      R\nCLR         :         R/W      :      R\nTSSR       :         R/W      :    R/W\nDWR        :         R/W      :      R\nTAR         :         R/W       :       -\nCAR         :         R/W      :       -\nLIR           :           R        :       R\nRIER        :          R/W     :      R/W\nRIIR         :          R/W     :       R/W\nTTR         :          R/W     :         -</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTC register read/write disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTC register read/write enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>FCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>FCR</displayName>
          <description>RTC Frequency Compensation Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000700</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FRACTION</name>
              <description>Fractional Part\nFormula = (fraction part of detected value) x 60\nRefer to 5.8.4.4 for the examples.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INTEGER</name>
              <description>Integer Part\nRegister should contain the value (INT(Factual) - 32761)\nEx: Integer part of detected value = 32772,\n      FCR.INTEGER = 32772-32761 = 11 (1011b)\nThe range between 32761 and 32776</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TLR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TLR</displayName>
          <description>Time Load Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>_1SEC</name>
              <description>1 Sec Time Digit (0~9)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_10SEC</name>
              <description>10 Sec Time Digit (0~5)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_1MIN</name>
              <description>1 Min Time Digit (0~9)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_10MIN</name>
              <description>10 Min Time Digit (0~5)</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_1HR</name>
              <description>1 Hour Time Digit (0~9)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_10HR</name>
              <description>10 Hour Time Digit (0~3)</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CLR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CLR</displayName>
          <description>Calendar Load Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00050101</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>_1DAY</name>
              <description>1-Day Calendar Digit (0~9)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_10DAY</name>
              <description>10-Day Calendar Digit (0~3)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_1MON</name>
              <description>1-Month Calendar Digit (0~9)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_10MON</name>
              <description>10-Month Calendar Digit (0~1)</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_1YEAR</name>
              <description>1-Year Calendar Digit (0~9)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_10YEAR</name>
              <description>10-Year Calendar Digit (0~9)</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TSSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TSSR</displayName>
          <description>Time Scale Selection Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HR24</name>
              <description>24-Hour / 12-Hour Mode Selection\nDetermines whether TLR and TAR are in 24-hour mode or 12-hour mode\n\nThe range of 24-hour time scale is between 0 and 23.\n12-hour time scale:\n01(AM01), 02(AM02), 03(AM03), 04(AM04), 05(AM05), 06(AM06)\n07(AM07), 08(AM08), 09(AM09), 10(AM10), 11(AM11), 12(AM12)\n21(PM01), 22(PM02), 23(PM03), 24(PM04), 25(PM05), 26(PM06)\n27(PM07), 28(PM08), 29(PM09), 30(PM10), 31(PM11), 32(PM12)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>select 12-hour time scale with AM and PM indication</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>select 24-hour time scale</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>DWR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>DWR</displayName>
          <description>Day of the Week Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000006</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DWR</name>
              <description>Day of the Week Register \n0 (Sunday),  1 (Monday),  2 (Tuesday),  3 (Wednesday)\n4 (Thursday),  5 (Friday),  6 (Saturday)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TAR</displayName>
          <description>Time Alarm Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>_1SEC</name>
              <description>1 Sec Time Digit of Alarm Setting (0~9)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_10SEC</name>
              <description>10 Sec Time Digit of Alarm Setting (0~5)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_1MIN</name>
              <description>1 Min Time Digit of Alarm Setting (0~9)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_10MIN</name>
              <description>10 Min Time Digit of Alarm Setting (0~5)</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_1HR</name>
              <description>1 Hour Time Digit of Alarm Setting (0~9)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_10HR</name>
              <description>10 Hour Time Digit of Alarm Setting (0~3)</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAR</displayName>
          <description>Calendar Alarm Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>_1DAY</name>
              <description>1-Day Calendar Digit of Alarm Setting (0~9)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_10DAY</name>
              <description>10-Day Calendar Digit of Alarm Setting (0~3)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_1MON</name>
              <description>1-Month Calendar Digit of Alarm Setting (0~9)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_10MON</name>
              <description>10-Month Calendar Digit of Alarm Setting (0~1)</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_1YEAR</name>
              <description>1-Year Calendar Digit of Alarm Setting (0~9)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_10YEAR</name>
              <description>10-Year Calendar Digit of Alarm Setting (0~9)</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>LIR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>LIR</displayName>
          <description>Leap year Indicator Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LIR</name>
              <description>Leap Year Indication Register (read only)\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Current year is not a leap year</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Current year is leap year</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>RIER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>RIER</displayName>
          <description>RTC Interrupt Enable Register</description>
          <addressOffset>0x28</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AIER</name>
              <description>Alarm Interrupt Enable\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTC Alarm Interrupt is disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTC Alarm Interrupt is enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TIER</name>
              <description>Time-Tick Interrupt and Wakeup-by-Tick Enable\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTC Time-Tick Interrupt is disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTC Time-Tick Interrupt is enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>RIIR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>RIIR</displayName>
          <description>RTC Interrupt Indicator Register</description>
          <addressOffset>0x2C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AI</name>
              <description>RTC Alarm Interrupt Flag\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Indicates no Alarm Interrupt condition</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Indicates RTC Alarm Interrupt generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TI</name>
              <description>RTC Time-Tick Interrupt Flag\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Indicates no Time-Tick Interrupt condition</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Indicates RTC Time-Tick Interrupt generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TTR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TTR</displayName>
          <description>RTC Time Tick Register</description>
          <addressOffset>0x30</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TTR</name>
              <description>Time Tick Register\nThe RTC time tick period for Periodic Time-Tick Interrupt request.\nTime Tick (second) : 1 / (2^TTR)\nNote: This register can be read back after the RTC is active.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TWKE</name>
              <description>RTC Timer Wakeup CPU Function Enable Bit\nIf TWKE is set before CPU is in power-down mode, when a RTC Time-Tick or Alarm Match occurs, CPU will wake up.\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable Wakeup CPU function</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable the Wakeup function</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SPI0</name>
      <description>SPI0 Register Map</description>
      <groupName>SPI0</groupName>
      <baseAddress>0x40030000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0xC</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x10</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x20</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x34</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>CNTRL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CNTRL</displayName>
          <description>Control and Status Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000004</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GO_BUSY</name>
              <description>Go and Busy Status\nNOTE: All registers should be set before writing 1 to this GO_BUSY bit. When a transfer is in progress, writing to any register of the SPI master/slave core has no effect.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Writing 0 to this bit has no effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Writing 1 to this bit starts the transfer. This bit remains set during the transfer and is automatically cleared after transfer finished</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_NEG</name>
              <description>Receive At Negative Edge\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The received data input signal is latched at the rising edge of SCLK</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The received data input signal is latched at the falling edge of SCLK</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_NEG</name>
              <description>Transmit At Negative Edge\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The transmitted data output signal is changed at the rising edge of SCLK</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The transmitted data output signal is changed at the falling edge of SCLK</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_BIT_LEN</name>
              <description>Transmit Bit Length\nThis field specifies how many bits are transmitted in one transmit/receive. Up to 32 bits can be transmitted.\nTX_BIT_LEN = 0x01 --- 1 bit\nTX_BIT_LEN = 0x02 --- 2 bits\n----\nTX_BIT_LEN = 0x1f  --- 31 bits\nTX_BIT_LEN = 0x00 --- 32 bits</description>
              <bitOffset>3</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_NUM</name>
              <description>Transmit/Receive Word Numbers\nThis field specifies how many transmit/receive word numbers should be executed in one transfer.\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Only one transmit/receive word will be executed in one transfer</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Two successive transmit/receive word will be executed in one transfer</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Reserved</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LSB</name>
              <description>LSB First\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The MSB is transmitted/received first (which bit in SPI_TX[0]/[1] and SPI_RX[0]/[1] register that is depends on the TX_BIT_LEN field)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The LSB is sent first on the line (bit 0 of SPI_TX[0]/[1]), and the first bit received from the line will be put in the LSB position in the Rx register (bit 0 of SPI_RX[0]/[1])</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLKP</name>
              <description>Clock Polarity\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SCLK idle low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SCLK idle high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLEEP</name>
              <description>Suspend Interval (Master Only)\nThese four bits provide configurable suspend interval between two successive transmit/receive transactions in a transfer. The suspend interval is from the last falling clock edge of the current transaction to the first rising clock edge of the successive transaction if CLKP = 0. If CLKP = 1, the interval is from the rising clock edge to the falling clock edge. The default value is 0x0. When TX_NUM = 00b, setting this field has no effect on transfer except as determined by REORDER[0] setting. The suspend interval is determined  according to the following equation:\n(SLEEP[3:0] + 2) * period of SCLK</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IF</name>
              <description>Interrupt Flag\nNOTE: This bit is cleared by writing 1 to itself.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Indicates the transfer is not  finished yet</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Indicates that the transfer is complete. Interrupt is generated to CPU if enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IE</name>
              <description>Interrupt Enable\n</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable SPI Interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable SPI Interrupt to CPU</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLAVE</name>
              <description>Master Slave Mode Control\n</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Master mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Slave mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BYTE_SLEEP</name>
              <description>Insert Sleep Interval Between Bytes\nThis function is only valid for 32bit transfers (TX_BIT_LEN = 0). If set then a pause of (SLEEP+2) SCLK cycles is inserted between each byte transmitted.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BYTE_ENDIAN</name>
              <description>Byte Endian Reorder Function\nThis function changes the order of bytes sent/received to be least significant physical byte first.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FIFO</name>
              <description>FIFO Mode\n</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No FIFO present on transmit and receive buffer</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable FIFO on transmit and receive buffer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TWOB</name>
              <description>Two Bits Transfer Mode \nNote that when enabled in master mode, MOSI0 data comes from TX[0] and MOSI1 data from TX[1]. Likewise RX[0] receives bit stream from MISO0  and RX[1] from MISO1. Note that when enabled, the setting of TX_NUM must be programmed as 0x00</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable two-bit transfer mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable two-bit transfer mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>VARCLK_EN</name>
              <description>Variable Clock Enable (Master Only)\nNote that when enabled, the setting of TX_BIT_LEN must be programmed as 0x10 (16 bits mode)</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The serial clock output frequency is fixed and determined only by the value of DIVIDER</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SCLK output frequency is variable. The output frequency is determined by the value of VARCLK, DIVIDER, and DIVIDER2</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_EMPTY</name>
              <description>Receive FIFO Empty Status\n</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The receive data FIFO is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The receive data FIFO is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_FULL</name>
              <description>Receive  FIFO Full Status\n</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The receive data FIFO is not full</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The receive data FIFO is full</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_EMPTY</name>
              <description>Transmit FIFO Empty Status\n</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The transmit data FIFO is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The transmit data FIFO is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_FULL</name>
              <description>Transmit  FIFO Full Status\n</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The transmit data FIFO is not full</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The transmit data FIFO is full</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_ASS_BURST</name>
              <description>Enable DMA Automatic SS function\nWhen enabled, interface will automatically generate a SS signal for an entire PDMA access transaction.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>DIVIDER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>DIVIDER</displayName>
          <description>Clock Divider Register (Master Only)</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DIVIDER</name>
              <description>Clock Divider Register (master only)\nThe value in this field is the frequency division of the system clock, PCLK, to generate the serial clock on the output SCLK. The desired frequency is obtained according to the following equation:\nFsclk = Fpclk / ((DIVIDER+1) * 2)\nIn slave mode, the period of SPI clock driven by a master shall satisfy\nFsclk &lt; = (Fpclk / 5)\nIn other words, the maximum frequency of SCLK clock is one fifth of the SPI peripheral clock.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIVIDER2</name>
              <description>Clock Divider 2 Register (master only)\nThe value in this field is the 2nd frequency divider of the system clock, PCLK, to generate the serial clock on the output SCLK. The desired frequency is obtained according to the following equation:\nFsclk = Fpclk / ((DIVIDER2+1) * 2)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SSR</displayName>
          <description>Slave Select Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SSR</name>
              <description>Slave Select Register (Master only)\nIf ASS bit is cleared, writing 1 to any bit location of this field sets the proper SPISSx0/1 line to an active state and writing 0 sets the line back to inactive state.\nIf ASS bit is set, writing 1 to any bit location of this field will select appropriate SPISSx0/1 line to be automatically driven to active state for the duration of the transmit/receive, and will be driven to inactive state for the rest of the time. (The active level of SPISSx0/1 is specified in SS_LVL).\nNote: SPISSx0 is always defined as device/slave select input signal in slave mode.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SS_LVL</name>
              <description>Slave Select Active Level \nIt defines the active level of device/slave select signal (SPISSx0/1).\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The slave select signal SPISSx0/1 is active at low-level/falling-edge</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The slave select signal SPISSx0/1 is active at high-level/rising-edge</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ASS</name>
              <description>Automatic Slave Select (Master only)\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>If this bit is cleared, slave select signals are asserted and de-asserted by setting and clearing related bits in SSR[1:0] register</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>If this bit is set, SPISSx0/1 signals are generated automatically. It means that device/slave select signal, which is set in SSR[1:0] register is asserted by the SPI controller when transmit/receive is started by setting GO_BUSY, and is de-asserted after each transmit/receive is finished</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SS_LTRIG</name>
              <description>Slave Select Level Trigger (Slave only)\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The input slave select signal is edge-trigger. This is the default value</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The slave select signal will be level-trigger. It depends on SS_LVL to decide the signal is active low or active high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LTRIG_FLAG</name>
              <description>Level Trigger Flag\nWhen the SS_LTRIG bit is set in slave mode, this bit can be read to indicate the received bit number is met the requirement or not.\nNote: This bit is READ only</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One of the received number and the received bit length doesn't meet the requirement in one transfer</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The received number and received bits met the requirement which defines in Tx_NUM and Tx_BIT_LEN among one transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>RX0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>RX0</displayName>
          <description>Data Receive Register 0</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX</name>
              <description>Data Receive Register\nThe Data Receive Registers hold the value of received data of the last executed transfer. Valid bits depend on the transmit bit length field in the SPI_CNTRL register. For example, if Tx_BIT_LEN is set to 0x08 and Tx_NUM is set to 0x0, bit Rx0[7:0] holds the received data.\nNOTE: The Data Receive Registers are read only registers.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="RX0">
          <name>RX1</name>
          <addressOffset>0x14</addressOffset>
       </register>
       <register>
          <name>TX0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TX0</displayName>
          <description>Data Transmit Register 0</description>
          <addressOffset>0x20</addressOffset>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>Tx</name>
              <description>Data Transmit Register\nThe Data Transmit Registers hold the data to be transmitted in the next transfer. Valid bits depend on the transmit bit length field in the CNTRL register. For example, if Tx_BIT_LEN is set to 0x08 and the Tx_NUM is set to 0x0, the bit Tx0[7:0] will be transmitted in next transfer. If Tx_BIT_LEN is set to 0x00 and Tx_NUM is set to 0x1, the core will perform two 32-bit transmit/receive successive using the same setting (the order is Tx0[31:0], Tx1[31:0]).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="TX0">
          <name>TX1</name>
          <addressOffset>0x24</addressOffset>
       </register>
       <register>
          <name>VARCLK</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>VARCLK</displayName>
          <description>Variable Clock Pattern Register</description>
          <addressOffset>0x34</addressOffset>
          <access>read-write</access>
          <resetValue>0x007FFF87</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VARCLK</name>
              <description>Variable Clock Pattern\nThe value in this field is the frequency pattern of the SPI clock. If the bit field of VARCLK is '0', the output frequency of SCLK is given by the value of DIVIDER. If the bit field of VARCLK is '1', the output frequency of SCLK is given by the value of DIVIDER2. Refer to register DIVIDER.\nRefer to Variable Serial Clock Frequency paragraph for detailed description.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>DMA</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>DMA</displayName>
          <description>SPI DMA Control Register</description>
          <addressOffset>0x38</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>Tx_DMA_GO</name>
              <description>Transmit DMA Start\nSet this bit to 1 will start the transmit DMA process. SPI module will issue request to DMA module automatically. \nIf using DMA mode to transfer data, remember not to set GO_BUSY bit of SPI_CNTRL register. The DMA controller inside SPI module will set it automatically whenever necessary.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>Rx_DMA_GO</name>
              <description>Receive DMA Start\nSet this bit to 1 will start the receive DMA process. SPI module will issue request to DMA module automatically.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>TMR0</name>
      <description>TMR Register Map</description>
      <groupName>TMR</groupName>
      <baseAddress>0x40010000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x10</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>TCSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TCSR</displayName>
          <description>Timer Control and Status Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000005</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRESCALE</name>
              <description>Pre-scale Counter\nClock input is divided by PRESCALE+1 before it is fed to the counter. If PRESCALE  = 0, then there is no scaling.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TDR_EN</name>
              <description>Data Latch Enable\nWhen TDR_EN is set, TDR (Timer Data Register) will be updated continuously with the 24-bit up-counter value as the timer is counting. \n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer Data Register update disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer Data Register update enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CACT</name>
              <description>Timer Active Status Bit (Read only)\nThis bit indicates the counter status of timer.\n</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer is not active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer is active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>CRST</name>
              <description>Counter Reset Bit\nSet this bit will reset the timer counter, prescale and also force CEN to 0.\n</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset Timer's prescale counter, internal 24-bit up-counter and CEN bit</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>Timer Operating Mode\n</description>
              <bitOffset>27</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The timer is operating in the one-shot mode. The associated interrupt signal is generated once (if IE is enabled) and CEN is automatically cleared by hardware</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The timer is operating in the periodic mode. The associated interrupt signal is generated periodically (if IE is enabled)</description>
                    <value>1</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Reserved</description>
                    <value>2</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>The timer is operating in continuous counting mode. The associated interrupt signal is generated when TDR = TCMPR (if IE is enabled); however, the 24-bit up-counter counts continuously without reset</description>
                    <value>3</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IE</name>
              <description>Interrupt Enable Bit\nIf timer interrupt is enabled, the timer asserts its interrupt signal when the count is equal to TCMPR.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable TIMER Interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable TIMER Interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CEN</name>
              <description>Counter Enable Bit\nNote1: Setting CEN = 1 enables 24-bit counter. It continues count from last value.\nNote2: This bit is auto-cleared by hardware in one-shot mode (MODE = 00b) when the timer interrupt is generated (IE = 1b).</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Stops/Suspends counting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Starts counting</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TCMPR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TCMPR</displayName>
          <description>Timer Compare Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TCMP</name>
              <description>Timer Comparison Value\nTCMP is a 24-bit comparison register. When the 24-bit up-counter is enabled and its value is equal to TCMP value, a Timer Interrupt is requested if the timer interrupt is enabled with TCSR.IE = 1. The TCMP value defines the timer cycle time.\nTime out period = (Period of timer clock input) * (8-bit PRESCALE + 1) * (24-bit TCMP)\nNOTE1: Never set TCMP to 0x000 or 0x001. Timer will not function correctly.\nNOTE2: Regardless of CEN state, whenever a new value is written to this register, TIMER will restart counting using this new value and abort previous count.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>25</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TISR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TISR</displayName>
          <description>Timer Interrupt Status Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TIF</name>
              <description>Timer Interrupt Flag\nThis bit indicates the interrupt status of Timer.\nTIF bit is set by hardware when the 24-bit counter matches the timer comparison value (TCMP). It is cleared by writing 1.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TDR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TDR</displayName>
          <description>Timer Data Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TDR</name>
              <description>Timer Data Register\nWhen TCSR.TDR_EN is set to 1, the internal 24-bit timer up-counter value will be latched into TDR. User can read this register for the up-counter value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>TMR1</name>
      <description>TMR Register Map</description>
      <groupName>TMR</groupName>
      <baseAddress>0x40010020</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x10</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>TCSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TCSR</displayName>
          <description>Timer Control and Status Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000005</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRESCALE</name>
              <description>Pre-scale Counter\nClock input is divided by PRESCALE+1 before it is fed to the counter. If PRESCALE  = 0, then there is no scaling.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TDR_EN</name>
              <description>Data Latch Enable\nWhen TDR_EN is set, TDR (Timer Data Register) will be updated continuously with the 24-bit up-counter value as the timer is counting. \n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer Data Register update disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer Data Register update enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CACT</name>
              <description>Timer Active Status Bit (Read only)\nThis bit indicates the counter status of timer.\n</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer is not active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer is active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>CRST</name>
              <description>Counter Reset Bit\nSet this bit will reset the timer counter, prescale and also force CEN to 0.\n</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset Timer's prescale counter, internal 24-bit up-counter and CEN bit</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>Timer Operating Mode\n</description>
              <bitOffset>27</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The timer is operating in the one-shot mode. The associated interrupt signal is generated once (if IE is enabled) and CEN is automatically cleared by hardware</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The timer is operating in the periodic mode. The associated interrupt signal is generated periodically (if IE is enabled)</description>
                    <value>1</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Reserved</description>
                    <value>2</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>The timer is operating in continuous counting mode. The associated interrupt signal is generated when TDR = TCMPR (if IE is enabled); however, the 24-bit up-counter counts continuously without reset</description>
                    <value>3</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IE</name>
              <description>Interrupt Enable Bit\nIf timer interrupt is enabled, the timer asserts its interrupt signal when the count is equal to TCMPR.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable TIMER Interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable TIMER Interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CEN</name>
              <description>Counter Enable Bit\nNote1: Setting CEN = 1 enables 24-bit counter. It continues count from last value.\nNote2: This bit is auto-cleared by hardware in one-shot mode (MODE = 00b) when the timer interrupt is generated (IE = 1b).</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Stops/Suspends counting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Starts counting</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TCMPR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TCMPR</displayName>
          <description>Timer Compare Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TCMP</name>
              <description>Timer Comparison Value\nTCMP is a 24-bit comparison register. When the 24-bit up-counter is enabled and its value is equal to TCMP value, a Timer Interrupt is requested if the timer interrupt is enabled with TCSR.IE = 1. The TCMP value defines the timer cycle time.\nTime out period = (Period of timer clock input) * (8-bit PRESCALE + 1) * (24-bit TCMP)\nNOTE1: Never set TCMP to 0x000 or 0x001. Timer will not function correctly.\nNOTE2: Regardless of CEN state, whenever a new value is written to this register, TIMER will restart counting using this new value and abort previous count.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>25</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TISR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TISR</displayName>
          <description>Timer Interrupt Status Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TIF</name>
              <description>Timer Interrupt Flag\nThis bit indicates the interrupt status of Timer.\nTIF bit is set by hardware when the 24-bit counter matches the timer comparison value (TCMP). It is cleared by writing 1.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TDR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TDR</displayName>
          <description>Timer Data Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TDR</name>
              <description>Timer Data Register\nWhen TCSR.TDR_EN is set to 1, the internal 24-bit timer up-counter value will be latched into TDR. User can read this register for the up-counter value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>WDT</name>
      <description>WDT Register Map</description>
      <groupName>WDT</groupName>
      <baseAddress>0x40004000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>WTCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>WTCR</displayName>
          <description>Watchdog Timer Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000700</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WTR</name>
              <description>Clear Watchdog Timer \nSet this bit will clear the Watchdog timer. \nNOTE: This bit will auto clear after few clock cycle</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Writing 0 to this bit has no effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the contents of the Watchdog timer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WTRE</name>
              <description>Watchdog Timer Reset Enable\nSetting this bit will enable the Watchdog timer reset function.\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable Watchdog timer reset function</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable Watchdog timer reset function</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WTRF</name>
              <description>Watchdog Timer Reset Flag\nWhen the Watchdog timer initiates a reset, the hardware will set this bit. This flag can be read by software to determine the source of reset. Software is responsible to clear it manually by writing 1 to it. If WTRE is disabled, then the Watchdog timer has no effect on this bit.\nNOTE: This bit is cleared by writing 1 to this bit.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Watchdog timer reset has not occurred</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Watchdog timer reset has occurred</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WTIF</name>
              <description>Watchdog Timer Interrupt Flag\nIf the Watchdog timer interrupt is enabled, then the hardware will set this bit to indicate that the Watchdog timer interrupt has occurred. If the Watchdog timer interrupt is not enabled, then this bit indicates that a timeout period has elapsed.\nNOTE: This bit is cleared by writing 1 to this bit.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Watchdog timer interrupt has not occurred</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Watchdog timer interrupt has occurred</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WTIE</name>
              <description>Watchdog Timer Interrupt Enable\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable the Watchdog timer interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable the Watchdog timer interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WTE</name>
              <description>Watchdog Timer Enable\n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable the Watchdog timer (This action will reset the internal counter)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable the Watchdog timer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WTIS</name>
              <description>Watchdog Timer Interval Select\nThese three bits select the timeout interval for the Watchdog timer, a watchdog reset will occur 1024 clock cycles later if WDG not reset. The timeout is given by:\nInterrupt Timeout = 2^(2xWTIS+4)  x WDT_CLK\nReset Timeout = (2^(2xWTIS+4) +1024) x WDT_CLK\nWhere WDT_CLK is the period of the Watchdog Timer clock source.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>UART0</name>
      <description>UART0 Register Map</description>
      <groupName>UART0</groupName>
      <baseAddress>0x40050000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x34</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>DATA</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>DATA</displayName>
          <description>UART0 Receive/Transfer FIFO Register.</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>_8_bitReceivedData</name>
              <description>Receive FIFO Register\nReading this register will return data from the receive data FIFO. By reading this register, the UART will return the  8-bit data received from Rx pin (LSB first).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>IER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IER</displayName>
          <description>UART0 Interrupt Enable Register.</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDA_IEN</name>
              <description>Receive Data Available Interrupt Enable.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Mask off RDA_INT</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable RDA_INT</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>THRE_IEN</name>
              <description>Transmit FIFO Register Empty Interrupt Enable\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Mask off THRE_INT</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable THRE_INT</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RLS_IEN</name>
              <description>Receive Line Status Interrupt Enable \n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Mask off RLS_INT</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable RLS_INT</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MS_IEN</name>
              <description>Modem Status Interrupt Enable\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Mask off MODEM_INT</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable MODEM_INT</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RTO_IEN</name>
              <description>Receive Time out Interrupt Enable\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Mask off TOUT_INT</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable TOUT_INT</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BUF_ERR_IEN</name>
              <description>Buffer Error Interrupt Enable\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Mask off BUF_ERR_INT</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable IBUF_ERR_INT</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_RX_BRK_IEN</name>
              <description>LIN RX Break Field Detected Interrupt Enable\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Mask off Lin bus Rx break field interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable Lin bus Rx break field interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TOC_EN</name>
              <description>Time-Out Counter Enable\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable Time-out counter</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTO_RTS_EN</name>
              <description>RTS Auto Flow Control Enable\nWhen RTS auto-flow is enabled, if the number of bytes in the Rx FIFO equals FCR.RTS_TRIG_LEVEL, the UART will de-assert the RTS signal.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable RTS auto flow control</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTO_CTS_EN</name>
              <description>CTS Auto Flow Control Enable \nWhen CTS auto-flow is enabled, the UART will send data to external device when CTS input is asserted (UART will not send data to device until CTS is asserted).</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable CTS auto flow control</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_TX_EN</name>
              <description>Transmit DMA Enable \nIf enabled, the UART will request DMA service when space is available in transmit FIFO.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_RX_EN</name>
              <description>Receive DMA Enable\nIf enabled, the UART will request DMA service when data is available in receive FIFO.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>FCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>FCR</displayName>
          <description>UART0 FIFO Control Register.</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RFR</name>
              <description>Receive FIFO Reset\nWhen RFR is set, all the bytes in the receive FIFO are cleared and receive internal state machine is reset.\nNote: This bit will auto-clear after 3 UART engine clock cycles.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Writing 0 to this bit has no effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Writing 1 to this bit will reset the receive internal state machine and pointers</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TFR</name>
              <description>Transmit FIFO Reset\nWhen TFR is set, all the bytes in the transmit FIFO are cleared and transmit internal state machine is reset.\nNote: This bit will auto-clear after 3 UART engine clock cycles.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Writing 0 to this bit has no effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Writing 1 to this bit will reset the transmit internal state machine and pointers</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RFITL</name>
              <description>Receive  FIFO Interrupt (RDA_INT) Trigger Level \nWhen the number of bytes in the receive FIFO equals the RFITL then the RDA_IF will be set and, if enabled, an RDA_INT interrupt will generated.\nValue             :            INTR_RDA Trigger Level (Bytes)\n0                    :                               1\n1                    :                               4\n2                    :                               8</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RTS_TRIG_LEVEL</name>
              <description>RTS Trigger Level for Auto-flow Control\nSets the FIFO trigger level when auto-flow control will de-assert RTS (request-to-send).\nValue               :                 Trigger Level (Bytes)\n0                      :                             1\n1                      :                             4\n2                      :                             8</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>LCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>LCR</displayName>
          <description>UART0 Line Control Register.</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WLS</name>
              <description>Word Length Select\n0 (5bits),  1(6bits),  2(7bits),  3(8bits)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NSB</name>
              <description>Number of STOP bits\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One "STOP bit" is generated after  the transmitted data</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Two "STOP bits" are generated when 6-, 7- and 8-bit word length is selected; One and a half "STOP bits" are generated in the transmitted data when 5-bit word length is selected;</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PBE</name>
              <description>Parity Bit Enable\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Parity bit is not generated (transmit data) or checked (receive data) during transfer</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Parity bit is generated or checked between the &quot;last data word bit&quot; and &quot;stop bit&quot; of the serial data</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EPE</name>
              <description>Even Parity Enable\nThis bit has effect only when PBE (parity bit enable) is set.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Odd number of logic 1's are transmitted or checked in the data word and parity bits</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Even number of logic 1's are transmitted or checked in the data word and parity bits</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPE</name>
              <description>Stick Parity Enable \n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable stick parity</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When bits PBE and SPE are set 'Stick Parity' is enabled. If EPE=0 the parity bit is transmitted and checked as always set, if EPE=1, the parity bit is transmitted and checked as always cleared</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BCB</name>
              <description>Break Control Bit \nWhen this bit is set to logic 1, the serial data output (Tx) is forced to the 'Space' state (logic 0). Normal condition is serial data output is 'Mark' state. This bit acts only on Tx and has no effect on the transmitter logic.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>MCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>MCR</displayName>
          <description>UART0 Modem Control Register.</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RTS_SET</name>
              <description>RTS (Request-To-Send) Signal \nIf IER.AUTO_RTS_EN = 0, this bit controls whether RTS pin is active or not.\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Drive RTS inactive ( = ~RTS_ACT)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Drive RTS active ( = RTS_ACT)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LBME</name>
              <description>Loopback Mode Enable\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RTS_ACT</name>
              <description>Request-to-Send (RTS) Active Trigger Level\nThis bit can change the RTS trigger level.\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTS is active low level</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTS is active high level</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RTS_ST</name>
              <description>RTS Pin State (read only)\nThis bit is the pin status of RTS.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>MSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>MSR</displayName>
          <description>UART0 Modem Status Register.</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DCTSF</name>
              <description>Detect CTS State Change Flag\nThis bit is set whenever CTS input has state change. It will generate Modem interrupt to CPU when IER.MS_IEN = 1\nNOTE: This bit is cleared by writing 1 to itself.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CTS_ST</name>
              <description>CTS Pin Status (read only)\nThis bit is the pin status of CTS.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CTS_ACT</name>
              <description>Clear-to-Send (CTS) Active Trigger Level\nThis bit can change the CTS trigger level.\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>CTS is active low level</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CTS is active high level</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>FSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>FSR</displayName>
          <description>UART0 FIFO Status Register.</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x10404000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX_OVF_IF</name>
              <description>Rx Overflow Error Interrupt Flag \nIf the Rx FIFO (UART0-&gt;DATA) is full, and an additional byte is received by the UART, an overflow condition will occur and set this bit to logic 1. It will also generate a BUF_ERR_IF event and interrupt if enabled.\nNOTE: This bit is cleared by writing 1 to itself.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PEF</name>
              <description>Parity Error Flag\nThis bit is set to logic 1 whenever the received character does not have a valid &quot;parity bit&quot;, and is reset whenever the CPU writes 1 to this bit.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FEF</name>
              <description>Framing Error Flag\nThis bit is set to logic 1 whenever the received character does not have a valid &quot;stop bit&quot; (that is, the stop bit following the last data bit or parity bit is detected as a logic 0), and is reset whenever the CPU writes 1 to this bit.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BIF</name>
              <description>Break Interrupt Flag\nThis bit is set to a logic 1 whenever the receive data input (Rx) is held in the &quot;space" state (logic 0) for longer than a full word transmission time (that is, the total time of start bit + data bits + parity + stop bits). It is reset whenever the CPU writes 1 to this bit.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_POINTER</name>
              <description>Rx FIFO pointer (Read Only)\nThis field returns the Rx FIFO buffer pointer. It is the number of bytes available for read in the Rx FIFO. When UART receives one byte from external device, RX_POINTER is incremented. When one byte of Rx FIFO is read by CPU, RX_POINTER is decremented.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_EMPTY</name>
              <description>Receive FIFO Empty (Read Only)\nThis bit indicates whether the Rx FIFO is empty or not.\nWhen the last byte of Rx FIFO has been read by CPU, hardware sets this bit high. It will be cleared when UART receives any new data.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_FULL</name>
              <description>Receive FIFO Full (Read Only)\nThis bit indicates whether the Rx FIFO is full or not.\nThis bit is set when Rx FIFO is full; otherwise it is cleared by hardware.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_POINTER</name>
              <description>Tx FIFO Pointer (Read Only)\nThis field returns the Tx FIFO buffer pointer. When CPU writes a byte into the Tx FIFO, TX_POINTER is incremented. When a byte from Tx FIFO is transferred to the Transmit Shift Register, TX_POINTER is decremented.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_EMPTY</name>
              <description>Transmit FIFO Empty (Read Only)\nThis bit indicates whether the Tx FIFO is empty or not.\nWhen the last byte of Tx FIFO has been transferred to Transmitter Shift Register, hardware sets this bit high. It will be cleared after writing data to FIFO (Tx FIFO not empty).</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_FULL</name>
              <description>Transmit FIFO Full (Read Only)\nThis bit indicates whether the Tx FIFO is full or not.\n</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_OVF_IF</name>
              <description>Tx Overflow Error Interrupt Flag \nIf the Tx FIFO (UART0-&gt;DATA) is full, an additional write to UART0-&gt;DATA will cause an overflow condition and set this bit to logic 1. It will also generate a BUF_ERR_IF event and interrupt if enabled.\nNOTE: This bit is cleared by writing 1 to itself.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TE</name>
              <description>Transmitter Empty (Read Only)\nBit is set by hardware when Tx FIFO is empty and the STOP bit of the last byte has been transmitted.\nBit is cleared automatically when Tx FIFO is not empty or the last byte transmission has not completed.\nNOTE: This bit is read only.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ISR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ISR</displayName>
          <description>UART0 Interrupt Status Register.</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000002</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDA_IF</name>
              <description>Receive Data Available Interrupt Flag (Read Only)\nWhen the number of bytes in the Rx FIFO equals FCR.RFITL then the RDA_IF will be set. If IER.RDA_IEN is enabled, the RDA interrupt will be generated. \nNOTE: This bit is read only and it will be cleared when the number of unread bytes of Rx FIFO drops below the threshold level (RFITL).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>THRE_IF</name>
              <description>Transmit Holding Register Empty Interrupt Flag (Read Only)\nThis bit is set when the last data of Tx FIFO is transferred to Transmitter Shift Register. If IER.THRE_IEN is enabled, the THRE interrupt will be generated.\nNOTE: This bit is read only and it will be cleared when writing data into the Tx FIFO.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RLS_IF</name>
              <description>Receive Line Status Interrupt Flag (Read Only)\nThis bit is set when the Rx receive data has a parity, framing or break error (at least one of, FSR.BIF, FSR.FEF and FSR.PEF, is set). If IER.RLS_IEN is enabled, the RLS interrupt will be generated.\nNOTE: This bit is read only and reset to 0 when all bits of BIF, FEF and PEF are cleared.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MODEM_IF</name>
              <description>MODEM Interrupt Flag (Read Only)\nNOTE: This bit is read only and reset when bit MSR.DCTSF is cleared by a write 1.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TOUT_IF</name>
              <description>Time Out Interrupt Flag (Read Only)\nThis bit is set when the Rx FIFO is not empty and no activity occurs in the Rx FIFO and the time out counter equal to TOIC. If IER.TOUT_IEN is enabled a CPU interrupt request will be generated.\nNOTE: This bit is read only and user can read FIFO to clear it.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BUF_ERR_IF</name>
              <description>Buffer Error Interrupt Flag (Read Only)\nThis bit is set when either the Tx or Rx FIFO overflows (FSR.TX_OVF_IF or FSR.RX_OVF_IF is set). When BUF_ERR_IF is set, the serial transfer may be corrupted. If IER.BUF_ERR_IEN is enabled a CPU interrupt request will be generated.\nNOTE: This bit is cleared when both FSR.TX_OVF_IF and FSR.RX_OVF_IF are cleared.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LIN_Rx_Break_IF</name>
              <description>LIN Bus Rx Break Field Detected Flag\nThis bit is set when LIN controller detects a break field. This bit is cleared by writing a 1.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RDA_INT</name>
              <description>Receive Data Available Interrupt Indicator to Interrupt Controller\nLogical AND of  IER.RDA_IEN and RDA_IF.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>THRE_INT</name>
              <description>Transmit Holding Register Empty Interrupt Indicator to Interrupt Controller\nLogical AND of  IER.THRE_IEN and THRE_IF.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RLS_INT</name>
              <description>Receive Line Status Interrupt Indicator to Interrupt Controller \nLogical AND of  IER.RLS_IEN and RLS_IF.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MODEM_INT</name>
              <description>MODEM Status Interrupt Indicator to Interrupt \nLogical AND of  IER.MS_IEN and MODEM_IF.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TOUT_INT</name>
              <description>Time Out Interrupt Indicator to Interrupt Controller \nLogical AND of  IER.RTO_IEN and TOUT_IF.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BUF_ERR_INT</name>
              <description>Buffer Error Interrupt Indicator to Interrupt Controller \nLogical AND of  IER.BUF_ERR_IEN and BUF_ERR_IF.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_Rx_Break_INT</name>
              <description>LIN Bus Rx Break Field Detected Interrupt Indicator to Interrupt Controller\nLogical AND of IER.LIN_RX_BRK_IEN and LIN_Rx_Break_IF.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DMAmodeBits</name>
              <description>DMA Mode Bits\nDMA mode equivalent following interrupt indicators and flags. See Table 5107 and normal  mode descriptions below.\nIn DMA mode (either DMA transmit or receive requests are active) these bits are generated rather than the normal use bits below.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TOR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TOR</displayName>
          <description>UART0 Time Out Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TOIC</name>
              <description>Time Out Interrupt Comparator\nThe time out counter resets and starts counting whenever the Rx FIFO receives a new data word. Once the content of time out counter (TOUT_CNT) is equal to that of time out interrupt comparator (TOIC), a receiver time out interrupt (TOUT_INT) is generated if IER.RTO_IEN is set. A new incoming data word or RX FIFO empty clears TOUT_IF. The period of the time out counter is the baud rate.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>BAUD</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BAUD</displayName>
          <description>UART0 Baud Rate Divisor Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x0F000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BRD</name>
              <description>Baud Rate Divider\nRefer to Table 5111 for more information.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIVX</name>
              <description>Divider X\nThe baud rate divider M = DIVX+1.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIVX_ONE</name>
              <description>Divider X equal 1\n0: M = DIVX+1, with restriction DIVX &#8805; 8.\n1: M = 1, with restriction BRD[15:0] &#8805; 3.\nRefer to Table 5111 for more information.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIVX_EN</name>
              <description>Divider X Enable\nThe baud rate equation is: Baud Rate = UART_CLK / [ M * (BRD + 2) ] ; The default value of M is 16.\nRefer to Table 5111 for more information.\nNOTE: When in IrDA mode, this bit must disabled.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable divider X ( M = 16)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable divider X (M = DIVX+1, with DIVX &#8805; 8)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>IRCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IRCR</displayName>
          <description>UART0 IrDA Control Register.</description>
          <addressOffset>0x28</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000040</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX_SELECT</name>
              <description>Transmit/Receive Selection\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Enable IrDA receiver</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable IrDA transmitter</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LOOPBACK</name>
              <description>IrDA Loopback Test Mode\nLoopback Tx to Rx.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_INV_EN</name>
              <description>Transmit inversion enable\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No inversion</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Invert Tx output signal</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_INV_EN</name>
              <description>Receive Inversion Enable\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No inversion</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Invert Rx input signal</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>LINCON</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>LINCON</displayName>
          <description>UART0 LIN Control Register.</description>
          <addressOffset>0x2C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LINBCNT</name>
              <description>UART LIN Break Field Length Count\nThis field indicates a 4-bit LIN Tx break field count.\nNOTE: This break field length is LINBCNT + 2</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_RX_EN</name>
              <description>LIN RX Enable\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable LIN Rx mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable LIN Rx mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_TX_EN</name>
              <description>LIN TX Break Mode Enable\nNOTE: When Tx break field transfer operation finished, this bit will be cleared automatically.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable LIN Tx Break Mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable LIN Tx Break Mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>FUNSEL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>FUNSEL</displayName>
          <description>UART0 Function Select Register.</description>
          <addressOffset>0x30</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LIN_EN</name>
              <description>Enable LIN  Function\nNote that IrDA and LIN functions are mutually exclusive: both cannot be active at same time.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UART Function</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable LIN Function</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IrDA_EN</name>
              <description>Enable IrDA Function\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UART Function</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable IrDA Function</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>I2S</name>
      <description>I2S Register Map</description>
      <groupName>I2S</groupName>
      <baseAddress>0x400A0000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x18</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>CON</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CON</displayName>
          <description>I2S Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>I2SEN</name>
              <description>Enable I2S Controller\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXEN</name>
              <description>Transmit Enable\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable data transmit</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable data transmit</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXEN</name>
              <description>Receive Enable\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable data receive</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable data receive</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MUTE</name>
              <description>Transmit Mute Enable\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmit data is shifted from FIFO</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmit channel zero</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WORDWIDTH</name>
              <description>Word Width\nThis parameter sets the word width of audio data. See Figure 563 for details of how data is formatted in transmit and receive FIFO.\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>data is 8 bit</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>data is 16 bit</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>data is 24 bit</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>data is 32 bit</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MONO</name>
              <description>Monaural data\nThis parameter sets whether mono or stereo data is processed. See Figure 563 for details of how data is formatted in transmit and receive FIFO.\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Data is stereo format</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Data is monaural format</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FORMAT</name>
              <description>Data format\nSee Figure 561 and Figure 562 for timing differences.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I2S data format</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>MSB justified data format</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLAVE</name>
              <description>Slave Mode\nI2S can operate as a master or slave. For master mode, I2S_BCLK and I2S_FS pins are outputs and send bit clock and frame sync  from ISD9160. In slave mode, I2S_BCLK and I2S_FS pins are inputs and bit clock and frame sync are received from external audio device.\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Master mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Slave mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXTH</name>
              <description>Transmit FIFO Threshold Level\nIf remaining data words in transmit FIFO less than or equal to the threshold level then TXTHI flag is set.\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXTH</name>
              <description>Receive FIFO Threshold Level\nWhen received data word(s) in buffer is equal or higher than threshold level then RXTHI flag is set. \n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MCLKEN</name>
              <description>Master Clock Enable\nThe ISD9160 can generate a master clock signal to an external audio CODEC to synchronize the audio devices. If audio devices are not synchronous, then data will be periodically corrupted. Software needs to implement a way to drop/repeat or interpolate samples in a jitter buffer if devices are not synchronized. The master clock frequency is determined by the CLKDIV.MCLK_DIV[2:0] register.\n</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable master clock</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable master clock</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RCHZCEN</name>
              <description>Right Channel Zero Cross Detect Enable\nIf this bit is set to 1, when right channel data sign bit changes, or data bits are all zero, the RZCF flag in I2S_STATUS register will be set to 1. \n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable right channel zero cross detect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable right channel zero cross detect</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LCHZCEN</name>
              <description>Left Channel Zero Cross Detect Enable\nIf this bit is set to 1, when left channel data sign bit changes, or data bits are all zero, the LZCF flag in I2S_STATUS register will be set to 1. \n</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable left channel zero cross detect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable left channel zero cross detect</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLR_TXFIFO</name>
              <description>Clear Transmit FIFO\nWrite 1 to clear transmit FIFO, internal pointer is reset to FIFO start point, and TXFIFO_LEVEL[3:0] returns to zero and transmit FIFO becomes empty. Data in transmit FIFO is not changed. \nThis bit is cleared by hardware automatically when clear operation complete.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CLR_RXFIFO</name>
              <description>Clear Receive FIFO\nWrite 1 to clear receive FIFO, internal pointer is reset to FIFO start point, and RXFIFO_LEVEL[3:0] returns to zero and receive FIFO becomes empty.\nThis bit is cleared by hardware automatically when clear operation complete.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXDMA</name>
              <description>Enable Transmit DMA\nWhen TX DMA is enables, I2S request DMA to transfer data from SRAM to transmit FIFO if FIFO is not full.\n</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable TX DMA</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable TX DMA</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXDMA</name>
              <description>Enable Receive DMA\nWhen RX DMA is enabled, I2S requests DMA to transfer data from receive FIFO to SRAM if FIFO is not empty.\n</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable RX DMA</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable RX DMA</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CLKDIV</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CLKDIV</displayName>
          <description>I2S Clock Divider Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MCLK_DIV</name>
              <description>Master Clock Divider\nISD9160 can generate a master clock to synchronously drive an external audio device. If MCLK_DIV is set to 0, MCLK is the same as I2S_CLK clock input, otherwise MCLK frequency is given by:\nF(MCLK) = F(I2S_CLK) / (2xMCLK_DIV)\nOr,\nMCLK_DIV = F(I2S_CLK) / (2 x F(MCLK))\nIf the desired MCLK frequency is 254Fs and Fs = 16kHz then MCLK_DIV = 6</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BCLK_DIV</name>
              <description>Bit Clock Divider\nIf I2S operates in master mode, bit clock is provided by ISD9160. Software can program these bits to generate bit clock frequency for the desired sample rate.\nFor sample rate Fs, the desired bit clock frequency is:\nF(BCLK) = Fs x Word_width_in_bytes x 16\nFor example if Fs = 16kHz, and word width is 2-bytes (16bit) then desired bit clock frequency is 512kHz.\nThe bit clock frequency is given by:\nF(BCLK) = F(I2S_CLK) / 2x(BCLK_DIV+1)\nOr,\nBCLK_DIV = F(I2S_CLK) / (2 x F(BCLK))  -1\nSo if F(I2S_CLK) = HCLK = 49.152MHz , desired F(BCLK) = 512kHz then BCLK_DIV = 47</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>IE</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IE</displayName>
          <description>I2S Interrupt Enable Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXUDFIE</name>
              <description>Receive FIFO Underflow Interrupt Enable\nIf software read receive FIFO when it is empty then RXUDF flag in I2SSTATUS register is set to 1. \n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXOVFIE</name>
              <description>Receive FIFO Overflow Interrupt Enable\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXTHIE</name>
              <description>Receive FIFO Threshold Level Interrupt\nInterrupt occurs if this bit is set to 1 and data words in receive FIFO is greater than or equal to RXTH[2:0].\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXUDFIE</name>
              <description>Transmit FIFO Underflow Interrupt Enable\nInterrupt occur if this bit is set to 1 and transmit FIFO underflow flag is set to 1.\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXOVFIE</name>
              <description>Transmit FIFO Overflow Interrupt Enable\nInterrupt occurs if this bit is set to 1 and transmit FIFO overflow flag is set to 1\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXTHIE</name>
              <description>Transmit FIFO Threshold Level Interrupt Enable\nInterrupt occurs if this bit is set to 1 and data words in transmit FIFO is less than TXTH[2:0].\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RZCIE</name>
              <description>Right Channel Zero Cross Interrupt Enable\nInterrupt will occur if this bit is set to 1 and right channel has zero cross event\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LZCIE</name>
              <description>Left Channel Zero Cross Interrupt Enable\nInterrupt will occur if this bit is set to 1 and left channel has zero cross event\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>STATUS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>STATUS</displayName>
          <description>I2S Status Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00141000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>I2SINT</name>
              <description>I2S Interrupt (Read Only)\nThis bit is set if any enabled I2S interrupt is active.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No I2S interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2S interrupt active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>I2SRXINT</name>
              <description>I2S Receive Interrupt (Read Only)\nThis indicates that there is an active receive interrupt source. This could be RXOVF, RXUDF or RXTHF if corresponding interrupt enable bits are active. To clear interrupt the corresponding source(s) must be cleared.\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No receive interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receive interrupt occurred</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>I2STXINT</name>
              <description>I2S Transmit Interrupt (Read Only)\nThis indicates that there is an active transmit interrupt source. This could be TXOVF, TXUDF, TXTHF, LZCF or RZCF if corresponding interrupt enable bits are active. To clear interrupt the corresponding source(s) must be cleared.\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No transmit interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmit interrupt occurred</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RIGHT</name>
              <description>Right Channel Active (Read Only)\nThis bit indicates current data being transmitted/received belongs to right channel\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Left channel</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Right channel</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RXUDF</name>
              <description>Receive FIFO Underflow Flag (Write '1' to clear)\nThis flag is set if attempt is made to read receive FIFO while it is empty.  \n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No underflow</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Underflow</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXOVF</name>
              <description>Receive FIFO Overflow Flag (Write '1' to clear)\nThis flag is set if I2S controller writes to receive FIFO when it is full.  Audio data is lost.\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No overflow</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Overflow</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXTHF</name>
              <description>Receive FIFO Threshold Flag (Read Only)\nWhen data word(s) in receive FIFO is greater than or equal to threshold value set in RXTH[2:0] the RXTHF bit becomes to 1. It remains set until receive FIFO level is less than RXTH[2:0]. It is cleared by reading RXFIFO until threshold satisfied.\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Data word(s) in FIFO is less than threshold level</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Data word(s) in FIFO is greater than or equal to threshold level</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RXFULL</name>
              <description>Receive FIFO full (Read Only)\nThis bit is set when receive FIFO is full.\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Not full</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Full</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RXEMPTY</name>
              <description>Receive FIFO empty (Read Only)\nThis is set when receive FIFO is empty.\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TXUDF</name>
              <description>Transmit FIFO underflow flag (Write '1' to clear)\nThis flag is set if I2S controller requests data when transmit FIFO is empty.  \n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No underflow</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Underflow</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXOVF</name>
              <description>Transmit FIFO Overflow Flag (Write '1' to clear)\nThis flag is set if data is written to transmit FIFO when it is full. \n</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No overflow</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Overflow</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXTHF</name>
              <description>Transmit FIFO Threshold Flag (Read Only)\nWhen data word(s) in transmit FIFO is less than or equal to the threshold value set in TXTH[2:0] the TXTHF bit becomes to 1. It remains set until transmit FIFO level is greater than TXTH[2:0]. Cleared by writing to TXFIFO register until threshold exceeded.\n</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Data word(s) in FIFO is greater than threshold level</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Data word(s) in FIFO is less than or equal to threshold level</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TXFULL</name>
              <description>Transmit FIFO Full (Read Only)\nThis bit is set when transmit FIFO is full.\n</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Not full</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Full</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TXEMPTY</name>
              <description>Transmit FIFO Empty (Read Only)\nThis is set when transmit FIFO is empty.\n</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TXBUSY</name>
              <description>Transmit Busy (Read Only)\nThis bit is cleared when all data in transmit FIFO and Tx shift register is shifted out. It is set when first data is loaded to Tx shift register. \n</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmit shift register is empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmit shift register is busy</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RZCF</name>
              <description>Right channel zero cross flag (write '1' to clear, or clear RCHZCEN)\n</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No zero cross</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Right channel zero cross is detected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LZCF</name>
              <description>Left channel zero cross flag (write '1' to clear, or clear LCHZCEN)\n</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No zero cross detected</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Left channel zero cross is detected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_LEVEL</name>
              <description>Receive FIFO level (Read Only)\n</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_LEVEL</name>
              <description>Transmit FIFO level (Read Only)\n</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TXFIFO</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TXFIFO</displayName>
          <description>I2S Transmit FIFO Register</description>
          <addressOffset>0x10</addressOffset>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXFIFO</name>
              <description>Transmit FIFO Register (Write Only)\nA write to this register pushes data onto the transmit FIFO. The transmit FIFO is eight words deep. The number of words currently in the FIFO can be determined by reading I2S-&gt;STATUS.TX_LEVEL.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>RXFIFO</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>RXFIFO</displayName>
          <description>I2S Receive FIFO Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXFIFO</name>
              <description>Receive FIFO Register (Read Only)\nA read of this register will pop data from the receive FIFO. The receive FIFO is eight words deep. The number of words currently in the FIFO can be determined by reading I2S-&gt;STATUS.RX_LEVEL.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>CRC</name>
      <description>CRC Register Map</description>
      <groupName>CRC</groupName>
      <baseAddress>0x40090000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0xC</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>CRC_EN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CRC_EN</displayName>
          <description>CRC Enable Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LEN</name>
              <description>CRC Packet Length\nIndicates number of bytes of CRC input to process. CRC calculation will stop once input number of bytes = LEN+1. Maximum packet size is 512 bytes, for LEN = 511.\nWriting any value to this register will flush all previous calculations and restart a new CRC calculation.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LSB</name>
              <description>CRC LSB mode\nDetermines whether CRC Generator processes input words (32bit/4Bytes) LSB (least significant byte) first or MSB (most significant byte) first.\nFor example if LSB = 1, and 0x01020304 is written to CRC_IN, bytes will be processed in order 0x04, 0x03, 0x02, 0x01. If LSB = 0, then order would be 0x01, 0x02, 0x3, 0x04.\nWriting any value to this register will flush all previous calculations and restart a new CRC calculation.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>CRC input is MSB first (default)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CRC input is LSB first</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CRC_IN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CRC_IN</displayName>
          <description>CRC Input Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CRC_IN</name>
              <description>CRC Input\nThe string of bytes to perform CRC calculation on.\nWhen LSB = 0, CRC performs calculation byte by byte in the order CRC_IN[31:24], CRC_IN[23:16], CRC_IN[15:8], CRC_IN[7:0].\nWhen LSB = 1, CRC performs calculation byte by byte in the order CRC_IN[7:0], CRC_IN[15:8], CRC_IN[23:16], CRC_IN[31:24].\nIf number of input bytes exceeds CRC Packet Length (CRC_EN[8:0]+1), any additional input bytes will be ignored.\nThe CRC generator takes four clock cycles to process the CRC input. Software must ensure that at least four clock cycles occur between writes of CRC_IN. Compiled assembly language can be examined to ensure this requirement is met.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CRC_OUT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CRC_OUT</displayName>
          <description>CRC Output Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-only</access>
          <resetValue>0x0000FFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CRC_OUT</name>
              <description>CRC Output\nThe result of CRC computation. The result is valid four clock cycles after last CRC_IN input data is written to CRC generator.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PDMA_GCR</name>
      <description>PDMA Register Map</description>
      <groupName>PDMA</groupName>
      <baseAddress>0x50008F00</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0xC</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>GCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GCR</displayName>
          <description>PDMA Global Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_RST</name>
              <description>PDMA Software Reset\nNote: This bit can reset all channels (global reset).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Writing 0 to this bit has no effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Writing 1 to this bit will reset the internal state machine and pointers. The contents of control register will not be cleared. This bit will auto clear after several clock cycles</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>HCLK_EN</name>
              <description>PDMA Controller Channel Clock Enable Control\nTo enable clock for channel  n HCLK_EN[n] must be set.\nHCLK_EN[n] = 1:  Enable Channel n clock\nHCLK_EN[n] = 0:  Disable Channel n clock</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDSSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDSSR</displayName>
          <description>PDMA Service Selection Control Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SPI0_RXSEL</name>
              <description>PDMA SPI0 Receive Selection\nThis field defines which PDMA channel is connected to SPI0 peripheral receive (PDMA source) request.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI0_TXSEL</name>
              <description>PDMA SPI0 Transmit Selection\nThis field defines which PDMA channel is connected to SPI0 peripheral transmit (PDMA destination) request.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_RXSEL</name>
              <description>PDMA ADC Receive Selection\nThis field defines which PDMA channel is connected to ADC peripheral receive (PDMA source) request.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DPWM_TXSEL</name>
              <description>PDMA DPWM Transmit Selection\nThis field defines which PDMA channel is connected to DPWM peripheral transmit (PDMA destination) request.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UART0_RXSEL</name>
              <description>PDMA UART0 Receive Selection\nThis field defines which PDMA channel is connected to UART0 peripheral receive (PDMA source) request.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UART0_TXSEL</name>
              <description>PDMA UART0 Transmit Selection\nThis field defines which PDMA channel is connected to UART0 peripheral transmit (PDMA destination) request.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>I2S_RXSEL</name>
              <description>PDMA I2S Receive Selection\nThis field defines which PDMA channel is connected to I2S peripheral receive (PDMA source) request.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>I2S_TXSEL</name>
              <description>PDMA I2S Transmit Selection\nThis field defines which PDMA channel is connected to I2S peripheral transmit (PDMA destination) request.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GCRISR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GCRISR</displayName>
          <description>PDMA Global Interrupt Status Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GCRISR</name>
              <description>Interrupt Pin Status (Read Only)\nGCRISR[n] is the interrupt status of PDMA channel n.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PDMA0</name>
      <description>PDMA Register Map</description>
      <groupName>PDMA</groupName>
      <baseAddress>0x50008000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x28</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>CSRn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CSRn</displayName>
          <description>PDMA Control Register of Channel n</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMACEN</name>
              <description>PDMA Channel Enable\nSetting this bit to 1 enables PDMA's operation. If this bit is cleared, PDMA will ignore all PDMA request and force Bus Master into IDLE state.\nNote: SW_RST will clear this bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_RST</name>
              <description>Software Engine Reset\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Writing 0 to this bit has no effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Writing 1 to this bit will reset the internal state machine and pointers. The contents of the control register will not be cleared. This bit will auto clear after a few clock cycles</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE_SEL</name>
              <description>PDMA Mode Select\nThis parameter selects to transfer direction of the PDMA channel. Possible values are:\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Memory to Memory mode (SRAM-to-SRAM)</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>IP to Memory mode (APB-to-SRAM)</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Memory to IP mode (SRAM-to-APB)</description>
                    <value>#10</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SAD_SEL</name>
              <description>Source Address Select\nThis parameter determines the behavior of the current source address register with each PDMA transfer. It can either be fixed, incremented or wrapped.\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer Source address is incremented</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer Source address is fixed</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Transfer Source address is wrapped. When CBCR (Current Byte Count) equals zero, the CSAR (Current Source Address) and CBCR registers will be reloaded from the SAR (Source Address) and BCR (Byte Count) registers automatically and PDMA will start another transfer. Cycle continues until software sets PDMA_EN = 0. When PDMA_EN is disabled, the PDMA will complete the active transfer but the remaining data in the SBUF will not be transferred to the destination address</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DAD_SEL</name>
              <description>Destination Address Select\nThis parameter determines the behavior of the current destination address register with each PDMA transfer. It can either be fixed, incremented or wrapped.\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer Destination Address is incremented</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer Destination Address is fixed (Used when data transferred from multiple addresses to a single destination such as peripheral FIFO input)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Transfer Destination Address is wrapped. When CBCR (Current Byte Count) equals zero, the CDAR (Current Destination Address) and CBCR registers will be reloaded from the DAR (Destination Address) and BCR (Byte Count) registers automatically and PDMA will start another transfer. Cycle continues until software sets PDMA_EN=0. When PDMA_EN is disabled, the PDMA will complete the active transfer but the remaining data in the SBUF will not be transferred to the destination address</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WRA_INT_SEL</name>
              <description>Wrap Interrupt Select \nx1xx:  If this bit is set, and wraparound mode is in operation a Wrap Interrupt can be generated when half each PDMA transfer is complete. For example if BCR = 32 then an interrupt could be generated when 16 bytes were sent.\nxxx1:  If this bit is set, and wraparound mode is in operation a Wrap Interrupt can be generated when  each PDMA transfer is wrapped. For example if BCR = 32 then an interrupt could be generated when 32 bytes were sent and PDMA wraps around.\nx1x1: Both half and w interrupts generated.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>APB_TWS</name>
              <description>Peripheral Transfer Width Select\nThis parameter determines the data width to be transferred each PDMA transfer operation.\nNote: This field is meaningful only when MODE_SEL is IP to Memory mode (APB-to-Memory) or Memory to IP mode (Memory-to-APB).</description>
              <bitOffset>19</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One word (32 bits) is transferred for every PDMA operation</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>One byte (8 bits) is transferred for every PDMA operation</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>One half-word (16 bits) is transferred for every PDMA operation</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIG_EN</name>
              <description>Trigger Enable - Start a PDMA operation\nNote: When PDMA transfer completed, this bit will be cleared automatically.\nIf a bus error occurs, all PDMA transfer will be stopped. Software must reset  PDMA channel, and then trigger again.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Write: no effect. Read: Idle/Finished</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable PDMA data read or write transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SARn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SARn</displayName>
          <description>PDMA Transfer Source Address Register of Channel n</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SAR</name>
              <description>PDMA Transfer Source Address Register\nThis register holds the initial Source Address of PDMA transfer. \nNote: The source address must be word aligned.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>DARn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>DARn</displayName>
          <description>PDMA Transfer Destination Address Register of Channel n</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DAR</name>
              <description>PDMA Transfer Destination Address Register\nThis register holds the initial Destination Address of PDMA transfer. \nNote: The destination address must be word aligned.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>BCRn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BCRn</displayName>
          <description>PDMA Transfer Byte Count Register of Channel n</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BCR</name>
              <description>PDMA Transfer Byte Count Register\nThis register controls the transfer byte count of PDMA. Maximum value is 0xFFFF.\nNote: When in memory-to-memory (CSR.MODE_SEL = 00b) mode, the transfer byte count must be word aligned, that is multiples of 4bytes.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>POINTn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>POINTn</displayName>
          <description>PDMA Internal Buffer Pointer Register of Channel n</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>POINT</name>
              <description>PDMA Internal Buffer Pointer Register (Read Only)\nA PDMA transaction consists of two stages, a read from the source address and a write to the destination address. Internally this data is buffered in a 32bit register. If transaction width between the read and write transactions are different, this register tracks which byte/half-word of the internal buffer is being processed by the current transaction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CSARn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CSARn</displayName>
          <description>PDMA Current Source Address Register of Channel n</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CSAR</name>
              <description>PDMA Current Source Address Register (Read Only)\nThis register returns the source address from which the PDMA transfer is occurring. This register is loaded from SAR when PDMA is triggered or when a wraparound occurs.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CDARn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CDARn</displayName>
          <description>PDMA Current Destination Address Register of Channel n</description>
          <addressOffset>0x18</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CDAR</name>
              <description>PDMA Current Destination Address Register (Read Only)\nThis register returns the destination address to which the PDMA transfer is occurring. This register is loaded from DAR when PDMA is triggered or when a wraparound occurs.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CBCRn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CBCRn</displayName>
          <description>PDMA Current Byte Count Register of Channel n</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CBCR</name>
              <description>PDMA Current Byte Count Register (Read Only)\nThis field indicates the current remaining byte count of PDMA transfer. This register is initialized with BCR register when PDMA is triggered or when a wraparound occurs</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>IERn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IERn</displayName>
          <description>PDMA Interrupt Enable Control Register of Channel n</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IE</name>
              <description>PDMA Read/Write Target Abort Interrupt Enable\nIf enabled, the PDMA controller will generate and interrupt to the CPU whenever a PDMA transaction is aborted due to an error. If a transfer is aborted, PDMA channel must be reset to resume DMA operation. \n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable PDMA transfer target abort interrupt generation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable PDMA transfer target abort interrupt generation</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BLKD_IE</name>
              <description>PDMA Transfer Done Interrupt Enable\nIf enabled, the PDMA controller will generate and interrupt to the CPU when the requested PDMA transfer is complete.\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable PDMA transfer done interrupt generation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable PDMA transfer done interrupt generation</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WAR_IE</name>
              <description>Wraparound Interrupt Enable\nIf enabled, and channel source or destination address is in wraparound mode,  the PDMA controller will generate a WRAP interrupt to the CPU according to the setting of CSR.WRA_INT_SEL. This can be interrupts when the transaction has finished and has wrapped around and/or when the transaction is half way in progress. This allows the efficient implementation of circular buffers for DMA.\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable Wraparound PDMA interrupt generation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable Wraparound interrupt generation</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ISRn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ISRn</displayName>
          <description>PDMA Interrupt Status Register of Channel n</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IF</name>
              <description>PDMA Read/Write Target Abort Interrupt Flag\nThis flag indicates a Target Abort interrupt condition has occurred. This condition can happen if attempt is made to read/write from  invalid or  non-existent memory space. It occurs when PDMA controller receives a bus error from AHB master. Upon occurrence PDMA will stop transfer and go to idle state. To resume, software must reset PDMA channel and initiate transfer again.\nNOTE: This bit is cleared by writing 1 to itself.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No bus ERROR response received</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bus ERROR response received</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BLKD_IF</name>
              <description>Block Transfer Done Interrupt Flag\nThis bit indicates that PDMA block transfer complete interrupt has been generated. It is cleared by writing 1 to the bit.\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer ongoing or Idle</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transfer Complete</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WAR_IF</name>
              <description>Wrap Around Transfer Byte Count Interrupt Flag\nThese flags are set whenever the conditions for a wraparound interrupt (complete or half complete) are met. They are cleared by writing one to the bits.\n0001 = Current transfer finished flag (CBCR == 0).\n0100 = Current transfer half complete flag (CBCR == BCR/2).</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INTR</name>
              <description>Interrupt Pin Status (Read Only)\nThis bit is the Interrupt pin status of PDMA channel.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PDMA1</name>
      <description>PDMA Register Map</description>
      <groupName>PDMA</groupName>
      <baseAddress>0x50008100</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x28</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>CSRn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CSRn</displayName>
          <description>PDMA Control Register of Channel n</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMACEN</name>
              <description>PDMA Channel Enable\nSetting this bit to 1 enables PDMA's operation. If this bit is cleared, PDMA will ignore all PDMA request and force Bus Master into IDLE state.\nNote: SW_RST will clear this bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_RST</name>
              <description>Software Engine Reset\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Writing 0 to this bit has no effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Writing 1 to this bit will reset the internal state machine and pointers. The contents of the control register will not be cleared. This bit will auto clear after a few clock cycles</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE_SEL</name>
              <description>PDMA Mode Select\nThis parameter selects to transfer direction of the PDMA channel. Possible values are:\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Memory to Memory mode (SRAM-to-SRAM)</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>IP to Memory mode (APB-to-SRAM)</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Memory to IP mode (SRAM-to-APB)</description>
                    <value>#10</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SAD_SEL</name>
              <description>Source Address Select\nThis parameter determines the behavior of the current source address register with each PDMA transfer. It can either be fixed, incremented or wrapped.\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer Source address is incremented</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer Source address is fixed</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Transfer Source address is wrapped. When CBCR (Current Byte Count) equals zero, the CSAR (Current Source Address) and CBCR registers will be reloaded from the SAR (Source Address) and BCR (Byte Count) registers automatically and PDMA will start another transfer. Cycle continues until software sets PDMA_EN = 0. When PDMA_EN is disabled, the PDMA will complete the active transfer but the remaining data in the SBUF will not be transferred to the destination address</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DAD_SEL</name>
              <description>Destination Address Select\nThis parameter determines the behavior of the current destination address register with each PDMA transfer. It can either be fixed, incremented or wrapped.\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer Destination Address is incremented</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer Destination Address is fixed (Used when data transferred from multiple addresses to a single destination such as peripheral FIFO input)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Transfer Destination Address is wrapped. When CBCR (Current Byte Count) equals zero, the CDAR (Current Destination Address) and CBCR registers will be reloaded from the DAR (Destination Address) and BCR (Byte Count) registers automatically and PDMA will start another transfer. Cycle continues until software sets PDMA_EN=0. When PDMA_EN is disabled, the PDMA will complete the active transfer but the remaining data in the SBUF will not be transferred to the destination address</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WRA_INT_SEL</name>
              <description>Wrap Interrupt Select \nx1xx:  If this bit is set, and wraparound mode is in operation a Wrap Interrupt can be generated when half each PDMA transfer is complete. For example if BCR = 32 then an interrupt could be generated when 16 bytes were sent.\nxxx1:  If this bit is set, and wraparound mode is in operation a Wrap Interrupt can be generated when  each PDMA transfer is wrapped. For example if BCR = 32 then an interrupt could be generated when 32 bytes were sent and PDMA wraps around.\nx1x1: Both half and w interrupts generated.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>APB_TWS</name>
              <description>Peripheral Transfer Width Select\nThis parameter determines the data width to be transferred each PDMA transfer operation.\nNote: This field is meaningful only when MODE_SEL is IP to Memory mode (APB-to-Memory) or Memory to IP mode (Memory-to-APB).</description>
              <bitOffset>19</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One word (32 bits) is transferred for every PDMA operation</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>One byte (8 bits) is transferred for every PDMA operation</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>One half-word (16 bits) is transferred for every PDMA operation</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIG_EN</name>
              <description>Trigger Enable - Start a PDMA operation\nNote: When PDMA transfer completed, this bit will be cleared automatically.\nIf a bus error occurs, all PDMA transfer will be stopped. Software must reset  PDMA channel, and then trigger again.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Write: no effect. Read: Idle/Finished</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable PDMA data read or write transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SARn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SARn</displayName>
          <description>PDMA Transfer Source Address Register of Channel n</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SAR</name>
              <description>PDMA Transfer Source Address Register\nThis register holds the initial Source Address of PDMA transfer. \nNote: The source address must be word aligned.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>DARn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>DARn</displayName>
          <description>PDMA Transfer Destination Address Register of Channel n</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DAR</name>
              <description>PDMA Transfer Destination Address Register\nThis register holds the initial Destination Address of PDMA transfer. \nNote: The destination address must be word aligned.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>BCRn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BCRn</displayName>
          <description>PDMA Transfer Byte Count Register of Channel n</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BCR</name>
              <description>PDMA Transfer Byte Count Register\nThis register controls the transfer byte count of PDMA. Maximum value is 0xFFFF.\nNote: When in memory-to-memory (CSR.MODE_SEL = 00b) mode, the transfer byte count must be word aligned, that is multiples of 4bytes.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>POINTn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>POINTn</displayName>
          <description>PDMA Internal Buffer Pointer Register of Channel n</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>POINT</name>
              <description>PDMA Internal Buffer Pointer Register (Read Only)\nA PDMA transaction consists of two stages, a read from the source address and a write to the destination address. Internally this data is buffered in a 32bit register. If transaction width between the read and write transactions are different, this register tracks which byte/half-word of the internal buffer is being processed by the current transaction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CSARn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CSARn</displayName>
          <description>PDMA Current Source Address Register of Channel n</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CSAR</name>
              <description>PDMA Current Source Address Register (Read Only)\nThis register returns the source address from which the PDMA transfer is occurring. This register is loaded from SAR when PDMA is triggered or when a wraparound occurs.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CDARn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CDARn</displayName>
          <description>PDMA Current Destination Address Register of Channel n</description>
          <addressOffset>0x18</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CDAR</name>
              <description>PDMA Current Destination Address Register (Read Only)\nThis register returns the destination address to which the PDMA transfer is occurring. This register is loaded from DAR when PDMA is triggered or when a wraparound occurs.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CBCRn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CBCRn</displayName>
          <description>PDMA Current Byte Count Register of Channel n</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CBCR</name>
              <description>PDMA Current Byte Count Register (Read Only)\nThis field indicates the current remaining byte count of PDMA transfer. This register is initialized with BCR register when PDMA is triggered or when a wraparound occurs</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>IERn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IERn</displayName>
          <description>PDMA Interrupt Enable Control Register of Channel n</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IE</name>
              <description>PDMA Read/Write Target Abort Interrupt Enable\nIf enabled, the PDMA controller will generate and interrupt to the CPU whenever a PDMA transaction is aborted due to an error. If a transfer is aborted, PDMA channel must be reset to resume DMA operation. \n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable PDMA transfer target abort interrupt generation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable PDMA transfer target abort interrupt generation</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BLKD_IE</name>
              <description>PDMA Transfer Done Interrupt Enable\nIf enabled, the PDMA controller will generate and interrupt to the CPU when the requested PDMA transfer is complete.\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable PDMA transfer done interrupt generation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable PDMA transfer done interrupt generation</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WAR_IE</name>
              <description>Wraparound Interrupt Enable\nIf enabled, and channel source or destination address is in wraparound mode,  the PDMA controller will generate a WRAP interrupt to the CPU according to the setting of CSR.WRA_INT_SEL. This can be interrupts when the transaction has finished and has wrapped around and/or when the transaction is half way in progress. This allows the efficient implementation of circular buffers for DMA.\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable Wraparound PDMA interrupt generation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable Wraparound interrupt generation</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ISRn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ISRn</displayName>
          <description>PDMA Interrupt Status Register of Channel n</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IF</name>
              <description>PDMA Read/Write Target Abort Interrupt Flag\nThis flag indicates a Target Abort interrupt condition has occurred. This condition can happen if attempt is made to read/write from  invalid or  non-existent memory space. It occurs when PDMA controller receives a bus error from AHB master. Upon occurrence PDMA will stop transfer and go to idle state. To resume, software must reset PDMA channel and initiate transfer again.\nNOTE: This bit is cleared by writing 1 to itself.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No bus ERROR response received</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bus ERROR response received</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BLKD_IF</name>
              <description>Block Transfer Done Interrupt Flag\nThis bit indicates that PDMA block transfer complete interrupt has been generated. It is cleared by writing 1 to the bit.\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer ongoing or Idle</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transfer Complete</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WAR_IF</name>
              <description>Wrap Around Transfer Byte Count Interrupt Flag\nThese flags are set whenever the conditions for a wraparound interrupt (complete or half complete) are met. They are cleared by writing one to the bits.\n0001 = Current transfer finished flag (CBCR == 0).\n0100 = Current transfer half complete flag (CBCR == BCR/2).</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INTR</name>
              <description>Interrupt Pin Status (Read Only)\nThis bit is the Interrupt pin status of PDMA channel.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PDMA2</name>
      <description>PDMA Register Map</description>
      <groupName>PDMA</groupName>
      <baseAddress>0x50008200</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x28</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>CSRn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CSRn</displayName>
          <description>PDMA Control Register of Channel n</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMACEN</name>
              <description>PDMA Channel Enable\nSetting this bit to 1 enables PDMA's operation. If this bit is cleared, PDMA will ignore all PDMA request and force Bus Master into IDLE state.\nNote: SW_RST will clear this bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_RST</name>
              <description>Software Engine Reset\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Writing 0 to this bit has no effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Writing 1 to this bit will reset the internal state machine and pointers. The contents of the control register will not be cleared. This bit will auto clear after a few clock cycles</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE_SEL</name>
              <description>PDMA Mode Select\nThis parameter selects to transfer direction of the PDMA channel. Possible values are:\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Memory to Memory mode (SRAM-to-SRAM)</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>IP to Memory mode (APB-to-SRAM)</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Memory to IP mode (SRAM-to-APB)</description>
                    <value>#10</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SAD_SEL</name>
              <description>Source Address Select\nThis parameter determines the behavior of the current source address register with each PDMA transfer. It can either be fixed, incremented or wrapped.\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer Source address is incremented</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer Source address is fixed</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Transfer Source address is wrapped. When CBCR (Current Byte Count) equals zero, the CSAR (Current Source Address) and CBCR registers will be reloaded from the SAR (Source Address) and BCR (Byte Count) registers automatically and PDMA will start another transfer. Cycle continues until software sets PDMA_EN = 0. When PDMA_EN is disabled, the PDMA will complete the active transfer but the remaining data in the SBUF will not be transferred to the destination address</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DAD_SEL</name>
              <description>Destination Address Select\nThis parameter determines the behavior of the current destination address register with each PDMA transfer. It can either be fixed, incremented or wrapped.\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer Destination Address is incremented</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer Destination Address is fixed (Used when data transferred from multiple addresses to a single destination such as peripheral FIFO input)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Transfer Destination Address is wrapped. When CBCR (Current Byte Count) equals zero, the CDAR (Current Destination Address) and CBCR registers will be reloaded from the DAR (Destination Address) and BCR (Byte Count) registers automatically and PDMA will start another transfer. Cycle continues until software sets PDMA_EN=0. When PDMA_EN is disabled, the PDMA will complete the active transfer but the remaining data in the SBUF will not be transferred to the destination address</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WRA_INT_SEL</name>
              <description>Wrap Interrupt Select \nx1xx:  If this bit is set, and wraparound mode is in operation a Wrap Interrupt can be generated when half each PDMA transfer is complete. For example if BCR = 32 then an interrupt could be generated when 16 bytes were sent.\nxxx1:  If this bit is set, and wraparound mode is in operation a Wrap Interrupt can be generated when  each PDMA transfer is wrapped. For example if BCR = 32 then an interrupt could be generated when 32 bytes were sent and PDMA wraps around.\nx1x1: Both half and w interrupts generated.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>APB_TWS</name>
              <description>Peripheral Transfer Width Select\nThis parameter determines the data width to be transferred each PDMA transfer operation.\nNote: This field is meaningful only when MODE_SEL is IP to Memory mode (APB-to-Memory) or Memory to IP mode (Memory-to-APB).</description>
              <bitOffset>19</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One word (32 bits) is transferred for every PDMA operation</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>One byte (8 bits) is transferred for every PDMA operation</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>One half-word (16 bits) is transferred for every PDMA operation</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIG_EN</name>
              <description>Trigger Enable - Start a PDMA operation\nNote: When PDMA transfer completed, this bit will be cleared automatically.\nIf a bus error occurs, all PDMA transfer will be stopped. Software must reset  PDMA channel, and then trigger again.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Write: no effect. Read: Idle/Finished</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable PDMA data read or write transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SARn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SARn</displayName>
          <description>PDMA Transfer Source Address Register of Channel n</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SAR</name>
              <description>PDMA Transfer Source Address Register\nThis register holds the initial Source Address of PDMA transfer. \nNote: The source address must be word aligned.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>DARn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>DARn</displayName>
          <description>PDMA Transfer Destination Address Register of Channel n</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DAR</name>
              <description>PDMA Transfer Destination Address Register\nThis register holds the initial Destination Address of PDMA transfer. \nNote: The destination address must be word aligned.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>BCRn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BCRn</displayName>
          <description>PDMA Transfer Byte Count Register of Channel n</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BCR</name>
              <description>PDMA Transfer Byte Count Register\nThis register controls the transfer byte count of PDMA. Maximum value is 0xFFFF.\nNote: When in memory-to-memory (CSR.MODE_SEL = 00b) mode, the transfer byte count must be word aligned, that is multiples of 4bytes.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>POINTn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>POINTn</displayName>
          <description>PDMA Internal Buffer Pointer Register of Channel n</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>POINT</name>
              <description>PDMA Internal Buffer Pointer Register (Read Only)\nA PDMA transaction consists of two stages, a read from the source address and a write to the destination address. Internally this data is buffered in a 32bit register. If transaction width between the read and write transactions are different, this register tracks which byte/half-word of the internal buffer is being processed by the current transaction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CSARn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CSARn</displayName>
          <description>PDMA Current Source Address Register of Channel n</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CSAR</name>
              <description>PDMA Current Source Address Register (Read Only)\nThis register returns the source address from which the PDMA transfer is occurring. This register is loaded from SAR when PDMA is triggered or when a wraparound occurs.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CDARn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CDARn</displayName>
          <description>PDMA Current Destination Address Register of Channel n</description>
          <addressOffset>0x18</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CDAR</name>
              <description>PDMA Current Destination Address Register (Read Only)\nThis register returns the destination address to which the PDMA transfer is occurring. This register is loaded from DAR when PDMA is triggered or when a wraparound occurs.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CBCRn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CBCRn</displayName>
          <description>PDMA Current Byte Count Register of Channel n</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CBCR</name>
              <description>PDMA Current Byte Count Register (Read Only)\nThis field indicates the current remaining byte count of PDMA transfer. This register is initialized with BCR register when PDMA is triggered or when a wraparound occurs</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>IERn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IERn</displayName>
          <description>PDMA Interrupt Enable Control Register of Channel n</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IE</name>
              <description>PDMA Read/Write Target Abort Interrupt Enable\nIf enabled, the PDMA controller will generate and interrupt to the CPU whenever a PDMA transaction is aborted due to an error. If a transfer is aborted, PDMA channel must be reset to resume DMA operation. \n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable PDMA transfer target abort interrupt generation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable PDMA transfer target abort interrupt generation</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BLKD_IE</name>
              <description>PDMA Transfer Done Interrupt Enable\nIf enabled, the PDMA controller will generate and interrupt to the CPU when the requested PDMA transfer is complete.\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable PDMA transfer done interrupt generation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable PDMA transfer done interrupt generation</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WAR_IE</name>
              <description>Wraparound Interrupt Enable\nIf enabled, and channel source or destination address is in wraparound mode,  the PDMA controller will generate a WRAP interrupt to the CPU according to the setting of CSR.WRA_INT_SEL. This can be interrupts when the transaction has finished and has wrapped around and/or when the transaction is half way in progress. This allows the efficient implementation of circular buffers for DMA.\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable Wraparound PDMA interrupt generation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable Wraparound interrupt generation</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ISRn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ISRn</displayName>
          <description>PDMA Interrupt Status Register of Channel n</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IF</name>
              <description>PDMA Read/Write Target Abort Interrupt Flag\nThis flag indicates a Target Abort interrupt condition has occurred. This condition can happen if attempt is made to read/write from  invalid or  non-existent memory space. It occurs when PDMA controller receives a bus error from AHB master. Upon occurrence PDMA will stop transfer and go to idle state. To resume, software must reset PDMA channel and initiate transfer again.\nNOTE: This bit is cleared by writing 1 to itself.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No bus ERROR response received</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bus ERROR response received</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BLKD_IF</name>
              <description>Block Transfer Done Interrupt Flag\nThis bit indicates that PDMA block transfer complete interrupt has been generated. It is cleared by writing 1 to the bit.\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer ongoing or Idle</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transfer Complete</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WAR_IF</name>
              <description>Wrap Around Transfer Byte Count Interrupt Flag\nThese flags are set whenever the conditions for a wraparound interrupt (complete or half complete) are met. They are cleared by writing one to the bits.\n0001 = Current transfer finished flag (CBCR == 0).\n0100 = Current transfer half complete flag (CBCR == BCR/2).</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INTR</name>
              <description>Interrupt Pin Status (Read Only)\nThis bit is the Interrupt pin status of PDMA channel.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PDMA3</name>
      <description>PDMA Register Map</description>
      <groupName>PDMA</groupName>
      <baseAddress>0x50008300</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x28</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>CSRn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CSRn</displayName>
          <description>PDMA Control Register of Channel n</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMACEN</name>
              <description>PDMA Channel Enable\nSetting this bit to 1 enables PDMA's operation. If this bit is cleared, PDMA will ignore all PDMA request and force Bus Master into IDLE state.\nNote: SW_RST will clear this bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_RST</name>
              <description>Software Engine Reset\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Writing 0 to this bit has no effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Writing 1 to this bit will reset the internal state machine and pointers. The contents of the control register will not be cleared. This bit will auto clear after a few clock cycles</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE_SEL</name>
              <description>PDMA Mode Select\nThis parameter selects to transfer direction of the PDMA channel. Possible values are:\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Memory to Memory mode (SRAM-to-SRAM)</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>IP to Memory mode (APB-to-SRAM)</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Memory to IP mode (SRAM-to-APB)</description>
                    <value>#10</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SAD_SEL</name>
              <description>Source Address Select\nThis parameter determines the behavior of the current source address register with each PDMA transfer. It can either be fixed, incremented or wrapped.\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer Source address is incremented</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer Source address is fixed</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Transfer Source address is wrapped. When CBCR (Current Byte Count) equals zero, the CSAR (Current Source Address) and CBCR registers will be reloaded from the SAR (Source Address) and BCR (Byte Count) registers automatically and PDMA will start another transfer. Cycle continues until software sets PDMA_EN = 0. When PDMA_EN is disabled, the PDMA will complete the active transfer but the remaining data in the SBUF will not be transferred to the destination address</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DAD_SEL</name>
              <description>Destination Address Select\nThis parameter determines the behavior of the current destination address register with each PDMA transfer. It can either be fixed, incremented or wrapped.\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer Destination Address is incremented</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer Destination Address is fixed (Used when data transferred from multiple addresses to a single destination such as peripheral FIFO input)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Transfer Destination Address is wrapped. When CBCR (Current Byte Count) equals zero, the CDAR (Current Destination Address) and CBCR registers will be reloaded from the DAR (Destination Address) and BCR (Byte Count) registers automatically and PDMA will start another transfer. Cycle continues until software sets PDMA_EN=0. When PDMA_EN is disabled, the PDMA will complete the active transfer but the remaining data in the SBUF will not be transferred to the destination address</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WRA_INT_SEL</name>
              <description>Wrap Interrupt Select \nx1xx:  If this bit is set, and wraparound mode is in operation a Wrap Interrupt can be generated when half each PDMA transfer is complete. For example if BCR = 32 then an interrupt could be generated when 16 bytes were sent.\nxxx1:  If this bit is set, and wraparound mode is in operation a Wrap Interrupt can be generated when  each PDMA transfer is wrapped. For example if BCR = 32 then an interrupt could be generated when 32 bytes were sent and PDMA wraps around.\nx1x1: Both half and w interrupts generated.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>APB_TWS</name>
              <description>Peripheral Transfer Width Select\nThis parameter determines the data width to be transferred each PDMA transfer operation.\nNote: This field is meaningful only when MODE_SEL is IP to Memory mode (APB-to-Memory) or Memory to IP mode (Memory-to-APB).</description>
              <bitOffset>19</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One word (32 bits) is transferred for every PDMA operation</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>One byte (8 bits) is transferred for every PDMA operation</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>One half-word (16 bits) is transferred for every PDMA operation</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIG_EN</name>
              <description>Trigger Enable - Start a PDMA operation\nNote: When PDMA transfer completed, this bit will be cleared automatically.\nIf a bus error occurs, all PDMA transfer will be stopped. Software must reset  PDMA channel, and then trigger again.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Write: no effect. Read: Idle/Finished</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable PDMA data read or write transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SARn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SARn</displayName>
          <description>PDMA Transfer Source Address Register of Channel n</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SAR</name>
              <description>PDMA Transfer Source Address Register\nThis register holds the initial Source Address of PDMA transfer. \nNote: The source address must be word aligned.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>DARn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>DARn</displayName>
          <description>PDMA Transfer Destination Address Register of Channel n</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DAR</name>
              <description>PDMA Transfer Destination Address Register\nThis register holds the initial Destination Address of PDMA transfer. \nNote: The destination address must be word aligned.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>BCRn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BCRn</displayName>
          <description>PDMA Transfer Byte Count Register of Channel n</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BCR</name>
              <description>PDMA Transfer Byte Count Register\nThis register controls the transfer byte count of PDMA. Maximum value is 0xFFFF.\nNote: When in memory-to-memory (CSR.MODE_SEL = 00b) mode, the transfer byte count must be word aligned, that is multiples of 4bytes.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>POINTn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>POINTn</displayName>
          <description>PDMA Internal Buffer Pointer Register of Channel n</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>POINT</name>
              <description>PDMA Internal Buffer Pointer Register (Read Only)\nA PDMA transaction consists of two stages, a read from the source address and a write to the destination address. Internally this data is buffered in a 32bit register. If transaction width between the read and write transactions are different, this register tracks which byte/half-word of the internal buffer is being processed by the current transaction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CSARn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CSARn</displayName>
          <description>PDMA Current Source Address Register of Channel n</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CSAR</name>
              <description>PDMA Current Source Address Register (Read Only)\nThis register returns the source address from which the PDMA transfer is occurring. This register is loaded from SAR when PDMA is triggered or when a wraparound occurs.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CDARn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CDARn</displayName>
          <description>PDMA Current Destination Address Register of Channel n</description>
          <addressOffset>0x18</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CDAR</name>
              <description>PDMA Current Destination Address Register (Read Only)\nThis register returns the destination address to which the PDMA transfer is occurring. This register is loaded from DAR when PDMA is triggered or when a wraparound occurs.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CBCRn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CBCRn</displayName>
          <description>PDMA Current Byte Count Register of Channel n</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CBCR</name>
              <description>PDMA Current Byte Count Register (Read Only)\nThis field indicates the current remaining byte count of PDMA transfer. This register is initialized with BCR register when PDMA is triggered or when a wraparound occurs</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>IERn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IERn</displayName>
          <description>PDMA Interrupt Enable Control Register of Channel n</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IE</name>
              <description>PDMA Read/Write Target Abort Interrupt Enable\nIf enabled, the PDMA controller will generate and interrupt to the CPU whenever a PDMA transaction is aborted due to an error. If a transfer is aborted, PDMA channel must be reset to resume DMA operation. \n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable PDMA transfer target abort interrupt generation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable PDMA transfer target abort interrupt generation</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BLKD_IE</name>
              <description>PDMA Transfer Done Interrupt Enable\nIf enabled, the PDMA controller will generate and interrupt to the CPU when the requested PDMA transfer is complete.\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable PDMA transfer done interrupt generation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable PDMA transfer done interrupt generation</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WAR_IE</name>
              <description>Wraparound Interrupt Enable\nIf enabled, and channel source or destination address is in wraparound mode,  the PDMA controller will generate a WRAP interrupt to the CPU according to the setting of CSR.WRA_INT_SEL. This can be interrupts when the transaction has finished and has wrapped around and/or when the transaction is half way in progress. This allows the efficient implementation of circular buffers for DMA.\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable Wraparound PDMA interrupt generation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable Wraparound interrupt generation</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ISRn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ISRn</displayName>
          <description>PDMA Interrupt Status Register of Channel n</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IF</name>
              <description>PDMA Read/Write Target Abort Interrupt Flag\nThis flag indicates a Target Abort interrupt condition has occurred. This condition can happen if attempt is made to read/write from  invalid or  non-existent memory space. It occurs when PDMA controller receives a bus error from AHB master. Upon occurrence PDMA will stop transfer and go to idle state. To resume, software must reset PDMA channel and initiate transfer again.\nNOTE: This bit is cleared by writing 1 to itself.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No bus ERROR response received</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bus ERROR response received</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BLKD_IF</name>
              <description>Block Transfer Done Interrupt Flag\nThis bit indicates that PDMA block transfer complete interrupt has been generated. It is cleared by writing 1 to the bit.\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer ongoing or Idle</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transfer Complete</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WAR_IF</name>
              <description>Wrap Around Transfer Byte Count Interrupt Flag\nThese flags are set whenever the conditions for a wraparound interrupt (complete or half complete) are met. They are cleared by writing one to the bits.\n0001 = Current transfer finished flag (CBCR == 0).\n0100 = Current transfer half complete flag (CBCR == BCR/2).</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INTR</name>
              <description>Interrupt Pin Status (Read Only)\nThis bit is the Interrupt pin status of PDMA channel.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>FMC</name>
      <description>FMC Register Map</description>
      <groupName>FMC</groupName>
      <baseAddress>0x5000C000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x18</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>ISPCON</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ISPCON</displayName>
          <description>ISP Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ISPEN</name>
              <description>ISP Enable\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable ISP function</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable ISP function</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BS</name>
              <description>Boot Select \nModify this bit to select which ROM next boot is to occur. This bit also functions as MCU boot status flag, which can be used to check where MCU booted from. This bit is initialized after power-on reset with the inverse of CBS in Config0; It is not reset for any other reset event.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>APROM</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LDROM</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CFGUEN</name>
              <description>CONFIG Update Enable \nWhen enabled, ISP functions can access the CONFIG address space and modify device configuration area.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LDUEN</name>
              <description>LDROM Update Enable\nLDROM update enable bit. \n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LDROM cannot be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LDROM can be updated when the MCU runs in APROM</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISPFF</name>
              <description>ISP Fail Flag\nThis bit is set by hardware when a triggered ISP meets any of the following conditions:\n(1) APROM writes to itself.\n(2) LDROM writes to itself. \n(3) Destination address is illegal, such as over an available range.\nWrite 1 to clear.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SWRST</name>
              <description>Software Reset\nWriting 1 to this bit will initiate a software reset. It is cleared by hardware after reset.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ISPADR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ISPADR</displayName>
          <description>ISP Address Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ISPADR</name>
              <description>ISP Address Register\nThis is the memory address register that a subsequent ISP command will access. ISP operation are carried out on 32bit words only, consequently ISPARD[1:0] must be 00b for  correct ISP operation.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ISPDAT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ISPDAT</displayName>
          <description>ISP Data Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ISPDAT</name>
              <description>ISP Data Register \nWrite data to this register before an ISP program operation.\nRead data from this register after an ISP read operation</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ISPCMD</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ISPCMD</displayName>
          <description>ISP Command Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ISPCMD</name>
              <description>ISP Command \nOperation Mode  :  ISPCMD\nStandby               :      0x3X\nRead                    :      0x00\nProgram               :      0x21\nPage Erase          :      0x22\nRead CID             :      0x0B\nRead DID             :      0x0C</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ISPTRG</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ISPTRG</displayName>
          <description>ISP Trigger Control Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ISPGO</name>
              <description>ISP Start Trigger\nWrite 1 to start ISP operation. This will be cleared to 0 by hardware automatically when ISP operation is finished.\nAfter triggering an ISP function M0 instruction pipeline should be flushed with a ISB instruction to guarantee data integrity.\nThis is a protected register, user must first follow the unlock sequence (see Protected Register Lock Key Register (REGLOCK)) to gain access.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ISP operation is finished</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ISP is on going</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>DFBADR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>DFBADR</displayName>
          <description>Data Flash Base Address</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>DFBA</name>
              <description>Data Flash Base Address\nThis register reports the data flash starting address. It is a read only register.\nData flash size is defined by user configuration, register content is loaded from Config1 when chip is reset.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>ADC</name>
      <description>ADC Register Map</description>
      <groupName>ADC</groupName>
      <baseAddress>0x400E0000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x20</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>ADCOUT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ADCOUT</displayName>
          <description>ADC FIFO Data Out.</description>
          <addressOffset>0x0</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFF0000</resetMask>
          <fields>
            <field>
              <name>ADCOUT</name>
              <description>ADC Audio Data FIFO Read\nA read of this register will read data from the audio FIFO and increment the read pointer.  A read past empty will repeat the last data. Can be used with FIFO_IE_LEV interrupt to determine if valid data is present in FIFO.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>EN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>EN</displayName>
          <description>ADC Enable Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>ADC Enable\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Conversion stopped and ADC is reset including FIFO pointers</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ADC Conversion enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CLK_DIV</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CLK_DIV</displayName>
          <description>ADC Clock Divider Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLK_DIV</name>
              <description>ADC Clock Divider \nThis register determines the clock division ration between the incoming ADC_CLK (= HCLK by default) and the Delta-Sigma sampling clock of the ADC. This together with the over-sampling ratio (OSR) determines the audio sample rate of the converter. CLK_DIV should be set to give a SD_CLK frequency in the range of 1.024-6.144MHz. \nCLK_DIV must be greater than 2.\nSD_CLK frequency = HCLK / CLK_DIV</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>DEC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>DEC</displayName>
          <description>ADC Decimation Control Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OSR</name>
              <description>Decimation Over-Sampling Ratio\nThis term determines the over-sampling ratio of the decimation filter. Valid values are:\n0: OSR = 64\n1: OSR = 128\n2: OSR = 192\n3: OSR = 384</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GAIN</name>
              <description>CIC Filter Additional Gain\nThis should normally remain default 0. Can be set to non-zero values to provide additional digital gain from the decimation filter. An additional gain is applied to signal of GAIN/2.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>INT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>INT</displayName>
          <description>ADC Interrupt Control Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FIFO_IE_LEV</name>
              <description>FIFO Interrupt Level\nDetermines at what level the ADC FIFO will generate a servicing interrupt to the CPU. Interrupt will be generated when number of words present in ADC FIFO is &gt; FIFO_IE_LEV.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IE</name>
              <description>Interrupt Enable\nIf set to '1' an interrupt is generated whenever FIFO level exceeds that set in FIFO_IE_LEV.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ADCPDMA</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ADCPDMA</displayName>
          <description>ADC PDMA Control Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RxDmaEn</name>
              <description>Enable ADC PDMA Receive Channel \nEnable ADC PDMA. If set, then ADC will request PDMA service when data is available.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ADCMPR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ADCMPR0</displayName>
          <description>ADC Comparator 0 Control Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMPEN</name>
              <description>Compare Enable\nSet this bit to 1 to enable compare CMPD with FIFO data output.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable compare</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable compare</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPIE</name>
              <description>Compare Interrupt Enable\nIf the compare function is enabled and the compare condition matches the setting of CMPCOND and CMPMATCNT, CMPF bit will be asserted, if CMPIE is set to 1, a compare interrupt request is generated.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable compare function interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable compare function interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPCOND</name>
              <description>Compare Condition\nNote: When the internal counter reaches the value (CMPMATCNT +1), the CMPF bit will be set.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Set the compare condition that result is less than CMPD</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Set the compare condition that result is greater or equal to CMPD</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPF</name>
              <description>Compare Flag\nWhen the conversion result meets condition in ADCMPR0 this bit is set to 1. It is cleared by writing 1 to self.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPMATCNT</name>
              <description>Compare Match Count\nWhen the A/D FIFO result matches the compare condition defined by CMPCOND, the internal match counter will increase by 1. When the internal counter reaches the value to (CMPMATCNT +1), the CMPF bit will be set.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPD</name>
              <description>Comparison Data\n16 bit value to compare to FIFO output word.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ADCMPR1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ADCMPR1</displayName>
          <description>ADC Comparator 1 Control Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMPEN</name>
              <description>Compare Enable\nSet this bit to 1 to enable compare CMPD with FIFO data output.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable compare</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable compare</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPIE</name>
              <description>Compare Interrupt Enable\nIf the compare function is enabled and the compare condition matches the setting of CMPCOND and CMPMATCNT, CMPF bit will be asserted, if CMPIE is set to 1, a compare interrupt request is generated.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable compare function interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable compare function interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPCOND</name>
              <description>Compare Condition\nNote: When the internal counter reaches the value (CMPMATCNT +1), the CMPF bit will be set.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Set the compare condition that result is less than CMPD</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Set the compare condition that result is greater or equal to CMPD</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPF</name>
              <description>Compare Flag\nWhen the conversion result meets condition in ADCMPR0 this bit is set to 1. It is cleared by writing 1 to self.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPMATCNT</name>
              <description>Compare Match Count\nWhen the A/D FIFO result matches the compare condition defined by CMPCOND, the internal match counter will increase by 1. When the internal counter reaches the value to (CMPMATCNT +1), the CMPF bit will be set.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPD</name>
              <description>Comparison Data\n16 bit value to compare to FIFO output word.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>DPWM</name>
      <description>DPWM Register Map</description>
      <groupName>DPWM</groupName>
      <baseAddress>0x40070000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x14</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>CTRL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CTRL</displayName>
          <description>DPWM Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>Freq</name>
              <description>DPWM Modulation Frequency\nThis parameter controls the carrier modulation frequency of the PWM signal as a proportion of DPWM_CLK.\nFreq  :   DPWM_CLK Division  :  Frequency for DPWM_CLK = 98.304MHZ\n0           :              228                   :                         431158\n1           :              156                   :                         630154\n2           :                76                   :                       1293474\n3           :                52                   :                       1890462\n4           :              780                   :                         126031\n5           :              524                   :                         187603\n6           :              396                   :                         248242\n7           :              268                   :                         366806</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>Deadtime</name>
              <description>DPWM Driver Deadtime Control\nEnabling this bit will insert an additional clock cycle deadtime into the switching of PMOS and NMOS driver transistors.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>Dither</name>
              <description>DPWM Signal Dither Control\nTo prevent structured noise on PWM output due to DC offsets in the input signal it is possible to add random dither to the PWM signal. These bits control the dither:\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No dither</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>+/- 1 bit dither</description>
                    <value>1</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>+/- 2 bit dither</description>
                    <value>3</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>Enable</name>
              <description>DPWM Enable\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable DPWM, SPK pins are tri-state, CIC filter is reset, FIFO pointers are reset (FIFO data is not reset)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable DPWM, SPK pins are enabled and driven, data is taken from FIFO</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>STAT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>STAT</displayName>
          <description>DPWM FIFO Status Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000002</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FULL</name>
              <description>FIFO Full\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>FIFO is not full</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>FIFO is full</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>EMPTY</name>
              <description>FIFO Empty\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>FIFO is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>FIFO is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>DMA</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>DMA</displayName>
          <description>DPWM PDMA Control Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EnablePDMA</name>
              <description>Enable DPWM DMA Interface\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable PDMA. No requests will be made to PDMA controller</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable PDMA. Block will request data from PDMA controller whenever FIFO is not empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>FIFO</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>FIFO</displayName>
          <description>DPWM FIFO Input</description>
          <addressOffset>0xC</addressOffset>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FIFO</name>
              <description>DPWM FIFO Audio Data Input\nA write to this register pushes data onto the DPWM FIFO and increments the write pointer. This is the address that PDMA writes audio data to.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ZOH_DIV</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ZOH_DIV</displayName>
          <description>DPWM Zero Order Hold Division Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000030</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ZOH_DIV</name>
              <description>DPWM Zero Order Hold, Down-Sampling Divisor\nThe input sample rate of the DPWM is set by HCLK frequency and the divisor set in this register by the following formula: \nFs = HCLK/ZOH_DIV/64\nValid range is 1 to 255. Default is 48, which gives a sample rate of 16kHz for a 49.152MHz (default) HCLK.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>ACMP</name>
      <description>ACMP Register Map</description>
      <groupName>ACMP</groupName>
      <baseAddress>0x400D0000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x10</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>CMPCR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CMPCR0</displayName>
          <description>Analog Comparator 0 Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMPEN</name>
              <description>Comparator Enable\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPIE</name>
              <description>CMP0 Interrupt Enable\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable CMP0 interrupt function</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable CMP0 interrupt function</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPCN</name>
              <description>Comparator0 Negative Input Select \n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>VBG, Bandgap reference voltage = 1.2V</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>VMID reference voltage = VCCA/2</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CMPCR1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CMPCR1</displayName>
          <description>Analog Comparator 1 Control Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMPEN</name>
              <description>Comparator Enable\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPIE</name>
              <description>CMP1 Interrupt Enable\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable CMP1interrupt function</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable CMP1 interrupt function</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPCN</name>
              <description>Comparator1 Negative Input Select \n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOB[7]</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>VBG, Bandgap reference voltage = 1.2V</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CMPSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CMPSR</displayName>
          <description>Comparator Status Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFF00</resetMask>
          <fields>
            <field>
              <name>CMPF0</name>
              <description>Compare 0 Flag\nThis bit is set by hardware whenever the comparator output changes state. This bit will cause a hardware interrupt if enabled. This bit is cleared by writing 1 to itself.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPF1</name>
              <description>Compare 1 Flag\nThis bit is set by hardware whenever the comparator output changes state. This bit will cause a hardware interrupt if enabled. This bit is cleared by writing 1 to itself.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CO0</name>
              <description>Comparator0 Output\nSynchronized to the APB clock to allow reading by software. Cleared when the comparator is disabled (CMP0EN = 0).</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CO1</name>
              <description>Comparator1 Output\nSynchronized to the APB clock to allow reading by software. Cleared when the comparator is disabled (CMP1EN = 0).</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CMPSEL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CMPSEL</displayName>
          <description>Comparator Select Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMPSEL</name>
              <description>Comparator0 GPIO Selection\nGPIOB[CMPSEL] is the active analog GPIO input selected to Comparator 0 positive input.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>ANA</name>
      <description>ANA Register Map</description>
      <groupName>ANA</groupName>
      <baseAddress>0x40080000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x8</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x20</offset>
        <size>0x10</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x38</offset>
        <size>0xC</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x50</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x60</offset>
        <size>0xC</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x84</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x8C</offset>
        <size>0x10</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>VMID</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>VMID</displayName>
          <description>VMID Reference Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000007</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PULLDOWN</name>
              <description>VMID Pulldown\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Release VMID pin for reference operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Pull VMID pin to ground. Default power down and reset condition</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PDLORES</name>
              <description>Power Down Low (4.8k&#8486;) Resistance Reference\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Connect the Low Resistance reference to VMID. Use this setting for fast power up of VMID. Can be turned off after 50ms to save power</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The Low Resistance reference is disconnected from VMID. Default power down and reset condition</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PDHIRES</name>
              <description>Power Down High (360k&#8486;) Resistance Reference\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Connect the High Resistance reference to VMID. Use this setting for minimum power consumption</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The High Resistance reference is disconnected from VMID. Default power down and reset condition</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ISRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ISRC</displayName>
          <description>Current Source Control Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>Enable Current Source to GPIOB[x]\nIndividually enable current source to GPIOB pins. Each GPIOB pin has a separate current source.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable current source to pin GPIOB[x]</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>VAL</name>
              <description>Current Source Value\nSelect master current for source generation\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>0.5 uA</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>1 uA</description>
                    <value>1</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>2.5 uA</description>
                    <value>2</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>5 uA</description>
                    <value>3</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>LDOSET</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>LDOSET</displayName>
          <description>LDO Voltage Select Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LDOSET</name>
              <description>Select LDO Output Voltage\nNote that maximum I/O pad operation speed only specified for voltage &gt;2.4V. \n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>3.0V</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>1.8V</description>
                    <value>1</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>2.4V</description>
                    <value>2</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>3.3V</description>
                    <value>3</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>LDOPD</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>LDOPD</displayName>
          <description>LDO Power Down Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PD</name>
              <description>Power Down LDO\nWhen powered down no current delivered to VD33.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Enable LDO</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Power Down</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DISCH</name>
              <description>Discharge\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No load on VD33</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Switch discharge resistor to VD33</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>MICBSEL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>MICBSEL</displayName>
          <description>Microphone Bias Select Register</description>
          <addressOffset>0x28</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SEL</name>
              <description>Select Microphone Bias Voltage\nMICBMODE = 0\n0: 90% VCCA\n1: 65% VCCA\n2: 75% VCCA\n3: 50% VCCA\nMICBMODE = 1\n0: 2.4V\n1: 1.7V\n2: 2.0V\n3: 1.3V</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>REF</name>
              <description>Select Reference Source For MICBIAS Generator\nVMID provides superior noise performance for MICBIAS generation and should be used unless fixed voltage is absolutely necessary, then noise performance can be sacrificed and bandgap voltage used as reference.\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>VMID = VCCA/2 is reference source</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>VBG (bandgap voltage reference) is reference source</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>MICBEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>MICBEN</displayName>
          <description>Microphone Bias Enable Register</description>
          <addressOffset>0x2C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MICBEN</name>
              <description>Enable Microphone Bias Generator\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Powered Down</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>VSET</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>VSET</displayName>
          <description>Logic Power Control Register</description>
          <addressOffset>0x38</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
          </fields>
       </register>
       <register>
          <name>TMPOWER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TMPOWER</displayName>
          <description>Power Test Mode Register</description>
          <addressOffset>0x3C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
          </fields>
       </register>
       <register>
          <name>TMANALOG</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TMANALOG</displayName>
          <description>Analog Test Mode Register</description>
          <addressOffset>0x40</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
          </fields>
       </register>
       <register>
          <name>AMUX</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>AMUX</displayName>
          <description>Analog Multiplexer Control Register</description>
          <addressOffset>0x50</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MUXN_SEL</name>
              <description>Selects Connection Of GPIOB[7:0] To PGA_INN, Negative Input Of PGA\nIf MUXN_SEL[n] = 1 then GPIOB[n] is connected to PGA_INN.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MUXP_SEL</name>
              <description>Selects Connection Of GPIOB[7,5,3,1] To PGA_INP, Positive Input Of PGA\n1000b: GPIOB[7] connected to PGA_INP\n0100b: GPIOB[5] connected to PGA_INP\n0010b: GPIOB[3] connected to PGA_INP\n0001b: GPIOB[1] connected to PGA_INP</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TEMP_SEL</name>
              <description>Select PTAT Current\n I_PTAT, to PGA_INN, negative input to PGA, for temperature measurement.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MIC_SEL</name>
              <description>Select MICP/MICN To PGA Inputs</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN</name>
              <description>Enable The Analog Multiplexer\n</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>All channels disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Selection determined by register setting</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PGAEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PGAEN</displayName>
          <description>PGA Enable Register</description>
          <addressOffset>0x60</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REF_SEL</name>
              <description>Select Reference For Analog Path\nSignal path is normally referenced to VMID (VCCA/2). To use an absolute reference this can be set to VBG = 1.2V.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Select VMID voltage as analog ground reference</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Select Bandgap voltage as analog ground reference</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PU_PGA</name>
              <description>Power Up Control For PGA Amplifier\nThis amplifier must be powered up for signal path operation.\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Power Down</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Power up</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PU_BOOST</name>
              <description>Power Up Control For Boost Stage Amplifier\nThis amplifier must be powered up for signal path operation.\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Power Down</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Power up</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BOOSTGAIN</name>
              <description>Boost Stage Gain Setting\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Gain = 0dB</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Gain = 26dB</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SIGCTRL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SIGCTRL</displayName>
          <description>Signal Path Control Register</description>
          <addressOffset>0x64</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PU_ZCD</name>
              <description>Power Up And Enable Control For Zero Cross Detect Comparator\nWhen enabled PGA gain settings will only be updated when ADC input signal crosses zero signal threshold. To operate ZCD the ALC peripheral clock (SYSCLK.BIQALC_EN) must also be enabled and BIQ-&gt;BIQ_CTRL.RSTn  = 1 to allow ZCD clocks to be generated. \n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Power down</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Power up and enable zero cross detection</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PU_BUFPGA</name>
              <description>Power Up Control For PGA Reference Buffer\nThis block must be powered up for signal path operation.\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Power down</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Power up</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PU_BUFADC</name>
              <description>Power Up Control For ADC Reference Buffer\nThis block must be powered up for signal path operation.\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Power down</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Power up</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PU_IBGEN</name>
              <description>Power Up Control For Current Bias Generation\nThis block must be powered up for signal path operation.\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Power down</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Power up</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PU_MOD</name>
              <description>Power Up ADC &#931;&#916; Modulator\nThis block must be powered up for ADC operation.\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Power down</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Power up</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MUTE_PGA</name>
              <description>PGA Mute Control\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Normal</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Signal Muted</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MUTE_IPBOOST</name>
              <description>Boost Stage Mute Control\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Normal</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Signal Muted</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PGAGAIN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PGAGAIN</displayName>
          <description>PGA Gain Select Register</description>
          <addressOffset>0x68</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000010</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GAIN</name>
              <description>Select The PGA Gain Setting\nFrom -12dB to 35.25dB in 0.75dB step size.  0x00 is lowest gain setting at -12dB and 0x3F is largest gain at 35.25dB.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GAIN_READ</name>
              <description>Current PGA Gain\nRead Only. May be different from GAIN register when AGC is enabled and is controlling the PGA gain.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TRIM</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TRIM</displayName>
          <description>Oscillator Trim Register</description>
          <addressOffset>0x84</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFF0000</resetMask>
          <fields>
            <field>
              <name>OSCTRIM</name>
              <description>Oscillator Trim\nReads current oscillator trim setting. Read Only.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COARSE</name>
              <description>COARSE \nCurrent COARSE range setting of the oscillator. Read Only</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SUPERFINE</name>
              <description>Superfine\nThe SUPERFINE trim setting is an 8bit signed integer. It adjusts the master oscillator by dithering the FINE trim setting between the current setting and one setting above (values 1,127) or below (values -1, -128) the current trim setting. Each step effectively moves the frequency 1/128th of the full FINE trim step size.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAPS_CTRL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAPS_CTRL</displayName>
          <description>Capacitive Touch Sensing Control Register</description>
          <addressOffset>0x8C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LOW_TIME</name>
              <description>Output Low Time\nNumber of PCLK cycles to discharge external capacitor. \n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>1cycle</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>2cycles</description>
                    <value>1</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>8cycles</description>
                    <value>2</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>16cycles</description>
                    <value>3</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CYCLE_CNT</name>
              <description>Number of Relaxation Cycles\nPeripheral performs 2^(CYCLE_CNT) relaxation cycles before generating interrupt.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>REF_CLK_MD</name>
              <description>Reference Clock Mode\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Capacitive Touch Sensing Mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Circuit is in Reference clock generation mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_DIV</name>
              <description>Reference Clock Divider\nCircuit can be used to generate a reference clock output of SDCLK/2/(CLK_DIV+1) instead of a Capacitive Touch Sensing reset signal.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RST_CNT</name>
              <description>Reset Count\n0: Release/Activate CAP_CNT\n1: Set high to reset CAP_CNT.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INT_EN</name>
              <description>Interrupt Enable\n</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable/Reset CAPS_IRQ interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable CAPS_IRQ interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EN</name>
              <description>Enable\n</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable/Reset block</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable Block</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAPS_CNT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAPS_CNT</displayName>
          <description>Capacitive Touch Sensing Count Register</description>
          <addressOffset>0x90</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CAPS_CNT</name>
              <description>Counter Read Back Value Of Capacitive Touch Sensing Block</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>FREQ_CTRL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>FREQ_CTRL</displayName>
          <description>Frequency Measurement Control Register</description>
          <addressOffset>0x94</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FM_SEL</name>
              <description>Reference Clock Source\n00b: OSC16K, \n01b: OSC32K (default), \n1xb: I2S_WS - can be GPIOA[4,8,12] according to GPA_ALT register, configure I2S in SLAVE mode to enable.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FM_DONE</name>
              <description>Measurement Done\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Measurement Ongoing</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Measurement Complete</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FM_CYCLE</name>
              <description>Frequency Measurement Cycles\nNumber of reference clock periods plus one to measure target clock (PCLK). For example if reference clock is OSC32K (T is 30.5175us), set FM_CYCLE to 7, then measurement period would be 30.5175*(7+1), 244.1us.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GO</name>
              <description>GO\n</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable/Reset block</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Start Frequency Measurement</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>FREQ_CNT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>FREQ_CNT</displayName>
          <description>Frequency Measurement Count Register</description>
          <addressOffset>0x98</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FREQ_CNT</name>
              <description>Frequency Measurement Count\nWhen FM_DONE = 1 and G0 = 1, this is number of PCLK periods counted for frequency measurement.\nThe frequency will be PCLK = FREQ_CNT * Fref /(FM_CYCLE+1) Hz\nMaximum resolution of measurement is  Fref /(FM_CYCLE+1)*2 Hz</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>ALC</name>
      <description>ALC Register Map</description>
      <groupName>ALC</groupName>
      <baseAddress>0x400B0048</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x10</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>ALC_CTRL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ALC_CTRL</displayName>
          <description>ALC Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x0E016320</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NGTH</name>
              <description>Noise Gate Threshold\nBoost disabled:    Threshold = (-81+6xNGTH) dB \nBoost enabled:     Threshold = (-87+6xNGTH) dB</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NGEN</name>
              <description>Noise Gate Enable\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Noise gate disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Noise gate enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ALCATK</name>
              <description>ALC Attack Time \n(Value: 0~10)\nWhen ALCMODE = 0, Range: 500us to 512ms\nWhen ALCMODE = 1,Range: 125us to 128ms (Both ALC time doubles with every step)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ALCDCY</name>
              <description>ALC Decay Time \n(Value: 0~10)\nWhen ALCMODE = 0,    Range: 125us to 128ms\nWhen ALCMODE = 1,    Range: 31us to 32ms (time doubles with every step)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ALCMODE</name>
              <description>ALC Mode\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ALC normal operation mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ALC limiter mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ALCLVL</name>
              <description>ALC Target Level\n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>-28.5 dB</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>-27 dB</description>
                    <value>1</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>-25.5 dB</description>
                    <value>2</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>-24 dB</description>
                    <value>3</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>-22.5 dB</description>
                    <value>4</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>-21 dB</description>
                    <value>5</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>-19.5 dB</description>
                    <value>6</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>-18 dB</description>
                    <value>7</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>8</name>
                    <description>-16.5 dB</description>
                    <value>8</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>9</name>
                    <description>-15 dB</description>
                    <value>9</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>10</name>
                    <description>-13.5 dB</description>
                    <value>10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>11</name>
                    <description>-12 dB</description>
                    <value>11</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>12</name>
                    <description>-10.5 dB</description>
                    <value>12</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>13</name>
                    <description>-9 dB</description>
                    <value>13</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>14</name>
                    <description>-7.5 dB</description>
                    <value>14</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>15</name>
                    <description>-6 dB</description>
                    <value>15</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ALCHLD</name>
              <description>ALC Hold Time \n(Value: 0~10).  Hold Time = (2^ALCHLD) ms</description>
              <bitOffset>17</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ALCZC</name>
              <description>ALC Zero Crossing\n</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>zero crossing disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>zero crossing enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ALCMIN</name>
              <description>ALC Minimum Gain\n</description>
              <bitOffset>22</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>-12 dB</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>-6 dB</description>
                    <value>1</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>0 dB</description>
                    <value>2</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>6 dB</description>
                    <value>3</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>12 dB</description>
                    <value>4</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>18 dB</description>
                    <value>5</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>24 dB</description>
                    <value>6</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>30 dB</description>
                    <value>7</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ALCMAX</name>
              <description>ALC Maximum Gain\n</description>
              <bitOffset>25</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>-6.75 dB</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>-0.75 dB</description>
                    <value>1</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>+5.25 dB</description>
                    <value>2</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>+11.25 dB</description>
                    <value>3</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>+17.25 dB</description>
                    <value>4</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>+23.25 dB</description>
                    <value>5</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>+29.25 dB</description>
                    <value>6</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>+35.25 dB</description>
                    <value>7</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ALCSEL</name>
              <description>ALC select\n</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ALC disabled (default)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ALC enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ALCNGSEL</name>
              <description>ALC noise gate peak detector select\n</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>use peak-to-peak value for noise gate threshold determination (default)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>use absolute peak value for noise gate threshold determination</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ALCPKSEL</name>
              <description>ALC gain peak detector select\n</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>use absolute peak value for ALC training (default)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>use peak-to-peak value for ALC training</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ALCPKLIM</name>
              <description>ALC peak limiter enable\n</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>enable fast decrement when signal exceeds 87.5% of full scale (default)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>disable fast decrement when signal exceeds 87.5% of full scale</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ALC_STATUS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ALC_STATUS</displayName>
          <description>ALC status register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FAST_DEC</name>
              <description>Clipping Flag\nAsserted when signal level is detected to be above 87.5% of full scale</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>NOISE</name>
              <description>Noise Flag\nAsserted when signal level is detected to be below NGTH</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>P2P</name>
              <description>Peak-To-Peak Value\n9 MSBs of measured peak-to-peak value</description>
              <bitOffset>2</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PEAK</name>
              <description>Peak Value\n9 MSBs of measured absolute peak value</description>
              <bitOffset>11</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ALC_INT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ALC_INT</displayName>
          <description>ALC interrupt register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ALC_INT</name>
              <description>ALC interrupt\nThis interrupt flag asserts whenever the interrupt is enabled and the PGA gain is updated, either through an ALC change with the ALC enabled or through a PGA gain write with the ALC disabled.\nWrite a 1 to this register to clear.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ALC_INTEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ALC_INTEN</displayName>
          <description>ALC interrupt enable register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ALC_INTEN</name>
              <description>ALC Interrupt Enable\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ALC_INT disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ALC_INT enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>BIQ</name>
      <description>BIQ Register Map</description>
      <groupName>BIQ</groupName>
      <baseAddress>0x400B0000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x3C</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x40</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>BIQ_COEFF0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BIQ_COEFF0</displayName>
          <description>Coefficient b0 In H(z) Transfer Function\n(3.16 format) - 1st stage BIQ Coefficients</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x0000D010</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
          </fields>
       </register>
       <register>
          <name>BIQ_COEFF1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BIQ_COEFF1</displayName>
          <description>Coefficient b1 In H(z) Transfer Function\n(3.16 format) - 1st stage BIQ Coefficients</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x0001C020</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
          </fields>
       </register>
       <register>
          <name>BIQ_COEFF2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BIQ_COEFF2</displayName>
          <description>Coefficient b2 In H(z) Transfer Function\n(3.16 format) - 1st stage BIQ Coefficients</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x0001C020</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
          </fields>
       </register>
       <register>
          <name>BIQ_COEFF3</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BIQ_COEFF3</displayName>
          <description>Coefficient a1 In H(z) Transfer Function\n(3.16 format) - 1st stage BIQ Coefficients</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x0001AD66</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
          </fields>
       </register>
       <register>
          <name>BIQ_COEFF4</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BIQ_COEFF4</displayName>
          <description>Coefficient a2 In H(z) Transfer Function\n(3.16 format) - 1st stage BIQ Coefficients</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x0000D1DC</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
          </fields>
       </register>
       <register>
          <name>BIQ_COEFF5</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BIQ_COEFF5</displayName>
          <description>Coefficient b0 In H(z) Transfer Function\n(3.16 format) - 2nd stage BIQ Coefficients</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x0000C1D0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
          </fields>
       </register>
       <register>
          <name>BIQ_COEFF6</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BIQ_COEFF6</displayName>
          <description>Coefficient b1 In H(z) Transfer Function\n(3.16 format) - 2nd stage BIQ Coefficients</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x000183A0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
          </fields>
       </register>
       <register>
          <name>BIQ_COEFF7</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BIQ_COEFF7</displayName>
          <description>Coefficient b2 In H(z) Transfer Function\n(3.16 format) - 2nd stage BIQ Coefficients</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-write</access>
          <resetValue>0x0000C1D0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
          </fields>
       </register>
       <register>
          <name>BIQ_COEFF8</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BIQ_COEFF8</displayName>
          <description>Coefficient a1 In H(z) Transfer Function\n(3.16 format) - 2nd stage BIQ Coefficients</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00017445</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
          </fields>
       </register>
       <register>
          <name>BIQ_COEFF9</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BIQ_COEFF9</displayName>
          <description>Coefficient a2 In H(z) Transfer Function\n(3.16 format) - 2nd stage BIQ Coefficients</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x000092F6</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
          </fields>
       </register>
       <register>
          <name>BIQ_COEFF10</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BIQ_COEFF10</displayName>
          <description>Coefficient b0 In H(z) Transfer Function\n(3.16 format) - 3rd stage BIQ Coefficients</description>
          <addressOffset>0x28</addressOffset>
          <access>read-write</access>
          <resetValue>0x0000B3CC</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
          </fields>
       </register>
       <register>
          <name>BIQ_COEFF11</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BIQ_COEFF11</displayName>
          <description>Coefficient b1 In H(z) Transfer Function\n(3.16 format) - 3rd stage BIQ Coefficients</description>
          <addressOffset>0x2C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00016798</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
          </fields>
       </register>
       <register>
          <name>BIQ_COEFF12</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BIQ_COEFF12</displayName>
          <description>Coefficient b2 In H(z) Transfer Function\n(3.16 format) - 3rd stage BIQ Coefficients</description>
          <addressOffset>0x30</addressOffset>
          <access>read-write</access>
          <resetValue>0x0000B3CC</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
          </fields>
       </register>
       <register>
          <name>BIQ_COEFF13</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BIQ_COEFF13</displayName>
          <description>Coefficient a1 In H(z) Transfer Function\n(3.16 format) - 3rd stage BIQ Coefficients</description>
          <addressOffset>0x34</addressOffset>
          <access>read-write</access>
          <resetValue>0x0001595D</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
          </fields>
       </register>
       <register>
          <name>BIQ_COEFF14</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BIQ_COEFF14</displayName>
          <description>Coefficient a2 In H(z) Transfer Function\n(3.16 format) - 3rd stage BIQ Coefficients</description>
          <addressOffset>0x38</addressOffset>
          <access>read-write</access>
          <resetValue>0x000075D2</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
          </fields>
       </register>
       <register>
          <name>BIQ_CTRL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BIQ_CTRL</displayName>
          <description>BIQ Control Register</description>
          <addressOffset>0x40</addressOffset>
          <access>read-write</access>
          <resetValue>0x0BFF0030</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>BIQ Filter Start To Run\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>BIQ filter is not processing</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>BIQ filter is on</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SELPWM</name>
              <description>AC Path Selection For BIQ\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>used in ADC path</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>used in DPWM path</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PRGCOEF</name>
              <description>Programming Mode Coefficient Control Bit\nThis bit must be turned off when BIQEN in on.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Coefficient RAM is in normal mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>coefficient RAM is under programming mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RSTn</name>
              <description>Move BIQ Out Of Reset State \n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>BIQ filter is in reset state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When this bit is on, the default coefficients will be downloaded to the coefficient ram automatically in 32 internal system clocks. Processor must delay enough time before changing the coefficients or turn the BIQ on</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>UPSR</name>
              <description>DPWM Path Up Sample Rate (From SR_DIV Result)\nThis register is only used when SELPWM is set to 1. The operating sample rate for the biquad filter will be\n(UPSR+1)*HCLK/(SR_DIV+1).\nDefault value for this register is 3.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SR_DIV</name>
              <description>Sample Rate Divider\nThis register is used to program the operating sampling rate of the biquad filter. The sample rate is defined as\nHCLK/(SR_DIV+1). \nDefault to 3071 so the sampling rate is 16K when HCLK is 49.152MHz.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>13</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
  </peripherals>
</device>
