<?xml version="1.0" encoding="utf-8"?>
<device schemaVersion="1.1" xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" xs:noNamespaceSchemaLocation="CMSIS-SVD_Schema_1_1.xsd" >
  <name>NUC1311AE_v1</name>
  <version>1.0</version>
  <description>NUC1311AE_v1 SVD file</description>
  <!-- Bus Interface Properties -->
  <!-- Cortex-M0 is byte addressable -->
  <addressUnitBits>8</addressUnitBits>
  <!-- the maximum data bit width accessible within a single transfer is 32bits -->
  <width>32</width>

  <!-- Register Default Properties -->
  <!-- the size of the registers is set to a bit width of 32. This can be overruled for individual peripherals and/or registers -->
  <size>32</size>
  <!-- the access to all registers is set to be readable and writeable. This can be overruled for individual peripherals and/or registers -->
  <access>read-write</access>
  <!-- for demonstration purposes the resetValue for all registers of the device is set to be 0. This can be overruled within the description -->
  <resetValue>0</resetValue>
  <!-- the resetMask = 0 specifies that by default no register of this device has a defined reset value -->
  <resetMask>0</resetMask>

  <peripherals>
    <peripheral>
      <name>GCR</name>
      <description>GCR Register Map</description>
      <groupName>GCR</groupName>
      <baseAddress>0x50000000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x14</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x18</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x24</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x30</offset>
        <size>0x18</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x50</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x5C</offset>
        <size>0xC</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x100</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>PDID</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDID</displayName>
          <description>Part Device Identification Number Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-only</access>
          <resetValue>0x20140018</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDID</name>
              <description>Part Device Identification Number\nThis register reflects device part number code. Software can read this register to identify which device is used.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>RSTSRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>RSTSRC</displayName>
          <description>System Reset Source Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFF00</resetMask>
          <fields>
            <field>
              <name>RSTS_POR</name>
              <description>Power-On Reset Flag\nThe RSTS_POR Flag is set by the 'Reset Signal' from the Power-On Reset (POR) vontroller or bit CHIP_RST (IPRSTC1[0]) to indicate the previous reset source.\nNote: Write 1 to clear this bit to 0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No reset from POR or CHIP_RST (IPRSTC1[0])</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Power-on Reset (POR) or CHIP_RST (IPRSTC1[0]) had issued the reset signal to reset the system</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RSTS_RESET</name>
              <description>Reset Pin Reset Flag\nThe RSTS_RESET flag is set by the 'Reset Signal' from the nRESET Pin to indicate the previous reset source.\nNote: Write 1 to clear this bit to 0.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No reset from nRESET pin</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The Pin nRESET had issued the reset signal to reset the system</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RSTS_WDT</name>
              <description>Watchdog Timer Reset Flag\nThe RSTS_WDT flag is set by the 'Reset Signal' from the watchdog timer or window watchdog timer to indicate the previous reset source.\nNote1: Write 1 to clear this bit to 0.\nNote2: Watchdog Timer register WTRF (WTCR[2]) bit is set if the system has been reset by WDT time-out reset. Window Watchdog Timer register WWDTRF (WWDTSR) bit is set if the system has been reset by WWDT time-out reset.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No reset from watchdog timer or window watchdog timer</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The watchdog timer or window watchdog timer had issued the reset signal to reset the system</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RSTS_LVR</name>
              <description>Low Voltage Reset Flag\nThe RSTS_LVR flag is set by the 'Reset Signal' from the Low-Voltage-Reset controller to indicate the previous reset source.\nNote: Write 1 to clear this bit to 0.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No reset from LVR</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The LVR controller had issued the reset signal to reset the system</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RSTS_BOD</name>
              <description>Brown-Out Detector Reset Flag\nThe RSTS_BOD flag is set by the 'Reset Signal' from the Brown-Out Detector to indicate the previous reset source.\nNote: Write 1 to clear this bit to 0.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No reset from BOD</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The BOD had issued the reset signal to reset the system</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RSTS_SYS</name>
              <description>SYS Reset Flag\nThe RSTS_SYS flag Is set by the 'Reset Signal' from the Cortex-M0 coreto indicate the previous reset source.\nNote: Write 1 to clear this bit to 0.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No reset from Cortex-M0</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The Cortex-M0 had issued the reset signal to reset the system by writing 1 to bit SYSRESETREQ (AIRCR[2], Application Interrupt and Reset Control Register, address = 0xE000ED0C) in system control registers of Cortex-M0 kernel</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RSTS_CPU</name>
              <description>CPU Reset Flag\nThe RSTS_CPU flag Is set by hardware if software writes CPU_RST (IPRSTC1[1]) 1 To reset Cortex-M0 coreand flash memory controller (FMC).\nNote: Write 1 to clear this bit to 0.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No reset from CPU</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Cortex-M0 CPU core and FMC are reset by software setting CPU_RST (IPRSTC1[1]) to 1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>IPRSTC1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IPRSTC1</displayName>
          <description>Peripheral Reset Control Register 1</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CHIP_RST</name>
              <description>CHIP One-Shot Reset (Write Protect)\nSetting this bit will reset the whole chip, including CPU coreand all peripherals, and this bit will automatically return to 0 after the 2 clock cycles.\nThe CHIP_RST is the same as the POR reset, all the chip controllers are reset and the chip setting from flash are also reload.\nFor the difference between CHIP_RST and SYSRESETREQ, please refer to section 6.2.2.\nNote: This bit is the protected bit, and programming it needs to write '59h', '16h', and '88h' to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>CHIP normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CHIP one-shot reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CPU_RST</name>
              <description>CPU Kernel One-Shot Reset (Write Protect)\nSetting this bit will only reset the CPU coreand Flash Memory Controller(FMC), and this bit will automatically return 0 after the two clock cycles.\nNote: This bit is the protected bit, and programming it needs to write '59h', '16h', and '88h' to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>CPU normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CPU one-shot reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>IPRSTC2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IPRSTC2</displayName>
          <description>Peripheral Reset Control Register 2</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPIO_RST</name>
              <description>GPIO Controller Reset</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR0_RST</name>
              <description>Timer0 Controller Reset</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer0 controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer0 controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR1_RST</name>
              <description>Timer1 Controller Reset</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer1 controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer1 controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR2_RST</name>
              <description>Timer2 Controller Reset</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer2 controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer2 controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR3_RST</name>
              <description>Timer3 Controller Reset</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer3 controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer3 controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C0_RST</name>
              <description>I2C0 Controller Reset</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I2C0 controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2C0 controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C1_RST</name>
              <description>I2C1 Controller Reset</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I2C1 controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2C1 controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI0_RST</name>
              <description>SPI0 Controller Reset</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPI0 controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI0 controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>UART0_RST</name>
              <description>UART0 Controller Reset</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UART0 controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART0 controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>UART1_RST</name>
              <description>UART1 Controller Reset</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UART1 controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART1 controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>UART2_RST</name>
              <description>UART2 Controller Reset </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UART2 controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART2 controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAN0_RST</name>
              <description>CAN0 Controller Reset</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>CAN0 controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CAN0 controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_RST</name>
              <description>ADC Controller Reset</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ADC controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ADC controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>IPRSTC3</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IPRSTC3</displayName>
          <description>Peripheral Reset Control Register 3</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>UART3_RST</name>
              <description>UART3 Controller Reset</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UART3 controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART3 controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>UART4_RST</name>
              <description>UART4 Controller Reset</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UART4 controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART4 controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>UART5_RST</name>
              <description>UART5 Controller Reset</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UART5 controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART5 controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM0_RST</name>
              <description>PWM0 Controller Reset</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM0 controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM0 controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM1_RST</name>
              <description>PWM1 Controller Reset</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM1 controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM1 controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BPWM0_RST</name>
              <description>BPWM0 Controller Reset</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>BPWM0 controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>BPWM0 controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BPWM1_RST</name>
              <description>BPWM1 Controller Reset</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>BPWM1 controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>BPWM1 controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>BODCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BODCR</displayName>
          <description>Brown-out Detector Control Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000380</resetValue>
          <resetMask>0xFFFFFFF0</resetMask>
          <fields>
            <field>
              <name>BOD_EN</name>
              <description>Brown-Out Detector Enable Control (Write Protect)\nThe default value is set by flash memory controller user configuration register CBODEN (CONFIG0[23]) bit.\nNote: This bit is the protected bit. It means programming this needs to write '59h', '16h', '88h' to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Brown-out Detector function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Brown-out Detector function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BOD_VL</name>
              <description>Brown-Out Detector Threshold Voltage Selection (Write Protect)\nThe default value is set by flash memory controller user configuration register CBOV (CONFIG0[22:21]) bit.\nNote: This bit is the protected bit. It means programming this needs to write '59h', '16h', '88h' to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Brown-out voltage is 2.2V</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Brown-out voltage is 2.7V</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Brown-out voltage is 3.7V</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Brown-out voltage is 4.4V</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BOD_RSTEN</name>
              <description>Brown-Out Reset Enable Control (Write Protect)\nWhile the Brown-out Detector function is enabled (BOD_EN high) and BOD reset function is enabled (BOD_RSTEN high), BOD will assert a signal to reset chip when the detected voltage is lower than the threshold (BOD_OUT high).\nNote1: While the BOD function is enabled (BOD_EN high) and BOD interrupt function is enabled (BOD_RSTEN low), BOD will assert an interrupt if BOD_OUT is high. BOD interrupt will keep till to the BOD_EN set to 0. BOD interrupt can be blocked by disabling the NVIC BOD interrupt or disabling BOD function (set BOD_EN low).\nNote2: The default value is set by flash controller user configuration register CBORST (CONFIG0[20]) bit. \nNote3: This bit is the protected bit. It means programming this needs to write '59h', '16h', '88h' to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Brown-out 'INTERRUPT' function Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Brown-out 'RESET' function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BOD_INTF</name>
              <description>Brown-Out Detector Interrupt Flag\nNote: Write 1 to clear this bit to 0.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Brown-out Detector does not detect any voltage draft at VDD down through or up through the voltage of BOD_VL setting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When Brown-out Detector detects the VDD is dropped down through the voltage of BOD_VL setting or the VDD is raised up through the voltage of BOD_VL setting, this bit is set to 1 and the Brown-out interrupt is requested if Brown-out interrupt is enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BOD_LPM</name>
              <description>Brown-Out Detector Low Power Mode (Write Protect)\nNote1: The BOD consumes about 100 uA in Normal mode, and the low power mode can reduce the current to about 1/10 but slow the BOD response.\nNote2: This bit is the protected bit, and programming it needs to write '59h', '16h', and '88h' to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>BOD operated in Normal mode (default)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>BOD Low Power mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BOD_OUT</name>
              <description>Brown-Out Detector Output Status</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Brown-out Detector output status is 0. It means the detected voltage is higher than BOD_VL setting or BOD_EN is 0</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Brown-out Detector output status is 1. It means the detected voltage is lower than BOD_VL setting. If the BOD_EN is 0, BOD function disabled, this bit always responds to 0</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LVR_EN</name>
              <description>Low Voltage Reset Enable Control (Write Protect)\nThe LVR function reset the chip when the input power voltage is lower than LVR circuit setting. LVR function is enabled by default.\nNote: This bit is the protected bit, and programming it needs to write '59h', '16h', and '88h' to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Low Voltage Reset function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Low Voltage Reset function Enabled - After enabling the bit, the LVR function will be active with 100us delay for LVR output stable (default)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BODDGSEL</name>
              <description>Brown-Out Detector Output De-Glitch Time Select (Write Protect)\nNote: This bit is the protected bit, and programming it needs to write '59h', '16h', and '88h' to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>BOD output is sampled by RC10K clock</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>4 system clock (HCLK)</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>8 system clock (HCLK)</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>16 system clock (HCLK)</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>32 system clock (HCLK)</description>
                    <value>#100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>64 system clock (HCLK)</description>
                    <value>#101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>128 system clock (HCLK)</description>
                    <value>#110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>256 system clock (HCLK)</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LVRDGSEL</name>
              <description>LVR Output De-Glitch Time Select (Write Protect)\nNote: This bit is the protected bit, and programming it needs to write '59h', '16h', and '88h' to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Without de-glitch function</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>4 system clock (HCLK)</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>8 system clock (HCLK)</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>16 system clock (HCLK)</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>32 system clock (HCLK)</description>
                    <value>#100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>64 system clock (HCLK)</description>
                    <value>#101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>128 system clock (HCLK)</description>
                    <value>#110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>256 system clock (HCLK)</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PORCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PORCR</displayName>
          <description>Power-on-reset Controller Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFF0000</resetMask>
          <fields>
            <field>
              <name>POR_DIS_CODE</name>
              <description>Power-On-Reset Enable Control (Write Protect)\nWhen powered on, the POR circuit generates a reset signal to reset the whole chip function, but noise on the power may cause the POR active again. User can disable internal POR circuit to avoid unpredictable noise to cause chip reset by writing 0x5AA5 to this field.\nThe POR function will be active again when  this field is set to another value or chip is reset by other reset source, including:\nnRESET, Watchdog Timer reset, Window Watchdog Timer reset, LVR reset, BOD reset, ICE reset command and the software-chip reset function\nNote: This bit is the protected bit. It means programming this needs to write '59h', '16h', '88h' to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>VREFCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>VREFCR</displayName>
          <description>VREF Controller Register</description>
          <addressOffset>0x28</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000010</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADC_VREFSEL</name>
              <description>ADC VREF Path Control (Write Protect)\nNote: This bit is the protected bit, and programming it needs to write '59h', '16h', and '88h' to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ADC VREF is from VREF pin</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ADC VREF is from AVDD</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPA_MFP</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPA_MFP</displayName>
          <description>GPIOA Multiple Function and Input Type Control Register</description>
          <addressOffset>0x30</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPA_MFP0</name>
              <description>PA.0 Pin Function Selection\nBits PA0_PWM04 (ALT_MFP3[4]), PA0_UR5TXD (ALT_MFP4[7]), PA0_I2C1SCL (ALT_MFP4[12]) and GPA_MFP0 determine the PA.0 function.\n(PA0_PWM04, PA0_UR5TXD, PA0_I2C1SCL, GPA_MFP0) value and function mapping is as following list.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA_MFP1</name>
              <description>PA.1 Pin Function Selection\nBits PA1_PWM05 (ALT_MFP3[5]), PA1_UR5RXD (ALT_MFP4[6]), PA1_I2C1SDA (ALT_MFP4[13]) and GPA_MFP1 determine the PA.1 function.\n(PA1_PWM05, PA1_UR5RXD, PA1_I2C1SDA, GPA_MFP1) value and function mapping is as following list.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA_MFP2</name>
              <description>PA.2 Pin Function Selection\nBits PA2_PWM10 (ALT_MFP3[6]), PA2_UR3TXD (ALT_MFP4[3]) and GPA_MFP2 determine the PA.2 function.\n(PA2_PWM10, PA2_UR3TXD, GPA_MFP2) value and function mapping is as following list.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA_MFP3</name>
              <description>PA.3 Pin Function Selection\nBits PA3_PWM11 (ALT_MFP3[7]), PA3_UR3RXD (ALT_MFP4[2]) and GPA_MFP3 determine the PA.3 function.\n(PA3_PWM11, PA3_UR3RXD, GPA_MFP3) value and function mapping is as following list.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA_MFP4</name>
              <description>PA.4 Pin Function Selection\nBit GPA_MFP4 determines the PA.4 function.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO function is selected</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ADC4 function is selected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA_MFP5</name>
              <description>PA.5 Pin Function Selection\nBits PA5_UR3RXD (ALT_MFP4[4]) and GPA_MFP5 determine the PA.5 function.\n(PA5_UR3RXD, GPA_MFP5) value and function mapping is as following list.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA_MFP6</name>
              <description>PA.6 Pin Function Selection\nBits PA6_UR3TXD (ALT_MFP4[5]) and GPA_MFP6 determine the PA.6 function.\n(PA6_UR3TXD, GPA_MFP6) value and function mapping is as following list.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA_MFP7</name>
              <description>PA.7 Pin Function Selection\nBits PA7_VREF (ALT_MFP4[14]) and GPA_MFP7 determine the PA.7 function.\n(PA7_VREF, GPA_MFP7) value and function mapping is as following list.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA_MFP8</name>
              <description>PA.8 Pin Function Selection\nBits PA8_UR1RTS (ALT_MFP4[0]) and GPA_MFP8 determine the PA.8 function.\n(PA8_UR1RTS, GPA_MFP8) value and function mapping is as following list.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA_MFP9</name>
              <description>PA.9 Pin Function Selection\nBits PA9_UR1CTS (ALT_MFP4[1]) and GPA_MFP9 determine the PA.9 function.\n(PA9_UR1CTS, GPA_MFP9) value and function mapping is as following list.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA_MFP10</name>
              <description>PA.10 Pin Function Selection\nBits PA10_PWM12 (ALT_MFP3[8]) and GPA_MFP10 determine the PA.10 function.\n(PA10_PWM12, GPA_MFP10) value and function mapping is as following list.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA_MFP11</name>
              <description>PA.11 Pin Function Selection\nBits PA11_PWM13 (ALT_MFP3[9]) and GPA_MFP11 determine the PA.11 function.\n(PA11_PWM13, GPA_MFP11) value and function mapping is as following list.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA_MFP12</name>
              <description>PA.12 Pin Function Selection\nBits PA12_UR5RXD (ALT_MFP4[8]) and GPA_MFP12 determine the PA.12 function.\n(PA12_UR5RXD, GPA_MFP12) value and function mapping is as following list.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA_MFP13</name>
              <description>PA.13 Pin Function Selection\nBits PA13_UR5TXD (ALT_MFP4[9]) and GPA_MFP13 determine the PA.13 function.\n(PA13_UR5TXD, GPA_MFP13) value and function mapping is as following list.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA_MFP14</name>
              <description>PA.14 Pin Function Selection\nBit GPA_MFP14 determines the PA.14 function.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO function is selected</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM0_CH2 function is selected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA_MFP15</name>
              <description>PA.15 Pin Function Selection\nBit GPA_MFP15 determines the PA.15 function.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO function is selected</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM0_CH3 function is selected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA_TYPEn</name>
              <description>Trigger Function Selection</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOA[15:0] I/O input Schmitt Trigger function Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOA[15:0] I/O input Schmitt Trigger function Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPB_MFP</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPB_MFP</displayName>
          <description>GPIOB Multiple Function and Input Type Control Register</description>
          <addressOffset>0x34</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPB_MFP0</name>
              <description>PB.0 Pin Function Selection\nBit GPB_MFP0 determines the PB.0 function.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO function is selected</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART0_RXD function is selected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPB_MFP1</name>
              <description>PB.1 Pin Function Selection\nBit GPB_MFP1 determines the PB.1 function.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO function is selected</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART0_TXD function is selected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPB_MFP2</name>
              <description>PB.2 Pin Function Selection\nBits PB2_TM2 (ALT_MFP2[4]), PB2_PWM1BK1 (ALT_MFP3[31]), PB2_T2EX (ALT_MFP[26]) and GPB_MFP2 determine the PB.2 function.\n(PB2_TM2, PB2_PWM1BK1, PB2_T2EX, GPB_MFP2) value and function mapping is as following list.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPB_MFP3</name>
              <description>PB.3 Pin Function Selection\nBits PB3_TM3 (ALT_MFP2[5]), PB3_PWM1BK0 (ALT_MFP3[30]), PB3_T3EX (ALT_MFP[27]) and GPB_MFP3 determine the PB.3 function.\n(PB3_TM3, PB3_PWM1BK0, PB3_T3EX, GPB_MFP3) value and function mapping is as following list.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPB_MFP4</name>
              <description>PB.4 Pin Function Selection\nBit GPB_MFP4 determines the PB.4 function.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO function is selected</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART1_RXD function is selected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPB_MFP5</name>
              <description>PB 5 Pin Function Selection\nBit GPB_MFP5 determines the PB.5 function.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO function is selected</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART1_TXD function is selected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPB_MFP6</name>
              <description>PB.6 Pin Function Selection\nBit GPB_MFP6 determines the PB.6 function.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO function is selected</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART1_nRTS function is selected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPB_MFP7</name>
              <description>PB.7 Pin Function Selection\nBit GPB_MFP7 determines the PB.7 function.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO function is selected</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART1_nCTS function is selected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPB_MFP8</name>
              <description>PB.8 Pin Function Selection\nBits PB8_BPWM12 (ALT_MFP3[20]), PB8_CLKO (ALT_MFP[29]) and GPB_MFP8 determine the PB.8 function.\n(PB8_BPWM12, PB8_CLKO, GPB_MFP8) value and function mapping is as following list.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPB_MFP9</name>
              <description>PB.9 Pin Function Selection\nBit GPB_MFP9 determines the PB.9 function.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO function is selected</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TM1 function is selected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPB_MFP10</name>
              <description>PB.10 Pin Function Selection\nBit GPB_MFP10 determines the PB.10 function.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO function is selected</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TM2 function is selected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPB_MFP11</name>
              <description>PB.11 Pin Function Selection\nBits PB11_PWM04 (ALT_MFP3[24]) and GPB_MFP11 determine the PB.11 function.\n(PB11_PWM04, GPB_MFP11) value and function mapping is as following list.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPB_MFP12</name>
              <description>PB.12 Pin Function Selection\nBits PB12_BPWM13 (ALT_MFP3[21]) and GPB_MFP12 determine the PB.12 function.\n(PB12_BPWM13, GPB_MFP12) value and function mapping is as following list.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPB_MFP14</name>
              <description>PB.14 Pin Function Selection\nBit GPB_MFP14 determines the PB.14 function.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO function is selected</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>INT0 function is selected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPB_MFP15</name>
              <description>PB.15 Pin Function Selection\nBits PB15_BPWM15 (ALT_MFP3[23]), PB15_T0EX (ALT_MFP[24]), PB15_TM0 (ALT_MFP2[2]) and GPB_MFP15 determine the PB.15 function.\n(PB15_BPWM15, PB15_T0EX, PB15_TM0, GPB_MFP15) value and function mapping is as following list.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPB_TYPEn</name>
              <description>Trigger Function Selection</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOB[15:0] I/O input Schmitt Trigger function Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOB[15:0] I/O input Schmitt Trigger function Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPC_MFP</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPC_MFP</displayName>
          <description>GPIOC Multiple Function and Input Type Control Register</description>
          <addressOffset>0x38</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPC_MFP0</name>
              <description>PC.0 Pin Function Selection\nBits PC0_BPWM00 (ALT_MFP3[12]) and GPC_MFP0 determine the PC.0 function.\n(PC0_BPWM00, GPC_MFP0) value and function mapping is as following list.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPC_MFP1</name>
              <description>PC.1 Pin Function Selection\nBits PC1_BPWM01 (ALT_MFP3[13]) and GPC_MFP1 determine the PC.1 function.\n(PC1_BPWM01, GPC_MFP1) value and function mapping is as following list.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPC_MFP2</name>
              <description>PC.2 Pin Function Selection\nBits PC2_BPWM02 (ALT_MFP3[14]) and GPC_MFP2 determine the PC.2 function.\n(PC2_BPWM02, GPC_MFP2) value and function mapping is as following list.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPC_MFP3</name>
              <description>PC.3 Pin Function Selection\nBits PC3_BPWM03 (ALT_MFP3[15]) and GPC_MFP3 determine the PC.3 function.\n(PC3_BPWM03, GPC_MFP3) value and function mapping is as following list.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPC_MFP6</name>
              <description>PC.6 Pin Function Selection\nBits PC6_PWM0BK0 (ALT_MFP3[28]), PC6_I2C0SDA (ALT_MFP4[10]) and GPC_MFP6 determine the PC.6 function.\n(PC6_PWM0BK0, PC6_I2C0SDA, GPC_MFP6) value and function mapping is as following list.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPC_MFP7</name>
              <description>PC.7 Pin Function Selection\nBits PC7_PWM0BK1 (ALT_MFP3[29]), PC7_I2C0SCL (ALT_MFP4[11]) and GPC_MFP7 determine the PC.7 function.\n(PC7_PWM0BK1, PC7_I2C0SCL, GPC_MFP7) value and function mapping is as following list.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPC_MFP8</name>
              <description>PC.8 Pin Function Selection\nBit GPC_MFP8 determines the PC.8 function.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO function is selected</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM0_BRAKE0 function is selected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPC_MFP9</name>
              <description>PC.9 Pin Function Selection\nBit GPC_MFP9 determines the PC.9 function.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO function is selected</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM0_BRAKE1 function is selected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPC_MFP10</name>
              <description>PC.10 Pin Function Selection\nBit GPC_MFP10 determines the PC.10 function.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO function is selected</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM1_BRAKE0 function is selected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPC_MFP11</name>
              <description>PC.11 Pin Function Selection\nBit GPC_MFP11 determines the PC.11 function.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO function is selected</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM1_BRAKE1 function is selected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPC_TYPEn</name>
              <description>Trigger Function Selection</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOC[15:0] I/O input Schmitt Trigger function Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOC[15:0] I/O input Schmitt Trigger function Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPD_MFP</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPD_MFP</displayName>
          <description>GPIOD Multiple Function and Input Type Control Register</description>
          <addressOffset>0x3C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPD_MFP6</name>
              <description>PD.6 Pin Function Selection\nBits PD6_BPWM11 (ALT_MFP3[19]) and GPD_MFP6 determine the PD.6 function.\n(PD6_BPWM11, GPD_MFP6) value and function mapping is as following list.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPD_MFP7</name>
              <description>PD.7 Pin Function Selection \nBits PD7_BPWM10 (ALT_MFP3[18]) and GPD_MFP7 determine the PD.7 function.\n(PD7_BPWM10, GPD_MFP7) value and function mapping is as following list.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPD_MFP14</name>
              <description>PD.14 Pin Function Selection \nBits PD14_BPWM05 (ALT_MFP3[17]) and GPD_MFP14 determine the PD.14 function.\n(PD14_BPWM05, GPD_MFP14) value and function mapping is as following list.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPD_MFP15</name>
              <description>PD.15 Pin Function Selection \nBits PD15_BPWM04 (ALT_MFP3[16]) and GPD_MFP15 determine the PD.15 function.\n(PD15_BPWM04, GPD_MFP15) value and function mapping is as following list.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPD_TYPEn</name>
              <description>Trigger Function Selection</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOD[15:0] I/O input Schmitt Trigger function Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOD[15:0] I/O input Schmitt Trigger function Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPE_MFP</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPE_MFP</displayName>
          <description>GPIOE Multiple Function and Input Type Control Register</description>
          <addressOffset>0x40</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPE_MFP5</name>
              <description>PE.5 Pin Function Selection\nBits PE5_T1EX (ALT_MFP[25]), PE5_TM1 (ALT_MFP2[3]) and GPE_MFP5 determine the PE.5 function.\n(PE5_T1EX, PE5_TM1, GPE_MFP5) value and function mapping is as following list.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPE_TYPE5</name>
              <description>Trigger Function Selection</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOE[5] I/O input Schmitt Trigger function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOE[5] I/O input Schmitt Trigger function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPF_MFP</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPF_MFP</displayName>
          <description>GPIOF Multiple Function and Input Type Control Register</description>
          <addressOffset>0x44</addressOffset>
          <access>read-write</access>
          <resetValue>0x000000C0</resetValue>
          <resetMask>0xFFFFFFF0</resetMask>
          <fields>
            <field>
              <name>GPF_MFP0</name>
              <description>PF.0 Pin Function Selection\nBit GPF_MFP0 determines the PF.0 function.\nNote: This bit is read only and is decided by user configuration CGPFMFP (CONFIG0[27]).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO function is selected</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>XT1_OUT function is selected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPF_MFP1</name>
              <description>PF.1 Pin Function Selection \nBit GPF_MFP1 determine the PF.1 function.\nNote: This bit is read only and is decided by user configuration CGPFMFP (CONFIG0[27]).</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO function is selected</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>XT1_IN function is selected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPF_MFP4</name>
              <description>PF.4 Pin Function Selection \nBits PF4_PWM14 (ALT_MFP3[10]) and GPF_MFP4 determine the PF.4 function.\n(PF4_PWM14, GPF_MFP4) value and function mapping is as following list.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPF_MFP5</name>
              <description>PF.5 Pin Function Selection\nBits PF5_PWM15 (ALT_MFP3[11]) and GPF_MFP5 determine the PF.5 function.\n(PF5_PWM15, GPF_MFP5) value and function mapping is as following list.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPF_MFP6</name>
              <description>PF.6 Pin Function Selection\nBit GPF_MFP6 determines the PF.6 function.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO function is selected</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ICE_CLK function is selected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPF_MFP7</name>
              <description>PF.7 Pin Function Selection\nBit GPF_MFP7 determines the PF.7 function.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO function is selected</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ICE_DAT function is selected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPF_MFP8</name>
              <description>PF.8 Pin Function Selection\nBit PF8_BPWM14 (ALT_MFP3[22]), GPF_MFP8 determines the PF.8 function.\n(PF8_BPWM14, GPF_MFP8) value and function mapping is as following list.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPF_TYPEn</name>
              <description>Trigger Function Selection</description>
              <bitOffset>16</bitOffset>
              <bitWidth>9</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOF[8:0] I/O input Schmitt Trigger function Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOF[8:0] I/O input Schmitt Trigger function Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ALT_MFP</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ALT_MFP</displayName>
          <description>Alternative Multiple Function Pin Control Register</description>
          <addressOffset>0x50</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PB15_T0EX</name>
              <description>PB.15 Pin Alternative Function Selection\nBits PB15_BPWM15 (ALT_MFP3[23]), PB15_T0EX (ALT_MFP[24]), PB15_TM0 (ALT_MFP2[2]) and GPB_MFP15 determine the PB.15 function.\n(PB15_BPWM15, PB15_T0EX, PB15_TM0, GPB_MFP15) value and function mapping is as following list.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PE5_T1EX</name>
              <description>PE.5 Pin Alternative Function Selection\nBits PE5_T1EX (ALT_MFP[25]), PE5_TM1 (ALT_MFP2[3]) and GPE_MFP5 determine the PE.5 function.\n(PE5_T1EX, PE5_TM1, GPE_MFP5) value and function mapping is as following list.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PB2_T2EX</name>
              <description>PB.2 Pin Alternative Function Selection\nBits PB2_TM2 (ALT_MFP2[4]), PB2_PWM1BK1 (ALT_MFP3[31]), PB2_T2EX (ALT_MFP[26]) and GPB_MFP2 determine the PB.2 function.\n(PB2_TM2, PB2_PWM1BK1, PB2_T2EX, GPB_MFP2) value and function mapping is as following list.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PB3_T3EX</name>
              <description>PB.3 Pin Alternative Function Selection\nBits PB3_TM3 (ALT_MFP2[5]), PB3_PWM1BK0 (ALT_MFP3[30]), PB3_T3EX (ALT_MFP[27]) and GPB_MFP3 determine the PB.3 function.\n(PB3_TM3, PB3_PWM1BK0, PB3_T3EX, GPB_MFP3) value and function mapping is as following list.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PB8_CLKO</name>
              <description>PB.8 Pin Alternative Function Selection\nBits PB8_BPWM12 (ALT_MFP3[20]), PB8_CLKO (ALT_MFP[29]) and GPB_MFP8 determine the PB.8 function.\n(PB8_BPWM12, PB8_CLKO, GPB_MFP8) value and function mapping is as following list.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ALT_MFP2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ALT_MFP2</displayName>
          <description>Alternative Multiple Function Pin Control Register 2</description>
          <addressOffset>0x5C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PB15_TM0</name>
              <description>PB.15 Pin Alternative Function Selection\nBits PB15_BPWM15 (ALT_MFP3[23]), PB15_T0EX (ALT_MFP[24]), PB15_TM0 (ALT_MFP2[2]) and GPB_MFP15 determine the PB.15 function.\n(PB15_BPWM15, PB15_T0EX, PB15_TM0, GPB_MFP15) value and function mapping is as following list.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PE5_TM1</name>
              <description>PE.5 Pin Alternative Function Selection\nBits PE5_T1EX (ALT_MFP[25]), PE5_TM1 (ALT_MFP2[3]) and GPE_MFP5 determine the PE.5 function.\n(PE5_T1EX, PE5_TM1, GPE_MFP5) value and function mapping is as following list.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PB2_TM2</name>
              <description>PB.2 Pin Alternative Function Selection\nBits PB2_TM2 (ALT_MFP2[4]), PB2_PWM1BK1 (ALT_MFP3[31]), PB2_T2EX (ALT_MFP[26]) and GPB_MFP2 determine the PB.2 function.\n(PB2_TM2, PB2_PWM1BK1, PB2_T2EX, GPB_MFP2) value and function mapping is as following list.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PB3_TM3</name>
              <description>PB.3 Pin Alternative Function Selection\nBits PB3_TM3 (ALT_MFP2[5]), PB3_PWM1BK0 (ALT_MFP3[30]), PB3_T3EX (ALT_MFP[27]) and GPB_MFP3 determine the PB.3 function.\n(PB3_TM3, PB3_PWM1BK0, PB3_T3EX, GPB_MFP3) value and function mapping is as following list.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ALT_MFP3</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ALT_MFP3</displayName>
          <description>Alternative Multiple Function Pin Control Register 3</description>
          <addressOffset>0x60</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PA0_PWM04</name>
              <description>PA.0 Pin Alternative Function Selection\nBits PA0_PWM04 (ALT_MFP3[4]), PA0_UR5TXD (ALT_MFP4[7]), PA0_I2C1SCL (ALT_MFP4[12]) and GPA_MFP0 determine the PA.0 function.\n(PA0_PWM04, PA0_UR5TXD, PA0_I2C1SCL, GPA_MFP0) value and function mapping is as following list.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PA1_PWM05</name>
              <description>PA.1 Pin Alternative Function Selection\nBits PA1_PWM05 (ALT_MFP3[5]), PA1_UR5RXD (ALT_MFP4[6]), PA1_I2C1SDA (ALT_MFP4[13]) and GPA_MFP1 determine the PA.1 function.\n(PA1_PWM05, PA1_UR5RXD , PA1_I2C1SDA, GPA_MFP1) value and function mapping is as following list.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PA2_PWM10</name>
              <description>PA.2 Pin Alternative Function Selection\nBits PA2_PWM10 (ALT_MFP3[6]), PA2_UR3TXD (ALT_MFP4[3]) and GPA_MFP2 determine the PA.2 function.\n(PA2_PWM10, PA2_UR3TXD, GPA_MFP2) value and function mapping is as following list.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PA3_PWM11</name>
              <description>PA.3 Pin Alternative Function Selection\nBits PA3_PWM11 (ALT_MFP3[7]), PA3_UR3RXD (ALT_MFP4[2]) and GPA_MFP3 determine the PA.3 function.\n(PA3_PWM11, PA3_UR3RXD, GPA_MFP3) value and function mapping is as following list.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PA10_PWM12</name>
              <description>PA.10 Pin Alternative Function Selection\nBits PA10_PWM12 (ALT_MFP3[8]) and GPA_MFP10 determine the PA.10 function.\n(PA10_PWM12, GPA_MFP10) value and function mapping is as following list.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PA11_PWM13</name>
              <description>PA.11 Pin Alternative Function Selection\nBits PA11_PWM13 (ALT_MFP3[9]) and GPA_MFP11 determine the PA.11 function.\n(PA11_PWM13, GPA_MFP11) value and function mapping is as following list.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PF4_PWM14</name>
              <description>PF.4 Pin Alternative Function Selection \nBits PF4_PWM14 (ALT_MFP3[10]) and GPF_MFP4 determine the PF.4 function.\n(PF4_PWM14, GPF_MFP4) value and function mapping is as following list.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PF5_PWM15</name>
              <description>PF.5 Pin Alternative Function Selection\nBits PF5_PWM15 (ALT_MFP3[11]) and GPF_MFP5 determine the PF.5 function.\n(PF5_PWM15, GPF_MFP5) value and function mapping is as following list.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PC0_BPWM00</name>
              <description>PC.0 Pin Alternative Function Selection\nBits PC0_BPWM00 (ALT_MFP3[12]) and GPC_MFP0 determine the PC.0 function.\n(PC0_BPWM00, GPC_MFP0) value and function mapping is as following list.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PC1_BPWM01</name>
              <description>PC.1 Pin Alternative Function Selection\nBits PC1_BPWM01 (ALT_MFP3[13]) and GPC_MFP1 determine the PC.1 function.\n(PC1_BPWM01, GPC_MFP1) value and function mapping is as following list.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PC2_BPWM02</name>
              <description>PC.2 Pin Alternative Function Selection\nBits PC2_BPWM02 (ALT_MFP3[14]) and GPC_MFP2 determine the PC.2 function.\n(PC2_BPWM02, GPC_MFP2) value and function mapping is as following list.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PC3_BPWM03</name>
              <description>PC.3 Pin Alternative Function Selection\nBits PC3_BPWM03 (ALT_MFP3[15]) and GPC_MFP3 determine the PC.3 function.\n(PC3_BPWM03, GPC_MFP3) value and function mapping is as following list.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PD15_BPWM04</name>
              <description>PD.15 Pin Alternative Function Selection \nBits PD15_BPWM04 (ALT_MFP3[16]) and GPD_MFP15 determine the PD.15 function.\n(PD15_BPWM04, GPD_MFP15) value and function mapping is as following list.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PD14_BPWM05</name>
              <description>PD.14 Pin Alternative Function Selection \nBits PD14_BPWM05 (ALT_MFP3[17]) and GPD_MFP14 determine the PD.14 function.\n(PD14_BPWM05, GPD_MFP14) value and function mapping is as following list.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PD7_BPWM10</name>
              <description>PD.7 Pin Alternative Function Selection \nBits PD7_BPWM10 (ALT_MFP3[18]) and GPD_MFP7 determine the PD.7 function.\n(PD7_BPWM10, GPD_MFP7) value and function mapping is as following list.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PD6_BPWM11</name>
              <description>PD.6 Pin Alternative Function Selection\nBits PD6_BPWM11 (ALT_MFP3[19]) and GPD_MFP6 determine the PD.6 function.\n(PD6_BPWM11, GPD_MFP6) value and function mapping is as following list.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PB8_BPWM12</name>
              <description>PB.8 Pin Alternative Function Selection\nBits PB8_BPWM12 (ALT_MFP3[20]), PB8_CLKO (ALT_MFP[29]) and GPB_MFP8 determine the PB.8 function.\n(PB8_BPWM12, PB8_CLKO, GPB_MFP8) value and function mapping is as following list.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PB12_BPWM13</name>
              <description>PB.12 Pin Alternative Function Selection\nBits PB12_BPWM13 (ALT_MFP3[21]) and GPB_MFP12 determine the PB.12 function.\n(PB12_BPWM13, GPB_MFP12) value and function mapping is as following list.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PF8_BPWM14</name>
              <description>PF.8 Pin Function Selection\nBit PF8_BPWM14 (ALT_MFP3[22]), GPF_MFP8 determines the PF.8 function.\n(PF8_BPWM14, GPF_MFP8) value and function mapping is as following list.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PB15_BPWM15</name>
              <description>PB.15 Pin Function Selection\nBits PB15_BPWM15 (ALT_MFP3[23]), PB15_T0EX (ALT_MFP[24]), PB15_TM0 (ALT_MFP2[2]) and GPB_MFP15 determine the PB.15 function.\n(PB15_BPWM15, PB15_T0EX, PB15_TM0, GPB_MFP15) value and function mapping is as following list.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PB11_PWM04</name>
              <description>PB.11 Pin Alternative Function Selection\nBits PB11_PWM04 (ALT_MFP3[24]) and GPB_MFP11 determine the PB.11 function.\n(PB11_PWM04, GPB_MFP11) value and function mapping is as following list.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PC6_PWM0BK0</name>
              <description>PC.6 Pin Alternative Function Selection\nBits PC6_PWM0BK0 (ALT_MFP3[28]), PC6_I2C0SDA (ALT_MFP4[10]) and GPC_MFP6 determine the PC.6 function.\n(PC6_PWM0BK0, PC6_I2C0SDA, GPB_MFP6) value and function mapping is as following list.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PC7_PWM0BK1</name>
              <description>PC.7 Pin Alternative Function Selection\nBits PC7_PWM0BK1 (ALT_MFP3[29]), PC7_I2C0SCL (ALT_MFP4[11]) and GPC_MFP7 determine the PC.7 function.\n(PC7_PWM0BK1, PC7_I2C0SCL, GPC_MFP7) value and function mapping is as following list.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PB3_PWM1BK0</name>
              <description>PB.3 Pin Alternative Function Selection\nBits PB3_TM3 (ALT_MFP2[5]), PB3_PWM1BK0 (ALT_MFP3[30]), PB3_T3EX (ALT_MFP[27]) and GPB_MFP3 determine the PB.3 function.\n(PB3_TM3, PB3_PWM1BK0, PB3_T3EX, GPB_MFP3) value and function mapping is as following list.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PB2_PWM1BK1</name>
              <description>PB.2 Pin Alternative Function Selection\nBits PB2_TM2 (ALT_MFP2[4]), PB2_PWM1BK1 (ALT_MFP3[31]), PB2_T2EX (ALT_MFP[26]) and GPB_MFP2 determine the PB.2 function.\n(PB2_TM2, PB2_PWM1BK1, PB2_T2EX, GPB_MFP2) value and function mapping is as following list.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ALT_MFP4</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ALT_MFP4</displayName>
          <description>Alternative Multiple Function Pin Control Register 4</description>
          <addressOffset>0x64</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PA8_UR1RTS</name>
              <description>PA.8 Pin Alternative Function Selection\nBits PA8_UR1RTS (ALT_MFP4[0]) and GPA_MFP8 determine the PA.8 function.\n(PA8_UR1RTS, GPA_MFP8) value and function mapping is as following list.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PA9_UR1CTS</name>
              <description>PA.9 Pin Alternative Function Selection\nBits PA9_UR1CTS (ALT_MFP4[1]) and GPA_MFP9 determine the PA.9 function.\n(PA9_UR1CTS, GPA_MFP9) value and function mapping is as following list.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PA3_UR3RXD</name>
              <description>PA.3 Pin Alternative Function Selection\nBits PA3_PWM11 (ALT_MFP3[7]), PA3_UR3RXD (ALT_MFP4[2]) and GPA_MFP3 determine the PA.3 function.\n(PA3_PWM11, PA3_UR3RXD, GPA_MFP3) value and function mapping is as following list.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PA2_UR3TXD</name>
              <description>PA.2 Pin Alternative Function Selection\nBits PA2_PWM10 (ALT_MFP3[6]), PA2_UR3TXD (ALT_MFP4[3]) and GPA_MFP2 determine the PA.2 function.\n(PA2_PWM10, PA2_UR3TXD, GPA_MFP2) value and function mapping is as following list.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PA5_UR3RXD</name>
              <description>PA.5 Pin Alternative Function Selection\nBits PA5_UR3RXD (ALT_MFP4[4]) and GPA_MFP5 determine the PA.5 function.\n(PA5_UR3RXD, GPA_MFP5) value and function mapping is as following list.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PA6_UR3TXD</name>
              <description>PA.6 Pin Alternative Function Selection\nBits PA6_UR3TXD (ALT_MFP4[5]) and GPA_MFP6 determine the PA.6 function.\n(PA6_UR3TXD, GPA_MFP6) value and function mapping is as following list.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PA1_UR5RXD</name>
              <description>PA.1 Pin Alternative Function Selection\nBits PA1_PWM05 (ALT_MFP3[5]), PA1_UR5RXD (ALT_MFP4[6]), PA1_I2C1SDA (ALT_MFP4[13]) and GPA_MFP1 determine the PA.1 function.\n(PA1_PWM05, PA1_UR5RXD, PA1_I2C1SDA, GPA_MFP1) value and function mapping is as following list.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PA0_UR5TXD</name>
              <description>PA.0 Pin Alternative Function Selection\nBits PA0_PWM04 (ALT_MFP3[4]), PA0_UR5TXD (ALT_MFP4[7]), PA0_I2C1SCL (ALT_MFP4[12]) and GPA_MFP0 determine the PA.0 function.\n(PA0_PWM04, PA0_UR5TXD, PA0_I2C1SCL, GPA_MFP0) value and function mapping is as following list.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PA12_UR5RXD</name>
              <description>PA.12 Pin Alternative Function Selection\nBits PA12_UR5RXD (ALT_MFP4[8]) and GPA_MFP12 determine the PA.12 function.\n(PA12_UR5RXD, GPA_MFP12) value and function mapping is as following list.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PA13_UR5TXD</name>
              <description>PA.13 Pin Alternative Function Selection\nBits PA13_UR5TXD (ALT_MFP4[9]) and GPA_MFP13 determine the PA.13 function.\n(PA13_UR5TXD, GPA_MFP13) value and function mapping is as following list.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PC6_I2C0SDA</name>
              <description>PC.6 Pin Alternative Function Selection\nBits PC6_PWM0BK0 (ALT_MFP3[28]), PC6_I2C0SDA (ALT_MFP4[10]) and GPC_MFP6 determine the PC.6 function.\n(PC6_PWM0BK0, PC6_I2C0SDA, GPC_MFP6) value and function mapping is as following list.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PC7_I2C0SCL</name>
              <description>PC.7 Pin Alternative Function Selection\nBits PC7_PWM0BK1 (ALT_MFP3[29]), PC7_I2C0SCL (ALT_MFP4[11]) and GPC_MFP7 determine the PC.7 function.\n(PC7_PWM0BK1, PC7_I2C0SCL, GPC_MFP7) value and function mapping is as following list.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PA0_I2C1SCL</name>
              <description>PA.0 Pin Alternative Function Selection\nBits PA0_PWM04 (ALT_MFP3[4]), PA0_UR5TXD (ALT_MFP4[7]), PA0_I2C1SCL (ALT_MFP4[12]) and GPA_MFP0 determine the PA.0 function.\n(PA0_PWM04, PA0_UR5TXD, PA0_I2C1SCL, GPA_MFP0) value and function mapping is as following list.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PA1_I2C1SDA</name>
              <description>PA.1 Pin Alternative Function Selection\nBits PA1_PWM05 (ALT_MFP3[5]), PA1_UR5RXD (ALT_MFP4[6]), PA1_I2C1SDA (ALT_MFP4[13]) and GPA_MFP1 determine the PA.1 function.\n(PA1_PWM05, PA1_UR5RXD, PA1_I2C1SDA, GPA_MFP1) value and function mapping is as following list.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PA7_VREF</name>
              <description>PA.7 Pin Alternative Function Selection\nBits PA7_VREF (ALT_MFP4[14]) and GPA_MFP7 determine the PA.7 function.\n(PA7_VREF, GPA_MFP7) value and function mapping is as following list.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>REGWRPROT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>REGWRPROT</displayName>
          <description>Register Write Protection Register</description>
          <addressOffset>0x100</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REGPROTDIS</name>
              <description>Register Write-Protection Disable Index (Read Only)\nThe Protected registers are:\nIPRSTC1: address 0x5000_0008\nBODCR: address 0x5000_0018\nPORCR: address 0x5000_0024\nVREFCR: address 0x5000_0028\nPWRCON: address 0x5000_0200 (bit[6] is not protected for power wake-up interrupt clear) \nAPBCLK bit[0]: address 0x5000_0208 (bit[0] is Watchdog Timer clock enable)\nCLKSEL0: address 0x5000_0210 (for HCLK and CPU STCLK clock source selection)\nCLKSEL1 bit[1:0]: address 0x5000_0214 (for Watchdog Timer clock source selection)\nNMI_SEL bit[8]: address 0x5000_0380 (for NMI_EN clock source selection)\nISPCON: address 0x5000_C000 (Flash ISP Control register)\nISPTRG: address 0x5000_C010 (ISP Trigger Control register)\nFATCON: address 0x5000_C018\nWTCR: address 0x4000_4000\nWTCRALT: address 0x4000_4004\nPWM_CTL0: address 0x4004_0000, 0x4014_0000\nPWM_DTCTL0_1: address 0x4004_0070, 0x4014_0070\nPWM_DTCTL2_3: address 0x4004_0074, 0x4014_0074\nPWM_DTCTL4_5: address 0x4004_0078, 0x4014_0078\nPWM_BRKCTL0_1: address 0x4004_00C8, 0x4014_00C8\nPWM_BRKCTL2_3: address 0x4004_00CC, 0x4014_00CC\nPWM_BRKCTL4_5: address 0x4004_00D0, 0x4014_00D0\nPWM_SWBRK: address 0x4004_00DC, 0x4014_00DC\nPWM_INTEN1: address 0x4004_00E4, 0x4014_00E4\nPWM_INTSTS1: address 0x4004_00EC, 0x4014_00EC\nBPWM_CTL0: address 0x4004_4000, 0x4014_4000\nNote: The bits which are write-protected will be noted as' (Write Protect)' beside the description.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Write-protection is enabled for writing protected registers. Any write to the protected register is ignored</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Write-protection is disabled for writing protected registers</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>REGWRPROT</name>
              <description>Register Write-Protection Code (Write Only)\nSome registers have write-protection function. Writing these registers have to disable the protected function by writing the sequence value '59h', '16h', '88h' to this field. After this sequence is completed, the REGPROTDIS bit will be set to 1 and write-protection registers can be normal write.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>7</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SCS</name>
      <description>SYST_NVIC_SCS Register Map</description>
      <groupName>SYST_NVIC_SCS</groupName>
      <baseAddress>0xE000E000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x10</offset>
        <size>0xC</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x100</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x180</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x200</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x280</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x400</offset>
        <size>0x20</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0xD00</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0xD0C</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0xD1C</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>SYST_CSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYST_CSR</displayName>
          <description>SysTick Control and Status Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ENABLE</name>
              <description>System Tick Counter Enabled</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Counter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Counter will operate in a multi-shot manner</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TICKINT</name>
              <description>System Tick Interrupt Enabled</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Counting down to 0 does not cause the SysTick exception to be pended. Software can use COUNTFLAG to determine if a count to 0 has occurred</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Counting down to 0 will cause the SysTick exception to be pended. Clearing the SysTick Current Value register by a write in software will not cause SysTick to be pended</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLKSRC</name>
              <description>System Tick Clock Source Selection</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source is (optional) external reference clock</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Core clock used for SysTick</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>COUNTFLAG</name>
              <description>Returns 1 If Timer Counted To 0 Since Last Time This Register Was Read\nCOUNTFLAG is set by a count transition from 1 to 0.\nCOUNTFLAG is cleared on read or by a write to the Current Value register.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYST_RVR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYST_RVR</displayName>
          <description>SysTick Reload Value Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>RELOAD</name>
              <description>Value to load into the Current Value register when the counter reaches 0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYST_CVR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYST_CVR</displayName>
          <description>SysTick Current Value Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>CURRENT</name>
              <description>System Tick Current Value\nCurrent counter value. This is the value of the counter at the time it is sampled. The counter does not provide read-modify-write protection. The register is write-clear. A software write of any value will clear the register to 0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_ISER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_ISER</displayName>
          <description>IRQ0 ~ IRQ31 Set-enable Control Register</description>
          <addressOffset>0x100</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SETENA</name>
              <description>Interrupt Enable Register\nEnable one or more interrupts. Each bit represents an interrupt number from IRQ0 ~ IRQ31 (Vector number from 16 ~ 47).\nWrite Operation:\nRead value indicates the current enable status.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect.\nAssociated interrupt status is Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Write 1 to enable associated interrupt.\nAssociated interrupt status is Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_ICER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_ICER</displayName>
          <description>IRQ0 ~ IRQ31 Clear-enable Control Register</description>
          <addressOffset>0x180</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLRENA</name>
              <description>Interrupt Disable Control\nDisable one or more interrupts. Each bit represents an interrupt number from IRQ0 ~ IRQ31 (Vector number from 16 ~ 47).\nWrite Operation:\nRead value indicates the current enable status.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect.\nAssociated interrupt status is Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Write 1 to disable associated interrupt.\nAssociated interrupt status is Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_ISPR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_ISPR</displayName>
          <description>IRQ0 ~ IRQ31 Set-pending Control Register</description>
          <addressOffset>0x200</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SETPEND</name>
              <description>Set Interrupt Pending Register\nWrite Operation:\nRead value indicates the current pending status.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect.\nAssociated interrupt in not in pending status</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Write 1 to set pending state. Each bit represents an interrupt number from IRQ0 ~ IRQ31 (Vector number from 16 ~ 47).\nAssociated interrupt is in pending status</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_ICPR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_ICPR</displayName>
          <description>IRQ0 ~ IRQ31 Clear-pending Control Register</description>
          <addressOffset>0x280</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLRPEND</name>
              <description>Clear Interrupt Pending Register\nWrite Operation:\nRead value indicates the current pending status.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect.\nAssociated interrupt in not in pending status</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Write 1 to clear pending state. Each bit represents an interrupt number from IRQ0 ~ IRQ31 (Vector number from 16 ~ 47).\nAssociated interrupt is in pending status</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_IPR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_IPR0</displayName>
          <description>IRQ0 ~ IRQ3 Priority Control Register</description>
          <addressOffset>0x400</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_0</name>
              <description>Priority Of IRQ0\n'0' denotes the highest priority and '3' denotes the lowest priority.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_1</name>
              <description>Priority Of IRQ1\n'0' denotes the highest priority and '3' denotes the lowest priority.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_2</name>
              <description>Priority Of IRQ2\n'0' denotes the highest priority and '3' denotes the lowest priority.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_3</name>
              <description>Priority Of IRQ3\n'0' denotes the highest priority and '3' denotes the lowest priority.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_IPR1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_IPR1</displayName>
          <description>IRQ4 ~ IRQ7 Priority Control Register</description>
          <addressOffset>0x404</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_4</name>
              <description>Priority Of IRQ4\n'0' denotes the highest priority and '3' denotes the lowest priority.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_5</name>
              <description>Priority Of IRQ5\n'0' denotes the highest priority and '3' denotes the lowest priority.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_6</name>
              <description>Priority Of IRQ6\n'0' denotes the highest priority and '3' denotes the lowest priority.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_7</name>
              <description>Priority Of IRQ7\n'0' denotes the highest priority and '3' denotes the lowest priority.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_IPR2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_IPR2</displayName>
          <description>IRQ8 ~ IRQ11 Priority Control Register</description>
          <addressOffset>0x408</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_8</name>
              <description>Priority Of IRQ8\n'0' denotes the highest priority and '3' denotes the lowest priority.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_9</name>
              <description>Priority Of IRQ9\n'0' denotes the highest priority and '3' denotes the lowest priority.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_10</name>
              <description>Priority Of IRQ10\n'0' denotes the highest priority and '3' denotes the lowest priority.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_11</name>
              <description>Priority Of IRQ11\n'0' denotes the highest priority and '3' denotes the lowest priority.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_IPR3</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_IPR3</displayName>
          <description>IRQ12 ~ IRQ15 Priority Control Register</description>
          <addressOffset>0x40C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_12</name>
              <description>Priority Of IRQ12\n'0' denotes the highest priority and '3' denotes the lowest priority.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_13</name>
              <description>Priority Of IRQ13\n'0' denotes the highest priority and '3' denotes the lowest priority</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_14</name>
              <description>Priority Of IRQ14\n'0' denotes the highest priority and '3' denotes the lowest priority.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_15</name>
              <description>Priority Of IRQ15\n'0' denotes the highest priority and '3' denotes the lowest priority.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_IPR4</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_IPR4</displayName>
          <description>IRQ16 ~ IRQ19 Priority Control Register</description>
          <addressOffset>0x410</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_16</name>
              <description>Priority Of IRQ16\n'0' denotes the highest priority and '3' denotes the lowest priority.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_17</name>
              <description>Priority Of IRQ17\n'0' denotes the highest priority and '3' denotes the lowest priority.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_18</name>
              <description>Priority Of IRQ18\n'0' denotes the highest priority and '3' denotes the lowest priority.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_19</name>
              <description>Priority Of IRQ19\n'0' denotes the highest priority and '3' denotes the lowest priority.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_IPR5</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_IPR5</displayName>
          <description>IRQ20 ~ IRQ23 Priority Control Register</description>
          <addressOffset>0x414</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_20</name>
              <description>Priority Of IRQ20\n'0' denotes the highest priority and '3' denotes the lowest priority.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_21</name>
              <description>Priority Of IRQ21\n'0' denotes the highest priority and '3' denotes the lowest priority</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_22</name>
              <description>Priority Of IRQ22\n'0' denotes the highest priority and '3' denotes the lowest priority.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_23</name>
              <description>Priority Of IRQ23\n'0' denotes the highest priority and '3' denotes the lowest priority.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_IPR6</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_IPR6</displayName>
          <description>IRQ24 ~ IRQ27 Priority Control Register</description>
          <addressOffset>0x418</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_24</name>
              <description>Priority Of IRQ24\n'0' denotes the highest priority and '3' denotes the lowest priority.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_25</name>
              <description>Priority Of IRQ25\n'0' denotes the highest priority and '3' denotes the lowest priority.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_26</name>
              <description>Priority Of IRQ26\n'0' denotes the highest priority and '3' denotes the lowest priority.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_27</name>
              <description>Priority Of IRQ27\n'0' denotes the highest priority and '3' denotes the lowest priority.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_IPR7</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_IPR7</displayName>
          <description>IRQ28 ~ IRQ31 Priority Control Register</description>
          <addressOffset>0x41C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_28</name>
              <description>Priority Of IRQ28\n'0' denotes the highest priority and '3' denotes the lowest priority.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_29</name>
              <description>Priority Of IRQ29\n'0' denotes the highest priority and '3' denotes the lowest priority.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_30</name>
              <description>Priority Of IRQ30\n'0' denotes the highest priority and '3' denotes the lowest priority.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_31</name>
              <description>Priority Of IRQ31\n'0' denotes the highest priority and '3' denotes the lowest priority.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CPUID</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CPUID</displayName>
          <description>CPUID Register</description>
          <addressOffset>0xD00</addressOffset>
          <access>read-only</access>
          <resetValue>0x410CC200</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REVISION</name>
              <description>Revision Number\nRead as 0x0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PARTNO</name>
              <description>Part Number Of The Processor\nRead as 0xC20.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PART</name>
              <description>Architecture Of The Processor\nRead as 0xC for ARMv6-M parts.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>IMPLEMENTER</name>
              <description>Implementer Code Assigned By ARM</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ICSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ICSR</displayName>
          <description>Interrupt Control and State Register</description>
          <addressOffset>0xD04</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VECTACTIVE</name>
              <description>Contains The Active Exception Number</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Thread mode</description>
                    <value>0</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>VECTPENDING</name>
              <description>Indicates The Exception Number Of The Highest Priority Pending Enabled Exception:</description>
              <bitOffset>12</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No pending exceptions</description>
                    <value>0</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRPENDING</name>
              <description>Interrupt Pending Flag, Excluding NMI And Faults:\nThis bit is read only.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt not pending</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt pending</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRPREEMPT</name>
              <description>If Set, A Pending Exception Will Be Serviced On Exit From The Debug Halt State\nThis bit is read only.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PENDSTCLR</name>
              <description>SysTick Exception Clear-Pending Bit\nWrite Operation:\nThis is a write only bit. When you want to clear PENDST bit, you must 'write 0 to PENDSTSET and write 1 to PENDSTCLR' at the same time.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Removes the pending state from the SysTick exception</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PENDSTSET</name>
              <description>SysTick Exception Set-Pending Bit\nWrite Operation:</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect.\nSysTick exception is not pending</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Changes SysTick exception state to pending.\nSysTick exception is pending</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PENDSVCLR</name>
              <description>PendSV Clear-Pending Bit\nWrite Operation:\nThis is a write only bit. When you want to clear PENDSV bit, you must 'write 0 to PENDSVSET and write 1 to PENDSVCLR' at the same time.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Removes the pending state from the PendSV exception</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PENDSVSET</name>
              <description>PendSV Set-Pending Bit\nWrite Operation:\nNote: Writing 1 to this bit is the only way to set the PendSV exception state to pending.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect.\nPendSV exception is not pending</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Changes PendSV exception state to pending.\nPendSV exception is pending</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>NMIPENDSET</name>
              <description>NMI Set-Pending Bit\nWrite Operation:\nBecause NMI is the highest-priority exception, normally the processor enters the NMI exception handler as soon as it detects a write of 1 to this bit. Entering the handler then clears this bit to 0. This means a read of this bit by the NMI exception handler returns 1 only if the NMI signal is reasserted while the processor is executing that handler.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect.\nNMI exception not pending</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Changes NMI exception state to pending.\nNMI exception pending</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>AIRCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>AIRCR</displayName>
          <description>Application Interrupt and Reset Control Register</description>
          <addressOffset>0xD0C</addressOffset>
          <access>read-write</access>
          <resetValue>0xFA050000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VECTCLRACTIVE</name>
              <description>Exception Active Status Clear Bit\nReserved for debug use. When writing to the register, user must write 0 to this bit, otherwise behavior is unpredictable.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SYSRESETREQ</name>
              <description>System Reset Request\nWriting this bit 1 will cause a reset signal to be asserted to the chip to indicate a reset is requested.\nThe bit is a write only bit and self-clears as part of the reset sequence.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VECTORKEY</name>
              <description>Register Access Key\nWrite Operation:\nWhen writing to this register, the VECTORKEY field need to be set to 0x05FA, otherwise the write operation would be ignored. The VECTORKEY filed is used to prevent accidental write to this register from resetting the system or clearing of the exception status.\nRead Operation:\nRead as 0xFA05.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SCR</displayName>
          <description>System Control Register</description>
          <addressOffset>0xD10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SLEEPONEXIT</name>
              <description>Sleep-On-Exit Enable Control\nThis bit indicates sleep-on-exit when returning from Handler mode to Thread mode.\nSetting this bit to 1 enables an interrupt driven application to avoid returning to an empty main application.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Do not sleep when returning to Thread mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enter Sleep or Deep Sleep when returning from ISR to Thread mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLEEPDEEP</name>
              <description>Processor Deep Sleep And Sleep Mode Selection\nControls whether the processor uses sleep or deep sleep as its low power mode:</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Sleep mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Deep Sleep mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SEVONPEND</name>
              <description>Send Event On Pending Bit\nWhen an event or interrupt enters pending state, the event signal wakes up the processor from WFE. If the processor is not waiting for an event, the event is registered and affects the next WFE.\nThe processor also wakes up on execution of an SEV instruction or an external event.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Only enabled interrupts or events can wake-up the processor, disabled interrupts are excluded</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled events and all interrupts, including disabled interrupts, can wake-up the processor</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SHPR2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SHPR2</displayName>
          <description>System Handler Priority Register 2</description>
          <addressOffset>0xD1C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_11</name>
              <description>Priority Of System Handler 11 - SVCall\n'0' denotes the highest priority and '3' denotes the lowest priority.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SHPR3</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SHPR3</displayName>
          <description>System Handler Priority Register 3</description>
          <addressOffset>0xD20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_14</name>
              <description>Priority Of System Handler 14 - PendSV\n'0' denotes the highest priority and '3' denotes the lowest priority.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_15</name>
              <description>Priority Of System Handler 15 - SysTick\n'0' denotes the highest priority and '3' denotes the lowest priority.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>INT</name>
      <description>INT Register Map</description>
      <groupName>INT</groupName>
      <baseAddress>0x50000300</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x8C</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>IRQ0_SRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IRQ0_SRC</displayName>
          <description>IRQ0 (BOD) Interrupt Source Identity</description>
          <addressOffset>0x0</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>INT_SRC</name>
              <description>Interrupt Source\nDefine the interrupt sources for interrupt event.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ1_SRC</name>
          <displayName>IRQ1_SRC</displayName>
          <description>IRQ1 (WDT) Interrupt Source Identity</description>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ2_SRC</name>
          <displayName>IRQ2_SRC</displayName>
          <description>IRQ2 (EINT0) Interrupt Source Identity</description>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ3_SRC</name>
          <displayName>IRQ3_SRC</displayName>
          <description>IRQ3 (EINT1) Interrupt Source Identity</description>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ4_SRC</name>
          <displayName>IRQ4_SRC</displayName>
          <description>IRQ4 (GPA/B) Interrupt Source Identity</description>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ5_SRC</name>
          <displayName>IRQ5_SRC</displayName>
          <description>IRQ5 (GPC/D/E/F) Interrupt Source Identity</description>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ6_SRC</name>
          <displayName>IRQ6_SRC</displayName>
          <description>Reserved.</description>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ7_SRC</name>
          <displayName>IRQ7_SRC</displayName>
          <description>Reserved.</description>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ8_SRC</name>
          <displayName>IRQ8_SRC</displayName>
          <description>IRQ8 (TMR0) Interrupt Source Identity</description>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ9_SRC</name>
          <displayName>IRQ9_SRC</displayName>
          <description>IRQ9 (TMR1) Interrupt Source Identity</description>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ10_SRC</name>
          <displayName>IRQ10_SRC</displayName>
          <description>IRQ10 (TMR2) Interrupt Source Identity</description>
          <addressOffset>0x28</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ11_SRC</name>
          <displayName>IRQ11_SRC</displayName>
          <description>IRQ11 (TMR3) Interrupt Source Identity</description>
          <addressOffset>0x2C</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ12_SRC</name>
          <displayName>IRQ12_SRC</displayName>
          <description>IRQ12 (UART0/2) Interrupt Source Identity</description>
          <addressOffset>0x30</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ13_SRC</name>
          <displayName>IRQ13_SRC</displayName>
          <description>IRQ13 (UART1) Interrupt Source Identity</description>
          <addressOffset>0x34</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ14_SRC</name>
          <displayName>IRQ14_SRC</displayName>
          <description>IRQ14 (SPI0) Interrupt Source Identity</description>
          <addressOffset>0x38</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ15_SRC</name>
          <displayName>IRQ15_SRC</displayName>
          <description>IRQ15 (UART3) Interrupt Source Identity</description>
          <addressOffset>0x3C</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ16_SRC</name>
          <displayName>IRQ16_SRC</displayName>
          <description>IRQ16 (UART4) Interrupt Source Identity</description>
          <addressOffset>0x40</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ17_SRC</name>
          <displayName>IRQ17_SRC</displayName>
          <description>IRQ17 (UART5) Interrupt Source Identity</description>
          <addressOffset>0x44</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ18_SRC</name>
          <displayName>IRQ18_SRC</displayName>
          <description>IRQ18 (I2C0) Interrupt Source Identity</description>
          <addressOffset>0x48</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ19_SRC</name>
          <displayName>IRQ19_SRC</displayName>
          <description>IRQ19 (I2C1) Interrupt Source Identity</description>
          <addressOffset>0x4C</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ20_SRC</name>
          <displayName>IRQ20_SRC</displayName>
          <description>IRQ20 (CAN0) Interrupt Source Identity</description>
          <addressOffset>0x50</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ21_SRC</name>
          <displayName>IRQ21_SRC</displayName>
          <description>Reserved.</description>
          <addressOffset>0x54</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ22_SRC</name>
          <displayName>IRQ22_SRC</displayName>
          <description>IRQ22 (PWM0) Interrupt Source Identity</description>
          <addressOffset>0x58</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ23_SRC</name>
          <displayName>IRQ23_SRC</displayName>
          <description>IRQ23 (PWM1) Interrupt Source Identity</description>
          <addressOffset>0x5C</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ24_SRC</name>
          <displayName>IRQ24_SRC</displayName>
          <description>IRQ24 (BPWM0) Interrupt Source Identity</description>
          <addressOffset>0x60</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ25_SRC</name>
          <displayName>IRQ25_SRC</displayName>
          <description>IRQ25 (BPWM1) Interrupt Source Identity</description>
          <addressOffset>0x64</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ26_SRC</name>
          <displayName>IRQ26_SRC</displayName>
          <description>IRQ26 (BRAKE0) Interrupt Source Identity</description>
          <addressOffset>0x68</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ27_SRC</name>
          <displayName>IRQ27_SRC</displayName>
          <description>IRQ27 (BRAKE1) Interrupt Source Identity</description>
          <addressOffset>0x6C</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ28_SRC</name>
          <displayName>IRQ28_SRC</displayName>
          <description>IRQ28 (PWRWU) Interrupt Source Identity</description>
          <addressOffset>0x70</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ29_SRC</name>
          <displayName>IRQ29_SRC</displayName>
          <description>IRQ29 (ADC) Interrupt Source Identity</description>
          <addressOffset>0x74</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ30_SRC</name>
          <displayName>IRQ30_SRC</displayName>
          <description>IRQ30 (CKD) Interrupt Source Identity</description>
          <addressOffset>0x78</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ31_SRC</name>
          <displayName>IRQ31_SRC</displayName>
          <description>Reserved.</description>
          <addressOffset>0x7C</addressOffset>
       </register>
       <register>
          <name>NMI_SEL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NMI_SEL</displayName>
          <description>NMI Source Interrupt Select Control Register</description>
          <addressOffset>0x80</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NMI_SEL</name>
              <description>NMI Interrupt Source Selection\nThe NMI interrupt to Cortex-M0 can be selected from one of the peripheral interrupt by setting NMI_SEL.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NMI_EN</name>
              <description>NMI Interrupt Enable Control (Write Protect)\nNote: This bit is the protected bit, and programming it needs to write '59h', '16h', and '88h' to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>NMI interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>NMI interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>MCU_IRQ</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>MCU_IRQ</displayName>
          <description>MCU Interrupt Request Source Register</description>
          <addressOffset>0x84</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MCU_IRQ</name>
              <description>MCU IRQ Source Register\nThe MCU_IRQ collects all the interrupts from the peripherals and generates the synchronous interrupt to Cortex-M0. There are two modes to generate interrupt to Cortex-M0, the normal mode and test mode.\nThe MCU_IRQ collects all interrupts from each peripheral and synchronizes them and interrupts the Cortex-M0.\nWhen the MCU_IRQ[n] is 0: Set MCU_IRQ[n] 1 will generate an interrupt to Cortex-M0 NVIC[n].\nWhen the MCU_IRQ[n] is 1 (mean an interrupt is assert), setting 1 to the MCU_IRQ[n] 1 will clear the interrupt and setting MCU_IRQ[n] 0: has no effect.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>MCU_IRQCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>MCU_IRQCR</displayName>
          <description>MCU Interrupt Request Control Register</description>
          <addressOffset>0x88</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FAST_IRQ</name>
              <description>Fast IRQ Latency Enable Control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>MCU IRQ latency is fixed at 13 clock cycles of HCLK, MCU will enter IRQ handler after this fixed latency when interrupt happened</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>MCU IRQ latency will not fixed, MCU will enter IRQ handler as soon as possible when interrupt happened</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>CLK</name>
      <description>CLK Register Map</description>
      <groupName>CLK</groupName>
      <baseAddress>0x50000200</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x28</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x30</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x70</offset>
        <size>0x10</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>PWRCON</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWRCON</displayName>
          <description>System Power-down Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000010</resetValue>
          <resetMask>0xFFFFFFF0</resetMask>
          <fields>
            <field>
              <name>XTL12M_EN</name>
              <description>4~24 MHz External High Speed Crystal Oscillator (HXT) Enable Control (Write Protect)\nThe bit default value is set by flash controller user configuration register CONFIG0 [26:24]. When the default clock source is from 4~24 MHz external high speed crystal oscillator, this  bit is set to 1 automatically.\nNote: This bit is the protected bit, and programming it needs to write '59h', '16h', and '88h' to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>4 ~ 24 MHz external high speed crystal oscillator (HXT) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>4 ~ 24 MHz external high speed crystal oscillator (HXT) Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>OSC22M_EN</name>
              <description>22.1184 MHz Internal High Speed RC Oscillator (HIRC) Enable Control (Write Protect)\nNote: This bit is the protected bit, and programming it needs to write '59h', '16h', and '88h' to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>22.1184 MHz internal high speed RC oscillator (HIRC) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>22.1184 MHz internal high speed RC oscillator (HIRC) Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>OSC10K_EN</name>
              <description>10 KHz Internal Low Speed RC Oscillator (LIRC) Enable Control (Write Protect)\nNote: This bit is the protected bit, and programming it needs to write '59h', '16h', and '88h' to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>10 kHz internal low speed RC oscillator (LIRC) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>10 kHz internal low speed RC oscillator (LIRC) Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_WU_DLY</name>
              <description>Wake-Up Delay Counter Enable Control (Write Protect)\nWhen the chip wakes up from Power-down mode, the clock control will delay certain clock cycles to wait system clock stable.\nThe delayed clock cycle is 4096 clock cycles when chip works at 4~24 MHz external high speed crystal oscillator (HXT), and 256 clock cycles when chip works at 22.1184 MHz internal high speed oscillator (HIRC).\nNote: This bit is the protected bit, and programming it needs to write '59h', '16h', and '88h' to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock cycles delay Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock cycles delay Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_WU_INT_EN</name>
              <description>Power-Down Mode Wake-Up Interrupt Enable Control (Write Protect)\nNote1: The interrupt will occur when both PD_WU_STS and PD_WU_INT_EN are high.\nNote2: This bit is the protected bit, and programming it needs to write '59h', '16h', and '88h' to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Power-down mode wake-up interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Power-down mode wake-up interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_WU_STS</name>
              <description>Power-Down Mode Wake-Up Interrupt Status\nSet by 'Power-down wake-up event', it indicates that resume from Power-down mode'.\nThe flag is set if the GPIO, UART, WDT, I2C, TIMER, CAN, or BOD wake-up occurred.\nWrite 1 to clear the bit to 0.\nNote: This bit is working only if PD_WU_INT_EN (PWRCON[5]) set to 1.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWR_DOWN_EN</name>
              <description>System Power-Down Enable Control (Write Protect)\nWhen this bit is set to 1, Power-down mode is enabled and chip Power-down behavior will depends on the PD_WAIT_CPU bit\n(a) If the PD_WAIT_CPU is 0, the chip enters Power-down mode immediately after the PWR_DOWN_EN bit set.\n(b) if the PD_WAIT_CPU is 1, the chip keeps active till the CPU sleep mode is also active and then the chip enters Power-down mode (recommend)\nWhen chip wakes up from Power-down mode, this bit is cleared by hardware. User needs to set this bit again for next Power-down.\nIn Power-down mode, 4~24 MHz external high speed crystal oscillator (HXT) and the 22.1184 MHz internal high speed RC oscillator (HIRC) will be disabled in this mode, but the 10 kHz internal low speed RC oscillator (LIRC) is not controlled by Power-down mode.\nIn Power- down mode, the PLL and system clock are disabled, and ignored the clock source selection. The clocks of peripheral are not controlled by Power-down mode, if the peripheral clock source is from the 10 kHz internal low speed RC oscillator (LIRC).\nNote: This bit is the protected bit, and programming it needs to write '59h', '16h', and '88h' to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Chip operating normally or chip in Idle mode because of WFI command</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Chip enters Power-down mode instantly or waits CPU sleep command WFI</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_WAIT_CPU</name>
              <description>Power-Down Entry Condition Control (Write Protect)\nNote: This bit is the protected bit, and programming it needs to write '59h', '16h', and '88h' to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Chip enters Power-down mode when the PWR_DOWN_EN bit is set to 1</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Chip enters Power- down mode when the both PD_WAIT_CPU and PWR_DOWN_EN bits are set to 1 and CPU runs WFI instruction</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>AHBCLK</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>AHBCLK</displayName>
          <description>AHB Devices Clock Enable Control Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000005</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ISP_EN</name>
              <description>Flash ISP Controller Clock Enable Control</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Flash ISP peripherial clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Flash ISP peripherial clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>APBCLK</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>APBCLK</displayName>
          <description>APB Devices Clock Enable Control Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFF0</resetMask>
          <fields>
            <field>
              <name>WDT_EN</name>
              <description>Watchdog Timer Clock Enable Control (Write Protect)\nNote: This bit is the protected bit, and programming it needs to write '59h', '16h', and '88h' to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Watchdog Timer clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Watchdog Timer clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR0_EN</name>
              <description>Timer0 Clock Enable Control</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer0 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer0 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR1_EN</name>
              <description>Timer1 Clock Enable Control</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer1 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer1 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR2_EN</name>
              <description>Timer2 Clock Enable Control</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer2 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer2 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR3_EN</name>
              <description>Timer3 Clock Enable Control</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer3 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer3 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FDIV_EN</name>
              <description>Frequency Divider Output Clock Enable Control</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>FDIV clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>FDIV clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C0_EN</name>
              <description>I2C0 Clock Enable Control</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I2C0 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2C0 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C1_EN</name>
              <description>I2C1 Clock Enable Control</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I2C1 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2C1 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI0_EN</name>
              <description>SPI0 Clock Enable Control</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPI0 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI0 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>UART0_EN</name>
              <description>UART0 Clock Enable Control</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UART0 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART0 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>UART1_EN</name>
              <description>UART1 Clock Enable Control</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UART1 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART1 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>UART2_EN</name>
              <description>UART2 Clock Enable Control</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UART2 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART2 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAN0_EN</name>
              <description>CAN Bus Controller-0 Clock Enable Control</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>CAN0 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CAN0 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_EN</name>
              <description>Analog-Digital-Converter (ADC) Clock Enable Control</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ADC clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ADC clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CLKSTATUS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CLKSTATUS</displayName>
          <description>Clock Status Monitor Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFF00</resetMask>
          <fields>
            <field>
              <name>XTL12M_STB</name>
              <description>4~24 MHz External High Speed Crystal Oscillator (HXT) Clock Source Stable Flag (Read Only)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>4~24 MHz external high speed crystal oscillator (HXT) clock is not stable or disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>4~24 MHz external high speed crystal oscillator (HXT) clock is stable and enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>PLL_STB</name>
              <description>Internal PLL Clock Source Stable Flag (Read Only)</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Internal PLL clock is not stable or disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Internal PLL clock is stable in normal mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>OSC10K_STB</name>
              <description>Internal 10 KHz Low Speed Oscillator (LIRC) Clock Source Stable Flag (Read Only)</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>10 kHz internal low speed RC oscillator (LIRC) clock is not stable or disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>10 kHz internal low speed RC oscillator (LIRC) clock is stable and enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>OSC22M_STB</name>
              <description>22.1184 MHz Internal High Speed RC Oscillator (HIRC) Clock Source Stable Flag (Read Only)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>22.1184 MHz internal high speed RC oscillator (HIRC) clock is not stable or disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>22.1184 MHz internal high speed RC oscillator (HIRC) clock is stable and enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>CLK_SW_FAIL</name>
              <description>Clock Switching Fail Flag (Read Only)\nThis bit is an index that if current system clock source is match as user defined at HCLK_S (CLKSEL[2:0]). When user switchs system clock, the system clock source will keep old clock until the new clock is stable. During the period that waiting new clock stable, this bit will be an index shows system clock source is not match as user wanted.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock switching success</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock switching failure</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CLKSEL0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CLKSEL0</displayName>
          <description>Clock Source Select Control Register 0</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000030</resetValue>
          <resetMask>0xFFFFFFF0</resetMask>
          <fields>
            <field>
              <name>HCLK_S</name>
              <description>HCLK Clock Source Select (Write Protect)\nBefore clock switching, the related clock sources (both pre-select and new-select) must be enabled\nThe 3-bit default value is reloaded from the value of CFOSC (CONFIG0[26:24]) in user configuration register of Flash controller by any reset. Therefore the default value is either 000b or 111b.\nThese bits are protected bit. It means programming this bit needs to write '59h', '16h', '88h' to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.\nNote: This bit is the protected bit, and programming it needs to write '59h', '16h', and '88h' to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from 4~24 MHz external high speed crystal oscillator (HXT)</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved.</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Clock source from PLL</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Clock source from 10 kHz internal low speed RC oscillator (LIRC)</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Clock source from 22.1184 MHz internalhigh speed RC oscillator (HIRC)</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>STCLK_S</name>
              <description>Cortex-M0 SysTick Clock Source Select (Write Protect)</description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from 4~24 MHz external high speed crystal oscillator (HXT)</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved.</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Clock source from 4~24 MHz external high speed crystal oscillator (HXT)/2</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Clock source from HCLK/2</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Clock source from 22.1184 MHz internal high speed RC oscillator (HIRC)/2</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CLKSEL1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CLKSEL1</displayName>
          <description>Clock Source Select Control Register 1</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WDT_S</name>
              <description>Watchdog Timer Clock Source Select (Write Protect)\nNote: This bit is the protected bit, and programming it needs to write '59h', '16h', and '88h' to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Reserved.</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved.</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Clock source from HCLK/2048</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Clock source from 10 kHz internal low speed RC oscillator (LIRC)</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_S</name>
              <description>ADC Clock Source Select</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from 4~24 MHz external high speed crystal oscillator (HXT)</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from PLL</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Clock source from HCLK</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Clock source from 22.1184 MHz internal high speed RC oscillator (HIRC)</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI0_S</name>
              <description>SPI0 Clock Source Selection</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from PLL</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from HCLK</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR0_S</name>
              <description>TIMER0 Clock Source Selection</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from 4~24 MHz external high speed crystal oscillator (HXT)</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved.</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Clock source from HCLK</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Clock source from external trigger</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Clock source from 10 kHz internal low speed RC oscillator (LIRC)</description>
                    <value>#101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Clock source from 22.1184 MHz internal high speed RC oscillator (HIRC)</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR1_S</name>
              <description>TIMER1 Clock Source Selection</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from 4~24 MHz external high speed crystal oscillator (HXT)</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved.</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Clock source from HCLK</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Clock source from external trigger</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Clock source from 10 kHz internal low speed RC oscillator (LIRC)</description>
                    <value>#101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Clock source from 22.1184 MHz internal high speed RC oscillator (HIRC)</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR2_S</name>
              <description>TIMER2 Clock Source Selection</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from external 4~24 MHz high speed crystal oscillator (HXT)</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved.</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Clock source from HCLK</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Clock source from external trigger</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Clock source from 10 kHz internal low speed RC oscillator (LIRC)</description>
                    <value>#101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Clock source from 22.1184 MHz internal high speed RC oscillator (HIRC)</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR3_S</name>
              <description>TIMER3 Clock Source Selection</description>
              <bitOffset>20</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from 4~24 MHz external high speed crystal oscillator (HXT)</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved.</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Clock source from HCLK</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Clock source from external trigger</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Clock source from 10 kHz internal low speed RC oscillator (LIRC)</description>
                    <value>#101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Clock source from 22.1184 MHz internal high speed RC oscillator (HIRC)</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_S</name>
              <description>UART Clock Source Selection</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from 4~24 MHz external high speed crystal oscillator (HXT)</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from PLL</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Clock source from 22.1184 MHz internal high speed RC oscillator (HIRC)</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CLKDIV</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CLKDIV</displayName>
          <description>Clock Divider Number Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HCLK_N</name>
              <description>HCLK Clock Divide Number From HCLK Clock Source</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_N</name>
              <description>UART Clock Divide Number From UART Clock Source</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_N</name>
              <description>ADC Clock Divide Number From ADC Clock Source</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CLKSEL2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CLKSEL2</displayName>
          <description>Clock Source Select Control Register 2</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-write</access>
          <resetValue>0x000200FF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FRQDIV_S</name>
              <description>Clock Divider Clock Source Selection</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from 4~24 MHz external high speed crystal oscillator clock</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved.</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Clock source from HCLK</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Clock source from 22.1184 MHz internal high speed RC oscillator clock</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WWDT_S</name>
              <description>Window Watchdog Timer Clock Source Selection</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Clock source from HCLK/2048 clock</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Clock source from 10 kHz internal low speed RC oscillator clock</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PLLCON</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PLLCON</displayName>
          <description>PLL Control Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x0005C22E</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FB_DV</name>
              <description>PLL Feedback Divider Control Bits\nRefer to the formulas below the table.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IN_DV</name>
              <description>PLL Input Divider Control Bits\nRefer to the formulas below the table.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OUT_DV</name>
              <description>PLL Output Divider Control Bits\nRefer to the formulas below the table.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PD</name>
              <description>Power-Down Mode\nIf the PWR_DOWN_EN bit is set to 1 in PWRCON register, the PLL will enter Power-down mode too.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PLL is in Normal mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PLL is in Power-down mode (default)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BP</name>
              <description>PLL Bypass Control</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PLL is in Normal mode (default)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PLL clock output is same as PLL source clock input</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>OE</name>
              <description>PLL OE (FOUT Enable) Pin Control</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PLL FOUT Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PLL FOUT is fixed low</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PLL_SRC</name>
              <description>PLL Source Clock Selection</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PLL source clock from 4~24 MHz external high speed crystal oscillator</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PLL source clock from 22.1184 MHz internal high speed RC oscillator</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>FRQDIV</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>FRQDIV</displayName>
          <description>Frequency Divider Control Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FSEL</name>
              <description>Divider Output Frequency Selection Bits\nThe formula of output frequency is\nFin is the input clock frequency.\nFout is the frequency of divider output clock.\nN is the 4-bit value of FSEL[3:0].</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIVIDER_EN</name>
              <description>Frequency Divider Enable Control</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Frequency divider function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Frequency divider function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DIVIDER1</name>
              <description>Frequency Divider One Enable Control</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Frequency divider will output clock with source frequency divided by FSEL</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Frequency divider will output clock with source frequency</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>APBCLK1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>APBCLK1</displayName>
          <description>APB Devices Clock Enable Control Register 1</description>
          <addressOffset>0x30</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>UART3_EN</name>
              <description>UART3 Clock Enable Control</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UART3 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART3 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>UART4_EN</name>
              <description>UART4 Clock Enable Control</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UART4 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART4 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>UART5_EN</name>
              <description>UART5 Clock Enable Control</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UART5 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART5 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM0_EN</name>
              <description>PWM0 Clock Enable Control</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM0 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM0 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM1_EN</name>
              <description>PWM1 Clock Enable Control</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM1 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM1 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BPWM0_EN</name>
              <description>BPWM0 Clock Enable Control</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>BPWM0 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>BPWM0 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BPWM1_EN</name>
              <description>BPWM1 Clock Enable Control</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>BPWM1 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>BPWM1 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CLKSEL3</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CLKSEL3</displayName>
          <description>Clock Source Select Control Register 3</description>
          <addressOffset>0x34</addressOffset>
          <access>read-write</access>
          <resetValue>0x000F003F</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PWM0_S</name>
              <description>PWM0 Clock Source Selection\nThe Engine clock source of PWM0 is defined by PWM0_S.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from PLL</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from PCLK</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM1_S</name>
              <description>PWM1 Clock Source Selection\nThe Engine clock source of PWM1 is defined by PWM1_S.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from PLL</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from PCLK</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BPWM0_S</name>
              <description>BPWM0 Clock Source Selection\nThe Engine clock source of BPWM0 is defined by BPWM0_S.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from PLL</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from PCLK</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BPWM1_S</name>
              <description>BPWM1 Clock Source Selection\nThe Engine clock source of BPWM1 is defined by BPWM1_S.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from PLL</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from PCLK</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CLKDCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CLKDCTL</displayName>
          <description>Clock Fail Detector Control Register</description>
          <addressOffset>0x70</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HXTFDEN</name>
              <description>HXT Clock Fail Detector Enable Control</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>HXT clock Fail detector Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>HXT clock Fail detector Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>HXTFIEN</name>
              <description>HXT Clock Fail Interrupt Enable Control</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>HXT clock Fail interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>HXT clock Fail interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>HXTFQDEN</name>
              <description>HXT Clock Frequency Monitor Enable Control</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>HXT clock frequency monitor Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>HXT clock frequency monitor Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>HXTFQIEN</name>
              <description>HXT Clock Frequency Monitor Interrupt Enable Control</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>HXT clock frequency monitor fail interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>HXT clock frequency monitor fail interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CLKDSTS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CLKDSTS</displayName>
          <description>Clock Fail Detector Status Register</description>
          <addressOffset>0x74</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HXTFIF</name>
              <description>HXT Clock Fail Interrupt Flag</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>HXT clock normal</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>HXT clock stop (write '1' to clear)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>HXTFQIF</name>
              <description>HXT Clock Frequency Monitor Interrupt Flag</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>HXT clock normal</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>HXT clock frequency abnormal (write '1' to clear)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CDUPB</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CDUPB</displayName>
          <description>Clock Frequency Detector Upper Boundary Register</description>
          <addressOffset>0x78</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>UPERBD</name>
              <description>HXT Clock Frequency Detector Upper Boundary\nThe bits define the high value of frequency monitor window.\nWhen HXT frequency monitor value higher than this register, the HXT frequency detect fail interrupt flag will set to 1.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CDLOWB</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CDLOWB</displayName>
          <description>Clock Frequency Detector Lower Boundary Register</description>
          <addressOffset>0x7C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LOWERBD</name>
              <description>HXT Clock Frequency Detector Lower Boundary\nThe bits define the low value of frequency monitor window.\nWhen HXT frequency monitor values lower than this register, the HXT frequency detect fail interrupt flag will set to 1.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>FMC</name>
      <description>FMC Register Map</description>
      <groupName>FMC</groupName>
      <baseAddress>0x5000C000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1C</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x40</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>ISPCON</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ISPCON</displayName>
          <description>ISP Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ISPEN</name>
              <description>ISP Enable Control (Write Protect )\nISP function enable bit. Set this bit to enable ISP function.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ISP function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ISP function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BS</name>
              <description>Boot Select (Write Protect )\nSet/clear this bit to select next booting from LDROM/APROM, respectively. This bit also functions as chip booting status flag, which can be used to check where chip booted from. This bit is initiated with the inversed value of CBS in CONFIG0 after any reset is happened except CPU reset (RSTS_CPU is 1) or system reset (RSTS_SYS) is happened.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Boot from APROM</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Boot from LDROM</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>APUEN</name>
              <description>APROM Update Enable Control (Write Protect)</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>APROM cannot be updated when chip runs in APROM</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>APROM can be updated when chip runs in APROM</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CFGUEN</name>
              <description>Enable Config Update By ISP (Write Protect)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ISP update config-bit Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ISP update config-bit Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LDUEN</name>
              <description>LDROM Update Enable Control (Write Protect)</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LDROM cannot be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LDROM can be updated when chip runs in APROM</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISPFF</name>
              <description>ISP Fail Flag (Write Protect)\nThis bit is set by hardware when a triggered ISP meets any of the following conditions:\n(1) APROM writes to itself if APUEN is set to 0.\n(2) LDROM writes to itself if LDUEN is set to 0.\n(3) CONFIG is erased/programmed if CFGUEN is set to 0.\n(4) Destination address is illegal, such as over an available range.\nWrite 1 to clear to this bit to 0.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ISPADR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ISPADR</displayName>
          <description>ISP Address Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ISPADR</name>
              <description>ISP Address\nThe NuMicro( NUC1311 series has a maximum of 17Kx32 (68 KB) embedded Flash, which supports word program only. ISPADR[1:0] must be kept 00b for ISP operation.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ISPDAT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ISPDAT</displayName>
          <description>ISP Data Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ISPDAT</name>
              <description>ISP Data\nWrite data to this register before ISP program operation.\nRead data from this register after ISP read operation.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ISPCMD</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ISPCMD</displayName>
          <description>ISP Command Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ISPCMD</name>
              <description>ISP Command\nISP command table is shown below:</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Read</description>
                    <value>0x00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>Read Unique ID</description>
                    <value>0x04</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>11</name>
                    <description>Read Company ID (0xDA)</description>
                    <value>0x0b</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>33</name>
                    <description>Program</description>
                    <value>0x21</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>34</name>
                    <description>Page Erase</description>
                    <value>0x22</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>46</name>
                    <description>Set Vector Page Re-Map</description>
                    <value>0x2e</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ISPTRG</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ISPTRG</displayName>
          <description>ISP Trigger Control Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ISPGO</name>
              <description>ISP Start Trigger (Write Protect)\nWrite 1 to start ISP operation and this bit will be cleared to 0 by hardware automatically when ISP operation is finished.\nThis bit is the protected bit, It means programming this bit needs to write '59h', '16h', '88h' to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ISP operation finished</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ISP is in progress</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>DFBADR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>DFBADR</displayName>
          <description>Data Flash Base Address</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFF00000</resetMask>
          <fields>
            <field>
              <name>DFBADR</name>
              <description>Data Flash Base Address\nThis register indicates Data Flash start address. It is read only.\nWhen DFVSEN is set to 0, the data flash is shared with APROM. The data flash size is defined by user configuration and the content of this register is loaded from Config1.\nWhen DFVSEN is set to 1, the data flash size is fixed as 4K and the start address can be read from this register is fixed at 0x0001_F000.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>FATCON</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>FATCON</displayName>
          <description>Flash Access Time Control Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FOMSEL0</name>
              <description>Chip Frequency Optimization Mode Select 0 (Write-Protection Bit)\nWhen CPU frequency is lower than 25 MHz, user can modify flash access delay cycle by FOMSEL1 and FOMSEL0 to improve system performance.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FOMSEL1</name>
              <description>Chip Frequency Optimization Mode Select1 (Write-protection Bit)</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ISPSTA</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ISPSTA</displayName>
          <description>ISP Status Register</description>
          <addressOffset>0x40</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ISPGO</name>
              <description>ISP Start Trigger (Read Only)\nWrite 1 to start ISP operation and this bit will be cleared to 0 by hardware automatically when ISP operation is finished.\nNote: This bit is the same as ISPTRG bit0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ISP operation finished</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ISP operation progressed</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>CBS</name>
              <description>Chip Boot Selection (Read Only)\nThis is a mirror of CBS in CONFIG0.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ISPFF</name>
              <description>ISP Fail Flag (Write-Protection Bit)\nThis bit is set by hardware when a triggered ISP meets any of the following conditions:\n(1) APROM writes to itself\n(2) LDROM writes to itself\n(3) CONFIG is erased/programmed if CFGUEN is set to 0\n(4) Destination address is illegal, such as over an available range\nWrite 1 to clear this bit.\nNote: The function of this bit is the same as ISPCON bit6.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VECMAP</name>
              <description>Vector Page Mapping Address (Read Only)\nThe current flash address space 0x0000_0000~0x0000_01FF is mapping to address {VECMAP[11:0], 9'h000} ~ {VECMAP[11:0], 9'h1FF}.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>GPIO</name>
      <description>GPIO Register Map</description>
      <groupName>GPIO</groupName>
      <baseAddress>0x50004000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x24</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x40</offset>
        <size>0x24</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x80</offset>
        <size>0x24</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0xC0</offset>
        <size>0x24</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x100</offset>
        <size>0x24</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x140</offset>
        <size>0x24</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x180</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x200</offset>
        <size>0x90</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x298</offset>
        <size>0x18</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x2B8</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x2D8</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x2F8</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x314</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x340</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x350</offset>
        <size>0x14</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>GPIOA_PMD</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPIOA_PMD</displayName>
          <description>GPIO Port A Pin I/O Mode Control</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>PMD0</name>
              <description>GPIOx I/O Pin[N] Mode Control\nDetermine each I/O mode of GPIOx pins.\nNote2:\nThe initial value of this field is defined by CIOINI (CONFIG0[10]). If CIOINI is set to 1, the default value is 0xFFFF_FFFF and all pins will be Quasi-bidirectional mode after chip is powered on. If CIOINI is cleared to 0, the default value is 0x0000_0000 and all pins will be input only mode after chip is powered on.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in Input mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in Push-pull Output mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-drain Output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD1</name>
              <description>GPIOx I/O Pin[N] Mode Control\nDetermine each I/O mode of GPIOx pins.\nNote2:\nThe initial value of this field is defined by CIOINI (CONFIG0[10]). If CIOINI is set to 1, the default value is 0xFFFF_FFFF and all pins will be Quasi-bidirectional mode after chip is powered on. If CIOINI is cleared to 0, the default value is 0x0000_0000 and all pins will be input only mode after chip is powered on.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in Input mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in Push-pull Output mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-drain Output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD2</name>
              <description>GPIOx I/O Pin[N] Mode Control\nDetermine each I/O mode of GPIOx pins.\nNote2:\nThe initial value of this field is defined by CIOINI (CONFIG0[10]). If CIOINI is set to 1, the default value is 0xFFFF_FFFF and all pins will be Quasi-bidirectional mode after chip is powered on. If CIOINI is cleared to 0, the default value is 0x0000_0000 and all pins will be input only mode after chip is powered on.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in Input mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in Push-pull Output mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-drain Output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD3</name>
              <description>GPIOx I/O Pin[N] Mode Control\nDetermine each I/O mode of GPIOx pins.\nNote2:\nThe initial value of this field is defined by CIOINI (CONFIG0[10]). If CIOINI is set to 1, the default value is 0xFFFF_FFFF and all pins will be Quasi-bidirectional mode after chip is powered on. If CIOINI is cleared to 0, the default value is 0x0000_0000 and all pins will be input only mode after chip is powered on.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in Input mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in Push-pull Output mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-drain Output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD4</name>
              <description>GPIOx I/O Pin[N] Mode Control\nDetermine each I/O mode of GPIOx pins.\nNote2:\nThe initial value of this field is defined by CIOINI (CONFIG0[10]). If CIOINI is set to 1, the default value is 0xFFFF_FFFF and all pins will be Quasi-bidirectional mode after chip is powered on. If CIOINI is cleared to 0, the default value is 0x0000_0000 and all pins will be input only mode after chip is powered on.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in Input mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in Push-pull Output mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-drain Output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD5</name>
              <description>GPIOx I/O Pin[N] Mode Control\nDetermine each I/O mode of GPIOx pins.\nNote2:\nThe initial value of this field is defined by CIOINI (CONFIG0[10]). If CIOINI is set to 1, the default value is 0xFFFF_FFFF and all pins will be Quasi-bidirectional mode after chip is powered on. If CIOINI is cleared to 0, the default value is 0x0000_0000 and all pins will be input only mode after chip is powered on.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in Input mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in Push-pull Output mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-drain Output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD6</name>
              <description>GPIOx I/O Pin[N] Mode Control\nDetermine each I/O mode of GPIOx pins.\nNote2:\nThe initial value of this field is defined by CIOINI (CONFIG0[10]). If CIOINI is set to 1, the default value is 0xFFFF_FFFF and all pins will be Quasi-bidirectional mode after chip is powered on. If CIOINI is cleared to 0, the default value is 0x0000_0000 and all pins will be input only mode after chip is powered on.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in Input mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in Push-pull Output mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-drain Output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD7</name>
              <description>GPIOx I/O Pin[N] Mode Control\nDetermine each I/O mode of GPIOx pins.\nNote2:\nThe initial value of this field is defined by CIOINI (CONFIG0[10]). If CIOINI is set to 1, the default value is 0xFFFF_FFFF and all pins will be Quasi-bidirectional mode after chip is powered on. If CIOINI is cleared to 0, the default value is 0x0000_0000 and all pins will be input only mode after chip is powered on.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in Input mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in Push-pull Output mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-drain Output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD8</name>
              <description>GPIOx I/O Pin[N] Mode Control\nDetermine each I/O mode of GPIOx pins.\nNote2:\nThe initial value of this field is defined by CIOINI (CONFIG0[10]). If CIOINI is set to 1, the default value is 0xFFFF_FFFF and all pins will be Quasi-bidirectional mode after chip is powered on. If CIOINI is cleared to 0, the default value is 0x0000_0000 and all pins will be input only mode after chip is powered on.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in Input mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in Push-pull Output mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-drain Output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD9</name>
              <description>GPIOx I/O Pin[N] Mode Control\nDetermine each I/O mode of GPIOx pins.\nNote2:\nThe initial value of this field is defined by CIOINI (CONFIG0[10]). If CIOINI is set to 1, the default value is 0xFFFF_FFFF and all pins will be Quasi-bidirectional mode after chip is powered on. If CIOINI is cleared to 0, the default value is 0x0000_0000 and all pins will be input only mode after chip is powered on.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in Input mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in Push-pull Output mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-drain Output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD10</name>
              <description>GPIOx I/O Pin[N] Mode Control\nDetermine each I/O mode of GPIOx pins.\nNote2:\nThe initial value of this field is defined by CIOINI (CONFIG0[10]). If CIOINI is set to 1, the default value is 0xFFFF_FFFF and all pins will be Quasi-bidirectional mode after chip is powered on. If CIOINI is cleared to 0, the default value is 0x0000_0000 and all pins will be input only mode after chip is powered on.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in Input mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in Push-pull Output mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-drain Output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD11</name>
              <description>GPIOx I/O Pin[N] Mode Control\nDetermine each I/O mode of GPIOx pins.\nNote2:\nThe initial value of this field is defined by CIOINI (CONFIG0[10]). If CIOINI is set to 1, the default value is 0xFFFF_FFFF and all pins will be Quasi-bidirectional mode after chip is powered on. If CIOINI is cleared to 0, the default value is 0x0000_0000 and all pins will be input only mode after chip is powered on.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in Input mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in Push-pull Output mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-drain Output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD12</name>
              <description>GPIOx I/O Pin[N] Mode Control\nDetermine each I/O mode of GPIOx pins.\nNote2:\nThe initial value of this field is defined by CIOINI (CONFIG0[10]). If CIOINI is set to 1, the default value is 0xFFFF_FFFF and all pins will be Quasi-bidirectional mode after chip is powered on. If CIOINI is cleared to 0, the default value is 0x0000_0000 and all pins will be input only mode after chip is powered on.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in Input mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in Push-pull Output mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-drain Output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD13</name>
              <description>GPIOx I/O Pin[N] Mode Control\nDetermine each I/O mode of GPIOx pins.\nNote2:\nThe initial value of this field is defined by CIOINI (CONFIG0[10]). If CIOINI is set to 1, the default value is 0xFFFF_FFFF and all pins will be Quasi-bidirectional mode after chip is powered on. If CIOINI is cleared to 0, the default value is 0x0000_0000 and all pins will be input only mode after chip is powered on.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in Input mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in Push-pull Output mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-drain Output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD14</name>
              <description>GPIOx I/O Pin[N] Mode Control\nDetermine each I/O mode of GPIOx pins.\nNote2:\nThe initial value of this field is defined by CIOINI (CONFIG0[10]). If CIOINI is set to 1, the default value is 0xFFFF_FFFF and all pins will be Quasi-bidirectional mode after chip is powered on. If CIOINI is cleared to 0, the default value is 0x0000_0000 and all pins will be input only mode after chip is powered on.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in Input mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in Push-pull Output mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-drain Output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD15</name>
              <description>GPIOx I/O Pin[N] Mode Control\nDetermine each I/O mode of GPIOx pins.\nNote2:\nThe initial value of this field is defined by CIOINI (CONFIG0[10]). If CIOINI is set to 1, the default value is 0xFFFF_FFFF and all pins will be Quasi-bidirectional mode after chip is powered on. If CIOINI is cleared to 0, the default value is 0x0000_0000 and all pins will be input only mode after chip is powered on.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in Input mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in Push-pull Output mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-drain Output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPIOA_OFFD</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPIOA_OFFD</displayName>
          <description>GPIO Port A Pin Digital Input Path Disable Control</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OFFD0</name>
              <description>GPIOx Pin[N] Digital Input Path Disable Control\nEach of these bits is used to control if the digital input path of corresponding GPIO pin is disabled. If input is analog signal, users can disable GPIO digital input path to avoid current leakage.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I/O digital input path Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I/O digital input path Disabled (digital input tied to low)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>OFFD1</name>
              <description>GPIOx Pin[N] Digital Input Path Disable Control\nEach of these bits is used to control if the digital input path of corresponding GPIO pin is disabled. If input is analog signal, users can disable GPIO digital input path to avoid current leakage.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I/O digital input path Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I/O digital input path Disabled (digital input tied to low)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>OFFD2</name>
              <description>GPIOx Pin[N] Digital Input Path Disable Control\nEach of these bits is used to control if the digital input path of corresponding GPIO pin is disabled. If input is analog signal, users can disable GPIO digital input path to avoid current leakage.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I/O digital input path Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I/O digital input path Disabled (digital input tied to low)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>OFFD3</name>
              <description>GPIOx Pin[N] Digital Input Path Disable Control\nEach of these bits is used to control if the digital input path of corresponding GPIO pin is disabled. If input is analog signal, users can disable GPIO digital input path to avoid current leakage.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I/O digital input path Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I/O digital input path Disabled (digital input tied to low)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>OFFD4</name>
              <description>GPIOx Pin[N] Digital Input Path Disable Control\nEach of these bits is used to control if the digital input path of corresponding GPIO pin is disabled. If input is analog signal, users can disable GPIO digital input path to avoid current leakage.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I/O digital input path Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I/O digital input path Disabled (digital input tied to low)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>OFFD5</name>
              <description>GPIOx Pin[N] Digital Input Path Disable Control\nEach of these bits is used to control if the digital input path of corresponding GPIO pin is disabled. If input is analog signal, users can disable GPIO digital input path to avoid current leakage.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I/O digital input path Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I/O digital input path Disabled (digital input tied to low)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>OFFD6</name>
              <description>GPIOx Pin[N] Digital Input Path Disable Control\nEach of these bits is used to control if the digital input path of corresponding GPIO pin is disabled. If input is analog signal, users can disable GPIO digital input path to avoid current leakage.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I/O digital input path Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I/O digital input path Disabled (digital input tied to low)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>OFFD7</name>
              <description>GPIOx Pin[N] Digital Input Path Disable Control\nEach of these bits is used to control if the digital input path of corresponding GPIO pin is disabled. If input is analog signal, users can disable GPIO digital input path to avoid current leakage.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I/O digital input path Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I/O digital input path Disabled (digital input tied to low)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>OFFD8</name>
              <description>GPIOx Pin[N] Digital Input Path Disable Control\nEach of these bits is used to control if the digital input path of corresponding GPIO pin is disabled. If input is analog signal, users can disable GPIO digital input path to avoid current leakage.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I/O digital input path Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I/O digital input path Disabled (digital input tied to low)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>OFFD9</name>
              <description>GPIOx Pin[N] Digital Input Path Disable Control\nEach of these bits is used to control if the digital input path of corresponding GPIO pin is disabled. If input is analog signal, users can disable GPIO digital input path to avoid current leakage.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I/O digital input path Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I/O digital input path Disabled (digital input tied to low)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>OFFD10</name>
              <description>GPIOx Pin[N] Digital Input Path Disable Control\nEach of these bits is used to control if the digital input path of corresponding GPIO pin is disabled. If input is analog signal, users can disable GPIO digital input path to avoid current leakage.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I/O digital input path Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I/O digital input path Disabled (digital input tied to low)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>OFFD11</name>
              <description>GPIOx Pin[N] Digital Input Path Disable Control\nEach of these bits is used to control if the digital input path of corresponding GPIO pin is disabled. If input is analog signal, users can disable GPIO digital input path to avoid current leakage.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I/O digital input path Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I/O digital input path Disabled (digital input tied to low)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>OFFD12</name>
              <description>GPIOx Pin[N] Digital Input Path Disable Control\nEach of these bits is used to control if the digital input path of corresponding GPIO pin is disabled. If input is analog signal, users can disable GPIO digital input path to avoid current leakage.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I/O digital input path Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I/O digital input path Disabled (digital input tied to low)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>OFFD13</name>
              <description>GPIOx Pin[N] Digital Input Path Disable Control\nEach of these bits is used to control if the digital input path of corresponding GPIO pin is disabled. If input is analog signal, users can disable GPIO digital input path to avoid current leakage.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I/O digital input path Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I/O digital input path Disabled (digital input tied to low)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>OFFD14</name>
              <description>GPIOx Pin[N] Digital Input Path Disable Control\nEach of these bits is used to control if the digital input path of corresponding GPIO pin is disabled. If input is analog signal, users can disable GPIO digital input path to avoid current leakage.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I/O digital input path Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I/O digital input path Disabled (digital input tied to low)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>OFFD15</name>
              <description>GPIOx Pin[N] Digital Input Path Disable Control\nEach of these bits is used to control if the digital input path of corresponding GPIO pin is disabled. If input is analog signal, users can disable GPIO digital input path to avoid current leakage.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I/O digital input path Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I/O digital input path Disabled (digital input tied to low)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPIOA_DOUT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPIOA_DOUT</displayName>
          <description>GPIO Port A Data Output Value</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x0000FFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DOUT0</name>
              <description>GPIOx Pin[N] Output Value\nEach of these bits controls the status of a GPIO pin when the GPIO pin is configured as Push-pull output, open-drain output or quasi-bidirectional mode.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/D/E/F] Pin[n] will drive Low if the GPIO pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/D/E/F] Pin[n] will drive High if the GPIO pin is configured as Push-pull output or Quasi-bidirectional mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT1</name>
              <description>GPIOx Pin[N] Output Value\nEach of these bits controls the status of a GPIO pin when the GPIO pin is configured as Push-pull output, open-drain output or quasi-bidirectional mode.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/D/E/F] Pin[n] will drive Low if the GPIO pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/D/E/F] Pin[n] will drive High if the GPIO pin is configured as Push-pull output or Quasi-bidirectional mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT2</name>
              <description>GPIOx Pin[N] Output Value\nEach of these bits controls the status of a GPIO pin when the GPIO pin is configured as Push-pull output, open-drain output or quasi-bidirectional mode.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/D/E/F] Pin[n] will drive Low if the GPIO pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/D/E/F] Pin[n] will drive High if the GPIO pin is configured as Push-pull output or Quasi-bidirectional mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT3</name>
              <description>GPIOx Pin[N] Output Value\nEach of these bits controls the status of a GPIO pin when the GPIO pin is configured as Push-pull output, open-drain output or quasi-bidirectional mode.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/D/E/F] Pin[n] will drive Low if the GPIO pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/D/E/F] Pin[n] will drive High if the GPIO pin is configured as Push-pull output or Quasi-bidirectional mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT4</name>
              <description>GPIOx Pin[N] Output Value\nEach of these bits controls the status of a GPIO pin when the GPIO pin is configured as Push-pull output, open-drain output or quasi-bidirectional mode.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/D/E/F] Pin[n] will drive Low if the GPIO pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/D/E/F] Pin[n] will drive High if the GPIO pin is configured as Push-pull output or Quasi-bidirectional mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT5</name>
              <description>GPIOx Pin[N] Output Value\nEach of these bits controls the status of a GPIO pin when the GPIO pin is configured as Push-pull output, open-drain output or quasi-bidirectional mode.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/D/E/F] Pin[n] will drive Low if the GPIO pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/D/E/F] Pin[n] will drive High if the GPIO pin is configured as Push-pull output or Quasi-bidirectional mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT6</name>
              <description>GPIOx Pin[N] Output Value\nEach of these bits controls the status of a GPIO pin when the GPIO pin is configured as Push-pull output, open-drain output or quasi-bidirectional mode.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/D/E/F] Pin[n] will drive Low if the GPIO pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/D/E/F] Pin[n] will drive High if the GPIO pin is configured as Push-pull output or Quasi-bidirectional mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT7</name>
              <description>GPIOx Pin[N] Output Value\nEach of these bits controls the status of a GPIO pin when the GPIO pin is configured as Push-pull output, open-drain output or quasi-bidirectional mode.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/D/E/F] Pin[n] will drive Low if the GPIO pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/D/E/F] Pin[n] will drive High if the GPIO pin is configured as Push-pull output or Quasi-bidirectional mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT8</name>
              <description>GPIOx Pin[N] Output Value\nEach of these bits controls the status of a GPIO pin when the GPIO pin is configured as Push-pull output, open-drain output or quasi-bidirectional mode.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/D/E/F] Pin[n] will drive Low if the GPIO pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/D/E/F] Pin[n] will drive High if the GPIO pin is configured as Push-pull output or Quasi-bidirectional mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT9</name>
              <description>GPIOx Pin[N] Output Value\nEach of these bits controls the status of a GPIO pin when the GPIO pin is configured as Push-pull output, open-drain output or quasi-bidirectional mode.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/D/E/F] Pin[n] will drive Low if the GPIO pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/D/E/F] Pin[n] will drive High if the GPIO pin is configured as Push-pull output or Quasi-bidirectional mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT10</name>
              <description>GPIOx Pin[N] Output Value\nEach of these bits controls the status of a GPIO pin when the GPIO pin is configured as Push-pull output, open-drain output or quasi-bidirectional mode.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/D/E/F] Pin[n] will drive Low if the GPIO pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/D/E/F] Pin[n] will drive High if the GPIO pin is configured as Push-pull output or Quasi-bidirectional mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT11</name>
              <description>GPIOx Pin[N] Output Value\nEach of these bits controls the status of a GPIO pin when the GPIO pin is configured as Push-pull output, open-drain output or quasi-bidirectional mode.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/D/E/F] Pin[n] will drive Low if the GPIO pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/D/E/F] Pin[n] will drive High if the GPIO pin is configured as Push-pull output or Quasi-bidirectional mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT12</name>
              <description>GPIOx Pin[N] Output Value\nEach of these bits controls the status of a GPIO pin when the GPIO pin is configured as Push-pull output, open-drain output or quasi-bidirectional mode.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/D/E/F] Pin[n] will drive Low if the GPIO pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/D/E/F] Pin[n] will drive High if the GPIO pin is configured as Push-pull output or Quasi-bidirectional mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT13</name>
              <description>GPIOx Pin[N] Output Value\nEach of these bits controls the status of a GPIO pin when the GPIO pin is configured as Push-pull output, open-drain output or quasi-bidirectional mode.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/D/E/F] Pin[n] will drive Low if the GPIO pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/D/E/F] Pin[n] will drive High if the GPIO pin is configured as Push-pull output or Quasi-bidirectional mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT14</name>
              <description>GPIOx Pin[N] Output Value\nEach of these bits controls the status of a GPIO pin when the GPIO pin is configured as Push-pull output, open-drain output or quasi-bidirectional mode.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/D/E/F] Pin[n] will drive Low if the GPIO pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/D/E/F] Pin[n] will drive High if the GPIO pin is configured as Push-pull output or Quasi-bidirectional mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT15</name>
              <description>GPIOx Pin[N] Output Value\nEach of these bits controls the status of a GPIO pin when the GPIO pin is configured as Push-pull output, open-drain output or quasi-bidirectional mode.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/D/E/F] Pin[n] will drive Low if the GPIO pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/D/E/F] Pin[n] will drive High if the GPIO pin is configured as Push-pull output or Quasi-bidirectional mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPIOA_DMASK</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPIOA_DMASK</displayName>
          <description>GPIO Port A Data Output Write Mask</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMASK0</name>
              <description>Port [A/B/C/D/E/F] Data Output Write Mask\nThese bits are used to protect the corresponding register of  GPIOx_DOUT[n] bit. When the  DMASK[n] bit is set to 1, the corresponding GPIOx_DOUT[n] bit is protected. If the write signal is masked, write data to the protect bit is ignored.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding GPIOx_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding GPIOx_DOUT[n] bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK1</name>
              <description>Port [A/B/C/D/E/F] Data Output Write Mask\nThese bits are used to protect the corresponding register of  GPIOx_DOUT[n] bit. When the  DMASK[n] bit is set to 1, the corresponding GPIOx_DOUT[n] bit is protected. If the write signal is masked, write data to the protect bit is ignored.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding GPIOx_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding GPIOx_DOUT[n] bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK2</name>
              <description>Port [A/B/C/D/E/F] Data Output Write Mask\nThese bits are used to protect the corresponding register of  GPIOx_DOUT[n] bit. When the  DMASK[n] bit is set to 1, the corresponding GPIOx_DOUT[n] bit is protected. If the write signal is masked, write data to the protect bit is ignored.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding GPIOx_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding GPIOx_DOUT[n] bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK3</name>
              <description>Port [A/B/C/D/E/F] Data Output Write Mask\nThese bits are used to protect the corresponding register of  GPIOx_DOUT[n] bit. When the  DMASK[n] bit is set to 1, the corresponding GPIOx_DOUT[n] bit is protected. If the write signal is masked, write data to the protect bit is ignored.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding GPIOx_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding GPIOx_DOUT[n] bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK4</name>
              <description>Port [A/B/C/D/E/F] Data Output Write Mask\nThese bits are used to protect the corresponding register of  GPIOx_DOUT[n] bit. When the  DMASK[n] bit is set to 1, the corresponding GPIOx_DOUT[n] bit is protected. If the write signal is masked, write data to the protect bit is ignored.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding GPIOx_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding GPIOx_DOUT[n] bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK5</name>
              <description>Port [A/B/C/D/E/F] Data Output Write Mask\nThese bits are used to protect the corresponding register of  GPIOx_DOUT[n] bit. When the  DMASK[n] bit is set to 1, the corresponding GPIOx_DOUT[n] bit is protected. If the write signal is masked, write data to the protect bit is ignored.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding GPIOx_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding GPIOx_DOUT[n] bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK6</name>
              <description>Port [A/B/C/D/E/F] Data Output Write Mask\nThese bits are used to protect the corresponding register of  GPIOx_DOUT[n] bit. When the  DMASK[n] bit is set to 1, the corresponding GPIOx_DOUT[n] bit is protected. If the write signal is masked, write data to the protect bit is ignored.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding GPIOx_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding GPIOx_DOUT[n] bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK7</name>
              <description>Port [A/B/C/D/E/F] Data Output Write Mask\nThese bits are used to protect the corresponding register of  GPIOx_DOUT[n] bit. When the  DMASK[n] bit is set to 1, the corresponding GPIOx_DOUT[n] bit is protected. If the write signal is masked, write data to the protect bit is ignored.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding GPIOx_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding GPIOx_DOUT[n] bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK8</name>
              <description>Port [A/B/C/D/E/F] Data Output Write Mask\nThese bits are used to protect the corresponding register of  GPIOx_DOUT[n] bit. When the  DMASK[n] bit is set to 1, the corresponding GPIOx_DOUT[n] bit is protected. If the write signal is masked, write data to the protect bit is ignored.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding GPIOx_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding GPIOx_DOUT[n] bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK9</name>
              <description>Port [A/B/C/D/E/F] Data Output Write Mask\nThese bits are used to protect the corresponding register of  GPIOx_DOUT[n] bit. When the  DMASK[n] bit is set to 1, the corresponding GPIOx_DOUT[n] bit is protected. If the write signal is masked, write data to the protect bit is ignored.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding GPIOx_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding GPIOx_DOUT[n] bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK10</name>
              <description>Port [A/B/C/D/E/F] Data Output Write Mask\nThese bits are used to protect the corresponding register of  GPIOx_DOUT[n] bit. When the  DMASK[n] bit is set to 1, the corresponding GPIOx_DOUT[n] bit is protected. If the write signal is masked, write data to the protect bit is ignored.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding GPIOx_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding GPIOx_DOUT[n] bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK11</name>
              <description>Port [A/B/C/D/E/F] Data Output Write Mask\nThese bits are used to protect the corresponding register of  GPIOx_DOUT[n] bit. When the  DMASK[n] bit is set to 1, the corresponding GPIOx_DOUT[n] bit is protected. If the write signal is masked, write data to the protect bit is ignored.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding GPIOx_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding GPIOx_DOUT[n] bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK12</name>
              <description>Port [A/B/C/D/E/F] Data Output Write Mask\nThese bits are used to protect the corresponding register of  GPIOx_DOUT[n] bit. When the  DMASK[n] bit is set to 1, the corresponding GPIOx_DOUT[n] bit is protected. If the write signal is masked, write data to the protect bit is ignored.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding GPIOx_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding GPIOx_DOUT[n] bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK13</name>
              <description>Port [A/B/C/D/E/F] Data Output Write Mask\nThese bits are used to protect the corresponding register of  GPIOx_DOUT[n] bit. When the  DMASK[n] bit is set to 1, the corresponding GPIOx_DOUT[n] bit is protected. If the write signal is masked, write data to the protect bit is ignored.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding GPIOx_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding GPIOx_DOUT[n] bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK14</name>
              <description>Port [A/B/C/D/E/F] Data Output Write Mask\nThese bits are used to protect the corresponding register of  GPIOx_DOUT[n] bit. When the  DMASK[n] bit is set to 1, the corresponding GPIOx_DOUT[n] bit is protected. If the write signal is masked, write data to the protect bit is ignored.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding GPIOx_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding GPIOx_DOUT[n] bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK15</name>
              <description>Port [A/B/C/D/E/F] Data Output Write Mask\nThese bits are used to protect the corresponding register of  GPIOx_DOUT[n] bit. When the  DMASK[n] bit is set to 1, the corresponding GPIOx_DOUT[n] bit is protected. If the write signal is masked, write data to the protect bit is ignored.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding GPIOx_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding GPIOx_DOUT[n] bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPIOA_PIN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPIOA_PIN</displayName>
          <description>GPIO Port A Pin Value</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFF0000</resetMask>
          <fields>
            <field>
              <name>PIN0</name>
              <description>Port [A/B/C/D/E/F] Pin Values\nEach bit of the register reflects the actual status of the respective GPIO pin. If the bit is 1, it indicates the corresponding pin status is high, else the pin status is low.\nNote:</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN1</name>
              <description>Port [A/B/C/D/E/F] Pin Values\nEach bit of the register reflects the actual status of the respective GPIO pin. If the bit is 1, it indicates the corresponding pin status is high, else the pin status is low.\nNote:</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN2</name>
              <description>Port [A/B/C/D/E/F] Pin Values\nEach bit of the register reflects the actual status of the respective GPIO pin. If the bit is 1, it indicates the corresponding pin status is high, else the pin status is low.\nNote:</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN3</name>
              <description>Port [A/B/C/D/E/F] Pin Values\nEach bit of the register reflects the actual status of the respective GPIO pin. If the bit is 1, it indicates the corresponding pin status is high, else the pin status is low.\nNote:</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN4</name>
              <description>Port [A/B/C/D/E/F] Pin Values\nEach bit of the register reflects the actual status of the respective GPIO pin. If the bit is 1, it indicates the corresponding pin status is high, else the pin status is low.\nNote:</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN5</name>
              <description>Port [A/B/C/D/E/F] Pin Values\nEach bit of the register reflects the actual status of the respective GPIO pin. If the bit is 1, it indicates the corresponding pin status is high, else the pin status is low.\nNote:</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN6</name>
              <description>Port [A/B/C/D/E/F] Pin Values\nEach bit of the register reflects the actual status of the respective GPIO pin. If the bit is 1, it indicates the corresponding pin status is high, else the pin status is low.\nNote:</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN7</name>
              <description>Port [A/B/C/D/E/F] Pin Values\nEach bit of the register reflects the actual status of the respective GPIO pin. If the bit is 1, it indicates the corresponding pin status is high, else the pin status is low.\nNote:</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN8</name>
              <description>Port [A/B/C/D/E/F] Pin Values\nEach bit of the register reflects the actual status of the respective GPIO pin. If the bit is 1, it indicates the corresponding pin status is high, else the pin status is low.\nNote:</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN9</name>
              <description>Port [A/B/C/D/E/F] Pin Values\nEach bit of the register reflects the actual status of the respective GPIO pin. If the bit is 1, it indicates the corresponding pin status is high, else the pin status is low.\nNote:</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN10</name>
              <description>Port [A/B/C/D/E/F] Pin Values\nEach bit of the register reflects the actual status of the respective GPIO pin. If the bit is 1, it indicates the corresponding pin status is high, else the pin status is low.\nNote:</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN11</name>
              <description>Port [A/B/C/D/E/F] Pin Values\nEach bit of the register reflects the actual status of the respective GPIO pin. If the bit is 1, it indicates the corresponding pin status is high, else the pin status is low.\nNote:</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN12</name>
              <description>Port [A/B/C/D/E/F] Pin Values\nEach bit of the register reflects the actual status of the respective GPIO pin. If the bit is 1, it indicates the corresponding pin status is high, else the pin status is low.\nNote:</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN13</name>
              <description>Port [A/B/C/D/E/F] Pin Values\nEach bit of the register reflects the actual status of the respective GPIO pin. If the bit is 1, it indicates the corresponding pin status is high, else the pin status is low.\nNote:</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN14</name>
              <description>Port [A/B/C/D/E/F] Pin Values\nEach bit of the register reflects the actual status of the respective GPIO pin. If the bit is 1, it indicates the corresponding pin status is high, else the pin status is low.\nNote:</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN15</name>
              <description>Port [A/B/C/D/E/F] Pin Values\nEach bit of the register reflects the actual status of the respective GPIO pin. If the bit is 1, it indicates the corresponding pin status is high, else the pin status is low.\nNote:</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPIOA_DBEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPIOA_DBEN</displayName>
          <description>GPIO Port A De-bounce Enable</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DBEN0</name>
              <description>Port [A/B/C/D/E/F] Input Signal De-Bounce Enable Control\nDBEN[n] is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period is controlled by DBNCECON[3:0].</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit[n] de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit[n] de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN1</name>
              <description>Port [A/B/C/D/E/F] Input Signal De-Bounce Enable Control\nDBEN[n] is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period is controlled by DBNCECON[3:0].</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit[n] de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit[n] de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN2</name>
              <description>Port [A/B/C/D/E/F] Input Signal De-Bounce Enable Control\nDBEN[n] is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period is controlled by DBNCECON[3:0].</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit[n] de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit[n] de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN3</name>
              <description>Port [A/B/C/D/E/F] Input Signal De-Bounce Enable Control\nDBEN[n] is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period is controlled by DBNCECON[3:0].</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit[n] de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit[n] de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN4</name>
              <description>Port [A/B/C/D/E/F] Input Signal De-Bounce Enable Control\nDBEN[n] is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period is controlled by DBNCECON[3:0].</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit[n] de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit[n] de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN5</name>
              <description>Port [A/B/C/D/E/F] Input Signal De-Bounce Enable Control\nDBEN[n] is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period is controlled by DBNCECON[3:0].</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit[n] de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit[n] de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN6</name>
              <description>Port [A/B/C/D/E/F] Input Signal De-Bounce Enable Control\nDBEN[n] is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period is controlled by DBNCECON[3:0].</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit[n] de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit[n] de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN7</name>
              <description>Port [A/B/C/D/E/F] Input Signal De-Bounce Enable Control\nDBEN[n] is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period is controlled by DBNCECON[3:0].</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit[n] de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit[n] de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN8</name>
              <description>Port [A/B/C/D/E/F] Input Signal De-Bounce Enable Control\nDBEN[n] is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period is controlled by DBNCECON[3:0].</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit[n] de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit[n] de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN9</name>
              <description>Port [A/B/C/D/E/F] Input Signal De-Bounce Enable Control\nDBEN[n] is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period is controlled by DBNCECON[3:0].</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit[n] de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit[n] de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN10</name>
              <description>Port [A/B/C/D/E/F] Input Signal De-Bounce Enable Control\nDBEN[n] is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period is controlled by DBNCECON[3:0].</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit[n] de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit[n] de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN11</name>
              <description>Port [A/B/C/D/E/F] Input Signal De-Bounce Enable Control\nDBEN[n] is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period is controlled by DBNCECON[3:0].</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit[n] de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit[n] de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN12</name>
              <description>Port [A/B/C/D/E/F] Input Signal De-Bounce Enable Control\nDBEN[n] is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period is controlled by DBNCECON[3:0].</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit[n] de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit[n] de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN13</name>
              <description>Port [A/B/C/D/E/F] Input Signal De-Bounce Enable Control\nDBEN[n] is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period is controlled by DBNCECON[3:0].</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit[n] de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit[n] de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN14</name>
              <description>Port [A/B/C/D/E/F] Input Signal De-Bounce Enable Control\nDBEN[n] is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period is controlled by DBNCECON[3:0].</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit[n] de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit[n] de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN15</name>
              <description>Port [A/B/C/D/E/F] Input Signal De-Bounce Enable Control\nDBEN[n] is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period is controlled by DBNCECON[3:0].</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit[n] de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit[n] de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPIOA_IMD</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPIOA_IMD</displayName>
          <description>GPIO Port A Interrupt Mode Control</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IMD0</name>
              <description>Port [A/B/C/D/E/F] Edge Or Level Detection Interrupt Control\nIMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD1</name>
              <description>Port [A/B/C/D/E/F] Edge Or Level Detection Interrupt Control\nIMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD2</name>
              <description>Port [A/B/C/D/E/F] Edge Or Level Detection Interrupt Control\nIMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD3</name>
              <description>Port [A/B/C/D/E/F] Edge Or Level Detection Interrupt Control\nIMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD4</name>
              <description>Port [A/B/C/D/E/F] Edge Or Level Detection Interrupt Control\nIMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD5</name>
              <description>Port [A/B/C/D/E/F] Edge Or Level Detection Interrupt Control\nIMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD6</name>
              <description>Port [A/B/C/D/E/F] Edge Or Level Detection Interrupt Control\nIMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD7</name>
              <description>Port [A/B/C/D/E/F] Edge Or Level Detection Interrupt Control\nIMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD8</name>
              <description>Port [A/B/C/D/E/F] Edge Or Level Detection Interrupt Control\nIMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD9</name>
              <description>Port [A/B/C/D/E/F] Edge Or Level Detection Interrupt Control\nIMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD10</name>
              <description>Port [A/B/C/D/E/F] Edge Or Level Detection Interrupt Control\nIMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD11</name>
              <description>Port [A/B/C/D/E/F] Edge Or Level Detection Interrupt Control\nIMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD12</name>
              <description>Port [A/B/C/D/E/F] Edge Or Level Detection Interrupt Control\nIMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD13</name>
              <description>Port [A/B/C/D/E/F] Edge Or Level Detection Interrupt Control\nIMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD14</name>
              <description>Port [A/B/C/D/E/F] Edge Or Level Detection Interrupt Control\nIMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD15</name>
              <description>Port [A/B/C/D/E/F] Edge Or Level Detection Interrupt Control\nIMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPIOA_IEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPIOA_IEN</displayName>
          <description>GPIO Port A Interrupt Enable</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IF_EN0</name>
              <description>Port [A/B/C/D/E/F] Interrupt Enabled By Input Falling Edge Or Input Level Low\nIF_EN[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function.\nWhen setting the IF_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level 'low' will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from 'high-to-low' will generate the interrupt.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN1</name>
              <description>Port [A/B/C/D/E/F] Interrupt Enabled By Input Falling Edge Or Input Level Low\nIF_EN[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function.\nWhen setting the IF_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level 'low' will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from 'high-to-low' will generate the interrupt.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN2</name>
              <description>Port [A/B/C/D/E/F] Interrupt Enabled By Input Falling Edge Or Input Level Low\nIF_EN[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function.\nWhen setting the IF_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level 'low' will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from 'high-to-low' will generate the interrupt.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN3</name>
              <description>Port [A/B/C/D/E/F] Interrupt Enabled By Input Falling Edge Or Input Level Low\nIF_EN[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function.\nWhen setting the IF_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level 'low' will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from 'high-to-low' will generate the interrupt.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN4</name>
              <description>Port [A/B/C/D/E/F] Interrupt Enabled By Input Falling Edge Or Input Level Low\nIF_EN[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function.\nWhen setting the IF_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level 'low' will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from 'high-to-low' will generate the interrupt.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN5</name>
              <description>Port [A/B/C/D/E/F] Interrupt Enabled By Input Falling Edge Or Input Level Low\nIF_EN[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function.\nWhen setting the IF_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level 'low' will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from 'high-to-low' will generate the interrupt.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN6</name>
              <description>Port [A/B/C/D/E/F] Interrupt Enabled By Input Falling Edge Or Input Level Low\nIF_EN[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function.\nWhen setting the IF_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level 'low' will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from 'high-to-low' will generate the interrupt.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN7</name>
              <description>Port [A/B/C/D/E/F] Interrupt Enabled By Input Falling Edge Or Input Level Low\nIF_EN[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function.\nWhen setting the IF_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level 'low' will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from 'high-to-low' will generate the interrupt.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN8</name>
              <description>Port [A/B/C/D/E/F] Interrupt Enabled By Input Falling Edge Or Input Level Low\nIF_EN[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function.\nWhen setting the IF_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level 'low' will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from 'high-to-low' will generate the interrupt.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN9</name>
              <description>Port [A/B/C/D/E/F] Interrupt Enabled By Input Falling Edge Or Input Level Low\nIF_EN[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function.\nWhen setting the IF_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level 'low' will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from 'high-to-low' will generate the interrupt.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN10</name>
              <description>Port [A/B/C/D/E/F] Interrupt Enabled By Input Falling Edge Or Input Level Low\nIF_EN[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function.\nWhen setting the IF_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level 'low' will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from 'high-to-low' will generate the interrupt.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN11</name>
              <description>Port [A/B/C/D/E/F] Interrupt Enabled By Input Falling Edge Or Input Level Low\nIF_EN[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function.\nWhen setting the IF_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level 'low' will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from 'high-to-low' will generate the interrupt.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN12</name>
              <description>Port [A/B/C/D/E/F] Interrupt Enabled By Input Falling Edge Or Input Level Low\nIF_EN[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function.\nWhen setting the IF_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level 'low' will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from 'high-to-low' will generate the interrupt.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN13</name>
              <description>Port [A/B/C/D/E/F] Interrupt Enabled By Input Falling Edge Or Input Level Low\nIF_EN[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function.\nWhen setting the IF_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level 'low' will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from 'high-to-low' will generate the interrupt.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN14</name>
              <description>Port [A/B/C/D/E/F] Interrupt Enabled By Input Falling Edge Or Input Level Low\nIF_EN[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function.\nWhen setting the IF_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level 'low' will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from 'high-to-low' will generate the interrupt.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN15</name>
              <description>Port [A/B/C/D/E/F] Interrupt Enabled By Input Falling Edge Or Input Level Low\nIF_EN[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function.\nWhen setting the IF_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level 'low' will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from 'high-to-low' will generate the interrupt.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN0</name>
              <description>Port [A/B/C/D/E/F] Interrupt Enabled By Input Rising Edge Or Input Level High\nIR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function.\nWhen setting the IR_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level 'high' will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from 'low-to-high' will generate the interrupt.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN1</name>
              <description>Port [A/B/C/D/E/F] Interrupt Enabled By Input Rising Edge Or Input Level High\nIR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function.\nWhen setting the IR_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level 'high' will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from 'low-to-high' will generate the interrupt.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN2</name>
              <description>Port [A/B/C/D/E/F] Interrupt Enabled By Input Rising Edge Or Input Level High\nIR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function.\nWhen setting the IR_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level 'high' will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from 'low-to-high' will generate the interrupt.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN3</name>
              <description>Port [A/B/C/D/E/F] Interrupt Enabled By Input Rising Edge Or Input Level High\nIR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function.\nWhen setting the IR_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level 'high' will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from 'low-to-high' will generate the interrupt.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN4</name>
              <description>Port [A/B/C/D/E/F] Interrupt Enabled By Input Rising Edge Or Input Level High\nIR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function.\nWhen setting the IR_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level 'high' will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from 'low-to-high' will generate the interrupt.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN5</name>
              <description>Port [A/B/C/D/E/F] Interrupt Enabled By Input Rising Edge Or Input Level High\nIR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function.\nWhen setting the IR_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level 'high' will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from 'low-to-high' will generate the interrupt.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN6</name>
              <description>Port [A/B/C/D/E/F] Interrupt Enabled By Input Rising Edge Or Input Level High\nIR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function.\nWhen setting the IR_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level 'high' will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from 'low-to-high' will generate the interrupt.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN7</name>
              <description>Port [A/B/C/D/E/F] Interrupt Enabled By Input Rising Edge Or Input Level High\nIR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function.\nWhen setting the IR_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level 'high' will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from 'low-to-high' will generate the interrupt.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN8</name>
              <description>Port [A/B/C/D/E/F] Interrupt Enabled By Input Rising Edge Or Input Level High\nIR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function.\nWhen setting the IR_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level 'high' will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from 'low-to-high' will generate the interrupt.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN9</name>
              <description>Port [A/B/C/D/E/F] Interrupt Enabled By Input Rising Edge Or Input Level High\nIR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function.\nWhen setting the IR_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level 'high' will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from 'low-to-high' will generate the interrupt.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN10</name>
              <description>Port [A/B/C/D/E/F] Interrupt Enabled By Input Rising Edge Or Input Level High\nIR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function.\nWhen setting the IR_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level 'high' will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from 'low-to-high' will generate the interrupt.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN11</name>
              <description>Port [A/B/C/D/E/F] Interrupt Enabled By Input Rising Edge Or Input Level High\nIR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function.\nWhen setting the IR_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level 'high' will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from 'low-to-high' will generate the interrupt.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN12</name>
              <description>Port [A/B/C/D/E/F] Interrupt Enabled By Input Rising Edge Or Input Level High\nIR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function.\nWhen setting the IR_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level 'high' will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from 'low-to-high' will generate the interrupt.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN13</name>
              <description>Port [A/B/C/D/E/F] Interrupt Enabled By Input Rising Edge Or Input Level High\nIR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function.\nWhen setting the IR_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level 'high' will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from 'low-to-high' will generate the interrupt.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN14</name>
              <description>Port [A/B/C/D/E/F] Interrupt Enabled By Input Rising Edge Or Input Level High\nIR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function.\nWhen setting the IR_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level 'high' will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from 'low-to-high' will generate the interrupt.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN15</name>
              <description>Port [A/B/C/D/E/F] Interrupt Enabled By Input Rising Edge Or Input Level High\nIR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function.\nWhen setting the IR_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level 'high' will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from 'low-to-high' will generate the interrupt.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPIOA_ISRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPIOA_ISRC</displayName>
          <description>GPIO Port A Interrupt Source Flag</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ISRC0</name>
              <description>Port [A/B/C/D/E/F] Interrupt Source Flag\nRead :</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at GPIOx[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOx[n] generates an interrupt.\nClear the corresponding pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC1</name>
              <description>Port [A/B/C/D/E/F] Interrupt Source Flag\nRead :</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at GPIOx[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOx[n] generates an interrupt.\nClear the corresponding pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC2</name>
              <description>Port [A/B/C/D/E/F] Interrupt Source Flag\nRead :</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at GPIOx[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOx[n] generates an interrupt.\nClear the corresponding pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC3</name>
              <description>Port [A/B/C/D/E/F] Interrupt Source Flag\nRead :</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at GPIOx[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOx[n] generates an interrupt.\nClear the corresponding pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC4</name>
              <description>Port [A/B/C/D/E/F] Interrupt Source Flag\nRead :</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at GPIOx[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOx[n] generates an interrupt.\nClear the corresponding pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC5</name>
              <description>Port [A/B/C/D/E/F] Interrupt Source Flag\nRead :</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at GPIOx[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOx[n] generates an interrupt.\nClear the corresponding pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC6</name>
              <description>Port [A/B/C/D/E/F] Interrupt Source Flag\nRead :</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at GPIOx[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOx[n] generates an interrupt.\nClear the corresponding pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC7</name>
              <description>Port [A/B/C/D/E/F] Interrupt Source Flag\nRead :</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at GPIOx[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOx[n] generates an interrupt.\nClear the corresponding pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC8</name>
              <description>Port [A/B/C/D/E/F] Interrupt Source Flag\nRead :</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at GPIOx[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOx[n] generates an interrupt.\nClear the corresponding pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC9</name>
              <description>Port [A/B/C/D/E/F] Interrupt Source Flag\nRead :</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at GPIOx[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOx[n] generates an interrupt.\nClear the corresponding pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC10</name>
              <description>Port [A/B/C/D/E/F] Interrupt Source Flag\nRead :</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at GPIOx[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOx[n] generates an interrupt.\nClear the corresponding pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC11</name>
              <description>Port [A/B/C/D/E/F] Interrupt Source Flag\nRead :</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at GPIOx[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOx[n] generates an interrupt.\nClear the corresponding pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC12</name>
              <description>Port [A/B/C/D/E/F] Interrupt Source Flag\nRead :</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at GPIOx[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOx[n] generates an interrupt.\nClear the corresponding pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC13</name>
              <description>Port [A/B/C/D/E/F] Interrupt Source Flag\nRead :</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at GPIOx[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOx[n] generates an interrupt.\nClear the corresponding pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC14</name>
              <description>Port [A/B/C/D/E/F] Interrupt Source Flag\nRead :</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at GPIOx[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOx[n] generates an interrupt.\nClear the corresponding pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC15</name>
              <description>Port [A/B/C/D/E/F] Interrupt Source Flag\nRead :</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at GPIOx[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOx[n] generates an interrupt.\nClear the corresponding pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="GPIOA_PMD">
          <name>GPIOB_PMD</name>
          <displayName>GPIOB_PMD</displayName>
          <description>GPIO Port B Pin I/O Mode Control</description>
          <addressOffset>0x40</addressOffset>
       </register>
       <register derivedFrom="GPIOA_OFFD">
          <name>GPIOB_OFFD</name>
          <displayName>GPIOB_OFFD</displayName>
          <description>GPIO Port B Pin Digital Input Path Disable Control</description>
          <addressOffset>0x44</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DOUT">
          <name>GPIOB_DOUT</name>
          <displayName>GPIOB_DOUT</displayName>
          <description>GPIO Port B Data Output Value</description>
          <addressOffset>0x48</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DMASK">
          <name>GPIOB_DMASK</name>
          <displayName>GPIOB_DMASK</displayName>
          <description>GPIO Port B Data Output Write Mask</description>
          <addressOffset>0x4C</addressOffset>
       </register>
       <register derivedFrom="GPIOA_PIN">
          <name>GPIOB_PIN</name>
          <displayName>GPIOB_PIN</displayName>
          <description>GPIO Port B Pin Value</description>
          <addressOffset>0x50</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DBEN">
          <name>GPIOB_DBEN</name>
          <displayName>GPIOB_DBEN</displayName>
          <description>GPIO Port B De-bounce Enable</description>
          <addressOffset>0x54</addressOffset>
       </register>
       <register derivedFrom="GPIOA_IMD">
          <name>GPIOB_IMD</name>
          <displayName>GPIOB_IMD</displayName>
          <description>GPIO Port B Interrupt Mode Control</description>
          <addressOffset>0x58</addressOffset>
       </register>
       <register derivedFrom="GPIOA_IEN">
          <name>GPIOB_IEN</name>
          <displayName>GPIOB_IEN</displayName>
          <description>GPIO Port B Interrupt Enable</description>
          <addressOffset>0x5C</addressOffset>
       </register>
       <register derivedFrom="GPIOA_ISRC">
          <name>GPIOB_ISRC</name>
          <displayName>GPIOB_ISRC</displayName>
          <description>GPIO Port B Interrupt Source Flag</description>
          <addressOffset>0x60</addressOffset>
       </register>
       <register derivedFrom="GPIOA_PMD">
          <name>GPIOC_PMD</name>
          <displayName>GPIOC_PMD</displayName>
          <description>GPIO Port C Pin I/O Mode Control</description>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="GPIOA_OFFD">
          <name>GPIOC_OFFD</name>
          <displayName>GPIOC_OFFD</displayName>
          <description>GPIO Port C Pin Digital Input Path Disable Control</description>
          <addressOffset>0x84</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DOUT">
          <name>GPIOC_DOUT</name>
          <displayName>GPIOC_DOUT</displayName>
          <description>GPIO Port C Data Output Value</description>
          <addressOffset>0x88</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DMASK">
          <name>GPIOC_DMASK</name>
          <displayName>GPIOC_DMASK</displayName>
          <description>GPIO Port C Data Output Write Mask</description>
          <addressOffset>0x8C</addressOffset>
       </register>
       <register derivedFrom="GPIOA_PIN">
          <name>GPIOC_PIN</name>
          <displayName>GPIOC_PIN</displayName>
          <description>GPIO Port C Pin Value</description>
          <addressOffset>0x90</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DBEN">
          <name>GPIOC_DBEN</name>
          <displayName>GPIOC_DBEN</displayName>
          <description>GPIO Port C De-bounce Enable</description>
          <addressOffset>0x94</addressOffset>
       </register>
       <register derivedFrom="GPIOA_IMD">
          <name>GPIOC_IMD</name>
          <displayName>GPIOC_IMD</displayName>
          <description>GPIO Port C Interrupt Mode Control</description>
          <addressOffset>0x98</addressOffset>
       </register>
       <register derivedFrom="GPIOA_IEN">
          <name>GPIOC_IEN</name>
          <displayName>GPIOC_IEN</displayName>
          <description>GPIO Port C Interrupt Enable</description>
          <addressOffset>0x9C</addressOffset>
       </register>
       <register derivedFrom="GPIOA_ISRC">
          <name>GPIOC_ISRC</name>
          <displayName>GPIOC_ISRC</displayName>
          <description>GPIO Port C Interrupt Source Flag</description>
          <addressOffset>0xA0</addressOffset>
       </register>
       <register derivedFrom="GPIOA_PMD">
          <name>GPIOD_PMD</name>
          <displayName>GPIOD_PMD</displayName>
          <description>GPIO Port D Pin I/O Mode Control</description>
          <addressOffset>0xC0</addressOffset>
       </register>
       <register derivedFrom="GPIOA_OFFD">
          <name>GPIOD_OFFD</name>
          <displayName>GPIOD_OFFD</displayName>
          <description>GPIO Port D Pin Digital Input Path Disable Control</description>
          <addressOffset>0xC4</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DOUT">
          <name>GPIOD_DOUT</name>
          <displayName>GPIOD_DOUT</displayName>
          <description>GPIO Port D Data Output Value</description>
          <addressOffset>0xC8</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DMASK">
          <name>GPIOD_DMASK</name>
          <displayName>GPIOD_DMASK</displayName>
          <description>GPIO Port D Data Output Write Mask</description>
          <addressOffset>0xCC</addressOffset>
       </register>
       <register derivedFrom="GPIOA_PIN">
          <name>GPIOD_PIN</name>
          <displayName>GPIOD_PIN</displayName>
          <description>GPIO Port D Pin Value</description>
          <addressOffset>0xD0</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DBEN">
          <name>GPIOD_DBEN</name>
          <displayName>GPIOD_DBEN</displayName>
          <description>GPIO Port D De-bounce Enable</description>
          <addressOffset>0xD4</addressOffset>
       </register>
       <register derivedFrom="GPIOA_IMD">
          <name>GPIOD_IMD</name>
          <displayName>GPIOD_IMD</displayName>
          <description>GPIO Port D Interrupt Mode Control</description>
          <addressOffset>0xD8</addressOffset>
       </register>
       <register derivedFrom="GPIOA_IEN">
          <name>GPIOD_IEN</name>
          <displayName>GPIOD_IEN</displayName>
          <description>GPIO Port D Interrupt Enable</description>
          <addressOffset>0xDC</addressOffset>
       </register>
       <register derivedFrom="GPIOA_ISRC">
          <name>GPIOD_ISRC</name>
          <displayName>GPIOD_ISRC</displayName>
          <description>GPIO Port D Interrupt Source Flag</description>
          <addressOffset>0xE0</addressOffset>
       </register>
       <register derivedFrom="GPIOA_PMD">
          <name>GPIOE_PMD</name>
          <displayName>GPIOE_PMD</displayName>
          <description>GPIO Port E Pin I/O Mode Control</description>
          <addressOffset>0x100</addressOffset>
       </register>
       <register derivedFrom="GPIOA_OFFD">
          <name>GPIOE_OFFD</name>
          <displayName>GPIOE_OFFD</displayName>
          <description>GPIO Port E Pin Digital Input Path Disable Control</description>
          <addressOffset>0x104</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DOUT">
          <name>GPIOE_DOUT</name>
          <displayName>GPIOE_DOUT</displayName>
          <description>GPIO Port E Data Output Value</description>
          <addressOffset>0x108</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DMASK">
          <name>GPIOE_DMASK</name>
          <displayName>GPIOE_DMASK</displayName>
          <description>GPIO Port E Data Output Write Mask</description>
          <addressOffset>0x10C</addressOffset>
       </register>
       <register derivedFrom="GPIOA_PIN">
          <name>GPIOE_PIN</name>
          <displayName>GPIOE_PIN</displayName>
          <description>GPIO Port E Pin Value</description>
          <addressOffset>0x110</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DBEN">
          <name>GPIOE_DBEN</name>
          <displayName>GPIOE_DBEN</displayName>
          <description>GPIO Port E De-bounce Enable</description>
          <addressOffset>0x114</addressOffset>
       </register>
       <register derivedFrom="GPIOA_IMD">
          <name>GPIOE_IMD</name>
          <displayName>GPIOE_IMD</displayName>
          <description>GPIO Port E Interrupt Mode Control</description>
          <addressOffset>0x118</addressOffset>
       </register>
       <register derivedFrom="GPIOA_IEN">
          <name>GPIOE_IEN</name>
          <displayName>GPIOE_IEN</displayName>
          <description>GPIO Port E Interrupt Enable</description>
          <addressOffset>0x11C</addressOffset>
       </register>
       <register derivedFrom="GPIOA_ISRC">
          <name>GPIOE_ISRC</name>
          <displayName>GPIOE_ISRC</displayName>
          <description>GPIO Port E Interrupt Source Flag</description>
          <addressOffset>0x120</addressOffset>
       </register>
       <register derivedFrom="GPIOA_PMD">
          <name>GPIOF_PMD</name>
          <displayName>GPIOF_PMD</displayName>
          <description>GPIO Port F Pin I/O Mode Control</description>
          <addressOffset>0x140</addressOffset>
       </register>
       <register derivedFrom="GPIOA_OFFD">
          <name>GPIOF_OFFD</name>
          <displayName>GPIOF_OFFD</displayName>
          <description>GPIO Port F Pin Digital Input Path Disable Control</description>
          <addressOffset>0x144</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DOUT">
          <name>GPIOF_DOUT</name>
          <displayName>GPIOF_DOUT</displayName>
          <description>GPIO Port F Data Output Value</description>
          <addressOffset>0x148</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DMASK">
          <name>GPIOF_DMASK</name>
          <displayName>GPIOF_DMASK</displayName>
          <description>GPIO Port F Data Output Write Mask</description>
          <addressOffset>0x14C</addressOffset>
       </register>
       <register derivedFrom="GPIOA_PIN">
          <name>GPIOF_PIN</name>
          <displayName>GPIOF_PIN</displayName>
          <description>GPIO Port F Pin Value</description>
          <addressOffset>0x150</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DBEN">
          <name>GPIOF_DBEN</name>
          <displayName>GPIOF_DBEN</displayName>
          <description>GPIO Port F De-bounce Enable</description>
          <addressOffset>0x154</addressOffset>
       </register>
       <register derivedFrom="GPIOA_IMD">
          <name>GPIOF_IMD</name>
          <displayName>GPIOF_IMD</displayName>
          <description>GPIO Port F Interrupt Mode Control</description>
          <addressOffset>0x158</addressOffset>
       </register>
       <register derivedFrom="GPIOA_IEN">
          <name>GPIOF_IEN</name>
          <displayName>GPIOF_IEN</displayName>
          <description>GPIO Port F Interrupt Enable</description>
          <addressOffset>0x15C</addressOffset>
       </register>
       <register derivedFrom="GPIOA_ISRC">
          <name>GPIOF_ISRC</name>
          <displayName>GPIOF_ISRC</displayName>
          <description>GPIO Port F Interrupt Source Flag</description>
          <addressOffset>0x160</addressOffset>
       </register>
       <register>
          <name>DBNCECON</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>DBNCECON</displayName>
          <description>External Interrupt De-bounce Control</description>
          <addressOffset>0x180</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000020</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DBCLKSEL</name>
              <description>De-Bounce Sampling Cycle Selection</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DBCLKSRC</name>
              <description>De-Bounce Counter Clock Source Selection</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>De-bounce counter clock source is the HCLK</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>De-bounce counter clock source is the internal 10 kHz low speed oscillator</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ICLK_ON</name>
              <description>Interrupt Clock On Mode\nIt is recommended to disable this bit to save system power if no special application concern.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge detection circuit is active only if I/O pin corresponding GPIOx_IEN bit is set to 1</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>All I/O pins edge detection circuit is always active after reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PA0_PDIO</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PA0_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output</description>
          <addressOffset>0x200</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFF0</resetMask>
          <fields>
            <field>
              <name>Pxn_PDIO</name>
              <description>GPIO Px.N Pin Data Input/Output\nWrite this bit can control one GPIO pin output value.\nRead this register to get GPIO pin status.\nFor example: writing PA0_PDIO will reflect the written value to bit GPIOA_DOUT[0], read PA0_PDIO will return the value of GPIOA_PIN[0].\nNote: The write operation will not be affected by register GPIOx_DMASK.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding GPIO pin set to low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding GPIO pin set to high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA1_PDIO</name>
          <displayName>PA1_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output</description>
          <addressOffset>0x204</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA2_PDIO</name>
          <displayName>PA2_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output</description>
          <addressOffset>0x208</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA3_PDIO</name>
          <displayName>PA3_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output</description>
          <addressOffset>0x20C</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA4_PDIO</name>
          <displayName>PA4_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output</description>
          <addressOffset>0x210</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA5_PDIO</name>
          <displayName>PA5_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output</description>
          <addressOffset>0x214</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA6_PDIO</name>
          <displayName>PA6_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output</description>
          <addressOffset>0x218</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA7_PDIO</name>
          <displayName>PA7_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output</description>
          <addressOffset>0x21C</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA8_PDIO</name>
          <displayName>PA8_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output</description>
          <addressOffset>0x220</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA9_PDIO</name>
          <displayName>PA9_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output</description>
          <addressOffset>0x224</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA10_PDIO</name>
          <displayName>PA10_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output</description>
          <addressOffset>0x228</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA11_PDIO</name>
          <displayName>PA11_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output</description>
          <addressOffset>0x22C</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA12_PDIO</name>
          <displayName>PA12_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output</description>
          <addressOffset>0x230</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA13_PDIO</name>
          <displayName>PA13_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output</description>
          <addressOffset>0x234</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA14_PDIO</name>
          <displayName>PA14_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output</description>
          <addressOffset>0x238</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA15_PDIO</name>
          <displayName>PA15_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output</description>
          <addressOffset>0x23C</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PB0_PDIO</name>
          <displayName>PB0_PDIO</displayName>
          <description>GPIO PB.n Pin Data Input/Output</description>
          <addressOffset>0x240</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB1_PDIO</name>
          <displayName>PB1_PDIO</displayName>
          <description>GPIO PB.n Pin Data Input/Output</description>
          <addressOffset>0x244</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB2_PDIO</name>
          <displayName>PB2_PDIO</displayName>
          <description>GPIO PB.n Pin Data Input/Output</description>
          <addressOffset>0x248</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB3_PDIO</name>
          <displayName>PB3_PDIO</displayName>
          <description>GPIO PB.n Pin Data Input/Output</description>
          <addressOffset>0x24C</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB4_PDIO</name>
          <displayName>PB4_PDIO</displayName>
          <description>GPIO PB.n Pin Data Input/Output</description>
          <addressOffset>0x250</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB5_PDIO</name>
          <displayName>PB5_PDIO</displayName>
          <description>GPIO PB.n Pin Data Input/Output</description>
          <addressOffset>0x254</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB6_PDIO</name>
          <displayName>PB6_PDIO</displayName>
          <description>GPIO PB.n Pin Data Input/Output</description>
          <addressOffset>0x258</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB7_PDIO</name>
          <displayName>PB7_PDIO</displayName>
          <description>GPIO PB.n Pin Data Input/Output</description>
          <addressOffset>0x25C</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB8_PDIO</name>
          <displayName>PB8_PDIO</displayName>
          <description>GPIO PB.n Pin Data Input/Output</description>
          <addressOffset>0x260</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB9_PDIO</name>
          <displayName>PB9_PDIO</displayName>
          <description>GPIO PB.n Pin Data Input/Output</description>
          <addressOffset>0x264</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB10_PDIO</name>
          <displayName>PB10_PDIO</displayName>
          <description>GPIO PB.n Pin Data Input/Output</description>
          <addressOffset>0x268</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB11_PDIO</name>
          <displayName>PB11_PDIO</displayName>
          <description>GPIO PB.n Pin Data Input/Output</description>
          <addressOffset>0x26C</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB12_PDIO</name>
          <displayName>PB12_PDIO</displayName>
          <description>GPIO PB.n Pin Data Input/Output</description>
          <addressOffset>0x270</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB13_PDIO</name>
          <displayName>PB13_PDIO</displayName>
          <description>GPIO PB.n Pin Data Input/Output</description>
          <addressOffset>0x274</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB14_PDIO</name>
          <displayName>PB14_PDIO</displayName>
          <description>GPIO PB.n Pin Data Input/Output</description>
          <addressOffset>0x278</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB15_PDIO</name>
          <displayName>PB15_PDIO</displayName>
          <description>GPIO PB.n Pin Data Input/Output</description>
          <addressOffset>0x27C</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PC0_PDIO</name>
          <displayName>PC0_PDIO</displayName>
          <description>GPIO PC.n Pin Data Input/Output</description>
          <addressOffset>0x280</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC1_PDIO</name>
          <displayName>PC1_PDIO</displayName>
          <description>GPIO PC.n Pin Data Input/Output</description>
          <addressOffset>0x284</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC2_PDIO</name>
          <displayName>PC2_PDIO</displayName>
          <description>GPIO PC.n Pin Data Input/Output</description>
          <addressOffset>0x288</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC3_PDIO</name>
          <displayName>PC3_PDIO</displayName>
          <description>GPIO PC.n Pin Data Input/Output</description>
          <addressOffset>0x28C</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC6_PDIO</name>
          <displayName>PC6_PDIO</displayName>
          <description>GPIO PC.n Pin Data Input/Output</description>
          <addressOffset>0x298</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC7_PDIO</name>
          <displayName>PC7_PDIO</displayName>
          <description>GPIO PC.n Pin Data Input/Output</description>
          <addressOffset>0x29C</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC8_PDIO</name>
          <displayName>PC8_PDIO</displayName>
          <description>GPIO PC.n Pin Data Input/Output</description>
          <addressOffset>0x2A0</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC9_PDIO</name>
          <displayName>PC9_PDIO</displayName>
          <description>GPIO PC.n Pin Data Input/Output</description>
          <addressOffset>0x2A4</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC10_PDIO</name>
          <displayName>PC10_PDIO</displayName>
          <description>GPIO PC.n Pin Data Input/Output</description>
          <addressOffset>0x2A8</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC11_PDIO</name>
          <displayName>PC11_PDIO</displayName>
          <description>GPIO PC.n Pin Data Input/Output</description>
          <addressOffset>0x2AC</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC14_PDIO</name>
          <displayName>PC14_PDIO</displayName>
          <description>GPIO PC.n Pin Data Input/Output</description>
          <addressOffset>0x2B8</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC15_PDIO</name>
          <displayName>PC15_PDIO</displayName>
          <description>GPIO PC.n Pin Data Input/Output</description>
          <addressOffset>0x2BC</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PD6_PDIO</name>
          <displayName>PD6_PDIO</displayName>
          <description>GPIO PD.n Pin Data Input/Output</description>
          <addressOffset>0x2D8</addressOffset>
       </register>
       <register derivedFrom="PD6_PDIO">
          <name>PD7_PDIO</name>
          <displayName>PD7_PDIO</displayName>
          <description>GPIO PD.n Pin Data Input/Output</description>
          <addressOffset>0x2DC</addressOffset>
       </register>
       <register derivedFrom="PD6_PDIO">
          <name>PD14_PDIO</name>
          <displayName>PD14_PDIO</displayName>
          <description>GPIO PD.n Pin Data Input/Output</description>
          <addressOffset>0x2F8</addressOffset>
       </register>
       <register derivedFrom="PD6_PDIO">
          <name>PD15_PDIO</name>
          <displayName>PD15_PDIO</displayName>
          <description>GPIO PD.n Pin Data Input/Output</description>
          <addressOffset>0x2FC</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PE5_PDIO</name>
          <displayName>PE5_PDIO</displayName>
          <description>GPIO PE.n Pin Data Input/Output</description>
          <addressOffset>0x314</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PF0_PDIO</name>
          <displayName>PF0_PDIO</displayName>
          <description>GPIO PF.n Pin Data Input/Output</description>
          <addressOffset>0x340</addressOffset>
       </register>
       <register derivedFrom="PF0_PDIO">
          <name>PF1_PDIO</name>
          <displayName>PF1_PDIO</displayName>
          <description>GPIO PF.n Pin Data Input/Output</description>
          <addressOffset>0x344</addressOffset>
       </register>
       <register derivedFrom="PF0_PDIO">
          <name>PF4_PDIO</name>
          <displayName>PF4_PDIO</displayName>
          <description>GPIO PF.n Pin Data Input/Output</description>
          <addressOffset>0x350</addressOffset>
       </register>
       <register derivedFrom="PF0_PDIO">
          <name>PF5_PDIO</name>
          <displayName>PF5_PDIO</displayName>
          <description>GPIO PF.n Pin Data Input/Output</description>
          <addressOffset>0x354</addressOffset>
       </register>
       <register derivedFrom="PF0_PDIO">
          <name>PF6_PDIO</name>
          <displayName>PF6_PDIO</displayName>
          <description>GPIO PF.n Pin Data Input/Output</description>
          <addressOffset>0x358</addressOffset>
       </register>
       <register derivedFrom="PF0_PDIO">
          <name>PF7_PDIO</name>
          <displayName>PF7_PDIO</displayName>
          <description>GPIO PF.n Pin Data Input/Output</description>
          <addressOffset>0x35C</addressOffset>
       </register>
       <register derivedFrom="PF0_PDIO">
          <name>PF8_PDIO</name>
          <displayName>PF8_PDIO</displayName>
          <description>GPIO PF.n Pin Data Input/Output</description>
          <addressOffset>0x360</addressOffset>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>TMR01</name>
      <description>TIMER Register Map</description>
      <groupName>TIMER</groupName>
      <baseAddress>0x40010000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1C</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x20</offset>
        <size>0x1C</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>TCSR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TCSR0</displayName>
          <description>Timer0 Control and Status Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000005</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRESCALE</name>
              <description>Prescale Counter</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TDR_EN</name>
              <description>Data Load Enable Control\nWhen TDR_EN is set, TDR (Timer Data Register) will be updated continuously with the 24-bit up-timer value as the timer is counting.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer Data Register update Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer Data Register update Enabled while Timer counter is active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRG_SRC_SEL</name>
              <description>Trigger Source Select Bit\nThis bit is used to select trigger source is from Timer time-out interrupt signal or capture interrupt signal.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer time-out interrupt signal is used to trigger PWM</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture interrupt signal is used to trigger PWM</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRG_PWM_EN</name>
              <description>Trigger PWM Enable Control\nIf this bit is set to 1, timer time-out interrupt or capture interrupt can be triggered PWM.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer interrupt trigger PWM Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>If TRG_SRC_SEL (TCSR[18]) = 0, time-out interrupt signal will trigger PWM</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKE_EN</name>
              <description>Wake Up Function Enable Control</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Wake-up trigger event Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Wake-up trigger event Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CTB</name>
              <description>Counter Mode Enable Control \nThis bit is for external counting pin function enabled. When timer is used as an event counter, this bit should be set to 1 and select HCLK as timer clock source. Please refer to 6.6.5.6 for detail description.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>External counter mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>External counter mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CACT</name>
              <description>Timer Active Status (Read Only)\nThis bit indicates the 24-bit up counter status.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>24-bit up counter is not active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>24-bit up counter is active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>CRST</name>
              <description>Timer Reset</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset 8-bit prescale counter, 24-bit up counter value and CEN bit if CACT is 1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>Timer Operating Mode</description>
              <bitOffset>27</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The Timer controller is operated in One-shot mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The Timer controller is operated in Periodic mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>The Timer controller is operated in Toggle-output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>The Timer controller is operated in Continuous Counting mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IE</name>
              <description>Interrupt Enable Control\nIf this bit is enabled, when the timer interrupt flag TIF (TISR[0]) is set to 1, the timer interrupt signal is generated and inform to CPU.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer Interrupt function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer Interrupt function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CEN</name>
              <description>Timer Enable Control</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Stops/Suspends counting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Starts counting</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBGACK_TMR</name>
              <description>ICE Debug Mode Acknowledge Disable Control (Write Protect)\nTIMER counter will keep going no matter CPU is held by ICE or not.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ICE debug mode acknowledgement effects TIMER counting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ICE debug mode acknowledgement Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TCMPR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TCMPR0</displayName>
          <description>Timer0 Compare Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TCMP</name>
              <description>Timer Compared Value\nTCMP is a 24-bit compared value register. When the internal 24-bit up counter value is equal to TCMP value, the TIF flag will set to 1.\nNote1: Never write 0x0 or 0x1 in TCMP field, or the core will run into unknown state.\nNote2: When timer is operating at continuous counting mode, the 24-bit up counter will keep counting continuously even if user writes a new value into TCMP field. But if timer is operating at other modes, the 24-bit up counter will restart counting and using newest TCMP value to be the timer compared value if user writes a new value into TCMP field.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TISR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TISR0</displayName>
          <description>Timer0 Interrupt Status Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TIF</name>
              <description>Timer Interrupt Flag\nThis bit indicates the interrupt flag status of Timer while TDR value reaches to TCMP value.\nNote: This bit is cleared by writing 1 to it.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TDR value matches the TCMP value</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TWF</name>
              <description>Timer Wake-Up Flag\nThis bit indicates the interrupt wake-up flag status of Timer.\nNote: This bit is cleared by writing 1 to it.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer does not cause CPU wake-up</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CPU wake-up from Idle or Power-down mode if Timer time-out interrupt signal generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TDR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TDR0</displayName>
          <description>Timer0 Data Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TDR</name>
              <description>Timer Data Register\nIf TDR_EN (TCSR[16]) is set to 1, TDR register will be updated continuously to monitor 24-bit up counter value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TCAP0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TCAP0</displayName>
          <description>Timer0 Capture Data Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TCAP</name>
              <description>Timer Capture Data Register\nWhen TEXIF (TEXISR[0]) flag and RSTCAPSEL (TEXCON[4]) is set to 1, the current TDR value will be auto-loaded into this TCAP filed immediately.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TEXCON0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TEXCON0</displayName>
          <description>Timer0 External Control Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX_PHASE</name>
              <description>Timer External Count Pin Phase Detect Selection\nThis bit indicates the detection phase of TMx_EXT pin.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>A falling edge of TMx_EXT pin will be counted</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>A rising edge of TMx_EXT pin will be counted</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TEX_EDGE</name>
              <description>Timer External Capture Pin Edge Detect Selection</description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>A 1 to 0 transition on TMx_EXT pin will be detected</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>A 0 to 1 transition on TMx_EXT pin will be detected</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Either 1 to 0 or 0 to 1 transition on TMx_EXT pin will be detected</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved.</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TEXEN</name>
              <description>Timer External Pin Function Enable Control\nThis bit enables the RSTCAPSEL function on the TMx_EXT pin.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RSTCAPSEL function of TMx_EXT pin will be ignored</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RSTCAPSEL function of TMx_EXT pin is active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RSTCAPSEL</name>
              <description>Timer External Reset Counter / Timer External Capture Mode Selection</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transition on TMx_EXT pin is using to save the TDR value into TCAP.(event capture function)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transition on TMx_EXT pin is using to reset the 24-bit up counter.(event reset counter function)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TEXIEN</name>
              <description>Timer External Capture Interrupt Enable Control\nIf TEXIEN enabled, Timer will raise an external capture interrupt signal and inform to CPU while TEXIF flag is set to 1.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TMx_EXT pin detection Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TMx_EXT pin detection Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TEXDB</name>
              <description>Timer External Capture Input Pin De-Bounce Enable Control\nIf this bit is enabled, the edge detection of TMx_EXT pin is detected with de-bounce circuit.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TMx_EXT pin de-bounce Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TMx_EXT pin de-bounce Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TCDB</name>
              <description>Timer External Counter Input Pin De-Bounce Enable Control\nIf this bit is enabled, the edge detection of TMx pin is detected with de-bounce circuit.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TMx pin de-bounce Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TMx pin de-bounce Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TEXISR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TEXISR0</displayName>
          <description>Timer0 External Interrupt Status Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TEXIF</name>
              <description>Timer External Capture Interrupt Flag\nThis bit indicates the external capture interrupt flag status.\nWhen TEXEN (TEXCON[3]) enabled, TMx_EXT pin selected as external capture function, and a transition on TMx_EXT pin matched the TEX_EDGE (TEXCON[2:1]) setting, this flag will set to 1 by hardware.\nNote: This bit is cleared by writing 1 to it.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TMx_EXT pin interrupt did not occur</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TMx_EXT pin interrupt occurred</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="TCSR0">
          <name>TCSR1</name>
          <displayName>TCSR1</displayName>
          <description>Timer1 Control and Status Register</description>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="TCMPR0">
          <name>TCMPR1</name>
          <displayName>TCMPR1</displayName>
          <description>Timer1 Compare Register</description>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="TISR0">
          <name>TISR1</name>
          <displayName>TISR1</displayName>
          <description>Timer1 Interrupt Status Register</description>
          <addressOffset>0x28</addressOffset>
       </register>
       <register derivedFrom="TDR0">
          <name>TDR1</name>
          <displayName>TDR1</displayName>
          <description>Timer1 Data Register</description>
          <addressOffset>0x2C</addressOffset>
       </register>
       <register derivedFrom="TCAP0">
          <name>TCAP1</name>
          <displayName>TCAP1</displayName>
          <description>Timer1 Capture Data Register</description>
          <addressOffset>0x30</addressOffset>
       </register>
       <register derivedFrom="TEXCON0">
          <name>TEXCON1</name>
          <displayName>TEXCON1</displayName>
          <description>Timer1 External Control Register</description>
          <addressOffset>0x34</addressOffset>
       </register>
       <register derivedFrom="TEXISR0">
          <name>TEXISR1</name>
          <displayName>TEXISR1</displayName>
          <description>Timer1 External Interrupt Status Register</description>
          <addressOffset>0x38</addressOffset>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>TMR23</name>
      <description>TIMER Register Map</description>
      <groupName>TIMER</groupName>
      <baseAddress>0x40110000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1C</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x20</offset>
        <size>0x1C</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>TCSR2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TCSR2</displayName>
          <description>Timer2 Control and Status Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000005</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRESCALE</name>
              <description>Prescale Counter</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TDR_EN</name>
              <description>Data Load Enable Control\nWhen TDR_EN is set, TDR (Timer Data Register) will be updated continuously with the 24-bit up-timer value as the timer is counting.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer Data Register update Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer Data Register update Enabled while Timer counter is active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRG_SRC_SEL</name>
              <description>Trigger Source Select Bit\nThis bit is used to select trigger source is from Timer time-out interrupt signal or capture interrupt signal.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer time-out interrupt signal is used to trigger PWM</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture interrupt signal is used to trigger PWM</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRG_PWM_EN</name>
              <description>Trigger PWM Enable Control\nIf this bit is set to 1, timer time-out interrupt or capture interrupt can be triggered PWM.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer interrupt trigger PWM Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>If TRG_SRC_SEL (TCSR[18]) = 0, time-out interrupt signal will trigger PWM</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKE_EN</name>
              <description>Wake Up Function Enable Control</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Wake-up trigger event Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Wake-up trigger event Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CTB</name>
              <description>Counter Mode Enable Control \nThis bit is for external counting pin function enabled. When timer is used as an event counter, this bit should be set to 1 and select HCLK as timer clock source. Please refer to 6.6.5.6 for detail description.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>External counter mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>External counter mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CACT</name>
              <description>Timer Active Status (Read Only)\nThis bit indicates the 24-bit up counter status.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>24-bit up counter is not active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>24-bit up counter is active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>CRST</name>
              <description>Timer Reset</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset 8-bit prescale counter, 24-bit up counter value and CEN bit if CACT is 1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>Timer Operating Mode</description>
              <bitOffset>27</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The Timer controller is operated in One-shot mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The Timer controller is operated in Periodic mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>The Timer controller is operated in Toggle-output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>The Timer controller is operated in Continuous Counting mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IE</name>
              <description>Interrupt Enable Control\nIf this bit is enabled, when the timer interrupt flag TIF (TISR[0]) is set to 1, the timer interrupt signal is generated and inform to CPU.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer Interrupt function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer Interrupt function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CEN</name>
              <description>Timer Enable Control</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Stops/Suspends counting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Starts counting</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBGACK_TMR</name>
              <description>ICE Debug Mode Acknowledge Disable Control (Write Protect)\nTIMER counter will keep going no matter CPU is held by ICE or not.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ICE debug mode acknowledgement effects TIMER counting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ICE debug mode acknowledgement Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TCMPR2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TCMPR2</displayName>
          <description>Timer2 Compare Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TCMP</name>
              <description>Timer Compared Value\nTCMP is a 24-bit compared value register. When the internal 24-bit up counter value is equal to TCMP value, the TIF flag will set to 1.\nNote1: Never write 0x0 or 0x1 in TCMP field, or the core will run into unknown state.\nNote2: When timer is operating at continuous counting mode, the 24-bit up counter will keep counting continuously even if user writes a new value into TCMP field. But if timer is operating at other modes, the 24-bit up counter will restart counting and using newest TCMP value to be the timer compared value if user writes a new value into TCMP field.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TISR2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TISR2</displayName>
          <description>Timer2 Interrupt Status Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TIF</name>
              <description>Timer Interrupt Flag\nThis bit indicates the interrupt flag status of Timer while TDR value reaches to TCMP value.\nNote: This bit is cleared by writing 1 to it.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TDR value matches the TCMP value</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TWF</name>
              <description>Timer Wake-Up Flag\nThis bit indicates the interrupt wake-up flag status of Timer.\nNote: This bit is cleared by writing 1 to it.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer does not cause CPU wake-up</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CPU wake-up from Idle or Power-down mode if Timer time-out interrupt signal generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TDR2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TDR2</displayName>
          <description>Timer2 Data Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TDR</name>
              <description>Timer Data Register\nIf TDR_EN (TCSR[16]) is set to 1, TDR register will be updated continuously to monitor 24-bit up counter value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TCAP2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TCAP2</displayName>
          <description>Timer2 Capture Data Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TCAP</name>
              <description>Timer Capture Data Register\nWhen TEXIF (TEXISR[0]) flag and RSTCAPSEL (TEXCON[4]) is set to 1, the current TDR value will be auto-loaded into this TCAP filed immediately.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TEXCON2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TEXCON2</displayName>
          <description>Timer2 External Control Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX_PHASE</name>
              <description>Timer External Count Pin Phase Detect Selection\nThis bit indicates the detection phase of TMx_EXT pin.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>A falling edge of TMx_EXT pin will be counted</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>A rising edge of TMx_EXT pin will be counted</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TEX_EDGE</name>
              <description>Timer External Capture Pin Edge Detect Selection</description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>A 1 to 0 transition on TMx_EXT pin will be detected</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>A 0 to 1 transition on TMx_EXT pin will be detected</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Either 1 to 0 or 0 to 1 transition on TMx_EXT pin will be detected</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved.</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TEXEN</name>
              <description>Timer External Pin Function Enable Control\nThis bit enables the RSTCAPSEL function on the TMx_EXT pin.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RSTCAPSEL function of TMx_EXT pin will be ignored</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RSTCAPSEL function of TMx_EXT pin is active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RSTCAPSEL</name>
              <description>Timer External Reset Counter / Timer External Capture Mode Selection</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transition on TMx_EXT pin is using to save the TDR value into TCAP.(event capture function)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transition on TMx_EXT pin is using to reset the 24-bit up counter.(event reset counter function)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TEXIEN</name>
              <description>Timer External Capture Interrupt Enable Control\nIf TEXIEN enabled, Timer will raise an external capture interrupt signal and inform to CPU while TEXIF flag is set to 1.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TMx_EXT pin detection Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TMx_EXT pin detection Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TEXDB</name>
              <description>Timer External Capture Input Pin De-Bounce Enable Control\nIf this bit is enabled, the edge detection of TMx_EXT pin is detected with de-bounce circuit.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TMx_EXT pin de-bounce Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TMx_EXT pin de-bounce Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TCDB</name>
              <description>Timer External Counter Input Pin De-Bounce Enable Control\nIf this bit is enabled, the edge detection of TMx pin is detected with de-bounce circuit.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TMx pin de-bounce Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TMx pin de-bounce Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TEXISR2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TEXISR2</displayName>
          <description>Timer2 External Interrupt Status Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TEXIF</name>
              <description>Timer External Capture Interrupt Flag\nThis bit indicates the external capture interrupt flag status.\nWhen TEXEN (TEXCON[3]) enabled, TMx_EXT pin selected as external capture function, and a transition on TMx_EXT pin matched the TEX_EDGE (TEXCON[2:1]) setting, this flag will set to 1 by hardware.\nNote: This bit is cleared by writing 1 to it.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TMx_EXT pin interrupt did not occur</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TMx_EXT pin interrupt occurred</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="TCSR2">
          <name>TCSR3</name>
          <displayName>TCSR3</displayName>
          <description>Timer3 Control and Status Register</description>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="TCMPR2">
          <name>TCMPR3</name>
          <displayName>TCMPR3</displayName>
          <description>Timer3 Compare Register</description>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="TISR2">
          <name>TISR3</name>
          <displayName>TISR3</displayName>
          <description>Timer3 Interrupt Status Register</description>
          <addressOffset>0x28</addressOffset>
       </register>
       <register derivedFrom="TDR2">
          <name>TDR3</name>
          <displayName>TDR3</displayName>
          <description>Timer3 Data Register</description>
          <addressOffset>0x2C</addressOffset>
       </register>
       <register derivedFrom="TCAP2">
          <name>TCAP3</name>
          <displayName>TCAP3</displayName>
          <description>Timer3 Capture Data Register</description>
          <addressOffset>0x30</addressOffset>
       </register>
       <register derivedFrom="TEXCON2">
          <name>TEXCON3</name>
          <displayName>TEXCON3</displayName>
          <description>Timer3 External Control Register</description>
          <addressOffset>0x34</addressOffset>
       </register>
       <register derivedFrom="TEXISR2">
          <name>TEXISR3</name>
          <displayName>TEXISR3</displayName>
          <description>Timer3 External Interrupt Status Register</description>
          <addressOffset>0x38</addressOffset>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PWM0</name>
      <description>PWM Register Map</description>
      <groupName>PWM</groupName>
      <baseAddress>0x40040000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x10</offset>
        <size>0x18</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x30</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x38</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x40</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x50</offset>
        <size>0x18</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x70</offset>
        <size>0xC</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x90</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x98</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0xA0</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0xB0</offset>
        <size>0x40</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0xF8</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x110</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x120</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x200</offset>
        <size>0x3C</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x250</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x304</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x30C</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x314</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x31C</offset>
        <size>0x18</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>PWM_CTL0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_CTL0</displayName>
          <description>PWM Control Register 0</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CTRLDn</name>
              <description>Center Re-Load\nEach bit n controls the corresponding PWM channel n.\nIn up-down counter type, PERIOD will load to PBUF at the end point of each period. CMPDAT will load to CMPBUF at the center point of a period.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IMMLDENn</name>
              <description>Immediately Load Enable control\nEach bit n controls the corresponding PWM channel n.\nNote: If IMMLDENn is enabled, WINLDENn and CTRLDn will be invalid.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PERIOD will load to PBUF at the end point of each period. CMPDAT will load to CMPBUF at the end point or center point of each period by setting CTRLD bit</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PERIOD/CMPDAT will load to PBUF and CMPBUF immediately when software update PERIOD/CMPDAT</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBGHALT</name>
              <description>ICE Debug Mode Counter Halt (Write Protect)\nIf counter halt is enabled, PWM all counters will keep current value until exit ICE debug mode. \nNote: This register is write protected. Refer to REGWRPROT register.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ICE debug mode counter halt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ICE debug mode counter halt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBGTRIOFF</name>
              <description>ICE Debug Mode Acknowledge Disable (Write Protect)\nPWM pin will keep output no matter ICE debug mode acknowledged or not.\nNote: This register is write protected. Refer to REGWRPROT register.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ICE debug mode acknowledgement effects PWM output</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ICE debug mode acknowledgement Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM_CTL1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_CTL1</displayName>
          <description>PWM Control Register 1</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNTTYPE0</name>
              <description>PWM Counter Behavior Type 0\nEach bit n controls corresponding PWM channel n.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Up counter type (supports in capture mode)</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Down count type (supports in capture mode)</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Up-down counter type</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved.</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CNTTYPE2</name>
              <description>PWM Counter Behavior Type 2\nEach bit n controls corresponding PWM channel n.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Up counter type (supports in capture mode)</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Down count type (supports in capture mode)</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Up-down counter type</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved.</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CNTTYPE4</name>
              <description>PWM Counter Behavior Type 4\nEach bit n controls corresponding PWM channel n.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Up counter type (supports in capture mode)</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Down count type (supports in capture mode)</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Up-down counter type</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved.</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMMODEn</name>
              <description>PWM Mode\nEach bit n controls the corresponding PWM channel n.\nNote: When operating in group function, these bits must all set to the same mode.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM independent mode</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM complementary mode</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM_CLKSRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_CLKSRC</displayName>
          <description>PWM Clock Source Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ECLKSRC0</name>
              <description>PWM_CH01 External Clock Source Select</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWMx_CLK, x denotes 0 or 1</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TIMER0 overflow</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>TIMER1 overflow</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>TIMER2 overflow</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>TIMER3 overflow</description>
                    <value>#100</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ECLKSRC2</name>
              <description>PWM_CH23 External Clock Source Select</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWMx_CLK, x denotes 0 or 1</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TIMER0 overflow</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>TIMER1 overflow</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>TIMER2 overflow</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>TIMER3 overflow</description>
                    <value>#100</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ECLKSRC4</name>
              <description>PWM_CH45 External Clock Source Select</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWMx_CLK, x denotes 0 or 1</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TIMER0 overflow</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>TIMER1 overflow</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>TIMER2 overflow</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>TIMER3 overflow</description>
                    <value>#100</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM_CLKPSC0_1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_CLKPSC0_1</displayName>
          <description>PWM Clock Pre-scale Register 0_1</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLKPSC</name>
              <description>PWM Counter Clock Pre-Scale \nThe clock of PWM counter is decided by clock prescaler. Each PWM pair share one PWM counter clock prescaler. The clock of PWM counter is divided by (CLKPSC+ 1).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PWM_CLKPSC0_1">
          <name>PWM_CLKPSC2_3</name>
          <displayName>PWM_CLKPSC2_3</displayName>
          <description>PWM Clock Pre-scale Register 2_3</description>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PWM_CLKPSC0_1">
          <name>PWM_CLKPSC4_5</name>
          <displayName>PWM_CLKPSC4_5</displayName>
          <description>PWM Clock Pre-scale Register 4_5</description>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register>
          <name>PWM_CNTEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_CNTEN</displayName>
          <description>PWM Counter Enable Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNTEN0</name>
              <description>PWM Counter Enable 0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM Counter and clock prescaler Stop Running</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM Counter and clock prescaler Start Running</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CNTEN2</name>
              <description>PWM Counter Enable 2</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM Counter and clock prescaler Stop Running</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM Counter and clock prescaler Start Running</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CNTEN4</name>
              <description>PWM Counter Enable 4</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM Counter and clock prescaler Stop Running</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM Counter and clock prescaler Start Running</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM_CNTCLR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_CNTCLR</displayName>
          <description>PWM Clear Counter Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNTCLR0</name>
              <description>Clear PWM Counter Control Bit 0\nIt is automatically cleared by hardware.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clear 16-bit PWM counter to 0000H</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CNTCLR2</name>
              <description>Clear PWM Counter Control Bit 2\nIt is automatically cleared by hardware.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clear 16-bit PWM counter to 0000H</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CNTCLR4</name>
              <description>Clear PWM Counter Control Bit 4\nIt is automatically cleared by hardware.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clear 16-bit PWM counter to 0000H</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM_PERIOD0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_PERIOD0</displayName>
          <description>PWM Period Register 0</description>
          <addressOffset>0x30</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PERIOD</name>
              <description>PWM Period Register\nUp-Count mode: In this mode, PWM counter counts from 0 to PERIOD, and restarts from 0.\nDown-Count mode: In this mode, PWM counter counts from PERIOD to 0, and restarts from PERIOD.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PWM_PERIOD0">
          <name>PWM_PERIOD2</name>
          <displayName>PWM_PERIOD2</displayName>
          <description>PWM Period Register 2</description>
          <addressOffset>0x38</addressOffset>
       </register>
       <register derivedFrom="PWM_PERIOD0">
          <name>PWM_PERIOD4</name>
          <displayName>PWM_PERIOD4</displayName>
          <description>PWM Period Register 4</description>
          <addressOffset>0x40</addressOffset>
       </register>
       <register>
          <name>PWM_CMPDAT0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_CMPDAT0</displayName>
          <description>PWM Comparator Register 0</description>
          <addressOffset>0x50</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMP</name>
              <description>PWM Comparator Register\nCMP use to compare with CNT to generate PWM waveform, interrupt and trigger ADC.\nIn independent mode, PWM_CMPDAT0~5 denote as 6 independent PWM_CH0~5 compared point.\nIn complementary mode, PWM_CMPDAT0, 2, 4 denote as first compared point, and PWM_CMPDAT1, 3, 5 denote as second compared point for the corresponding 3 complementary pairs PWM_CH0 and PWM_CH1, PWM_CH2 and PWM_CH3, PWM_CH4 and PWM_CH5.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PWM_CMPDAT0">
          <name>PWM_CMPDAT1</name>
          <displayName>PWM_CMPDAT1</displayName>
          <description>PWM Comparator Register 1</description>
          <addressOffset>0x54</addressOffset>
       </register>
       <register derivedFrom="PWM_CMPDAT0">
          <name>PWM_CMPDAT2</name>
          <displayName>PWM_CMPDAT2</displayName>
          <description>PWM Comparator Register 2</description>
          <addressOffset>0x58</addressOffset>
       </register>
       <register derivedFrom="PWM_CMPDAT0">
          <name>PWM_CMPDAT3</name>
          <displayName>PWM_CMPDAT3</displayName>
          <description>PWM Comparator Register 3</description>
          <addressOffset>0x5C</addressOffset>
       </register>
       <register derivedFrom="PWM_CMPDAT0">
          <name>PWM_CMPDAT4</name>
          <displayName>PWM_CMPDAT4</displayName>
          <description>PWM Comparator Register 4</description>
          <addressOffset>0x60</addressOffset>
       </register>
       <register derivedFrom="PWM_CMPDAT0">
          <name>PWM_CMPDAT5</name>
          <displayName>PWM_CMPDAT5</displayName>
          <description>PWM Comparator Register 5</description>
          <addressOffset>0x64</addressOffset>
       </register>
       <register>
          <name>PWM_DTCTL0_1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_DTCTL0_1</displayName>
          <description>PWM Dead-time Control Register 0_1</description>
          <addressOffset>0x70</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DTCNT</name>
              <description>Dead-Time Counter (Write Protect)\nThe dead-time can be calculated from the following formula: \nNote: This register is write protected. Refer to REGWRPROT register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DTEN</name>
              <description>Enable Dead-Time Insertion For PWM Pair (PWM_CH0, PWM_CH1) (PWM_CH2, PWM_CH3) (PWM_CH4, PWM_CH5) (Write Protect)\nDead-time insertion is only active when this pair of complementary PWM is enabled. If dead- time insertion is inactive, the outputs of pin pair are complementary without any delay.\nNote: This register is write protected. Refer to REGWRPROT register.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Dead-time insertion Disabled on the pin pair</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Dead-time insertion Enabled on the pin pair</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DTCKSEL</name>
              <description>Dead-Time Clock Select (Write Protect)\nNote: This register is write protected. Refer to REGWRPROT register.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Dead-time clock source from PWM_CLK</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Dead-time clock source from prescaler output</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PWM_DTCTL0_1">
          <name>PWM_DTCTL2_3</name>
          <displayName>PWM_DTCTL2_3</displayName>
          <description>PWM Dead-time Control Register 2_3</description>
          <addressOffset>0x74</addressOffset>
       </register>
       <register derivedFrom="PWM_DTCTL0_1">
          <name>PWM_DTCTL4_5</name>
          <displayName>PWM_DTCTL4_5</displayName>
          <description>PWM Dead-time Control Register 4_5</description>
          <addressOffset>0x78</addressOffset>
       </register>
       <register>
          <name>PWM_CNT0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_CNT0</displayName>
          <description>PWM Counter Register 0</description>
          <addressOffset>0x90</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNT</name>
              <description>PWM Data Register (Read Only)\nUser can monitor CNT to know the current value in 16-bit period counter.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DIRF</name>
              <description>PWM Direction Indicator Flag (Read Only)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Counter is Down count</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Counter is UP count</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PWM_CNT0">
          <name>PWM_CNT2</name>
          <displayName>PWM_CNT2</displayName>
          <description>PWM Counter Register 2</description>
          <addressOffset>0x98</addressOffset>
       </register>
       <register derivedFrom="PWM_CNT0">
          <name>PWM_CNT4</name>
          <displayName>PWM_CNT4</displayName>
          <description>PWM Counter Register 4</description>
          <addressOffset>0xA0</addressOffset>
       </register>
       <register>
          <name>PWM_WGCTL0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_WGCTL0</displayName>
          <description>PWM Generation Register 0</description>
          <addressOffset>0xB0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ZPCTLn</name>
              <description>PWM Zero Point Control\nEach bit n controls the corresponding PWM channel n.\nPWM can control output level when PWM counter count to zero.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Do nothing</description>
                    <value>00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM zero point output Low</description>
                    <value>01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>10</name>
                    <description>PWM zero point output High</description>
                    <value>10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>11</name>
                    <description>PWM zero point output Toggle</description>
                    <value>11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PRDPCTLn</name>
              <description>PWM Period (Center) Point Control\nEach bit n controls the corresponding PWM channel n.\nPWM can control output level when PWM counter count to (PERIODn+1).\nNote: This bit is center point control when PWM counter operating in up-down counter type.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>12</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Do nothing</description>
                    <value>00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM period (center) point output Low</description>
                    <value>01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>10</name>
                    <description>PWM period (center) point output High</description>
                    <value>10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>11</name>
                    <description>PWM period (center) point output Toggle</description>
                    <value>11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM_WGCTL1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_WGCTL1</displayName>
          <description>PWM Generation Register 1</description>
          <addressOffset>0xB4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMPUCTLn</name>
              <description>PWM Compare Up Point Control\nEach bit n controls the corresponding PWM channel n.\nPWM can control output level when PWM counter up count to CMPDAT.\nNote: In complementary mode, CMPUCTL1, 3, 5 use as another CMPUCTL for channel 0, 2, 4.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Do nothing</description>
                    <value>00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM compare up point output Low</description>
                    <value>01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>10</name>
                    <description>PWM compare up point output High</description>
                    <value>10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>11</name>
                    <description>PWM compare up point output Toggle</description>
                    <value>11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPDCTLn</name>
              <description>PWM Compare Down Point Control\nEach bit n controls the corresponding PWM channel n.\nPWM can control output level when PWM counter down count to CMPDAT.\nNote: In complementary mode, CMPDCTL1, 3, 5 use as another CMPDCTL for channel 0, 2, 4.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>12</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Do nothing</description>
                    <value>00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM compare down point output Low</description>
                    <value>01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>10</name>
                    <description>PWM compare down point output High</description>
                    <value>10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>11</name>
                    <description>PWM compare down point output Toggle</description>
                    <value>11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM_MSKEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_MSKEN</displayName>
          <description>PWM Mask Enable Register</description>
          <addressOffset>0xB8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MSKENn</name>
              <description>PWM Mask Enable Control\nEach bit n controls the corresponding PWM channel n.\nThe PWM output signal will be masked when this bit is enabled. The corresponding PWM channel n will output MSKDATn (PWM_MSK[5:0]) data. </description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM output signal is non-masked</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM output signal is masked and output MSKDATn data</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM_MSK</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_MSK</displayName>
          <description>PWM Mask Data Register</description>
          <addressOffset>0xBC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MSKDATn</name>
              <description>PWM Mask Data Bit\nThis data bit control the state of PWMn output pin, if corresponding mask function is enabled. Each bit n controls the corresponding PWM channel n.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Output logic low to PWMn</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Output logic high to PWMn</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM_BNF</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_BNF</displayName>
          <description>PWM Brake Noise Filter Register</description>
          <addressOffset>0xC0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BRK0FEN</name>
              <description>PWM Brake 0 Noise Filter Enable Control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Noise filter of PWM Brake 0 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Noise filter of PWM Brake 0 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRK0FCS</name>
              <description>Brake 0 Edge Detector Filter Clock Selection</description>
              <bitOffset>1</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Filter clock is HCLK</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Filter clock is HCLK/2</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Filter clock is HCLK/4</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Filter clock is HCLK/8</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>Filter clock is HCLK/16</description>
                    <value>#100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Filter clock is HCLK/32</description>
                    <value>#101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Filter clock is HCLK/64</description>
                    <value>#110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Filter clock is HCLK/128</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRK0FCNT</name>
              <description>Brake 0 Edge Detector Filter Count\nThe register bits control the Brake0 filter counter to count from 0 to BRK1FCNT.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BRK0PINV</name>
              <description>Brake 0 Pin Inverse</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The state of pin PWMx_BRAKE0 is passed to the negative edge detector</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The inversed state of pin PWMx_BRAKE10 is passed to the negative edge detector</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRK1FEN</name>
              <description>PWM Brake 1 Noise Filter Enable Control</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Noise filter of PWM Brake 1 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Noise filter of PWM Brake 1 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRK1FCS</name>
              <description>Brake 1 Edge Detector Filter Clock Selection</description>
              <bitOffset>9</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Filter clock = HCLK</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Filter clock = HCLK/2</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Filter clock = HCLK/4</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Filter clock = HCLK/8</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>Filter clock = HCLK/16</description>
                    <value>#100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Filter clock = HCLK/32</description>
                    <value>#101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Filter clock = HCLK/64</description>
                    <value>#110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Filter clock = HCLK/128</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRK1FCNT</name>
              <description>Brake 1 Edge Detector Filter Count\nThe register bits control the Brake1 filter counter to count from 0 to BRK1FCNT.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BRK1PINV</name>
              <description>Brake 1 Pin Inverse</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The state of pin PWMx_BRAKE1 is passed to the negative edge detector</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The inversed state of pin PWMx_BRAKE1 is passed to the negative edge detector</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BK0SRC</name>
              <description>Brake 0 Pin Source Select\nFor PWM0 setting:</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Brake 0 pin source come from PWM0_BRAKE0.\nBrake 0 pin source come from PWM1_BRAKE0</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Brake 0 pin source come from PWM1_BRAKE0.\nBrake 0 pin source come from PWM0_BRAKE0</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BK1SRC</name>
              <description>Brake 1 Pin Source Select\nFor PWM0 setting:</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Brake 1 pin source come from PWM0_BRAKE1.\nBrake 1 pin source come from PWM1_BRAKE1</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Brake 1 pin source come from PWM1_BRAKE1.\nBrake 1 pin source come from PWM0_BRAKE1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM_FAILBRK</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_FAILBRK</displayName>
          <description>PWM System Fail Brake Control Register</description>
          <addressOffset>0xC4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CSSBRKEN</name>
              <description>Clock Security System Detection Trigger PWM Brake Function 0 Enable Control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Brake Function triggered by CSS detection Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Brake Function triggered by CSS detection Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BODBRKEN</name>
              <description>Brown-Out Detection Trigger PWM Brake Function 0 Enable Control</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Brake Function triggered by BOD Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Brake Function triggered by BOD Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CORBRKEN</name>
              <description>Core Lockup Detection Trigger PWM Brake Function 0 Enable Control</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Brake Function triggered by Core lockup detection Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Brake Function triggered by Core lockup detection Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM_BRKCTL0_1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_BRKCTL0_1</displayName>
          <description>PWM Brake Edge Detect Control Register 0_1</description>
          <addressOffset>0xC8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BRKP0EEN</name>
              <description>Enable PWMx_BRAKE0 Pin As Edge-Detect Brake Source (Write Protect)\nNote: This register is write protected. Refer to REGWRPROT register.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>BKP0 pin as edge-detect brake source Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>BKP0 pin as edge-detect brake source Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKP1EEN</name>
              <description>Enable PWMx_BRAKE1 Pin As Edge-Detect Brake Source (Write Protect)\nNote: This register is write protected. Refer to REGWRPROT register.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>BKP1 pin as edge-detect brake source Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>BKP1 pin as edge-detect brake source Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SYSEEN</name>
              <description>Enable System Fail As Edge-Detect Brake Source (Write Protect)\nNote: This register is write protected. Refer to REGWRPROT register.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>System Fail condition as edge-detect brake source Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>System Fail condition as edge-detect brake source Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKP0LEN</name>
              <description>Enable BKP0 Pin As Level-Detect Brake Source (Write Protect)\nNote: This register is write protected. Refer to REGWRPROT register.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWMx_BRAKE0 pin as level-detect brake source Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWMx_BRAKE0 pin as level-detect brake source Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKP1LEN</name>
              <description>Enable BKP1 Pin As Level-Detect Brake Source (Write Protect)\nNote: This register is write protected. Refer to REGWRPROT register.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWMx_BRAKE1 pin as level-detect brake source Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWMx_BRAKE1 pin as level-detect brake source Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SYSLEN</name>
              <description>Enable System Fail As Level-Detect Brake Source (Write Protect)\nNote: This register is write protected. Refer to REGWRPROT register.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>System Fail condition as level-detect brake source Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>System Fail condition as level-detect brake source Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKAEVEN</name>
              <description>PWM Brake Action Select For Even Channel (Write Protect)\nNote: This register is write protected. Refer to REGWRPROT register.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM even channel level-detect brake function not affect channel output</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM even channel output tri-state when level-detect brake happened</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>PWM even channel output low level when level-detect brake happened</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>PWM even channel output high level when level-detect brake happened</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKAODD</name>
              <description>PWM Brake Action Select For Odd Channel (Write Protect)\nNote: This register is write protected. Refer to REGWRPROT register.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM odd channel level-detect brake function not affect channel output</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM odd channel output tri-state when level-detect brake happened</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>PWM odd channel output low level when level-detect brake happened</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>PWM odd channel output high level when level-detect brake happened</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PWM_BRKCTL0_1">
          <name>PWM_BRKCTL2_3</name>
          <displayName>PWM_BRKCTL2_3</displayName>
          <description>PWM Brake Edge Detect Control Register 2_3</description>
          <addressOffset>0xCC</addressOffset>
       </register>
       <register derivedFrom="PWM_BRKCTL0_1">
          <name>PWM_BRKCTL4_5</name>
          <displayName>PWM_BRKCTL4_5</displayName>
          <description>PWM Brake Edge Detect Control Register 4_5</description>
          <addressOffset>0xD0</addressOffset>
       </register>
       <register>
          <name>PWM_POLCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_POLCTL</displayName>
          <description>PWM Pin Polar Inverse Register</description>
          <addressOffset>0xD4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PINVn</name>
              <description>PWM PIN Polar Inverse Control\nThe register controls polarity state of PWM output. Each bit n controls the corresponding PWM channel n.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM output polar inverse Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM output polar inverse Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM_POEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_POEN</displayName>
          <description>PWM Output Enable Register</description>
          <addressOffset>0xD8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>POENn</name>
              <description>PWM Pin Output Enable Control\nEach bit n controls the corresponding PWM channel n.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM pin at tri-state</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM pin in output mode</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM_SWBRK</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_SWBRK</displayName>
          <description>PWM Software Brake Control Register</description>
          <addressOffset>0xDC</addressOffset>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BRKETRGn</name>
              <description>PWM Edge Brake Software Trigger (Write Only) (Write Protect)\nEach bit n controls the corresponding PWM pair n.\nWrite 1 to this bit will trigger Edge brake, and set BRKEIFn to 1 in PWM_INTSTS1 register. \nNote: This register is write protected. Refer to REGWRPROT register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>BRKLTRGn</name>
              <description>PWM Level Brake Software Trigger (Write Only) (Write Protect)\nEach bit n controls the corresponding PWM pair n.\nWrite 1 to this bit will trigger level brake, and set BRKLIFn to 1 in PWM_INTSTS1 register. \nNote: This register is write protected. Refer to REGWRPROT register.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM_INTEN0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_INTEN0</displayName>
          <description>PWM Interrupt Enable Register 0</description>
          <addressOffset>0xE0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ZIEN0</name>
              <description>PWM Zero Point Interrupt Enable 0\nNote: Odd channels will read always 0 at complementary mode.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Zero point interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Zero point interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ZIEN2</name>
              <description>PWM Zero Point Interrupt Enable 2\nNote: Odd channels will read always 0 at complementary mode.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Zero point interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Zero point interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ZIEN4</name>
              <description>PWM Zero Point Interrupt Enable 4\nNote: Odd channels will read always 0 at complementary mode.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Zero point interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Zero point interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PIEN0</name>
              <description>PWM Period Point Interrupt Enable 0\nNote: When up-down counter type period point means center point.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Period point interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Period point interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PIEN2</name>
              <description>PWM Period Point Interrupt Enable 2\nNote: When up-down counter type period point means center point.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Period point interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Period point interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PIEN4</name>
              <description>PWM Period Point Interrupt Enable 4\nNote: When up-down counter type period point means center point.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Period point interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Period point interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPUIENn</name>
              <description>PWM Compare Up Count Interrupt Enable Control\nEach bit n controls the corresponding PWM channel n.\nNote: In complementary mode, CMPUIEN1, 3, 5 use as another CMPUIEN for channel 0, 2, 4.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Compare up count interrupt Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Compare up count interrupt Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPDIENn</name>
              <description>PWM Compare Down Count Interrupt Enable Control\nEach bit n controls the corresponding PWM channel n.\nNote: In complementary mode, CMPDIEN1, 3, 5 use as another CMPDIEN for channel 0, 2, 4.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Compare down count interrupt Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Compare down count interrupt Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM_INTEN1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_INTEN1</displayName>
          <description>PWM Interrupt Enable Register 1</description>
          <addressOffset>0xE4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BRKEIEN0_1</name>
              <description>PWM Edge-Detect Brake Interrupt Enable For Channel0/1 (Write Protect)\nNote: This register is write protected. Refer to REGWRPROT register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge-detect Brake interrupt for channel0/1 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Edge-detect Brake interrupt for channel0/1 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKEIEN2_3</name>
              <description>PWM Edge-Detect Brake Interrupt Enable For Channel2/3 (Write Protect)\nNote: This register is write protected. Refer to REGWRPROT register.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge-detect Brake interrupt for channel2/3 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Edge-detect Brake interrupt for channel2/3 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKEIEN4_5</name>
              <description>PWM Edge-Detect Brake Interrupt Enable For Channel4/5 (Write Protect)\nNote: This register is write protected. Refer to REGWRPROT register.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge-detect Brake interrupt for channel4/5 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Edge-detect Brake interrupt for channel4/5 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKLIEN0_1</name>
              <description>PWM Level-Detect Brake Interrupt Enable For Channel0/1 (Write Protect)\nNote: This register is write protected. Refer to REGWRPROT register.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Level-detect Brake interrupt for channel0/1 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level-detect Brake interrupt for channel0/1 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKLIEN2_3</name>
              <description>PWM Level-Detect Brake Interrupt Enable For Channel2/3 (Write Protect)\nNote: This register is write protected. Refer to REGWRPROT register.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Level-detect Brake interrupt for channel2/3 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level-detect Brake interrupt for channel2/3 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKLIEN4_5</name>
              <description>PWM Level-Detect Brake Interrupt Enable For Channel4/5 (Write Protect)\nNote: This register is write protected. Refer to REGWRPROT register.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Level-detect Brake interrupt for channel4/5 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level-detect Brake interrupt for channel4/5 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM_INTSTS0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_INTSTS0</displayName>
          <description>PWM Interrupt Flag Register 0</description>
          <addressOffset>0xE8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ZIF0</name>
              <description>PWM Zero Point Interrupt Flag 0\nThis bit is set by hardware when PWM_CH0 counter reaches zero, software can write 1 to clear this bit to zero.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ZIF2</name>
              <description>PWM Zero Point Interrupt Flag 2\nThis bit is set by hardware when PWM_CH2 counter reaches zero, software can write 1 to clear this bit to zero.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ZIF4</name>
              <description>PWM Zero Point Interrupt Flag 4\nThis bit is set by hardware when PWM_CH4 counter reaches zero, software can write 1 to clear this bit to zero.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PIF0</name>
              <description>PWM Period Point Interrupt Flag 0\nThis bit is set by hardware when PWM_CH0 counter reaches PWM_PERIOD0, software can write 1 to clear this bit to zero.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PIF2</name>
              <description>PWM Period Point Interrupt Flag 2\nThis bit is set by hardware when PWM_CH2 counter reaches PWM_PERIOD2, software can write 1 to clear this bit to zero.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PIF4</name>
              <description>PWM Period Point Interrupt Flag 4\nThis bit is set by hardware when PWM_CH4 counter reaches PWM_PERIOD4, software can write 1 to clear this bit to zero.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPUIFn</name>
              <description>PWM Compare Up Count Interrupt Flag\nFlag is set by hardware when PWM counter up count and reaches PWM_CMPDATn, software can clear this bit by writing 1 to it. Each bit n controls the corresponding PWM channel n.\nNote1: If CMPDAT equal to PERIOD, this flag is not working in up counter type selection.\nNote2: In complementary mode, CMPUIF1, 3, 5 use as another CMPUIF for channel 0, 2, 4.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPDIFn</name>
              <description>PWM Compare Down Count Interrupt Flag\nEach bit n controls the corresponding PWM channel n.\nFlag is set by hardware when PWM counter down count and reaches PWM_CMPDATn, software can clear this bit by writing 1 to it.\nNote1: If CMPDAT equal to PERIOD, this flag is not working in down counter type selection.\nNote2: In complementary mode, CMPDIF1, 3, 5 use as another CMPDIF for channel 0, 2, 4.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM_INTSTS1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_INTSTS1</displayName>
          <description>PWM Interrupt Flag Register 1</description>
          <addressOffset>0xEC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BRKEIF0</name>
              <description>PWM Channel0 Edge-Detect Brake Interrupt Flag (Write Protect)\nNote: This register is write protected. Refer to REGWRPROT register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel0 edge-detect brake event do not happened</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM channel0 edge-detect brake event happened, this bit is set to 1, writing 1 to clear</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKEIF1</name>
              <description>PWM Channel1 Edge-Detect Brake Interrupt Flag (Write Protect)\nNote: This register is write protected. Refer to REGWRPROT register.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel1 edge-detect brake event do not happened</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM channel1 edge-detect brake event happened, this bit is set to 1, writing 1 to clear</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKEIF2</name>
              <description>PWM Channel2 Edge-Detect Brake Interrupt Flag (Write Protect)\nNote: This register is write protected. Refer to REGWRPROT register.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel2 edge-detect brake event do not happened</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM channel2 edge-detect brake event happened, this bit is set to 1, writing 1 to clear</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKEIF3</name>
              <description>PWM Channel3 Edge-Detect Brake Interrupt Flag (Write Protect)\nNote: This register is write protected. Refer to REGWRPROT register.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel3 edge-detect brake event do not happened</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM channel3 edge-detect brake event happened, this bit is set to 1, writing 1 to clear</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKEIF4</name>
              <description>PWM Channel4 Edge-Detect Brake Interrupt Flag (Write Protect)\nNote: This register is write protected. Refer to REGWRPROT register.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel4 edge-detect brake event do not happened</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM channel4 edge-detect brake event happened, this bit is set to 1, writing 1 to clear</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKEIF5</name>
              <description>PWM Channel5 Edge-Detect Brake Interrupt Flag (Write Protect)\nNote: This register is write protected. Refer to REGWRPROT register.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel5 edge-detect brake event do not happened</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM channel5 edge-detect brake event happened, this bit is set to 1, writing 1 to clear</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKLIF0</name>
              <description>PWM Channel0 Level-Detect Brake Interrupt Flag (Write Protect)\nNote: This register is write protected. Refer to REGWRPROT register.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel0 level-detect brake event do not happened</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM channel0 level-detect brake event happened, this bit is set to 1, writing 1 to clear</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKLIF1</name>
              <description>PWM Channel1 Level-Detect Brake Interrupt Flag (Write Protect)\nNote: This register is write protected. Refer to REGWRPROT register.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel1 level-detect brake event do not happened</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM channel1 level-detect brake event happened, this bit is set to 1, writing 1 to clear</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKLIF2</name>
              <description>PWM Channel2 Level-Detect Brake Interrupt Flag (Write Protect)\nNote: This register is write protected. Refer to REGWRPROT register.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel2 level-detect brake event do not happened</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM channel2 level-detect brake event happened, this bit is set to 1, writing 1 to clear</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKLIF3</name>
              <description>PWM Channel3 Level-Detect Brake Interrupt Flag (Write Protect)\nNote: This register is write protected. Refer to REGWRPROT register.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel3 level-detect brake event do not happened</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM channel3 level-detect brake event happened, this bit is set to 1, writing 1 to clear</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKLIF4</name>
              <description>PWM Channel4 Level-Detect Brake Interrupt Flag (Write Protect)\nNote: This register is write protected. Refer to REGWRPROT register.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel4 level-detect brake event do not happened</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM channel4 level-detect brake event happened, this bit is set to 1, writing 1 to clear</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKLIF5</name>
              <description>PWM Channel5 Level-Detect Brake Interrupt Flag (Write Protect)\nNote: This register is write protected. Refer to REGWRPROT register.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel5 level-detect brake event do not happened</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM channel5 level-detect brake event happened, this bit is set to 1, writing 1 to clear</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKESTS0</name>
              <description>PWM Channel0 Edge-Detect Brake Status</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel0 edge-detect brake state is released</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM channel0 edge-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel0 at brake state, writing 1 to clear</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKESTS1</name>
              <description>PWM Channel1 Edge-Detect Brake Status</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel1 edge-detect brake state is released</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM channel1 edge-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel1 at brake state, writing 1 to clear</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKESTS2</name>
              <description>PWM Channel2 Edge-Detect Brake Status</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel2 edge-detect brake state is released</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM channel2 edge-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel2 at brake state, writing 1 to clear</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKESTS3</name>
              <description>PWM Channel3 Edge-Detect Brake Status</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel3 edge-detect brake state is released</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM channel3 edge-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel3 at brake state, writing 1 to clear</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKESTS4</name>
              <description>PWM Channel4 Edge-Detect Brake Status</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel4 edge-detect brake state is released</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM channel4 edge-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel4 at brake state, writing 1 to clear</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKESTS5</name>
              <description>PWM Channel5 Edge-Detect Brake Status</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel5 edge-detect brake state is released</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM channel5 edge-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel5 at brake state, writing 1 to clear</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKLSTS0</name>
              <description>PWM Channel0 Level-Detect Brake Status (Read Only)\nNote: This bit is read only and auto cleared by hardware. When enabled brake source return to high level, PWM will release brake state until current PWM period finished. The PWM waveform will start output from next full PWM period.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel0 level-detect brake state is released</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM channel0 level-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel0 at brake state</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BRKLSTS1</name>
              <description>PWM Channel1 Level-Detect Brake Status (Read Only)\nNote: This bit is read only and auto cleared by hardware. When enabled brake source return to high level, PWM will release brake state until current PWM period finished. The PWM waveform will start output from next full PWM period.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel1 level-detect brake state is released</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM channel1 level-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel1 at brake state</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BRKLSTS2</name>
              <description>PWM Channel2 Level-Detect Brake Status (Read Only)\nNote: This bit is read only and auto cleared by hardware. When enabled brake source return to high level, PWM will release brake state until current PWM period finished. The PWM waveform will start output from next full PWM period.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel2 level-detect brake state is released</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM channel2 level-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel2 at brake state</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BRKLSTS3</name>
              <description>PWM Channel3 Level-Detect Brake Status (Read Only)\nNote: This bit is read only and auto cleared by hardware. When enabled brake source return to high level, PWM will release brake state until current PWM period finished. The PWM waveform will start output from next full PWM period.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel3 level-detect brake state is released</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM channel3 level-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel3 at brake state</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BRKLSTS4</name>
              <description>PWM Channel4 Level-Detect Brake Status (Read Only)\nNote: This bit is read only and auto cleared by hardware. When enabled brake source return to high level, PWM will release brake state until current PWM period finished. The PWM waveform will start output from next full PWM period.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel4 level-detect brake state is released</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM channel4 level-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel4 at brake state</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BRKLSTS5</name>
              <description>PWM Channel5 Level-Detect Brake Status (Read Only)\nNote: This bit is read only and auto cleared by hardware. When enabled brake source return to high level, PWM will release brake state until current PWM period finished. The PWM waveform will start output from next full PWM period.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel5 level-detect brake state is released</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM channel5 level-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel5 at brake state</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM_ADCTS0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_ADCTS0</displayName>
          <description>PWM Trigger ADC Source Select Register 0</description>
          <addressOffset>0xF8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TRGSEL0</name>
              <description>PWM_CH0 Trigger ADC Source Select</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM_CH0 zero point</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM_CH0 period point</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>PWM_CH0 zero or period point</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>PWM_CH0 up-count CMPDAT point</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>PWM_CH0 down-count CMPDAT point</description>
                    <value>#0100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Reserved.</description>
                    <value>#0101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Reserved.</description>
                    <value>#0110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Reserved.</description>
                    <value>#0111</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>8</name>
                    <description>PWM_CH1 up-count CMPDAT point</description>
                    <value>#1000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>9</name>
                    <description>PWM_CH1 down-count CMPDAT point</description>
                    <value>#1001</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGEN0</name>
              <description>PWM_CH0 Trigger ADC Enable Control</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGSEL1</name>
              <description>PWM_CH1 Trigger ADC Source Select</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM_CH0 zero point</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM_CH0 period point</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>PWM_CH0 zero or period point</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>PWM_CH0 up-count CMPDAT point</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>PWM_CH0 down-count CMPDAT point</description>
                    <value>#0100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Reserved.</description>
                    <value>#0101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Reserved.</description>
                    <value>#0110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Reserved.</description>
                    <value>#0111</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>8</name>
                    <description>PWM_CH1 up-count CMPDAT point</description>
                    <value>#1000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>9</name>
                    <description>PWM_CH1 down-count CMPDAT point</description>
                    <value>#1001</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGEN1</name>
              <description>PWM_CH1 Trigger ADC Enable Control</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGSEL2</name>
              <description>PWM_CH2 Trigger ADC Source Select</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM_CH2 zero point</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM_CH2 period point</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>PWM_CH2 zero or period point</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>PWM_CH2 up-count CMPDAT point</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>PWM_CH2 down-count CMPDAT point</description>
                    <value>#0100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Reserved.</description>
                    <value>#0101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Reserved.</description>
                    <value>#0110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Reserved.</description>
                    <value>#0111</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>8</name>
                    <description>PWM_CH3 up-count CMPDAT point</description>
                    <value>#1000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>9</name>
                    <description>PWM_CH3 down-count CMPDAT point</description>
                    <value>#1001</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGEN2</name>
              <description>PWM_CH2 Trigger ADC Enable Control</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGSEL3</name>
              <description>PWM_CH3 Trigger ADC Source Select</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM_CH2 zero point</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM_CH2 period point</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>PWM_CH2 zero or period point</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>PWM_CH2 up-count CMPDAT point</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>PWM_CH2 down-count CMPDAT point</description>
                    <value>#0100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Reserved.</description>
                    <value>#0101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Reserved.</description>
                    <value>#0110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Reserved.</description>
                    <value>#0111</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>8</name>
                    <description>PWM_CH3 up-count CMPDAT point</description>
                    <value>#1000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>9</name>
                    <description>PWM_CH3 down-count CMPDAT point</description>
                    <value>#1001</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGEN3</name>
              <description>PWM_CH3 Trigger ADC Enable Control</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM_ADCTS1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_ADCTS1</displayName>
          <description>PWM Trigger ADC Source Select Register 1</description>
          <addressOffset>0xFC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TRGSEL4</name>
              <description>PWM_CH4 Trigger ADC Source Select</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM_CH4 zero point</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM_CH4 period point</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>PWM_CH4 zero or period point</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>PWM_CH4 up-count CMPDAT point</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>PWM_CH4 down-count CMPDAT point</description>
                    <value>#0100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Reserved.</description>
                    <value>#0101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Reserved.</description>
                    <value>#0110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Reserved.</description>
                    <value>#0111</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>8</name>
                    <description>PWM_CH5 up-count CMPDAT point</description>
                    <value>#1000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>9</name>
                    <description>PWM_CH5 down-count CMPDAT point</description>
                    <value>#1001</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGEN4</name>
              <description>PWM_CH4 Trigger ADC Enable Control</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGSEL5</name>
              <description>PWM_CH5 Trigger ADC Source Select</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM_CH4 zero point</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM_CH4 period point</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>PWM_CH4 zero or period point</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>PWM_CH4 up-count CMPDAT point</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>PWM_CH4 down-count CMPDAT point</description>
                    <value>#0100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Reserved.</description>
                    <value>#0101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Reserved.</description>
                    <value>#0110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Reserved.</description>
                    <value>#0111</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>8</name>
                    <description>PWM_CH5 up-count CMPDAT point</description>
                    <value>#1000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>9</name>
                    <description>PWM_CH5 down-count CMPDAT point</description>
                    <value>#1001</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGEN5</name>
              <description>PWM_CH5 Trigger ADC Enable Control</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM_SSCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_SSCTL</displayName>
          <description>PWM Synchronous Start Control Register</description>
          <addressOffset>0x110</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SSEN0</name>
              <description>PWM Synchronous Start Function Enable 0\nWhen synchronous start function is enabled, the PWM_CH0 counter enable bit (CNTEN0) can be enabled by writing PWM synchronous start trigger bit (CNTSEN). </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM synchronous start function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM synchronous start function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEN2</name>
              <description>PWM Synchronous Start Function Enable 2\nWhen synchronous start function is enabled, the PWM_CH2 counter enable bit (CNTEN2) can be enabled by writing PWM synchronous start trigger bit (CNTSEN). </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM synchronous start function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM synchronous start function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEN4</name>
              <description>PWM Synchronous Start Function Enable 4\nWhen synchronous start function is enabled, the PWM_CH4 counter enable bit (CNTEN4) can be enabled by writing PWM synchronous start trigger bit (CNTSEN). </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM synchronous start function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM synchronous start function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SSRC</name>
              <description>PWM Synchronous Start Source Select</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Synchronous start source come from PWM0</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Synchronous start source come from PWM1</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Synchronous start source come from BPWM0</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Synchronous start source come from BPWM1</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM_SSTRG</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_SSTRG</displayName>
          <description>PWM Synchronous Start Trigger Register</description>
          <addressOffset>0x114</addressOffset>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNTSEN</name>
              <description>PWM Counter Synchronous Start Enable (Write Only)\nPMW counter synchronous enable function is used to make selected PWM channels (include PWM0_CHx and PWM1_CHx) start counting at the same time.\nWriting this bit to 1 will also set the counter enable bit (CNTENn, n denotes channel 0 to 5) if correlated PWM channel counter synchronous start function is enabled.\nNote: This bit only present in PWM0_BA.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM_STATUS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_STATUS</displayName>
          <description>PWM Status Register</description>
          <addressOffset>0x120</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNTMAX0</name>
              <description>Time-Base Counter 0 Equal To 0xFFFF Latched Status</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>indicates the time-base counter never reached its maximum value 0xFFFF</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>indicates the time-base counter reached its maximum value, software can write 1 to clear this bit</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CNTMAX2</name>
              <description>Time-Base Counter 2 Equal To 0xFFFF Latched Status</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>indicates the time-base counter never reached its maximum value 0xFFFF</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>indicates the time-base counter reached its maximum value, software can write 1 to clear this bit</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CNTMAX4</name>
              <description>Time-Base Counter 4 Equal To 0xFFFF Latched Status</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>indicates the time-base counter never reached its maximum value 0xFFFF</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>indicates the time-base counter reached its maximum value, software can write 1 to clear this bit</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADCTRGn</name>
              <description>ADC Start Of Conversion Status\nEach bit n controls the corresponding PWM channel n.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Indicates no ADC start of conversion trigger event has occurred</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Indicates an ADC start of conversion trigger event has occurred, software can write 1 to clear this bit</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM_CAPINEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_CAPINEN</displayName>
          <description>PWM Capture Input Enable Register</description>
          <addressOffset>0x200</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CAPINENn</name>
              <description>Capture Input Enable\nEach bit n controls the corresponding PWM channel n.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM Channel capture input path Disabled. The input of PWM channel capture function is always regarded as 0</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM Channel capture input path Enabled. The input of PWM channel capture function comes from correlative multifunction pin</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM_CAPCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_CAPCTL</displayName>
          <description>PWM Capture Control Register</description>
          <addressOffset>0x204</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CAPENn</name>
              <description>Capture Function Enable Control\nEach bit n controls the corresponding PWM channel n.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Capture function Disabled. RCAPDAT/FCAPDAT register will not be updated</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture function Enabled. Capture latched the PWM counter value when detected rising or falling edge of input signal and saved to RCAPDAT (Rising latch) and FCAPDAT (Falling latch)</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPINVn</name>
              <description>Capture Inverter Enable Control\nEach bit n controls the corresponding PWM channel n.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Capture source inverter Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture source inverter Enabled. Reverse the input signal from GPIO</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RCRLDENn</name>
              <description>Rising Capture Reload Enable Control\nEach bit n controls the corresponding PWM channel n.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Rising capture reload counter Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Rising capture reload counter Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FCRLDENn</name>
              <description>Falling Capture Reload Enable Control\nEach bit n controls the corresponding PWM channel n.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Falling capture reload counter Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Falling capture reload counter Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM_CAPSTS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_CAPSTS</displayName>
          <description>PWM Capture Status Register</description>
          <addressOffset>0x208</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CRLIFOVn</name>
              <description>Capture Rising Latch Interrupt Flag Overrun Status (Read Only)\nThis flag indicates if rising latch happened when the corresponding CRLIF is 1. Each bit n controls the corresponding PWM channel n.\nNote: This bit will be cleared automatically when user clear corresponding CRLIF.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CFLIFOVn</name>
              <description>Capture Falling Latch Interrupt Flag Overrun Status (Read Only)\nThis flag indicates if falling latch happened when the corresponding CFLIF is 1. Each bit n controls the corresponding PWM channel n.\nNote: This bit will be cleared automatically when user clear corresponding CFLIF.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM_RCAPDAT0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_RCAPDAT0</displayName>
          <description>PWM Rising Capture Data Register 0</description>
          <addressOffset>0x20C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RCAPDAT</name>
              <description>PWM Rising Capture Data Register (Read Only)\nWhen rising capture condition happened, the PWM counter value will be saved in this register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM_FCAPDAT0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_FCAPDAT0</displayName>
          <description>PWM Falling Capture Data Register 0</description>
          <addressOffset>0x210</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FCAPDAT</name>
              <description>PWM Falling Capture Data Register (Read Only)\nWhen falling capture condition happened, the PWM counter value will be saved in this register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PWM_RCAPDAT0">
          <name>PWM_RCAPDAT1</name>
          <displayName>PWM_RCAPDAT1</displayName>
          <description>PWM Rising Capture Data Register 1</description>
          <addressOffset>0x214</addressOffset>
       </register>
       <register derivedFrom="PWM_FCAPDAT0">
          <name>PWM_FCAPDAT1</name>
          <displayName>PWM_FCAPDAT1</displayName>
          <description>PWM Falling Capture Data Register 1</description>
          <addressOffset>0x218</addressOffset>
       </register>
       <register derivedFrom="PWM_RCAPDAT0">
          <name>PWM_RCAPDAT2</name>
          <displayName>PWM_RCAPDAT2</displayName>
          <description>PWM Rising Capture Data Register 2</description>
          <addressOffset>0x21C</addressOffset>
       </register>
       <register derivedFrom="PWM_FCAPDAT0">
          <name>PWM_FCAPDAT2</name>
          <displayName>PWM_FCAPDAT2</displayName>
          <description>PWM Falling Capture Data Register 2</description>
          <addressOffset>0x220</addressOffset>
       </register>
       <register derivedFrom="PWM_RCAPDAT0">
          <name>PWM_RCAPDAT3</name>
          <displayName>PWM_RCAPDAT3</displayName>
          <description>PWM Rising Capture Data Register 3</description>
          <addressOffset>0x224</addressOffset>
       </register>
       <register derivedFrom="PWM_FCAPDAT0">
          <name>PWM_FCAPDAT3</name>
          <displayName>PWM_FCAPDAT3</displayName>
          <description>PWM Falling Capture Data Register 3</description>
          <addressOffset>0x228</addressOffset>
       </register>
       <register derivedFrom="PWM_RCAPDAT0">
          <name>PWM_RCAPDAT4</name>
          <displayName>PWM_RCAPDAT4</displayName>
          <description>PWM Rising Capture Data Register 4</description>
          <addressOffset>0x22C</addressOffset>
       </register>
       <register derivedFrom="PWM_FCAPDAT0">
          <name>PWM_FCAPDAT4</name>
          <displayName>PWM_FCAPDAT4</displayName>
          <description>PWM Falling Capture Data Register 4</description>
          <addressOffset>0x230</addressOffset>
       </register>
       <register derivedFrom="PWM_RCAPDAT0">
          <name>PWM_RCAPDAT5</name>
          <displayName>PWM_RCAPDAT5</displayName>
          <description>PWM Rising Capture Data Register 5</description>
          <addressOffset>0x234</addressOffset>
       </register>
       <register derivedFrom="PWM_FCAPDAT0">
          <name>PWM_FCAPDAT5</name>
          <displayName>PWM_FCAPDAT5</displayName>
          <description>PWM Falling Capture Data Register 5</description>
          <addressOffset>0x238</addressOffset>
       </register>
       <register>
          <name>PWM_CAPIEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_CAPIEN</displayName>
          <description>PWM Capture Interrupt Enable Register</description>
          <addressOffset>0x250</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CAPRIENn</name>
              <description>PWM Capture Rising Latch Interrupt Enable Control\nEach bit n controls the corresponding PWM channel n.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Capture rising edge latch interrupt Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture rising edge latch interrupt Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPFIENn</name>
              <description>PWM Capture Falling Latch Interrupt Enable Control\nEach bit n controls the corresponding PWM channel n.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Capture falling edge latch interrupt Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture falling edge latch interrupt Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM_CAPIF</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_CAPIF</displayName>
          <description>PWM Capture Interrupt Flag Register</description>
          <addressOffset>0x254</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CRLIFn</name>
              <description>PWM Capture Rising Latch Interrupt Flag\nThis bit is writing 1 to clear. Each bit n controls the corresponding PWM channel n.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No capture rising latch condition happened</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture rising latch condition happened, this flag will be set to high</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CFLIFn</name>
              <description>PWM Capture Falling Latch Interrupt Flag\nThis bit is writing 1 to clear. Each bit n controls the corresponding PWM channel n.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No capture falling latch condition happened</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture falling latch condition happened, this flag will be set to high</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM_PBUF0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_PBUF0</displayName>
          <description>PWM PERIOD0 Buffer</description>
          <addressOffset>0x304</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PBUF</name>
              <description>PWM Period Register Buffer (Read Only)\nUsed as PERIOD active register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PWM_PBUF0">
          <name>PWM_PBUF2</name>
          <displayName>PWM_PBUF2</displayName>
          <description>PWM PERIOD2 Buffer</description>
          <addressOffset>0x30C</addressOffset>
       </register>
       <register derivedFrom="PWM_PBUF0">
          <name>PWM_PBUF4</name>
          <displayName>PWM_PBUF4</displayName>
          <description>PWM PERIOD4 Buffer</description>
          <addressOffset>0x314</addressOffset>
       </register>
       <register>
          <name>PWM_CMPBUF0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_CMPBUF0</displayName>
          <description>PWM CMPDAT0 Buffer</description>
          <addressOffset>0x31C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMPBUF</name>
              <description>PWM Comparator Register Buffer (Read Only)\nUsed as CMP active register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PWM_CMPBUF0">
          <name>PWM_CMPBUF1</name>
          <displayName>PWM_CMPBUF1</displayName>
          <description>PWM CMPDAT1 Buffer</description>
          <addressOffset>0x320</addressOffset>
       </register>
       <register derivedFrom="PWM_CMPBUF0">
          <name>PWM_CMPBUF2</name>
          <displayName>PWM_CMPBUF2</displayName>
          <description>PWM CMPDAT2 Buffer</description>
          <addressOffset>0x324</addressOffset>
       </register>
       <register derivedFrom="PWM_CMPBUF0">
          <name>PWM_CMPBUF3</name>
          <displayName>PWM_CMPBUF3</displayName>
          <description>PWM CMPDAT3 Buffer</description>
          <addressOffset>0x328</addressOffset>
       </register>
       <register derivedFrom="PWM_CMPBUF0">
          <name>PWM_CMPBUF4</name>
          <displayName>PWM_CMPBUF4</displayName>
          <description>PWM CMPDAT4 Buffer</description>
          <addressOffset>0x32C</addressOffset>
       </register>
       <register derivedFrom="PWM_CMPBUF0">
          <name>PWM_CMPBUF5</name>
          <displayName>PWM_CMPBUF5</displayName>
          <description>PWM CMPDAT5 Buffer</description>
          <addressOffset>0x330</addressOffset>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PWM1</name>
      <description>PWM Register Map</description>
      <groupName>PWM</groupName>
      <baseAddress>0x40140000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x10</offset>
        <size>0x18</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x30</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x38</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x40</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x50</offset>
        <size>0x18</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x70</offset>
        <size>0xC</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x90</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x98</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0xA0</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0xB0</offset>
        <size>0x40</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0xF8</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x110</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x120</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x200</offset>
        <size>0x3C</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x250</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x304</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x30C</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x314</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x31C</offset>
        <size>0x18</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>PWM_CTL0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_CTL0</displayName>
          <description>PWM Control Register 0</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CTRLDn</name>
              <description>Center Re-Load\nEach bit n controls the corresponding PWM channel n.\nIn up-down counter type, PERIOD will load to PBUF at the end point of each period. CMPDAT will load to CMPBUF at the center point of a period.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IMMLDENn</name>
              <description>Immediately Load Enable control\nEach bit n controls the corresponding PWM channel n.\nNote: If IMMLDENn is enabled, WINLDENn and CTRLDn will be invalid.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PERIOD will load to PBUF at the end point of each period. CMPDAT will load to CMPBUF at the end point or center point of each period by setting CTRLD bit</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PERIOD/CMPDAT will load to PBUF and CMPBUF immediately when software update PERIOD/CMPDAT</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBGHALT</name>
              <description>ICE Debug Mode Counter Halt (Write Protect)\nIf counter halt is enabled, PWM all counters will keep current value until exit ICE debug mode. \nNote: This register is write protected. Refer to REGWRPROT register.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ICE debug mode counter halt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ICE debug mode counter halt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBGTRIOFF</name>
              <description>ICE Debug Mode Acknowledge Disable (Write Protect)\nPWM pin will keep output no matter ICE debug mode acknowledged or not.\nNote: This register is write protected. Refer to REGWRPROT register.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ICE debug mode acknowledgement effects PWM output</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ICE debug mode acknowledgement Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM_CTL1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_CTL1</displayName>
          <description>PWM Control Register 1</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNTTYPE0</name>
              <description>PWM Counter Behavior Type 0\nEach bit n controls corresponding PWM channel n.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Up counter type (supports in capture mode)</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Down count type (supports in capture mode)</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Up-down counter type</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved.</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CNTTYPE2</name>
              <description>PWM Counter Behavior Type 2\nEach bit n controls corresponding PWM channel n.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Up counter type (supports in capture mode)</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Down count type (supports in capture mode)</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Up-down counter type</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved.</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CNTTYPE4</name>
              <description>PWM Counter Behavior Type 4\nEach bit n controls corresponding PWM channel n.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Up counter type (supports in capture mode)</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Down count type (supports in capture mode)</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Up-down counter type</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved.</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMMODEn</name>
              <description>PWM Mode\nEach bit n controls the corresponding PWM channel n.\nNote: When operating in group function, these bits must all set to the same mode.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM independent mode</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM complementary mode</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM_CLKSRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_CLKSRC</displayName>
          <description>PWM Clock Source Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ECLKSRC0</name>
              <description>PWM_CH01 External Clock Source Select</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWMx_CLK, x denotes 0 or 1</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TIMER0 overflow</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>TIMER1 overflow</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>TIMER2 overflow</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>TIMER3 overflow</description>
                    <value>#100</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ECLKSRC2</name>
              <description>PWM_CH23 External Clock Source Select</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWMx_CLK, x denotes 0 or 1</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TIMER0 overflow</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>TIMER1 overflow</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>TIMER2 overflow</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>TIMER3 overflow</description>
                    <value>#100</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ECLKSRC4</name>
              <description>PWM_CH45 External Clock Source Select</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWMx_CLK, x denotes 0 or 1</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TIMER0 overflow</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>TIMER1 overflow</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>TIMER2 overflow</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>TIMER3 overflow</description>
                    <value>#100</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM_CLKPSC0_1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_CLKPSC0_1</displayName>
          <description>PWM Clock Pre-scale Register 0_1</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLKPSC</name>
              <description>PWM Counter Clock Pre-Scale \nThe clock of PWM counter is decided by clock prescaler. Each PWM pair share one PWM counter clock prescaler. The clock of PWM counter is divided by (CLKPSC+ 1).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PWM_CLKPSC0_1">
          <name>PWM_CLKPSC2_3</name>
          <displayName>PWM_CLKPSC2_3</displayName>
          <description>PWM Clock Pre-scale Register 2_3</description>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PWM_CLKPSC0_1">
          <name>PWM_CLKPSC4_5</name>
          <displayName>PWM_CLKPSC4_5</displayName>
          <description>PWM Clock Pre-scale Register 4_5</description>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register>
          <name>PWM_CNTEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_CNTEN</displayName>
          <description>PWM Counter Enable Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNTEN0</name>
              <description>PWM Counter Enable 0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM Counter and clock prescaler Stop Running</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM Counter and clock prescaler Start Running</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CNTEN2</name>
              <description>PWM Counter Enable 2</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM Counter and clock prescaler Stop Running</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM Counter and clock prescaler Start Running</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CNTEN4</name>
              <description>PWM Counter Enable 4</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM Counter and clock prescaler Stop Running</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM Counter and clock prescaler Start Running</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM_CNTCLR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_CNTCLR</displayName>
          <description>PWM Clear Counter Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNTCLR0</name>
              <description>Clear PWM Counter Control Bit 0\nIt is automatically cleared by hardware.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clear 16-bit PWM counter to 0000H</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CNTCLR2</name>
              <description>Clear PWM Counter Control Bit 2\nIt is automatically cleared by hardware.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clear 16-bit PWM counter to 0000H</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CNTCLR4</name>
              <description>Clear PWM Counter Control Bit 4\nIt is automatically cleared by hardware.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clear 16-bit PWM counter to 0000H</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM_PERIOD0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_PERIOD0</displayName>
          <description>PWM Period Register 0</description>
          <addressOffset>0x30</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PERIOD</name>
              <description>PWM Period Register\nUp-Count mode: In this mode, PWM counter counts from 0 to PERIOD, and restarts from 0.\nDown-Count mode: In this mode, PWM counter counts from PERIOD to 0, and restarts from PERIOD.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PWM_PERIOD0">
          <name>PWM_PERIOD2</name>
          <displayName>PWM_PERIOD2</displayName>
          <description>PWM Period Register 2</description>
          <addressOffset>0x38</addressOffset>
       </register>
       <register derivedFrom="PWM_PERIOD0">
          <name>PWM_PERIOD4</name>
          <displayName>PWM_PERIOD4</displayName>
          <description>PWM Period Register 4</description>
          <addressOffset>0x40</addressOffset>
       </register>
       <register>
          <name>PWM_CMPDAT0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_CMPDAT0</displayName>
          <description>PWM Comparator Register 0</description>
          <addressOffset>0x50</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMP</name>
              <description>PWM Comparator Register\nCMP use to compare with CNT to generate PWM waveform, interrupt and trigger ADC.\nIn independent mode, PWM_CMPDAT0~5 denote as 6 independent PWM_CH0~5 compared point.\nIn complementary mode, PWM_CMPDAT0, 2, 4 denote as first compared point, and PWM_CMPDAT1, 3, 5 denote as second compared point for the corresponding 3 complementary pairs PWM_CH0 and PWM_CH1, PWM_CH2 and PWM_CH3, PWM_CH4 and PWM_CH5.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PWM_CMPDAT0">
          <name>PWM_CMPDAT1</name>
          <displayName>PWM_CMPDAT1</displayName>
          <description>PWM Comparator Register 1</description>
          <addressOffset>0x54</addressOffset>
       </register>
       <register derivedFrom="PWM_CMPDAT0">
          <name>PWM_CMPDAT2</name>
          <displayName>PWM_CMPDAT2</displayName>
          <description>PWM Comparator Register 2</description>
          <addressOffset>0x58</addressOffset>
       </register>
       <register derivedFrom="PWM_CMPDAT0">
          <name>PWM_CMPDAT3</name>
          <displayName>PWM_CMPDAT3</displayName>
          <description>PWM Comparator Register 3</description>
          <addressOffset>0x5C</addressOffset>
       </register>
       <register derivedFrom="PWM_CMPDAT0">
          <name>PWM_CMPDAT4</name>
          <displayName>PWM_CMPDAT4</displayName>
          <description>PWM Comparator Register 4</description>
          <addressOffset>0x60</addressOffset>
       </register>
       <register derivedFrom="PWM_CMPDAT0">
          <name>PWM_CMPDAT5</name>
          <displayName>PWM_CMPDAT5</displayName>
          <description>PWM Comparator Register 5</description>
          <addressOffset>0x64</addressOffset>
       </register>
       <register>
          <name>PWM_DTCTL0_1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_DTCTL0_1</displayName>
          <description>PWM Dead-time Control Register 0_1</description>
          <addressOffset>0x70</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DTCNT</name>
              <description>Dead-Time Counter (Write Protect)\nThe dead-time can be calculated from the following formula: \nNote: This register is write protected. Refer to REGWRPROT register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DTEN</name>
              <description>Enable Dead-Time Insertion For PWM Pair (PWM_CH0, PWM_CH1) (PWM_CH2, PWM_CH3) (PWM_CH4, PWM_CH5) (Write Protect)\nDead-time insertion is only active when this pair of complementary PWM is enabled. If dead- time insertion is inactive, the outputs of pin pair are complementary without any delay.\nNote: This register is write protected. Refer to REGWRPROT register.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Dead-time insertion Disabled on the pin pair</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Dead-time insertion Enabled on the pin pair</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DTCKSEL</name>
              <description>Dead-Time Clock Select (Write Protect)\nNote: This register is write protected. Refer to REGWRPROT register.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Dead-time clock source from PWM_CLK</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Dead-time clock source from prescaler output</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PWM_DTCTL0_1">
          <name>PWM_DTCTL2_3</name>
          <displayName>PWM_DTCTL2_3</displayName>
          <description>PWM Dead-time Control Register 2_3</description>
          <addressOffset>0x74</addressOffset>
       </register>
       <register derivedFrom="PWM_DTCTL0_1">
          <name>PWM_DTCTL4_5</name>
          <displayName>PWM_DTCTL4_5</displayName>
          <description>PWM Dead-time Control Register 4_5</description>
          <addressOffset>0x78</addressOffset>
       </register>
       <register>
          <name>PWM_CNT0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_CNT0</displayName>
          <description>PWM Counter Register 0</description>
          <addressOffset>0x90</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNT</name>
              <description>PWM Data Register (Read Only)\nUser can monitor CNT to know the current value in 16-bit period counter.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DIRF</name>
              <description>PWM Direction Indicator Flag (Read Only)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Counter is Down count</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Counter is UP count</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PWM_CNT0">
          <name>PWM_CNT2</name>
          <displayName>PWM_CNT2</displayName>
          <description>PWM Counter Register 2</description>
          <addressOffset>0x98</addressOffset>
       </register>
       <register derivedFrom="PWM_CNT0">
          <name>PWM_CNT4</name>
          <displayName>PWM_CNT4</displayName>
          <description>PWM Counter Register 4</description>
          <addressOffset>0xA0</addressOffset>
       </register>
       <register>
          <name>PWM_WGCTL0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_WGCTL0</displayName>
          <description>PWM Generation Register 0</description>
          <addressOffset>0xB0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ZPCTLn</name>
              <description>PWM Zero Point Control\nEach bit n controls the corresponding PWM channel n.\nPWM can control output level when PWM counter count to zero.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Do nothing</description>
                    <value>00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM zero point output Low</description>
                    <value>01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>10</name>
                    <description>PWM zero point output High</description>
                    <value>10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>11</name>
                    <description>PWM zero point output Toggle</description>
                    <value>11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PRDPCTLn</name>
              <description>PWM Period (Center) Point Control\nEach bit n controls the corresponding PWM channel n.\nPWM can control output level when PWM counter count to (PERIODn+1).\nNote: This bit is center point control when PWM counter operating in up-down counter type.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>12</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Do nothing</description>
                    <value>00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM period (center) point output Low</description>
                    <value>01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>10</name>
                    <description>PWM period (center) point output High</description>
                    <value>10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>11</name>
                    <description>PWM period (center) point output Toggle</description>
                    <value>11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM_WGCTL1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_WGCTL1</displayName>
          <description>PWM Generation Register 1</description>
          <addressOffset>0xB4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMPUCTLn</name>
              <description>PWM Compare Up Point Control\nEach bit n controls the corresponding PWM channel n.\nPWM can control output level when PWM counter up count to CMPDAT.\nNote: In complementary mode, CMPUCTL1, 3, 5 use as another CMPUCTL for channel 0, 2, 4.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Do nothing</description>
                    <value>00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM compare up point output Low</description>
                    <value>01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>10</name>
                    <description>PWM compare up point output High</description>
                    <value>10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>11</name>
                    <description>PWM compare up point output Toggle</description>
                    <value>11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPDCTLn</name>
              <description>PWM Compare Down Point Control\nEach bit n controls the corresponding PWM channel n.\nPWM can control output level when PWM counter down count to CMPDAT.\nNote: In complementary mode, CMPDCTL1, 3, 5 use as another CMPDCTL for channel 0, 2, 4.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>12</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Do nothing</description>
                    <value>00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM compare down point output Low</description>
                    <value>01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>10</name>
                    <description>PWM compare down point output High</description>
                    <value>10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>11</name>
                    <description>PWM compare down point output Toggle</description>
                    <value>11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM_MSKEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_MSKEN</displayName>
          <description>PWM Mask Enable Register</description>
          <addressOffset>0xB8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MSKENn</name>
              <description>PWM Mask Enable Control\nEach bit n controls the corresponding PWM channel n.\nThe PWM output signal will be masked when this bit is enabled. The corresponding PWM channel n will output MSKDATn (PWM_MSK[5:0]) data. </description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM output signal is non-masked</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM output signal is masked and output MSKDATn data</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM_MSK</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_MSK</displayName>
          <description>PWM Mask Data Register</description>
          <addressOffset>0xBC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MSKDATn</name>
              <description>PWM Mask Data Bit\nThis data bit control the state of PWMn output pin, if corresponding mask function is enabled. Each bit n controls the corresponding PWM channel n.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Output logic low to PWMn</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Output logic high to PWMn</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM_BNF</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_BNF</displayName>
          <description>PWM Brake Noise Filter Register</description>
          <addressOffset>0xC0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BRK0FEN</name>
              <description>PWM Brake 0 Noise Filter Enable Control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Noise filter of PWM Brake 0 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Noise filter of PWM Brake 0 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRK0FCS</name>
              <description>Brake 0 Edge Detector Filter Clock Selection</description>
              <bitOffset>1</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Filter clock is HCLK</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Filter clock is HCLK/2</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Filter clock is HCLK/4</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Filter clock is HCLK/8</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>Filter clock is HCLK/16</description>
                    <value>#100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Filter clock is HCLK/32</description>
                    <value>#101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Filter clock is HCLK/64</description>
                    <value>#110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Filter clock is HCLK/128</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRK0FCNT</name>
              <description>Brake 0 Edge Detector Filter Count\nThe register bits control the Brake0 filter counter to count from 0 to BRK1FCNT.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BRK0PINV</name>
              <description>Brake 0 Pin Inverse</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The state of pin PWMx_BRAKE0 is passed to the negative edge detector</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The inversed state of pin PWMx_BRAKE10 is passed to the negative edge detector</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRK1FEN</name>
              <description>PWM Brake 1 Noise Filter Enable Control</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Noise filter of PWM Brake 1 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Noise filter of PWM Brake 1 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRK1FCS</name>
              <description>Brake 1 Edge Detector Filter Clock Selection</description>
              <bitOffset>9</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Filter clock = HCLK</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Filter clock = HCLK/2</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Filter clock = HCLK/4</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Filter clock = HCLK/8</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>Filter clock = HCLK/16</description>
                    <value>#100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Filter clock = HCLK/32</description>
                    <value>#101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Filter clock = HCLK/64</description>
                    <value>#110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Filter clock = HCLK/128</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRK1FCNT</name>
              <description>Brake 1 Edge Detector Filter Count\nThe register bits control the Brake1 filter counter to count from 0 to BRK1FCNT.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BRK1PINV</name>
              <description>Brake 1 Pin Inverse</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The state of pin PWMx_BRAKE1 is passed to the negative edge detector</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The inversed state of pin PWMx_BRAKE1 is passed to the negative edge detector</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BK0SRC</name>
              <description>Brake 0 Pin Source Select\nFor PWM0 setting:</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Brake 0 pin source come from PWM0_BRAKE0.\nBrake 0 pin source come from PWM1_BRAKE0</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Brake 0 pin source come from PWM1_BRAKE0.\nBrake 0 pin source come from PWM0_BRAKE0</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BK1SRC</name>
              <description>Brake 1 Pin Source Select\nFor PWM0 setting:</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Brake 1 pin source come from PWM0_BRAKE1.\nBrake 1 pin source come from PWM1_BRAKE1</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Brake 1 pin source come from PWM1_BRAKE1.\nBrake 1 pin source come from PWM0_BRAKE1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM_FAILBRK</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_FAILBRK</displayName>
          <description>PWM System Fail Brake Control Register</description>
          <addressOffset>0xC4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CSSBRKEN</name>
              <description>Clock Security System Detection Trigger PWM Brake Function 0 Enable Control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Brake Function triggered by CSS detection Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Brake Function triggered by CSS detection Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BODBRKEN</name>
              <description>Brown-Out Detection Trigger PWM Brake Function 0 Enable Control</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Brake Function triggered by BOD Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Brake Function triggered by BOD Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CORBRKEN</name>
              <description>Core Lockup Detection Trigger PWM Brake Function 0 Enable Control</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Brake Function triggered by Core lockup detection Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Brake Function triggered by Core lockup detection Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM_BRKCTL0_1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_BRKCTL0_1</displayName>
          <description>PWM Brake Edge Detect Control Register 0_1</description>
          <addressOffset>0xC8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BRKP0EEN</name>
              <description>Enable PWMx_BRAKE0 Pin As Edge-Detect Brake Source (Write Protect)\nNote: This register is write protected. Refer to REGWRPROT register.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>BKP0 pin as edge-detect brake source Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>BKP0 pin as edge-detect brake source Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKP1EEN</name>
              <description>Enable PWMx_BRAKE1 Pin As Edge-Detect Brake Source (Write Protect)\nNote: This register is write protected. Refer to REGWRPROT register.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>BKP1 pin as edge-detect brake source Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>BKP1 pin as edge-detect brake source Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SYSEEN</name>
              <description>Enable System Fail As Edge-Detect Brake Source (Write Protect)\nNote: This register is write protected. Refer to REGWRPROT register.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>System Fail condition as edge-detect brake source Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>System Fail condition as edge-detect brake source Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKP0LEN</name>
              <description>Enable BKP0 Pin As Level-Detect Brake Source (Write Protect)\nNote: This register is write protected. Refer to REGWRPROT register.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWMx_BRAKE0 pin as level-detect brake source Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWMx_BRAKE0 pin as level-detect brake source Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKP1LEN</name>
              <description>Enable BKP1 Pin As Level-Detect Brake Source (Write Protect)\nNote: This register is write protected. Refer to REGWRPROT register.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWMx_BRAKE1 pin as level-detect brake source Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWMx_BRAKE1 pin as level-detect brake source Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SYSLEN</name>
              <description>Enable System Fail As Level-Detect Brake Source (Write Protect)\nNote: This register is write protected. Refer to REGWRPROT register.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>System Fail condition as level-detect brake source Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>System Fail condition as level-detect brake source Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKAEVEN</name>
              <description>PWM Brake Action Select For Even Channel (Write Protect)\nNote: This register is write protected. Refer to REGWRPROT register.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM even channel level-detect brake function not affect channel output</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM even channel output tri-state when level-detect brake happened</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>PWM even channel output low level when level-detect brake happened</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>PWM even channel output high level when level-detect brake happened</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKAODD</name>
              <description>PWM Brake Action Select For Odd Channel (Write Protect)\nNote: This register is write protected. Refer to REGWRPROT register.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM odd channel level-detect brake function not affect channel output</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM odd channel output tri-state when level-detect brake happened</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>PWM odd channel output low level when level-detect brake happened</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>PWM odd channel output high level when level-detect brake happened</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PWM_BRKCTL0_1">
          <name>PWM_BRKCTL2_3</name>
          <displayName>PWM_BRKCTL2_3</displayName>
          <description>PWM Brake Edge Detect Control Register 2_3</description>
          <addressOffset>0xCC</addressOffset>
       </register>
       <register derivedFrom="PWM_BRKCTL0_1">
          <name>PWM_BRKCTL4_5</name>
          <displayName>PWM_BRKCTL4_5</displayName>
          <description>PWM Brake Edge Detect Control Register 4_5</description>
          <addressOffset>0xD0</addressOffset>
       </register>
       <register>
          <name>PWM_POLCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_POLCTL</displayName>
          <description>PWM Pin Polar Inverse Register</description>
          <addressOffset>0xD4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PINVn</name>
              <description>PWM PIN Polar Inverse Control\nThe register controls polarity state of PWM output. Each bit n controls the corresponding PWM channel n.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM output polar inverse Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM output polar inverse Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM_POEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_POEN</displayName>
          <description>PWM Output Enable Register</description>
          <addressOffset>0xD8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>POENn</name>
              <description>PWM Pin Output Enable Control\nEach bit n controls the corresponding PWM channel n.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM pin at tri-state</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM pin in output mode</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM_SWBRK</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_SWBRK</displayName>
          <description>PWM Software Brake Control Register</description>
          <addressOffset>0xDC</addressOffset>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BRKETRGn</name>
              <description>PWM Edge Brake Software Trigger (Write Only) (Write Protect)\nEach bit n controls the corresponding PWM pair n.\nWrite 1 to this bit will trigger Edge brake, and set BRKEIFn to 1 in PWM_INTSTS1 register. \nNote: This register is write protected. Refer to REGWRPROT register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>BRKLTRGn</name>
              <description>PWM Level Brake Software Trigger (Write Only) (Write Protect)\nEach bit n controls the corresponding PWM pair n.\nWrite 1 to this bit will trigger level brake, and set BRKLIFn to 1 in PWM_INTSTS1 register. \nNote: This register is write protected. Refer to REGWRPROT register.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM_INTEN0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_INTEN0</displayName>
          <description>PWM Interrupt Enable Register 0</description>
          <addressOffset>0xE0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ZIEN0</name>
              <description>PWM Zero Point Interrupt Enable 0\nNote: Odd channels will read always 0 at complementary mode.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Zero point interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Zero point interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ZIEN2</name>
              <description>PWM Zero Point Interrupt Enable 2\nNote: Odd channels will read always 0 at complementary mode.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Zero point interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Zero point interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ZIEN4</name>
              <description>PWM Zero Point Interrupt Enable 4\nNote: Odd channels will read always 0 at complementary mode.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Zero point interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Zero point interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PIEN0</name>
              <description>PWM Period Point Interrupt Enable 0\nNote: When up-down counter type period point means center point.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Period point interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Period point interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PIEN2</name>
              <description>PWM Period Point Interrupt Enable 2\nNote: When up-down counter type period point means center point.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Period point interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Period point interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PIEN4</name>
              <description>PWM Period Point Interrupt Enable 4\nNote: When up-down counter type period point means center point.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Period point interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Period point interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPUIENn</name>
              <description>PWM Compare Up Count Interrupt Enable Control\nEach bit n controls the corresponding PWM channel n.\nNote: In complementary mode, CMPUIEN1, 3, 5 use as another CMPUIEN for channel 0, 2, 4.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Compare up count interrupt Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Compare up count interrupt Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPDIENn</name>
              <description>PWM Compare Down Count Interrupt Enable Control\nEach bit n controls the corresponding PWM channel n.\nNote: In complementary mode, CMPDIEN1, 3, 5 use as another CMPDIEN for channel 0, 2, 4.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Compare down count interrupt Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Compare down count interrupt Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM_INTEN1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_INTEN1</displayName>
          <description>PWM Interrupt Enable Register 1</description>
          <addressOffset>0xE4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BRKEIEN0_1</name>
              <description>PWM Edge-Detect Brake Interrupt Enable For Channel0/1 (Write Protect)\nNote: This register is write protected. Refer to REGWRPROT register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge-detect Brake interrupt for channel0/1 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Edge-detect Brake interrupt for channel0/1 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKEIEN2_3</name>
              <description>PWM Edge-Detect Brake Interrupt Enable For Channel2/3 (Write Protect)\nNote: This register is write protected. Refer to REGWRPROT register.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge-detect Brake interrupt for channel2/3 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Edge-detect Brake interrupt for channel2/3 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKEIEN4_5</name>
              <description>PWM Edge-Detect Brake Interrupt Enable For Channel4/5 (Write Protect)\nNote: This register is write protected. Refer to REGWRPROT register.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge-detect Brake interrupt for channel4/5 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Edge-detect Brake interrupt for channel4/5 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKLIEN0_1</name>
              <description>PWM Level-Detect Brake Interrupt Enable For Channel0/1 (Write Protect)\nNote: This register is write protected. Refer to REGWRPROT register.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Level-detect Brake interrupt for channel0/1 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level-detect Brake interrupt for channel0/1 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKLIEN2_3</name>
              <description>PWM Level-Detect Brake Interrupt Enable For Channel2/3 (Write Protect)\nNote: This register is write protected. Refer to REGWRPROT register.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Level-detect Brake interrupt for channel2/3 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level-detect Brake interrupt for channel2/3 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKLIEN4_5</name>
              <description>PWM Level-Detect Brake Interrupt Enable For Channel4/5 (Write Protect)\nNote: This register is write protected. Refer to REGWRPROT register.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Level-detect Brake interrupt for channel4/5 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level-detect Brake interrupt for channel4/5 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM_INTSTS0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_INTSTS0</displayName>
          <description>PWM Interrupt Flag Register 0</description>
          <addressOffset>0xE8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ZIF0</name>
              <description>PWM Zero Point Interrupt Flag 0\nThis bit is set by hardware when PWM_CH0 counter reaches zero, software can write 1 to clear this bit to zero.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ZIF2</name>
              <description>PWM Zero Point Interrupt Flag 2\nThis bit is set by hardware when PWM_CH2 counter reaches zero, software can write 1 to clear this bit to zero.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ZIF4</name>
              <description>PWM Zero Point Interrupt Flag 4\nThis bit is set by hardware when PWM_CH4 counter reaches zero, software can write 1 to clear this bit to zero.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PIF0</name>
              <description>PWM Period Point Interrupt Flag 0\nThis bit is set by hardware when PWM_CH0 counter reaches PWM_PERIOD0, software can write 1 to clear this bit to zero.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PIF2</name>
              <description>PWM Period Point Interrupt Flag 2\nThis bit is set by hardware when PWM_CH2 counter reaches PWM_PERIOD2, software can write 1 to clear this bit to zero.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PIF4</name>
              <description>PWM Period Point Interrupt Flag 4\nThis bit is set by hardware when PWM_CH4 counter reaches PWM_PERIOD4, software can write 1 to clear this bit to zero.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPUIFn</name>
              <description>PWM Compare Up Count Interrupt Flag\nFlag is set by hardware when PWM counter up count and reaches PWM_CMPDATn, software can clear this bit by writing 1 to it. Each bit n controls the corresponding PWM channel n.\nNote1: If CMPDAT equal to PERIOD, this flag is not working in up counter type selection.\nNote2: In complementary mode, CMPUIF1, 3, 5 use as another CMPUIF for channel 0, 2, 4.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPDIFn</name>
              <description>PWM Compare Down Count Interrupt Flag\nEach bit n controls the corresponding PWM channel n.\nFlag is set by hardware when PWM counter down count and reaches PWM_CMPDATn, software can clear this bit by writing 1 to it.\nNote1: If CMPDAT equal to PERIOD, this flag is not working in down counter type selection.\nNote2: In complementary mode, CMPDIF1, 3, 5 use as another CMPDIF for channel 0, 2, 4.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM_INTSTS1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_INTSTS1</displayName>
          <description>PWM Interrupt Flag Register 1</description>
          <addressOffset>0xEC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BRKEIF0</name>
              <description>PWM Channel0 Edge-Detect Brake Interrupt Flag (Write Protect)\nNote: This register is write protected. Refer to REGWRPROT register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel0 edge-detect brake event do not happened</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM channel0 edge-detect brake event happened, this bit is set to 1, writing 1 to clear</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKEIF1</name>
              <description>PWM Channel1 Edge-Detect Brake Interrupt Flag (Write Protect)\nNote: This register is write protected. Refer to REGWRPROT register.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel1 edge-detect brake event do not happened</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM channel1 edge-detect brake event happened, this bit is set to 1, writing 1 to clear</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKEIF2</name>
              <description>PWM Channel2 Edge-Detect Brake Interrupt Flag (Write Protect)\nNote: This register is write protected. Refer to REGWRPROT register.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel2 edge-detect brake event do not happened</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM channel2 edge-detect brake event happened, this bit is set to 1, writing 1 to clear</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKEIF3</name>
              <description>PWM Channel3 Edge-Detect Brake Interrupt Flag (Write Protect)\nNote: This register is write protected. Refer to REGWRPROT register.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel3 edge-detect brake event do not happened</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM channel3 edge-detect brake event happened, this bit is set to 1, writing 1 to clear</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKEIF4</name>
              <description>PWM Channel4 Edge-Detect Brake Interrupt Flag (Write Protect)\nNote: This register is write protected. Refer to REGWRPROT register.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel4 edge-detect brake event do not happened</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM channel4 edge-detect brake event happened, this bit is set to 1, writing 1 to clear</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKEIF5</name>
              <description>PWM Channel5 Edge-Detect Brake Interrupt Flag (Write Protect)\nNote: This register is write protected. Refer to REGWRPROT register.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel5 edge-detect brake event do not happened</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM channel5 edge-detect brake event happened, this bit is set to 1, writing 1 to clear</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKLIF0</name>
              <description>PWM Channel0 Level-Detect Brake Interrupt Flag (Write Protect)\nNote: This register is write protected. Refer to REGWRPROT register.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel0 level-detect brake event do not happened</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM channel0 level-detect brake event happened, this bit is set to 1, writing 1 to clear</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKLIF1</name>
              <description>PWM Channel1 Level-Detect Brake Interrupt Flag (Write Protect)\nNote: This register is write protected. Refer to REGWRPROT register.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel1 level-detect brake event do not happened</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM channel1 level-detect brake event happened, this bit is set to 1, writing 1 to clear</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKLIF2</name>
              <description>PWM Channel2 Level-Detect Brake Interrupt Flag (Write Protect)\nNote: This register is write protected. Refer to REGWRPROT register.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel2 level-detect brake event do not happened</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM channel2 level-detect brake event happened, this bit is set to 1, writing 1 to clear</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKLIF3</name>
              <description>PWM Channel3 Level-Detect Brake Interrupt Flag (Write Protect)\nNote: This register is write protected. Refer to REGWRPROT register.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel3 level-detect brake event do not happened</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM channel3 level-detect brake event happened, this bit is set to 1, writing 1 to clear</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKLIF4</name>
              <description>PWM Channel4 Level-Detect Brake Interrupt Flag (Write Protect)\nNote: This register is write protected. Refer to REGWRPROT register.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel4 level-detect brake event do not happened</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM channel4 level-detect brake event happened, this bit is set to 1, writing 1 to clear</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKLIF5</name>
              <description>PWM Channel5 Level-Detect Brake Interrupt Flag (Write Protect)\nNote: This register is write protected. Refer to REGWRPROT register.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel5 level-detect brake event do not happened</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM channel5 level-detect brake event happened, this bit is set to 1, writing 1 to clear</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKESTS0</name>
              <description>PWM Channel0 Edge-Detect Brake Status</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel0 edge-detect brake state is released</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM channel0 edge-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel0 at brake state, writing 1 to clear</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKESTS1</name>
              <description>PWM Channel1 Edge-Detect Brake Status</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel1 edge-detect brake state is released</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM channel1 edge-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel1 at brake state, writing 1 to clear</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKESTS2</name>
              <description>PWM Channel2 Edge-Detect Brake Status</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel2 edge-detect brake state is released</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM channel2 edge-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel2 at brake state, writing 1 to clear</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKESTS3</name>
              <description>PWM Channel3 Edge-Detect Brake Status</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel3 edge-detect brake state is released</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM channel3 edge-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel3 at brake state, writing 1 to clear</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKESTS4</name>
              <description>PWM Channel4 Edge-Detect Brake Status</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel4 edge-detect brake state is released</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM channel4 edge-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel4 at brake state, writing 1 to clear</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKESTS5</name>
              <description>PWM Channel5 Edge-Detect Brake Status</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel5 edge-detect brake state is released</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM channel5 edge-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel5 at brake state, writing 1 to clear</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKLSTS0</name>
              <description>PWM Channel0 Level-Detect Brake Status (Read Only)\nNote: This bit is read only and auto cleared by hardware. When enabled brake source return to high level, PWM will release brake state until current PWM period finished. The PWM waveform will start output from next full PWM period.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel0 level-detect brake state is released</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM channel0 level-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel0 at brake state</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BRKLSTS1</name>
              <description>PWM Channel1 Level-Detect Brake Status (Read Only)\nNote: This bit is read only and auto cleared by hardware. When enabled brake source return to high level, PWM will release brake state until current PWM period finished. The PWM waveform will start output from next full PWM period.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel1 level-detect brake state is released</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM channel1 level-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel1 at brake state</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BRKLSTS2</name>
              <description>PWM Channel2 Level-Detect Brake Status (Read Only)\nNote: This bit is read only and auto cleared by hardware. When enabled brake source return to high level, PWM will release brake state until current PWM period finished. The PWM waveform will start output from next full PWM period.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel2 level-detect brake state is released</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM channel2 level-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel2 at brake state</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BRKLSTS3</name>
              <description>PWM Channel3 Level-Detect Brake Status (Read Only)\nNote: This bit is read only and auto cleared by hardware. When enabled brake source return to high level, PWM will release brake state until current PWM period finished. The PWM waveform will start output from next full PWM period.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel3 level-detect brake state is released</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM channel3 level-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel3 at brake state</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BRKLSTS4</name>
              <description>PWM Channel4 Level-Detect Brake Status (Read Only)\nNote: This bit is read only and auto cleared by hardware. When enabled brake source return to high level, PWM will release brake state until current PWM period finished. The PWM waveform will start output from next full PWM period.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel4 level-detect brake state is released</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM channel4 level-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel4 at brake state</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BRKLSTS5</name>
              <description>PWM Channel5 Level-Detect Brake Status (Read Only)\nNote: This bit is read only and auto cleared by hardware. When enabled brake source return to high level, PWM will release brake state until current PWM period finished. The PWM waveform will start output from next full PWM period.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel5 level-detect brake state is released</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM channel5 level-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel5 at brake state</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM_ADCTS0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_ADCTS0</displayName>
          <description>PWM Trigger ADC Source Select Register 0</description>
          <addressOffset>0xF8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TRGSEL0</name>
              <description>PWM_CH0 Trigger ADC Source Select</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM_CH0 zero point</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM_CH0 period point</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>PWM_CH0 zero or period point</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>PWM_CH0 up-count CMPDAT point</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>PWM_CH0 down-count CMPDAT point</description>
                    <value>#0100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Reserved.</description>
                    <value>#0101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Reserved.</description>
                    <value>#0110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Reserved.</description>
                    <value>#0111</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>8</name>
                    <description>PWM_CH1 up-count CMPDAT point</description>
                    <value>#1000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>9</name>
                    <description>PWM_CH1 down-count CMPDAT point</description>
                    <value>#1001</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGEN0</name>
              <description>PWM_CH0 Trigger ADC Enable Control</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGSEL1</name>
              <description>PWM_CH1 Trigger ADC Source Select</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM_CH0 zero point</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM_CH0 period point</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>PWM_CH0 zero or period point</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>PWM_CH0 up-count CMPDAT point</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>PWM_CH0 down-count CMPDAT point</description>
                    <value>#0100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Reserved.</description>
                    <value>#0101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Reserved.</description>
                    <value>#0110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Reserved.</description>
                    <value>#0111</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>8</name>
                    <description>PWM_CH1 up-count CMPDAT point</description>
                    <value>#1000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>9</name>
                    <description>PWM_CH1 down-count CMPDAT point</description>
                    <value>#1001</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGEN1</name>
              <description>PWM_CH1 Trigger ADC Enable Control</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGSEL2</name>
              <description>PWM_CH2 Trigger ADC Source Select</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM_CH2 zero point</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM_CH2 period point</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>PWM_CH2 zero or period point</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>PWM_CH2 up-count CMPDAT point</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>PWM_CH2 down-count CMPDAT point</description>
                    <value>#0100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Reserved.</description>
                    <value>#0101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Reserved.</description>
                    <value>#0110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Reserved.</description>
                    <value>#0111</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>8</name>
                    <description>PWM_CH3 up-count CMPDAT point</description>
                    <value>#1000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>9</name>
                    <description>PWM_CH3 down-count CMPDAT point</description>
                    <value>#1001</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGEN2</name>
              <description>PWM_CH2 Trigger ADC Enable Control</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGSEL3</name>
              <description>PWM_CH3 Trigger ADC Source Select</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM_CH2 zero point</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM_CH2 period point</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>PWM_CH2 zero or period point</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>PWM_CH2 up-count CMPDAT point</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>PWM_CH2 down-count CMPDAT point</description>
                    <value>#0100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Reserved.</description>
                    <value>#0101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Reserved.</description>
                    <value>#0110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Reserved.</description>
                    <value>#0111</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>8</name>
                    <description>PWM_CH3 up-count CMPDAT point</description>
                    <value>#1000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>9</name>
                    <description>PWM_CH3 down-count CMPDAT point</description>
                    <value>#1001</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGEN3</name>
              <description>PWM_CH3 Trigger ADC Enable Control</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM_ADCTS1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_ADCTS1</displayName>
          <description>PWM Trigger ADC Source Select Register 1</description>
          <addressOffset>0xFC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TRGSEL4</name>
              <description>PWM_CH4 Trigger ADC Source Select</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM_CH4 zero point</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM_CH4 period point</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>PWM_CH4 zero or period point</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>PWM_CH4 up-count CMPDAT point</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>PWM_CH4 down-count CMPDAT point</description>
                    <value>#0100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Reserved.</description>
                    <value>#0101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Reserved.</description>
                    <value>#0110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Reserved.</description>
                    <value>#0111</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>8</name>
                    <description>PWM_CH5 up-count CMPDAT point</description>
                    <value>#1000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>9</name>
                    <description>PWM_CH5 down-count CMPDAT point</description>
                    <value>#1001</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGEN4</name>
              <description>PWM_CH4 Trigger ADC Enable Control</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGSEL5</name>
              <description>PWM_CH5 Trigger ADC Source Select</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM_CH4 zero point</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM_CH4 period point</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>PWM_CH4 zero or period point</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>PWM_CH4 up-count CMPDAT point</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>PWM_CH4 down-count CMPDAT point</description>
                    <value>#0100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Reserved.</description>
                    <value>#0101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Reserved.</description>
                    <value>#0110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Reserved.</description>
                    <value>#0111</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>8</name>
                    <description>PWM_CH5 up-count CMPDAT point</description>
                    <value>#1000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>9</name>
                    <description>PWM_CH5 down-count CMPDAT point</description>
                    <value>#1001</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGEN5</name>
              <description>PWM_CH5 Trigger ADC Enable Control</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM_SSCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_SSCTL</displayName>
          <description>PWM Synchronous Start Control Register</description>
          <addressOffset>0x110</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SSEN0</name>
              <description>PWM Synchronous Start Function Enable 0\nWhen synchronous start function is enabled, the PWM_CH0 counter enable bit (CNTEN0) can be enabled by writing PWM synchronous start trigger bit (CNTSEN). </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM synchronous start function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM synchronous start function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEN2</name>
              <description>PWM Synchronous Start Function Enable 2\nWhen synchronous start function is enabled, the PWM_CH2 counter enable bit (CNTEN2) can be enabled by writing PWM synchronous start trigger bit (CNTSEN). </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM synchronous start function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM synchronous start function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEN4</name>
              <description>PWM Synchronous Start Function Enable 4\nWhen synchronous start function is enabled, the PWM_CH4 counter enable bit (CNTEN4) can be enabled by writing PWM synchronous start trigger bit (CNTSEN). </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM synchronous start function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM synchronous start function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SSRC</name>
              <description>PWM Synchronous Start Source Select</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Synchronous start source come from PWM0</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Synchronous start source come from PWM1</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Synchronous start source come from BPWM0</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Synchronous start source come from BPWM1</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM_SSTRG</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_SSTRG</displayName>
          <description>PWM Synchronous Start Trigger Register</description>
          <addressOffset>0x114</addressOffset>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNTSEN</name>
              <description>PWM Counter Synchronous Start Enable (Write Only)\nPMW counter synchronous enable function is used to make selected PWM channels (include PWM0_CHx and PWM1_CHx) start counting at the same time.\nWriting this bit to 1 will also set the counter enable bit (CNTENn, n denotes channel 0 to 5) if correlated PWM channel counter synchronous start function is enabled.\nNote: This bit only present in PWM0_BA.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM_STATUS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_STATUS</displayName>
          <description>PWM Status Register</description>
          <addressOffset>0x120</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNTMAX0</name>
              <description>Time-Base Counter 0 Equal To 0xFFFF Latched Status</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>indicates the time-base counter never reached its maximum value 0xFFFF</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>indicates the time-base counter reached its maximum value, software can write 1 to clear this bit</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CNTMAX2</name>
              <description>Time-Base Counter 2 Equal To 0xFFFF Latched Status</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>indicates the time-base counter never reached its maximum value 0xFFFF</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>indicates the time-base counter reached its maximum value, software can write 1 to clear this bit</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CNTMAX4</name>
              <description>Time-Base Counter 4 Equal To 0xFFFF Latched Status</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>indicates the time-base counter never reached its maximum value 0xFFFF</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>indicates the time-base counter reached its maximum value, software can write 1 to clear this bit</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADCTRGn</name>
              <description>ADC Start Of Conversion Status\nEach bit n controls the corresponding PWM channel n.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Indicates no ADC start of conversion trigger event has occurred</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Indicates an ADC start of conversion trigger event has occurred, software can write 1 to clear this bit</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM_CAPINEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_CAPINEN</displayName>
          <description>PWM Capture Input Enable Register</description>
          <addressOffset>0x200</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CAPINENn</name>
              <description>Capture Input Enable\nEach bit n controls the corresponding PWM channel n.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM Channel capture input path Disabled. The input of PWM channel capture function is always regarded as 0</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM Channel capture input path Enabled. The input of PWM channel capture function comes from correlative multifunction pin</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM_CAPCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_CAPCTL</displayName>
          <description>PWM Capture Control Register</description>
          <addressOffset>0x204</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CAPENn</name>
              <description>Capture Function Enable Control\nEach bit n controls the corresponding PWM channel n.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Capture function Disabled. RCAPDAT/FCAPDAT register will not be updated</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture function Enabled. Capture latched the PWM counter value when detected rising or falling edge of input signal and saved to RCAPDAT (Rising latch) and FCAPDAT (Falling latch)</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPINVn</name>
              <description>Capture Inverter Enable Control\nEach bit n controls the corresponding PWM channel n.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Capture source inverter Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture source inverter Enabled. Reverse the input signal from GPIO</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RCRLDENn</name>
              <description>Rising Capture Reload Enable Control\nEach bit n controls the corresponding PWM channel n.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Rising capture reload counter Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Rising capture reload counter Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FCRLDENn</name>
              <description>Falling Capture Reload Enable Control\nEach bit n controls the corresponding PWM channel n.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Falling capture reload counter Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Falling capture reload counter Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM_CAPSTS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_CAPSTS</displayName>
          <description>PWM Capture Status Register</description>
          <addressOffset>0x208</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CRLIFOVn</name>
              <description>Capture Rising Latch Interrupt Flag Overrun Status (Read Only)\nThis flag indicates if rising latch happened when the corresponding CRLIF is 1. Each bit n controls the corresponding PWM channel n.\nNote: This bit will be cleared automatically when user clear corresponding CRLIF.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CFLIFOVn</name>
              <description>Capture Falling Latch Interrupt Flag Overrun Status (Read Only)\nThis flag indicates if falling latch happened when the corresponding CFLIF is 1. Each bit n controls the corresponding PWM channel n.\nNote: This bit will be cleared automatically when user clear corresponding CFLIF.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM_RCAPDAT0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_RCAPDAT0</displayName>
          <description>PWM Rising Capture Data Register 0</description>
          <addressOffset>0x20C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RCAPDAT</name>
              <description>PWM Rising Capture Data Register (Read Only)\nWhen rising capture condition happened, the PWM counter value will be saved in this register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM_FCAPDAT0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_FCAPDAT0</displayName>
          <description>PWM Falling Capture Data Register 0</description>
          <addressOffset>0x210</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FCAPDAT</name>
              <description>PWM Falling Capture Data Register (Read Only)\nWhen falling capture condition happened, the PWM counter value will be saved in this register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PWM_RCAPDAT0">
          <name>PWM_RCAPDAT1</name>
          <displayName>PWM_RCAPDAT1</displayName>
          <description>PWM Rising Capture Data Register 1</description>
          <addressOffset>0x214</addressOffset>
       </register>
       <register derivedFrom="PWM_FCAPDAT0">
          <name>PWM_FCAPDAT1</name>
          <displayName>PWM_FCAPDAT1</displayName>
          <description>PWM Falling Capture Data Register 1</description>
          <addressOffset>0x218</addressOffset>
       </register>
       <register derivedFrom="PWM_RCAPDAT0">
          <name>PWM_RCAPDAT2</name>
          <displayName>PWM_RCAPDAT2</displayName>
          <description>PWM Rising Capture Data Register 2</description>
          <addressOffset>0x21C</addressOffset>
       </register>
       <register derivedFrom="PWM_FCAPDAT0">
          <name>PWM_FCAPDAT2</name>
          <displayName>PWM_FCAPDAT2</displayName>
          <description>PWM Falling Capture Data Register 2</description>
          <addressOffset>0x220</addressOffset>
       </register>
       <register derivedFrom="PWM_RCAPDAT0">
          <name>PWM_RCAPDAT3</name>
          <displayName>PWM_RCAPDAT3</displayName>
          <description>PWM Rising Capture Data Register 3</description>
          <addressOffset>0x224</addressOffset>
       </register>
       <register derivedFrom="PWM_FCAPDAT0">
          <name>PWM_FCAPDAT3</name>
          <displayName>PWM_FCAPDAT3</displayName>
          <description>PWM Falling Capture Data Register 3</description>
          <addressOffset>0x228</addressOffset>
       </register>
       <register derivedFrom="PWM_RCAPDAT0">
          <name>PWM_RCAPDAT4</name>
          <displayName>PWM_RCAPDAT4</displayName>
          <description>PWM Rising Capture Data Register 4</description>
          <addressOffset>0x22C</addressOffset>
       </register>
       <register derivedFrom="PWM_FCAPDAT0">
          <name>PWM_FCAPDAT4</name>
          <displayName>PWM_FCAPDAT4</displayName>
          <description>PWM Falling Capture Data Register 4</description>
          <addressOffset>0x230</addressOffset>
       </register>
       <register derivedFrom="PWM_RCAPDAT0">
          <name>PWM_RCAPDAT5</name>
          <displayName>PWM_RCAPDAT5</displayName>
          <description>PWM Rising Capture Data Register 5</description>
          <addressOffset>0x234</addressOffset>
       </register>
       <register derivedFrom="PWM_FCAPDAT0">
          <name>PWM_FCAPDAT5</name>
          <displayName>PWM_FCAPDAT5</displayName>
          <description>PWM Falling Capture Data Register 5</description>
          <addressOffset>0x238</addressOffset>
       </register>
       <register>
          <name>PWM_CAPIEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_CAPIEN</displayName>
          <description>PWM Capture Interrupt Enable Register</description>
          <addressOffset>0x250</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CAPRIENn</name>
              <description>PWM Capture Rising Latch Interrupt Enable Control\nEach bit n controls the corresponding PWM channel n.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Capture rising edge latch interrupt Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture rising edge latch interrupt Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPFIENn</name>
              <description>PWM Capture Falling Latch Interrupt Enable Control\nEach bit n controls the corresponding PWM channel n.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Capture falling edge latch interrupt Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture falling edge latch interrupt Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM_CAPIF</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_CAPIF</displayName>
          <description>PWM Capture Interrupt Flag Register</description>
          <addressOffset>0x254</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CRLIFn</name>
              <description>PWM Capture Rising Latch Interrupt Flag\nThis bit is writing 1 to clear. Each bit n controls the corresponding PWM channel n.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No capture rising latch condition happened</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture rising latch condition happened, this flag will be set to high</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CFLIFn</name>
              <description>PWM Capture Falling Latch Interrupt Flag\nThis bit is writing 1 to clear. Each bit n controls the corresponding PWM channel n.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No capture falling latch condition happened</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture falling latch condition happened, this flag will be set to high</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM_PBUF0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_PBUF0</displayName>
          <description>PWM PERIOD0 Buffer</description>
          <addressOffset>0x304</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PBUF</name>
              <description>PWM Period Register Buffer (Read Only)\nUsed as PERIOD active register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PWM_PBUF0">
          <name>PWM_PBUF2</name>
          <displayName>PWM_PBUF2</displayName>
          <description>PWM PERIOD2 Buffer</description>
          <addressOffset>0x30C</addressOffset>
       </register>
       <register derivedFrom="PWM_PBUF0">
          <name>PWM_PBUF4</name>
          <displayName>PWM_PBUF4</displayName>
          <description>PWM PERIOD4 Buffer</description>
          <addressOffset>0x314</addressOffset>
       </register>
       <register>
          <name>PWM_CMPBUF0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM_CMPBUF0</displayName>
          <description>PWM CMPDAT0 Buffer</description>
          <addressOffset>0x31C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMPBUF</name>
              <description>PWM Comparator Register Buffer (Read Only)\nUsed as CMP active register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PWM_CMPBUF0">
          <name>PWM_CMPBUF1</name>
          <displayName>PWM_CMPBUF1</displayName>
          <description>PWM CMPDAT1 Buffer</description>
          <addressOffset>0x320</addressOffset>
       </register>
       <register derivedFrom="PWM_CMPBUF0">
          <name>PWM_CMPBUF2</name>
          <displayName>PWM_CMPBUF2</displayName>
          <description>PWM CMPDAT2 Buffer</description>
          <addressOffset>0x324</addressOffset>
       </register>
       <register derivedFrom="PWM_CMPBUF0">
          <name>PWM_CMPBUF3</name>
          <displayName>PWM_CMPBUF3</displayName>
          <description>PWM CMPDAT3 Buffer</description>
          <addressOffset>0x328</addressOffset>
       </register>
       <register derivedFrom="PWM_CMPBUF0">
          <name>PWM_CMPBUF4</name>
          <displayName>PWM_CMPBUF4</displayName>
          <description>PWM CMPDAT4 Buffer</description>
          <addressOffset>0x32C</addressOffset>
       </register>
       <register derivedFrom="PWM_CMPBUF0">
          <name>PWM_CMPBUF5</name>
          <displayName>PWM_CMPBUF5</displayName>
          <description>PWM CMPDAT5 Buffer</description>
          <addressOffset>0x330</addressOffset>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>BPWM0</name>
      <description>BPWM Register Map</description>
      <groupName>BPWM</groupName>
      <baseAddress>0x40044000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x10</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x20</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x30</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x50</offset>
        <size>0x18</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x90</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0xB0</offset>
        <size>0x10</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0xD4</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0xE0</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0xE8</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0xF8</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x110</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x120</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x200</offset>
        <size>0x3C</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x250</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x304</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x31C</offset>
        <size>0x18</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>BPWM_CTL0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BPWM_CTL0</displayName>
          <description>BPWM Control Register 0</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CTRLDn</name>
              <description>Center Re-Load\nEach bit n controls the corresponding BPWM channel n.\nIn up-down counter type, PERIOD will load to PBUF at the end point of each period. CMPDAT will load to CMPBUF at the center point of a period.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IMMLDENn</name>
              <description>Immediately Load Enable\nEach bit n controls the corresponding BPWM channel n.\nNote: If IMMLDENn is enabled, WINLDENn and CTRLDn will be invalid.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PERIOD will load to PBUF at the end point of each period. CMPDAT will load to CMPBUF at the end point or center point of each period by setting CTRLD bit</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PERIOD/CMPDAT will load to PBUF and CMPBUF immediately when software update PERIOD/CMPDAT</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBGHALT</name>
              <description>ICE Debug Mode Counter Halt (Write Protect)\nIf counter halt is enabled, BPWM all counters will keep current value until exit ICE debug mode. \nNote: This register is write protected. Refer to SYS_REGLCTL register.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ICE debug mode counter halt disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ICE debug mode counter halt enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBGTRIOFF</name>
              <description>ICE Debug Mode Acknowledge Disable (Write Protect)\nBPWM pin will keep output no matter ICE debug mode acknowledged or not.\nNote: This register is write protected. Refer to SYS_REGLCTL register.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ICE debug mode acknowledgement effects BPWM output</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ICE debug mode acknowledgement disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>BPWM_CTL1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BPWM_CTL1</displayName>
          <description>BPWM Control Register 1</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNTTYPE0</name>
              <description>BPWM Counter Behavior Type 0\nEach bit n controls corresponding BPWM channel n.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Up counter type (supports in capture mode)</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Down count type (supports in capture mode)</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Up-down counter type</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved.</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>BPWM_CLKSRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BPWM_CLKSRC</displayName>
          <description>BPWM Clock Source Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ECLKSRC0</name>
              <description>BPWM_CH01 External Clock Source Select</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>BPWMx_CLK, x denotes 0 or 1</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TIMER0 overflow</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>TIMER1 overflow</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>TIMER2 overflow</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>TIMER3 overflow</description>
                    <value>#100</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>BPWM_CLKPSC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BPWM_CLKPSC</displayName>
          <description>BPWM Clock Pre-scale Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLKPSC</name>
              <description>BPWM Counter Clock Pre-Scale \nThe clock of BPWM counter is decided by clock prescaler. Each BPWM pair share one BPWM counter clock prescaler. The clock of BPWM counter is divided by (CLKPSC+ 1).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>BPWM_CNTEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BPWM_CNTEN</displayName>
          <description>BPWM Counter Enable Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNTEN0</name>
              <description>BPWM Counter Enable 0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>BPWM Counter and clock prescaler Stop Running</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>BPWM Counter and clock prescaler Start Running</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>BPWM_CNTCLR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BPWM_CNTCLR</displayName>
          <description>BPWM Clear Counter Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNTCLR0</name>
              <description>Clear BPWM Counter Control Bit 0\nIt is automatically cleared by hardware.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clear 16-bit BPWM counter to 0000H</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>BPWM_PERIOD</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BPWM_PERIOD</displayName>
          <description>BPWM Period Register</description>
          <addressOffset>0x30</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PERIOD</name>
              <description>BPWM Period Register\nUp-Count mode: In this mode, BPWM counter counts from 0 to PERIOD, and restarts from 0.\nDown-Count mode: In this mode, BPWM counter counts from PERIOD to 0, and restarts from PERIOD.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>BPWM_CMPDAT0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BPWM_CMPDAT0</displayName>
          <description>BPWM Comparator Register 0</description>
          <addressOffset>0x50</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMP</name>
              <description>BPWM Comparator Register\nCMP use to compare with CNT to generate BPWM waveform, interrupt and trigger ADC.\nIn independent mode, BPWM_CMPDAT0~5 denote as 6 independent BPWM_CH0~5 compared point.\nIn complementary mode, BPWM_CMPDAT0, 2, 4 denote as first compared point, and BPWM_CMPDAT1, 3, 5 denote as second compared point for the corresponding 3 complementary pairs BPWM_CH0 and BPWM_CH1, BPWM_CH2 and BPWM_CH3, BPWM_CH4 and BPWM_CH5.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="BPWM_CMPDAT0">
          <name>BPWM_CMPDAT1</name>
          <displayName>BPWM_CMPDAT1</displayName>
          <description>BPWM Comparator Register 1</description>
          <addressOffset>0x54</addressOffset>
       </register>
       <register derivedFrom="BPWM_CMPDAT0">
          <name>BPWM_CMPDAT2</name>
          <displayName>BPWM_CMPDAT2</displayName>
          <description>BPWM Comparator Register 2</description>
          <addressOffset>0x58</addressOffset>
       </register>
       <register derivedFrom="BPWM_CMPDAT0">
          <name>BPWM_CMPDAT3</name>
          <displayName>BPWM_CMPDAT3</displayName>
          <description>BPWM Comparator Register 3</description>
          <addressOffset>0x5C</addressOffset>
       </register>
       <register derivedFrom="BPWM_CMPDAT0">
          <name>BPWM_CMPDAT4</name>
          <displayName>BPWM_CMPDAT4</displayName>
          <description>BPWM Comparator Register 4</description>
          <addressOffset>0x60</addressOffset>
       </register>
       <register derivedFrom="BPWM_CMPDAT0">
          <name>BPWM_CMPDAT5</name>
          <displayName>BPWM_CMPDAT5</displayName>
          <description>BPWM Comparator Register 5</description>
          <addressOffset>0x64</addressOffset>
       </register>
       <register>
          <name>BPWM_CNT0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BPWM_CNT0</displayName>
          <description>BPWM Counter Register 0</description>
          <addressOffset>0x90</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNT</name>
              <description>BPWM Data Register (Read Only)\nUser can monitor CNT to know the current value in 16-bit period counter.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DIRF</name>
              <description>BPWM Direction Indicator Flag (Read Only)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Counter is Down count</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Counter is UP count</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>BPWM_WGCTL0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BPWM_WGCTL0</displayName>
          <description>BPWM Generation Register 0</description>
          <addressOffset>0xB0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ZPCTLn</name>
              <description>BPWM Zero Point Control\nEach bit n controls the corresponding BPWM channel n.\nBPWM can control output level when BPWM counter count to zero.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Do nothing</description>
                    <value>00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>BPWM zero point output Low</description>
                    <value>01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>10</name>
                    <description>BPWM zero point output High</description>
                    <value>10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>11</name>
                    <description>BPWM zero point output Toggle</description>
                    <value>11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PRDPCTLn</name>
              <description>BPWM Period (Center) Point Control\nEach bit n controls the corresponding BPWM channel n.\nBPWM can control output level when BPWM counter count to (PERIODn+1).\nNote: This bit is center point control when BPWM counter operating in up-down counter type.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>12</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Do nothing</description>
                    <value>00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>BPWM period (center) point output Low</description>
                    <value>01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>10</name>
                    <description>BPWM period (center) point output High</description>
                    <value>10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>11</name>
                    <description>BPWM period (center) point output Toggle</description>
                    <value>11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>BPWM_WGCTL1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BPWM_WGCTL1</displayName>
          <description>BPWM Generation Register 1</description>
          <addressOffset>0xB4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMPUCTLn</name>
              <description>BPWM Compare Up Point Control\nEach bit n controls the corresponding BPWM channel n.\nBPWM can control output level when BPWM counter up count to CMPDAT.\nNote: In complementary mode, CMPUCTL1, 3, 5 use as another CMPUCTL for channel 0, 2, 4.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Do nothing</description>
                    <value>00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>BPWM compare up point output Low</description>
                    <value>01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>10</name>
                    <description>BPWM compare up point output High</description>
                    <value>10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>11</name>
                    <description>BPWM compare up point output Toggle</description>
                    <value>11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPDCTLn</name>
              <description>BPWM Compare Down Point Control\nEach bit n controls the corresponding BPWM channel n.\nBPWM can control output level when BPWM counter down count to CMPDAT.\nNote: In complementary mode, CMPDCTL1, 3, 5 use as another CMPDCTL for channel 0, 2, 4.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>12</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Do nothing</description>
                    <value>00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>BPWM compare down point output Low</description>
                    <value>01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>10</name>
                    <description>BPWM compare down point output High</description>
                    <value>10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>11</name>
                    <description>BPWM compare down point output Toggle</description>
                    <value>11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>BPWM_MSKEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BPWM_MSKEN</displayName>
          <description>BPWM Mask Enable Register</description>
          <addressOffset>0xB8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MSKENn</name>
              <description>BPWM Mask Enable Control\nEach bit n controls the corresponding BPWM channel n.\nThe BPWM output signal will be masked when this bit is enabled. The corresponding BPWM channel n will output MSKDATn (BPWM_MSK[5:0]) data. </description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>BPWM output signal is non-masked</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>BPWM output signal is masked and output MSKDATn data</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>BPWM_MSK</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BPWM_MSK</displayName>
          <description>BPWM Mask Data Register</description>
          <addressOffset>0xBC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MSKDATn</name>
              <description>BPWM Mask Data Bit\nThis data bit control the state of BPWMn output pin, if corresponding mask function is enabled. Each bit n controls the corresponding BPWM channel n.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Output logic low to BPWMn</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Output logic high to BPWMn</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>BPWM_POLCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BPWM_POLCTL</displayName>
          <description>BPWM Pin Polar Inverse Register</description>
          <addressOffset>0xD4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PINVn</name>
              <description>BPWM PIN Polar Inverse Control\nThe register controls polarity state of BPWM output. Each bit n controls the corresponding BPWM channel n.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>BPWM output polar inverse Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>BPWM output polar inverse Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>BPWM_POEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BPWM_POEN</displayName>
          <description>BPWM Output Enable Register</description>
          <addressOffset>0xD8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>POENn</name>
              <description>BPWM Pin Output Enable Control\nEach bit n controls the corresponding BPWM channel n.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>BPWM pin at tri-state</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>BPWM pin in output mode</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>BPWM_INTEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BPWM_INTEN</displayName>
          <description>BPWM Interrupt Enable Register</description>
          <addressOffset>0xE0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ZIEN0</name>
              <description>BPWM Zero Point Interrupt Enable 0\nNote: Odd channels will read always 0 at complementary mode.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Zero point interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Zero point interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PIEN0</name>
              <description>BPWM Period Point Interrupt Enable 0\nNote: When up-down counter type period point means center point.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Period point interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Period point interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPUIENn</name>
              <description>BPWM Compare Up Count Interrupt Enable Control\nEach bit n controls the corresponding BPWM channel n.\nNote: In complementary mode, CMPUIEN1, 3, 5 use as another CMPUIEN for channel 0, 2, 4.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Compare up count interrupt Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Compare up count interrupt Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPDIENn</name>
              <description>BPWM Compare Down Count Interrupt Enable Control\nEach bit n controls the corresponding BPWM channel n.\nNote: In complementary mode, CMPDIEN1, 3, 5 use as another CMPDIEN for channel 0, 2, 4.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Compare down count interrupt Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Compare down count interrupt Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>BPWM_INTSTS0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BPWM_INTSTS0</displayName>
          <description>BPWM Interrupt Flag Register</description>
          <addressOffset>0xE8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ZIF0</name>
              <description>BPWM Zero Point Interrupt Flag 0\nThis bit is set by hardware when BPWM_CH0 counter reaches zero, software can write 1 to clear this bit to zero.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PIF0</name>
              <description>BPWM Period Point Interrupt Flag 0\nThis bit is set by hardware when BPWM_CH0 counter reaches BPWM_PERIOD0, software can write 1 to clear this bit to zero.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPUIFn</name>
              <description>BPWM Compare Up Count Interrupt Flag\nFlag is set by hardware when BPWM counter up count and reaches BPWM_CMPDATn, software can clear this bit by writing 1 to it. Each bit n controls the corresponding BPWM channel n.\nNote1: If CMPDAT equal to PERIOD, this flag is not working in up counter type selection.\nNote2: In complementary mode, CMPUIF1, 3, 5 use as another CMPUIF for channel 0, 2, 4.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPDIFn</name>
              <description>BPWM Compare Down Count Interrupt Flag\nEach bit n controls the corresponding BPWM channel n.\nFlag is set by hardware when BPWM counter down count and reaches BPWM_CMPDATn, software can clear this bit by writing 1 to it.\nNote1: If CMPDAT equal to PERIOD, this flag is not working in down counter type selection.\nNote2: In complementary mode, CMPDIF1, 3, 5 use as another CMPDIF for channel 0, 2, 4.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>BPWM_ADCTS0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BPWM_ADCTS0</displayName>
          <description>BPWM Trigger ADC Source Select Register 0</description>
          <addressOffset>0xF8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TRGSEL0</name>
              <description>BPWM_CH0 Trigger ADC Source Select</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>BPWM_CH0 zero point</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>BPWM_CH0 period point</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>BPWM_CH0 zero or period point</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>BPWM_CH0 up-count CMPDAT point</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>BPWM_CH0 down-count CMPDAT point</description>
                    <value>#0100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Reserved.</description>
                    <value>#0101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Reserved.</description>
                    <value>#0110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Reserved.</description>
                    <value>#0111</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>8</name>
                    <description>BPWM_CH1 up-count CMPDAT point</description>
                    <value>#1000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>9</name>
                    <description>BPWM_CH1 down-count CMPDAT point</description>
                    <value>#1001</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGEN0</name>
              <description>BPWM_CH0 Trigger ADC Enable Control</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGSEL1</name>
              <description>BPWM_CH1 Trigger ADC Source Select</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>BPWM_CH0 zero point</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>BPWM_CH0 period point</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>BPWM_CH0 zero or period point</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>BPWM_CH0 up-count CMPDAT point</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>BPWM_CH0 down-count CMPDAT point</description>
                    <value>#0100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Reserved.</description>
                    <value>#0101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Reserved.</description>
                    <value>#0110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Reserved.</description>
                    <value>#0111</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>8</name>
                    <description>BPWM_CH1 up-count CMPDAT point</description>
                    <value>#1000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>9</name>
                    <description>BPWM_CH1 down-count CMPDAT point</description>
                    <value>#1001</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGEN1</name>
              <description>BPWM_CH1 Trigger ADC Enable Control</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGSEL2</name>
              <description>BPWM_CH2 Trigger ADC Source Select\nOthers reserved.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>BPWM_CH2 zero point</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>BPWM_CH2 period point</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>BPWM_CH2 zero or period point</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>BPWM_CH2 up-count CMPDAT point</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>BPWM_CH2 down-count CMPDAT point</description>
                    <value>#0100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Reserved.</description>
                    <value>#0101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Reserved.</description>
                    <value>#0110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Reserved.</description>
                    <value>#0111</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>8</name>
                    <description>BPWM_CH3 up-count CMPDAT point</description>
                    <value>#1000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>9</name>
                    <description>BPWM_CH3 down-count CMPDAT point</description>
                    <value>#1001</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGEN2</name>
              <description>BPWM_CH2 Trigger ADC Enable Control</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGSEL3</name>
              <description>BPWM_CH3 Trigger ADC Source Select</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>BPWM_CH2 zero point</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>BPWM_CH2 period point</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>BPWM_CH2 zero or period point</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>BPWM_CH2 up-count CMPDAT point</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>BPWM_CH2 down-count CMPDAT point</description>
                    <value>#0100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Reserved.</description>
                    <value>#0101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Reserved.</description>
                    <value>#0110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Reserved.</description>
                    <value>#0111</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>8</name>
                    <description>BPWM_CH3 up-count CMPDAT point</description>
                    <value>#1000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>9</name>
                    <description>BPWM_CH3 down-count CMPDAT point</description>
                    <value>#1001</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGEN3</name>
              <description>BPWM_CH3 Trigger ADC Enable Control</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>BPWM_ADCTS1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BPWM_ADCTS1</displayName>
          <description>BPWM Trigger ADC Source Select Register 1</description>
          <addressOffset>0xFC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TRGSEL4</name>
              <description>BPWM_CH4 Trigger ADC Source Select</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>BPWM_CH4 zero point</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>BPWM_CH4 period point</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>BPWM_CH4 zero or period point</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>BPWM_CH4 up-count CMPDAT point</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>BPWM_CH4 down-count CMPDAT point</description>
                    <value>#0100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Reserved.</description>
                    <value>#0101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Reserved.</description>
                    <value>#0110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Reserved.</description>
                    <value>#0111</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>8</name>
                    <description>BPWM_CH5 up-count CMPDAT point</description>
                    <value>#1000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>9</name>
                    <description>BPWM_CH5 down-count CMPDAT point</description>
                    <value>#1001</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGEN4</name>
              <description>BPWM_CH4 Trigger ADC Enable Control</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGSEL5</name>
              <description>BPWM_CH5 Trigger ADC Source Select</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>BPWM_CH4 zero point</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>BPWM_CH4 period point</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>BPWM_CH4 zero or period point</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>BPWM_CH4 up-count CMPDAT point</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>BPWM_CH4 down-count CMPDAT point</description>
                    <value>#0100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Reserved.</description>
                    <value>#0101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Reserved.</description>
                    <value>#0110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Reserved.</description>
                    <value>#0111</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>8</name>
                    <description>BPWM_CH5 up-count CMPDAT point</description>
                    <value>#1000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>9</name>
                    <description>BPWM_CH5 down-count CMPDAT point</description>
                    <value>#1001</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGEN5</name>
              <description>BPWM_CH5 Trigger ADC Enable Control</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>BPWM_SSCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BPWM_SSCTL</displayName>
          <description>BPWM Synchronous Start Control Register</description>
          <addressOffset>0x110</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SSEN0</name>
              <description>BPWM Synchronous Start Function Enable 0\nWhen synchronous start function is enabled, the BPWM_CH0 counter enable bit (CNTEN0) can be enabled by writing BPWM synchronous start trigger bit (CNTSEN). </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>BPWM synchronous start function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>BPWM synchronous start function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SSRC</name>
              <description>BPWM Synchronous Start Source Select</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Synchronous start source come from BPWM0</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Synchronous start source come from BPWM1</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Synchronous start source come from BPWM0</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Synchronous start source come from BPWM1</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>BPWM_SSTRG</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BPWM_SSTRG</displayName>
          <description>BPWM Synchronous Start Trigger Register</description>
          <addressOffset>0x114</addressOffset>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNTSEN</name>
              <description>BPWM Counter Synchronous Start Enable (Write Only)\nPMW counter synchronous enable function is used to make selected BPWM channels (include BPWM0_CHx and BPWM1_CHx) start counting at the same time.\nWriting this bit to 1 will also set the counter enable bit (CNTENn, n denotes channel 0 to 5) if correlated BPWM channel counter synchronous start function is enabled.\nNote: This bit only present in BPWM0_BA.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>BPWM_STATUS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BPWM_STATUS</displayName>
          <description>BPWM Status Register</description>
          <addressOffset>0x120</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNTMAX0</name>
              <description>Time-Base Counter 0 Equal To 0xFFFF Latched Status</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Indicates the time-base counter never reached its maximum value 0xFFFF</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Indicates the time-base counter reached its maximum value, software can write 1 to clear this bit</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADCTRGn</name>
              <description>ADC Start Of Conversion Status\nEach bit n controls the corresponding BPWM channel n.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Indicates no ADC start of conversion trigger event has occurred</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Indicates an ADC start of conversion trigger event has occurred, software can write 1 to clear this bit</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>BPWM_CAPINEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BPWM_CAPINEN</displayName>
          <description>BPWM Capture Input Enable Register</description>
          <addressOffset>0x200</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CAPINENn</name>
              <description>Capture Input Enable Control\nEach bit n controls the corresponding BPWM channel n.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>BPWM Channel capture input path Disabled. The input of BPWM channel capture function is always regarded as 0</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>BPWM Channel capture input path Enabled. The input of BPWM channel capture function comes from correlative multifunction pin</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>BPWM_CAPCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BPWM_CAPCTL</displayName>
          <description>BPWM Capture Control Register</description>
          <addressOffset>0x204</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CAPENn</name>
              <description>Capture Function Enable Control\nEach bit n controls the corresponding BPWM channel n.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Capture function Disabled. RCAPDAT/FCAPDAT register will not be updated</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture function Enabled. Capture latched the BPWM counter value when detected rising or falling edge of input signal and saved to RCAPDAT (Rising latch) and FCAPDAT (Falling latch)</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPINVn</name>
              <description>Capture Inverter Enable Control\nEach bit n controls the corresponding BPWM channel n.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Capture source inverter Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture source inverter Enabled. Reverse the input signal from GPIO</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RCRLDENn</name>
              <description>Rising Capture Reload Enable Control\nEach bit n controls the corresponding BPWM channel n.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Rising capture reload counter Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Rising capture reload counter Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FCRLDENn</name>
              <description>Falling Capture Reload Enable Control\nEach bit n controls the corresponding BPWM channel n.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Falling capture reload counter Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Falling capture reload counter Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>BPWM_CAPSTS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BPWM_CAPSTS</displayName>
          <description>BPWM Capture Status Register</description>
          <addressOffset>0x208</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CRLIFOVn</name>
              <description>Capture Rising Latch Interrupt Flag Overrun Status (Read Only)\nThis flag indicates if rising latch happened when the corresponding CRLIF is 1. Each bit n controls the corresponding BPWM channel n.\nNote: This bit will be cleared automatically when user clear corresponding CRLIF.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CFLIFOVn</name>
              <description>Capture Falling Latch Interrupt Flag Overrun Status (Read Only)\nThis flag indicates if falling latch happened when the corresponding CFLIF is 1. Each bit n controls the corresponding BPWM channel n.\nNote: This bit will be cleared automatically when user clear corresponding CFLIF.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>BPWM_RCAPDAT0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BPWM_RCAPDAT0</displayName>
          <description>BPWM Rising Capture Data Register 0</description>
          <addressOffset>0x20C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RCAPDAT</name>
              <description>BPWM Rising Capture Data Register (Read Only)\nWhen rising capture condition happened, the BPWM counter value will be saved in this register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>BPWM_FCAPDAT0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BPWM_FCAPDAT0</displayName>
          <description>BPWM Falling Capture Data Register 0</description>
          <addressOffset>0x210</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FCAPDAT</name>
              <description>BPWM Falling Capture Data Register (Read Only)\nWhen falling capture condition happened, the BPWM counter value will be saved in this register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="BPWM_RCAPDAT0">
          <name>BPWM_RCAPDAT1</name>
          <displayName>BPWM_RCAPDAT1</displayName>
          <description>BPWM Rising Capture Data Register 1</description>
          <addressOffset>0x214</addressOffset>
       </register>
       <register derivedFrom="BPWM_FCAPDAT0">
          <name>BPWM_FCAPDAT1</name>
          <displayName>BPWM_FCAPDAT1</displayName>
          <description>BPWM Falling Capture Data Register 1</description>
          <addressOffset>0x218</addressOffset>
       </register>
       <register derivedFrom="BPWM_RCAPDAT0">
          <name>BPWM_RCAPDAT2</name>
          <displayName>BPWM_RCAPDAT2</displayName>
          <description>BPWM Rising Capture Data Register 2</description>
          <addressOffset>0x21C</addressOffset>
       </register>
       <register derivedFrom="BPWM_FCAPDAT0">
          <name>BPWM_FCAPDAT2</name>
          <displayName>BPWM_FCAPDAT2</displayName>
          <description>BPWM Falling Capture Data Register 2</description>
          <addressOffset>0x220</addressOffset>
       </register>
       <register derivedFrom="BPWM_RCAPDAT0">
          <name>BPWM_RCAPDAT3</name>
          <displayName>BPWM_RCAPDAT3</displayName>
          <description>BPWM Rising Capture Data Register 3</description>
          <addressOffset>0x224</addressOffset>
       </register>
       <register derivedFrom="BPWM_FCAPDAT0">
          <name>BPWM_FCAPDAT3</name>
          <displayName>BPWM_FCAPDAT3</displayName>
          <description>BPWM Falling Capture Data Register 3</description>
          <addressOffset>0x228</addressOffset>
       </register>
       <register derivedFrom="BPWM_RCAPDAT0">
          <name>BPWM_RCAPDAT4</name>
          <displayName>BPWM_RCAPDAT4</displayName>
          <description>BPWM Rising Capture Data Register 4</description>
          <addressOffset>0x22C</addressOffset>
       </register>
       <register derivedFrom="BPWM_FCAPDAT0">
          <name>BPWM_FCAPDAT4</name>
          <displayName>BPWM_FCAPDAT4</displayName>
          <description>BPWM Falling Capture Data Register 4</description>
          <addressOffset>0x230</addressOffset>
       </register>
       <register derivedFrom="BPWM_RCAPDAT0">
          <name>BPWM_RCAPDAT5</name>
          <displayName>BPWM_RCAPDAT5</displayName>
          <description>BPWM Rising Capture Data Register 5</description>
          <addressOffset>0x234</addressOffset>
       </register>
       <register derivedFrom="BPWM_FCAPDAT0">
          <name>BPWM_FCAPDAT5</name>
          <displayName>BPWM_FCAPDAT5</displayName>
          <description>BPWM Falling Capture Data Register 5</description>
          <addressOffset>0x238</addressOffset>
       </register>
       <register>
          <name>BPWM_CAPIEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BPWM_CAPIEN</displayName>
          <description>BPWM Capture Interrupt Enable Register</description>
          <addressOffset>0x250</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CAPRIENn</name>
              <description>BPWM Capture Rising Latch Interrupt Enable Control\nEach bit n controls the corresponding BPWM channel n.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Capture rising edge latch interrupt Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture rising edge latch interrupt Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPFIENn</name>
              <description>BPWM Capture Falling Latch Interrupt Enable Control\nEach bit n controls the corresponding BPWM channel n.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Capture falling edge latch interrupt Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture falling edge latch interrupt Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>BPWM_CAPIF</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BPWM_CAPIF</displayName>
          <description>BPWM Capture Interrupt Flag Register</description>
          <addressOffset>0x254</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CRLIFn</name>
              <description>BPWM Capture Rising Latch Interrupt Flag\nThis bit is writing 1 to clear. Each bit n controls the corresponding BPWM channel n.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No capture rising latch condition happened</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture rising latch condition happened, this flag will be set to high</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CFLIFn</name>
              <description>BPWM Capture Falling Latch Interrupt Flag\nThis bit is writing 1 to clear. Each bit n controls the corresponding BPWM channel n.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No capture falling latch condition happened</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture falling latch condition happened, this flag will be set to high</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>BPWM_PBUF</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BPWM_PBUF</displayName>
          <description>BPWM PERIOD Buffer</description>
          <addressOffset>0x304</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PBUF</name>
              <description>BPWM Period Register Buffer (Read Only)\nUsed as PERIOD active register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>BPWM_CMPBUF0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BPWM_CMPBUF0</displayName>
          <description>BPWM CMPDAT0 Buffer</description>
          <addressOffset>0x31C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMPBUF</name>
              <description>BPWM Comparator Register Buffer (Read Only)\nUsed as CMP active register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="BPWM_CMPBUF0">
          <name>BPWM_CMPBUF1</name>
          <displayName>BPWM_CMPBUF1</displayName>
          <description>BPWM CMPDAT1 Buffer</description>
          <addressOffset>0x320</addressOffset>
       </register>
       <register derivedFrom="BPWM_CMPBUF0">
          <name>BPWM_CMPBUF2</name>
          <displayName>BPWM_CMPBUF2</displayName>
          <description>BPWM CMPDAT2 Buffer</description>
          <addressOffset>0x324</addressOffset>
       </register>
       <register derivedFrom="BPWM_CMPBUF0">
          <name>BPWM_CMPBUF3</name>
          <displayName>BPWM_CMPBUF3</displayName>
          <description>BPWM CMPDAT3 Buffer</description>
          <addressOffset>0x328</addressOffset>
       </register>
       <register derivedFrom="BPWM_CMPBUF0">
          <name>BPWM_CMPBUF4</name>
          <displayName>BPWM_CMPBUF4</displayName>
          <description>BPWM CMPDAT4 Buffer</description>
          <addressOffset>0x32C</addressOffset>
       </register>
       <register derivedFrom="BPWM_CMPBUF0">
          <name>BPWM_CMPBUF5</name>
          <displayName>BPWM_CMPBUF5</displayName>
          <description>BPWM CMPDAT5 Buffer</description>
          <addressOffset>0x330</addressOffset>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>BPWM1</name>
      <description>BPWM Register Map</description>
      <groupName>BPWM</groupName>
      <baseAddress>0x40144000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x10</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x20</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x30</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x50</offset>
        <size>0x18</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x90</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0xB0</offset>
        <size>0x10</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0xD4</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0xE0</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0xE8</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0xF8</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x110</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x120</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x200</offset>
        <size>0x3C</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x250</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x304</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x31C</offset>
        <size>0x18</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>BPWM_CTL0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BPWM_CTL0</displayName>
          <description>BPWM Control Register 0</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CTRLDn</name>
              <description>Center Re-Load\nEach bit n controls the corresponding BPWM channel n.\nIn up-down counter type, PERIOD will load to PBUF at the end point of each period. CMPDAT will load to CMPBUF at the center point of a period.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IMMLDENn</name>
              <description>Immediately Load Enable\nEach bit n controls the corresponding BPWM channel n.\nNote: If IMMLDENn is enabled, WINLDENn and CTRLDn will be invalid.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PERIOD will load to PBUF at the end point of each period. CMPDAT will load to CMPBUF at the end point or center point of each period by setting CTRLD bit</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PERIOD/CMPDAT will load to PBUF and CMPBUF immediately when software update PERIOD/CMPDAT</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBGHALT</name>
              <description>ICE Debug Mode Counter Halt (Write Protect)\nIf counter halt is enabled, BPWM all counters will keep current value until exit ICE debug mode. \nNote: This register is write protected. Refer to SYS_REGLCTL register.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ICE debug mode counter halt disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ICE debug mode counter halt enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBGTRIOFF</name>
              <description>ICE Debug Mode Acknowledge Disable (Write Protect)\nBPWM pin will keep output no matter ICE debug mode acknowledged or not.\nNote: This register is write protected. Refer to SYS_REGLCTL register.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ICE debug mode acknowledgement effects BPWM output</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ICE debug mode acknowledgement disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>BPWM_CTL1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BPWM_CTL1</displayName>
          <description>BPWM Control Register 1</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNTTYPE0</name>
              <description>BPWM Counter Behavior Type 0\nEach bit n controls corresponding BPWM channel n.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Up counter type (supports in capture mode)</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Down count type (supports in capture mode)</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Up-down counter type</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved.</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>BPWM_CLKSRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BPWM_CLKSRC</displayName>
          <description>BPWM Clock Source Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ECLKSRC0</name>
              <description>BPWM_CH01 External Clock Source Select</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>BPWMx_CLK, x denotes 0 or 1</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TIMER0 overflow</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>TIMER1 overflow</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>TIMER2 overflow</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>TIMER3 overflow</description>
                    <value>#100</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>BPWM_CLKPSC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BPWM_CLKPSC</displayName>
          <description>BPWM Clock Pre-scale Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLKPSC</name>
              <description>BPWM Counter Clock Pre-Scale \nThe clock of BPWM counter is decided by clock prescaler. Each BPWM pair share one BPWM counter clock prescaler. The clock of BPWM counter is divided by (CLKPSC+ 1).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>BPWM_CNTEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BPWM_CNTEN</displayName>
          <description>BPWM Counter Enable Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNTEN0</name>
              <description>BPWM Counter Enable 0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>BPWM Counter and clock prescaler Stop Running</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>BPWM Counter and clock prescaler Start Running</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>BPWM_CNTCLR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BPWM_CNTCLR</displayName>
          <description>BPWM Clear Counter Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNTCLR0</name>
              <description>Clear BPWM Counter Control Bit 0\nIt is automatically cleared by hardware.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clear 16-bit BPWM counter to 0000H</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>BPWM_PERIOD</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BPWM_PERIOD</displayName>
          <description>BPWM Period Register</description>
          <addressOffset>0x30</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PERIOD</name>
              <description>BPWM Period Register\nUp-Count mode: In this mode, BPWM counter counts from 0 to PERIOD, and restarts from 0.\nDown-Count mode: In this mode, BPWM counter counts from PERIOD to 0, and restarts from PERIOD.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>BPWM_CMPDAT0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BPWM_CMPDAT0</displayName>
          <description>BPWM Comparator Register 0</description>
          <addressOffset>0x50</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMP</name>
              <description>BPWM Comparator Register\nCMP use to compare with CNT to generate BPWM waveform, interrupt and trigger ADC.\nIn independent mode, BPWM_CMPDAT0~5 denote as 6 independent BPWM_CH0~5 compared point.\nIn complementary mode, BPWM_CMPDAT0, 2, 4 denote as first compared point, and BPWM_CMPDAT1, 3, 5 denote as second compared point for the corresponding 3 complementary pairs BPWM_CH0 and BPWM_CH1, BPWM_CH2 and BPWM_CH3, BPWM_CH4 and BPWM_CH5.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="BPWM_CMPDAT0">
          <name>BPWM_CMPDAT1</name>
          <displayName>BPWM_CMPDAT1</displayName>
          <description>BPWM Comparator Register 1</description>
          <addressOffset>0x54</addressOffset>
       </register>
       <register derivedFrom="BPWM_CMPDAT0">
          <name>BPWM_CMPDAT2</name>
          <displayName>BPWM_CMPDAT2</displayName>
          <description>BPWM Comparator Register 2</description>
          <addressOffset>0x58</addressOffset>
       </register>
       <register derivedFrom="BPWM_CMPDAT0">
          <name>BPWM_CMPDAT3</name>
          <displayName>BPWM_CMPDAT3</displayName>
          <description>BPWM Comparator Register 3</description>
          <addressOffset>0x5C</addressOffset>
       </register>
       <register derivedFrom="BPWM_CMPDAT0">
          <name>BPWM_CMPDAT4</name>
          <displayName>BPWM_CMPDAT4</displayName>
          <description>BPWM Comparator Register 4</description>
          <addressOffset>0x60</addressOffset>
       </register>
       <register derivedFrom="BPWM_CMPDAT0">
          <name>BPWM_CMPDAT5</name>
          <displayName>BPWM_CMPDAT5</displayName>
          <description>BPWM Comparator Register 5</description>
          <addressOffset>0x64</addressOffset>
       </register>
       <register>
          <name>BPWM_CNT0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BPWM_CNT0</displayName>
          <description>BPWM Counter Register 0</description>
          <addressOffset>0x90</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNT</name>
              <description>BPWM Data Register (Read Only)\nUser can monitor CNT to know the current value in 16-bit period counter.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DIRF</name>
              <description>BPWM Direction Indicator Flag (Read Only)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Counter is Down count</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Counter is UP count</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>BPWM_WGCTL0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BPWM_WGCTL0</displayName>
          <description>BPWM Generation Register 0</description>
          <addressOffset>0xB0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ZPCTLn</name>
              <description>BPWM Zero Point Control\nEach bit n controls the corresponding BPWM channel n.\nBPWM can control output level when BPWM counter count to zero.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Do nothing</description>
                    <value>00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>BPWM zero point output Low</description>
                    <value>01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>10</name>
                    <description>BPWM zero point output High</description>
                    <value>10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>11</name>
                    <description>BPWM zero point output Toggle</description>
                    <value>11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PRDPCTLn</name>
              <description>BPWM Period (Center) Point Control\nEach bit n controls the corresponding BPWM channel n.\nBPWM can control output level when BPWM counter count to (PERIODn+1).\nNote: This bit is center point control when BPWM counter operating in up-down counter type.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>12</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Do nothing</description>
                    <value>00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>BPWM period (center) point output Low</description>
                    <value>01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>10</name>
                    <description>BPWM period (center) point output High</description>
                    <value>10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>11</name>
                    <description>BPWM period (center) point output Toggle</description>
                    <value>11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>BPWM_WGCTL1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BPWM_WGCTL1</displayName>
          <description>BPWM Generation Register 1</description>
          <addressOffset>0xB4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMPUCTLn</name>
              <description>BPWM Compare Up Point Control\nEach bit n controls the corresponding BPWM channel n.\nBPWM can control output level when BPWM counter up count to CMPDAT.\nNote: In complementary mode, CMPUCTL1, 3, 5 use as another CMPUCTL for channel 0, 2, 4.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Do nothing</description>
                    <value>00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>BPWM compare up point output Low</description>
                    <value>01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>10</name>
                    <description>BPWM compare up point output High</description>
                    <value>10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>11</name>
                    <description>BPWM compare up point output Toggle</description>
                    <value>11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPDCTLn</name>
              <description>BPWM Compare Down Point Control\nEach bit n controls the corresponding BPWM channel n.\nBPWM can control output level when BPWM counter down count to CMPDAT.\nNote: In complementary mode, CMPDCTL1, 3, 5 use as another CMPDCTL for channel 0, 2, 4.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>12</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Do nothing</description>
                    <value>00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>BPWM compare down point output Low</description>
                    <value>01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>10</name>
                    <description>BPWM compare down point output High</description>
                    <value>10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>11</name>
                    <description>BPWM compare down point output Toggle</description>
                    <value>11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>BPWM_MSKEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BPWM_MSKEN</displayName>
          <description>BPWM Mask Enable Register</description>
          <addressOffset>0xB8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MSKENn</name>
              <description>BPWM Mask Enable Control\nEach bit n controls the corresponding BPWM channel n.\nThe BPWM output signal will be masked when this bit is enabled. The corresponding BPWM channel n will output MSKDATn (BPWM_MSK[5:0]) data. </description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>BPWM output signal is non-masked</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>BPWM output signal is masked and output MSKDATn data</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>BPWM_MSK</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BPWM_MSK</displayName>
          <description>BPWM Mask Data Register</description>
          <addressOffset>0xBC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MSKDATn</name>
              <description>BPWM Mask Data Bit\nThis data bit control the state of BPWMn output pin, if corresponding mask function is enabled. Each bit n controls the corresponding BPWM channel n.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Output logic low to BPWMn</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Output logic high to BPWMn</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>BPWM_POLCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BPWM_POLCTL</displayName>
          <description>BPWM Pin Polar Inverse Register</description>
          <addressOffset>0xD4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PINVn</name>
              <description>BPWM PIN Polar Inverse Control\nThe register controls polarity state of BPWM output. Each bit n controls the corresponding BPWM channel n.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>BPWM output polar inverse Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>BPWM output polar inverse Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>BPWM_POEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BPWM_POEN</displayName>
          <description>BPWM Output Enable Register</description>
          <addressOffset>0xD8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>POENn</name>
              <description>BPWM Pin Output Enable Control\nEach bit n controls the corresponding BPWM channel n.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>BPWM pin at tri-state</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>BPWM pin in output mode</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>BPWM_INTEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BPWM_INTEN</displayName>
          <description>BPWM Interrupt Enable Register</description>
          <addressOffset>0xE0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ZIEN0</name>
              <description>BPWM Zero Point Interrupt Enable 0\nNote: Odd channels will read always 0 at complementary mode.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Zero point interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Zero point interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PIEN0</name>
              <description>BPWM Period Point Interrupt Enable 0\nNote: When up-down counter type period point means center point.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Period point interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Period point interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPUIENn</name>
              <description>BPWM Compare Up Count Interrupt Enable Control\nEach bit n controls the corresponding BPWM channel n.\nNote: In complementary mode, CMPUIEN1, 3, 5 use as another CMPUIEN for channel 0, 2, 4.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Compare up count interrupt Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Compare up count interrupt Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPDIENn</name>
              <description>BPWM Compare Down Count Interrupt Enable Control\nEach bit n controls the corresponding BPWM channel n.\nNote: In complementary mode, CMPDIEN1, 3, 5 use as another CMPDIEN for channel 0, 2, 4.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Compare down count interrupt Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Compare down count interrupt Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>BPWM_INTSTS0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BPWM_INTSTS0</displayName>
          <description>BPWM Interrupt Flag Register</description>
          <addressOffset>0xE8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ZIF0</name>
              <description>BPWM Zero Point Interrupt Flag 0\nThis bit is set by hardware when BPWM_CH0 counter reaches zero, software can write 1 to clear this bit to zero.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PIF0</name>
              <description>BPWM Period Point Interrupt Flag 0\nThis bit is set by hardware when BPWM_CH0 counter reaches BPWM_PERIOD0, software can write 1 to clear this bit to zero.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPUIFn</name>
              <description>BPWM Compare Up Count Interrupt Flag\nFlag is set by hardware when BPWM counter up count and reaches BPWM_CMPDATn, software can clear this bit by writing 1 to it. Each bit n controls the corresponding BPWM channel n.\nNote1: If CMPDAT equal to PERIOD, this flag is not working in up counter type selection.\nNote2: In complementary mode, CMPUIF1, 3, 5 use as another CMPUIF for channel 0, 2, 4.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPDIFn</name>
              <description>BPWM Compare Down Count Interrupt Flag\nEach bit n controls the corresponding BPWM channel n.\nFlag is set by hardware when BPWM counter down count and reaches BPWM_CMPDATn, software can clear this bit by writing 1 to it.\nNote1: If CMPDAT equal to PERIOD, this flag is not working in down counter type selection.\nNote2: In complementary mode, CMPDIF1, 3, 5 use as another CMPDIF for channel 0, 2, 4.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>BPWM_ADCTS0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BPWM_ADCTS0</displayName>
          <description>BPWM Trigger ADC Source Select Register 0</description>
          <addressOffset>0xF8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TRGSEL0</name>
              <description>BPWM_CH0 Trigger ADC Source Select</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>BPWM_CH0 zero point</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>BPWM_CH0 period point</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>BPWM_CH0 zero or period point</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>BPWM_CH0 up-count CMPDAT point</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>BPWM_CH0 down-count CMPDAT point</description>
                    <value>#0100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Reserved.</description>
                    <value>#0101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Reserved.</description>
                    <value>#0110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Reserved.</description>
                    <value>#0111</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>8</name>
                    <description>BPWM_CH1 up-count CMPDAT point</description>
                    <value>#1000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>9</name>
                    <description>BPWM_CH1 down-count CMPDAT point</description>
                    <value>#1001</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGEN0</name>
              <description>BPWM_CH0 Trigger ADC Enable Control</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGSEL1</name>
              <description>BPWM_CH1 Trigger ADC Source Select</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>BPWM_CH0 zero point</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>BPWM_CH0 period point</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>BPWM_CH0 zero or period point</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>BPWM_CH0 up-count CMPDAT point</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>BPWM_CH0 down-count CMPDAT point</description>
                    <value>#0100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Reserved.</description>
                    <value>#0101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Reserved.</description>
                    <value>#0110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Reserved.</description>
                    <value>#0111</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>8</name>
                    <description>BPWM_CH1 up-count CMPDAT point</description>
                    <value>#1000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>9</name>
                    <description>BPWM_CH1 down-count CMPDAT point</description>
                    <value>#1001</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGEN1</name>
              <description>BPWM_CH1 Trigger ADC Enable Control</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGSEL2</name>
              <description>BPWM_CH2 Trigger ADC Source Select\nOthers reserved.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>BPWM_CH2 zero point</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>BPWM_CH2 period point</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>BPWM_CH2 zero or period point</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>BPWM_CH2 up-count CMPDAT point</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>BPWM_CH2 down-count CMPDAT point</description>
                    <value>#0100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Reserved.</description>
                    <value>#0101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Reserved.</description>
                    <value>#0110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Reserved.</description>
                    <value>#0111</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>8</name>
                    <description>BPWM_CH3 up-count CMPDAT point</description>
                    <value>#1000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>9</name>
                    <description>BPWM_CH3 down-count CMPDAT point</description>
                    <value>#1001</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGEN2</name>
              <description>BPWM_CH2 Trigger ADC Enable Control</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGSEL3</name>
              <description>BPWM_CH3 Trigger ADC Source Select</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>BPWM_CH2 zero point</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>BPWM_CH2 period point</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>BPWM_CH2 zero or period point</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>BPWM_CH2 up-count CMPDAT point</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>BPWM_CH2 down-count CMPDAT point</description>
                    <value>#0100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Reserved.</description>
                    <value>#0101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Reserved.</description>
                    <value>#0110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Reserved.</description>
                    <value>#0111</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>8</name>
                    <description>BPWM_CH3 up-count CMPDAT point</description>
                    <value>#1000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>9</name>
                    <description>BPWM_CH3 down-count CMPDAT point</description>
                    <value>#1001</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGEN3</name>
              <description>BPWM_CH3 Trigger ADC Enable Control</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>BPWM_ADCTS1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BPWM_ADCTS1</displayName>
          <description>BPWM Trigger ADC Source Select Register 1</description>
          <addressOffset>0xFC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TRGSEL4</name>
              <description>BPWM_CH4 Trigger ADC Source Select</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>BPWM_CH4 zero point</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>BPWM_CH4 period point</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>BPWM_CH4 zero or period point</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>BPWM_CH4 up-count CMPDAT point</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>BPWM_CH4 down-count CMPDAT point</description>
                    <value>#0100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Reserved.</description>
                    <value>#0101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Reserved.</description>
                    <value>#0110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Reserved.</description>
                    <value>#0111</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>8</name>
                    <description>BPWM_CH5 up-count CMPDAT point</description>
                    <value>#1000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>9</name>
                    <description>BPWM_CH5 down-count CMPDAT point</description>
                    <value>#1001</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGEN4</name>
              <description>BPWM_CH4 Trigger ADC Enable Control</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGSEL5</name>
              <description>BPWM_CH5 Trigger ADC Source Select</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>BPWM_CH4 zero point</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>BPWM_CH4 period point</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>BPWM_CH4 zero or period point</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>BPWM_CH4 up-count CMPDAT point</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>BPWM_CH4 down-count CMPDAT point</description>
                    <value>#0100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Reserved.</description>
                    <value>#0101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Reserved.</description>
                    <value>#0110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Reserved.</description>
                    <value>#0111</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>8</name>
                    <description>BPWM_CH5 up-count CMPDAT point</description>
                    <value>#1000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>9</name>
                    <description>BPWM_CH5 down-count CMPDAT point</description>
                    <value>#1001</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGEN5</name>
              <description>BPWM_CH5 Trigger ADC Enable Control</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>BPWM_SSCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BPWM_SSCTL</displayName>
          <description>BPWM Synchronous Start Control Register</description>
          <addressOffset>0x110</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SSEN0</name>
              <description>BPWM Synchronous Start Function Enable 0\nWhen synchronous start function is enabled, the BPWM_CH0 counter enable bit (CNTEN0) can be enabled by writing BPWM synchronous start trigger bit (CNTSEN). </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>BPWM synchronous start function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>BPWM synchronous start function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SSRC</name>
              <description>BPWM Synchronous Start Source Select</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Synchronous start source come from BPWM0</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Synchronous start source come from BPWM1</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Synchronous start source come from BPWM0</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Synchronous start source come from BPWM1</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>BPWM_SSTRG</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BPWM_SSTRG</displayName>
          <description>BPWM Synchronous Start Trigger Register</description>
          <addressOffset>0x114</addressOffset>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNTSEN</name>
              <description>BPWM Counter Synchronous Start Enable (Write Only)\nPMW counter synchronous enable function is used to make selected BPWM channels (include BPWM0_CHx and BPWM1_CHx) start counting at the same time.\nWriting this bit to 1 will also set the counter enable bit (CNTENn, n denotes channel 0 to 5) if correlated BPWM channel counter synchronous start function is enabled.\nNote: This bit only present in BPWM0_BA.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>BPWM_STATUS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BPWM_STATUS</displayName>
          <description>BPWM Status Register</description>
          <addressOffset>0x120</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNTMAX0</name>
              <description>Time-Base Counter 0 Equal To 0xFFFF Latched Status</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Indicates the time-base counter never reached its maximum value 0xFFFF</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Indicates the time-base counter reached its maximum value, software can write 1 to clear this bit</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADCTRGn</name>
              <description>ADC Start Of Conversion Status\nEach bit n controls the corresponding BPWM channel n.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Indicates no ADC start of conversion trigger event has occurred</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Indicates an ADC start of conversion trigger event has occurred, software can write 1 to clear this bit</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>BPWM_CAPINEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BPWM_CAPINEN</displayName>
          <description>BPWM Capture Input Enable Register</description>
          <addressOffset>0x200</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CAPINENn</name>
              <description>Capture Input Enable Control\nEach bit n controls the corresponding BPWM channel n.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>BPWM Channel capture input path Disabled. The input of BPWM channel capture function is always regarded as 0</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>BPWM Channel capture input path Enabled. The input of BPWM channel capture function comes from correlative multifunction pin</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>BPWM_CAPCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BPWM_CAPCTL</displayName>
          <description>BPWM Capture Control Register</description>
          <addressOffset>0x204</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CAPENn</name>
              <description>Capture Function Enable Control\nEach bit n controls the corresponding BPWM channel n.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Capture function Disabled. RCAPDAT/FCAPDAT register will not be updated</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture function Enabled. Capture latched the BPWM counter value when detected rising or falling edge of input signal and saved to RCAPDAT (Rising latch) and FCAPDAT (Falling latch)</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPINVn</name>
              <description>Capture Inverter Enable Control\nEach bit n controls the corresponding BPWM channel n.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Capture source inverter Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture source inverter Enabled. Reverse the input signal from GPIO</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RCRLDENn</name>
              <description>Rising Capture Reload Enable Control\nEach bit n controls the corresponding BPWM channel n.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Rising capture reload counter Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Rising capture reload counter Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FCRLDENn</name>
              <description>Falling Capture Reload Enable Control\nEach bit n controls the corresponding BPWM channel n.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Falling capture reload counter Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Falling capture reload counter Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>BPWM_CAPSTS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BPWM_CAPSTS</displayName>
          <description>BPWM Capture Status Register</description>
          <addressOffset>0x208</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CRLIFOVn</name>
              <description>Capture Rising Latch Interrupt Flag Overrun Status (Read Only)\nThis flag indicates if rising latch happened when the corresponding CRLIF is 1. Each bit n controls the corresponding BPWM channel n.\nNote: This bit will be cleared automatically when user clear corresponding CRLIF.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CFLIFOVn</name>
              <description>Capture Falling Latch Interrupt Flag Overrun Status (Read Only)\nThis flag indicates if falling latch happened when the corresponding CFLIF is 1. Each bit n controls the corresponding BPWM channel n.\nNote: This bit will be cleared automatically when user clear corresponding CFLIF.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>BPWM_RCAPDAT0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BPWM_RCAPDAT0</displayName>
          <description>BPWM Rising Capture Data Register 0</description>
          <addressOffset>0x20C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RCAPDAT</name>
              <description>BPWM Rising Capture Data Register (Read Only)\nWhen rising capture condition happened, the BPWM counter value will be saved in this register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>BPWM_FCAPDAT0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BPWM_FCAPDAT0</displayName>
          <description>BPWM Falling Capture Data Register 0</description>
          <addressOffset>0x210</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FCAPDAT</name>
              <description>BPWM Falling Capture Data Register (Read Only)\nWhen falling capture condition happened, the BPWM counter value will be saved in this register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="BPWM_RCAPDAT0">
          <name>BPWM_RCAPDAT1</name>
          <displayName>BPWM_RCAPDAT1</displayName>
          <description>BPWM Rising Capture Data Register 1</description>
          <addressOffset>0x214</addressOffset>
       </register>
       <register derivedFrom="BPWM_FCAPDAT0">
          <name>BPWM_FCAPDAT1</name>
          <displayName>BPWM_FCAPDAT1</displayName>
          <description>BPWM Falling Capture Data Register 1</description>
          <addressOffset>0x218</addressOffset>
       </register>
       <register derivedFrom="BPWM_RCAPDAT0">
          <name>BPWM_RCAPDAT2</name>
          <displayName>BPWM_RCAPDAT2</displayName>
          <description>BPWM Rising Capture Data Register 2</description>
          <addressOffset>0x21C</addressOffset>
       </register>
       <register derivedFrom="BPWM_FCAPDAT0">
          <name>BPWM_FCAPDAT2</name>
          <displayName>BPWM_FCAPDAT2</displayName>
          <description>BPWM Falling Capture Data Register 2</description>
          <addressOffset>0x220</addressOffset>
       </register>
       <register derivedFrom="BPWM_RCAPDAT0">
          <name>BPWM_RCAPDAT3</name>
          <displayName>BPWM_RCAPDAT3</displayName>
          <description>BPWM Rising Capture Data Register 3</description>
          <addressOffset>0x224</addressOffset>
       </register>
       <register derivedFrom="BPWM_FCAPDAT0">
          <name>BPWM_FCAPDAT3</name>
          <displayName>BPWM_FCAPDAT3</displayName>
          <description>BPWM Falling Capture Data Register 3</description>
          <addressOffset>0x228</addressOffset>
       </register>
       <register derivedFrom="BPWM_RCAPDAT0">
          <name>BPWM_RCAPDAT4</name>
          <displayName>BPWM_RCAPDAT4</displayName>
          <description>BPWM Rising Capture Data Register 4</description>
          <addressOffset>0x22C</addressOffset>
       </register>
       <register derivedFrom="BPWM_FCAPDAT0">
          <name>BPWM_FCAPDAT4</name>
          <displayName>BPWM_FCAPDAT4</displayName>
          <description>BPWM Falling Capture Data Register 4</description>
          <addressOffset>0x230</addressOffset>
       </register>
       <register derivedFrom="BPWM_RCAPDAT0">
          <name>BPWM_RCAPDAT5</name>
          <displayName>BPWM_RCAPDAT5</displayName>
          <description>BPWM Rising Capture Data Register 5</description>
          <addressOffset>0x234</addressOffset>
       </register>
       <register derivedFrom="BPWM_FCAPDAT0">
          <name>BPWM_FCAPDAT5</name>
          <displayName>BPWM_FCAPDAT5</displayName>
          <description>BPWM Falling Capture Data Register 5</description>
          <addressOffset>0x238</addressOffset>
       </register>
       <register>
          <name>BPWM_CAPIEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BPWM_CAPIEN</displayName>
          <description>BPWM Capture Interrupt Enable Register</description>
          <addressOffset>0x250</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CAPRIENn</name>
              <description>BPWM Capture Rising Latch Interrupt Enable Control\nEach bit n controls the corresponding BPWM channel n.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Capture rising edge latch interrupt Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture rising edge latch interrupt Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPFIENn</name>
              <description>BPWM Capture Falling Latch Interrupt Enable Control\nEach bit n controls the corresponding BPWM channel n.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Capture falling edge latch interrupt Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture falling edge latch interrupt Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>BPWM_CAPIF</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BPWM_CAPIF</displayName>
          <description>BPWM Capture Interrupt Flag Register</description>
          <addressOffset>0x254</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CRLIFn</name>
              <description>BPWM Capture Rising Latch Interrupt Flag\nThis bit is writing 1 to clear. Each bit n controls the corresponding BPWM channel n.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No capture rising latch condition happened</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture rising latch condition happened, this flag will be set to high</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CFLIFn</name>
              <description>BPWM Capture Falling Latch Interrupt Flag\nThis bit is writing 1 to clear. Each bit n controls the corresponding BPWM channel n.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No capture falling latch condition happened</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture falling latch condition happened, this flag will be set to high</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>BPWM_PBUF</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BPWM_PBUF</displayName>
          <description>BPWM PERIOD Buffer</description>
          <addressOffset>0x304</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PBUF</name>
              <description>BPWM Period Register Buffer (Read Only)\nUsed as PERIOD active register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>BPWM_CMPBUF0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BPWM_CMPBUF0</displayName>
          <description>BPWM CMPDAT0 Buffer</description>
          <addressOffset>0x31C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMPBUF</name>
              <description>BPWM Comparator Register Buffer (Read Only)\nUsed as CMP active register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="BPWM_CMPBUF0">
          <name>BPWM_CMPBUF1</name>
          <displayName>BPWM_CMPBUF1</displayName>
          <description>BPWM CMPDAT1 Buffer</description>
          <addressOffset>0x320</addressOffset>
       </register>
       <register derivedFrom="BPWM_CMPBUF0">
          <name>BPWM_CMPBUF2</name>
          <displayName>BPWM_CMPBUF2</displayName>
          <description>BPWM CMPDAT2 Buffer</description>
          <addressOffset>0x324</addressOffset>
       </register>
       <register derivedFrom="BPWM_CMPBUF0">
          <name>BPWM_CMPBUF3</name>
          <displayName>BPWM_CMPBUF3</displayName>
          <description>BPWM CMPDAT3 Buffer</description>
          <addressOffset>0x328</addressOffset>
       </register>
       <register derivedFrom="BPWM_CMPBUF0">
          <name>BPWM_CMPBUF4</name>
          <displayName>BPWM_CMPBUF4</displayName>
          <description>BPWM CMPDAT4 Buffer</description>
          <addressOffset>0x32C</addressOffset>
       </register>
       <register derivedFrom="BPWM_CMPBUF0">
          <name>BPWM_CMPBUF5</name>
          <displayName>BPWM_CMPBUF5</displayName>
          <description>BPWM CMPDAT5 Buffer</description>
          <addressOffset>0x330</addressOffset>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>WDT</name>
      <description>WDT Register Map</description>
      <groupName>WDT</groupName>
      <baseAddress>0x40004000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>WTCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>WTCR</displayName>
          <description>Watchdog Timer Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000700</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WTR</name>
              <description>Reset Watchdog Timer Up Counter (Write Protect)\nNote: This bit will be automatically cleared by hardware.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the internal 18-bit WDT up counter value</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WTRE</name>
              <description>Watchdog Timer Reset Enable Control (Write Protect)\nSetting this bit will enable the WDT time-out reset function if the WDT up counter value has not been cleared after the specific WDT reset delay period expires.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>WDT time-out reset function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>WDT time-out reset function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WTRF</name>
              <description>Watchdog Timer Time-Out Reset Flag\nThis bit indicates the system has been reset by WDT time-out reset or not.\nNote: This bit is cleared by writing 1 to it.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>WDT time-out reset did not occur</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>WDT time-out reset occurred</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WTIF</name>
              <description>Watchdog Timer Time-Out Interrupt Flag\nThis bit will set to 1 while WDT up counter value reaches the selected WDT time-out interval.\nNote: This bit is cleared by writing 1 to it.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>WDT time-out interrupt did not occur</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>WDT time-out interrupt occurred</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WTWKE</name>
              <description>Watchdog Timer Time-Out Wake-Up Function Control (Write Protect)\nIf this bit is set to 1, while WTIF is generated to 1 and WTIE enabled, the WDT time-out interrupt signal will generate a wake-up trigger event to chip.\nNote: Chip can be woken-up by WDT time-out interrupt signal generated only if WDT   clock source is selected to 10 kHz oscillator.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Wake-up trigger event Disabled if WDT time-out interrupt signal generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Wake-up trigger event Enabled if WDT time-out interrupt signal generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WTWKF</name>
              <description>Watchdog Timer Time-Out Wake-Up Flag\nThis bit indicates the interrupt wake-up flag status of WDT.\nNote: This bit is cleared by writing 1 to it.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>WDT does not cause chip wake-up</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Chip wake-up from Idle or Power-down mode if WDT time-out interrupt signal generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WTIE</name>
              <description>Watchdog Timer Time-Out Interrupt Enable Control (Write Protect)\nIf this bit is enabled, the WDT time-out interrupt signal is generated and inform to CPU.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>WDT time-out interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>WDT time-out interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WTE</name>
              <description>Watchdog Timer Enable Control (Write Protect)\nNote: If CWDTEN (CONFIG0[31] Watchdog Enable) bit is set to 0, this bit is forced as 1 and user cannot change this bit to 0.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>WDT Disabled. (This action will reset the internal up counter value.)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>WDT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WTIS</name>
              <description>Watchdog Timer Time-Out Interval Selection (Write Protect)\nThese three bits select the time-out interval period for the WDT.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>24 *TWDT</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>26 * TWDT</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>28 * TWDT</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>210 * TWDT</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>212 * TWDT</description>
                    <value>#100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>214 * TWDT</description>
                    <value>#101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>216 * TWDT</description>
                    <value>#110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>218 * TWDT</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBGACK_WDT</name>
              <description>ICE Debug Mode Acknowledge Disable Control (Write Protect)\nWDT up counter will keep going no matter CPU is held by ICE or not.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ICE debug mode acknowledgement effects WDT counting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ICE debug mode acknowledgement Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>WTCRALT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>WTCRALT</displayName>
          <description>Watchdog Timer Alternative Control Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WTRDSEL</name>
              <description>Watchdog Timer Reset Delay Selection (Write Protect)\nWhen WDT time-out happened, user has a time named WDT Reset Delay Period to clear WDT counter to prevent WDT time-out reset happened. User can select a suitable value of WDT Reset Delay Period for different WDT time-out period.\nThese bits are protected bit. It means programming this bit needs to write '59h', '16h', '88h' to address 0x5000_0100 to disable register protection. Reference the register REGWRPROT at address GCR_BA+0x100.\nNote: This register will be reset to 0 if WDT time-out reset happened.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Watchdog Timer Reset Delay Period is 1026 * WDT_CLK</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Watchdog Timer Reset Delay Period is 130 * WDT_CLK</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Watchdog Timer Reset Delay Period is 18 * WDT_CLK</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Watchdog Timer Reset Delay Period is 3 * WDT_CLK</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>WWDT</name>
      <description>WWDT Register Map</description>
      <groupName>WWDT</groupName>
      <baseAddress>0x40004100</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x10</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>WWDTRLD</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>WWDTRLD</displayName>
          <description>Window Watchdog Timer Reload Counter Register</description>
          <addressOffset>0x0</addressOffset>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WWDTRLD</name>
              <description>WWDT Reload Counter Register\nWriting 0x00005AA5 to this register will reload the WWDT counter value to 0x3F. \nNote: User can only write WWDTRLD to reload WWDT counter value when current WWDT counter value between 0 and WINCMP. If user writes WWDTRLD when current WWDT counter value is larger than WINCMP, WWDT reset signal will generate immediately.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>WWDTCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>WWDTCR</displayName>
          <description>Window Watchdog Timer Control Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x003F0800</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WWDTEN</name>
              <description>WWDT Enable Control\nSet this bit to enable WWDT counter counting.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>WWDT counter is stopped</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>WWDT counter is starting counting</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WWDTIE</name>
              <description>WWDT Interrupt Enable Control\nIf this bit is enabled, the WWDT counter compare match interrupt signal is generated and inform to CPU.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>WWDT counter compare match interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>WWDT counter compare match interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PERIODSEL</name>
              <description>WWDT Counter Prescale Period Selection</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Pre-scale is 1; Max time-out period is 1 * 64 * TWWDT</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Pre-scale is 2; Max time-out period is 2 * 64 * TWWDT</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Pre-scale is 4; Max time-out period is 4 * 64 * TWWDT</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Pre-scale is 8; Max time-out period is 8 * 64 * TWWDT</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>Pre-scale is 16; Max time-out period is 16 * 64 * TWWDT</description>
                    <value>#0100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Pre-scale is 32; Max time-out period is 32 * 64 * TWWDT</description>
                    <value>#0101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Pre-scale is 64; Max time-out period is 64 * 64 * TWWDT</description>
                    <value>#0110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Pre-scale is 128; Max time-out period is 128 * 64 * TWWDT</description>
                    <value>#0111</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>8</name>
                    <description>Pre-scale is 192; Max time-out period is 192 * 64 * TWWDT</description>
                    <value>#1000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>9</name>
                    <description>Pre-scale is 256; Max time-out period is 256 * 64 * TWWDT</description>
                    <value>#1001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>10</name>
                    <description>Pre-scale is 384; Max time-out period is 384 * 64 * TWWDT</description>
                    <value>#1010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>11</name>
                    <description>Pre-scale is 512; Max time-out period is 512 * 64 * TWWDT</description>
                    <value>#1011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>12</name>
                    <description>Pre-scale is 768; Max time-out period is 768 * 64 * TWWDT</description>
                    <value>#1100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>13</name>
                    <description>Pre-scale is 1024; Max time-out period is 1024 * 64 * TWWDT</description>
                    <value>#1101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>14</name>
                    <description>Pre-scale is 1536; Max time-out period is 1536 * 64 * TWWDT</description>
                    <value>#1110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>15</name>
                    <description>Pre-scale is 2048; Max time-out period is 2048 * 64 * TWWDT</description>
                    <value>#1111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WINCMP</name>
              <description>WWDT Window Compare Register\nSet this register to adjust the valid reload window. \nNote: User can only write WWDTRLD to reload WWDT counter value when current WWDT counter value between 0 and WINCMP. If user writes WWDTRLD when current WWDT counter value larger than WINCMP, WWDT reset signal will generate immediately.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DBGACK_WWDT</name>
              <description>ICE Debug Mode Acknowledge Disable Control\nWWDT down counter will keep going no matter CPU is held by ICE or not.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ICE debug mode acknowledgement effects WWDT counting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ICE debug mode acknowledgement Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>WWDTSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>WWDTSR</displayName>
          <description>Window Watchdog Timer Status Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WWDTIF</name>
              <description>WWDT Compare Match Interrupt Flag\nThis bit indicates the interrupt flag status of WWDT while WWDT counter value matches WINCMP value.\nNote: This bit is cleared by writing 1 to it.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>WWDT counter value matches WINCMP value</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WWDTRF</name>
              <description>WWDT Time-Out Reset Flag\nThis bit indicates the system has been reset by WWDT time-out reset or not.\nNote: This bit is cleared by writing 1 to it.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>WWDT time-out reset did not occur</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>WWDT time-out reset occurred</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>WWDTCVR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>WWDTCVR</displayName>
          <description>Window Watchdog Timer Counter Value Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-only</access>
          <resetValue>0x0000003F</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WWDTCVAL</name>
              <description>WWDT Counter Value\nWWDTCVAL will be updated continuously to monitor 6-bit down counter value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>UART0</name>
      <description>UART Register Map</description>
      <groupName>UART</groupName>
      <baseAddress>0x40050000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x3C</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>UA_RBR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_RBR</displayName>
          <description>UART Receive Buffer Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>RBR</name>
              <description>Receive Buffer Register (Read Only)\nBy reading this register, the UART will return the 8-bit data received from RX pin (LSB first).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_THR</name>
          <alternateRegister>UA_RBR</alternateRegister>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_THR</displayName>
          <description>UART Transmit Holding Register</description>
          <addressOffset>0x0</addressOffset>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>THR</name>
              <description>Transmit Holding Register\nBy writing one byte to this register, the data byte will be stored in transmitter FIFO. The UART Controller will send out the data stored in transmitter FIFO top location through the TX pin.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_IER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_IER</displayName>
          <description>UART Interrupt Enable Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDA_IEN</name>
              <description>Receive Data Available Interrupt Enable Control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RDA_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RDA_INT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>THRE_IEN</name>
              <description>Transmit Holding Register Empty Interrupt Enable Control</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>THRE_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>THRE_INT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RLS_IEN</name>
              <description>Receive Line Status Interrupt Enable Control</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RLS_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RLS_INT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODEM_IEN</name>
              <description>Modem Status Interrupt Enable Control (Available In UART0/UART1 Channel)</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>MODEM_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>MODEM_INT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TOUT_IEN</name>
              <description>RX Time-Out Interrupt Enable Control</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TOUT_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TOUT_INT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BUF_ERR_IEN</name>
              <description>Buffer Error Interrupt Enable Control</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>BUF_ERR_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>BUF_ERR_INT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WKCTSIEN</name>
              <description>NCTS Wake-Up Interrupt Enable Control</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>nCTS wake-up system function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Wake-up system function Enabled, when the system is in Power-down mode, an external nCTS change will wake-up system from Power-down mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_IEN</name>
              <description>LIN Bus Interrupt Enable Control\nNote: This field is used for LIN function mode.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Lin bus interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Lin bus interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WKDATIEN</name>
              <description>Incoming Data Wake-Up Interrupt Enable Control\nNote: Hardware will clear this bit when the incoming data wake-up operation finishes and 'system clock' work stable.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Incoming data wake-up system function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Incoming data wake-up system function Enabled, when the system is in Power-down mode, incoming data will wake-up system from Power-down mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TIME_OUT_EN</name>
              <description>Time-Out Counter Enable Control</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Time-out counter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time-out counter Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTO_RTS_EN</name>
              <description>RTS Auto Flow Control Enable Control ( Available In UART0/UART1 Channel)\nWhen RTS auto-flow is enabled, if the number of bytes in the RX FIFO equals the RTS_TRI_LEV (UA_FCR [19:16]), the UART will de-assert RTS signal.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTS auto flow control Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTS auto flow control Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTO_CTS_EN</name>
              <description>CTS Auto Flow Control Enable Control (Available In UART0/UART1 Channel)\nWhen CTS auto-flow is enabled, the UART will send data to external device when CTS input assert (UART will not send data to device until CTS is asserted).</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>CTS auto flow control Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CTS auto flow control Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ABRIEN</name>
              <description>Auto-Baud Rate Interrupt Enable Control</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Auto-baud rate interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-baud rate interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_FCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_FCR</displayName>
          <description>UART FIFO Control Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000101</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RFR</name>
              <description>RX Field Software Reset\nWhen RFR is set, all the byte in the receiver FIFO /receive buffer and RX internal state machine are cleared.\nNote: This bit will automatically clear at least 3 UART peripherial clock cycles.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the RX internal state machine and pointers</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TFR</name>
              <description>TX Field Software Reset\nWhen TFR is set, all the byte in the transmit FIFO/ transmit buffer and TX internal state machine are cleared.\nNote: This bit will automatically clear at least 3 UART peripherial clock cycles.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the TX internal state machine and pointers</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RFITL</name>
              <description>RX FIFO Interrupt (INT_RDA) Trigger Level (Available In UART0/UART1/UART2 Channel)\nWhen the number of bytes in the receive FIFO equals the RFITL, the RDA_IF will be set (if UA_IER [RDA_IEN] enabled, and an interrupt will be generated).</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX FIFO Interrupt Trigger Level is 1 byte.\nRX Buffer Interrupt Trigger Level is 1 byte</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX FIFO Interrupt Trigger Level is 4 bytes</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>RX FIFO Interrupt Trigger Level is 8 bytes</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>RX FIFO Interrupt Trigger Level is 14 bytes</description>
                    <value>#0011</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_DIS</name>
              <description>Receiver Disable Control\nThe receiver is disabled or not (set 1 to disable receiver).\nNote: This field is used for RS-485 Normal Multi-drop mode. It should be programmed before RS-485_NMM (UA_ALT_CSR[8]) is programmed.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receiver Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receiver Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RTS_TRI_LEV</name>
              <description>RTS Trigger Level For Auto-Flow Control Use (Available In UART0/UART1 Channel)\nNote: This field is used for RTS auto-flow control.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTS Trigger Level is 1 byte</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTS Trigger Level is 4 bytes</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>RTS Trigger Level is 8 bytes</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>RTS Trigger Level is 14 bytes</description>
                    <value>#0011</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_LCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_LCR</displayName>
          <description>UART Line Control Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WLS</name>
              <description>Word Length Selection</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Word length is 5-bit</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Word length is 6-bit</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Word length is 7-bit</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Word length is 8-bit</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>NSB</name>
              <description>Number Of 'STOP Bit'</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One ' STOP bit' is generated in the transmitted data</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When select 5-bit word length, 1.5 'STOP bit' is generated in the transmitted data. When select 6-,7- and 8-bti word length, 2 'STOP bit' is generated in the transmitted data</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PBE</name>
              <description>Parity Bit Enable Control</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No parity bit</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Parity bit is generated on each outgoing character and is checked on each incoming data</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EPE</name>
              <description>Even Parity Enable Control\nThis bit has effect only when PBE (UA_LCR[3]) is set.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Odd number of logic 1's is transmitted and checked in each word</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Even number of logic 1's is transmitted and checked in each word</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPE</name>
              <description>Stick Parity Enable Control</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Stick parity Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>If PBE (UA_LCR[3]) and EBE (UA_LCR[4]) are logic 1, the parity bit is transmitted and checked as logic 0. If PBE (UA_LCR[3]) is 1 and EBE (UA_LCR[4]) is 0 then the parity bit is transmitted and checked as 1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BCB</name>
              <description>Break Control Bit\nWhen this bit is set to logic 1, the serial data output (TX) is forced to the Spacing State (logic 0). This bit acts only on TX and has no effect on the transmitter logic.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_MCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_MCR</displayName>
          <description>UART Modem Control Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000200</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RTS</name>
              <description>RTS (Request-To-Send) Signal Control (Available In UART0/UART1 Channel)\nThis bit is direct control internal RTS signal active or not, and then drive the RTS pin output with LEV_RTS bit configuration.\nNote1: This RTS signal control bit is not effective when RTS auto-flow control is enabled in UART function mode.\nNote2: This RTS signal control bit is not effective when RS-485 auto direction mode (AUD) is enabled in RS-485 function mode.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTS signal is active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTS signal is inactive</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LEV_RTS</name>
              <description>RTS Pin Active Level ( Available In UART0/UART1 Channel)\nThis bit defines the active level state of RTS pin output.\nNote1: Refer to Figure 692 and Figure 693 for UART function mode.\nNote2: Refer to Figure 6103 and Figure 6104 for RS-485 function mode.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTS pin output is high level active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTS pin output is low level active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RTS_ST</name>
              <description>RTS Pin State (Read Only) ( Available In UART0/UART1 Channel)\nThis bit mirror from RTS pin output of voltage logic status.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTS pin output is low level voltage logic state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTS pin output is high level voltage logic state</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_MSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_MSR</displayName>
          <description>UART Modem Status Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000110</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DCTSF</name>
              <description>Detect CTS State Change Flag (Read Only)\nThis bit is set whenever CTS input has change state, and it will generate Modem interrupt to CPU when MODEM_IEN (UA_IER [3]) is set to 1.\nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>CTS input has not change state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CTS input has change state</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>CTS_ST</name>
              <description>CTS Pin Status (Read Only) \nThis bit mirror from CTS pin input of voltage logic status.\nNote: This bit echoes when UART Controller peripheral clock is enabled, and CTS multi-function port is selected.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>CTS pin input is low level voltage logic state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CTS pin input is high level voltage logic state</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LEV_CTS</name>
              <description>CTS Pin Active Level\nThis bit defines the active level state of CTS pin input.\nNote: Refer to  Figure 691 for more information.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>CTS pin input is high level active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CTS pin input is low level active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_FSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_FSR</displayName>
          <description>UART FIFO Status Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x10404000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX_OVER_IF</name>
              <description>RX Overflow Error IF (Read Only)\nThis bit is set when RX FIFO overflow. \nIf the number of bytes of received data is greater than RX_FIFO (UA_RBR) size, 16 bytes of UART0/UART1/UART2, this bit will be set.\nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX FIFO is not overflow.\nRX Buffer is not overflow</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX FIFO is overflow.\nRX Buffer is overflow</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>ABRDIF</name>
              <description>Auto-Baud Rate Detect Interrupt (Read Only) \nThis bit is set to logic '1' when auto-baud rate detect function is finished. \nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Auto-baud rate detect function is not finished</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-baud rate detect function is finished</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>ABRDTOIF</name>
              <description>Auto-Baud Rate Time-Out Interrupt (Read Only) \nNote1: This bit is set to logic '1' in Auto-baud Rate Detect mode and the baud rate counter is overflow.\nNote2: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Auto-baud rate counter is underflow</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-baud rate counter is overflow</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RS485_ADD_DETF</name>
              <description>RS-485 Address Byte Detection Flag (Read Only) (Available In UART0/UART1)\nNote1: This field is used for RS-485 function mode and RS485_ADD_EN (UA_ALT_CSR[15]) is set to 1 to enable Address detection mode.\nNote2: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receiver detects a data that is not an address bit (bit 9 ='1')</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receiver detects a data that is an address bit (bit 9 ='1')</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>PEF</name>
              <description>Parity Error Flag (Read Only)\nThis bit is set to logic 1 whenever the received character does not have a valid 'parity bit', and is reset whenever the CPU writes 1 to this bit.\nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No parity error is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Parity error is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>FEF</name>
              <description>Framing Error Flag (Read Only)\nThis bit is set to logic 1 whenever the received character does not have a valid 'stop bit' (that is, the stop bit following the last data bit or parity bit is detected as logic 0), and is reset whenever the CPU writes 1 to this bit.\nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No framing error is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Framing error is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BIF</name>
              <description>Break Interrupt Flag (Read Only)\nThis bit is set to logic 1 whenever the received data input(RX) is held in the 'spacing state' (logic 0) for longer than a full word transmission time (that is, the total time of 'start bit' + data bits + parity + stop bits) and is reset whenever the CPU writes 1 to this bit.\nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Break interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Break interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_POINTER</name>
              <description>RX FIFO Pointer (Read Only)\nThis field indicates the RX FIFO Buffer Pointer. When UART receives one byte from external device, then RX_POINTER increases one. When one byte of RX FIFO is read by CPU, then RX_POINTER decreases one.\nThe Maximum value shown in RX_POINTER is 15 (UART0/UART1/UART2). When the using level of RX FIFO Buffer equal to 16, the RX_FULL bit is set to 1 and RX_POINTER will show 0. As one byte of RX FIFO is read by CPU, the RX_FULL bit is cleared to 0 and RX_POINTER will show 15 (UART0/UART1/UART2).\nWhen RX Buffer is equal to 1, if one byte data is received, the RX_FULL bit is set to 1 and RX_POINTER will show 1. Once the RX Buffer is read, the RX_POINTER is 0.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_EMPTY</name>
              <description>Receiver FIFO Empty (Read Only)\nThis bit initiate RX FIFO empty or not. (UART0/UART1/UART2)\nNote: When the last byte of RX Buffer has been read by CPU, hardware sets this bit high. It will be cleared when UART receives any new data.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX FIFO is not empty.\nRX Buffer is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX FIFO is empty.\nRX Buffer is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_FULL</name>
              <description>Receiver FIFO Full (Read Only)\nThis bit initiates RX FIFO is full or not (UART0/UART1/UART2). \nNote: This bit is set when the number of usage in RX Buffer is equal to 1 (UART3/UART4/UART5), otherwise is cleared by hardware.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX FIFO is not full.\nRX buffer is not full</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX FIFO is full.\nRX bufferis full</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_POINTER</name>
              <description>TX FIFO Pointer (Read Only)\nThis field indicates the TX FIFO Buffer Pointer. When CPU writes one byte into UA_THR, then TX_POINTER increases one. When one byte of TX FIFO is transferred to Transmitter Shift Register, then TX_POINTER decreases one.\nThe Maximum value shown in TX_POINTER is 15 (UART0/UART1/UART2). When the using level of TX FIFO Buffer is equal to 16, the TX_FULL bit is set to 1 and TX_POINTER will show 0. As one byte of TX FIFO is transferred to Transmitter Shift Register, the TX_FULL bit is cleared to 0 and TX_POINTER will show 15  (UART0/UART1/UART2).\nTX_POINTER is 0 (UART3/URT4/UART5).\nWhen TX Buffer is equal to 1, if one byte data is received, the TX_FULL bit is set to 1 and TX_POINTER will show 1. Once the TX Buffer is read, the TX_POINTER is 0.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_EMPTY</name>
              <description>Transmitter FIFO Empty (Read Only)\nThis bit indicates TX FIFO empty or not. (UART0/UART1/UART2)\nNote: When the last byte of TX Buffer has been transferred to Transmitter Shift Register, hardware sets this bit high. It will be cleared when writing data into THR (TX FIFO not empty).</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX FIFO is not empty.\nTX Buffer is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX FIFO is empty.\nTX Buffer is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_FULL</name>
              <description>Transmitter FIFO Full (Read Only)\nThis bit indicates TX FIFO is full or not. (UART0/UART1/UART2)\nThis bit is set when the number of usage in TX Buffer is equal to 1 (UART3/UART4/UART5), otherwise is cleared by hardware.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX FIFO is not full.\nTX Buffer is not full</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX FIFO is full.\nTX Buffer is full</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_OVER_IF</name>
              <description>TX Overflow Error Interrupt Flag (Read Only)\nIf TX FIFO (UA_THR) is full, an additional write to UA_THR will cause this bit to logic 1. (UART0/UART1/UART2)\nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX FIFO is not overflow.\nTX Buffer is not overflow</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX FIFO is overflow.\nTX Buffer is overflow</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TE_FLAG</name>
              <description>Transmitter Empty Flag (Read Only)\nThis bit is set by hardware when TX FIFO (UA_THR) is empty and the STOP bit of the last byte has been transmitted. (UART0/UART1/UART2)\nNote: This bit is cleared automatically when TX FIFO/TX Buffer is not empty or the last byte transmission has not completed.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX FIFO is not empty.\nTX Buffer is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX FIFO is empty.\nTX Buffer is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_ISR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_ISR</displayName>
          <description>UART Interrupt Status Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000002</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDA_IF</name>
              <description>Receive Data Available Interrupt Flag (Read Only)\nWhen the number of bytes in the RX FIFO (UART0/UART1/UART2) / RX Buffer (UART3/UART4/UART5) equals the RFITL then the RDA_IF(UA_ISR[0]) will be set. If RDA_IEN (UA_IER [0]) is enabled, the RDA interrupt will be generated.\nNote: This bit is read only and it will be cleared when the number of unread bytes of RX FIFO drops below the threshold level (RFITL(UA_FCR[7:4]).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RDA interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RDA interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>THRE_IF</name>
              <description>Transmit Holding Register Empty Interrupt Flag (Read Only) \nThis bit is set when the last data of TX FIFO (UART0/UART1/UART2) / TX Buffer (UART3/UART4/UART5) is transferred to Transmitter Shift Register. If THRE_IEN (UA_IER[1]) is enabled, the THRE interrupt will be generated.\nNote: This bit is read only and it will be cleared when writing data into THR (TX FIFO not empty).</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No THRE interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>THRE interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RLS_IF</name>
              <description>Receive Line Interrupt Flag (Read Only)  \nThis bit is set when the RX receive data have parity error, frame error or break error (at least one of 3 bits, BIF(UA_FSR[6]), FEF(UA_FSR[5]) and PEF(UA_FSR[4]), is set). If RLS_IEN (UA_IER [2]) is enabled, the RLS interrupt will be generated.\nNote2: This bit is read only and reset to 0 when all bits of BIF(UA_FSR[6]), FEF(UA_FSR[5]) and PEF(UA_FSR[4]) are cleared.\nNote3: In RS-485 function mode, this bit is read only and reset to 0 when all bits of BIF(UA_FSR[6]) , FEF(UA_FSR[5]) and PEF(UA_FSR[4]) and RS485_ADD_DETF (UA_FSR[3]) are cleared.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RLS interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RLS interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>MODEM_IF</name>
              <description>MODEM Interrupt Flag (Read Only) (Not Available In UART2 Channel)\nNote: This bit is read only and reset to 0 when bit DCTSF is cleared by a write 1 on DCTSF(UA_MSR[0]).</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Modem interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Modem interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TOUT_IF</name>
              <description>Time-Out Interrupt Flag (Read Only)\nThis bit is set when the RX FIFO (UART0/UART1/UART2) / RX Buffer (UART3/UART4/UART5) is not empty and no activities occurred in the RX FIFO and the time-out counter equal to TOIC. If TOUT_IEN (UA_IER [4]) is enabled, the Tout interrupt will be generated.\nNote: This bit is read only and user can read UA_RBR (RX is in active) to clear it.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Time-out interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time-out interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BUF_ERR_IF</name>
              <description>Buffer Error Interrupt Flag (Read Only)\nThis bit is set when the TX FIFO (UART0/UART1/UART2) / TX Buffer (UART3/UART4/UART5) or RX FIFO (UART0/UART1/UART2)/ RX Buffer (UART3/UART4/UART5) overflows (TX_OVER_IF (UA_FSR[24]) or RX_OVER_IF (UA_FSR[0]) is set). When BUF_ERR_IF (UA_ISR[5]) is set, the transfer is not correct. If BUF_ERR_IEN (UA_IER [8]) is enabled, the buffer error interrupt will be generated.\nNote: This bit is read only and reset to 0 when all bits of TX_OVER_IF(UA_FSR[24]) and RX_OVER_IF(UA_FSR[0]) are cleared.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No buffer error interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Buffer error interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>WKIF</name>
              <description>UART Wake-Up Flag (Read Only)\nThis bit is set when DATWKIF (UART_INTSTS[17]) or CTSWKIF(UART_INTSTS[16]) is set to 1.\nNote: This bit is read only. This bit is cleared if both of DATWKIF (UART_INTSTS[17]) and CTSWKIF (UART_INTSTS[16]) are cleared to 0 by writing 1 to DATWKIF (UART_INTSTS[17])  and CTSWKIF (UART_INTSTS[17]).</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No DATWKIF and CTSWKIF are generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>DATWKIF or CTSWKIF</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LIN_IF</name>
              <description>LIN Bus Flag (Read Only)(UART0/UARt1/UART2)\nNote: This bit is read only. This bit is cleared when LINS_HDET_F (UA_LIN_SR[0]), LIN_BKDET_F (UA_LIN_SR[9]), BIT_ERR_F (UA_LIN_SR[9]), LINS_IDPENR_F (UA_LIN_SR[2]) and LINS_HERR_F (UA_LIN_SR[1]) all are cleared.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>None of LINS_HDET_F, LIN_BKDET_F, BIT_ERR_F, LINS_IDPERR_F and LINS_HERR_F is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>At least one of LINS_HDET_F, LIN_BKDET_F, BIT_ERR_F, LINS_IDPERR_F and LINS_HERR_F is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RDA_INT</name>
              <description>Receive Data Available Interrupt Indicator (Read Only)\nThis bit is set if RDA_IEN (UA_IER[0]) and RDA_IF (UA_ISR[0]) are both set to 1.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RDA interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RDA interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>THRE_INT</name>
              <description>Transmit Holding Register Empty Interrupt Indicator (Read Only)\nThis bit is set if THRE_IEN (UA_IER[1])and THRE_IF(UA_SR[1]) are both set to 1.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No THRE interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>THRE interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RLS_INT</name>
              <description>Receive Line Status Interrupt Indicator (Read Only) \nThis bit is set if RLS_IEN (UA_IER[2]) and RLS_IF(UA_ISR[2]) are both set to 1.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RLS interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RLS interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>MODEM_INT</name>
              <description>MODEM Status Interrupt Indicator (Read Only) (Available In UART0/UART1 Channel)\nThis bit is set if MODEM_IEN(UA_IER[3] and MODEM_IF(UA_ISR[4]) are both set to 1</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Modem interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Modem interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TOUT_INT</name>
              <description>Time-Out Interrupt Indicator (Read Only)\nThis bit is set if TOUT_IEN(UA_IER[4]) and TOUT_IF(UA_ISR[4]) are both set to 1.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Tout interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Tout interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BUF_ERR_INT</name>
              <description>Buffer Error Interrupt Indicator (Read Only)\nThis bit is set if BUF_ERR_IEN(UA_IER[5] and BUF_ERR_IF(UA_ISR[5]) are both set to 1.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No buffer error interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Buffer error interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LIN_INT</name>
              <description>LIN Bus Interrupt Indicator (Read Only)\nThis bit is set if LIN_IEN (UA_IER[8]) and LIN _IF(UA_ISR[7]) are both set to 1.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No LIN Bus interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The LIN Bus interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>CTSWKIF</name>
              <description>NCTS Wake-Up Interrupt Flag (Read Only)\nNote1: If WKCTSIEN (UA_IER[6])is enabled, the wake-up interrupt is generated.\nNote2: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Chip stays in power-down state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Chip wake-up from power-down state by nCTS wake-up</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>DATWKIF</name>
              <description>Data Wake-Up Interrupt Flag (Read Only)\nThis bit is set if chip wake-up from power-down state by data wake-up.\nNote1: If WKDATIEN (UA_IER[10]) is enabled, the wake-up interrupt is generated.\nNote2: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Chip stays in power-down state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Chip wake-up from power-down state by data wake-up</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_TOR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_TOR</displayName>
          <description>UART Time-out Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TOIC</name>
              <description>Time-Out Interrupt Comparator</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DLY</name>
              <description>TX Delay Time Value \nThis field is used to programming the transfer delay time between the last stop bit and next start bit.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_BAUD</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_BAUD</displayName>
          <description>UART Baud Rate Divisor Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x0F000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BRD</name>
              <description>Baud Rate Divider\nThe field indicates the baud rate divider.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIVIDER_X</name>
              <description>Divider X</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIV_X_ONE</name>
              <description>Divider X Equal To 1\nRefer to Table 624 UART Baud Rate Equation for more information.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Divider M = X (the equation of M = X+1, but DIVIDER_X[27:24] must  = 8)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Divider M = 1 (the equation of M = 1, but BRD [15:0] must  = 3)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DIV_X_EN</name>
              <description>Divider X Enable Control\nRefer to Table 624 UART Baud Rate Equation for more information.\nNote: In IrDA mode, this bit must disable.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Divider X Disabled (the equation of M = 16)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Divider X Enabled (the equation of M = X+1, but DIVIDER_X [27:24] must  = 8)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_IRCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_IRCR</displayName>
          <description>UART IrDA Control Register</description>
          <addressOffset>0x28</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000040</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX_SELECT</name>
              <description>IrDA Receiver/Transmitter Selection Enable Control</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>IrDA Transmitter Disabled and Receiver Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>IrDA Transmitter Enabled and Receiver Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INV_TX</name>
              <description>IrDA Inverse Transmitting Output Signal Control</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>None inverse transmitting signal</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverse transmitting output signal</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INV_RX</name>
              <description>IrDA Inverse Receive Input Signal Control</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>None inverse receiving input signal</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverse receiving input signal</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_ALT_CSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_ALT_CSR</displayName>
          <description>UART Alternate Control/Status Register</description>
          <addressOffset>0x2C</addressOffset>
          <access>read-write</access>
          <resetValue>0x0000000C</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LIN_BKFL</name>
              <description>UART LIN Break Field Length (Available In UART0/UART1/UART2)\nThis field indicates a 4-bit LIN TX break field count.\nNote1: This break field length is LIN_BKFL + 1.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_RX_EN</name>
              <description>LIN RX Enable Control (Available In UART0/UART1/UART2)</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN RX mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN RX mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_TX_EN</name>
              <description>LIN TX Break Mode Enable Control (Available In UART0/UART1/UART2)\nNote: When TX break field transfer operation finished, this bit will be cleared automatically.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN TX Break mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN TX Break mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS485_NMM</name>
              <description>RS-485 Normal Multi-Drop Operation Mode (NMM) (Available In UART0/UART1)\nNote: It cannot be active with RS-485_AAD operation mode.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RS-485 Normal Multi-drop Operation mode (NMM) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RS-485 Normal Multi-drop Operation mode (NMM) Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS485_AAD</name>
              <description>RS-485 Auto Address Detection Operation Mode (AAD) (Available In UART0/UART1)\nNote: It cannot be active with RS-485_NMM operation mode.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RS-485 Auto Address Detection Operation mode (AAD) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RS-485 Auto Address Detection Operation mode (AAD) Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS485_AUD</name>
              <description>RS-485 Auto Direction Mode (AUD) (Available In UART0/UART1)\nNote: It can be active with RS-485_AAD or RS-485_NMM operation mode.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RS-485 Auto Direction Operation mode (AUO) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RS-485 Auto Direction Operation mode (AUO) Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS485_ADD_EN</name>
              <description>RS-485 Address Detection Enable Control (Available In UART0/UART1)\nThis bit is used to enable RS-485 Address Detection mode. \nNote: This bit is used for RS-485 any operation mode.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Address detection mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Address detection mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ABRIF</name>
              <description>Auto-Baud Rate Interrupt Flag (Read Only) \nThis bit is set when auto-baud rate detection function finished or the auto-baud rate counter was overflow and if ABRIEN(UART_IEN [18]) is set then the auto-baud rate interrupt will be generated. \nNote: This bit is read only, but it can be cleared by writing '1' to ABRDTOIF (UA_FSR[2]) and ABRDIF(UA_FSR[1]).</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ABRDEN</name>
              <description>Auto-Baud Rate Detect Enable Control\nThis bit is cleared automatically after auto-baud detection is finished.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Auto-baud rate detect function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-baud rate detect function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ABRDBITS</name>
              <description>Auto-Baud Rate Detect Bit Length \nNote: The calculation of bit number includes the START bit.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>1-bit time from Start bit to the 1st rising edge. The input pattern shall be 0x01</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>2-bit time from Start bit to the 1st rising edge. The input pattern shall be 0x02</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>4-bit time from Start bit to the 1st rising edge. The input pattern shall be 0x08</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>8-bit time from Start bit to the 1st rising edge. The input pattern shall be 0x80</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADDR_MATCH</name>
              <description>Address Match Value Register (Available In UART0/UART1)\nThis field contains the RS-485 address match values.\nNote: This field is used for RS-485 auto address detection mode.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_FUN_SEL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_FUN_SEL</displayName>
          <description>UART Function Select Register</description>
          <addressOffset>0x30</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FUN_SEL</name>
              <description>Function Select Enable Control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UART function Enabled</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN function Enabled. (Available in UART0/UART1/UART2)</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>IrDA function Enabled</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>RS-485 function Enabled. (Available in UART0/UART1)</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_LIN_CTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_LIN_CTL</displayName>
          <description>UART LIN Control Register</description>
          <addressOffset>0x34</addressOffset>
          <access>read-write</access>
          <resetValue>0x000C0000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LINS_EN</name>
              <description>LIN Slave Mode Enable Control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN slave mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN slave mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LINS_HDET_EN</name>
              <description>LIN Slave Header Detection Enable Control</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN slave header detection Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN slave header detection Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LINS_ARS_EN</name>
              <description>LIN Slave Automatic Resynchronization Mode Enable Control\nNote2: When operation in Automatic Resynchronization mode, the baud rate setting must be mode2 (BAUD_M1 (UA_BAUD [29]) and BAUD_M0 (UA_BAUD [28]) must be 1).\nNote3: The control and interactions of this field are explained in section 6.11.5.8.4. (Slave mode with automatic resynchronization).</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN automatic resynchronization Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN automatic resynchronization Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LINS_DUM_EN</name>
              <description>LIN Slave Divider Update Method Enable Control\nNote2: This bit used for LIN Slave Automatic Resynchronization mode. (for Non-Automatic Resynchronization mode, this bit should be kept cleared) \nNote3: The control and interactions of this field are explained in section 6.11.5.8.4. (Slave mode with automatic resynchronization).</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UA_BAUD updated is written by software (if no automatic resynchronization update occurs at the same time)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UA_BAUD is updated at the next received character. User must set the bit before checksum reception</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_MUTE_EN</name>
              <description>LIN Mute Mode Enable Control\nNote: The exit from mute mode condition and each control and interactions of this field are explained in (LIN slave mode).</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN mute mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN mute mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_SHD</name>
              <description>LIN TX Send Header Enable Control\nThe LIN TX header can be 'break field' or 'break and sync field' or 'break, sync and frame ID field', it is depend on setting LIN_HEAD_SEL (UA_LIN_CTL[23:22]).\nNote1: These registers are shadow registers of LIN_SHD (UA_ALT_CSR [7]); user can read/write it by setting LIN_SHD (UA_ALT_CSR [7]) or LIN_SHD (UA_LIN_CTL [8]).\nNote2: When transmitter header field (it may be 'break' or 'break + sync' or 'break + sync + frame ID' selected by LIN_HEAD_SEL (UA_LIN_CTL[23:22]) field) transfer operation finished, this bit will be cleared automatically.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Send LIN TX header Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Send LIN TX header Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_IDPEN</name>
              <description>LIN ID Parity Enable Control</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN frame ID parity Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN frame ID parity Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_BKDET_EN</name>
              <description>LIN Break Detection Enable Control</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN break detection Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN break detection Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_RX_DIS</name>
              <description>LIN Receiver Disable Control</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN receiver Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN receiver Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BIT_ERR_EN</name>
              <description>Bit Error Detect Enable Control</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit error detection function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit error detection Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_BKFL</name>
              <description>LIN Break Field Length\nThis field indicates a 4-bit LIN TX break field count.\nNote1: These registers are shadow registers of LIN_BKFL, User can read/write it by setting LIN_BKFL (UA_ALT_CSR[3:0]) or LIN_BKFL (UA_LIN_CTL[19:16].\nNote2: This break field length is LIN_BKFL + 1.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_BS_LEN</name>
              <description>LIN Break/Sync Delimiter Length\n\nNote: This bit used for LIN master to sending header field.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The LIN break/sync delimiter length is 1 bit time</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>The LIN break/sync delimiter length is 2 bit time.\nThe LIN break/sync delimiter length is 3 bit time</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>The LIN break/sync delimiter length is 4 bit time</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_HEAD_SEL</name>
              <description>LIN Header Select</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The LIN header includes 'break field'</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The LIN header includes 'break field' and 'sync field'</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>The LIN header includes 'break field', 'sync field' and 'frame ID field'</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved.</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_PID</name>
              <description>LIN PID Register\nIf the parity generated by hardware, user fill ID0~ID5, (LIN_PID [29:24] )hardware will calculate P0 (LIN_PID[30]) and P1 (LIN_PID[31]), otherwise user must filled frame ID and parity in this field.\n\nNote1: User can fill any 8-bit value to this field and the bit 24 indicates ID0 (LSB first).\nNote2: This field can be used for LIN master mode or slave mode.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_LIN_SR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_LIN_SR</displayName>
          <description>UART LIN Status Register</description>
          <addressOffset>0x38</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LINS_HDET_F</name>
              <description>LIN Slave Header Detection Flag (Read Only)\nThis bit is set by hardware when a LIN header is detected in LIN slave mode and be cleared by writing 1 to it.\nNote3: When enable ID parity check LIN_IDPEN (UA_LIN_CTL [9]), if hardware detect complete header ('break + sync + frame ID'), the LINS_HEDT_F will be set whether the frame ID correct or not.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN header not detected</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN header detected (break + sync + frame ID)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LINS_HERR_F</name>
              <description>LIN Slave Header Error Flag (Read Only)\nThis bit is set by hardware when a LIN header error is detected in LIN slave mode and be cleared by writing 1 to it. The header errors include 'break delimiter is too short (less than 0.5 bit time)', 'frame error in sync field or Identifier field', 'sync field data is not 0x55 in Non-Automatic Resynchronization mode', 'sync field deviation error with Automatic Resynchronization mode', 'sync field measure time-out with Automatic Resynchronization mode' and 'LIN header reception time-out'.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN header error not detected</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN header error detected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LINS_IDPERR_F</name>
              <description>LIN Slave ID Parity Error Flag (Read Only)\nThis bit is set by hardware when receipted frame ID parity is not correct.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receipted frame ID parity is not correct</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LINS_SYNC_F</name>
              <description>LIN Slave Sync Field\nThis bit indicates that the LIN sync field is being analyzed in Automatic Resynchronization mode. When the receiver header have some error been detect, user must reset the internal circuit to re-search new frame header by writing 1 to this bit.\nNote2: This bit is read only, but it can be cleared by writing 1 to it.\nNote3: When writing 1 to it, hardware will reload the initial baud rate and re-search a new frame header.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The current character is not at LIN sync state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The current character is at LIN sync state</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_BKDET_F</name>
              <description>LIN Break Detection Flag (Read Only)\nThis bit is set by hardware when a break is detected and be cleared by writing 1 to it through software.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN break not detected</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN break detected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BIT_ERR_F</name>
              <description>Bit Error Detect Status Flag (Read Only)\nAt TX transfer state, hardware will monitoring the bus state, if the input pin (SIN) state not equals to the output pin (SOUT) state, BIT_ERR_F (UA_LIN_SR[9]) will be set.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>UART1</name>
      <description>UART Register Map</description>
      <groupName>UART</groupName>
      <baseAddress>0x40150000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x3C</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>UA_RBR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_RBR</displayName>
          <description>UART Receive Buffer Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>RBR</name>
              <description>Receive Buffer Register (Read Only)\nBy reading this register, the UART will return the 8-bit data received from RX pin (LSB first).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_THR</name>
          <alternateRegister>UA_RBR</alternateRegister>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_THR</displayName>
          <description>UART Transmit Holding Register</description>
          <addressOffset>0x0</addressOffset>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>THR</name>
              <description>Transmit Holding Register\nBy writing one byte to this register, the data byte will be stored in transmitter FIFO. The UART Controller will send out the data stored in transmitter FIFO top location through the TX pin.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_IER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_IER</displayName>
          <description>UART Interrupt Enable Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDA_IEN</name>
              <description>Receive Data Available Interrupt Enable Control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RDA_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RDA_INT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>THRE_IEN</name>
              <description>Transmit Holding Register Empty Interrupt Enable Control</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>THRE_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>THRE_INT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RLS_IEN</name>
              <description>Receive Line Status Interrupt Enable Control</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RLS_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RLS_INT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODEM_IEN</name>
              <description>Modem Status Interrupt Enable Control (Available In UART0/UART1 Channel)</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>MODEM_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>MODEM_INT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TOUT_IEN</name>
              <description>RX Time-Out Interrupt Enable Control</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TOUT_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TOUT_INT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BUF_ERR_IEN</name>
              <description>Buffer Error Interrupt Enable Control</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>BUF_ERR_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>BUF_ERR_INT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WKCTSIEN</name>
              <description>NCTS Wake-Up Interrupt Enable Control</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>nCTS wake-up system function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Wake-up system function Enabled, when the system is in Power-down mode, an external nCTS change will wake-up system from Power-down mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_IEN</name>
              <description>LIN Bus Interrupt Enable Control\nNote: This field is used for LIN function mode.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Lin bus interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Lin bus interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WKDATIEN</name>
              <description>Incoming Data Wake-Up Interrupt Enable Control\nNote: Hardware will clear this bit when the incoming data wake-up operation finishes and 'system clock' work stable.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Incoming data wake-up system function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Incoming data wake-up system function Enabled, when the system is in Power-down mode, incoming data will wake-up system from Power-down mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TIME_OUT_EN</name>
              <description>Time-Out Counter Enable Control</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Time-out counter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time-out counter Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTO_RTS_EN</name>
              <description>RTS Auto Flow Control Enable Control ( Available In UART0/UART1 Channel)\nWhen RTS auto-flow is enabled, if the number of bytes in the RX FIFO equals the RTS_TRI_LEV (UA_FCR [19:16]), the UART will de-assert RTS signal.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTS auto flow control Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTS auto flow control Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTO_CTS_EN</name>
              <description>CTS Auto Flow Control Enable Control (Available In UART0/UART1 Channel)\nWhen CTS auto-flow is enabled, the UART will send data to external device when CTS input assert (UART will not send data to device until CTS is asserted).</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>CTS auto flow control Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CTS auto flow control Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ABRIEN</name>
              <description>Auto-Baud Rate Interrupt Enable Control</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Auto-baud rate interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-baud rate interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_FCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_FCR</displayName>
          <description>UART FIFO Control Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000101</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RFR</name>
              <description>RX Field Software Reset\nWhen RFR is set, all the byte in the receiver FIFO /receive buffer and RX internal state machine are cleared.\nNote: This bit will automatically clear at least 3 UART peripherial clock cycles.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the RX internal state machine and pointers</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TFR</name>
              <description>TX Field Software Reset\nWhen TFR is set, all the byte in the transmit FIFO/ transmit buffer and TX internal state machine are cleared.\nNote: This bit will automatically clear at least 3 UART peripherial clock cycles.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the TX internal state machine and pointers</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RFITL</name>
              <description>RX FIFO Interrupt (INT_RDA) Trigger Level (Available In UART0/UART1/UART2 Channel)\nWhen the number of bytes in the receive FIFO equals the RFITL, the RDA_IF will be set (if UA_IER [RDA_IEN] enabled, and an interrupt will be generated).</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX FIFO Interrupt Trigger Level is 1 byte.\nRX Buffer Interrupt Trigger Level is 1 byte</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX FIFO Interrupt Trigger Level is 4 bytes</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>RX FIFO Interrupt Trigger Level is 8 bytes</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>RX FIFO Interrupt Trigger Level is 14 bytes</description>
                    <value>#0011</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_DIS</name>
              <description>Receiver Disable Control\nThe receiver is disabled or not (set 1 to disable receiver).\nNote: This field is used for RS-485 Normal Multi-drop mode. It should be programmed before RS-485_NMM (UA_ALT_CSR[8]) is programmed.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receiver Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receiver Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RTS_TRI_LEV</name>
              <description>RTS Trigger Level For Auto-Flow Control Use (Available In UART0/UART1 Channel)\nNote: This field is used for RTS auto-flow control.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTS Trigger Level is 1 byte</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTS Trigger Level is 4 bytes</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>RTS Trigger Level is 8 bytes</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>RTS Trigger Level is 14 bytes</description>
                    <value>#0011</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_LCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_LCR</displayName>
          <description>UART Line Control Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WLS</name>
              <description>Word Length Selection</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Word length is 5-bit</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Word length is 6-bit</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Word length is 7-bit</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Word length is 8-bit</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>NSB</name>
              <description>Number Of 'STOP Bit'</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One ' STOP bit' is generated in the transmitted data</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When select 5-bit word length, 1.5 'STOP bit' is generated in the transmitted data. When select 6-,7- and 8-bti word length, 2 'STOP bit' is generated in the transmitted data</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PBE</name>
              <description>Parity Bit Enable Control</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No parity bit</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Parity bit is generated on each outgoing character and is checked on each incoming data</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EPE</name>
              <description>Even Parity Enable Control\nThis bit has effect only when PBE (UA_LCR[3]) is set.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Odd number of logic 1's is transmitted and checked in each word</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Even number of logic 1's is transmitted and checked in each word</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPE</name>
              <description>Stick Parity Enable Control</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Stick parity Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>If PBE (UA_LCR[3]) and EBE (UA_LCR[4]) are logic 1, the parity bit is transmitted and checked as logic 0. If PBE (UA_LCR[3]) is 1 and EBE (UA_LCR[4]) is 0 then the parity bit is transmitted and checked as 1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BCB</name>
              <description>Break Control Bit\nWhen this bit is set to logic 1, the serial data output (TX) is forced to the Spacing State (logic 0). This bit acts only on TX and has no effect on the transmitter logic.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_MCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_MCR</displayName>
          <description>UART Modem Control Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000200</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RTS</name>
              <description>RTS (Request-To-Send) Signal Control (Available In UART0/UART1 Channel)\nThis bit is direct control internal RTS signal active or not, and then drive the RTS pin output with LEV_RTS bit configuration.\nNote1: This RTS signal control bit is not effective when RTS auto-flow control is enabled in UART function mode.\nNote2: This RTS signal control bit is not effective when RS-485 auto direction mode (AUD) is enabled in RS-485 function mode.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTS signal is active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTS signal is inactive</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LEV_RTS</name>
              <description>RTS Pin Active Level ( Available In UART0/UART1 Channel)\nThis bit defines the active level state of RTS pin output.\nNote1: Refer to Figure 692 and Figure 693 for UART function mode.\nNote2: Refer to Figure 6103 and Figure 6104 for RS-485 function mode.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTS pin output is high level active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTS pin output is low level active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RTS_ST</name>
              <description>RTS Pin State (Read Only) ( Available In UART0/UART1 Channel)\nThis bit mirror from RTS pin output of voltage logic status.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTS pin output is low level voltage logic state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTS pin output is high level voltage logic state</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_MSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_MSR</displayName>
          <description>UART Modem Status Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000110</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DCTSF</name>
              <description>Detect CTS State Change Flag (Read Only)\nThis bit is set whenever CTS input has change state, and it will generate Modem interrupt to CPU when MODEM_IEN (UA_IER [3]) is set to 1.\nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>CTS input has not change state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CTS input has change state</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>CTS_ST</name>
              <description>CTS Pin Status (Read Only) \nThis bit mirror from CTS pin input of voltage logic status.\nNote: This bit echoes when UART Controller peripheral clock is enabled, and CTS multi-function port is selected.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>CTS pin input is low level voltage logic state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CTS pin input is high level voltage logic state</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LEV_CTS</name>
              <description>CTS Pin Active Level\nThis bit defines the active level state of CTS pin input.\nNote: Refer to  Figure 691 for more information.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>CTS pin input is high level active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CTS pin input is low level active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_FSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_FSR</displayName>
          <description>UART FIFO Status Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x10404000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX_OVER_IF</name>
              <description>RX Overflow Error IF (Read Only)\nThis bit is set when RX FIFO overflow. \nIf the number of bytes of received data is greater than RX_FIFO (UA_RBR) size, 16 bytes of UART0/UART1/UART2, this bit will be set.\nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX FIFO is not overflow.\nRX Buffer is not overflow</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX FIFO is overflow.\nRX Buffer is overflow</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>ABRDIF</name>
              <description>Auto-Baud Rate Detect Interrupt (Read Only) \nThis bit is set to logic '1' when auto-baud rate detect function is finished. \nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Auto-baud rate detect function is not finished</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-baud rate detect function is finished</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>ABRDTOIF</name>
              <description>Auto-Baud Rate Time-Out Interrupt (Read Only) \nNote1: This bit is set to logic '1' in Auto-baud Rate Detect mode and the baud rate counter is overflow.\nNote2: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Auto-baud rate counter is underflow</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-baud rate counter is overflow</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RS485_ADD_DETF</name>
              <description>RS-485 Address Byte Detection Flag (Read Only) (Available In UART0/UART1)\nNote1: This field is used for RS-485 function mode and RS485_ADD_EN (UA_ALT_CSR[15]) is set to 1 to enable Address detection mode.\nNote2: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receiver detects a data that is not an address bit (bit 9 ='1')</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receiver detects a data that is an address bit (bit 9 ='1')</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>PEF</name>
              <description>Parity Error Flag (Read Only)\nThis bit is set to logic 1 whenever the received character does not have a valid 'parity bit', and is reset whenever the CPU writes 1 to this bit.\nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No parity error is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Parity error is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>FEF</name>
              <description>Framing Error Flag (Read Only)\nThis bit is set to logic 1 whenever the received character does not have a valid 'stop bit' (that is, the stop bit following the last data bit or parity bit is detected as logic 0), and is reset whenever the CPU writes 1 to this bit.\nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No framing error is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Framing error is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BIF</name>
              <description>Break Interrupt Flag (Read Only)\nThis bit is set to logic 1 whenever the received data input(RX) is held in the 'spacing state' (logic 0) for longer than a full word transmission time (that is, the total time of 'start bit' + data bits + parity + stop bits) and is reset whenever the CPU writes 1 to this bit.\nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Break interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Break interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_POINTER</name>
              <description>RX FIFO Pointer (Read Only)\nThis field indicates the RX FIFO Buffer Pointer. When UART receives one byte from external device, then RX_POINTER increases one. When one byte of RX FIFO is read by CPU, then RX_POINTER decreases one.\nThe Maximum value shown in RX_POINTER is 15 (UART0/UART1/UART2). When the using level of RX FIFO Buffer equal to 16, the RX_FULL bit is set to 1 and RX_POINTER will show 0. As one byte of RX FIFO is read by CPU, the RX_FULL bit is cleared to 0 and RX_POINTER will show 15 (UART0/UART1/UART2).\nWhen RX Buffer is equal to 1, if one byte data is received, the RX_FULL bit is set to 1 and RX_POINTER will show 1. Once the RX Buffer is read, the RX_POINTER is 0.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_EMPTY</name>
              <description>Receiver FIFO Empty (Read Only)\nThis bit initiate RX FIFO empty or not. (UART0/UART1/UART2)\nNote: When the last byte of RX Buffer has been read by CPU, hardware sets this bit high. It will be cleared when UART receives any new data.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX FIFO is not empty.\nRX Buffer is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX FIFO is empty.\nRX Buffer is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_FULL</name>
              <description>Receiver FIFO Full (Read Only)\nThis bit initiates RX FIFO is full or not (UART0/UART1/UART2). \nNote: This bit is set when the number of usage in RX Buffer is equal to 1 (UART3/UART4/UART5), otherwise is cleared by hardware.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX FIFO is not full.\nRX buffer is not full</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX FIFO is full.\nRX bufferis full</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_POINTER</name>
              <description>TX FIFO Pointer (Read Only)\nThis field indicates the TX FIFO Buffer Pointer. When CPU writes one byte into UA_THR, then TX_POINTER increases one. When one byte of TX FIFO is transferred to Transmitter Shift Register, then TX_POINTER decreases one.\nThe Maximum value shown in TX_POINTER is 15 (UART0/UART1/UART2). When the using level of TX FIFO Buffer is equal to 16, the TX_FULL bit is set to 1 and TX_POINTER will show 0. As one byte of TX FIFO is transferred to Transmitter Shift Register, the TX_FULL bit is cleared to 0 and TX_POINTER will show 15  (UART0/UART1/UART2).\nTX_POINTER is 0 (UART3/URT4/UART5).\nWhen TX Buffer is equal to 1, if one byte data is received, the TX_FULL bit is set to 1 and TX_POINTER will show 1. Once the TX Buffer is read, the TX_POINTER is 0.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_EMPTY</name>
              <description>Transmitter FIFO Empty (Read Only)\nThis bit indicates TX FIFO empty or not. (UART0/UART1/UART2)\nNote: When the last byte of TX Buffer has been transferred to Transmitter Shift Register, hardware sets this bit high. It will be cleared when writing data into THR (TX FIFO not empty).</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX FIFO is not empty.\nTX Buffer is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX FIFO is empty.\nTX Buffer is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_FULL</name>
              <description>Transmitter FIFO Full (Read Only)\nThis bit indicates TX FIFO is full or not. (UART0/UART1/UART2)\nThis bit is set when the number of usage in TX Buffer is equal to 1 (UART3/UART4/UART5), otherwise is cleared by hardware.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX FIFO is not full.\nTX Buffer is not full</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX FIFO is full.\nTX Buffer is full</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_OVER_IF</name>
              <description>TX Overflow Error Interrupt Flag (Read Only)\nIf TX FIFO (UA_THR) is full, an additional write to UA_THR will cause this bit to logic 1. (UART0/UART1/UART2)\nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX FIFO is not overflow.\nTX Buffer is not overflow</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX FIFO is overflow.\nTX Buffer is overflow</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TE_FLAG</name>
              <description>Transmitter Empty Flag (Read Only)\nThis bit is set by hardware when TX FIFO (UA_THR) is empty and the STOP bit of the last byte has been transmitted. (UART0/UART1/UART2)\nNote: This bit is cleared automatically when TX FIFO/TX Buffer is not empty or the last byte transmission has not completed.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX FIFO is not empty.\nTX Buffer is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX FIFO is empty.\nTX Buffer is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_ISR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_ISR</displayName>
          <description>UART Interrupt Status Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000002</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDA_IF</name>
              <description>Receive Data Available Interrupt Flag (Read Only)\nWhen the number of bytes in the RX FIFO (UART0/UART1/UART2) / RX Buffer (UART3/UART4/UART5) equals the RFITL then the RDA_IF(UA_ISR[0]) will be set. If RDA_IEN (UA_IER [0]) is enabled, the RDA interrupt will be generated.\nNote: This bit is read only and it will be cleared when the number of unread bytes of RX FIFO drops below the threshold level (RFITL(UA_FCR[7:4]).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RDA interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RDA interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>THRE_IF</name>
              <description>Transmit Holding Register Empty Interrupt Flag (Read Only) \nThis bit is set when the last data of TX FIFO (UART0/UART1/UART2) / TX Buffer (UART3/UART4/UART5) is transferred to Transmitter Shift Register. If THRE_IEN (UA_IER[1]) is enabled, the THRE interrupt will be generated.\nNote: This bit is read only and it will be cleared when writing data into THR (TX FIFO not empty).</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No THRE interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>THRE interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RLS_IF</name>
              <description>Receive Line Interrupt Flag (Read Only)  \nThis bit is set when the RX receive data have parity error, frame error or break error (at least one of 3 bits, BIF(UA_FSR[6]), FEF(UA_FSR[5]) and PEF(UA_FSR[4]), is set). If RLS_IEN (UA_IER [2]) is enabled, the RLS interrupt will be generated.\nNote2: This bit is read only and reset to 0 when all bits of BIF(UA_FSR[6]), FEF(UA_FSR[5]) and PEF(UA_FSR[4]) are cleared.\nNote3: In RS-485 function mode, this bit is read only and reset to 0 when all bits of BIF(UA_FSR[6]) , FEF(UA_FSR[5]) and PEF(UA_FSR[4]) and RS485_ADD_DETF (UA_FSR[3]) are cleared.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RLS interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RLS interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>MODEM_IF</name>
              <description>MODEM Interrupt Flag (Read Only) (Not Available In UART2 Channel)\nNote: This bit is read only and reset to 0 when bit DCTSF is cleared by a write 1 on DCTSF(UA_MSR[0]).</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Modem interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Modem interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TOUT_IF</name>
              <description>Time-Out Interrupt Flag (Read Only)\nThis bit is set when the RX FIFO (UART0/UART1/UART2) / RX Buffer (UART3/UART4/UART5) is not empty and no activities occurred in the RX FIFO and the time-out counter equal to TOIC. If TOUT_IEN (UA_IER [4]) is enabled, the Tout interrupt will be generated.\nNote: This bit is read only and user can read UA_RBR (RX is in active) to clear it.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Time-out interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time-out interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BUF_ERR_IF</name>
              <description>Buffer Error Interrupt Flag (Read Only)\nThis bit is set when the TX FIFO (UART0/UART1/UART2) / TX Buffer (UART3/UART4/UART5) or RX FIFO (UART0/UART1/UART2)/ RX Buffer (UART3/UART4/UART5) overflows (TX_OVER_IF (UA_FSR[24]) or RX_OVER_IF (UA_FSR[0]) is set). When BUF_ERR_IF (UA_ISR[5]) is set, the transfer is not correct. If BUF_ERR_IEN (UA_IER [8]) is enabled, the buffer error interrupt will be generated.\nNote: This bit is read only and reset to 0 when all bits of TX_OVER_IF(UA_FSR[24]) and RX_OVER_IF(UA_FSR[0]) are cleared.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No buffer error interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Buffer error interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>WKIF</name>
              <description>UART Wake-Up Flag (Read Only)\nThis bit is set when DATWKIF (UART_INTSTS[17]) or CTSWKIF(UART_INTSTS[16]) is set to 1.\nNote: This bit is read only. This bit is cleared if both of DATWKIF (UART_INTSTS[17]) and CTSWKIF (UART_INTSTS[16]) are cleared to 0 by writing 1 to DATWKIF (UART_INTSTS[17])  and CTSWKIF (UART_INTSTS[17]).</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No DATWKIF and CTSWKIF are generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>DATWKIF or CTSWKIF</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LIN_IF</name>
              <description>LIN Bus Flag (Read Only)(UART0/UARt1/UART2)\nNote: This bit is read only. This bit is cleared when LINS_HDET_F (UA_LIN_SR[0]), LIN_BKDET_F (UA_LIN_SR[9]), BIT_ERR_F (UA_LIN_SR[9]), LINS_IDPENR_F (UA_LIN_SR[2]) and LINS_HERR_F (UA_LIN_SR[1]) all are cleared.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>None of LINS_HDET_F, LIN_BKDET_F, BIT_ERR_F, LINS_IDPERR_F and LINS_HERR_F is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>At least one of LINS_HDET_F, LIN_BKDET_F, BIT_ERR_F, LINS_IDPERR_F and LINS_HERR_F is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RDA_INT</name>
              <description>Receive Data Available Interrupt Indicator (Read Only)\nThis bit is set if RDA_IEN (UA_IER[0]) and RDA_IF (UA_ISR[0]) are both set to 1.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RDA interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RDA interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>THRE_INT</name>
              <description>Transmit Holding Register Empty Interrupt Indicator (Read Only)\nThis bit is set if THRE_IEN (UA_IER[1])and THRE_IF(UA_SR[1]) are both set to 1.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No THRE interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>THRE interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RLS_INT</name>
              <description>Receive Line Status Interrupt Indicator (Read Only) \nThis bit is set if RLS_IEN (UA_IER[2]) and RLS_IF(UA_ISR[2]) are both set to 1.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RLS interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RLS interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>MODEM_INT</name>
              <description>MODEM Status Interrupt Indicator (Read Only) (Available In UART0/UART1 Channel)\nThis bit is set if MODEM_IEN(UA_IER[3] and MODEM_IF(UA_ISR[4]) are both set to 1</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Modem interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Modem interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TOUT_INT</name>
              <description>Time-Out Interrupt Indicator (Read Only)\nThis bit is set if TOUT_IEN(UA_IER[4]) and TOUT_IF(UA_ISR[4]) are both set to 1.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Tout interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Tout interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BUF_ERR_INT</name>
              <description>Buffer Error Interrupt Indicator (Read Only)\nThis bit is set if BUF_ERR_IEN(UA_IER[5] and BUF_ERR_IF(UA_ISR[5]) are both set to 1.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No buffer error interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Buffer error interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LIN_INT</name>
              <description>LIN Bus Interrupt Indicator (Read Only)\nThis bit is set if LIN_IEN (UA_IER[8]) and LIN _IF(UA_ISR[7]) are both set to 1.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No LIN Bus interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The LIN Bus interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>CTSWKIF</name>
              <description>NCTS Wake-Up Interrupt Flag (Read Only)\nNote1: If WKCTSIEN (UA_IER[6])is enabled, the wake-up interrupt is generated.\nNote2: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Chip stays in power-down state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Chip wake-up from power-down state by nCTS wake-up</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>DATWKIF</name>
              <description>Data Wake-Up Interrupt Flag (Read Only)\nThis bit is set if chip wake-up from power-down state by data wake-up.\nNote1: If WKDATIEN (UA_IER[10]) is enabled, the wake-up interrupt is generated.\nNote2: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Chip stays in power-down state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Chip wake-up from power-down state by data wake-up</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_TOR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_TOR</displayName>
          <description>UART Time-out Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TOIC</name>
              <description>Time-Out Interrupt Comparator</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DLY</name>
              <description>TX Delay Time Value \nThis field is used to programming the transfer delay time between the last stop bit and next start bit.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_BAUD</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_BAUD</displayName>
          <description>UART Baud Rate Divisor Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x0F000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BRD</name>
              <description>Baud Rate Divider\nThe field indicates the baud rate divider.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIVIDER_X</name>
              <description>Divider X</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIV_X_ONE</name>
              <description>Divider X Equal To 1\nRefer to Table 624 UART Baud Rate Equation for more information.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Divider M = X (the equation of M = X+1, but DIVIDER_X[27:24] must  = 8)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Divider M = 1 (the equation of M = 1, but BRD [15:0] must  = 3)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DIV_X_EN</name>
              <description>Divider X Enable Control\nRefer to Table 624 UART Baud Rate Equation for more information.\nNote: In IrDA mode, this bit must disable.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Divider X Disabled (the equation of M = 16)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Divider X Enabled (the equation of M = X+1, but DIVIDER_X [27:24] must  = 8)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_IRCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_IRCR</displayName>
          <description>UART IrDA Control Register</description>
          <addressOffset>0x28</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000040</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX_SELECT</name>
              <description>IrDA Receiver/Transmitter Selection Enable Control</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>IrDA Transmitter Disabled and Receiver Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>IrDA Transmitter Enabled and Receiver Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INV_TX</name>
              <description>IrDA Inverse Transmitting Output Signal Control</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>None inverse transmitting signal</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverse transmitting output signal</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INV_RX</name>
              <description>IrDA Inverse Receive Input Signal Control</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>None inverse receiving input signal</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverse receiving input signal</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_ALT_CSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_ALT_CSR</displayName>
          <description>UART Alternate Control/Status Register</description>
          <addressOffset>0x2C</addressOffset>
          <access>read-write</access>
          <resetValue>0x0000000C</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LIN_BKFL</name>
              <description>UART LIN Break Field Length (Available In UART0/UART1/UART2)\nThis field indicates a 4-bit LIN TX break field count.\nNote1: This break field length is LIN_BKFL + 1.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_RX_EN</name>
              <description>LIN RX Enable Control (Available In UART0/UART1/UART2)</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN RX mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN RX mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_TX_EN</name>
              <description>LIN TX Break Mode Enable Control (Available In UART0/UART1/UART2)\nNote: When TX break field transfer operation finished, this bit will be cleared automatically.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN TX Break mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN TX Break mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS485_NMM</name>
              <description>RS-485 Normal Multi-Drop Operation Mode (NMM) (Available In UART0/UART1)\nNote: It cannot be active with RS-485_AAD operation mode.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RS-485 Normal Multi-drop Operation mode (NMM) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RS-485 Normal Multi-drop Operation mode (NMM) Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS485_AAD</name>
              <description>RS-485 Auto Address Detection Operation Mode (AAD) (Available In UART0/UART1)\nNote: It cannot be active with RS-485_NMM operation mode.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RS-485 Auto Address Detection Operation mode (AAD) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RS-485 Auto Address Detection Operation mode (AAD) Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS485_AUD</name>
              <description>RS-485 Auto Direction Mode (AUD) (Available In UART0/UART1)\nNote: It can be active with RS-485_AAD or RS-485_NMM operation mode.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RS-485 Auto Direction Operation mode (AUO) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RS-485 Auto Direction Operation mode (AUO) Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS485_ADD_EN</name>
              <description>RS-485 Address Detection Enable Control (Available In UART0/UART1)\nThis bit is used to enable RS-485 Address Detection mode. \nNote: This bit is used for RS-485 any operation mode.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Address detection mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Address detection mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ABRIF</name>
              <description>Auto-Baud Rate Interrupt Flag (Read Only) \nThis bit is set when auto-baud rate detection function finished or the auto-baud rate counter was overflow and if ABRIEN(UART_IEN [18]) is set then the auto-baud rate interrupt will be generated. \nNote: This bit is read only, but it can be cleared by writing '1' to ABRDTOIF (UA_FSR[2]) and ABRDIF(UA_FSR[1]).</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ABRDEN</name>
              <description>Auto-Baud Rate Detect Enable Control\nThis bit is cleared automatically after auto-baud detection is finished.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Auto-baud rate detect function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-baud rate detect function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ABRDBITS</name>
              <description>Auto-Baud Rate Detect Bit Length \nNote: The calculation of bit number includes the START bit.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>1-bit time from Start bit to the 1st rising edge. The input pattern shall be 0x01</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>2-bit time from Start bit to the 1st rising edge. The input pattern shall be 0x02</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>4-bit time from Start bit to the 1st rising edge. The input pattern shall be 0x08</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>8-bit time from Start bit to the 1st rising edge. The input pattern shall be 0x80</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADDR_MATCH</name>
              <description>Address Match Value Register (Available In UART0/UART1)\nThis field contains the RS-485 address match values.\nNote: This field is used for RS-485 auto address detection mode.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_FUN_SEL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_FUN_SEL</displayName>
          <description>UART Function Select Register</description>
          <addressOffset>0x30</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FUN_SEL</name>
              <description>Function Select Enable Control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UART function Enabled</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN function Enabled. (Available in UART0/UART1/UART2)</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>IrDA function Enabled</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>RS-485 function Enabled. (Available in UART0/UART1)</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_LIN_CTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_LIN_CTL</displayName>
          <description>UART LIN Control Register</description>
          <addressOffset>0x34</addressOffset>
          <access>read-write</access>
          <resetValue>0x000C0000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LINS_EN</name>
              <description>LIN Slave Mode Enable Control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN slave mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN slave mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LINS_HDET_EN</name>
              <description>LIN Slave Header Detection Enable Control</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN slave header detection Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN slave header detection Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LINS_ARS_EN</name>
              <description>LIN Slave Automatic Resynchronization Mode Enable Control\nNote2: When operation in Automatic Resynchronization mode, the baud rate setting must be mode2 (BAUD_M1 (UA_BAUD [29]) and BAUD_M0 (UA_BAUD [28]) must be 1).\nNote3: The control and interactions of this field are explained in section 6.11.5.8.4. (Slave mode with automatic resynchronization).</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN automatic resynchronization Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN automatic resynchronization Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LINS_DUM_EN</name>
              <description>LIN Slave Divider Update Method Enable Control\nNote2: This bit used for LIN Slave Automatic Resynchronization mode. (for Non-Automatic Resynchronization mode, this bit should be kept cleared) \nNote3: The control and interactions of this field are explained in section 6.11.5.8.4. (Slave mode with automatic resynchronization).</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UA_BAUD updated is written by software (if no automatic resynchronization update occurs at the same time)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UA_BAUD is updated at the next received character. User must set the bit before checksum reception</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_MUTE_EN</name>
              <description>LIN Mute Mode Enable Control\nNote: The exit from mute mode condition and each control and interactions of this field are explained in (LIN slave mode).</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN mute mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN mute mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_SHD</name>
              <description>LIN TX Send Header Enable Control\nThe LIN TX header can be 'break field' or 'break and sync field' or 'break, sync and frame ID field', it is depend on setting LIN_HEAD_SEL (UA_LIN_CTL[23:22]).\nNote1: These registers are shadow registers of LIN_SHD (UA_ALT_CSR [7]); user can read/write it by setting LIN_SHD (UA_ALT_CSR [7]) or LIN_SHD (UA_LIN_CTL [8]).\nNote2: When transmitter header field (it may be 'break' or 'break + sync' or 'break + sync + frame ID' selected by LIN_HEAD_SEL (UA_LIN_CTL[23:22]) field) transfer operation finished, this bit will be cleared automatically.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Send LIN TX header Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Send LIN TX header Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_IDPEN</name>
              <description>LIN ID Parity Enable Control</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN frame ID parity Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN frame ID parity Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_BKDET_EN</name>
              <description>LIN Break Detection Enable Control</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN break detection Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN break detection Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_RX_DIS</name>
              <description>LIN Receiver Disable Control</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN receiver Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN receiver Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BIT_ERR_EN</name>
              <description>Bit Error Detect Enable Control</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit error detection function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit error detection Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_BKFL</name>
              <description>LIN Break Field Length\nThis field indicates a 4-bit LIN TX break field count.\nNote1: These registers are shadow registers of LIN_BKFL, User can read/write it by setting LIN_BKFL (UA_ALT_CSR[3:0]) or LIN_BKFL (UA_LIN_CTL[19:16].\nNote2: This break field length is LIN_BKFL + 1.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_BS_LEN</name>
              <description>LIN Break/Sync Delimiter Length\n\nNote: This bit used for LIN master to sending header field.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The LIN break/sync delimiter length is 1 bit time</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>The LIN break/sync delimiter length is 2 bit time.\nThe LIN break/sync delimiter length is 3 bit time</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>The LIN break/sync delimiter length is 4 bit time</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_HEAD_SEL</name>
              <description>LIN Header Select</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The LIN header includes 'break field'</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The LIN header includes 'break field' and 'sync field'</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>The LIN header includes 'break field', 'sync field' and 'frame ID field'</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved.</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_PID</name>
              <description>LIN PID Register\nIf the parity generated by hardware, user fill ID0~ID5, (LIN_PID [29:24] )hardware will calculate P0 (LIN_PID[30]) and P1 (LIN_PID[31]), otherwise user must filled frame ID and parity in this field.\n\nNote1: User can fill any 8-bit value to this field and the bit 24 indicates ID0 (LSB first).\nNote2: This field can be used for LIN master mode or slave mode.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_LIN_SR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_LIN_SR</displayName>
          <description>UART LIN Status Register</description>
          <addressOffset>0x38</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LINS_HDET_F</name>
              <description>LIN Slave Header Detection Flag (Read Only)\nThis bit is set by hardware when a LIN header is detected in LIN slave mode and be cleared by writing 1 to it.\nNote3: When enable ID parity check LIN_IDPEN (UA_LIN_CTL [9]), if hardware detect complete header ('break + sync + frame ID'), the LINS_HEDT_F will be set whether the frame ID correct or not.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN header not detected</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN header detected (break + sync + frame ID)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LINS_HERR_F</name>
              <description>LIN Slave Header Error Flag (Read Only)\nThis bit is set by hardware when a LIN header error is detected in LIN slave mode and be cleared by writing 1 to it. The header errors include 'break delimiter is too short (less than 0.5 bit time)', 'frame error in sync field or Identifier field', 'sync field data is not 0x55 in Non-Automatic Resynchronization mode', 'sync field deviation error with Automatic Resynchronization mode', 'sync field measure time-out with Automatic Resynchronization mode' and 'LIN header reception time-out'.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN header error not detected</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN header error detected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LINS_IDPERR_F</name>
              <description>LIN Slave ID Parity Error Flag (Read Only)\nThis bit is set by hardware when receipted frame ID parity is not correct.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receipted frame ID parity is not correct</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LINS_SYNC_F</name>
              <description>LIN Slave Sync Field\nThis bit indicates that the LIN sync field is being analyzed in Automatic Resynchronization mode. When the receiver header have some error been detect, user must reset the internal circuit to re-search new frame header by writing 1 to this bit.\nNote2: This bit is read only, but it can be cleared by writing 1 to it.\nNote3: When writing 1 to it, hardware will reload the initial baud rate and re-search a new frame header.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The current character is not at LIN sync state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The current character is at LIN sync state</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_BKDET_F</name>
              <description>LIN Break Detection Flag (Read Only)\nThis bit is set by hardware when a break is detected and be cleared by writing 1 to it through software.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN break not detected</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN break detected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BIT_ERR_F</name>
              <description>Bit Error Detect Status Flag (Read Only)\nAt TX transfer state, hardware will monitoring the bus state, if the input pin (SIN) state not equals to the output pin (SOUT) state, BIT_ERR_F (UA_LIN_SR[9]) will be set.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>UART2</name>
      <description>UART Register Map</description>
      <groupName>UART</groupName>
      <baseAddress>0x40154000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x10</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x18</offset>
        <size>0x24</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>UA_RBR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_RBR</displayName>
          <description>UART Receive Buffer Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>RBR</name>
              <description>Receive Buffer Register (Read Only)\nBy reading this register, the UART will return the 8-bit data received from RX pin (LSB first).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_THR</name>
          <alternateRegister>UA_RBR</alternateRegister>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_THR</displayName>
          <description>UART Transmit Holding Register</description>
          <addressOffset>0x0</addressOffset>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>THR</name>
              <description>Transmit Holding Register\nBy writing one byte to this register, the data byte will be stored in transmitter FIFO. The UART Controller will send out the data stored in transmitter FIFO top location through the TX pin.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_IER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_IER</displayName>
          <description>UART Interrupt Enable Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDA_IEN</name>
              <description>Receive Data Available Interrupt Enable Control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RDA_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RDA_INT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>THRE_IEN</name>
              <description>Transmit Holding Register Empty Interrupt Enable Control</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>THRE_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>THRE_INT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RLS_IEN</name>
              <description>Receive Line Status Interrupt Enable Control</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RLS_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RLS_INT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODEM_IEN</name>
              <description>Modem Status Interrupt Enable Control (Available In UART0/UART1 Channel)</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>MODEM_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>MODEM_INT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TOUT_IEN</name>
              <description>RX Time-Out Interrupt Enable Control</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TOUT_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TOUT_INT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BUF_ERR_IEN</name>
              <description>Buffer Error Interrupt Enable Control</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>BUF_ERR_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>BUF_ERR_INT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WKCTSIEN</name>
              <description>NCTS Wake-Up Interrupt Enable Control</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>nCTS wake-up system function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Wake-up system function Enabled, when the system is in Power-down mode, an external nCTS change will wake-up system from Power-down mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_IEN</name>
              <description>LIN Bus Interrupt Enable Control\nNote: This field is used for LIN function mode.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Lin bus interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Lin bus interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WKDATIEN</name>
              <description>Incoming Data Wake-Up Interrupt Enable Control\nNote: Hardware will clear this bit when the incoming data wake-up operation finishes and 'system clock' work stable.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Incoming data wake-up system function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Incoming data wake-up system function Enabled, when the system is in Power-down mode, incoming data will wake-up system from Power-down mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TIME_OUT_EN</name>
              <description>Time-Out Counter Enable Control</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Time-out counter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time-out counter Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTO_RTS_EN</name>
              <description>RTS Auto Flow Control Enable Control ( Available In UART0/UART1 Channel)\nWhen RTS auto-flow is enabled, if the number of bytes in the RX FIFO equals the RTS_TRI_LEV (UA_FCR [19:16]), the UART will de-assert RTS signal.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTS auto flow control Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTS auto flow control Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTO_CTS_EN</name>
              <description>CTS Auto Flow Control Enable Control (Available In UART0/UART1 Channel)\nWhen CTS auto-flow is enabled, the UART will send data to external device when CTS input assert (UART will not send data to device until CTS is asserted).</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>CTS auto flow control Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CTS auto flow control Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ABRIEN</name>
              <description>Auto-Baud Rate Interrupt Enable Control</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Auto-baud rate interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-baud rate interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_FCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_FCR</displayName>
          <description>UART FIFO Control Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000101</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RFR</name>
              <description>RX Field Software Reset\nWhen RFR is set, all the byte in the receiver FIFO /receive buffer and RX internal state machine are cleared.\nNote: This bit will automatically clear at least 3 UART peripherial clock cycles.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the RX internal state machine and pointers</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TFR</name>
              <description>TX Field Software Reset\nWhen TFR is set, all the byte in the transmit FIFO/ transmit buffer and TX internal state machine are cleared.\nNote: This bit will automatically clear at least 3 UART peripherial clock cycles.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the TX internal state machine and pointers</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RFITL</name>
              <description>RX FIFO Interrupt (INT_RDA) Trigger Level (Available In UART0/UART1/UART2 Channel)\nWhen the number of bytes in the receive FIFO equals the RFITL, the RDA_IF will be set (if UA_IER [RDA_IEN] enabled, and an interrupt will be generated).</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX FIFO Interrupt Trigger Level is 1 byte.\nRX Buffer Interrupt Trigger Level is 1 byte</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX FIFO Interrupt Trigger Level is 4 bytes</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>RX FIFO Interrupt Trigger Level is 8 bytes</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>RX FIFO Interrupt Trigger Level is 14 bytes</description>
                    <value>#0011</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_DIS</name>
              <description>Receiver Disable Control\nThe receiver is disabled or not (set 1 to disable receiver).\nNote: This field is used for RS-485 Normal Multi-drop mode. It should be programmed before RS-485_NMM (UA_ALT_CSR[8]) is programmed.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receiver Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receiver Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RTS_TRI_LEV</name>
              <description>RTS Trigger Level For Auto-Flow Control Use (Available In UART0/UART1 Channel)\nNote: This field is used for RTS auto-flow control.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTS Trigger Level is 1 byte</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTS Trigger Level is 4 bytes</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>RTS Trigger Level is 8 bytes</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>RTS Trigger Level is 14 bytes</description>
                    <value>#0011</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_LCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_LCR</displayName>
          <description>UART Line Control Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WLS</name>
              <description>Word Length Selection</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Word length is 5-bit</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Word length is 6-bit</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Word length is 7-bit</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Word length is 8-bit</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>NSB</name>
              <description>Number Of 'STOP Bit'</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One ' STOP bit' is generated in the transmitted data</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When select 5-bit word length, 1.5 'STOP bit' is generated in the transmitted data. When select 6-,7- and 8-bti word length, 2 'STOP bit' is generated in the transmitted data</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PBE</name>
              <description>Parity Bit Enable Control</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No parity bit</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Parity bit is generated on each outgoing character and is checked on each incoming data</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EPE</name>
              <description>Even Parity Enable Control\nThis bit has effect only when PBE (UA_LCR[3]) is set.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Odd number of logic 1's is transmitted and checked in each word</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Even number of logic 1's is transmitted and checked in each word</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPE</name>
              <description>Stick Parity Enable Control</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Stick parity Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>If PBE (UA_LCR[3]) and EBE (UA_LCR[4]) are logic 1, the parity bit is transmitted and checked as logic 0. If PBE (UA_LCR[3]) is 1 and EBE (UA_LCR[4]) is 0 then the parity bit is transmitted and checked as 1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BCB</name>
              <description>Break Control Bit\nWhen this bit is set to logic 1, the serial data output (TX) is forced to the Spacing State (logic 0). This bit acts only on TX and has no effect on the transmitter logic.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_FSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_FSR</displayName>
          <description>UART FIFO Status Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x10404000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX_OVER_IF</name>
              <description>RX Overflow Error IF (Read Only)\nThis bit is set when RX FIFO overflow. \nIf the number of bytes of received data is greater than RX_FIFO (UA_RBR) size, 16 bytes of UART0/UART1/UART2, this bit will be set.\nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX FIFO is not overflow.\nRX Buffer is not overflow</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX FIFO is overflow.\nRX Buffer is overflow</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>ABRDIF</name>
              <description>Auto-Baud Rate Detect Interrupt (Read Only) \nThis bit is set to logic '1' when auto-baud rate detect function is finished. \nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Auto-baud rate detect function is not finished</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-baud rate detect function is finished</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>ABRDTOIF</name>
              <description>Auto-Baud Rate Time-Out Interrupt (Read Only) \nNote1: This bit is set to logic '1' in Auto-baud Rate Detect mode and the baud rate counter is overflow.\nNote2: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Auto-baud rate counter is underflow</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-baud rate counter is overflow</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RS485_ADD_DETF</name>
              <description>RS-485 Address Byte Detection Flag (Read Only) (Available In UART0/UART1)\nNote1: This field is used for RS-485 function mode and RS485_ADD_EN (UA_ALT_CSR[15]) is set to 1 to enable Address detection mode.\nNote2: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receiver detects a data that is not an address bit (bit 9 ='1')</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receiver detects a data that is an address bit (bit 9 ='1')</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>PEF</name>
              <description>Parity Error Flag (Read Only)\nThis bit is set to logic 1 whenever the received character does not have a valid 'parity bit', and is reset whenever the CPU writes 1 to this bit.\nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No parity error is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Parity error is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>FEF</name>
              <description>Framing Error Flag (Read Only)\nThis bit is set to logic 1 whenever the received character does not have a valid 'stop bit' (that is, the stop bit following the last data bit or parity bit is detected as logic 0), and is reset whenever the CPU writes 1 to this bit.\nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No framing error is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Framing error is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BIF</name>
              <description>Break Interrupt Flag (Read Only)\nThis bit is set to logic 1 whenever the received data input(RX) is held in the 'spacing state' (logic 0) for longer than a full word transmission time (that is, the total time of 'start bit' + data bits + parity + stop bits) and is reset whenever the CPU writes 1 to this bit.\nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Break interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Break interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_POINTER</name>
              <description>RX FIFO Pointer (Read Only)\nThis field indicates the RX FIFO Buffer Pointer. When UART receives one byte from external device, then RX_POINTER increases one. When one byte of RX FIFO is read by CPU, then RX_POINTER decreases one.\nThe Maximum value shown in RX_POINTER is 15 (UART0/UART1/UART2). When the using level of RX FIFO Buffer equal to 16, the RX_FULL bit is set to 1 and RX_POINTER will show 0. As one byte of RX FIFO is read by CPU, the RX_FULL bit is cleared to 0 and RX_POINTER will show 15 (UART0/UART1/UART2).\nWhen RX Buffer is equal to 1, if one byte data is received, the RX_FULL bit is set to 1 and RX_POINTER will show 1. Once the RX Buffer is read, the RX_POINTER is 0.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_EMPTY</name>
              <description>Receiver FIFO Empty (Read Only)\nThis bit initiate RX FIFO empty or not. (UART0/UART1/UART2)\nNote: When the last byte of RX Buffer has been read by CPU, hardware sets this bit high. It will be cleared when UART receives any new data.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX FIFO is not empty.\nRX Buffer is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX FIFO is empty.\nRX Buffer is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_FULL</name>
              <description>Receiver FIFO Full (Read Only)\nThis bit initiates RX FIFO is full or not (UART0/UART1/UART2). \nNote: This bit is set when the number of usage in RX Buffer is equal to 1 (UART3/UART4/UART5), otherwise is cleared by hardware.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX FIFO is not full.\nRX buffer is not full</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX FIFO is full.\nRX bufferis full</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_POINTER</name>
              <description>TX FIFO Pointer (Read Only)\nThis field indicates the TX FIFO Buffer Pointer. When CPU writes one byte into UA_THR, then TX_POINTER increases one. When one byte of TX FIFO is transferred to Transmitter Shift Register, then TX_POINTER decreases one.\nThe Maximum value shown in TX_POINTER is 15 (UART0/UART1/UART2). When the using level of TX FIFO Buffer is equal to 16, the TX_FULL bit is set to 1 and TX_POINTER will show 0. As one byte of TX FIFO is transferred to Transmitter Shift Register, the TX_FULL bit is cleared to 0 and TX_POINTER will show 15  (UART0/UART1/UART2).\nTX_POINTER is 0 (UART3/URT4/UART5).\nWhen TX Buffer is equal to 1, if one byte data is received, the TX_FULL bit is set to 1 and TX_POINTER will show 1. Once the TX Buffer is read, the TX_POINTER is 0.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_EMPTY</name>
              <description>Transmitter FIFO Empty (Read Only)\nThis bit indicates TX FIFO empty or not. (UART0/UART1/UART2)\nNote: When the last byte of TX Buffer has been transferred to Transmitter Shift Register, hardware sets this bit high. It will be cleared when writing data into THR (TX FIFO not empty).</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX FIFO is not empty.\nTX Buffer is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX FIFO is empty.\nTX Buffer is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_FULL</name>
              <description>Transmitter FIFO Full (Read Only)\nThis bit indicates TX FIFO is full or not. (UART0/UART1/UART2)\nThis bit is set when the number of usage in TX Buffer is equal to 1 (UART3/UART4/UART5), otherwise is cleared by hardware.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX FIFO is not full.\nTX Buffer is not full</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX FIFO is full.\nTX Buffer is full</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_OVER_IF</name>
              <description>TX Overflow Error Interrupt Flag (Read Only)\nIf TX FIFO (UA_THR) is full, an additional write to UA_THR will cause this bit to logic 1. (UART0/UART1/UART2)\nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX FIFO is not overflow.\nTX Buffer is not overflow</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX FIFO is overflow.\nTX Buffer is overflow</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TE_FLAG</name>
              <description>Transmitter Empty Flag (Read Only)\nThis bit is set by hardware when TX FIFO (UA_THR) is empty and the STOP bit of the last byte has been transmitted. (UART0/UART1/UART2)\nNote: This bit is cleared automatically when TX FIFO/TX Buffer is not empty or the last byte transmission has not completed.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX FIFO is not empty.\nTX Buffer is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX FIFO is empty.\nTX Buffer is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_ISR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_ISR</displayName>
          <description>UART Interrupt Status Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000002</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDA_IF</name>
              <description>Receive Data Available Interrupt Flag (Read Only)\nWhen the number of bytes in the RX FIFO (UART0/UART1/UART2) / RX Buffer (UART3/UART4/UART5) equals the RFITL then the RDA_IF(UA_ISR[0]) will be set. If RDA_IEN (UA_IER [0]) is enabled, the RDA interrupt will be generated.\nNote: This bit is read only and it will be cleared when the number of unread bytes of RX FIFO drops below the threshold level (RFITL(UA_FCR[7:4]).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RDA interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RDA interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>THRE_IF</name>
              <description>Transmit Holding Register Empty Interrupt Flag (Read Only) \nThis bit is set when the last data of TX FIFO (UART0/UART1/UART2) / TX Buffer (UART3/UART4/UART5) is transferred to Transmitter Shift Register. If THRE_IEN (UA_IER[1]) is enabled, the THRE interrupt will be generated.\nNote: This bit is read only and it will be cleared when writing data into THR (TX FIFO not empty).</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No THRE interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>THRE interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RLS_IF</name>
              <description>Receive Line Interrupt Flag (Read Only)  \nThis bit is set when the RX receive data have parity error, frame error or break error (at least one of 3 bits, BIF(UA_FSR[6]), FEF(UA_FSR[5]) and PEF(UA_FSR[4]), is set). If RLS_IEN (UA_IER [2]) is enabled, the RLS interrupt will be generated.\nNote2: This bit is read only and reset to 0 when all bits of BIF(UA_FSR[6]), FEF(UA_FSR[5]) and PEF(UA_FSR[4]) are cleared.\nNote3: In RS-485 function mode, this bit is read only and reset to 0 when all bits of BIF(UA_FSR[6]) , FEF(UA_FSR[5]) and PEF(UA_FSR[4]) and RS485_ADD_DETF (UA_FSR[3]) are cleared.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RLS interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RLS interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>MODEM_IF</name>
              <description>MODEM Interrupt Flag (Read Only) (Not Available In UART2 Channel)\nNote: This bit is read only and reset to 0 when bit DCTSF is cleared by a write 1 on DCTSF(UA_MSR[0]).</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Modem interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Modem interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TOUT_IF</name>
              <description>Time-Out Interrupt Flag (Read Only)\nThis bit is set when the RX FIFO (UART0/UART1/UART2) / RX Buffer (UART3/UART4/UART5) is not empty and no activities occurred in the RX FIFO and the time-out counter equal to TOIC. If TOUT_IEN (UA_IER [4]) is enabled, the Tout interrupt will be generated.\nNote: This bit is read only and user can read UA_RBR (RX is in active) to clear it.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Time-out interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time-out interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BUF_ERR_IF</name>
              <description>Buffer Error Interrupt Flag (Read Only)\nThis bit is set when the TX FIFO (UART0/UART1/UART2) / TX Buffer (UART3/UART4/UART5) or RX FIFO (UART0/UART1/UART2)/ RX Buffer (UART3/UART4/UART5) overflows (TX_OVER_IF (UA_FSR[24]) or RX_OVER_IF (UA_FSR[0]) is set). When BUF_ERR_IF (UA_ISR[5]) is set, the transfer is not correct. If BUF_ERR_IEN (UA_IER [8]) is enabled, the buffer error interrupt will be generated.\nNote: This bit is read only and reset to 0 when all bits of TX_OVER_IF(UA_FSR[24]) and RX_OVER_IF(UA_FSR[0]) are cleared.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No buffer error interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Buffer error interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>WKIF</name>
              <description>UART Wake-Up Flag (Read Only)\nThis bit is set when DATWKIF (UART_INTSTS[17]) or CTSWKIF(UART_INTSTS[16]) is set to 1.\nNote: This bit is read only. This bit is cleared if both of DATWKIF (UART_INTSTS[17]) and CTSWKIF (UART_INTSTS[16]) are cleared to 0 by writing 1 to DATWKIF (UART_INTSTS[17])  and CTSWKIF (UART_INTSTS[17]).</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No DATWKIF and CTSWKIF are generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>DATWKIF or CTSWKIF</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LIN_IF</name>
              <description>LIN Bus Flag (Read Only)(UART0/UARt1/UART2)\nNote: This bit is read only. This bit is cleared when LINS_HDET_F (UA_LIN_SR[0]), LIN_BKDET_F (UA_LIN_SR[9]), BIT_ERR_F (UA_LIN_SR[9]), LINS_IDPENR_F (UA_LIN_SR[2]) and LINS_HERR_F (UA_LIN_SR[1]) all are cleared.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>None of LINS_HDET_F, LIN_BKDET_F, BIT_ERR_F, LINS_IDPERR_F and LINS_HERR_F is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>At least one of LINS_HDET_F, LIN_BKDET_F, BIT_ERR_F, LINS_IDPERR_F and LINS_HERR_F is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RDA_INT</name>
              <description>Receive Data Available Interrupt Indicator (Read Only)\nThis bit is set if RDA_IEN (UA_IER[0]) and RDA_IF (UA_ISR[0]) are both set to 1.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RDA interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RDA interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>THRE_INT</name>
              <description>Transmit Holding Register Empty Interrupt Indicator (Read Only)\nThis bit is set if THRE_IEN (UA_IER[1])and THRE_IF(UA_SR[1]) are both set to 1.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No THRE interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>THRE interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RLS_INT</name>
              <description>Receive Line Status Interrupt Indicator (Read Only) \nThis bit is set if RLS_IEN (UA_IER[2]) and RLS_IF(UA_ISR[2]) are both set to 1.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RLS interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RLS interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>MODEM_INT</name>
              <description>MODEM Status Interrupt Indicator (Read Only) (Available In UART0/UART1 Channel)\nThis bit is set if MODEM_IEN(UA_IER[3] and MODEM_IF(UA_ISR[4]) are both set to 1</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Modem interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Modem interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TOUT_INT</name>
              <description>Time-Out Interrupt Indicator (Read Only)\nThis bit is set if TOUT_IEN(UA_IER[4]) and TOUT_IF(UA_ISR[4]) are both set to 1.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Tout interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Tout interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BUF_ERR_INT</name>
              <description>Buffer Error Interrupt Indicator (Read Only)\nThis bit is set if BUF_ERR_IEN(UA_IER[5] and BUF_ERR_IF(UA_ISR[5]) are both set to 1.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No buffer error interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Buffer error interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LIN_INT</name>
              <description>LIN Bus Interrupt Indicator (Read Only)\nThis bit is set if LIN_IEN (UA_IER[8]) and LIN _IF(UA_ISR[7]) are both set to 1.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No LIN Bus interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The LIN Bus interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>CTSWKIF</name>
              <description>NCTS Wake-Up Interrupt Flag (Read Only)\nNote1: If WKCTSIEN (UA_IER[6])is enabled, the wake-up interrupt is generated.\nNote2: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Chip stays in power-down state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Chip wake-up from power-down state by nCTS wake-up</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>DATWKIF</name>
              <description>Data Wake-Up Interrupt Flag (Read Only)\nThis bit is set if chip wake-up from power-down state by data wake-up.\nNote1: If WKDATIEN (UA_IER[10]) is enabled, the wake-up interrupt is generated.\nNote2: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Chip stays in power-down state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Chip wake-up from power-down state by data wake-up</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_TOR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_TOR</displayName>
          <description>UART Time-out Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TOIC</name>
              <description>Time-Out Interrupt Comparator</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DLY</name>
              <description>TX Delay Time Value \nThis field is used to programming the transfer delay time between the last stop bit and next start bit.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_BAUD</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_BAUD</displayName>
          <description>UART Baud Rate Divisor Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x0F000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BRD</name>
              <description>Baud Rate Divider\nThe field indicates the baud rate divider.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIVIDER_X</name>
              <description>Divider X</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIV_X_ONE</name>
              <description>Divider X Equal To 1\nRefer to Table 624 UART Baud Rate Equation for more information.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Divider M = X (the equation of M = X+1, but DIVIDER_X[27:24] must  = 8)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Divider M = 1 (the equation of M = 1, but BRD [15:0] must  = 3)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DIV_X_EN</name>
              <description>Divider X Enable Control\nRefer to Table 624 UART Baud Rate Equation for more information.\nNote: In IrDA mode, this bit must disable.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Divider X Disabled (the equation of M = 16)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Divider X Enabled (the equation of M = X+1, but DIVIDER_X [27:24] must  = 8)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_IRCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_IRCR</displayName>
          <description>UART IrDA Control Register</description>
          <addressOffset>0x28</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000040</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX_SELECT</name>
              <description>IrDA Receiver/Transmitter Selection Enable Control</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>IrDA Transmitter Disabled and Receiver Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>IrDA Transmitter Enabled and Receiver Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INV_TX</name>
              <description>IrDA Inverse Transmitting Output Signal Control</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>None inverse transmitting signal</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverse transmitting output signal</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INV_RX</name>
              <description>IrDA Inverse Receive Input Signal Control</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>None inverse receiving input signal</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverse receiving input signal</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_ALT_CSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_ALT_CSR</displayName>
          <description>UART Alternate Control/Status Register</description>
          <addressOffset>0x2C</addressOffset>
          <access>read-write</access>
          <resetValue>0x0000000C</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LIN_BKFL</name>
              <description>UART LIN Break Field Length (Available In UART0/UART1/UART2)\nThis field indicates a 4-bit LIN TX break field count.\nNote1: This break field length is LIN_BKFL + 1.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_RX_EN</name>
              <description>LIN RX Enable Control (Available In UART0/UART1/UART2)</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN RX mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN RX mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_TX_EN</name>
              <description>LIN TX Break Mode Enable Control (Available In UART0/UART1/UART2)\nNote: When TX break field transfer operation finished, this bit will be cleared automatically.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN TX Break mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN TX Break mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS485_NMM</name>
              <description>RS-485 Normal Multi-Drop Operation Mode (NMM) (Available In UART0/UART1)\nNote: It cannot be active with RS-485_AAD operation mode.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RS-485 Normal Multi-drop Operation mode (NMM) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RS-485 Normal Multi-drop Operation mode (NMM) Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS485_AAD</name>
              <description>RS-485 Auto Address Detection Operation Mode (AAD) (Available In UART0/UART1)\nNote: It cannot be active with RS-485_NMM operation mode.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RS-485 Auto Address Detection Operation mode (AAD) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RS-485 Auto Address Detection Operation mode (AAD) Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS485_AUD</name>
              <description>RS-485 Auto Direction Mode (AUD) (Available In UART0/UART1)\nNote: It can be active with RS-485_AAD or RS-485_NMM operation mode.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RS-485 Auto Direction Operation mode (AUO) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RS-485 Auto Direction Operation mode (AUO) Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS485_ADD_EN</name>
              <description>RS-485 Address Detection Enable Control (Available In UART0/UART1)\nThis bit is used to enable RS-485 Address Detection mode. \nNote: This bit is used for RS-485 any operation mode.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Address detection mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Address detection mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ABRIF</name>
              <description>Auto-Baud Rate Interrupt Flag (Read Only) \nThis bit is set when auto-baud rate detection function finished or the auto-baud rate counter was overflow and if ABRIEN(UART_IEN [18]) is set then the auto-baud rate interrupt will be generated. \nNote: This bit is read only, but it can be cleared by writing '1' to ABRDTOIF (UA_FSR[2]) and ABRDIF(UA_FSR[1]).</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ABRDEN</name>
              <description>Auto-Baud Rate Detect Enable Control\nThis bit is cleared automatically after auto-baud detection is finished.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Auto-baud rate detect function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-baud rate detect function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ABRDBITS</name>
              <description>Auto-Baud Rate Detect Bit Length \nNote: The calculation of bit number includes the START bit.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>1-bit time from Start bit to the 1st rising edge. The input pattern shall be 0x01</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>2-bit time from Start bit to the 1st rising edge. The input pattern shall be 0x02</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>4-bit time from Start bit to the 1st rising edge. The input pattern shall be 0x08</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>8-bit time from Start bit to the 1st rising edge. The input pattern shall be 0x80</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADDR_MATCH</name>
              <description>Address Match Value Register (Available In UART0/UART1)\nThis field contains the RS-485 address match values.\nNote: This field is used for RS-485 auto address detection mode.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_FUN_SEL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_FUN_SEL</displayName>
          <description>UART Function Select Register</description>
          <addressOffset>0x30</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FUN_SEL</name>
              <description>Function Select Enable Control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UART function Enabled</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN function Enabled. (Available in UART0/UART1/UART2)</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>IrDA function Enabled</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>RS-485 function Enabled. (Available in UART0/UART1)</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_LIN_CTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_LIN_CTL</displayName>
          <description>UART LIN Control Register</description>
          <addressOffset>0x34</addressOffset>
          <access>read-write</access>
          <resetValue>0x000C0000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LINS_EN</name>
              <description>LIN Slave Mode Enable Control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN slave mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN slave mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LINS_HDET_EN</name>
              <description>LIN Slave Header Detection Enable Control</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN slave header detection Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN slave header detection Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LINS_ARS_EN</name>
              <description>LIN Slave Automatic Resynchronization Mode Enable Control\nNote2: When operation in Automatic Resynchronization mode, the baud rate setting must be mode2 (BAUD_M1 (UA_BAUD [29]) and BAUD_M0 (UA_BAUD [28]) must be 1).\nNote3: The control and interactions of this field are explained in section 6.11.5.8.4. (Slave mode with automatic resynchronization).</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN automatic resynchronization Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN automatic resynchronization Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LINS_DUM_EN</name>
              <description>LIN Slave Divider Update Method Enable Control\nNote2: This bit used for LIN Slave Automatic Resynchronization mode. (for Non-Automatic Resynchronization mode, this bit should be kept cleared) \nNote3: The control and interactions of this field are explained in section 6.11.5.8.4. (Slave mode with automatic resynchronization).</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UA_BAUD updated is written by software (if no automatic resynchronization update occurs at the same time)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UA_BAUD is updated at the next received character. User must set the bit before checksum reception</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_MUTE_EN</name>
              <description>LIN Mute Mode Enable Control\nNote: The exit from mute mode condition and each control and interactions of this field are explained in (LIN slave mode).</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN mute mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN mute mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_SHD</name>
              <description>LIN TX Send Header Enable Control\nThe LIN TX header can be 'break field' or 'break and sync field' or 'break, sync and frame ID field', it is depend on setting LIN_HEAD_SEL (UA_LIN_CTL[23:22]).\nNote1: These registers are shadow registers of LIN_SHD (UA_ALT_CSR [7]); user can read/write it by setting LIN_SHD (UA_ALT_CSR [7]) or LIN_SHD (UA_LIN_CTL [8]).\nNote2: When transmitter header field (it may be 'break' or 'break + sync' or 'break + sync + frame ID' selected by LIN_HEAD_SEL (UA_LIN_CTL[23:22]) field) transfer operation finished, this bit will be cleared automatically.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Send LIN TX header Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Send LIN TX header Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_IDPEN</name>
              <description>LIN ID Parity Enable Control</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN frame ID parity Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN frame ID parity Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_BKDET_EN</name>
              <description>LIN Break Detection Enable Control</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN break detection Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN break detection Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_RX_DIS</name>
              <description>LIN Receiver Disable Control</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN receiver Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN receiver Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BIT_ERR_EN</name>
              <description>Bit Error Detect Enable Control</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit error detection function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit error detection Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_BKFL</name>
              <description>LIN Break Field Length\nThis field indicates a 4-bit LIN TX break field count.\nNote1: These registers are shadow registers of LIN_BKFL, User can read/write it by setting LIN_BKFL (UA_ALT_CSR[3:0]) or LIN_BKFL (UA_LIN_CTL[19:16].\nNote2: This break field length is LIN_BKFL + 1.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_BS_LEN</name>
              <description>LIN Break/Sync Delimiter Length\n\nNote: This bit used for LIN master to sending header field.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The LIN break/sync delimiter length is 1 bit time</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>The LIN break/sync delimiter length is 2 bit time.\nThe LIN break/sync delimiter length is 3 bit time</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>The LIN break/sync delimiter length is 4 bit time</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_HEAD_SEL</name>
              <description>LIN Header Select</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The LIN header includes 'break field'</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The LIN header includes 'break field' and 'sync field'</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>The LIN header includes 'break field', 'sync field' and 'frame ID field'</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved.</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_PID</name>
              <description>LIN PID Register\nIf the parity generated by hardware, user fill ID0~ID5, (LIN_PID [29:24] )hardware will calculate P0 (LIN_PID[30]) and P1 (LIN_PID[31]), otherwise user must filled frame ID and parity in this field.\n\nNote1: User can fill any 8-bit value to this field and the bit 24 indicates ID0 (LSB first).\nNote2: This field can be used for LIN master mode or slave mode.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_LIN_SR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_LIN_SR</displayName>
          <description>UART LIN Status Register</description>
          <addressOffset>0x38</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LINS_HDET_F</name>
              <description>LIN Slave Header Detection Flag (Read Only)\nThis bit is set by hardware when a LIN header is detected in LIN slave mode and be cleared by writing 1 to it.\nNote3: When enable ID parity check LIN_IDPEN (UA_LIN_CTL [9]), if hardware detect complete header ('break + sync + frame ID'), the LINS_HEDT_F will be set whether the frame ID correct or not.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN header not detected</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN header detected (break + sync + frame ID)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LINS_HERR_F</name>
              <description>LIN Slave Header Error Flag (Read Only)\nThis bit is set by hardware when a LIN header error is detected in LIN slave mode and be cleared by writing 1 to it. The header errors include 'break delimiter is too short (less than 0.5 bit time)', 'frame error in sync field or Identifier field', 'sync field data is not 0x55 in Non-Automatic Resynchronization mode', 'sync field deviation error with Automatic Resynchronization mode', 'sync field measure time-out with Automatic Resynchronization mode' and 'LIN header reception time-out'.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN header error not detected</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN header error detected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LINS_IDPERR_F</name>
              <description>LIN Slave ID Parity Error Flag (Read Only)\nThis bit is set by hardware when receipted frame ID parity is not correct.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receipted frame ID parity is not correct</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LINS_SYNC_F</name>
              <description>LIN Slave Sync Field\nThis bit indicates that the LIN sync field is being analyzed in Automatic Resynchronization mode. When the receiver header have some error been detect, user must reset the internal circuit to re-search new frame header by writing 1 to this bit.\nNote2: This bit is read only, but it can be cleared by writing 1 to it.\nNote3: When writing 1 to it, hardware will reload the initial baud rate and re-search a new frame header.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The current character is not at LIN sync state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The current character is at LIN sync state</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_BKDET_F</name>
              <description>LIN Break Detection Flag (Read Only)\nThis bit is set by hardware when a break is detected and be cleared by writing 1 to it through software.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN break not detected</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN break detected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BIT_ERR_F</name>
              <description>Bit Error Detect Status Flag (Read Only)\nAt TX transfer state, hardware will monitoring the bus state, if the input pin (SIN) state not equals to the output pin (SOUT) state, BIT_ERR_F (UA_LIN_SR[9]) will be set.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>UART3</name>
      <description>UART Register Map</description>
      <groupName>UART</groupName>
      <baseAddress>0x40054000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x10</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x18</offset>
        <size>0x1C</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>UA_RBR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_RBR</displayName>
          <description>UART Receive Buffer Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>RBR</name>
              <description>Receive Buffer Register (Read Only)\nBy reading this register, the UART will return the 8-bit data received from RX pin (LSB first).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_THR</name>
          <alternateRegister>UA_RBR</alternateRegister>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_THR</displayName>
          <description>UART Transmit Holding Register</description>
          <addressOffset>0x0</addressOffset>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>THR</name>
              <description>Transmit Holding Register\nBy writing one byte to this register, the data byte will be stored in transmitter FIFO. The UART Controller will send out the data stored in transmitter FIFO top location through the TX pin.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_IER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_IER</displayName>
          <description>UART Interrupt Enable Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDA_IEN</name>
              <description>Receive Data Available Interrupt Enable Control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RDA_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RDA_INT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>THRE_IEN</name>
              <description>Transmit Holding Register Empty Interrupt Enable Control</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>THRE_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>THRE_INT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RLS_IEN</name>
              <description>Receive Line Status Interrupt Enable Control</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RLS_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RLS_INT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODEM_IEN</name>
              <description>Modem Status Interrupt Enable Control (Available In UART0/UART1 Channel)</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>MODEM_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>MODEM_INT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TOUT_IEN</name>
              <description>RX Time-Out Interrupt Enable Control</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TOUT_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TOUT_INT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BUF_ERR_IEN</name>
              <description>Buffer Error Interrupt Enable Control</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>BUF_ERR_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>BUF_ERR_INT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WKCTSIEN</name>
              <description>NCTS Wake-Up Interrupt Enable Control</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>nCTS wake-up system function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Wake-up system function Enabled, when the system is in Power-down mode, an external nCTS change will wake-up system from Power-down mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_IEN</name>
              <description>LIN Bus Interrupt Enable Control\nNote: This field is used for LIN function mode.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Lin bus interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Lin bus interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WKDATIEN</name>
              <description>Incoming Data Wake-Up Interrupt Enable Control\nNote: Hardware will clear this bit when the incoming data wake-up operation finishes and 'system clock' work stable.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Incoming data wake-up system function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Incoming data wake-up system function Enabled, when the system is in Power-down mode, incoming data will wake-up system from Power-down mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TIME_OUT_EN</name>
              <description>Time-Out Counter Enable Control</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Time-out counter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time-out counter Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTO_RTS_EN</name>
              <description>RTS Auto Flow Control Enable Control ( Available In UART0/UART1 Channel)\nWhen RTS auto-flow is enabled, if the number of bytes in the RX FIFO equals the RTS_TRI_LEV (UA_FCR [19:16]), the UART will de-assert RTS signal.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTS auto flow control Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTS auto flow control Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTO_CTS_EN</name>
              <description>CTS Auto Flow Control Enable Control (Available In UART0/UART1 Channel)\nWhen CTS auto-flow is enabled, the UART will send data to external device when CTS input assert (UART will not send data to device until CTS is asserted).</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>CTS auto flow control Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CTS auto flow control Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ABRIEN</name>
              <description>Auto-Baud Rate Interrupt Enable Control</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Auto-baud rate interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-baud rate interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_FCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_FCR</displayName>
          <description>UART FIFO Control Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000101</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RFR</name>
              <description>RX Field Software Reset\nWhen RFR is set, all the byte in the receiver FIFO /receive buffer and RX internal state machine are cleared.\nNote: This bit will automatically clear at least 3 UART peripherial clock cycles.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the RX internal state machine and pointers</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TFR</name>
              <description>TX Field Software Reset\nWhen TFR is set, all the byte in the transmit FIFO/ transmit buffer and TX internal state machine are cleared.\nNote: This bit will automatically clear at least 3 UART peripherial clock cycles.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the TX internal state machine and pointers</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RFITL</name>
              <description>RX FIFO Interrupt (INT_RDA) Trigger Level (Available In UART0/UART1/UART2 Channel)\nWhen the number of bytes in the receive FIFO equals the RFITL, the RDA_IF will be set (if UA_IER [RDA_IEN] enabled, and an interrupt will be generated).</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX FIFO Interrupt Trigger Level is 1 byte.\nRX Buffer Interrupt Trigger Level is 1 byte</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX FIFO Interrupt Trigger Level is 4 bytes</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>RX FIFO Interrupt Trigger Level is 8 bytes</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>RX FIFO Interrupt Trigger Level is 14 bytes</description>
                    <value>#0011</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_DIS</name>
              <description>Receiver Disable Control\nThe receiver is disabled or not (set 1 to disable receiver).\nNote: This field is used for RS-485 Normal Multi-drop mode. It should be programmed before RS-485_NMM (UA_ALT_CSR[8]) is programmed.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receiver Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receiver Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RTS_TRI_LEV</name>
              <description>RTS Trigger Level For Auto-Flow Control Use (Available In UART0/UART1 Channel)\nNote: This field is used for RTS auto-flow control.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTS Trigger Level is 1 byte</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTS Trigger Level is 4 bytes</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>RTS Trigger Level is 8 bytes</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>RTS Trigger Level is 14 bytes</description>
                    <value>#0011</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_LCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_LCR</displayName>
          <description>UART Line Control Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WLS</name>
              <description>Word Length Selection</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Word length is 5-bit</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Word length is 6-bit</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Word length is 7-bit</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Word length is 8-bit</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>NSB</name>
              <description>Number Of 'STOP Bit'</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One ' STOP bit' is generated in the transmitted data</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When select 5-bit word length, 1.5 'STOP bit' is generated in the transmitted data. When select 6-,7- and 8-bti word length, 2 'STOP bit' is generated in the transmitted data</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PBE</name>
              <description>Parity Bit Enable Control</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No parity bit</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Parity bit is generated on each outgoing character and is checked on each incoming data</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EPE</name>
              <description>Even Parity Enable Control\nThis bit has effect only when PBE (UA_LCR[3]) is set.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Odd number of logic 1's is transmitted and checked in each word</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Even number of logic 1's is transmitted and checked in each word</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPE</name>
              <description>Stick Parity Enable Control</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Stick parity Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>If PBE (UA_LCR[3]) and EBE (UA_LCR[4]) are logic 1, the parity bit is transmitted and checked as logic 0. If PBE (UA_LCR[3]) is 1 and EBE (UA_LCR[4]) is 0 then the parity bit is transmitted and checked as 1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BCB</name>
              <description>Break Control Bit\nWhen this bit is set to logic 1, the serial data output (TX) is forced to the Spacing State (logic 0). This bit acts only on TX and has no effect on the transmitter logic.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_FSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_FSR</displayName>
          <description>UART FIFO Status Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x10404000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX_OVER_IF</name>
              <description>RX Overflow Error IF (Read Only)\nThis bit is set when RX FIFO overflow. \nIf the number of bytes of received data is greater than RX_FIFO (UA_RBR) size, 16 bytes of UART0/UART1/UART2, this bit will be set.\nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX FIFO is not overflow.\nRX Buffer is not overflow</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX FIFO is overflow.\nRX Buffer is overflow</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>ABRDIF</name>
              <description>Auto-Baud Rate Detect Interrupt (Read Only) \nThis bit is set to logic '1' when auto-baud rate detect function is finished. \nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Auto-baud rate detect function is not finished</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-baud rate detect function is finished</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>ABRDTOIF</name>
              <description>Auto-Baud Rate Time-Out Interrupt (Read Only) \nNote1: This bit is set to logic '1' in Auto-baud Rate Detect mode and the baud rate counter is overflow.\nNote2: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Auto-baud rate counter is underflow</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-baud rate counter is overflow</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RS485_ADD_DETF</name>
              <description>RS-485 Address Byte Detection Flag (Read Only) (Available In UART0/UART1)\nNote1: This field is used for RS-485 function mode and RS485_ADD_EN (UA_ALT_CSR[15]) is set to 1 to enable Address detection mode.\nNote2: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receiver detects a data that is not an address bit (bit 9 ='1')</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receiver detects a data that is an address bit (bit 9 ='1')</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>PEF</name>
              <description>Parity Error Flag (Read Only)\nThis bit is set to logic 1 whenever the received character does not have a valid 'parity bit', and is reset whenever the CPU writes 1 to this bit.\nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No parity error is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Parity error is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>FEF</name>
              <description>Framing Error Flag (Read Only)\nThis bit is set to logic 1 whenever the received character does not have a valid 'stop bit' (that is, the stop bit following the last data bit or parity bit is detected as logic 0), and is reset whenever the CPU writes 1 to this bit.\nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No framing error is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Framing error is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BIF</name>
              <description>Break Interrupt Flag (Read Only)\nThis bit is set to logic 1 whenever the received data input(RX) is held in the 'spacing state' (logic 0) for longer than a full word transmission time (that is, the total time of 'start bit' + data bits + parity + stop bits) and is reset whenever the CPU writes 1 to this bit.\nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Break interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Break interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_POINTER</name>
              <description>RX FIFO Pointer (Read Only)\nThis field indicates the RX FIFO Buffer Pointer. When UART receives one byte from external device, then RX_POINTER increases one. When one byte of RX FIFO is read by CPU, then RX_POINTER decreases one.\nThe Maximum value shown in RX_POINTER is 15 (UART0/UART1/UART2). When the using level of RX FIFO Buffer equal to 16, the RX_FULL bit is set to 1 and RX_POINTER will show 0. As one byte of RX FIFO is read by CPU, the RX_FULL bit is cleared to 0 and RX_POINTER will show 15 (UART0/UART1/UART2).\nWhen RX Buffer is equal to 1, if one byte data is received, the RX_FULL bit is set to 1 and RX_POINTER will show 1. Once the RX Buffer is read, the RX_POINTER is 0.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_EMPTY</name>
              <description>Receiver FIFO Empty (Read Only)\nThis bit initiate RX FIFO empty or not. (UART0/UART1/UART2)\nNote: When the last byte of RX Buffer has been read by CPU, hardware sets this bit high. It will be cleared when UART receives any new data.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX FIFO is not empty.\nRX Buffer is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX FIFO is empty.\nRX Buffer is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_FULL</name>
              <description>Receiver FIFO Full (Read Only)\nThis bit initiates RX FIFO is full or not (UART0/UART1/UART2). \nNote: This bit is set when the number of usage in RX Buffer is equal to 1 (UART3/UART4/UART5), otherwise is cleared by hardware.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX FIFO is not full.\nRX buffer is not full</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX FIFO is full.\nRX bufferis full</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_POINTER</name>
              <description>TX FIFO Pointer (Read Only)\nThis field indicates the TX FIFO Buffer Pointer. When CPU writes one byte into UA_THR, then TX_POINTER increases one. When one byte of TX FIFO is transferred to Transmitter Shift Register, then TX_POINTER decreases one.\nThe Maximum value shown in TX_POINTER is 15 (UART0/UART1/UART2). When the using level of TX FIFO Buffer is equal to 16, the TX_FULL bit is set to 1 and TX_POINTER will show 0. As one byte of TX FIFO is transferred to Transmitter Shift Register, the TX_FULL bit is cleared to 0 and TX_POINTER will show 15  (UART0/UART1/UART2).\nTX_POINTER is 0 (UART3/URT4/UART5).\nWhen TX Buffer is equal to 1, if one byte data is received, the TX_FULL bit is set to 1 and TX_POINTER will show 1. Once the TX Buffer is read, the TX_POINTER is 0.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_EMPTY</name>
              <description>Transmitter FIFO Empty (Read Only)\nThis bit indicates TX FIFO empty or not. (UART0/UART1/UART2)\nNote: When the last byte of TX Buffer has been transferred to Transmitter Shift Register, hardware sets this bit high. It will be cleared when writing data into THR (TX FIFO not empty).</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX FIFO is not empty.\nTX Buffer is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX FIFO is empty.\nTX Buffer is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_FULL</name>
              <description>Transmitter FIFO Full (Read Only)\nThis bit indicates TX FIFO is full or not. (UART0/UART1/UART2)\nThis bit is set when the number of usage in TX Buffer is equal to 1 (UART3/UART4/UART5), otherwise is cleared by hardware.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX FIFO is not full.\nTX Buffer is not full</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX FIFO is full.\nTX Buffer is full</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_OVER_IF</name>
              <description>TX Overflow Error Interrupt Flag (Read Only)\nIf TX FIFO (UA_THR) is full, an additional write to UA_THR will cause this bit to logic 1. (UART0/UART1/UART2)\nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX FIFO is not overflow.\nTX Buffer is not overflow</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX FIFO is overflow.\nTX Buffer is overflow</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TE_FLAG</name>
              <description>Transmitter Empty Flag (Read Only)\nThis bit is set by hardware when TX FIFO (UA_THR) is empty and the STOP bit of the last byte has been transmitted. (UART0/UART1/UART2)\nNote: This bit is cleared automatically when TX FIFO/TX Buffer is not empty or the last byte transmission has not completed.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX FIFO is not empty.\nTX Buffer is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX FIFO is empty.\nTX Buffer is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_ISR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_ISR</displayName>
          <description>UART Interrupt Status Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000002</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDA_IF</name>
              <description>Receive Data Available Interrupt Flag (Read Only)\nWhen the number of bytes in the RX FIFO (UART0/UART1/UART2) / RX Buffer (UART3/UART4/UART5) equals the RFITL then the RDA_IF(UA_ISR[0]) will be set. If RDA_IEN (UA_IER [0]) is enabled, the RDA interrupt will be generated.\nNote: This bit is read only and it will be cleared when the number of unread bytes of RX FIFO drops below the threshold level (RFITL(UA_FCR[7:4]).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RDA interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RDA interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>THRE_IF</name>
              <description>Transmit Holding Register Empty Interrupt Flag (Read Only) \nThis bit is set when the last data of TX FIFO (UART0/UART1/UART2) / TX Buffer (UART3/UART4/UART5) is transferred to Transmitter Shift Register. If THRE_IEN (UA_IER[1]) is enabled, the THRE interrupt will be generated.\nNote: This bit is read only and it will be cleared when writing data into THR (TX FIFO not empty).</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No THRE interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>THRE interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RLS_IF</name>
              <description>Receive Line Interrupt Flag (Read Only)  \nThis bit is set when the RX receive data have parity error, frame error or break error (at least one of 3 bits, BIF(UA_FSR[6]), FEF(UA_FSR[5]) and PEF(UA_FSR[4]), is set). If RLS_IEN (UA_IER [2]) is enabled, the RLS interrupt will be generated.\nNote2: This bit is read only and reset to 0 when all bits of BIF(UA_FSR[6]), FEF(UA_FSR[5]) and PEF(UA_FSR[4]) are cleared.\nNote3: In RS-485 function mode, this bit is read only and reset to 0 when all bits of BIF(UA_FSR[6]) , FEF(UA_FSR[5]) and PEF(UA_FSR[4]) and RS485_ADD_DETF (UA_FSR[3]) are cleared.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RLS interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RLS interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>MODEM_IF</name>
              <description>MODEM Interrupt Flag (Read Only) (Not Available In UART2 Channel)\nNote: This bit is read only and reset to 0 when bit DCTSF is cleared by a write 1 on DCTSF(UA_MSR[0]).</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Modem interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Modem interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TOUT_IF</name>
              <description>Time-Out Interrupt Flag (Read Only)\nThis bit is set when the RX FIFO (UART0/UART1/UART2) / RX Buffer (UART3/UART4/UART5) is not empty and no activities occurred in the RX FIFO and the time-out counter equal to TOIC. If TOUT_IEN (UA_IER [4]) is enabled, the Tout interrupt will be generated.\nNote: This bit is read only and user can read UA_RBR (RX is in active) to clear it.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Time-out interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time-out interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BUF_ERR_IF</name>
              <description>Buffer Error Interrupt Flag (Read Only)\nThis bit is set when the TX FIFO (UART0/UART1/UART2) / TX Buffer (UART3/UART4/UART5) or RX FIFO (UART0/UART1/UART2)/ RX Buffer (UART3/UART4/UART5) overflows (TX_OVER_IF (UA_FSR[24]) or RX_OVER_IF (UA_FSR[0]) is set). When BUF_ERR_IF (UA_ISR[5]) is set, the transfer is not correct. If BUF_ERR_IEN (UA_IER [8]) is enabled, the buffer error interrupt will be generated.\nNote: This bit is read only and reset to 0 when all bits of TX_OVER_IF(UA_FSR[24]) and RX_OVER_IF(UA_FSR[0]) are cleared.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No buffer error interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Buffer error interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>WKIF</name>
              <description>UART Wake-Up Flag (Read Only)\nThis bit is set when DATWKIF (UART_INTSTS[17]) or CTSWKIF(UART_INTSTS[16]) is set to 1.\nNote: This bit is read only. This bit is cleared if both of DATWKIF (UART_INTSTS[17]) and CTSWKIF (UART_INTSTS[16]) are cleared to 0 by writing 1 to DATWKIF (UART_INTSTS[17])  and CTSWKIF (UART_INTSTS[17]).</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No DATWKIF and CTSWKIF are generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>DATWKIF or CTSWKIF</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LIN_IF</name>
              <description>LIN Bus Flag (Read Only)(UART0/UARt1/UART2)\nNote: This bit is read only. This bit is cleared when LINS_HDET_F (UA_LIN_SR[0]), LIN_BKDET_F (UA_LIN_SR[9]), BIT_ERR_F (UA_LIN_SR[9]), LINS_IDPENR_F (UA_LIN_SR[2]) and LINS_HERR_F (UA_LIN_SR[1]) all are cleared.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>None of LINS_HDET_F, LIN_BKDET_F, BIT_ERR_F, LINS_IDPERR_F and LINS_HERR_F is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>At least one of LINS_HDET_F, LIN_BKDET_F, BIT_ERR_F, LINS_IDPERR_F and LINS_HERR_F is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RDA_INT</name>
              <description>Receive Data Available Interrupt Indicator (Read Only)\nThis bit is set if RDA_IEN (UA_IER[0]) and RDA_IF (UA_ISR[0]) are both set to 1.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RDA interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RDA interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>THRE_INT</name>
              <description>Transmit Holding Register Empty Interrupt Indicator (Read Only)\nThis bit is set if THRE_IEN (UA_IER[1])and THRE_IF(UA_SR[1]) are both set to 1.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No THRE interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>THRE interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RLS_INT</name>
              <description>Receive Line Status Interrupt Indicator (Read Only) \nThis bit is set if RLS_IEN (UA_IER[2]) and RLS_IF(UA_ISR[2]) are both set to 1.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RLS interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RLS interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>MODEM_INT</name>
              <description>MODEM Status Interrupt Indicator (Read Only) (Available In UART0/UART1 Channel)\nThis bit is set if MODEM_IEN(UA_IER[3] and MODEM_IF(UA_ISR[4]) are both set to 1</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Modem interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Modem interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TOUT_INT</name>
              <description>Time-Out Interrupt Indicator (Read Only)\nThis bit is set if TOUT_IEN(UA_IER[4]) and TOUT_IF(UA_ISR[4]) are both set to 1.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Tout interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Tout interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BUF_ERR_INT</name>
              <description>Buffer Error Interrupt Indicator (Read Only)\nThis bit is set if BUF_ERR_IEN(UA_IER[5] and BUF_ERR_IF(UA_ISR[5]) are both set to 1.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No buffer error interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Buffer error interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LIN_INT</name>
              <description>LIN Bus Interrupt Indicator (Read Only)\nThis bit is set if LIN_IEN (UA_IER[8]) and LIN _IF(UA_ISR[7]) are both set to 1.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No LIN Bus interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The LIN Bus interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>CTSWKIF</name>
              <description>NCTS Wake-Up Interrupt Flag (Read Only)\nNote1: If WKCTSIEN (UA_IER[6])is enabled, the wake-up interrupt is generated.\nNote2: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Chip stays in power-down state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Chip wake-up from power-down state by nCTS wake-up</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>DATWKIF</name>
              <description>Data Wake-Up Interrupt Flag (Read Only)\nThis bit is set if chip wake-up from power-down state by data wake-up.\nNote1: If WKDATIEN (UA_IER[10]) is enabled, the wake-up interrupt is generated.\nNote2: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Chip stays in power-down state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Chip wake-up from power-down state by data wake-up</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_TOR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_TOR</displayName>
          <description>UART Time-out Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TOIC</name>
              <description>Time-Out Interrupt Comparator</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DLY</name>
              <description>TX Delay Time Value \nThis field is used to programming the transfer delay time between the last stop bit and next start bit.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_BAUD</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_BAUD</displayName>
          <description>UART Baud Rate Divisor Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x0F000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BRD</name>
              <description>Baud Rate Divider\nThe field indicates the baud rate divider.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIVIDER_X</name>
              <description>Divider X</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIV_X_ONE</name>
              <description>Divider X Equal To 1\nRefer to Table 624 UART Baud Rate Equation for more information.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Divider M = X (the equation of M = X+1, but DIVIDER_X[27:24] must  = 8)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Divider M = 1 (the equation of M = 1, but BRD [15:0] must  = 3)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DIV_X_EN</name>
              <description>Divider X Enable Control\nRefer to Table 624 UART Baud Rate Equation for more information.\nNote: In IrDA mode, this bit must disable.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Divider X Disabled (the equation of M = 16)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Divider X Enabled (the equation of M = X+1, but DIVIDER_X [27:24] must  = 8)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_IRCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_IRCR</displayName>
          <description>UART IrDA Control Register</description>
          <addressOffset>0x28</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000040</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX_SELECT</name>
              <description>IrDA Receiver/Transmitter Selection Enable Control</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>IrDA Transmitter Disabled and Receiver Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>IrDA Transmitter Enabled and Receiver Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INV_TX</name>
              <description>IrDA Inverse Transmitting Output Signal Control</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>None inverse transmitting signal</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverse transmitting output signal</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INV_RX</name>
              <description>IrDA Inverse Receive Input Signal Control</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>None inverse receiving input signal</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverse receiving input signal</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_ALT_CSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_ALT_CSR</displayName>
          <description>UART Alternate Control/Status Register</description>
          <addressOffset>0x2C</addressOffset>
          <access>read-write</access>
          <resetValue>0x0000000C</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LIN_BKFL</name>
              <description>UART LIN Break Field Length (Available In UART0/UART1/UART2)\nThis field indicates a 4-bit LIN TX break field count.\nNote1: This break field length is LIN_BKFL + 1.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_RX_EN</name>
              <description>LIN RX Enable Control (Available In UART0/UART1/UART2)</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN RX mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN RX mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_TX_EN</name>
              <description>LIN TX Break Mode Enable Control (Available In UART0/UART1/UART2)\nNote: When TX break field transfer operation finished, this bit will be cleared automatically.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN TX Break mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN TX Break mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS485_NMM</name>
              <description>RS-485 Normal Multi-Drop Operation Mode (NMM) (Available In UART0/UART1)\nNote: It cannot be active with RS-485_AAD operation mode.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RS-485 Normal Multi-drop Operation mode (NMM) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RS-485 Normal Multi-drop Operation mode (NMM) Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS485_AAD</name>
              <description>RS-485 Auto Address Detection Operation Mode (AAD) (Available In UART0/UART1)\nNote: It cannot be active with RS-485_NMM operation mode.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RS-485 Auto Address Detection Operation mode (AAD) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RS-485 Auto Address Detection Operation mode (AAD) Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS485_AUD</name>
              <description>RS-485 Auto Direction Mode (AUD) (Available In UART0/UART1)\nNote: It can be active with RS-485_AAD or RS-485_NMM operation mode.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RS-485 Auto Direction Operation mode (AUO) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RS-485 Auto Direction Operation mode (AUO) Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS485_ADD_EN</name>
              <description>RS-485 Address Detection Enable Control (Available In UART0/UART1)\nThis bit is used to enable RS-485 Address Detection mode. \nNote: This bit is used for RS-485 any operation mode.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Address detection mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Address detection mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ABRIF</name>
              <description>Auto-Baud Rate Interrupt Flag (Read Only) \nThis bit is set when auto-baud rate detection function finished or the auto-baud rate counter was overflow and if ABRIEN(UART_IEN [18]) is set then the auto-baud rate interrupt will be generated. \nNote: This bit is read only, but it can be cleared by writing '1' to ABRDTOIF (UA_FSR[2]) and ABRDIF(UA_FSR[1]).</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ABRDEN</name>
              <description>Auto-Baud Rate Detect Enable Control\nThis bit is cleared automatically after auto-baud detection is finished.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Auto-baud rate detect function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-baud rate detect function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ABRDBITS</name>
              <description>Auto-Baud Rate Detect Bit Length \nNote: The calculation of bit number includes the START bit.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>1-bit time from Start bit to the 1st rising edge. The input pattern shall be 0x01</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>2-bit time from Start bit to the 1st rising edge. The input pattern shall be 0x02</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>4-bit time from Start bit to the 1st rising edge. The input pattern shall be 0x08</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>8-bit time from Start bit to the 1st rising edge. The input pattern shall be 0x80</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADDR_MATCH</name>
              <description>Address Match Value Register (Available In UART0/UART1)\nThis field contains the RS-485 address match values.\nNote: This field is used for RS-485 auto address detection mode.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_FUN_SEL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_FUN_SEL</displayName>
          <description>UART Function Select Register</description>
          <addressOffset>0x30</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FUN_SEL</name>
              <description>Function Select Enable Control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UART function Enabled</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN function Enabled. (Available in UART0/UART1/UART2)</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>IrDA function Enabled</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>RS-485 function Enabled. (Available in UART0/UART1)</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>UART4</name>
      <description>UART Register Map</description>
      <groupName>UART</groupName>
      <baseAddress>0x40058000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x10</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x18</offset>
        <size>0x1C</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>UA_RBR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_RBR</displayName>
          <description>UART Receive Buffer Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>RBR</name>
              <description>Receive Buffer Register (Read Only)\nBy reading this register, the UART will return the 8-bit data received from RX pin (LSB first).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_THR</name>
          <alternateRegister>UA_RBR</alternateRegister>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_THR</displayName>
          <description>UART Transmit Holding Register</description>
          <addressOffset>0x0</addressOffset>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>THR</name>
              <description>Transmit Holding Register\nBy writing one byte to this register, the data byte will be stored in transmitter FIFO. The UART Controller will send out the data stored in transmitter FIFO top location through the TX pin.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_IER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_IER</displayName>
          <description>UART Interrupt Enable Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDA_IEN</name>
              <description>Receive Data Available Interrupt Enable Control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RDA_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RDA_INT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>THRE_IEN</name>
              <description>Transmit Holding Register Empty Interrupt Enable Control</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>THRE_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>THRE_INT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RLS_IEN</name>
              <description>Receive Line Status Interrupt Enable Control</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RLS_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RLS_INT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODEM_IEN</name>
              <description>Modem Status Interrupt Enable Control (Available In UART0/UART1 Channel)</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>MODEM_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>MODEM_INT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TOUT_IEN</name>
              <description>RX Time-Out Interrupt Enable Control</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TOUT_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TOUT_INT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BUF_ERR_IEN</name>
              <description>Buffer Error Interrupt Enable Control</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>BUF_ERR_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>BUF_ERR_INT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WKCTSIEN</name>
              <description>NCTS Wake-Up Interrupt Enable Control</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>nCTS wake-up system function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Wake-up system function Enabled, when the system is in Power-down mode, an external nCTS change will wake-up system from Power-down mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_IEN</name>
              <description>LIN Bus Interrupt Enable Control\nNote: This field is used for LIN function mode.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Lin bus interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Lin bus interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WKDATIEN</name>
              <description>Incoming Data Wake-Up Interrupt Enable Control\nNote: Hardware will clear this bit when the incoming data wake-up operation finishes and 'system clock' work stable.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Incoming data wake-up system function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Incoming data wake-up system function Enabled, when the system is in Power-down mode, incoming data will wake-up system from Power-down mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TIME_OUT_EN</name>
              <description>Time-Out Counter Enable Control</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Time-out counter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time-out counter Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTO_RTS_EN</name>
              <description>RTS Auto Flow Control Enable Control ( Available In UART0/UART1 Channel)\nWhen RTS auto-flow is enabled, if the number of bytes in the RX FIFO equals the RTS_TRI_LEV (UA_FCR [19:16]), the UART will de-assert RTS signal.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTS auto flow control Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTS auto flow control Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTO_CTS_EN</name>
              <description>CTS Auto Flow Control Enable Control (Available In UART0/UART1 Channel)\nWhen CTS auto-flow is enabled, the UART will send data to external device when CTS input assert (UART will not send data to device until CTS is asserted).</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>CTS auto flow control Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CTS auto flow control Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ABRIEN</name>
              <description>Auto-Baud Rate Interrupt Enable Control</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Auto-baud rate interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-baud rate interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_FCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_FCR</displayName>
          <description>UART FIFO Control Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000101</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RFR</name>
              <description>RX Field Software Reset\nWhen RFR is set, all the byte in the receiver FIFO /receive buffer and RX internal state machine are cleared.\nNote: This bit will automatically clear at least 3 UART peripherial clock cycles.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the RX internal state machine and pointers</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TFR</name>
              <description>TX Field Software Reset\nWhen TFR is set, all the byte in the transmit FIFO/ transmit buffer and TX internal state machine are cleared.\nNote: This bit will automatically clear at least 3 UART peripherial clock cycles.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the TX internal state machine and pointers</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RFITL</name>
              <description>RX FIFO Interrupt (INT_RDA) Trigger Level (Available In UART0/UART1/UART2 Channel)\nWhen the number of bytes in the receive FIFO equals the RFITL, the RDA_IF will be set (if UA_IER [RDA_IEN] enabled, and an interrupt will be generated).</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX FIFO Interrupt Trigger Level is 1 byte.\nRX Buffer Interrupt Trigger Level is 1 byte</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX FIFO Interrupt Trigger Level is 4 bytes</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>RX FIFO Interrupt Trigger Level is 8 bytes</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>RX FIFO Interrupt Trigger Level is 14 bytes</description>
                    <value>#0011</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_DIS</name>
              <description>Receiver Disable Control\nThe receiver is disabled or not (set 1 to disable receiver).\nNote: This field is used for RS-485 Normal Multi-drop mode. It should be programmed before RS-485_NMM (UA_ALT_CSR[8]) is programmed.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receiver Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receiver Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RTS_TRI_LEV</name>
              <description>RTS Trigger Level For Auto-Flow Control Use (Available In UART0/UART1 Channel)\nNote: This field is used for RTS auto-flow control.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTS Trigger Level is 1 byte</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTS Trigger Level is 4 bytes</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>RTS Trigger Level is 8 bytes</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>RTS Trigger Level is 14 bytes</description>
                    <value>#0011</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_LCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_LCR</displayName>
          <description>UART Line Control Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WLS</name>
              <description>Word Length Selection</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Word length is 5-bit</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Word length is 6-bit</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Word length is 7-bit</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Word length is 8-bit</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>NSB</name>
              <description>Number Of 'STOP Bit'</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One ' STOP bit' is generated in the transmitted data</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When select 5-bit word length, 1.5 'STOP bit' is generated in the transmitted data. When select 6-,7- and 8-bti word length, 2 'STOP bit' is generated in the transmitted data</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PBE</name>
              <description>Parity Bit Enable Control</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No parity bit</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Parity bit is generated on each outgoing character and is checked on each incoming data</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EPE</name>
              <description>Even Parity Enable Control\nThis bit has effect only when PBE (UA_LCR[3]) is set.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Odd number of logic 1's is transmitted and checked in each word</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Even number of logic 1's is transmitted and checked in each word</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPE</name>
              <description>Stick Parity Enable Control</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Stick parity Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>If PBE (UA_LCR[3]) and EBE (UA_LCR[4]) are logic 1, the parity bit is transmitted and checked as logic 0. If PBE (UA_LCR[3]) is 1 and EBE (UA_LCR[4]) is 0 then the parity bit is transmitted and checked as 1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BCB</name>
              <description>Break Control Bit\nWhen this bit is set to logic 1, the serial data output (TX) is forced to the Spacing State (logic 0). This bit acts only on TX and has no effect on the transmitter logic.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_FSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_FSR</displayName>
          <description>UART FIFO Status Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x10404000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX_OVER_IF</name>
              <description>RX Overflow Error IF (Read Only)\nThis bit is set when RX FIFO overflow. \nIf the number of bytes of received data is greater than RX_FIFO (UA_RBR) size, 16 bytes of UART0/UART1/UART2, this bit will be set.\nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX FIFO is not overflow.\nRX Buffer is not overflow</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX FIFO is overflow.\nRX Buffer is overflow</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>ABRDIF</name>
              <description>Auto-Baud Rate Detect Interrupt (Read Only) \nThis bit is set to logic '1' when auto-baud rate detect function is finished. \nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Auto-baud rate detect function is not finished</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-baud rate detect function is finished</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>ABRDTOIF</name>
              <description>Auto-Baud Rate Time-Out Interrupt (Read Only) \nNote1: This bit is set to logic '1' in Auto-baud Rate Detect mode and the baud rate counter is overflow.\nNote2: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Auto-baud rate counter is underflow</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-baud rate counter is overflow</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RS485_ADD_DETF</name>
              <description>RS-485 Address Byte Detection Flag (Read Only) (Available In UART0/UART1)\nNote1: This field is used for RS-485 function mode and RS485_ADD_EN (UA_ALT_CSR[15]) is set to 1 to enable Address detection mode.\nNote2: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receiver detects a data that is not an address bit (bit 9 ='1')</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receiver detects a data that is an address bit (bit 9 ='1')</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>PEF</name>
              <description>Parity Error Flag (Read Only)\nThis bit is set to logic 1 whenever the received character does not have a valid 'parity bit', and is reset whenever the CPU writes 1 to this bit.\nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No parity error is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Parity error is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>FEF</name>
              <description>Framing Error Flag (Read Only)\nThis bit is set to logic 1 whenever the received character does not have a valid 'stop bit' (that is, the stop bit following the last data bit or parity bit is detected as logic 0), and is reset whenever the CPU writes 1 to this bit.\nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No framing error is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Framing error is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BIF</name>
              <description>Break Interrupt Flag (Read Only)\nThis bit is set to logic 1 whenever the received data input(RX) is held in the 'spacing state' (logic 0) for longer than a full word transmission time (that is, the total time of 'start bit' + data bits + parity + stop bits) and is reset whenever the CPU writes 1 to this bit.\nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Break interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Break interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_POINTER</name>
              <description>RX FIFO Pointer (Read Only)\nThis field indicates the RX FIFO Buffer Pointer. When UART receives one byte from external device, then RX_POINTER increases one. When one byte of RX FIFO is read by CPU, then RX_POINTER decreases one.\nThe Maximum value shown in RX_POINTER is 15 (UART0/UART1/UART2). When the using level of RX FIFO Buffer equal to 16, the RX_FULL bit is set to 1 and RX_POINTER will show 0. As one byte of RX FIFO is read by CPU, the RX_FULL bit is cleared to 0 and RX_POINTER will show 15 (UART0/UART1/UART2).\nWhen RX Buffer is equal to 1, if one byte data is received, the RX_FULL bit is set to 1 and RX_POINTER will show 1. Once the RX Buffer is read, the RX_POINTER is 0.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_EMPTY</name>
              <description>Receiver FIFO Empty (Read Only)\nThis bit initiate RX FIFO empty or not. (UART0/UART1/UART2)\nNote: When the last byte of RX Buffer has been read by CPU, hardware sets this bit high. It will be cleared when UART receives any new data.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX FIFO is not empty.\nRX Buffer is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX FIFO is empty.\nRX Buffer is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_FULL</name>
              <description>Receiver FIFO Full (Read Only)\nThis bit initiates RX FIFO is full or not (UART0/UART1/UART2). \nNote: This bit is set when the number of usage in RX Buffer is equal to 1 (UART3/UART4/UART5), otherwise is cleared by hardware.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX FIFO is not full.\nRX buffer is not full</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX FIFO is full.\nRX bufferis full</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_POINTER</name>
              <description>TX FIFO Pointer (Read Only)\nThis field indicates the TX FIFO Buffer Pointer. When CPU writes one byte into UA_THR, then TX_POINTER increases one. When one byte of TX FIFO is transferred to Transmitter Shift Register, then TX_POINTER decreases one.\nThe Maximum value shown in TX_POINTER is 15 (UART0/UART1/UART2). When the using level of TX FIFO Buffer is equal to 16, the TX_FULL bit is set to 1 and TX_POINTER will show 0. As one byte of TX FIFO is transferred to Transmitter Shift Register, the TX_FULL bit is cleared to 0 and TX_POINTER will show 15  (UART0/UART1/UART2).\nTX_POINTER is 0 (UART3/URT4/UART5).\nWhen TX Buffer is equal to 1, if one byte data is received, the TX_FULL bit is set to 1 and TX_POINTER will show 1. Once the TX Buffer is read, the TX_POINTER is 0.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_EMPTY</name>
              <description>Transmitter FIFO Empty (Read Only)\nThis bit indicates TX FIFO empty or not. (UART0/UART1/UART2)\nNote: When the last byte of TX Buffer has been transferred to Transmitter Shift Register, hardware sets this bit high. It will be cleared when writing data into THR (TX FIFO not empty).</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX FIFO is not empty.\nTX Buffer is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX FIFO is empty.\nTX Buffer is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_FULL</name>
              <description>Transmitter FIFO Full (Read Only)\nThis bit indicates TX FIFO is full or not. (UART0/UART1/UART2)\nThis bit is set when the number of usage in TX Buffer is equal to 1 (UART3/UART4/UART5), otherwise is cleared by hardware.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX FIFO is not full.\nTX Buffer is not full</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX FIFO is full.\nTX Buffer is full</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_OVER_IF</name>
              <description>TX Overflow Error Interrupt Flag (Read Only)\nIf TX FIFO (UA_THR) is full, an additional write to UA_THR will cause this bit to logic 1. (UART0/UART1/UART2)\nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX FIFO is not overflow.\nTX Buffer is not overflow</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX FIFO is overflow.\nTX Buffer is overflow</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TE_FLAG</name>
              <description>Transmitter Empty Flag (Read Only)\nThis bit is set by hardware when TX FIFO (UA_THR) is empty and the STOP bit of the last byte has been transmitted. (UART0/UART1/UART2)\nNote: This bit is cleared automatically when TX FIFO/TX Buffer is not empty or the last byte transmission has not completed.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX FIFO is not empty.\nTX Buffer is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX FIFO is empty.\nTX Buffer is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_ISR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_ISR</displayName>
          <description>UART Interrupt Status Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000002</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDA_IF</name>
              <description>Receive Data Available Interrupt Flag (Read Only)\nWhen the number of bytes in the RX FIFO (UART0/UART1/UART2) / RX Buffer (UART3/UART4/UART5) equals the RFITL then the RDA_IF(UA_ISR[0]) will be set. If RDA_IEN (UA_IER [0]) is enabled, the RDA interrupt will be generated.\nNote: This bit is read only and it will be cleared when the number of unread bytes of RX FIFO drops below the threshold level (RFITL(UA_FCR[7:4]).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RDA interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RDA interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>THRE_IF</name>
              <description>Transmit Holding Register Empty Interrupt Flag (Read Only) \nThis bit is set when the last data of TX FIFO (UART0/UART1/UART2) / TX Buffer (UART3/UART4/UART5) is transferred to Transmitter Shift Register. If THRE_IEN (UA_IER[1]) is enabled, the THRE interrupt will be generated.\nNote: This bit is read only and it will be cleared when writing data into THR (TX FIFO not empty).</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No THRE interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>THRE interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RLS_IF</name>
              <description>Receive Line Interrupt Flag (Read Only)  \nThis bit is set when the RX receive data have parity error, frame error or break error (at least one of 3 bits, BIF(UA_FSR[6]), FEF(UA_FSR[5]) and PEF(UA_FSR[4]), is set). If RLS_IEN (UA_IER [2]) is enabled, the RLS interrupt will be generated.\nNote2: This bit is read only and reset to 0 when all bits of BIF(UA_FSR[6]), FEF(UA_FSR[5]) and PEF(UA_FSR[4]) are cleared.\nNote3: In RS-485 function mode, this bit is read only and reset to 0 when all bits of BIF(UA_FSR[6]) , FEF(UA_FSR[5]) and PEF(UA_FSR[4]) and RS485_ADD_DETF (UA_FSR[3]) are cleared.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RLS interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RLS interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>MODEM_IF</name>
              <description>MODEM Interrupt Flag (Read Only) (Not Available In UART2 Channel)\nNote: This bit is read only and reset to 0 when bit DCTSF is cleared by a write 1 on DCTSF(UA_MSR[0]).</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Modem interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Modem interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TOUT_IF</name>
              <description>Time-Out Interrupt Flag (Read Only)\nThis bit is set when the RX FIFO (UART0/UART1/UART2) / RX Buffer (UART3/UART4/UART5) is not empty and no activities occurred in the RX FIFO and the time-out counter equal to TOIC. If TOUT_IEN (UA_IER [4]) is enabled, the Tout interrupt will be generated.\nNote: This bit is read only and user can read UA_RBR (RX is in active) to clear it.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Time-out interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time-out interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BUF_ERR_IF</name>
              <description>Buffer Error Interrupt Flag (Read Only)\nThis bit is set when the TX FIFO (UART0/UART1/UART2) / TX Buffer (UART3/UART4/UART5) or RX FIFO (UART0/UART1/UART2)/ RX Buffer (UART3/UART4/UART5) overflows (TX_OVER_IF (UA_FSR[24]) or RX_OVER_IF (UA_FSR[0]) is set). When BUF_ERR_IF (UA_ISR[5]) is set, the transfer is not correct. If BUF_ERR_IEN (UA_IER [8]) is enabled, the buffer error interrupt will be generated.\nNote: This bit is read only and reset to 0 when all bits of TX_OVER_IF(UA_FSR[24]) and RX_OVER_IF(UA_FSR[0]) are cleared.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No buffer error interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Buffer error interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>WKIF</name>
              <description>UART Wake-Up Flag (Read Only)\nThis bit is set when DATWKIF (UART_INTSTS[17]) or CTSWKIF(UART_INTSTS[16]) is set to 1.\nNote: This bit is read only. This bit is cleared if both of DATWKIF (UART_INTSTS[17]) and CTSWKIF (UART_INTSTS[16]) are cleared to 0 by writing 1 to DATWKIF (UART_INTSTS[17])  and CTSWKIF (UART_INTSTS[17]).</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No DATWKIF and CTSWKIF are generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>DATWKIF or CTSWKIF</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LIN_IF</name>
              <description>LIN Bus Flag (Read Only)(UART0/UARt1/UART2)\nNote: This bit is read only. This bit is cleared when LINS_HDET_F (UA_LIN_SR[0]), LIN_BKDET_F (UA_LIN_SR[9]), BIT_ERR_F (UA_LIN_SR[9]), LINS_IDPENR_F (UA_LIN_SR[2]) and LINS_HERR_F (UA_LIN_SR[1]) all are cleared.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>None of LINS_HDET_F, LIN_BKDET_F, BIT_ERR_F, LINS_IDPERR_F and LINS_HERR_F is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>At least one of LINS_HDET_F, LIN_BKDET_F, BIT_ERR_F, LINS_IDPERR_F and LINS_HERR_F is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RDA_INT</name>
              <description>Receive Data Available Interrupt Indicator (Read Only)\nThis bit is set if RDA_IEN (UA_IER[0]) and RDA_IF (UA_ISR[0]) are both set to 1.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RDA interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RDA interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>THRE_INT</name>
              <description>Transmit Holding Register Empty Interrupt Indicator (Read Only)\nThis bit is set if THRE_IEN (UA_IER[1])and THRE_IF(UA_SR[1]) are both set to 1.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No THRE interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>THRE interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RLS_INT</name>
              <description>Receive Line Status Interrupt Indicator (Read Only) \nThis bit is set if RLS_IEN (UA_IER[2]) and RLS_IF(UA_ISR[2]) are both set to 1.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RLS interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RLS interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>MODEM_INT</name>
              <description>MODEM Status Interrupt Indicator (Read Only) (Available In UART0/UART1 Channel)\nThis bit is set if MODEM_IEN(UA_IER[3] and MODEM_IF(UA_ISR[4]) are both set to 1</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Modem interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Modem interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TOUT_INT</name>
              <description>Time-Out Interrupt Indicator (Read Only)\nThis bit is set if TOUT_IEN(UA_IER[4]) and TOUT_IF(UA_ISR[4]) are both set to 1.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Tout interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Tout interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BUF_ERR_INT</name>
              <description>Buffer Error Interrupt Indicator (Read Only)\nThis bit is set if BUF_ERR_IEN(UA_IER[5] and BUF_ERR_IF(UA_ISR[5]) are both set to 1.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No buffer error interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Buffer error interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LIN_INT</name>
              <description>LIN Bus Interrupt Indicator (Read Only)\nThis bit is set if LIN_IEN (UA_IER[8]) and LIN _IF(UA_ISR[7]) are both set to 1.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No LIN Bus interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The LIN Bus interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>CTSWKIF</name>
              <description>NCTS Wake-Up Interrupt Flag (Read Only)\nNote1: If WKCTSIEN (UA_IER[6])is enabled, the wake-up interrupt is generated.\nNote2: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Chip stays in power-down state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Chip wake-up from power-down state by nCTS wake-up</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>DATWKIF</name>
              <description>Data Wake-Up Interrupt Flag (Read Only)\nThis bit is set if chip wake-up from power-down state by data wake-up.\nNote1: If WKDATIEN (UA_IER[10]) is enabled, the wake-up interrupt is generated.\nNote2: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Chip stays in power-down state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Chip wake-up from power-down state by data wake-up</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_TOR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_TOR</displayName>
          <description>UART Time-out Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TOIC</name>
              <description>Time-Out Interrupt Comparator</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DLY</name>
              <description>TX Delay Time Value \nThis field is used to programming the transfer delay time between the last stop bit and next start bit.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_BAUD</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_BAUD</displayName>
          <description>UART Baud Rate Divisor Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x0F000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BRD</name>
              <description>Baud Rate Divider\nThe field indicates the baud rate divider.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIVIDER_X</name>
              <description>Divider X</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIV_X_ONE</name>
              <description>Divider X Equal To 1\nRefer to Table 624 UART Baud Rate Equation for more information.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Divider M = X (the equation of M = X+1, but DIVIDER_X[27:24] must  = 8)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Divider M = 1 (the equation of M = 1, but BRD [15:0] must  = 3)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DIV_X_EN</name>
              <description>Divider X Enable Control\nRefer to Table 624 UART Baud Rate Equation for more information.\nNote: In IrDA mode, this bit must disable.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Divider X Disabled (the equation of M = 16)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Divider X Enabled (the equation of M = X+1, but DIVIDER_X [27:24] must  = 8)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_IRCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_IRCR</displayName>
          <description>UART IrDA Control Register</description>
          <addressOffset>0x28</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000040</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX_SELECT</name>
              <description>IrDA Receiver/Transmitter Selection Enable Control</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>IrDA Transmitter Disabled and Receiver Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>IrDA Transmitter Enabled and Receiver Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INV_TX</name>
              <description>IrDA Inverse Transmitting Output Signal Control</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>None inverse transmitting signal</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverse transmitting output signal</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INV_RX</name>
              <description>IrDA Inverse Receive Input Signal Control</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>None inverse receiving input signal</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverse receiving input signal</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_ALT_CSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_ALT_CSR</displayName>
          <description>UART Alternate Control/Status Register</description>
          <addressOffset>0x2C</addressOffset>
          <access>read-write</access>
          <resetValue>0x0000000C</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LIN_BKFL</name>
              <description>UART LIN Break Field Length (Available In UART0/UART1/UART2)\nThis field indicates a 4-bit LIN TX break field count.\nNote1: This break field length is LIN_BKFL + 1.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_RX_EN</name>
              <description>LIN RX Enable Control (Available In UART0/UART1/UART2)</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN RX mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN RX mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_TX_EN</name>
              <description>LIN TX Break Mode Enable Control (Available In UART0/UART1/UART2)\nNote: When TX break field transfer operation finished, this bit will be cleared automatically.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN TX Break mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN TX Break mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS485_NMM</name>
              <description>RS-485 Normal Multi-Drop Operation Mode (NMM) (Available In UART0/UART1)\nNote: It cannot be active with RS-485_AAD operation mode.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RS-485 Normal Multi-drop Operation mode (NMM) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RS-485 Normal Multi-drop Operation mode (NMM) Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS485_AAD</name>
              <description>RS-485 Auto Address Detection Operation Mode (AAD) (Available In UART0/UART1)\nNote: It cannot be active with RS-485_NMM operation mode.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RS-485 Auto Address Detection Operation mode (AAD) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RS-485 Auto Address Detection Operation mode (AAD) Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS485_AUD</name>
              <description>RS-485 Auto Direction Mode (AUD) (Available In UART0/UART1)\nNote: It can be active with RS-485_AAD or RS-485_NMM operation mode.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RS-485 Auto Direction Operation mode (AUO) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RS-485 Auto Direction Operation mode (AUO) Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS485_ADD_EN</name>
              <description>RS-485 Address Detection Enable Control (Available In UART0/UART1)\nThis bit is used to enable RS-485 Address Detection mode. \nNote: This bit is used for RS-485 any operation mode.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Address detection mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Address detection mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ABRIF</name>
              <description>Auto-Baud Rate Interrupt Flag (Read Only) \nThis bit is set when auto-baud rate detection function finished or the auto-baud rate counter was overflow and if ABRIEN(UART_IEN [18]) is set then the auto-baud rate interrupt will be generated. \nNote: This bit is read only, but it can be cleared by writing '1' to ABRDTOIF (UA_FSR[2]) and ABRDIF(UA_FSR[1]).</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ABRDEN</name>
              <description>Auto-Baud Rate Detect Enable Control\nThis bit is cleared automatically after auto-baud detection is finished.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Auto-baud rate detect function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-baud rate detect function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ABRDBITS</name>
              <description>Auto-Baud Rate Detect Bit Length \nNote: The calculation of bit number includes the START bit.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>1-bit time from Start bit to the 1st rising edge. The input pattern shall be 0x01</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>2-bit time from Start bit to the 1st rising edge. The input pattern shall be 0x02</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>4-bit time from Start bit to the 1st rising edge. The input pattern shall be 0x08</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>8-bit time from Start bit to the 1st rising edge. The input pattern shall be 0x80</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADDR_MATCH</name>
              <description>Address Match Value Register (Available In UART0/UART1)\nThis field contains the RS-485 address match values.\nNote: This field is used for RS-485 auto address detection mode.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_FUN_SEL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_FUN_SEL</displayName>
          <description>UART Function Select Register</description>
          <addressOffset>0x30</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FUN_SEL</name>
              <description>Function Select Enable Control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UART function Enabled</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN function Enabled. (Available in UART0/UART1/UART2)</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>IrDA function Enabled</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>RS-485 function Enabled. (Available in UART0/UART1)</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>UART5</name>
      <description>UART Register Map</description>
      <groupName>UART</groupName>
      <baseAddress>0x40158000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x10</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x18</offset>
        <size>0x1C</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>UA_RBR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_RBR</displayName>
          <description>UART Receive Buffer Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>RBR</name>
              <description>Receive Buffer Register (Read Only)\nBy reading this register, the UART will return the 8-bit data received from RX pin (LSB first).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_THR</name>
          <alternateRegister>UA_RBR</alternateRegister>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_THR</displayName>
          <description>UART Transmit Holding Register</description>
          <addressOffset>0x0</addressOffset>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>THR</name>
              <description>Transmit Holding Register\nBy writing one byte to this register, the data byte will be stored in transmitter FIFO. The UART Controller will send out the data stored in transmitter FIFO top location through the TX pin.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_IER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_IER</displayName>
          <description>UART Interrupt Enable Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDA_IEN</name>
              <description>Receive Data Available Interrupt Enable Control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RDA_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RDA_INT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>THRE_IEN</name>
              <description>Transmit Holding Register Empty Interrupt Enable Control</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>THRE_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>THRE_INT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RLS_IEN</name>
              <description>Receive Line Status Interrupt Enable Control</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RLS_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RLS_INT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODEM_IEN</name>
              <description>Modem Status Interrupt Enable Control (Available In UART0/UART1 Channel)</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>MODEM_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>MODEM_INT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TOUT_IEN</name>
              <description>RX Time-Out Interrupt Enable Control</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TOUT_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TOUT_INT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BUF_ERR_IEN</name>
              <description>Buffer Error Interrupt Enable Control</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>BUF_ERR_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>BUF_ERR_INT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WKCTSIEN</name>
              <description>NCTS Wake-Up Interrupt Enable Control</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>nCTS wake-up system function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Wake-up system function Enabled, when the system is in Power-down mode, an external nCTS change will wake-up system from Power-down mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_IEN</name>
              <description>LIN Bus Interrupt Enable Control\nNote: This field is used for LIN function mode.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Lin bus interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Lin bus interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WKDATIEN</name>
              <description>Incoming Data Wake-Up Interrupt Enable Control\nNote: Hardware will clear this bit when the incoming data wake-up operation finishes and 'system clock' work stable.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Incoming data wake-up system function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Incoming data wake-up system function Enabled, when the system is in Power-down mode, incoming data will wake-up system from Power-down mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TIME_OUT_EN</name>
              <description>Time-Out Counter Enable Control</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Time-out counter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time-out counter Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTO_RTS_EN</name>
              <description>RTS Auto Flow Control Enable Control ( Available In UART0/UART1 Channel)\nWhen RTS auto-flow is enabled, if the number of bytes in the RX FIFO equals the RTS_TRI_LEV (UA_FCR [19:16]), the UART will de-assert RTS signal.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTS auto flow control Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTS auto flow control Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTO_CTS_EN</name>
              <description>CTS Auto Flow Control Enable Control (Available In UART0/UART1 Channel)\nWhen CTS auto-flow is enabled, the UART will send data to external device when CTS input assert (UART will not send data to device until CTS is asserted).</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>CTS auto flow control Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CTS auto flow control Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ABRIEN</name>
              <description>Auto-Baud Rate Interrupt Enable Control</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Auto-baud rate interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-baud rate interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_FCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_FCR</displayName>
          <description>UART FIFO Control Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000101</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RFR</name>
              <description>RX Field Software Reset\nWhen RFR is set, all the byte in the receiver FIFO /receive buffer and RX internal state machine are cleared.\nNote: This bit will automatically clear at least 3 UART peripherial clock cycles.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the RX internal state machine and pointers</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TFR</name>
              <description>TX Field Software Reset\nWhen TFR is set, all the byte in the transmit FIFO/ transmit buffer and TX internal state machine are cleared.\nNote: This bit will automatically clear at least 3 UART peripherial clock cycles.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the TX internal state machine and pointers</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RFITL</name>
              <description>RX FIFO Interrupt (INT_RDA) Trigger Level (Available In UART0/UART1/UART2 Channel)\nWhen the number of bytes in the receive FIFO equals the RFITL, the RDA_IF will be set (if UA_IER [RDA_IEN] enabled, and an interrupt will be generated).</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX FIFO Interrupt Trigger Level is 1 byte.\nRX Buffer Interrupt Trigger Level is 1 byte</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX FIFO Interrupt Trigger Level is 4 bytes</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>RX FIFO Interrupt Trigger Level is 8 bytes</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>RX FIFO Interrupt Trigger Level is 14 bytes</description>
                    <value>#0011</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_DIS</name>
              <description>Receiver Disable Control\nThe receiver is disabled or not (set 1 to disable receiver).\nNote: This field is used for RS-485 Normal Multi-drop mode. It should be programmed before RS-485_NMM (UA_ALT_CSR[8]) is programmed.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receiver Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receiver Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RTS_TRI_LEV</name>
              <description>RTS Trigger Level For Auto-Flow Control Use (Available In UART0/UART1 Channel)\nNote: This field is used for RTS auto-flow control.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTS Trigger Level is 1 byte</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTS Trigger Level is 4 bytes</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>RTS Trigger Level is 8 bytes</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>RTS Trigger Level is 14 bytes</description>
                    <value>#0011</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_LCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_LCR</displayName>
          <description>UART Line Control Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WLS</name>
              <description>Word Length Selection</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Word length is 5-bit</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Word length is 6-bit</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Word length is 7-bit</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Word length is 8-bit</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>NSB</name>
              <description>Number Of 'STOP Bit'</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One ' STOP bit' is generated in the transmitted data</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When select 5-bit word length, 1.5 'STOP bit' is generated in the transmitted data. When select 6-,7- and 8-bti word length, 2 'STOP bit' is generated in the transmitted data</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PBE</name>
              <description>Parity Bit Enable Control</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No parity bit</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Parity bit is generated on each outgoing character and is checked on each incoming data</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EPE</name>
              <description>Even Parity Enable Control\nThis bit has effect only when PBE (UA_LCR[3]) is set.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Odd number of logic 1's is transmitted and checked in each word</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Even number of logic 1's is transmitted and checked in each word</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPE</name>
              <description>Stick Parity Enable Control</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Stick parity Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>If PBE (UA_LCR[3]) and EBE (UA_LCR[4]) are logic 1, the parity bit is transmitted and checked as logic 0. If PBE (UA_LCR[3]) is 1 and EBE (UA_LCR[4]) is 0 then the parity bit is transmitted and checked as 1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BCB</name>
              <description>Break Control Bit\nWhen this bit is set to logic 1, the serial data output (TX) is forced to the Spacing State (logic 0). This bit acts only on TX and has no effect on the transmitter logic.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_FSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_FSR</displayName>
          <description>UART FIFO Status Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x10404000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX_OVER_IF</name>
              <description>RX Overflow Error IF (Read Only)\nThis bit is set when RX FIFO overflow. \nIf the number of bytes of received data is greater than RX_FIFO (UA_RBR) size, 16 bytes of UART0/UART1/UART2, this bit will be set.\nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX FIFO is not overflow.\nRX Buffer is not overflow</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX FIFO is overflow.\nRX Buffer is overflow</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>ABRDIF</name>
              <description>Auto-Baud Rate Detect Interrupt (Read Only) \nThis bit is set to logic '1' when auto-baud rate detect function is finished. \nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Auto-baud rate detect function is not finished</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-baud rate detect function is finished</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>ABRDTOIF</name>
              <description>Auto-Baud Rate Time-Out Interrupt (Read Only) \nNote1: This bit is set to logic '1' in Auto-baud Rate Detect mode and the baud rate counter is overflow.\nNote2: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Auto-baud rate counter is underflow</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-baud rate counter is overflow</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RS485_ADD_DETF</name>
              <description>RS-485 Address Byte Detection Flag (Read Only) (Available In UART0/UART1)\nNote1: This field is used for RS-485 function mode and RS485_ADD_EN (UA_ALT_CSR[15]) is set to 1 to enable Address detection mode.\nNote2: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receiver detects a data that is not an address bit (bit 9 ='1')</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receiver detects a data that is an address bit (bit 9 ='1')</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>PEF</name>
              <description>Parity Error Flag (Read Only)\nThis bit is set to logic 1 whenever the received character does not have a valid 'parity bit', and is reset whenever the CPU writes 1 to this bit.\nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No parity error is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Parity error is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>FEF</name>
              <description>Framing Error Flag (Read Only)\nThis bit is set to logic 1 whenever the received character does not have a valid 'stop bit' (that is, the stop bit following the last data bit or parity bit is detected as logic 0), and is reset whenever the CPU writes 1 to this bit.\nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No framing error is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Framing error is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BIF</name>
              <description>Break Interrupt Flag (Read Only)\nThis bit is set to logic 1 whenever the received data input(RX) is held in the 'spacing state' (logic 0) for longer than a full word transmission time (that is, the total time of 'start bit' + data bits + parity + stop bits) and is reset whenever the CPU writes 1 to this bit.\nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Break interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Break interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_POINTER</name>
              <description>RX FIFO Pointer (Read Only)\nThis field indicates the RX FIFO Buffer Pointer. When UART receives one byte from external device, then RX_POINTER increases one. When one byte of RX FIFO is read by CPU, then RX_POINTER decreases one.\nThe Maximum value shown in RX_POINTER is 15 (UART0/UART1/UART2). When the using level of RX FIFO Buffer equal to 16, the RX_FULL bit is set to 1 and RX_POINTER will show 0. As one byte of RX FIFO is read by CPU, the RX_FULL bit is cleared to 0 and RX_POINTER will show 15 (UART0/UART1/UART2).\nWhen RX Buffer is equal to 1, if one byte data is received, the RX_FULL bit is set to 1 and RX_POINTER will show 1. Once the RX Buffer is read, the RX_POINTER is 0.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_EMPTY</name>
              <description>Receiver FIFO Empty (Read Only)\nThis bit initiate RX FIFO empty or not. (UART0/UART1/UART2)\nNote: When the last byte of RX Buffer has been read by CPU, hardware sets this bit high. It will be cleared when UART receives any new data.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX FIFO is not empty.\nRX Buffer is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX FIFO is empty.\nRX Buffer is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_FULL</name>
              <description>Receiver FIFO Full (Read Only)\nThis bit initiates RX FIFO is full or not (UART0/UART1/UART2). \nNote: This bit is set when the number of usage in RX Buffer is equal to 1 (UART3/UART4/UART5), otherwise is cleared by hardware.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX FIFO is not full.\nRX buffer is not full</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX FIFO is full.\nRX bufferis full</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_POINTER</name>
              <description>TX FIFO Pointer (Read Only)\nThis field indicates the TX FIFO Buffer Pointer. When CPU writes one byte into UA_THR, then TX_POINTER increases one. When one byte of TX FIFO is transferred to Transmitter Shift Register, then TX_POINTER decreases one.\nThe Maximum value shown in TX_POINTER is 15 (UART0/UART1/UART2). When the using level of TX FIFO Buffer is equal to 16, the TX_FULL bit is set to 1 and TX_POINTER will show 0. As one byte of TX FIFO is transferred to Transmitter Shift Register, the TX_FULL bit is cleared to 0 and TX_POINTER will show 15  (UART0/UART1/UART2).\nTX_POINTER is 0 (UART3/URT4/UART5).\nWhen TX Buffer is equal to 1, if one byte data is received, the TX_FULL bit is set to 1 and TX_POINTER will show 1. Once the TX Buffer is read, the TX_POINTER is 0.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_EMPTY</name>
              <description>Transmitter FIFO Empty (Read Only)\nThis bit indicates TX FIFO empty or not. (UART0/UART1/UART2)\nNote: When the last byte of TX Buffer has been transferred to Transmitter Shift Register, hardware sets this bit high. It will be cleared when writing data into THR (TX FIFO not empty).</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX FIFO is not empty.\nTX Buffer is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX FIFO is empty.\nTX Buffer is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_FULL</name>
              <description>Transmitter FIFO Full (Read Only)\nThis bit indicates TX FIFO is full or not. (UART0/UART1/UART2)\nThis bit is set when the number of usage in TX Buffer is equal to 1 (UART3/UART4/UART5), otherwise is cleared by hardware.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX FIFO is not full.\nTX Buffer is not full</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX FIFO is full.\nTX Buffer is full</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_OVER_IF</name>
              <description>TX Overflow Error Interrupt Flag (Read Only)\nIf TX FIFO (UA_THR) is full, an additional write to UA_THR will cause this bit to logic 1. (UART0/UART1/UART2)\nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX FIFO is not overflow.\nTX Buffer is not overflow</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX FIFO is overflow.\nTX Buffer is overflow</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TE_FLAG</name>
              <description>Transmitter Empty Flag (Read Only)\nThis bit is set by hardware when TX FIFO (UA_THR) is empty and the STOP bit of the last byte has been transmitted. (UART0/UART1/UART2)\nNote: This bit is cleared automatically when TX FIFO/TX Buffer is not empty or the last byte transmission has not completed.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX FIFO is not empty.\nTX Buffer is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX FIFO is empty.\nTX Buffer is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_ISR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_ISR</displayName>
          <description>UART Interrupt Status Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000002</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDA_IF</name>
              <description>Receive Data Available Interrupt Flag (Read Only)\nWhen the number of bytes in the RX FIFO (UART0/UART1/UART2) / RX Buffer (UART3/UART4/UART5) equals the RFITL then the RDA_IF(UA_ISR[0]) will be set. If RDA_IEN (UA_IER [0]) is enabled, the RDA interrupt will be generated.\nNote: This bit is read only and it will be cleared when the number of unread bytes of RX FIFO drops below the threshold level (RFITL(UA_FCR[7:4]).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RDA interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RDA interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>THRE_IF</name>
              <description>Transmit Holding Register Empty Interrupt Flag (Read Only) \nThis bit is set when the last data of TX FIFO (UART0/UART1/UART2) / TX Buffer (UART3/UART4/UART5) is transferred to Transmitter Shift Register. If THRE_IEN (UA_IER[1]) is enabled, the THRE interrupt will be generated.\nNote: This bit is read only and it will be cleared when writing data into THR (TX FIFO not empty).</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No THRE interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>THRE interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RLS_IF</name>
              <description>Receive Line Interrupt Flag (Read Only)  \nThis bit is set when the RX receive data have parity error, frame error or break error (at least one of 3 bits, BIF(UA_FSR[6]), FEF(UA_FSR[5]) and PEF(UA_FSR[4]), is set). If RLS_IEN (UA_IER [2]) is enabled, the RLS interrupt will be generated.\nNote2: This bit is read only and reset to 0 when all bits of BIF(UA_FSR[6]), FEF(UA_FSR[5]) and PEF(UA_FSR[4]) are cleared.\nNote3: In RS-485 function mode, this bit is read only and reset to 0 when all bits of BIF(UA_FSR[6]) , FEF(UA_FSR[5]) and PEF(UA_FSR[4]) and RS485_ADD_DETF (UA_FSR[3]) are cleared.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RLS interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RLS interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>MODEM_IF</name>
              <description>MODEM Interrupt Flag (Read Only) (Not Available In UART2 Channel)\nNote: This bit is read only and reset to 0 when bit DCTSF is cleared by a write 1 on DCTSF(UA_MSR[0]).</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Modem interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Modem interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TOUT_IF</name>
              <description>Time-Out Interrupt Flag (Read Only)\nThis bit is set when the RX FIFO (UART0/UART1/UART2) / RX Buffer (UART3/UART4/UART5) is not empty and no activities occurred in the RX FIFO and the time-out counter equal to TOIC. If TOUT_IEN (UA_IER [4]) is enabled, the Tout interrupt will be generated.\nNote: This bit is read only and user can read UA_RBR (RX is in active) to clear it.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Time-out interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time-out interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BUF_ERR_IF</name>
              <description>Buffer Error Interrupt Flag (Read Only)\nThis bit is set when the TX FIFO (UART0/UART1/UART2) / TX Buffer (UART3/UART4/UART5) or RX FIFO (UART0/UART1/UART2)/ RX Buffer (UART3/UART4/UART5) overflows (TX_OVER_IF (UA_FSR[24]) or RX_OVER_IF (UA_FSR[0]) is set). When BUF_ERR_IF (UA_ISR[5]) is set, the transfer is not correct. If BUF_ERR_IEN (UA_IER [8]) is enabled, the buffer error interrupt will be generated.\nNote: This bit is read only and reset to 0 when all bits of TX_OVER_IF(UA_FSR[24]) and RX_OVER_IF(UA_FSR[0]) are cleared.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No buffer error interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Buffer error interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>WKIF</name>
              <description>UART Wake-Up Flag (Read Only)\nThis bit is set when DATWKIF (UART_INTSTS[17]) or CTSWKIF(UART_INTSTS[16]) is set to 1.\nNote: This bit is read only. This bit is cleared if both of DATWKIF (UART_INTSTS[17]) and CTSWKIF (UART_INTSTS[16]) are cleared to 0 by writing 1 to DATWKIF (UART_INTSTS[17])  and CTSWKIF (UART_INTSTS[17]).</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No DATWKIF and CTSWKIF are generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>DATWKIF or CTSWKIF</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LIN_IF</name>
              <description>LIN Bus Flag (Read Only)(UART0/UARt1/UART2)\nNote: This bit is read only. This bit is cleared when LINS_HDET_F (UA_LIN_SR[0]), LIN_BKDET_F (UA_LIN_SR[9]), BIT_ERR_F (UA_LIN_SR[9]), LINS_IDPENR_F (UA_LIN_SR[2]) and LINS_HERR_F (UA_LIN_SR[1]) all are cleared.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>None of LINS_HDET_F, LIN_BKDET_F, BIT_ERR_F, LINS_IDPERR_F and LINS_HERR_F is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>At least one of LINS_HDET_F, LIN_BKDET_F, BIT_ERR_F, LINS_IDPERR_F and LINS_HERR_F is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RDA_INT</name>
              <description>Receive Data Available Interrupt Indicator (Read Only)\nThis bit is set if RDA_IEN (UA_IER[0]) and RDA_IF (UA_ISR[0]) are both set to 1.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RDA interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RDA interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>THRE_INT</name>
              <description>Transmit Holding Register Empty Interrupt Indicator (Read Only)\nThis bit is set if THRE_IEN (UA_IER[1])and THRE_IF(UA_SR[1]) are both set to 1.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No THRE interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>THRE interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RLS_INT</name>
              <description>Receive Line Status Interrupt Indicator (Read Only) \nThis bit is set if RLS_IEN (UA_IER[2]) and RLS_IF(UA_ISR[2]) are both set to 1.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RLS interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RLS interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>MODEM_INT</name>
              <description>MODEM Status Interrupt Indicator (Read Only) (Available In UART0/UART1 Channel)\nThis bit is set if MODEM_IEN(UA_IER[3] and MODEM_IF(UA_ISR[4]) are both set to 1</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Modem interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Modem interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TOUT_INT</name>
              <description>Time-Out Interrupt Indicator (Read Only)\nThis bit is set if TOUT_IEN(UA_IER[4]) and TOUT_IF(UA_ISR[4]) are both set to 1.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Tout interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Tout interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BUF_ERR_INT</name>
              <description>Buffer Error Interrupt Indicator (Read Only)\nThis bit is set if BUF_ERR_IEN(UA_IER[5] and BUF_ERR_IF(UA_ISR[5]) are both set to 1.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No buffer error interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Buffer error interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LIN_INT</name>
              <description>LIN Bus Interrupt Indicator (Read Only)\nThis bit is set if LIN_IEN (UA_IER[8]) and LIN _IF(UA_ISR[7]) are both set to 1.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No LIN Bus interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The LIN Bus interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>CTSWKIF</name>
              <description>NCTS Wake-Up Interrupt Flag (Read Only)\nNote1: If WKCTSIEN (UA_IER[6])is enabled, the wake-up interrupt is generated.\nNote2: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Chip stays in power-down state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Chip wake-up from power-down state by nCTS wake-up</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>DATWKIF</name>
              <description>Data Wake-Up Interrupt Flag (Read Only)\nThis bit is set if chip wake-up from power-down state by data wake-up.\nNote1: If WKDATIEN (UA_IER[10]) is enabled, the wake-up interrupt is generated.\nNote2: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Chip stays in power-down state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Chip wake-up from power-down state by data wake-up</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_TOR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_TOR</displayName>
          <description>UART Time-out Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TOIC</name>
              <description>Time-Out Interrupt Comparator</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DLY</name>
              <description>TX Delay Time Value \nThis field is used to programming the transfer delay time between the last stop bit and next start bit.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_BAUD</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_BAUD</displayName>
          <description>UART Baud Rate Divisor Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x0F000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BRD</name>
              <description>Baud Rate Divider\nThe field indicates the baud rate divider.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIVIDER_X</name>
              <description>Divider X</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIV_X_ONE</name>
              <description>Divider X Equal To 1\nRefer to Table 624 UART Baud Rate Equation for more information.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Divider M = X (the equation of M = X+1, but DIVIDER_X[27:24] must  = 8)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Divider M = 1 (the equation of M = 1, but BRD [15:0] must  = 3)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DIV_X_EN</name>
              <description>Divider X Enable Control\nRefer to Table 624 UART Baud Rate Equation for more information.\nNote: In IrDA mode, this bit must disable.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Divider X Disabled (the equation of M = 16)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Divider X Enabled (the equation of M = X+1, but DIVIDER_X [27:24] must  = 8)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_IRCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_IRCR</displayName>
          <description>UART IrDA Control Register</description>
          <addressOffset>0x28</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000040</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX_SELECT</name>
              <description>IrDA Receiver/Transmitter Selection Enable Control</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>IrDA Transmitter Disabled and Receiver Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>IrDA Transmitter Enabled and Receiver Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INV_TX</name>
              <description>IrDA Inverse Transmitting Output Signal Control</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>None inverse transmitting signal</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverse transmitting output signal</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INV_RX</name>
              <description>IrDA Inverse Receive Input Signal Control</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>None inverse receiving input signal</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverse receiving input signal</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_ALT_CSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_ALT_CSR</displayName>
          <description>UART Alternate Control/Status Register</description>
          <addressOffset>0x2C</addressOffset>
          <access>read-write</access>
          <resetValue>0x0000000C</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LIN_BKFL</name>
              <description>UART LIN Break Field Length (Available In UART0/UART1/UART2)\nThis field indicates a 4-bit LIN TX break field count.\nNote1: This break field length is LIN_BKFL + 1.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_RX_EN</name>
              <description>LIN RX Enable Control (Available In UART0/UART1/UART2)</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN RX mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN RX mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_TX_EN</name>
              <description>LIN TX Break Mode Enable Control (Available In UART0/UART1/UART2)\nNote: When TX break field transfer operation finished, this bit will be cleared automatically.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN TX Break mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN TX Break mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS485_NMM</name>
              <description>RS-485 Normal Multi-Drop Operation Mode (NMM) (Available In UART0/UART1)\nNote: It cannot be active with RS-485_AAD operation mode.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RS-485 Normal Multi-drop Operation mode (NMM) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RS-485 Normal Multi-drop Operation mode (NMM) Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS485_AAD</name>
              <description>RS-485 Auto Address Detection Operation Mode (AAD) (Available In UART0/UART1)\nNote: It cannot be active with RS-485_NMM operation mode.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RS-485 Auto Address Detection Operation mode (AAD) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RS-485 Auto Address Detection Operation mode (AAD) Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS485_AUD</name>
              <description>RS-485 Auto Direction Mode (AUD) (Available In UART0/UART1)\nNote: It can be active with RS-485_AAD or RS-485_NMM operation mode.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RS-485 Auto Direction Operation mode (AUO) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RS-485 Auto Direction Operation mode (AUO) Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS485_ADD_EN</name>
              <description>RS-485 Address Detection Enable Control (Available In UART0/UART1)\nThis bit is used to enable RS-485 Address Detection mode. \nNote: This bit is used for RS-485 any operation mode.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Address detection mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Address detection mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ABRIF</name>
              <description>Auto-Baud Rate Interrupt Flag (Read Only) \nThis bit is set when auto-baud rate detection function finished or the auto-baud rate counter was overflow and if ABRIEN(UART_IEN [18]) is set then the auto-baud rate interrupt will be generated. \nNote: This bit is read only, but it can be cleared by writing '1' to ABRDTOIF (UA_FSR[2]) and ABRDIF(UA_FSR[1]).</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ABRDEN</name>
              <description>Auto-Baud Rate Detect Enable Control\nThis bit is cleared automatically after auto-baud detection is finished.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Auto-baud rate detect function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-baud rate detect function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ABRDBITS</name>
              <description>Auto-Baud Rate Detect Bit Length \nNote: The calculation of bit number includes the START bit.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>1-bit time from Start bit to the 1st rising edge. The input pattern shall be 0x01</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>2-bit time from Start bit to the 1st rising edge. The input pattern shall be 0x02</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>4-bit time from Start bit to the 1st rising edge. The input pattern shall be 0x08</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>8-bit time from Start bit to the 1st rising edge. The input pattern shall be 0x80</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADDR_MATCH</name>
              <description>Address Match Value Register (Available In UART0/UART1)\nThis field contains the RS-485 address match values.\nNote: This field is used for RS-485 auto address detection mode.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_FUN_SEL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_FUN_SEL</displayName>
          <description>UART Function Select Register</description>
          <addressOffset>0x30</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FUN_SEL</name>
              <description>Function Select Enable Control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UART function Enabled</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN function Enabled. (Available in UART0/UART1/UART2)</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>IrDA function Enabled</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>RS-485 function Enabled. (Available in UART0/UART1)</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>I2C0</name>
      <description>I2C Register Map</description>
      <groupName>I2C</groupName>
      <baseAddress>0x40020000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x34</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x3C</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>I2CON</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CON</displayName>
          <description>I2C Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AA</name>
              <description>Assert Acknowledge Control</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SI</name>
              <description>I2C Interrupt Flag\nWhen a new I2C state is present in the I2CSTATUS register, the SI flag is set by hardware, and if bit EI (I2CON [7]) is set, the I2C interrupt is requested. SI must be cleared by software. Clear SI by writing 1 to this bit.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STO</name>
              <description>I2C STOP Control\nIn Master mode, setting STO to transmit a STOP condition to bus then I2C hardware will check the bus condition if a STOP condition is detected this bit will be cleared by hardware automatically. In a slave mode, setting STO resets I2C hardware to the defined 'not addressed' slave mode. This means it is NO LONGER in the slave receiver mode to receive data from the master transmit device.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STA</name>
              <description>I2C START Control\nSetting STA to logic 1 to enter Master mode, the I2C hardware sends a START or repeat START condition to bus when the bus is free.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENS1</name>
              <description>I2C Controller Enable Control</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EI</name>
              <description>Interrupt Enable Control</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I2C interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2C interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2CADDR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CADDR0</displayName>
          <description>I2C Slave Address Register0</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GC</name>
              <description>General Call Function</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>General Call Function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>General Call Function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>I2CADDR</name>
              <description>I2C Address Register\nThe content of this register is irrelevant when I2C is in Master mode. In the slave mode, the seven most significant bits must be loaded with the chip's own address. The I2C hardware will react if either of the address is matched.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2CDAT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CDAT</displayName>
          <description>I2C Data Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>I2CDAT</name>
              <description>I2C Data Register\nThis field is located with the 8-bit transferred data of I2C serial port.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2CSTATUS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CSTATUS</displayName>
          <description>I2C Status Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-only</access>
          <resetValue>0x000000F8</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>I2CSTATUS</name>
              <description>I2C Status Register\nThere are 26 possible status codes. \nWhen I2CSTATUS contains 0xF8, no serial interrupt is requested. \nIn addition, states 0x00 stands for a Bus Error. A Bus Error occurs when a START or STOP condition is present at an illegal position in the formation frame. Example of illegal position are during the serial transfer of an address byte, a data byte or an acknowledge bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2CLK</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CLK</displayName>
          <description>I2C Clock Divided Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>I2CLK</name>
              <description>I2C Clock Divided Register\nNote: The minimum value of I2CLK is 4.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2CTOC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CTOC</displayName>
          <description>I2C Time-out Counter Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TIF</name>
              <description>Time-Out Flag\nThis bit is set by hardware when I2C time-out happened and it can interrupt CPU if I2C interrupt enable bit EI (I2CON[7]) is set to 1.\nNote: Write 1 to clear this bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIV4</name>
              <description>Time-Out Counter Input Clock Divided By 4\nWhen Enabled, The time-out period is extend 4 times.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ENTI</name>
              <description>Time-Out Counter Enable Control \nWhen Enabled, the 14-bit time-out counter will start counting when SI (I2CON[3]) is clear. Setting flag SI SI(I2CON[3]) to high will reset counter and re-start up counting after SI SI(I2CON[3]) is cleared.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="I2CADDR0">
          <name>I2CADDR1</name>
          <displayName>I2CADDR1</displayName>
          <description>I2C Slave Address Register1</description>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="I2CADDR0">
          <name>I2CADDR2</name>
          <displayName>I2CADDR2</displayName>
          <description>I2C Slave Address Register2</description>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="I2CADDR0">
          <name>I2CADDR3</name>
          <displayName>I2CADDR3</displayName>
          <description>I2C Slave Address Register3</description>
          <addressOffset>0x20</addressOffset>
       </register>
       <register>
          <name>I2CADM0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CADM0</displayName>
          <description>I2C Slave Address Mask Register0</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>I2CADM</name>
              <description>I2C Address Mask Register\nI2C bus controllers support multiple address recognition with four address mask register. When the bit in the address mask register is set to one, it means the received corresponding address bit is don't-care. If the bit is set to zero, that means the received corresponding register bit should be exact the same as address register.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>7</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Mask Disabled (the received corresponding register bit should be exact the same as address register.)</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Mask Enabled (the received corresponding address bit is don't care.)</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="I2CADM0">
          <name>I2CADM1</name>
          <displayName>I2CADM1</displayName>
          <description>I2C Slave Address Mask Register1</description>
          <addressOffset>0x28</addressOffset>
       </register>
       <register derivedFrom="I2CADM0">
          <name>I2CADM2</name>
          <displayName>I2CADM2</displayName>
          <description>I2C Slave Address Mask Register2</description>
          <addressOffset>0x2C</addressOffset>
       </register>
       <register derivedFrom="I2CADM0">
          <name>I2CADM3</name>
          <displayName>I2CADM3</displayName>
          <description>I2C Slave Address Mask Register3</description>
          <addressOffset>0x30</addressOffset>
       </register>
       <register>
          <name>I2CWKUPCON</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CWKUPCON</displayName>
          <description>I2C Wake-up Control Register</description>
          <addressOffset>0x3C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WKUPEN</name>
              <description>I2C Wake-Up Enable Control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I2C wake-up function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2C wake-up function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2CWKUPSTS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CWKUPSTS</displayName>
          <description>I2C Wake-up Status Register</description>
          <addressOffset>0x40</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WKUPIF</name>
              <description>I2C Wake-Up Flag\nNote: Software can write 1 to clear this bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Chip is not woken-up from Power-down mode by I2C</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Chip is woken-up from Power-down mode by I2C</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>I2C1</name>
      <description>I2C Register Map</description>
      <groupName>I2C</groupName>
      <baseAddress>0x40120000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x34</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x3C</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>I2CON</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CON</displayName>
          <description>I2C Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AA</name>
              <description>Assert Acknowledge Control</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SI</name>
              <description>I2C Interrupt Flag\nWhen a new I2C state is present in the I2CSTATUS register, the SI flag is set by hardware, and if bit EI (I2CON [7]) is set, the I2C interrupt is requested. SI must be cleared by software. Clear SI by writing 1 to this bit.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STO</name>
              <description>I2C STOP Control\nIn Master mode, setting STO to transmit a STOP condition to bus then I2C hardware will check the bus condition if a STOP condition is detected this bit will be cleared by hardware automatically. In a slave mode, setting STO resets I2C hardware to the defined 'not addressed' slave mode. This means it is NO LONGER in the slave receiver mode to receive data from the master transmit device.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STA</name>
              <description>I2C START Control\nSetting STA to logic 1 to enter Master mode, the I2C hardware sends a START or repeat START condition to bus when the bus is free.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENS1</name>
              <description>I2C Controller Enable Control</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EI</name>
              <description>Interrupt Enable Control</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I2C interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2C interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2CADDR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CADDR0</displayName>
          <description>I2C Slave Address Register0</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GC</name>
              <description>General Call Function</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>General Call Function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>General Call Function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>I2CADDR</name>
              <description>I2C Address Register\nThe content of this register is irrelevant when I2C is in Master mode. In the slave mode, the seven most significant bits must be loaded with the chip's own address. The I2C hardware will react if either of the address is matched.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2CDAT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CDAT</displayName>
          <description>I2C Data Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>I2CDAT</name>
              <description>I2C Data Register\nThis field is located with the 8-bit transferred data of I2C serial port.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2CSTATUS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CSTATUS</displayName>
          <description>I2C Status Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-only</access>
          <resetValue>0x000000F8</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>I2CSTATUS</name>
              <description>I2C Status Register\nThere are 26 possible status codes. \nWhen I2CSTATUS contains 0xF8, no serial interrupt is requested. \nIn addition, states 0x00 stands for a Bus Error. A Bus Error occurs when a START or STOP condition is present at an illegal position in the formation frame. Example of illegal position are during the serial transfer of an address byte, a data byte or an acknowledge bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2CLK</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CLK</displayName>
          <description>I2C Clock Divided Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>I2CLK</name>
              <description>I2C Clock Divided Register\nNote: The minimum value of I2CLK is 4.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2CTOC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CTOC</displayName>
          <description>I2C Time-out Counter Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TIF</name>
              <description>Time-Out Flag\nThis bit is set by hardware when I2C time-out happened and it can interrupt CPU if I2C interrupt enable bit EI (I2CON[7]) is set to 1.\nNote: Write 1 to clear this bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIV4</name>
              <description>Time-Out Counter Input Clock Divided By 4\nWhen Enabled, The time-out period is extend 4 times.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ENTI</name>
              <description>Time-Out Counter Enable Control \nWhen Enabled, the 14-bit time-out counter will start counting when SI (I2CON[3]) is clear. Setting flag SI SI(I2CON[3]) to high will reset counter and re-start up counting after SI SI(I2CON[3]) is cleared.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="I2CADDR0">
          <name>I2CADDR1</name>
          <displayName>I2CADDR1</displayName>
          <description>I2C Slave Address Register1</description>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="I2CADDR0">
          <name>I2CADDR2</name>
          <displayName>I2CADDR2</displayName>
          <description>I2C Slave Address Register2</description>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="I2CADDR0">
          <name>I2CADDR3</name>
          <displayName>I2CADDR3</displayName>
          <description>I2C Slave Address Register3</description>
          <addressOffset>0x20</addressOffset>
       </register>
       <register>
          <name>I2CADM0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CADM0</displayName>
          <description>I2C Slave Address Mask Register0</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>I2CADM</name>
              <description>I2C Address Mask Register\nI2C bus controllers support multiple address recognition with four address mask register. When the bit in the address mask register is set to one, it means the received corresponding address bit is don't-care. If the bit is set to zero, that means the received corresponding register bit should be exact the same as address register.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>7</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Mask Disabled (the received corresponding register bit should be exact the same as address register.)</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Mask Enabled (the received corresponding address bit is don't care.)</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="I2CADM0">
          <name>I2CADM1</name>
          <displayName>I2CADM1</displayName>
          <description>I2C Slave Address Mask Register1</description>
          <addressOffset>0x28</addressOffset>
       </register>
       <register derivedFrom="I2CADM0">
          <name>I2CADM2</name>
          <displayName>I2CADM2</displayName>
          <description>I2C Slave Address Mask Register2</description>
          <addressOffset>0x2C</addressOffset>
       </register>
       <register derivedFrom="I2CADM0">
          <name>I2CADM3</name>
          <displayName>I2CADM3</displayName>
          <description>I2C Slave Address Mask Register3</description>
          <addressOffset>0x30</addressOffset>
       </register>
       <register>
          <name>I2CWKUPCON</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CWKUPCON</displayName>
          <description>I2C Wake-up Control Register</description>
          <addressOffset>0x3C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WKUPEN</name>
              <description>I2C Wake-Up Enable Control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I2C wake-up function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2C wake-up function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2CWKUPSTS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CWKUPSTS</displayName>
          <description>I2C Wake-up Status Register</description>
          <addressOffset>0x40</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WKUPIF</name>
              <description>I2C Wake-Up Flag\nNote: Software can write 1 to clear this bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Chip is not woken-up from Power-down mode by I2C</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Chip is woken-up from Power-down mode by I2C</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SPI0</name>
      <description>SPI Register Map</description>
      <groupName>SPI</groupName>
      <baseAddress>0x40030000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0xC</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x10</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x20</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x34</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x3C</offset>
        <size>0xC</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>SPI_CNTRL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_CNTRL</displayName>
          <description>Control and Status Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x05003004</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GO_BUSY</name>
              <description>SPI Transfer Control Bit And Busy Status\nIf FIFO mode is disabled, during the data transfer, this bit keeps the value of 1. As the transfer is finished, this bit will be cleared automatically. Software can read this bit to check if the SPI is in busy status.\nIn FIFO mode, this bit will be controlled by hardware. Software should not modify this bit. In Slave mode, this bit always returns 1 when this register is read by software. In Master mode, this bit reflects the busy or idle status of SPI.\nNote: When FIFO mode is disabled, all configurations should be set before writing 1 to this GO_BUSY bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Data transfer stopped</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>In Master mode, writing 1 to this bit to start the SPI data transfer; in Slave mode, writing 1 to this bit indicates that the slave is ready to communicate with a master</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_NEG</name>
              <description>Receive On Negative Edge</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Received data input signal is latched on the rising edge of SPI bus clock</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Received data input signal is latched on the falling edge of SPI bus clock</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_NEG</name>
              <description>Transmit On Negative Edge</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmitted data output signal is changed on the rising edge of SPI bus clock</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmitted data output signal is changed on the falling edge of SPI bus clock</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_BIT_LEN</name>
              <description>Transmit Bit Length\nThis field specifies how many bits can be transmitted/received in one transaction. The minimum bit length is 8 bits and can up to 32 bits.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LSB</name>
              <description>Send LSB First</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The MSB, which bit of transmit/receive register depends on the setting of TX_BIT_LEN, is transmitted/received first</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The LSB, bit 0 of the SPI TX0/1 register, is sent first to the SPI data output pin, and the first bit received from the SPI data input pin will be put in the LSB position of the RX register (bit 0 of SPI_RX0/1)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLKP</name>
              <description>Clock Polarity</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPI bus clock is idle low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI bus clock is idle high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SP_CYCLE</name>
              <description>Suspend Interval (Master Only)\nThe four bits provide configurable suspend interval between two successive transmit/receive transaction in a transfer. The definition of the suspend interval is the interval between the last clock edge of the preceding transaction word and the first clock edge of the following transaction word. The default value is 0x3. The period of the suspend interval is obtained according to the following equation.\n (SP_CYCLE[3:0] + 0.5) * period of SPI bus clock cycle\nExample:\nIf the variable clock function is enabled and the transmit FIFO buffer is not empty, the minimum period of suspend interval between the successive transactions is (6.5 + SP_CYCLE) * SPI bus clock cycle.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IF</name>
              <description>Unit Transfer Interrupt Flag\nNote: This bit will be cleared by writing 1 to itself.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No transaction has been finished since this bit was cleared to 0</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI controller has finished one unit transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IE</name>
              <description>Unit Transfer Interrupt EnableBit</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPI unit transfer interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI unit transfer interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLAVE</name>
              <description>Slave Mode EnableBit</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Master mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Slave mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>REORDER</name>
              <description>Byte Reorder Function EnableBit\nNote:\nByte Reorder function is only available if TX_BIT_LEN is defined as 16, 24, and 32 bits.\nIn Slave mode with level-trigger configuration, the slave select pin must be kept at active state during the byte suspend interval.\nThe Byte Reorder function is not supported when the variable bus clock function or Dual I/O mode is enabled.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Byte Reorder function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Byte Reorder function Enabled. A byte suspend interval will be inserted among each byte. The period of the byte suspend interval depends on the setting of SP_CYCLE</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FIFO</name>
              <description>FIFO Mode Enable Control\nNote:\nBefore enabling FIFO mode, the other related settings should be set in advance.\nIn Master mode, if the FIFO mode is enabled, the GO_BUSY bit will be set to 1 automatically after writing data to the transmit FIFO buffer; the GO_BUSY bit will be cleared to 0 automatically when the SPI controller is in idle. If all data stored at transmit FIFO buffer are sent out, the TX_EMPTY bit will be set to 1 and the GO_BUSY bit will be cleared to 0.\nAfter clearing this bit to 0, user must wait for at least 2 peripheral clock periods before setting this bit to 1 again.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>FIFO mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>FIFO mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>VARCLK_EN</name>
              <description>Variable Clock Enable Control (Master Only)\nNote: When this VARCLK_EN bit is set to 1, the setting of TX_BIT_LEN must be programmed as 0x10 (16-bit mode).</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPI clock output frequency is fixed and decided only by the value of DIVIDER</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI clock output frequency is variable. The output frequency is decided by the value of VARCLK, DIVIDER, and DIVIDER2</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_EMPTY</name>
              <description>Receive FIFO Buffer Empty Indicator (Read Only)\nIt is a mutual mirror bit of SPI_STATUS[24].</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receive FIFO buffer is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receive FIFO buffer is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_FULL</name>
              <description>Receive FIFO Buffer Full Indicator (Read Only)\nIt is a mutual mirror bit of SPI_STATUS[25].</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receive FIFO buffer is not full</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receive FIFO buffer is full</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_EMPTY</name>
              <description>Transmit FIFO Buffer Empty Indicator (Read Only)\nIt is a mutual mirror bit of SPI_STATUS[26].</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmit FIFO buffer is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmit FIFO buffer is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_FULL</name>
              <description>Transmit FIFO Buffer Full Indicator (Read Only)\nIt is a mutual mirror bit of SPI_STATUS[27].</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmit FIFO buffer is not full</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmit FIFO buffer is full</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_DIVIDER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_DIVIDER</displayName>
          <description>Clock Divider Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DIVIDER</name>
              <description>Clock Divider 1 Register \nThe value in this field is the frequency divider for generating the SPI peripheral clock, fspi_eclk, and the SPI bus clock of SPI master. The frequency is obtained according to the following equation. \nIf the bit of BCn, SPI_CNTRL2[31], is set to 0,\n\nelse if BCn is set to 1,\n\nwhere \n is the SPI peripheral clock source, which is defined in the CLKSEL1 register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIVIDER2</name>
              <description>Clock Divider 2 Register (Master Only)\nThe value in this field is the 2nd frequency divider for generating the second clock of the variable clock function. The frequency is obtained according to the following equation: \n\nIf the VARCLK_EN bit is cleared to 0, this setting is unmeaning.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_SSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_SSR</displayName>
          <description>Slave Select Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SSR</name>
              <description>Slave Select Control Bit (Master Only)\nIf AUTOSS bit is cleared, writing 1 to any bit of this field sets the proper SPI0_SPISS0 line to an active state and writing 0 sets the line back to inactive state.\nIf the AUTOSS bit is set, writing 0 to any bit location of this field will keep the corresponding SPI0_SPISS0 line at inactive state; writing 1 to any bit location of this field will select appropriate SPI0_SPISS0 line to be automatically driven to active state for the duration of the transmit/receive, and will be driven to inactive state for the rest of the time. The active state of SPI0_SPISS0 is specified in SS_LVL. \nNote: SPI0_SPISS0 is defined as the slave select input in Slave mode.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SS_LVL</name>
              <description>Slave Select Active Level\nThis bit defines the active status of slave select signal (SPI0_SPISS0).</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The slave select signal SPI0_SPISS0 is active on low-level/falling-edge</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The slave select signal SPI0_SPISS0 is active on high-level/rising-edge</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTOSS</name>
              <description>Automatic Slave Select Function Enable Control (Master Only)</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>If this bit is cleared, slave select signal will be asserted/de-asserted by setting /clearing the corresponding bit of SPI_SSR[0]</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>If this bit is set, SPI0_SPISS0 signal will be generated automatically. It means that device/slave select signal, which is set in SPI_SSR[0], will be asserted by the SPI controller when transmit/receive is started, and will be de-asserted after each transmit/receive is finished</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SS_LTRIG</name>
              <description>Slave Select Level Trigger Enable Control (Slave Only)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Slave select signal is edge-trigger. This is the default value. The SS_LVL bit decides the signal is active after a falling-edge or rising-edge</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Slave select signal is level-trigger. The SS_LVL bit decides the signal is active low or active high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LTRIG_FLAG</name>
              <description>Level Trigger Accomplish Flag\nIn Slave mode, this bit indicates whether the received bit number meets the requirement or not after the current transaction done. \nNote: This bit is READ only. As the GO_BUSY bit is set to 1 by software, the LTRIG_FLAG will be cleared to 0 after 4 SPI peripheral clock periods plus 1 system clock period. In FIFO mode, this bit has no meaning.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transferred bit length of one transaction does not meet the specified requirement</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transferred bit length meets the specified requirement which defined in TX_BIT_LEN</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_RX0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_RX0</displayName>
          <description>Data Receive Register 0</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX</name>
              <description>Data Receive Register\nThe data receive register holds the datum received from SPI data input pin. If FIFO mode is disabled, the last received data can be accessed through software by reading this register. If the FIFO bit is set as 1 and the RX_EMPTY bit, SPI_CNTRL[24] or SPI_STATUS[24], is not set to 1, the receive FIFO buffer can be accessed through software by reading this register. This is a read-only register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="SPI_RX0">
          <name>SPI_RX1</name>
          <displayName>SPI_RX1</displayName>
          <description>Data Receive Register 1</description>
          <addressOffset>0x14</addressOffset>
       </register>
       <register>
          <name>SPI_TX0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_TX0</displayName>
          <description>Data Transmit Register 0</description>
          <addressOffset>0x20</addressOffset>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX</name>
              <description>Data Transmit Register\nThe data transmit registers hold the data to be transmitted in the next transfer. The number of valid bits depends on the setting of transmit bit length field of the SPI_CNTRL register.\nFor example, if TX_BIT_LEN is set to 0x08, the bits TX[7:0] will be transmitted in next transfer. If TX_BIT_LEN is set to 0x00, the SPI controller will perform a 32-bit transfer.\nNote 1: When the SPI controller is configured as a slave device and FIFO mode is disabled, if the SPI controller attempts to transmit data to a master, the transmit data register should be updated by software before setting the GO_BUSY bit to 1.\nNote 2: In Master mode, SPI controller will start to transfer after 5 peripheral clock cycles since user wrote to this register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="SPI_TX0">
          <name>SPI_TX1</name>
          <displayName>SPI_TX1</displayName>
          <description>Data Transmit Register 1</description>
          <addressOffset>0x24</addressOffset>
       </register>
       <register>
          <name>SPI_VARCLK</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_VARCLK</displayName>
          <description>Variable Clock Pattern Register</description>
          <addressOffset>0x34</addressOffset>
          <access>read-write</access>
          <resetValue>0x007FFF87</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VARCLK</name>
              <description>Variable Clock Pattern\nThis register defines the clock pattern of the SPI transfer. If the variable clock function is disabled, this setting is unmeaning. Refer to the 'Variable Clock Function' paragraph for more detail description.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_CNTRL2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_CNTRL2</displayName>
          <description>Control and Status Register 2</description>
          <addressOffset>0x3C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00001000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NOSLVSEL</name>
              <description>Slave 3-Wire Mode Enable Control\nThis is used to ignore the slave select signal in Slave mode. The SPI controller can work with 3-wire interface including SPI0_CLK, SPI0_MISO0 and SPI0_MOSI0 pins.\nNote: In Slave 3-wire mode, the SS_LTRIG, SPI_SSR[4] will be set as 1 automatically.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>4-wire bi-direction interface</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>3-wire bi-direction interface</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLV_ABORT</name>
              <description>Slave 3-Wire Mode Abort Control\nIn normal operation, there is an interrupt event when the received data meet the required bits which defined in TX_BIT_LEN.\nIf the received bits are less than the requirement and there is no more SPI clock input over the one transfer time in Slave 3-wire mode, the user can set this bit to force the current transfer done and then the user can get a transfer done interrupt event. \nNote: This bit will be cleared to 0 automatically by hardware after it is set to 1 by software.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SSTA_INTEN</name>
              <description>Slave 3-Wire Mode Start Interrupt Enable Control\nUsed to enable interrupt when the transfer has started in Slave 3-wire mode. If there is no transfer done interrupt over the time period which is defined by user after the transfer start, the user can set the SLV_ABORT bit to force the transfer done.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transaction start interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transaction start interrupt Enabled. It will be cleared to 0 as the current transfer is done or the SLV_START_INTSTS bit is cleared</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLV_START_INTSTS</name>
              <description>Slave 3-Wire Mode Start Interrupt Status\nThis bit indicates if a transaction has started in Slave 3-wire mode. It is a mutual mirror bit of SPI_STATUS[11].</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Slave has not detected any SPI clock transition since the SSTA_INTEN bit was set to 1</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>A transaction has started in Slave 3-wire mode. It will be cleared automatically when a transaction is done or by writing 1 to this bit</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DUAL_IO_DIR</name>
              <description>Dual I/O Mode Direction Control</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Dual Input mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Dual Output mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DUAL_IO_EN</name>
              <description>Dual I/O Mode EnableBit</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Dual I/O mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Dual I/O mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SS_INT_OPT</name>
              <description>Slave Select Inactive Interrupt Option \nThis setting is only available if the SPI controller is configured as level trigger slave device.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>As the slave select signal goes to inactive level, the IF bit will NOT be set to 1</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>As the slave select signal goes to inactive level, the IF bit will be set to 1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BCn</name>
              <description>SPI Peripheral Clock Backward Compatible Option\nRefer to the description of SPI_DIVIDER register for details.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Backward compatible clock configuration</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock configuration is not backward compatible</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_FIFO_CTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_FIFO_CTL</displayName>
          <description>SPI FIFO Control Register</description>
          <addressOffset>0x40</addressOffset>
          <access>read-write</access>
          <resetValue>0x44000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX_CLR</name>
              <description>Clear Receive FIFO Buffer</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clear receive FIFO buffer. The RX_FULL flag will be cleared to 0 and the RX_EMPTY flag will be set to 1. This bit will be cleared to 0 by hardware after it is set to 1 by software</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_CLR</name>
              <description>Clear Transmit FIFO Buffer</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clear transmit FIFO buffer. The TX_FULL flag will be cleared to 0 and the TX_EMPTY flag will be set to 1. This bit will be cleared to 0 by hardware after it is set to 1 by software</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_INTEN</name>
              <description>Receive Threshold Interrupt Enable Control</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX threshold interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX threshold interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_INTEN</name>
              <description>Transmit Threshold Interrupt Enable Control</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX threshold interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX threshold interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXOV_INTEN</name>
              <description>Receive FIFO Overrun Interrupt Enable Control</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receive FIFO overrun interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receive FIFO overrun interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMEOUT_INTEN</name>
              <description>Receive FIFO Time-Out Interrupt Enable Control</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Time-out interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time-out interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_THRESHOLD</name>
              <description>Receive FIFO Threshold\nIf the valid data count of the receive FIFO buffer is larger than the RX_THRESHOLD setting, the RX_INTSTS bit will be set to 1, else the RX_INTSTS bit will be cleared to 0.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_THRESHOLD</name>
              <description>Transmit FIFO Threshold\nIf the valid data count of the transmit FIFO buffer is less than or equal to the TX_THRESHOLD setting, the TX_INTSTS bit will be set to 1, else the TX_INTSTS bit will be cleared to 0.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_STATUS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_STATUS</displayName>
          <description>SPI Status Register</description>
          <addressOffset>0x44</addressOffset>
          <access>read-write</access>
          <resetValue>0x05000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX_INTSTS</name>
              <description>Receive FIFO Threshold Interrupt Status (Read Only)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The valid data count within the Rx FIFO buffer is less than or equal to the setting value of RX_THRESHOLD</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The valid data count within the receive FIFO buffer is larger than the setting value of RX_THRESHOLD</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_OVERRUN</name>
              <description>Receive FIFO Overrun Status\nWhen the receive FIFO buffer is full, the follow-up data will be dropped and this bit will be set to 1.\nNote: This bit will be cleared by writing 1 to itself.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_INTSTS</name>
              <description>Transmit FIFO Threshold Interrupt Status (Read Only)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The valid data count within the transmit FIFO buffer is larger than the setting value of TX_THRESHOLD</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The valid data count within the transmit FIFO buffer is less than or equal to the setting value of TX_THRESHOLD</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>SLV_START_INTSTS</name>
              <description>Slave Start Interrupt Status\nIt is used to dedicate if a transaction has started in Slave 3-wire mode. It is a mutual mirror bit of SPI_CNTRL2[11].</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Slave has not detected any SPI clock transition since the SSTA_INTEN bit was set to 1</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>A transaction has started in Slave 3-wire mode. It will be cleared as a transaction is done or by writing 1 to this bit</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_FIFO_COUNT</name>
              <description>Receive FIFO Data Count (Read Only)\nThis bit field indicates the valid data count of receive FIFO buffer.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>IF</name>
              <description>SPI Unit Transfer Interrupt Flag\nIt is a mutual mirror bit of SPI_CNTRL[16].\nNote: This bit will be cleared by writing 1 to itself.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No transaction has been finished since this bit was cleared to 0</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI controller has finished one unit transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMEOUT</name>
              <description>Time-Out Interrupt Flag\nNote: This bit will be cleared by writing 1 to itself.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No receive FIFO time-out event</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receive FIFO buffer is not empty and no read operation on receive FIFO buffer over 64 SPI clock period in Master mode or over 576 SPI peripheral clock period in Slave mode. When the received FIFO buffer is read by software, the time-out status will be cleared automatically</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_EMPTY</name>
              <description>Receive FIFO Buffer Empty Indicator (Read Only)\nIt is a mutual mirror bit of SPI_CNTRL[24].</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receive FIFO buffer is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receive FIFO buffer is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_FULL</name>
              <description>Receive FIFO Buffer Empty Indicator (Read Only)\nIt is a mutual mirror bit of SPI_CNTRL[25].</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receive FIFO buffer is not full</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receive FIFO buffer is full</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_EMPTY</name>
              <description>Transmit FIFO Buffer Empty Indicator (Read Only)\nIt is a mutual mirror bit of SPI_CNTRL[26].</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmit FIFO buffer is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmit FIFO buffer is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_FULL</name>
              <description>Transmit FIFO Buffer Full Indicator (Read Only)\nIt is a mutual mirror bit of SPI_CNTRL[27].</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmit FIFO buffer is not full</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmit FIFO buffer is full</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_FIFO_COUNT</name>
              <description>Transmit FIFO Data Count (Read Only)\nThis bit field indicates the valid data count of transmit FIFO buffer.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>CAN0</name>
      <description>CAN Register Map</description>
      <groupName>CAN</groupName>
      <baseAddress>0x40180000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1C</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x20</offset>
        <size>0x2C</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x80</offset>
        <size>0x2C</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x100</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x120</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x140</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x160</offset>
        <size>0x10</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>CAN_CON</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_CON</displayName>
          <description>Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>Init</name>
              <description>Init Initialization</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Normal Operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Initialization is started</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IE</name>
              <description>Module Interrupt Enable Control</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SIE</name>
              <description>Status Change Interrupt Enable Control</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled - No Status Change Interrupt will be generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled - An interrupt will be generated when a message transfer is successfully completed or a CAN bus error is detected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EIE</name>
              <description>Error Interrupt Enable Control</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled - No Error Status Interrupt will be generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled - A change in the bits BOff (CAN_STATUS[7]) or EWarn (CAN_STATUS[6]) in the Status Register will generate an interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DAR</name>
              <description>Automatic Re-Transmission Disable Control</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Automatic Retransmission of disturbed messages Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Automatic Retransmission Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CCE</name>
              <description>Configuration Change Enable Control</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No write access to the Bit Timing Register</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Write access to the Bit Timing Register (CAN_BTIME) allowed. (while Init bit (CAN_CON[0]) = 1)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>Test</name>
              <description>Test Mode Enable Control</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Normal Operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Test Mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_STATUS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_STATUS</displayName>
          <description>Status Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LEC</name>
              <description>Last Error Code (Type Of The Last Error To Occur On The CAN Bus)\nThe LEC field holds a code, which indicates the type of the last error to occur on the CAN bus. This field will be cleared to '0' when a message has been transferred (reception or transmission) without error. The unused code '7' may be written by the CPU to check for updates. The following table describes the error code.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TxOK</name>
              <description>Transmitted A Message Successfully</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Since this bit was reset by the CPU, no message has been successfully transmitted. This bit is never reset by the CAN Core</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Since this bit was last reset by the CPU, a message has been successfully (error free and acknowledged by at least one other node) transmitted</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RxOK</name>
              <description>Received A Message Successfully</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No message has been successfully received since this bit was last reset by the CPU. This bit is never reset by the CAN Core</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>A message has been successfully received since this bit was last reset by the CPU (independent of the result of acceptance filtering)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EPass</name>
              <description>Error Passive (Read Only)</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The CAN Core is error active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The CAN Core is in the error passive state as defined in the CAN Specification</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>EWarn</name>
              <description>Error Warning Status (Read Only)</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Both error counters are below the error warning limit of 96</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>At least one of the error counters in the EML has reached the error warning limit of 96</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BOff</name>
              <description>Bus-Off Status (Read Only) </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The CAN module is not in bus-off state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The CAN module is in bus-off state</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_ERR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_ERR</displayName>
          <description>Error Counter Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TEC</name>
              <description>Transmit Error Counter\nActual state of the Transmit Error Counter. Values between 0 and 255.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>REC</name>
              <description>Receive Error Counter\nActual state of the Receive Error Counter. Values between 0 and 127.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RP</name>
              <description>Receive Error Passive</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The Receive Error Counter is below the error passive level</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The Receive Error Counter has reached the error passive level as defined in the CAN Specification</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_BTIME</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_BTIME</displayName>
          <description>Bit Timing Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00002301</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BRP</name>
              <description>Baud Rate Prescaler \n0x01-0x3F: The value by which the oscillator frequency is divided for generating the bit time quanta. The bit time is built up from a multiple of this quantum. Valid values for the Baud Rate Prescaler are [0...63]. The actual interpretation by the hardware of this value is such that one more than the value programmed here is used.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SJW</name>
              <description>(Re)Synchronization Jump Width\n0x0-0x3: Valid programmed values are [0...3]. The actual interpretation by the hardware of this value is such that one more than the value programmed here is used.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSeg1</name>
              <description>Time Segment Before The Sample Point Minus Sync_Seg\n0x01-0x0F: valid values for TSeg1 are [1...15]. The actual interpretation by the hardware of this value is such that one more than the value programmed is used.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSeg2</name>
              <description>Time Segment After Sample Point \n0x0-0x7: Valid values for TSeg2 are [0...7]. The actual interpretation by the hardware of this value is such that one more than the value programmed here is used.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_IIDR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_IIDR</displayName>
          <description>Interrupt Identifier Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IntId</name>
              <description>Interrupt Identifier (Indicates The Source Of The Interrupt)\nIf several interrupts are pending, the CAN Interrupt Register will point to the pending interrupt with the highest priority, disregarding their chronological order. An interrupt remains pending until the application software has cleared it. If IntId is different from 0x0000 and IE (CAN_IFn_MCON[1]) is set, the IRQ interrupt signal to the EIC is active. The interrupt remains active until IntId is back to value 0x0000 (the cause of the interrupt is reset) or until IE is reset.\nThe Status Interrupt has the highest priority. Among the message interrupts, the Message Object' s interrupt priority decreases with increasing message number.\nA message interrupt is cleared by clearing the Message Object's IntPnd bit (CAN_IFn_MCON[13]). The Status Interrupt is cleared by reading the Status Register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_TEST</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_TEST</displayName>
          <description>Test Register (Register Map Note 1)</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000080</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>Basic</name>
              <description>Basic Mode</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Basic Mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>IF1 Registers used as Tx Buffer, IF2 Registers used as Rx Buffer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>Silent</name>
              <description>Silent Mode</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The module is in Silent Mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LBack</name>
              <description>Loop Back Mode Enable Control</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Loop Back Mode is Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Loop Back Mode is Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>Tx</name>
              <description>Tx[1:0]: Control Of CAN_TX Pin</description>
              <bitOffset>5</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Reset value, CAN_TX pin is controlled by the CAN Core</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Sample Point can be monitored at CAN_TX pin</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>CAN_TX pin drives a dominant ('0') value</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>CAN_TX pin drives a recessive ('1') value</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>Rx</name>
              <description>Monitors The Actual Value Of CAN_RX Pin (Read Only) </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The CAN bus is dominant (CAN_RX = '0')</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The CAN bus is recessive (CAN_RX = '1')</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_BRPE</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_BRPE</displayName>
          <description>Baud Rate Prescaler Extension Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BRPE</name>
              <description>Baud Rate Prescaler Extension\n0x00-0x0F: By programming BRPE, the Baud Rate Prescaler can be extended to values up to 1023. The actual interpretation by the hardware is that one more than the value programmed by BRPE (MSBs) and BTIME (LSBs) is used.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_IF1_CREQ</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_IF1_CREQ</displayName>
          <description>IF1 (Register Map Note 2) Command Request Registers</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MessageNumber</name>
              <description>Message Number\n0x01-0x20: Valid Message Number, the Message Object in the Message.\nRAM is selected for data transfer.\n0x00: Not a valid Message Number, interpreted as 0x20.\n0x21-0x3F: Not a valid Message Number, interpreted as 0x01-0x1F.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>Busy</name>
              <description>Busy Flag</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Read/write action has finished</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Writing to the IFn Command Request Register is in progress. This bit can only be read by the software</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_IF1_CMASK</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_IF1_CMASK</displayName>
          <description>IF1 Command Mask Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DAT_B</name>
              <description>Access Data Bytes [7:4]\nWrite Operation: </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Data Bytes [7:4] unchanged</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transfer Data Bytes [7:4] to Message Object.\nTransfer Data Bytes [7:4] to IFn Message Buffer Register</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DAT_A</name>
              <description>Access Data Bytes [3:0]\nWrite Operation:</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Data Bytes [3:0] unchanged</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transfer Data Bytes [3:0] to Message Object.\nTransfer Data Bytes [3:0] to IFn Message Buffer Register</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TxRqst_NewDat</name>
              <description>Access Transmission Request Bit When Write Operation\nNote: A read access to a Message Object can be combined with the reset of the control bits IntPnd and NewDat. The values of these bits transferred to the IFn Message Control Register always reflect the status before resetting these bits.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TxRqst bit unchanged.\nNewDat bit remains unchanged</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Set TxRqst bit.\nClear NewDat bit in the Message Object</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ClrIntPnd</name>
              <description>Clear Interrupt Pending Bit\nWrite Operation:\nWhen writing to a Message Object, this bit is ignored.\nRead Operation:</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>IntPnd bit (CAN_IFn_MCON[13]) remains unchanged</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clear IntPnd bit in the Message Object</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>Control</name>
              <description>Control Access Control Bit\nWrite Operation:</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Control Bits unchanged</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transfer Control Bits to Message Object.\nTransfer Control Bits to IFn Message Buffer Register</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>Arb</name>
              <description>Access Arbitration Bits\nWrite Operation:</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Arbitration bits unchanged</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transfer Identifier + Dir (CAN_IFn_ARB2[13]) + Xtd (CAN_IFn_ARB2[14]) + MsgVal (CAN_IFn_ARB2[15]) to Message Object.\nTransfer Identifier + Dir + Xtd + MsgVal to IFn Message Buffer Register</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>Mask</name>
              <description>Access Mask Bits\nWrite Operation:</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Mask bits unchanged</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transfer Identifier Mask + MDir + MXtd to Message Object.\nTransfer Identifier Mask + MDir + MXtd to IFn Message Buffer Register</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WR_RD</name>
              <description>Write / Read Mode</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Read: Transfer data from the Message Object addressed by the Command Request Register into the selected Message Buffer Registers</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Write: Transfer data from the selected Message Buffer Registers to the Message Object addressed by the Command Request Register</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_IF1_MASK1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_IF1_MASK1</displayName>
          <description>IF1 Mask 1 Register</description>
          <addressOffset>0x28</addressOffset>
          <access>read-write</access>
          <resetValue>0x0000FFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>Msk15_0</name>
              <description>Identifier Mask 15-0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The corresponding bit in the identifier of the message object cannot inhibit the match in the acceptance filtering</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The corresponding identifier bit is used for acceptance filtering</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_IF1_MASK2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_IF1_MASK2</displayName>
          <description>IF1 Mask 2 Register</description>
          <addressOffset>0x2C</addressOffset>
          <access>read-write</access>
          <resetValue>0x0000FFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>Msk28_16</name>
              <description>Identifier Mask 28-16</description>
              <bitOffset>0</bitOffset>
              <bitWidth>13</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The corresponding bit in the identifier of the message object cannot inhibit the match in the acceptance filtering</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The corresponding identifier bit is used for acceptance filtering</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MDir</name>
              <description>Mask Message Direction</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The message direction bit (Dir (CAN_IFn_ARB2[13])) has no effect on the acceptance filtering</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The message direction bit (Dir) is used for acceptance filtering</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MXtd</name>
              <description>Mask Extended Identifier\nNote: When 11-bit  ('standard')  Identifiers  are  used  for  a  Message Object, the identifiers of received Data Frames are written into bits ID28 to ID18 (CAN_IFn_ARB2[12:2]). For acceptance filtering, only these bits together with mask bits Msk28 to Msk18 (CAN_IFn_MASK2[12:2]) are considered.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The extended identifier bit (IDE) has no effect on the acceptance filtering</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The extended identifier bit (IDE) is used for acceptance filtering</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_IF1_ARB1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_IF1_ARB1</displayName>
          <description>IF1 Arbitration 1 Register</description>
          <addressOffset>0x30</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ID15_0</name>
              <description>Message Identifier 15-0\nID28 - ID0, 29-bit Identifier ('Extended Frame').\nID28 - ID18, 11-bit Identifier ('Standard Frame').</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_IF1_ARB2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_IF1_ARB2</displayName>
          <description>IF1 Arbitration 2 Register</description>
          <addressOffset>0x34</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ID28_16</name>
              <description>Message Identifier 28-16\nID28 - ID0, 29-bit Identifier ('Extended Frame').\nID28 - ID18, 11-bit Identifier ('Standard Frame').</description>
              <bitOffset>0</bitOffset>
              <bitWidth>13</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>Dir</name>
              <description>Message Direction</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Direction is receive</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Direction is transmit</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>Xtd</name>
              <description>Extended Identifier</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The 11-bit ('standard') Identifier will be used for this Message Object</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The 29-bit ('extended') Identifier will be used for this Message Object</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MsgVal</name>
              <description>Message Valid\nNote: The application software must reset the MsgVal bit of all unused Messages Objects during the initialization before it resets bit Init (CAN_CON[0]). This bit must also be reset before the identifier Id28-0 (CAN_IFn_ARB1/2), the control bits Xtd (CAN_IFn_ARB2[14]), Dir (CAN_IFn_ARB2[13]), or the Data Length Code DLC3-0 (CAN_IFn_MCON[3:0]) are modified,  or if the Messages Object  is no longer required.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The Message Object is ignored by the Message Handler</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The Message Object is configured and should be considered by the Message Handler</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_IF1_MCON</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_IF1_MCON</displayName>
          <description>IF1 Message Control Register</description>
          <addressOffset>0x38</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DLC</name>
              <description>Data Length Code\n0-8: Data Frame has 0-8 data bytes.\n9-15: Data Frame has 8 data bytes\nNote: The Data Length Code of a Message Object must be defined the same as in all the corresponding objects with the same identifier at other nodes. When the Message Handler stores a data frame, it will write the DLC to the value given by the received message.\nData(0): 1st data byte of a CAN Data Frame\nData(1): 2nd data byte of a CAN Data Frame\nData(2): 3rd data byte of a CAN Data Frame\nData(3): 4th data byte of a CAN Data Frame\nData(4): 5th data byte of a CAN Data Frame\nData(5): 6th data byte of a CAN Data Frame\nData(6): 7th data byte of a CAN Data Frame\nData(7): 8th data byte of a CAN Data Frame\nNote: The Data(0) byte is the first data byte shifted into the shift register of the CAN Core during a reception while the Data(7) byte is the last. When the Message Handler stores a Data Frame, it will write all the eight data bytes into a Message Object. If the Data Length Code is less than 8, the remaining bytes of the Message Object will be overwritten by unspecified values.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EoB</name>
              <description>End Of Buffer\nNote: This bit is used to concatenate two or more Message Objects (up to 32) to build a FIFO Buffer. For single Message Objects (not belonging to a FIFO Buffer), this bit must always be set to one.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Message Object belongs to a FIFO Buffer and is not the last Message Object of that FIFO Buffer</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Single Message Object or last Message Object of a FIFO Buffer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TxRqst</name>
              <description>Transmit Request</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>This Message Object is not waiting for transmission</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The transmission of this Message Object is requested and is not yet done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RmtEn</name>
              <description>Remote Enable Control</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>At the reception of a Remote Frame, TxRqst (CAN_IFn_MCON[8]) is left unchanged</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>At the reception of a Remote Frame, TxRqst is set</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RxIE</name>
              <description>Receive Interrupt Enable Control</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>IntPnd (CAN_IFn_MCON[13]) will be left unchanged after a successful reception of a frame</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>IntPnd will be set after a successful reception of a frame</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TxIE</name>
              <description>Transmit Interrupt Enable Control</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>IntPnd (CAN_IFn_MCON[13]) will be left unchanged after the successful transmission of a frame</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>IntPnd will be set after a successful transmission of a frame</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>UMask</name>
              <description>Use Acceptance Mask\nNote: If the UMask bit is set to one, the Message Object's mask bits have  to  be  programmed  during  initialization  of  the  Message Object before MsgVal bit (CAN_IFn_ARB2[15]) is set to one.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Mask ignored</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Use Mask (Msk28-0, MXtd, and MDir) for acceptance filtering</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IntPnd</name>
              <description>Interrupt Pending</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>This message object is not the source of an interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>This message object is the source of an interrupt. The Interrupt Identifier in the Interrupt Register will point to this message object if there is no other interrupt source with higher priority</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MsgLst</name>
              <description></description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No message lost since last time this bit was reset by the CPU</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The Message Handler stored a new message into this object when NewDat was still set, the CPU has lost a message</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>NewDat</name>
              <description>New Data</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No new data has been written into the data portion of this Message Object by the Message Handler since last time this flag was cleared by the application software</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The Message Handler or the application software has written new data into the data portion of this Message Object</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_IF1_DAT_A1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_IF1_DAT_A1</displayName>
          <description>IF1 Data A1 Register (Register Map Note 3)</description>
          <addressOffset>0x3C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>Data_0</name>
              <description>Data Byte 0\n1st data byte of a CAN Data Frame.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>Data_1</name>
              <description>Data Byte 1\n2nd data byte of a CAN Data Frame.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_IF1_DAT_A2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_IF1_DAT_A2</displayName>
          <description>IF1 Data A2 Register (Register Map Note 3)</description>
          <addressOffset>0x40</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>Data_2</name>
              <description>Data Byte 2\n3rd data byte of CAN Data Frame.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>Data_3</name>
              <description>Data Byte 3\n4th data byte of CAN Data Frame.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_IF1_DAT_B1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_IF1_DAT_B1</displayName>
          <description>IF1 Data B1 Register (Register Map Note 3)</description>
          <addressOffset>0x44</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>Data_4</name>
              <description>Data Byte 4\n5th data byte of CAN Data Frame.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>Data_5</name>
              <description>Data Byte 5\n6th data byte of CAN Data Frame.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_IF1_DAT_B2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_IF1_DAT_B2</displayName>
          <description>IF1 Data B2 Register (Register Map Note 3)</description>
          <addressOffset>0x48</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>Data_6</name>
              <description>Data Byte 6\n7th data byte of CAN Data Frame.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>Data_7</name>
              <description>Data Byte 7\n8th data byte of CAN Data Frame.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="CAN_IF1_CREQ">
          <name>CAN_IF2_CREQ</name>
          <displayName>CAN_IF2_CREQ</displayName>
          <description>IF2 (Register Map Note 2) Command Request Registers</description>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="CAN_IF1_CMASK">
          <name>CAN_IF2_CMASK</name>
          <displayName>CAN_IF2_CMASK</displayName>
          <description>IF2 Command Mask Register</description>
          <addressOffset>0x84</addressOffset>
       </register>
       <register derivedFrom="CAN_IF1_MASK1">
          <name>CAN_IF2_MASK1</name>
          <displayName>CAN_IF2_MASK1</displayName>
          <description>IF2 Mask 1 Register</description>
          <addressOffset>0x88</addressOffset>
       </register>
       <register derivedFrom="CAN_IF1_MASK2">
          <name>CAN_IF2_MASK2</name>
          <displayName>CAN_IF2_MASK2</displayName>
          <description>IF2 Mask 2 Register</description>
          <addressOffset>0x8C</addressOffset>
       </register>
       <register derivedFrom="CAN_IF1_ARB1">
          <name>CAN_IF2_ARB1</name>
          <displayName>CAN_IF2_ARB1</displayName>
          <description>IF2 Arbitration 1 Register</description>
          <addressOffset>0x90</addressOffset>
       </register>
       <register derivedFrom="CAN_IF1_ARB2">
          <name>CAN_IF2_ARB2</name>
          <displayName>CAN_IF2_ARB2</displayName>
          <description>IF2 Arbitration 2 Register</description>
          <addressOffset>0x94</addressOffset>
       </register>
       <register derivedFrom="CAN_IF1_MCON">
          <name>CAN_IF2_MCON</name>
          <displayName>CAN_IF2_MCON</displayName>
          <description>IF2 Message Control Register</description>
          <addressOffset>0x98</addressOffset>
       </register>
       <register derivedFrom="CAN_IF1_DAT_A1">
          <name>CAN_IF2_DAT_A1</name>
          <displayName>CAN_IF2_DAT_A1</displayName>
          <description>IF2 Data A1 Register (Register Map Note 3)</description>
          <addressOffset>0x9C</addressOffset>
       </register>
       <register derivedFrom="CAN_IF1_DAT_A2">
          <name>CAN_IF2_DAT_A2</name>
          <displayName>CAN_IF2_DAT_A2</displayName>
          <description>IF2 Data A2 Register (Register Map Note 3)</description>
          <addressOffset>0xA0</addressOffset>
       </register>
       <register derivedFrom="CAN_IF1_DAT_B1">
          <name>CAN_IF2_DAT_B1</name>
          <displayName>CAN_IF2_DAT_B1</displayName>
          <description>IF2 Data B1 Register (Register Map Note 3)</description>
          <addressOffset>0xA4</addressOffset>
       </register>
       <register derivedFrom="CAN_IF1_DAT_B2">
          <name>CAN_IF2_DAT_B2</name>
          <displayName>CAN_IF2_DAT_B2</displayName>
          <description>IF2 Data B2 Register (Register Map Note 3)</description>
          <addressOffset>0xA8</addressOffset>
       </register>
       <register>
          <name>CAN_TXREQ1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_TXREQ1</displayName>
          <description>Transmission Request Register 1</description>
          <addressOffset>0x100</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TxRqst16_1</name>
              <description>Transmission Request Bits 16-1 (Of All Message Objects)\nThese bits are read only.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>This Message Object is not waiting for transmission</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The transmission of this Message Object is requested and is not yet done</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_TXREQ2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_TXREQ2</displayName>
          <description>Transmission Request Register 2</description>
          <addressOffset>0x104</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TxRqst32_17</name>
              <description>Transmission Request Bits 32-17 (Of All Message Objects)\nThese bits are read only.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>This Message Object is not waiting for transmission</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The transmission of this Message Object is requested and is not yet done</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_NDAT1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_NDAT1</displayName>
          <description>New Data Register 1</description>
          <addressOffset>0x120</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NewData16_1</name>
              <description>New Data Bits 16-1 (Of All Message Objects)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No new data has been written into the data portion of this Message Object by the Message Handler since the last time this flag was cleared by the application software</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The Message Handler or the application software has written new data into the data portion of this Message Object</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_NDAT2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_NDAT2</displayName>
          <description>New Data Register 2</description>
          <addressOffset>0x124</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NewData32_17</name>
              <description>New Data Bits 32-17 (Of All Message Objects)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No new data has been written into the data portion of this Message Object by the Message Handler since the last time this flag was cleared by the application software</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The Message Handler or the application software has written new data into the data portion of this Message Object</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_IPND1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_IPND1</displayName>
          <description>Interrupt Pending Register 1</description>
          <addressOffset>0x140</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IntPnd16_1</name>
              <description>Interrupt Pending Bits 16-1 (Of All Message Objects)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>This message object is not the source of an interrupt</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>This message object is the source of an interrupt</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_IPND2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_IPND2</displayName>
          <description>Interrupt Pending Register 2</description>
          <addressOffset>0x144</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IntPnd32_17</name>
              <description>Interrupt Pending Bits 32-17 (Of All Message Objects)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>This message object is not the source of an interrupt</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>This message object is the source of an interrupt</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_MVLD1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_MVLD1</displayName>
          <description>Message Valid Register 1</description>
          <addressOffset>0x160</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MsgVal16_1</name>
              <description>Message Valid Bits 16-1 (Of All Message Objects) (Read Only)\nEx. CAN_MVLD1[0] means Message object No.1 is valid or not. If CAN_MVLD1[0] is set, message object No.1 is configured.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>This Message Object is ignored by the Message Handler</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>This Message Object is configured and should be considered by the Message Handler</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_MVLD2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_MVLD2</displayName>
          <description>Message Valid Register 2</description>
          <addressOffset>0x164</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MsgVal32_17</name>
              <description>Message Valid Bits 32-17 (Of All Message Objects) (Read Only)\nEx.CAN_MVLD2[15] means Message object No.32 is valid or not. If CAN_MVLD2[15] is set, message object No.32 is configured.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>This Message Object is ignored by the Message Handler</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>This Message Object is configured and should be considered by the Message Handler</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_WU_EN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_WU_EN</displayName>
          <description>Wake-up Enable Register</description>
          <addressOffset>0x168</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WAKUP_EN</name>
              <description>Wake-Up Enable Control\nNote: User can wake-up system when there is a falling edge in the CAN_Rx pin.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The wake-up function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The wake-up function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_WU_STATUS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_WU_STATUS</displayName>
          <description>Wake-up Status Register</description>
          <addressOffset>0x16C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WAKUP_STS</name>
              <description>Wake-Up Status \nNote: This bit can be cleared by writing '0'.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No wake-up event occurred</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Wake-up event occurred</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>ADC</name>
      <description>ADC Register Map</description>
      <groupName>ADC</groupName>
      <baseAddress>0x400E0000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x34</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>ADDR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ADDR0</displayName>
          <description>ADC Data Register 0</description>
          <addressOffset>0x0</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RSLT</name>
              <description>A/D Conversion Result\nThis field contains conversion result of ADC.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>OVERRUN</name>
              <description>Overrun Flag\nIf converted data in RSLT has not been read before new conversion result is loaded to this register, OVERRUN is set to 1 and previous conversion result is gone. It is cleared by hardware after ADDR register is read.\nThis is a read only bit.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Data in RSLT (ADDRx[15:0], x=0~7) is recent conversion result</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Data in RSLT (ADDRx[15:0], x=0~7) is overwritten</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>VALID</name>
              <description>Valid Flag\nThis bit is set to 1 when corresponding channel analog input conversion is completed and cleared by hardware after ADDR register is read.\nThis is a read only bit.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Data in RSLT bits (ADDRx[15:0], x=0~7) is not valid</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Data in RSLT bits (ADDRx[15:0], x=0~7) is valid</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="ADDR0">
          <name>ADDR1</name>
          <displayName>ADDR1</displayName>
          <description>ADC Data Register 1</description>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="ADDR0">
          <name>ADDR2</name>
          <displayName>ADDR2</displayName>
          <description>ADC Data Register 2</description>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="ADDR0">
          <name>ADDR3</name>
          <displayName>ADDR3</displayName>
          <description>ADC Data Register 3</description>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="ADDR0">
          <name>ADDR4</name>
          <displayName>ADDR4</displayName>
          <description>ADC Data Register 4</description>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="ADDR0">
          <name>ADDR5</name>
          <displayName>ADDR5</displayName>
          <description>ADC Data Register 5</description>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="ADDR0">
          <name>ADDR6</name>
          <displayName>ADDR6</displayName>
          <description>ADC Data Register 6</description>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="ADDR0">
          <name>ADDR7</name>
          <displayName>ADDR7</displayName>
          <description>ADC Data Register 7</description>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register>
          <name>ADCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ADCR</displayName>
          <description>ADC Control Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADEN</name>
              <description>A/D Converter Enable Control\nBefore starting A/D conversion function, this bit should be set to 1. Clear it to 0 to disable A/D converter analog circuit for saving power consumption.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADIE</name>
              <description>A/D Interrupt Enable Control\nA/D conversion end interrupt request is generated if ADIE bit (ADCR[1]) is set to 1.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>A/D interrupt function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>A/D interrupt function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADMD</name>
              <description>A/D Converter Operation Mode\nWhen changing the operation mode, software should disable ADST bit (ADCR[11]) firstly.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Single conversion</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved.</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Single-cycle scan</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Continuous scan</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGS</name>
              <description>Hardware Trigger Source\nSoftware should disable TRGEN (ADCR[8]) and ADST (ADCR[11]) before change TRGS.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>A/D conversion is started by external STADC pin</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>A/D conversion is started by PWM Center-aligned trigger</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGCOND</name>
              <description>External Trigger Condition\nThese two bits decide external pin STADC trigger event is level or edge. The signal must be kept at stable state at least 8 PCLKs for level trigger and 4 PCLKs at high and low state for edge trigger.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Low level</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>High level</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Falling edge</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Rising edge</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGEN</name>
              <description>Hardware Trigger Enable Control\nEnable or disable triggering of A/D conversion by hardware (external STADC pin or PWM Center-aligned trigger).\nADC hardware trigger function is only supported in single-cycle scan mode.\nIf hardware trigger mode, the ADST bit (ADCR[11]) can be set to 1 by the selected hardware trigger source.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DIFFEN</name>
              <description>Differential Input Mode Control</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Single-end analog input mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Differential analog input mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADST</name>
              <description>A/D Conversion Start\nADST bit can be set to 1 from three sources: software, PWM Center-aligned trigger and external pin STADC. ADST will be cleared to 0 by hardware automatically at the ends of single mode and single-cycle scan mode. In continuous scan mode, A/D conversion is continuously performed until software writes 0 to this bit or chip reset.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Conversion stops and A/D converter enter idle state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Conversion starts</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMOF</name>
              <description>A/D Differential Input Mode Output Format</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>A/D Conversion result will be filled in RSLT at ADDRx registers with unsigned format</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>A/D Conversion result will be filled in RSLT at ADDRx registers with 2'complement format</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ADCHER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ADCHER</displayName>
          <description>ADC Channel Enable Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CHEN</name>
              <description>Analog Input Channel Enable Control\nSet CHEN[7:0] to enable the corresponding analog input channel 7 ~ 0. If DIFFEN bit (ADCR[10]) is set to 1, only the even number channels need to be enabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ADC input channel Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ADC input channel Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESEL</name>
              <description>Analog Input Channel 7 Selection</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>External analog input</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Internal band-gap voltage</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Reserved.</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved.</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ADCMPR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ADCMPR0</displayName>
          <description>ADC Compare Register 0</description>
          <addressOffset>0x28</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMPEN</name>
              <description>Compare Enable Control\nSet this bit to 1 to enable ADC controller to compare CMPD (ADCMPR0/1[27:16]) with specified channel conversion result when converted data is loaded into ADDR register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Compare function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Compare function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPIE</name>
              <description>Compare Interrupt Enable Control\nIf the compare function is enabled and the compare condition matches the setting of CMPCOND (ADCMPR0/1[2]) and CMPMATCNT (ADCMPR0/1[11:8]), CMPF0/1 bit (ADSR[1]/[2]) will be asserted, in the meanwhile, if CMPIE (ADCMPR0/1[1]) is set to 1, a compare interrupt request is generated.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Compare function interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Compare function interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPCOND</name>
              <description>Compare Condition\nNote: When the internal counter reaches the value to (CMPMATCNT (ADCMPR0/1[11:8]) + 1), the CMPF0/1 bit (ADSR[1]/[2]) will be set.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Set the compare condition as that when a 12-bit A/D conversion result is less than the 12-bit CMPD (ADCMPR0/1[27:16]), the internal match counter will increase one</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Set the compare condition as that when a 12-bit A/D conversion result is greater or equal to the 12-bit CMPD (ADCMPR0/1[27:16]), the internal match counter will increase one</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPCH</name>
              <description>Compare Channel Selection</description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Channel 0 conversion result is selected to be compared</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Channel 1 conversion result is selected to be compared</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Channel 2 conversion result is selected to be compared</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Channel 3 conversion result is selected to be compared</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>Channel 4 conversion result is selected to be compared</description>
                    <value>#100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Channel 5 conversion result is selected to be compared</description>
                    <value>#101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Channel 6 conversion result is selected to be compared</description>
                    <value>#110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Channel 7 conversion result is selected to be compared</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPMATCNT</name>
              <description>Compare Match Count\nWhen the specified A/D channel analog conversion result matches the compare condition defined by CMPCOND (ADCMPR0/1[2]), the internal match counter will increase 1, The comparing data must successively matched with the compare condition. Once any comparing data does not match during the comparing, the internal counter will clear to 0. When the internal counter reaches the value to (CMPMATCNT (ADCMPR0/1[11:8]) +1), the CMPF0/1 bit (ADSR[1]/[2]) will be set.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPD</name>
              <description>Comparison Data\nThe 12-bit data is used to compare with conversion result of specified channel.\nWhen DMOF bit (ADCR[31]) is set to 0, ADC comparator compares CMPD with conversion result with unsigned format. CMPD should be filled in unsigned format.\nWhen DMOF bit (ADCR[31]) is set to 1, ADC comparator compares CMPD with conversion result with 2'complement format. CMPD should be filled in 2'complement format.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="ADCMPR0">
          <name>ADCMPR1</name>
          <displayName>ADCMPR1</displayName>
          <description>ADC Compare Register 1</description>
          <addressOffset>0x2C</addressOffset>
       </register>
       <register>
          <name>ADSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ADSR</displayName>
          <description>ADC Status Register</description>
          <addressOffset>0x30</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADF</name>
              <description>A/D Conversion End Flag\nA status flag that indicates the end of A/D conversion.\nADF is set to 1 at these two conditions:\n1. When A/D conversion ends in Single mode.\n2. When A/D conversion ends on all specified channels in Scan mode.\nThis flag can be cleared by writing 1 to itself.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPF0</name>
              <description>Compare Flag\nWhen the selected channel A/D conversion result meets setting condition in ADCMPR0 then this bit is set to 1. And it is cleared by writing 1 to self.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Conversion result in ADDR does not meet ADCMPR0 setting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Conversion result in ADDR meets ADCMPR0 setting</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPF1</name>
              <description>Compare Flag\nWhen the selected channel A/D conversion result meets setting condition in ADCMPR1 then this bit is set to 1. And it is cleared by writing 1 to self.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Conversion result in ADDR does not meet ADCMPR1 setting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Conversion result in ADDR meets ADCMPR1 setting</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BUSY</name>
              <description>BUSY/IDLE\nThis bit is mirror of as ADST bit (ADCR[11]).\nIt is read only.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>A/D converter is in idle state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>A/D converter is busy at conversion</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CHANNEL</name>
              <description>Current Conversion Channel\nIt is read only.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VALID</name>
              <description>Data Valid Flag\nIt is a mirror of VALID bit (ADDR0~7[17]).\nIt is read only.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERRUN</name>
              <description>Overrun Flag\nIt is a mirror to OVERRUN bit (ADDR0~7[16]).\nIt is read only.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
  </peripherals>
</device>
