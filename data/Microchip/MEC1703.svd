<?xml version="1.0" encoding="UTF-8"?>
<!--
Copyright (c) 2017 Microchip Technology Inc.

 SPDX-License-Identifier: Apache-2.0

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->
<device xmlns:xs="http://www.w3.org/2001/XMLSchema-instance"
        schemaVersion="1.1"
        xs:noNamespaceSchemaLocation="CMSIS-SVD.xsd">
   <vendor>Microchip Technology</vendor>
   <vendorID>MCHP</vendorID>
   <name>MEC1703</name>
   <series>MEC1703</series>
   <version>0</version>
   <description>Microchip MEC1703 Microcontroller</description>
   <cpu>
      <name>CM4</name>
      <revision>r1p0</revision>
      <endian>little</endian>
      <mpuPresent>true</mpuPresent>
      <fpuPresent>true</fpuPresent>
      <nvicPrioBits>3</nvicPrioBits>
      <vendorSystickConfig>false</vendorSystickConfig>
   </cpu>
   <addressUnitBits>8</addressUnitBits>
   <width>32</width>
   <size>32</size>
   <access>read-write</access>
   <resetValue>0x00000000</resetValue>
   <resetMask>0xFFFFFFFF</resetMask>
   <peripherals>
      <peripheral>
         <name>PCR</name>
         <version>1001.0</version>
         <description>The Power, Clocks, and Resets (PCR) Section identifies all the power supplies,\n                    clock sources, and reset inputs to the chip and defines all the derived power, clock, and reset signals.</description>
         <groupName>PCR</groupName>
         <prependToName>PCR_</prependToName>
         <baseAddress>0x40080100</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x84</size>
            <usage>registers</usage>
         </addressBlock>
         <registers>
            <register>
               <name>SYS_SLP_CTRL</name>
               <description>System Sleep Control</description>
               <addressOffset>0x0</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SLP_MOD</name>
                     <description>Selects the System Sleep mode</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TEST</name>
                     <description>Test bit</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SLP_ALL</name>
                     <description>Initiates the System Sleep mode</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>PROC_CLK_CTRL</name>
               <description>Processor Clock Control Register [7:0] Processor Clock Divide Value (PROC_DIV)\n                           1: divide 48 MHz Ring Oscillator by 1.\n                   3: divide 48 MHz Ring Oscillator by 3.\n                         4: divide 48 MHz Ring Oscillator by 4.\n                         16: divide 48 MHz Ring Oscillator by 16.\n                 48: divide 48 MHz Ring Oscillator by 48.\n                 No other values are supported.</description>
               <addressOffset>0x4</addressOffset>
               <size>32</size>
               <resetValue>0x00000004</resetValue>
               <fields>
                  <field>
                     <name>DIV</name>
                     <description>Selects the EC clock rate</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                     <enumeratedValues>
                        <name>DIVSelect</name>
                        <enumeratedValue>
                           <name>DIV_BY_1</name>
                           <description>1: divide 48 MHz Ring Oscillator by 1</description>
                           <value>0x1</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>DIV_BY_3</name>
                           <description>3: divide 48 MHz Ring Oscillator by 3</description>
                           <value>0x3</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>DIV_BY_4</name>
                           <description>4: divide 48 MHz Ring Oscillator by 4</description>
                           <value>0x4</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>DIV_BY_16</name>
                           <description>16: divide 48 MHz Ring Oscillator by 16</description>
                           <value>0x10</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>DIV_BY_48</name>
                           <description>48: divide 48 MHz Ring Oscillator by 48</description>
                           <value>0x30</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
               </fields>
            </register>
            <register>
               <name>SLOW_CLK_CTRL</name>
               <description>Configures the EC_CLK clock domain</description>
               <addressOffset>0x8</addressOffset>
               <size>32</size>
               <resetValue>0x000001E0</resetValue>
               <fields>
                  <field>
                     <name>DIV</name>
                     <description>DIV. n=Divide by n; 0=Clock off</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>10</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>OSC_ID</name>
               <description>Oscillator ID Register</description>
               <addressOffset>0xC</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>TEST</name>
                     <description>Test bits</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>PLL_LOCK</name>
                     <description>PLL Lock Status</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>PWR_RST_STS</name>
               <description>PCR Power Reset Status Register</description>
               <addressOffset>0x10</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>VCC_PWRGD_STS</name>
                     <description>Indicates the status of VCC_PWRGD. 0 = PWRGD not asserted. 1 = PWRGD asserte.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RST_H_STS</name>
                     <description>Indicates the status of RESET_VCC. 0 = reset active. 1 = reset not active.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>VBAT_RST_STS</name>
                     <description>VBAT reset status 0 = No reset occurred while VTR was off or since the last time this bit was cleared. 1 = A reset occurred.(R/WC)</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RST_VTR_STS</name>
                     <description>Indicates the status of VTR_RESET.(R/WC)\n        0 = No reset occurred since the last time this bit was cleared.\n                1 = A reset occurred.</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>JTAG_RST_STS</name>
                     <description>Indicates s RESET_SYS was triggered by a JTAG action.(R/WC)\n          0 = No JTAG reset occurred since the last time this bit was cleared.\n           1 = A reset occurred because of a JATAG command.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>_32K_ACTIVE</name>
                     <description>32K_ACTIVE</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PCICLK_ACTIVE</name>
                     <description>PCICLK_ACTIVE</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ESPI_CLK_ACTIVE</name>
                     <description>ESPI_CLK_ACTIVE</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>PWR_RST_CTRL</name>
               <description>Power Reset Control Register</description>
               <addressOffset>0x14</addressOffset>
               <size>32</size>
               <resetValue>0x00000101</resetValue>
               <fields>
                  <field>
                     <name>PWR_INV</name>
                     <description>Used by FW to control internal RESET_VCC signal function and external PWROK pin. This bit is read-only when VCC_PWRGD\n                is de-asserted low.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>H_RST_SEL</name>
                     <description>Determines what generates the internal platform reset signal. 1=LRESET# pin; 0=eSPI PLTRST# VWire</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SYS_RST</name>
               <description>System Reset Register</description>
               <addressOffset>0x18</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SOFT_SYS_RST</name>
                     <description>A write of a 1 forces an assertion of the RESET_SYS reset signal, resetting the device. A write of 0 has no effect.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SLP_EN_0</name>
               <description>Sleep Enable 0 Register</description>
               <addressOffset>0x30</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>JTAG_STAP_SLP_EN</name>
                     <description>JTAG STAP Enable</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>OTP_SLP_EN</name>
                     <description>eFuse Enable</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ISPI_SLP_EN</name>
                     <description>ISPI Enable</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SLP_EN_1</name>
               <description>Sleep Enable 1 Register</description>
               <addressOffset>0x34</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>INT_SLP_EN</name>
                     <description>Interrupt Sleep Enable</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PECI_SLP_EN</name>
                     <description>PECI Sleep Enable</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TACH0_SLP_EN</name>
                     <description>TACH0 Sleep Enable</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWM0_SLP_EN</name>
                     <description>PWM0 Sleep Enable</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PMC_SLP_EN</name>
                     <description>PMC Sleep Enable</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DMA_SLP_EN</name>
                     <description>DMA Sleep Enable</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TFDP_SLP_EN</name>
                     <description>TFDP Sleep Enable</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PROC_SLP_EN</name>
                     <description>PROCESSOR Sleep Enable</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>WDT_SLP_EN</name>
                     <description>WDT Sleep Enable</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SMB0_SLP_EN</name>
                     <description>SMB0 Sleep Enable</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TACH1_SLP_EN</name>
                     <description>TACH1 Sleep Enable</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TACH2_SLP_EN</name>
                     <description>TACH2 Sleep Enable</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWM1_SLP_EN</name>
                     <description>PWM1 Sleep Enable</description>
                     <bitOffset>20</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWM2_SLP_EN</name>
                     <description>PWM2 Sleep Enable</description>
                     <bitOffset>21</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWM3_SLP_EN</name>
                     <description>PWM3 Sleep Enable</description>
                     <bitOffset>22</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWM4_SLP_EN</name>
                     <description>PWM4 Sleep Enable</description>
                     <bitOffset>23</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWM5_SLP_EN</name>
                     <description>PWM5 Sleep Enable</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWM6_SLP_EN</name>
                     <description>PWM6 Sleep Enable</description>
                     <bitOffset>25</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWM7_SLP_EN</name>
                     <description>PWM7 Sleep Enable</description>
                     <bitOffset>26</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWM8_SLP_EN</name>
                     <description>PWM8 Sleep Enable</description>
                     <bitOffset>27</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>EC_REG_BANK_SLP_EN</name>
                     <description>EC_REG_BANK Sleep Enable</description>
                     <bitOffset>29</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TMR16_0_SLP_EN</name>
                     <description>TIMER16_0 Sleep Enable</description>
                     <bitOffset>30</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TMR16_1_SLP_EN</name>
                     <description>TIMER16_1 Sleep Enable</description>
                     <bitOffset>31</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SLP_EN_2</name>
               <description>Sleep Enable 2 Register</description>
               <addressOffset>0x38</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>LPC_SLP_EN</name>
                     <description>LPC Sleep Enable</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>UART0_SLP_EN</name>
                     <description>UART 0 Sleep Enable</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>UART1_SLP_EN</name>
                     <description>UART 1 Sleep Enable</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GLBL_CFG_SLP_EN</name>
                     <description>GLBL_CFG</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ACPI_EC_0_SLP_EN</name>
                     <description>ACPI EC 0 Sleep Enable</description>
                     <bitOffset>13</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ACPI_EC_1_SLP_EN</name>
                     <description>ACPI EC 1 Sleep Enable</description>
                     <bitOffset>14</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ACPI_PM1_SLP_EN</name>
                     <description>ACPI PM1 Sleep Enable</description>
                     <bitOffset>15</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>EMU_8042_SLP_EN</name>
                     <description>8042 Emulation Sleep Enable</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MBOX_SLP_EN</name>
                     <description>Mailbox Sleep Enable</description>
                     <bitOffset>17</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RTC_SLP_EN</name>
                     <description>RTC Sleep Enable</description>
                     <bitOffset>18</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ESPI_SLP_EN</name>
                     <description>eSPI Sleep Enable</description>
                     <bitOffset>19</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ACPI_EC_2_SLP_EN</name>
                     <description>ACPI EC 2 Sleep Enable</description>
                     <bitOffset>21</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ACPI_EC_3_SLP_EN</name>
                     <description>ACPI EC 3 Sleep Enable</description>
                     <bitOffset>22</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ACPI_EC_4_SLP_EN</name>
                     <description>ACPI EC 4 Sleep Enable</description>
                     <bitOffset>23</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PORT80_0_SLP_EN</name>
                     <description>Port80 0 Sleep Enable</description>
                     <bitOffset>25</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PORT80_1_SLP_EN</name>
                     <description>Port80 1 Sleep Enable</description>
                     <bitOffset>26</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>KBCEM_SLP_EN</name>
                     <description>8042EM Sleep Enable (8042EM_SLP_EN)</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SLP_EN_3</name>
               <description>Sleep Enable 3 Register</description>
               <addressOffset>0x3C</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>ADC_SLP_EN</name>
                     <description>ADC Sleep Enable</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PS2_0_SLP_EN</name>
                     <description>PS2 0 Sleep Enable</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PS2_1_SLP_EN</name>
                     <description>PS2 1 Sleep Enable</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PS2_2_SLP_EN</name>
                     <description>PS2 2 Sleep Enable</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GP_SPI0_SLP_EN</name>
                     <description>GP SPI0 Sleep Enable</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>HTMR_0_SLP_EN</name>
                     <description>HTIMER 0 Sleep Enable</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>KEYSCAN_SLP_EN</name>
                     <description>KEYSCAN Sleep Enable</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RPMPWM_SLP_EN</name>
                     <description>RPM-PWM Sleep Enable</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SMB1_SLP_EN</name>
                     <description>SMB1 Sleep Enable</description>
                     <bitOffset>13</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SMB2_SLP_EN</name>
                     <description>SMB2 Sleep Enable</description>
                     <bitOffset>14</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SMB3_SLP_EN</name>
                     <description>SMB3 Sleep Enable</description>
                     <bitOffset>15</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>LED0_SLP_EN</name>
                     <description>LED0 Sleep Enable</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>LED1_SLP_EN</name>
                     <description>LED1 Sleep Enable</description>
                     <bitOffset>17</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>LED2_SLP_EN</name>
                     <description>LED2 Sleep Enable</description>
                     <bitOffset>18</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BC_M_SLP_EN</name>
                     <description>BC Master Sleep Enable</description>
                     <bitOffset>19</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GP_SPI1_SLP_EN</name>
                     <description>GP SPI1 Sleep Enable</description>
                     <bitOffset>20</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TMR16_2_SLP_EN</name>
                     <description>TIMER16_2_Sleep Enable</description>
                     <bitOffset>21</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TMR16_3_SLP_EN</name>
                     <description>TIMER16_3 Sleep Enable</description>
                     <bitOffset>22</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TMR32_0_SLP_EN</name>
                     <description>TIMER32_0 Sleep Enable</description>
                     <bitOffset>23</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TMR32_1_SLP_EN</name>
                     <description>TIMER32_1 Sleep Enable</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>LED3_SLP_EN</name>
                     <description>LED3 Sleep Enable</description>
                     <bitOffset>25</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PKE_SLP_EN</name>
                     <description>PKE Sleep Enable</description>
                     <bitOffset>26</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RNG_SLP_EN</name>
                     <description>RNG Sleep Enable</description>
                     <bitOffset>27</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>AES_HASH_SLP_EN</name>
                     <description>AES_HASH Sleep Enable</description>
                     <bitOffset>28</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>HTMR_1_SLP_EN</name>
                     <description>HTIMER 1 Sleep Enable</description>
                     <bitOffset>29</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CCTMR_SLP_EN</name>
                     <description>Capture Compare Timer Sleep Enable</description>
                     <bitOffset>30</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWM9_SLP_EN</name>
                     <description>PWM9 Sleep Enable</description>
                     <bitOffset>31</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SLP_EN_4</name>
               <description>Sleep Enable 4 Register</description>
               <addressOffset>0x40</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>PWM10_SLP_EN</name>
                     <description>PWM10 Sleep Enable</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWM11_SLP_EN</name>
                     <description>PWM11 Sleep Enable</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CNT_TMER0_SLP_EN</name>
                     <description>CNT_TMER0 Sleep Enable</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CNT_TMER1_SLP_EN</name>
                     <description>CNT_TMER1 Sleep Enable</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CNT_TMER2_SLP_EN</name>
                     <description>CNT_TMER2 Sleep Enable</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CNT_TMER3_SLP_EN</name>
                     <description>CNT_TMER3 Sleep Enable</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RTOS_SLP_EN</name>
                     <description>PWM6 Sleep Enable</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RPMPWM1_SLP_EN</name>
                     <description>RPMPWM 1 Sleep Enable</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>QMSPI_SLP_EN</name>
                     <description>Quad SPI Sleep Enable</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BC_MASTER_SLP_EN</name>
                     <description>BC Master Sleep Enable</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RC_ID0_SLP_EN</name>
                     <description>RC_ID0 Sleep Enable</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RC_ID1_SLP_EN</name>
                     <description>RC_ID1 Sleep Enable</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RC_ID2_SLP_EN</name>
                     <description>RC_ID2 Sleep Enable</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PROCHOT_SLP_EN</name>
                     <description>PROCHOT Sleep Enable</description>
                     <bitOffset>13</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>EEPROM_SLP_EN</name>
                     <description>EEPROM Sleep Enable</description>
                     <bitOffset>14</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FUJICL_SLP_EN</name>
                     <description>Fujitsu Custom Logic Sleep Enable</description>
                     <bitOffset>15</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CLK_REQ_0</name>
               <description>Clock Required 0 Register</description>
               <addressOffset>0x50</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>JTAG_STAP_CLK_REQ</name>
                     <description>JTAG Clock Reuqired</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>EFUSE_CLK_REQ</name>
                     <description>eFuse Clock Reuqired</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ISPI_CLK_REQ</name>
                     <description>ISPI Clock Reuqired</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CLK_REQ_1</name>
               <description>Clock Required 1 Register</description>
               <addressOffset>0x54</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>INT_CLK_REQ</name>
                     <description>Interrupt Clock Reuqired</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PECI_CLK_REQ</name>
                     <description>PECI Clock Reuqired</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TACH0_CLK_REQ</name>
                     <description>TACH0 Clock Reuqired</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWM0_CLK_REQ</name>
                     <description>PWM0 Clock Reuqired</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PMC_CLK_REQ</name>
                     <description>PMC Clock Reuqired</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DMA_CLK_REQ</name>
                     <description>DMA Clock Reuqired</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TFDP_CLK_REQ</name>
                     <description>TFDP Clock Reuqired</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PROCESSOR_CLK_REQ</name>
                     <description>PROCESSOR Clock Reuqired</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>WDT_CLK_REQ</name>
                     <description>WDT Clock Reuqired</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SMB0_CLK_REQ</name>
                     <description>SMB0 Clock Reuqired</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TACH1_CLK_REQ</name>
                     <description>TACH1 Clock Reuqired</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TACH2_CLK_REQ</name>
                     <description>TACH2 Clock Reuqired</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWM1_CLK_REQ</name>
                     <description>PWM1 Clock Reuqired</description>
                     <bitOffset>20</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWM2_CLK_REQ</name>
                     <description>PWM2 Clock Reuqired</description>
                     <bitOffset>21</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWM3_CLK_REQ</name>
                     <description>PWM3 Clock Reuqired</description>
                     <bitOffset>22</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWM4_CLK_REQ</name>
                     <description>PWM4 Clock Reuqired</description>
                     <bitOffset>23</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWM5_CLK_REQ</name>
                     <description>PWM5 Clock Reuqired</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWM6_CLK_REQ</name>
                     <description>PWM6 Clock Reuqired</description>
                     <bitOffset>25</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWM7_CLK_REQ</name>
                     <description>PWM7 Clock Reuqired</description>
                     <bitOffset>26</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWM8_CLK_REQ</name>
                     <description>PWM8 Clock Reuqired</description>
                     <bitOffset>27</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>EC_REG_BANK_CLK_REQ</name>
                     <description>EC_REG_BANK Clock Reuqired</description>
                     <bitOffset>29</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TMR16_0_CLK_REQ</name>
                     <description>TIMER16_0 Clock Reuqired</description>
                     <bitOffset>30</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TMR16_1_CLK_REQ</name>
                     <description>TIMER16_1 Clock Reuqired</description>
                     <bitOffset>31</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CLK_REQ_2</name>
               <description>Clock Required 2 Register</description>
               <addressOffset>0x58</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>LPC_CLK_REQ</name>
                     <description>LPC Clock Reuqired</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>UART_0_CLK_REQ</name>
                     <description>UART 0 Clock Reuqired</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>UART_1_CLK_REQ</name>
                     <description>UART 1 Clock Reuqired</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GLBL_CFG_CLK_REQ</name>
                     <description>GLBL_CFG Clock Reuqired</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ACPI_EC_0_CLK_REQ</name>
                     <description>ACPI EC 0 Clock Reuqired</description>
                     <bitOffset>13</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ACPI_EC_1_CLK_REQ</name>
                     <description>ACPI EC 1 Clock Reuqired</description>
                     <bitOffset>14</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ACPI_PM1_CLK_REQ</name>
                     <description>ACPI PM1 Clock Reuqired</description>
                     <bitOffset>15</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>EMU_8042_CLK_REQ</name>
                     <description>8042 Emulation Clock Reuqired</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MAILBOX_CLK_REQ</name>
                     <description>Mailbox Clock Reuqired</description>
                     <bitOffset>17</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RTC_CLK_REQ</name>
                     <description>RTC Clock Reuqired</description>
                     <bitOffset>18</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ESPI_CLK_REQ</name>
                     <description>eSPI Clock Reuqired</description>
                     <bitOffset>19</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ACPI_EC_2_CLK_REQ</name>
                     <description>ACPI EC 2 Clock Reuqired</description>
                     <bitOffset>21</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ACPI_EC_3_CLK_REQ</name>
                     <description>ACPI EC 3 Clock Reuqired</description>
                     <bitOffset>22</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ACPI_EC_4_CLK_REQ</name>
                     <description>ACPI EC 4 Clock Reuqired</description>
                     <bitOffset>23</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PORT80_0_CLK_REQ</name>
                     <description>Port80 0 Clock Reuqired</description>
                     <bitOffset>25</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PORT80_1_CLK_REQ</name>
                     <description>Port80 1 Clock Reuqired</description>
                     <bitOffset>26</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>KBCEM_CLK_REQ</name>
                     <description>8042EM Clock Reuqired (8042EM_CLK_REQ)</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CLK_REQ_3</name>
               <description>Clock Required 3 Register</description>
               <addressOffset>0x5C</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>ADC_CLK_REQ</name>
                     <description>ADC Clock Reuqired</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PS2_0_CLK_REQ</name>
                     <description>PS2 0 Clock Reuqired</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PS2_1_CLK_REQ</name>
                     <description>PS2 1 Clock Reuqired</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PS2_2_CLK_REQ</name>
                     <description>PS2 2 Clock Reuqired</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GP_SPI0_CLK_REQ</name>
                     <description>GP SPI0 Clock Reuqired</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>HTMR_0_CLK_REQ</name>
                     <description>HTIMER 0 Clock Reuqired</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>KEYSCAN_CLK_REQ</name>
                     <description>KEYSCAN Clock Reuqired</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RPMPWM_CLK_REQ</name>
                     <description>RPM-PWM Clock Reuqired</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SMB1_CLK_REQ</name>
                     <description>SMB1 Clock Reuqired</description>
                     <bitOffset>13</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SMB2_CLK_REQ</name>
                     <description>SMB2 Clock Reuqired</description>
                     <bitOffset>14</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SMB3_CLK_REQ</name>
                     <description>SMB3 Clock Reuqired</description>
                     <bitOffset>15</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>LED0_CLK_REQ</name>
                     <description>LED0 Clock Reuqired</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>LED1_CLK_REQ</name>
                     <description>LED1 Clock Reuqired</description>
                     <bitOffset>17</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>LED2_CLK_REQ</name>
                     <description>LED2 Clock Reuqired</description>
                     <bitOffset>18</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BC_MASTER_CLK_REQ</name>
                     <description>BC Master Clock Reuqired</description>
                     <bitOffset>19</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GP_SPI1_CLK_REQ</name>
                     <description>GP SPI1 Clock Reuqired</description>
                     <bitOffset>20</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TMR16_2_CLK_REQ</name>
                     <description>TIMER16_2 Clock Reuqired</description>
                     <bitOffset>21</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TMR16_3_CLK_REQ</name>
                     <description>TIMER16_3 Clock Reuqired</description>
                     <bitOffset>22</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TMR32_0_CLK_REQ</name>
                     <description>TIMER32_0 Clock Reuqired</description>
                     <bitOffset>23</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TMR32_1_CLK_REQ</name>
                     <description>TIMER32_1 Clock Reuqired</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>LED3_CLK_REQ</name>
                     <description>LED3 Clock Reuqired</description>
                     <bitOffset>25</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PKE_CLK_REQ</name>
                     <description>PKE Clock Reuqired</description>
                     <bitOffset>26</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RNG_CLK_REQ</name>
                     <description>RNG Clock Reuqired</description>
                     <bitOffset>27</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>AES_HASH_CLK_REQ</name>
                     <description>AES_HASH Clock Reuqired</description>
                     <bitOffset>28</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>HTMR_1_CLK_REQ</name>
                     <description>HTIMER 1 Clock Reuqired</description>
                     <bitOffset>29</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CCTMR_CLK_REQ</name>
                     <description>Capture Compare Timer Clock Reuqired</description>
                     <bitOffset>30</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWM9_CLK_REQ</name>
                     <description>PWM9 Clock Reuqired</description>
                     <bitOffset>31</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CLK_REQ_4</name>
               <description>Clock Required 4 Register</description>
               <addressOffset>0x60</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>PWM10_CLK_REQ</name>
                     <description>PWM10 Clock Reuqired</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWM11_CLK_REQ</name>
                     <description>PWM11 Clock Reuqired</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CNT_TMER0_CLK_REQ</name>
                     <description>CNT_TMER0 Clock Reuqired</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CNT_TMER1_CLK_REQ</name>
                     <description>CNT_TMER1 Clock Reuqired</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CNT_TMER2_CLK_REQ</name>
                     <description>CNT_TMER2 Clock Reuqired</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CNT_TMER3_CLK_REQ</name>
                     <description>CNT_TMER3 Clock Reuqired</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RTOS_CLK_REQ</name>
                     <description>PWM6 Clock Reuqired</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RPMPWM1_CLK_REQ</name>
                     <description>RPMPWM 1 Clock Reuqired</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>QSPI_CLK_REQ</name>
                     <description>Quad SPI Clock Reuqired</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BC_MASTER_CLK_REQ</name>
                     <description>BC Master Clock Reuqired</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RC_ID0_CLK_REQ</name>
                     <description>RC_ID0 Clock Reuqired</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RC_ID1_CLK_REQ</name>
                     <description>RC_ID1 Clock Reuqired</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RC_ID2_CLK_REQ</name>
                     <description>RC_ID2 Clock Reuqired</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PROCHOT_CLK_REQ</name>
                     <description>PROCHOT Clock Reuqired</description>
                     <bitOffset>13</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>EEPROM_CLK_REQ</name>
                     <description>EEPROM Clock Reuqired</description>
                     <bitOffset>14</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FUJICL_CLK_REQ</name>
                     <description>Fujitsu Custom Logic Clock Reuqired</description>
                     <bitOffset>15</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>RST_EN_0</name>
               <description>Reset Enable 0 Register</description>
               <addressOffset>0x70</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>JTAG_STAP_RST_EN</name>
                     <description>JTAG STAP Reset Enable</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>EFUSE_RST_EN</name>
                     <description>eFuse Reset Enable</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ISPI_RST_EN</name>
                     <description>ISPI Reset Enable</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>RST_EN_1</name>
               <description>Reset Enable 1 Register</description>
               <addressOffset>0x74</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>INT_RST_EN</name>
                     <description>Interrupt Reset Enable</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PECI_RST_EN</name>
                     <description>PECI Reset Enable</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TACH0_RST_EN</name>
                     <description>TACH0 Reset Enable</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWM0_RST_EN</name>
                     <description>PWM0 Reset Enable</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PMC_RST_EN</name>
                     <description>PMC Reset Enable</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DMA_RST_EN</name>
                     <description>DMA Reset Enable</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TFDP_RST_EN</name>
                     <description>TFDP Reset Enable</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PROCESSOR_RST_EN</name>
                     <description>PROCESSOR Reset Enable</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>WDT_RST_EN</name>
                     <description>WDT Reset Enable</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SMB0_RST_EN</name>
                     <description>SMB0 Reset Enable</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TACH1_RST_EN</name>
                     <description>TACH1 Reset Enable</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TACH2_RST_EN</name>
                     <description>TACH2 Reset Enable</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWM1_RST_EN</name>
                     <description>PWM1 Reset Enable</description>
                     <bitOffset>20</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWM2_RST_EN</name>
                     <description>PWM2 Reset Enable</description>
                     <bitOffset>21</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWM3_RST_EN</name>
                     <description>PWM3 Reset Enable</description>
                     <bitOffset>22</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWM4_RST_EN</name>
                     <description>PWM4 Reset Enable</description>
                     <bitOffset>23</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWM5_RST_EN</name>
                     <description>PWM5 Reset Enable</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWM6_RST_EN</name>
                     <description>PWM6 Reset Enable</description>
                     <bitOffset>25</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWM7_RST_EN</name>
                     <description>PWM7 Reset Enable</description>
                     <bitOffset>26</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWM8_RST_EN</name>
                     <description>PWM8 Reset Enable</description>
                     <bitOffset>27</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>EC_REG_BANK_RST_EN</name>
                     <description>EC_REG_BANK Reset Enable</description>
                     <bitOffset>29</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TMR16_0_RST_EN</name>
                     <description>TIMER16_0 Reset Enable</description>
                     <bitOffset>30</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TMR16_1_RST_EN</name>
                     <description>TIMER16_1 Reset Enable</description>
                     <bitOffset>31</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>RST_EN_2</name>
               <description>Reset Enable 2 Register</description>
               <addressOffset>0x78</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>LPC_RST_EN</name>
                     <description>LPC Reset Enable</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>UART_0_RST_EN</name>
                     <description>UART 0 Reset Enable</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>UART_1_RST_EN</name>
                     <description>UART 1 Reset Enable</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GLBL_CFG_RST_EN</name>
                     <description>GLBL_CFG Reset Enable</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ACPI_EC_0_RST_EN</name>
                     <description>ACPI EC 0 Reset Enable</description>
                     <bitOffset>13</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ACPI_EC_1_RST_EN</name>
                     <description>ACPI EC 1 Reset Enable</description>
                     <bitOffset>14</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ACPI_PM1_RST_EN</name>
                     <description>ACPI PM1 Reset Enable</description>
                     <bitOffset>15</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>EMU_8042_RST_EN</name>
                     <description>8042 Emulation Reset Enable</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MAILBOX_RST_EN</name>
                     <description>Mailbox Reset Enable</description>
                     <bitOffset>17</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RTC_RST_EN</name>
                     <description>RTC Reset Enable</description>
                     <bitOffset>18</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ESPI_RST_EN</name>
                     <description>eSPI Reset Enable</description>
                     <bitOffset>19</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ACPI_EC_2_RST_EN</name>
                     <description>ACPI EC 2 Reset Enable</description>
                     <bitOffset>21</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ACPI_EC_3_RST_EN</name>
                     <description>ACPI EC 3 Reset Enable</description>
                     <bitOffset>22</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ACPI_EC_4_RST_EN</name>
                     <description>ACPI EC 4 Reset Enable</description>
                     <bitOffset>23</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PORT80_0_RST_EN</name>
                     <description>Port80 0 Reset Enable</description>
                     <bitOffset>25</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PORT80_1_RST_EN</name>
                     <description>Port80 1 Reset Enable</description>
                     <bitOffset>26</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>KBCEM_RST_EN</name>
                     <description>8042EM Reset Enable (8042EM_RST_EN)</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>RST_EN_3</name>
               <description>Reset Enable 3 Register</description>
               <addressOffset>0x7C</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>ADC_RST_EN</name>
                     <description>ADC Reset Enable</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PS2_0_RST_EN</name>
                     <description>PS2 0 Reset Enable</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PS2_1_RST_EN</name>
                     <description>PS2 1 Reset Enable</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PS2_2_RST_EN</name>
                     <description>PS2 2 Reset Enable</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GP_SPI0_RST_EN</name>
                     <description>GP SPI0 Reset Enable</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>HTMR_0_RST_EN</name>
                     <description>HTIMER 0 Reset Enable</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>KEYSCAN_RST_EN</name>
                     <description>KEYSCAN Reset Enable</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RPMPWM_RST_EN</name>
                     <description>RPM-PWM Reset Enable</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SMB1_RST_EN</name>
                     <description>SMB1 Reset Enable</description>
                     <bitOffset>13</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SMB2_RST_EN</name>
                     <description>SMB2 Reset Enable</description>
                     <bitOffset>14</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SMB3_RST_EN</name>
                     <description>SMB3 Reset Enable</description>
                     <bitOffset>15</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>LED0_RST_EN</name>
                     <description>LED0 Reset Enable</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>LED1_RST_EN</name>
                     <description>LED1 Reset Enable</description>
                     <bitOffset>17</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>LED2_RST_EN</name>
                     <description>LED2 Reset Enable</description>
                     <bitOffset>18</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BC_MASTER_RST_EN</name>
                     <description>BC Master Reset Enable</description>
                     <bitOffset>19</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GP_SPI1_RST_EN</name>
                     <description>GP SPI1 Reset Enable</description>
                     <bitOffset>20</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TMR16_2_RST_EN</name>
                     <description>TIMER16_2 Reset Enable</description>
                     <bitOffset>21</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TMR16_3_RST_EN</name>
                     <description>TIMER16_3 Reset Enable</description>
                     <bitOffset>22</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TMR32_0_RST_EN</name>
                     <description>TIMER32_0 Reset Enable</description>
                     <bitOffset>23</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TMR32_1_RST_EN</name>
                     <description>TIMER32_1 Reset Enable</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>LED3_RST_EN</name>
                     <description>LED3 Reset Enable</description>
                     <bitOffset>25</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PKE_RST_EN</name>
                     <description>PKE Reset Enable</description>
                     <bitOffset>26</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RNG_RST_EN</name>
                     <description>RNG Reset Enable</description>
                     <bitOffset>27</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>AES_HASH_RST_EN</name>
                     <description>AES_HASH Reset Enable</description>
                     <bitOffset>28</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>HTMR_1_RST_EN</name>
                     <description>HTIMER 1 Reset Enable</description>
                     <bitOffset>29</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CCTMR_RST_EN</name>
                     <description>Capture Compare Timer Reset Enable</description>
                     <bitOffset>30</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWM9_RST_EN</name>
                     <description>PWM9 Reset Enable</description>
                     <bitOffset>31</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>RST_EN_4</name>
               <description>Reset Enable 4 Register</description>
               <addressOffset>0x80</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>PWM10_RST_EN</name>
                     <description>PWM10 Reset Enable</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWM11_RST_EN</name>
                     <description>PWM11 Reset Enable</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CNT_TMER0_RST_EN</name>
                     <description>CNT_TMER0 Reset Enable</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CNT_TMER1_RST_EN</name>
                     <description>CNT_TMER1 Reset Enable</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CNT_TMER2_RST_EN</name>
                     <description>CNT_TMER2 Reset Enable</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CNT_TMER3_RST_EN</name>
                     <description>CNT_TMER3 Reset Enable</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RTOS_RST_EN</name>
                     <description>PWM6 Reset Enable</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RPMPWM1_RST_EN</name>
                     <description>RPMPWM 1 Reset Enable</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>QSPI_RST_EN</name>
                     <description>Quad SPI Reset Enable</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BC_MASTER_RST_EN</name>
                     <description>BC Master Reset Enable</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RC_ID0_RST_EN</name>
                     <description>RC_ID0 Reset Enable</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RC_ID1_RST_EN</name>
                     <description>RC_ID1 Reset Enable</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RC_ID2_RST_EN</name>
                     <description>RC_ID2 Reset Enable</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PROCHOT_RST_EN</name>
                     <description>PROCHOT Reset Enable</description>
                     <bitOffset>13</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>EEPROM_RST_EN</name>
                     <description>EEPROM Reset Enable</description>
                     <bitOffset>14</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FUJICL_RST_EN</name>
                     <description>Fujitsu Custom Logic Reset Enable</description>
                     <bitOffset>15</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>DMA_MAIN</name>
         <version>851.0</version>
         <description>DMA Main Registers</description>
         <groupName>DMA_MAIN</groupName>
         <prependToName>DMA_MAIN_</prependToName>
         <baseAddress>0x40002400</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x8</size>
            <usage>registers</usage>
         </addressBlock>
         <registers>
            <register>
               <name>ACTRST</name>
               <description>Soft reset the entire module. Enable the blocks operation.</description>
               <addressOffset>0x0</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>ACT</name>
                     <description>Enable the blocks operation. (R/WS)\n                 1=Enable block. Each individual channel must be enabled separately.\n                 0=Disable all channels.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SOFT_RST</name>
                     <description>Soft reset the entire module. This bit is self-clearing.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>DATA_PKT</name>
               <description>Debug register that has the data that is stored in the Data Packet. This data is read data from the currently active transfer source.</description>
               <addressOffset>0x4</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <resetValue>0x00000000</resetValue>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>DMA_CHAN00</name>
         <version>851.0</version>
         <description>DMA Channel 00 Registers</description>
         <groupName>DMA_CHAN00</groupName>
         <prependToName>DMA_CHAN00_</prependToName>
         <baseAddress>0x40002440</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x2C</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>DMA_CH00</name>
            <value>24</value>
         </interrupt>
         <registers>
            <register>
               <name>ACTIVATE</name>
               <description>Enable this channel for operation. The DMA Main Control: Activate must also be enabled for this channel to be operational.</description>
               <addressOffset>0x0</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>CHN</name>
                     <description>Enable this channel for operation. The DMA Main Control:Activate must also be enabled for this channel to be operational.\n              1=Enable channel(block). Each individual channel must be enabled separately.\n                0=Disable channel(block).</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MSTART</name>
               <description>This is the starting address for the Memory device.</description>
               <addressOffset>0x4</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>MEND</name>
               <description>This is the ending address for the Memory device.</description>
               <addressOffset>0x8</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>DSTART</name>
               <description>This is the Master Device address.</description>
               <addressOffset>0xC</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>CTRL</name>
               <description>DMA Channel N Control</description>
               <addressOffset>0x10</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>RUN</name>
                     <description>This is a control field. Note: This bit only applies to Hardware Flow Control mode.\n          1= This channel is enabled and will service transfer requests\n                0=This channel is disabled. All transfer requests are ignored.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>REQ</name>
                     <description>This is a status field.\n            1= There is a transfer request from the Master Device\n                0= There is no transfer request from the Master Device</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DONE</name>
                     <description>This is a status signal. It is only valid while DMA Channel Control: Run is Enabled. \n            This is the inverse of the DMA Channel Control: Busy field, except this is qualified with the DMA Channel Control:Run field.\n            1=Channel is done\n              0=Channel is not done or it is OFF</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>STS</name>
                     <description>This is a status signal. The status decode is listed in priority order with the highest priority first.\n          3: Error detected by the DMA\n          2: The DMA Channel is externally done, in that the Device has terminated the transfer over the Hardware Flow Control through the Port dma_term\n         1: The DMA Channel is locally done, in that Memory Start Address equals Memory End Address\n               0: DMA Channel Control:Run is Disabled (0x0)</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>2</bitWidth>
                     <enumeratedValues>
                        <name>STSSelect</name>
                        <enumeratedValue>
                           <name>ERROR</name>
                           <description>3: Error detected by the DMA</description>
                           <value>0x3</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>EXT_DONE</name>
                           <description>2: The DMA Channel is externally done, in that the Device has terminated the transfer over the Hardware Flow Control through the Port dma_term</description>
                           <value>0x2</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>LOC_DONE</name>
                           <description>1: The DMA Channel is locally done, in that Memory Start Address equals Memory End Address</description>
                           <value>0x1</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>DIS</name>
                           <description>0: DMA Channel Control:Run is Disabled (0x0)</description>
                           <value>0x0</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>BUSY</name>
                     <description>This is a status signal.\n                 1=The DMA Channel is busy (FSM is not IDLE)\n              0=The DMA Channel is not busy (FSM is IDLE)</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TX_DIR</name>
                     <description>This determines the direction of the DMA Transfer.\n       1=Data Packet Read from Memory Start Address followed by Data Packet Write to Device Address\n            0=Data Packet Read from Device Address followed by Data Packet Write to Memory Start Address</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>HW_FLOW_CTRL_DEV</name>
                     <description>This is the device that is connected to this channel as its Hardware Flow Control master.\n       The Flow Control Interface is a bus with each master concatenated onto it.\n                This selects which bus index of the concatenated Flow Control Interface bus is targeted towards this channel.\n            The Flow Control Interface Port list is dma_req, dma_term, and dma_done.</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>7</bitWidth>
                  </field>
                  <field>
                     <name>INC_MEM_ADDR</name>
                     <description>This will enable an auto-increment to the DMA Channel Memory Address.\n              1=Increment the DMA Channel Memory Address by DMA Channel Control:Transfer Size after every Data Packet transfer\n           0=Do nothing</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>INC_DEV_ADDR</name>
                     <description>This will enable an auto-increment to the DMA Channel Device Address.\n             1: Increment the DMA Channel Device Address by DMA Channel Control:Transfer Size after every Data Packet transfer\n                 0: Do nothing</description>
                     <bitOffset>17</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>LOCK</name>
                     <description>This is used to lock the arbitration of the Channel Arbiter on this channel once this channel is granted. Once this is locked, it will remain on the arbiter until it has completed it transfer (either the Transfer Aborted, Transfer Done or Transfer Terminated conditions).</description>
                     <bitOffset>18</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DIS_HW_FLOW_CTRL</name>
                     <description>This will Disable the Hardware Flow Control. When disabled, any DMA Master device attempting to communicate to the DMA over the DMA Flow Control Interface (Ports: dma_req, dma_term, and dma_done) will be ignored. This should be set before using the DMA channel in Firmware Flow Control mode.</description>
                     <bitOffset>19</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TRANS_SIZE</name>
                     <description>This is the transfer size in Bytes of each Data Packet transfer.\n              Note: The transfer size must be a legal AMBA transfer size. Valid sizes are 1, 2 and 4 Bytes.</description>
                     <bitOffset>20</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>TRANS_GO</name>
                     <description>This is used for the Firmware Flow Control DMA transfer.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TRANS_ABORT</name>
                     <description>This is used to abort the current transfer on this DMA Channel. The aborted transfer will be forced to terminate immediately.</description>
                     <bitOffset>25</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>ISTS</name>
               <description>DMA Channel N Interrupt Status</description>
               <addressOffset>0x14</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>BUS_ERR</name>
                     <description>This is an interrupt source register. This flags when there is an Error detected over the internal 32-bit Bus.\n         1: Error detected. (R/WC)</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FLOW_CTRL</name>
                     <description>This is an interrupt source register. This flags when the DMA Channel has encountered a Hardware Flow Control Request\n             after the DMA Channel has completed the transfer. This means the Master Device is attempting to overflow the DMA.\n          1=Hardware Flow Control is requesting after the transfer has completed\n           0=No Hardware Flow Control event</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DONE</name>
                     <description>This is an interrupt source register. This flags when the DMA Channel has completed a transfer successfully on its side.\n      A completed transfer is defined as when the DMA Channel reaches its limit; Memory Start Address equals Memory End Address.\n              A completion due to a Hardware Flow Control Terminate will not flag this interrupt.\n                 1=Memory Start Address equals Memory End Address\n           0=Memory Start Address does not equal Memory End Address</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>IEN</name>
               <description>DMA CHANNEL N INTERRUPT ENABLE</description>
               <addressOffset>0x18</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>STS_EN_BUS_ERR</name>
                     <description>This is an interrupt enable for DMA Channel Interrupt:Status Bus Error.\n            1=Enable Interrupt\n                   0=Disable Interrupt</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>STS_EN_FLOW_CTRL</name>
                     <description>This is an interrupt enable for DMA Channel Interrupt:Status Flow Control Error.\n            1=Enable Interrupt\n              0=Disable Interrupt</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>STS_EN_DONE</name>
                     <description>This is an interrupt enable for DMA Channel Interrupt:Status Done.\n             1=Enable Interrupt\n                      0=Disable Interrupt</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CRC_EN</name>
               <description>DMA CHANNEL N CRC ENABLE</description>
               <addressOffset>0x20</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>MODE</name>
                     <description>1=Enable the calculation of CRC-32 for DMA Channel N\n           0=Disable the calculation of CRC-32 for DMA Channel N</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>POST_TRANS</name>
                     <description>The bit enables the transfer of the calculated CRC-32 after the completion of the DMA transaction.\n        If the DMA transaction is aborted by either firmware or an internal bus error, the transfer will not occur.\n           If the target of the DMA transfer is a device and the device signaled the termination of the DMA transaction,\n          the CRC post transfer will not occur.\n           1=Enable the transfer of CRC-32 for DMA Channel N after the DMA transaction completes\n           0=Disable the automatic transfer of the CRC</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CRC_DATA</name>
               <description>DMA CHANNEL N CRC DATA</description>
               <addressOffset>0x24</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>CRC</name>
                     <description>Writes to this register initialize the CRC generator. Reads from this register return the output of the\n          CRC that is calculated from the data transferred by DMA Channel N. The output of the CRC generator is bit-reversed\n        and inverted on reads, as required by the CRC-32-IEEE definition. A CRC can be accumulated across multiple DMA transactions\n          on Channel N. If it is necessary to save the intermediate CRC value, the result of the read of this register must be\n              bit-reversed and inverted before being written back to this register.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CRC_POST_STS</name>
               <description>DMA CHANNEL N CRC POST STATUS</description>
               <addressOffset>0x28</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>CRC_DONE</name>
                     <description>This bit is set to '1b' when the CRC calculation has completed from either normal or forced termination.\n        It is cleared to '0b' when the DMA controller starts a new transfer on the channel.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CRC_RUNNING</name>
                     <description>This bit is set to '1b' when the DMA controller starts the post-transfer transmission of the CRC.\n          It is only set when the post-transfer is enabled by the CRC_POST_TRANSFER_ENABLE field. This bit is cleared\n           to '0b' when the post-transfer completes.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CRC_DATA_DONE</name>
                     <description>This bit is set to '1b' when the DMA controller has completed the post-transfer of the CRC data.\n       This bit is cleared to '0b' when the a new DMA transfer starts.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CRC_DATA_READY</name>
                     <description>This bit is set to '1b' when the DMA controller is processing the post-transfer of the CRC data.\n        This bit is cleared to '0b' when the post-transfer completes.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>DMA_CHAN01</name>
         <version>851.0</version>
         <description>DMA Channel 01 Registers</description>
         <groupName>DMA_CHAN01</groupName>
         <prependToName>DMA_CHAN01_</prependToName>
         <baseAddress>0x40002480</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x2C</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>DMA_CH01</name>
            <value>25</value>
         </interrupt>
         <registers>
            <register>
               <name>ACTIVATE</name>
               <description>Enable this channel for operation. The DMA Main Control: Activate must also be enabled for this channel to be operational.</description>
               <addressOffset>0x0</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>CHN</name>
                     <description>Enable this channel for operation. The DMA Main Control:Activate must also be enabled for this channel to be operational.\n           1=Enable channel(block). Each individual channel must be enabled separately.\n               0=Disable channel(block).</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MSTART</name>
               <description>This is the starting address for the Memory device.</description>
               <addressOffset>0x4</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>MEND</name>
               <description>This is the ending address for the Memory device.</description>
               <addressOffset>0x8</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>DSTART</name>
               <description>This is the Master Device address.</description>
               <addressOffset>0xC</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>CTRL</name>
               <description>DMA Channel N Control</description>
               <addressOffset>0x10</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>RUN</name>
                     <description>This is a control field. Note: This bit only applies to Hardware Flow Control mode.\n          1= This channel is enabled and will service transfer requests\n             0=This channel is disabled. All transfer requests are ignored.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>REQ</name>
                     <description>This is a status field.\n         1= There is a transfer request from the Master Device\n             0= There is no transfer request from the Master Device</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DONE</name>
                     <description>This is a status signal. It is only valid while DMA Channel Control: Run is Enabled. \n              This is the inverse of the DMA Channel Control: Busy field, except this is qualified with the DMA Channel Control:Run field.\n          1=Channel is done\n               0=Channel is not done or it is OFF</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>STS</name>
                     <description>This is a status signal. The status decode is listed in priority order with the highest priority first.\n           3: Error detected by the DMA\n           2: The DMA Channel is externally done, in that the Device has terminated the transfer over the Hardware Flow Control through the Port dma_term\n      1: The DMA Channel is locally done, in that Memory Start Address equals Memory End Address\n          0: DMA Channel Control:Run is Disabled (0x0)</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>2</bitWidth>
                     <enumeratedValues>
                        <name>STSSelect</name>
                        <enumeratedValue>
                           <name>ERROR</name>
                           <description>3: Error detected by the DMA</description>
                           <value>0x3</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>EXT_DONE</name>
                           <description>2: The DMA Channel is externally done, in that the Device has terminated the transfer over the Hardware Flow Control through the Port dma_term</description>
                           <value>0x2</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>LOC_DONE</name>
                           <description>1: The DMA Channel is locally done, in that Memory Start Address equals Memory End Address</description>
                           <value>0x1</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>DIS</name>
                           <description>0: DMA Channel Control:Run is Disabled (0x0)</description>
                           <value>0x0</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>BUSY</name>
                     <description>This is a status signal.\n               1=The DMA Channel is busy (FSM is not IDLE)\n             0=The DMA Channel is not busy (FSM is IDLE)</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TX_DIR</name>
                     <description>This determines the direction of the DMA Transfer.\n            1=Data Packet Read from Memory Start Address followed by Data Packet Write to Device Address\n                0=Data Packet Read from Device Address followed by Data Packet Write to Memory Start Address</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>HW_FLOW_CTRL_DEV</name>
                     <description>This is the device that is connected to this channel as its Hardware Flow Control master.\n         The Flow Control Interface is a bus with each master concatenated onto it.\n                   This selects which bus index of the concatenated Flow Control Interface bus is targeted towards this channel.\n         The Flow Control Interface Port list is dma_req, dma_term, and dma_done.</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>7</bitWidth>
                  </field>
                  <field>
                     <name>INC_MEM_ADDR</name>
                     <description>This will enable an auto-increment to the DMA Channel Memory Address.\n                 1=Increment the DMA Channel Memory Address by DMA Channel Control:Transfer Size after every Data Packet transfer\n               0=Do nothing</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>INC_DEV_ADDR</name>
                     <description>This will enable an auto-increment to the DMA Channel Device Address.\n           1: Increment the DMA Channel Device Address by DMA Channel Control:Transfer Size after every Data Packet transfer\n           0: Do nothing</description>
                     <bitOffset>17</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>LOCK</name>
                     <description>This is used to lock the arbitration of the Channel Arbiter on this channel once this channel is granted. Once this is locked, it will remain on the arbiter until it has completed it transfer (either the Transfer Aborted, Transfer Done or Transfer Terminated conditions).</description>
                     <bitOffset>18</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DIS_HW_FLOW_CTRL</name>
                     <description>This will Disable the Hardware Flow Control. When disabled, any DMA Master device attempting to communicate to the DMA over the DMA Flow Control Interface (Ports: dma_req, dma_term, and dma_done) will be ignored. This should be set before using the DMA channel in Firmware Flow Control mode.</description>
                     <bitOffset>19</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TRANS_SIZE</name>
                     <description>This is the transfer size in Bytes of each Data Packet transfer.\n      Note: The transfer size must be a legal AMBA transfer size. Valid sizes are 1, 2 and 4 Bytes.</description>
                     <bitOffset>20</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>TRANS_GO</name>
                     <description>This is used for the Firmware Flow Control DMA transfer.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TRANS_ABORT</name>
                     <description>This is used to abort the current transfer on this DMA Channel. The aborted transfer will be forced to terminate immediately.</description>
                     <bitOffset>25</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>ISTS</name>
               <description>DMA Channel N Interrupt Status</description>
               <addressOffset>0x14</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>BUS_ERROR</name>
                     <description>This is an interrupt source register. This flags when there is an Error detected over the internal 32-bit Bus.\n         1: Error detected. (R/WC)</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FLOW_CTRL</name>
                     <description>This is an interrupt source register. This flags when the DMA Channel has encountered a Hardware Flow Control Request\n          after the DMA Channel has completed the transfer. This means the Master Device is attempting to overflow the DMA.\n           1=Hardware Flow Control is requesting after the transfer has completed\n         0=No Hardware Flow Control event</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DONE</name>
                     <description>This is an interrupt source register. This flags when the DMA Channel has completed a transfer successfully on its side.\n      A completed transfer is defined as when the DMA Channel reaches its limit; Memory Start Address equals Memory End Address.\n                A completion due to a Hardware Flow Control Terminate will not flag this interrupt.\n           1=Memory Start Address equals Memory End Address\n         0=Memory Start Address does not equal Memory End Address</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>IEN</name>
               <description>DMA CHANNEL N INTERRUPT ENABLE</description>
               <addressOffset>0x18</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>STS_EN_BUS_ERR</name>
                     <description>This is an interrupt enable for DMA Channel Interrupt:Status Bus Error.\n       1=Enable Interrupt\n          0=Disable Interrupt</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>STS_EN_FLOW_CTRL</name>
                     <description>This is an interrupt enable for DMA Channel Interrupt:Status Flow Control Error.\n        1=Enable Interrupt\n             0=Disable Interrupt</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>STS_EN_DONE</name>
                     <description>This is an interrupt enable for DMA Channel Interrupt:Status Done.\n         1=Enable Interrupt\n                  0=Disable Interrupt</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>FILL_EN</name>
               <description>DMA CHANNEL N FILL ENABLE</description>
               <addressOffset>0x20</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>MODE</name>
                     <description>1=Enable the calculation of CRC-32 for DMA Channel N\n             0=Disable the calculation of CRC-32 for DMA Channel N</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>FILL_DATA</name>
               <description>DMA CHANNEL N FILL DATA</description>
               <addressOffset>0x24</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>DATA</name>
                     <description>This is the data pattern used to fill memory.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>FILL_STS</name>
               <description>DMA CHANNEL N FILL STATUS</description>
               <addressOffset>0x28</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>DONE</name>
                     <description>This bit is set to '1b' when the CRC calculation has completed from either normal or forced termination.\n        It is cleared to '0b' when the DMA controller starts a new transfer on the channel.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RUNNING</name>
                     <description>This bit is set to '1b' when the DMA controller starts the post-transfer transmission of the CRC.\n          It is only set when the post-transfer is enabled by the CRC_POST_TRANSFER_ENABLE field. This bit is cleared\n             to '0b' when the post-transfer completes.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>DMA_CHAN02</name>
         <version>851.0</version>
         <description>DMA Channel 00 Registers</description>
         <groupName>DMA_CHAN02</groupName>
         <prependToName>DMA_CHAN02_</prependToName>
         <baseAddress>0x400024C0</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x19</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>DMA_CH02</name>
            <value>26</value>
         </interrupt>
         <registers>
            <register>
               <name>ACTIVATE</name>
               <description>Enable this channel for operation. The DMA Main Control: Activate must also be enabled for this channel to be operational.</description>
               <addressOffset>0x0</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>CHN</name>
                     <description>Enable this channel for operation. The DMA Main Control:Activate must also be enabled for this channel to be operational.\n        1=Enable channel(block). Each individual channel must be enabled separately.\n          0=Disable channel(block).</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MSTART</name>
               <description>This is the starting address for the Memory device.</description>
               <addressOffset>0x4</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>MEND</name>
               <description>This is the ending address for the Memory device.</description>
               <addressOffset>0x8</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>DSTART</name>
               <description>This is the Master Device address.</description>
               <addressOffset>0xC</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>CTRL</name>
               <description>DMA Channel N Control</description>
               <addressOffset>0x10</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>RUN</name>
                     <description>This is a control field. Note: This bit only applies to Hardware Flow Control mode.\n          1= This channel is enabled and will service transfer requests\n             0=This channel is disabled. All transfer requests are ignored.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>REQ</name>
                     <description>This is a status field.\n            1= There is a transfer request from the Master Device\n                  0= There is no transfer request from the Master Device</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DONE</name>
                     <description>This is a status signal. It is only valid while DMA Channel Control: Run is Enabled. \n           This is the inverse of the DMA Channel Control: Busy field, except this is qualified with the DMA Channel Control:Run field.\n          1=Channel is done\n          0=Channel is not done or it is OFF</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>STS</name>
                     <description>This is a status signal. The status decode is listed in priority order with the highest priority first.\n             3: Error detected by the DMA\n                          2: The DMA Channel is externally done, in that the Device has terminated the transfer over the Hardware Flow Control through the Port dma_term\n      1: The DMA Channel is locally done, in that Memory Start Address equals Memory End Address\n          0: DMA Channel Control:Run is Disabled (0x0)</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>2</bitWidth>
                     <enumeratedValues>
                        <name>STSSelect</name>
                        <enumeratedValue>
                           <name>ERROR</name>
                           <description>3: Error detected by the DMA</description>
                           <value>0x3</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>EXT_DONE</name>
                           <description>2: The DMA Channel is externally done, in that the Device has terminated the transfer over the Hardware Flow Control through the Port dma_term</description>
                           <value>0x2</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>LOC_DONE</name>
                           <description>1: The DMA Channel is locally done, in that Memory Start Address equals Memory End Address</description>
                           <value>0x1</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>DIS</name>
                           <description>0: DMA Channel Control:Run is Disabled (0x0)</description>
                           <value>0x0</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>BUSY</name>
                     <description>This is a status signal.\n               1=The DMA Channel is busy (FSM is not IDLE)\n             0=The DMA Channel is not busy (FSM is IDLE)</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TX_DIR</name>
                     <description>This determines the direction of the DMA Transfer.\n              1=Data Packet Read from Memory Start Address followed by Data Packet Write to Device Address\n              0=Data Packet Read from Device Address followed by Data Packet Write to Memory Start Address</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>HW_FLOW_CTRL_DEV</name>
                     <description>This is the device that is connected to this channel as its Hardware Flow Control master.\n        The Flow Control Interface is a bus with each master concatenated onto it.\n                This selects which bus index of the concatenated Flow Control Interface bus is targeted towards this channel.\n       The Flow Control Interface Port list is dma_req, dma_term, and dma_done.</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>7</bitWidth>
                  </field>
                  <field>
                     <name>INC_MEM_ADDR</name>
                     <description>This will enable an auto-increment to the DMA Channel Memory Address.\n               1=Increment the DMA Channel Memory Address by DMA Channel Control:Transfer Size after every Data Packet transfer\n           0=Do nothing</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>INC_DEV_ADDR</name>
                     <description>This will enable an auto-increment to the DMA Channel Device Address.\n              1: Increment the DMA Channel Device Address by DMA Channel Control:Transfer Size after every Data Packet transfer\n              0: Do nothing</description>
                     <bitOffset>17</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>LOCK</name>
                     <description>This is used to lock the arbitration of the Channel Arbiter on this channel once this channel is granted. Once this is locked, it will remain on the arbiter until it has completed it transfer (either the Transfer Aborted, Transfer Done or Transfer Terminated conditions).</description>
                     <bitOffset>18</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DIS_HW_FLOW_CTRL</name>
                     <description>This will Disable the Hardware Flow Control. When disabled, any DMA Master device attempting to communicate to the DMA over the DMA Flow Control Interface (Ports: dma_req, dma_term, and dma_done) will be ignored. This should be set before using the DMA channel in Firmware Flow Control mode.</description>
                     <bitOffset>19</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TRANS_SIZE</name>
                     <description>This is the transfer size in Bytes of each Data Packet transfer.\n         Note: The transfer size must be a legal AMBA transfer size. Valid sizes are 1, 2 and 4 Bytes.</description>
                     <bitOffset>20</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>TRANS_GO</name>
                     <description>This is used for the Firmware Flow Control DMA transfer.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TRANS_ABORT</name>
                     <description>This is used to abort the current transfer on this DMA Channel. The aborted transfer will be forced to terminate immediately.</description>
                     <bitOffset>25</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>ISTS</name>
               <description>DMA Channel N Interrupt Status</description>
               <addressOffset>0x14</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>BUS_ERR</name>
                     <description>This is an interrupt source register. This flags when there is an Error detected over the internal 32-bit Bus.\n        1: Error detected. (R/WC)</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FLOW_CTRL</name>
                     <description>This is an interrupt source register. This flags when the DMA Channel has encountered a Hardware Flow Control Request\n           after the DMA Channel has completed the transfer. This means the Master Device is attempting to overflow the DMA.\n            1=Hardware Flow Control is requesting after the transfer has completed\n         0=No Hardware Flow Control event</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DONE</name>
                     <description>This is an interrupt source register. This flags when the DMA Channel has completed a transfer successfully on its side.\n        A completed transfer is defined as when the DMA Channel reaches its limit; Memory Start Address equals Memory End Address.\n            A completion due to a Hardware Flow Control Terminate will not flag this interrupt.\n             1=Memory Start Address equals Memory End Address\n                0=Memory Start Address does not equal Memory End Address</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>IEN</name>
               <description>DMA CHANNEL N INTERRUPT ENABLE</description>
               <addressOffset>0x18</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>STS_EN_BUS_ERR</name>
                     <description>This is an interrupt enable for DMA Channel Interrupt:Status Bus Error.\n         1=Enable Interrupt\n            0=Disable Interrupt</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>STS_EN_FLOW_CTRL</name>
                     <description>This is an interrupt enable for DMA Channel Interrupt:Status Flow Control Error.\n        1=Enable Interrupt\n         0=Disable Interrupt</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>STS_EN_DONE</name>
                     <description>This is an interrupt enable for DMA Channel Interrupt:Status Done.\n           1=Enable Interrupt\n           0=Disable Interrupt</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral derivedFrom="DMA_CHAN02">
         <name>DMA_CHAN03</name>
         <baseAddress>0x40002500</baseAddress>
         <interrupt>
            <name>DMA_CH03</name>
            <value>27</value>
         </interrupt>
      </peripheral>
      <peripheral derivedFrom="DMA_CHAN02">
         <name>DMA_CHAN04</name>
         <baseAddress>0x40002540</baseAddress>
         <interrupt>
            <name>DMA_CH04</name>
            <value>28</value>
         </interrupt>
      </peripheral>
      <peripheral derivedFrom="DMA_CHAN02">
         <name>DMA_CHAN05</name>
         <baseAddress>0x40002580</baseAddress>
         <interrupt>
            <name>DMA_CH05</name>
            <value>29</value>
         </interrupt>
      </peripheral>
      <peripheral derivedFrom="DMA_CHAN02">
         <name>DMA_CHAN06</name>
         <baseAddress>0x400025C0</baseAddress>
         <interrupt>
            <name>DMA_CH06</name>
            <value>30</value>
         </interrupt>
      </peripheral>
      <peripheral derivedFrom="DMA_CHAN02">
         <name>DMA_CHAN07</name>
         <baseAddress>0x40002600</baseAddress>
         <interrupt>
            <name>DMA_CH07</name>
            <value>31</value>
         </interrupt>
      </peripheral>
      <peripheral derivedFrom="DMA_CHAN02">
         <name>DMA_CHAN08</name>
         <baseAddress>0x40002640</baseAddress>
         <interrupt>
            <name>DMA_CH08</name>
            <value>32</value>
         </interrupt>
      </peripheral>
      <peripheral derivedFrom="DMA_CHAN02">
         <name>DMA_CHAN09</name>
         <baseAddress>0x40002680</baseAddress>
         <interrupt>
            <name>DMA_CH09</name>
            <value>33</value>
         </interrupt>
      </peripheral>
      <peripheral derivedFrom="DMA_CHAN02">
         <name>DMA_CHAN10</name>
         <baseAddress>0x400026C0</baseAddress>
         <interrupt>
            <name>DMA_CH10</name>
            <value>34</value>
         </interrupt>
      </peripheral>
      <peripheral derivedFrom="DMA_CHAN02">
         <name>DMA_CHAN11</name>
         <baseAddress>0x40002700</baseAddress>
         <interrupt>
            <name>DMA_CH11</name>
            <value>35</value>
         </interrupt>
      </peripheral>
      <peripheral derivedFrom="DMA_CHAN02">
         <name>DMA_CHAN12</name>
         <baseAddress>0x40002740</baseAddress>
         <interrupt>
            <name>DMA_CH12</name>
            <value>36</value>
         </interrupt>
      </peripheral>
      <peripheral derivedFrom="DMA_CHAN02">
         <name>DMA_CHAN13</name>
         <baseAddress>0x40002780</baseAddress>
         <interrupt>
            <name>DMA_CH13</name>
            <value>37</value>
         </interrupt>
      </peripheral>
      <peripheral>
         <name>ECIA</name>
         <description>The interrupt generation logic is made of 16 groups of signals, each of which\n         consist of a Status register, a Enable register and a Result register. The Status and Enable are\n        latched registers. The Result register is a bit by bit AND function of the Source and Enable registers.\n         All the bits of the Result register are OR'ed together and AND'ed with the corresponding bit in the Block\n         Select register to form the interrupt signal that is routed to the ARM interrupt controller.</description>
         <groupName>ECIA</groupName>
         <prependToName>ECIA_</prependToName>
         <baseAddress>0x4000E000</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x20C</size>
            <usage>registers</usage>
         </addressBlock>
         <registers>
            <cluster>
               <dim>19</dim>
               <dimIncrement>0x14</dimIncrement>
               <name>GIRQ[%s]</name>
               <description/>
               <addressOffset>0x0</addressOffset>
               <register>
                  <name>SRC</name>
                  <description>Status R/W1C</description>
                  <addressOffset>0x0</addressOffset>
                  <size>32</size>
                  <resetValue>0x00000000</resetValue>
               </register>
               <register>
                  <name>EN_SET</name>
                  <description>Write to set source enables</description>
                  <addressOffset>0x4</addressOffset>
                  <size>32</size>
                  <resetValue>0x00000000</resetValue>
               </register>
               <register>
                  <name>RESULT</name>
                  <description>Read-only bitwise OR of Source and Enable</description>
                  <addressOffset>0x8</addressOffset>
                  <size>32</size>
                  <access>read-only</access>
                  <resetValue>0x00000000</resetValue>
               </register>
               <register>
                  <name>EN_CLR</name>
                  <description>Write to clear source enables</description>
                  <addressOffset>0xC</addressOffset>
                  <size>32</size>
                  <resetValue>0x00000000</resetValue>
               </register>
            </cluster>
            <register>
               <name>BLK_EN_SET</name>
               <description>Block Enable Set Register</description>
               <addressOffset>0x200</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>VTOR_EN_SET</name>
                     <description>Each GIRQx bit can be individually enabled to assert an interrupt event.\n          Reads always return the current value of the internal GIRQX_ENABLE bit. The state of the GIRQX_ENABLE bit is determined by\n         the corresponding GIRQX_ENABLE_SET bit and the GIRQX_ENABLE_ CLEAR bit. (0=disabled, 1=enabled) (R/WS)\n           1=Interrupts in the GIRQx Source Register may be enabled\n               0=No effect.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>31</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BLK_EN_CLR</name>
               <description>Block Enable Clear Register.</description>
               <addressOffset>0x204</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>VTOR_EN_CLR</name>
                     <description>Each GIRQx bit can be individually disabled to inhibit an interrupt event.\n        Reads always return the current value of the internal GIRQX_ENABLE bit. The state of the GIRQX_ENABLE bit is determined by\n         the corresponding GIRQX_ENABLE_SET bit and the GIRQX_ENABLE_ CLEAR bit. (0=disabled, 1=enabled) (R/WC)\n                 1=All interrupts in the GIRQx Source Register are disabled\n             0=No effect.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>31</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BLK_IRQ_VTOR</name>
               <description>Block IRQ Vector Register</description>
               <addressOffset>0x208</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>VTOR</name>
                     <description>Each bit in this field reports the status of the group GIRQ interrupt assertion to the NVIC. If the GIRQx interrupt\n       is disabled as a group, by the Block Enable Clear Register, then the corresponding bit will be '0'b and no interrupt will be asserted.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>25</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>GCR</name>
         <version>1011.0</version>
         <description>The Logical Device Configuration registers support motherboard designs in\n        which the resources required by their components are known and assigned by the BIOS\n          at POST.</description>
         <groupName>GCR</groupName>
         <prependToName>GCR_</prependToName>
         <baseAddress>0x400FFF00</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x22</size>
            <usage>registers</usage>
         </addressBlock>
         <registers>
            <register>
               <name>LDN</name>
               <description>A write to this register selects the current logical device. This allows access to the control and configuration\n         registers for each logical device. Note: The Activate command operates only on the selected logical device.</description>
               <addressOffset>0x7</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>DEV_ID</name>
               <description>A read-only register which provides device identification.</description>
               <addressOffset>0x20</addressOffset>
               <size>8</size>
               <access>read-only</access>
               <resetValue>0x2E</resetValue>
            </register>
            <register>
               <name>DEV_REV</name>
               <description>A read-only register which provides device revision information.</description>
               <addressOffset>0x21</addressOffset>
               <size>8</size>
               <access>read-only</access>
               <resetValue>0x00</resetValue>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>UART0</name>
         <version>391.0</version>
         <description>The 16550 UART (Universal Asynchronous Receiver/Transmitter) is a\n          full-function Two Pin Serial Port that supports the standard RS-232 Interface.</description>
         <groupName>UART</groupName>
         <prependToName>UART_</prependToName>
         <baseAddress>0x400F2400</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x3F1</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>UART0</name>
            <value>40</value>
         </interrupt>
         <registers>
            <cluster>
               <name>DATA</name>
               <description>UART when DLAB=0</description>
               <headerStructName>UartData</headerStructName>
               <addressOffset>0x0</addressOffset>
               <register>
                  <name>RX_DAT</name>
                  <description>UART Receive (Read) Buffer Register (DLAB=0)</description>
                  <addressOffset>0x0</addressOffset>
                  <size>8</size>
                  <access>read-only</access>
                  <resetValue>0x00</resetValue>
               </register>
               <register>
                  <name>TX_DAT</name>
                  <description>UART Transmit (Write) Buffer Register (DLAB=0)</description>
                  <addressOffset>0x0</addressOffset>
                  <size>8</size>
                  <access>write-only</access>
                  <resetValue>0x00</resetValue>
               </register>
               <register>
                  <name>IEN</name>
                  <description>UART Interrupt Enable Register (DLAB=0)</description>
                  <addressOffset>0x1</addressOffset>
                  <size>8</size>
                  <resetValue>0x00</resetValue>
                  <fields>
                     <field>
                        <name>ERDAI</name>
                        <description>ERDAI This bit enables the Received Data Available Interrupt (and timeout interrupts in the FIFO mode) when set to logic '1'.</description>
                        <bitOffset>0</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>ETHREI</name>
                        <description>ETHREI This bit enables the Transmitter Holding Register Empty Interrupt when set to logic '1'.</description>
                        <bitOffset>1</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>ELSI</name>
                        <description>ELSI This bit enables the Received Line Status Interrupt when set to logic '1'.</description>
                        <bitOffset>2</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>EMSI</name>
                        <description>EMSI  This bit enables the MODEM Status Interrupt when set to logic '1'.</description>
                        <bitOffset>3</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                  </fields>
               </register>
               <register>
                  <name>FIFO_CR</name>
                  <description>UART FIFO Control Register</description>
                  <addressOffset>0x2</addressOffset>
                  <size>8</size>
                  <access>write-only</access>
                  <resetValue>0x00</resetValue>
                  <fields>
                     <field>
                        <name>EXRF</name>
                        <description>EXRF Enable XMIT and RECV FIFO.</description>
                        <bitOffset>0</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>CLR_RECV_FIFO</name>
                        <description>CLEAR_RECV_FIFO  Setting this bit to a logic '1' clears all bytes in the RCVR FIFO and resets its counter logic to '0'.</description>
                        <bitOffset>1</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>CLR_XMIT_FIFO</name>
                        <description>CLEAR_XMIT_FIFO  Setting this bit to a logic '1' clears all bytes in the XMIT FIFO and resets its counter logic to '0' . The shift register is not cleared. This bit is self-clearing.</description>
                        <bitOffset>2</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>DMA_MODE_SEL</name>
                        <description>DMA_MODE_SELECT  Writing to this bit has no effect on the operation of the UART. The RXRDY and TXRDY pins are not available on this chip.</description>
                        <bitOffset>3</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>RECV_FIFO_TRIG_LVL</name>
                        <description>RECV_FIFO_TRIGGER_LEVEL These bits are used to set the trigger level for the RCVR FIFO interrupt.</description>
                        <bitOffset>6</bitOffset>
                        <bitWidth>2</bitWidth>
                     </field>
                  </fields>
               </register>
               <register>
                  <name>INT_ID</name>
                  <description>UART Interrupt Identification Register</description>
                  <addressOffset>0x2</addressOffset>
                  <size>8</size>
                  <access>read-only</access>
                  <resetValue>0x00</resetValue>
                  <fields>
                     <field>
                        <name>IPEND</name>
                        <description>IPEND  This bit can be used in either a hardwired prioritized or polled environment to indicate whether an interrupt is pending.</description>
                        <bitOffset>0</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>INTID</name>
                        <description>INTID  These bits identify the highest priority interrupt pending</description>
                        <bitOffset>1</bitOffset>
                        <bitWidth>3</bitWidth>
                     </field>
                     <field>
                        <name>FIFO_EN</name>
                        <description>These two bits are set when the FIFO CONTROL Register bit 0 equals 1.</description>
                        <bitOffset>6</bitOffset>
                        <bitWidth>2</bitWidth>
                     </field>
                  </fields>
               </register>
               <register>
                  <name>LCR</name>
                  <description>UART Line Control Register</description>
                  <addressOffset>0x3</addressOffset>
                  <size>8</size>
                  <resetValue>0x00</resetValue>
                  <fields>
                     <field>
                        <name>WORD_LEN</name>
                        <description>WORD_LENGTH These two bits specify the number of bits in each transmitted or received serial character.</description>
                        <bitOffset>0</bitOffset>
                        <bitWidth>2</bitWidth>
                     </field>
                     <field>
                        <name>STOP_BITS</name>
                        <description>STOP_BITS  This bit specifies the number of stop bits in each transmitted or received serial character.</description>
                        <bitOffset>2</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>EN_PAR</name>
                        <description>ENABLE_PARITY  Parity Enable bit.</description>
                        <bitOffset>3</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>PAR_SEL</name>
                        <description>PARITY_SELECT Even Parity Select bit.</description>
                        <bitOffset>4</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>STICK_PAR</name>
                        <description>STICK_PARITY  Stick Parity bit.</description>
                        <bitOffset>5</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>BRK_CTRL</name>
                        <description>BREAK_CONTROL Set Break Control bit</description>
                        <bitOffset>6</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>DLAB</name>
                        <description>DLAB Divisor Latch Access Bit (DLAB).</description>
                        <bitOffset>7</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                  </fields>
               </register>
               <register>
                  <name>MCR</name>
                  <description>UART Modem Control Register</description>
                  <addressOffset>0x4</addressOffset>
                  <size>8</size>
                  <resetValue>0x00</resetValue>
                  <fields>
                     <field>
                        <name>DTR</name>
                        <description>DTR  This bit controls the Data Terminal Ready (nDTR) output.</description>
                        <bitOffset>0</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>RTS</name>
                        <description>RTS  This bit controls the Request To Send (nRTS) output.</description>
                        <bitOffset>1</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>OUT1</name>
                        <description>OUT1 This bit controls the Output 1 (OUT1) bit.</description>
                        <bitOffset>2</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>OUT2</name>
                        <description>OUT2  This bit is used to enable an UART interrupt.</description>
                        <bitOffset>3</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>LOOPBACK</name>
                        <description>LOOPBACK  This bit provides the loopback feature for diagnostic testing of the Serial Port.</description>
                        <bitOffset>4</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                  </fields>
               </register>
               <register>
                  <name>LSR</name>
                  <description>UART Line Status Register</description>
                  <addressOffset>0x5</addressOffset>
                  <size>8</size>
                  <access>read-only</access>
                  <resetValue>0x00</resetValue>
                  <fields>
                     <field>
                        <name>DATA_READY</name>
                        <description>DATA_READY  Data Ready. It is set to a logic '1' whenever a complete incoming character has been received and transferred into the Receiver Buffer Register or the FIFO</description>
                        <bitOffset>0</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>OVERRUN</name>
                        <description>OVERRUN  Overrun Error.</description>
                        <bitOffset>1</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>PE</name>
                        <description>PARITY ERROR  Parity Error.</description>
                        <bitOffset>2</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>FRAME_ERR</name>
                        <description>FRAME_ERROR Framing Error.</description>
                        <bitOffset>3</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>BRK_INTR</name>
                        <description>BREAK_INTERRUPT   Break Interrupt.</description>
                        <bitOffset>4</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>TRANS_EMPTY</name>
                        <description>TRANSMIT_EMPTY  Transmitter Holding Register Empty Bit 5 indicates that the Serial Port is ready to accept a new character for transmission.</description>
                        <bitOffset>5</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>TRANS_ERR</name>
                        <description>Transmitter Empty. Bit 6 is set to a logic '1' whenever the Transmitter Holding Register (THR) and Transmitter Shift Register (TSR) are both empty.</description>
                        <bitOffset>6</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>FIFO_ERR</name>
                        <description>FIFO_ERROR</description>
                        <bitOffset>7</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                  </fields>
               </register>
               <register>
                  <name>MSR</name>
                  <description>UART Modem Status Register</description>
                  <addressOffset>0x6</addressOffset>
                  <size>8</size>
                  <access>read-only</access>
                  <resetValue>0x00</resetValue>
                  <fields>
                     <field>
                        <name>CTS</name>
                        <description>CTS  Delta Clear To Send (DCTS).</description>
                        <bitOffset>0</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>DSR</name>
                        <description>DSR  Delta Data Set Ready (DDSR).</description>
                        <bitOffset>1</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>RI</name>
                        <description>RI  Trailing Edge of Ring Indicator (TERI).</description>
                        <bitOffset>2</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>DCD</name>
                        <description>DCD  Delta Data Carrier Detect (DDCD).</description>
                        <bitOffset>3</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>nCTS</name>
                        <description>nCTS  This bit is the complement of the Clear To Send (nCTS) input.</description>
                        <bitOffset>4</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>nDSR</name>
                        <description>This bit is the complement of the Data Set Ready (nDSR) input.</description>
                        <bitOffset>5</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>nRI</name>
                        <description>nRI This bit is the complement of the Ring Indicator (nRI) input.</description>
                        <bitOffset>6</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>nDCD</name>
                        <description>nDCD   This bit is the complement of the Data Carrier Detect (nDCD) input.</description>
                        <bitOffset>7</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                  </fields>
               </register>
               <register>
                  <name>SCR</name>
                  <description>UART Scratchpad Register    This 8 bit read/write register has no effect on the operation of the Serial Port. It is intended as a scratchpad register to be used by the programmer to hold data temporarily.</description>
                  <addressOffset>0x7</addressOffset>
                  <size>8</size>
                  <resetValue>0x00</resetValue>
               </register>
               <register>
                  <name>ACTIVATE</name>
                  <description>UART Activate Register. [0:0] ACTIVATE When this bit is 1, the UART logical device is powered and functional. When this bit is 0, the UART logical device is powered down and inactive.</description>
                  <addressOffset>0x330</addressOffset>
                  <size>8</size>
                  <resetValue>0x00</resetValue>
               </register>
               <register>
                  <name>CFG_SEL</name>
                  <description>UART Config Select Register</description>
                  <addressOffset>0x3F0</addressOffset>
                  <size>8</size>
                  <resetValue>0x00</resetValue>
                  <fields>
                     <field>
                        <name>CLK_SRC</name>
                        <description>CLK_SRC  1=The UART Baud Clock is derived from an external clock source, 0=The UART Baud Clock is derived from one of the two internal clock sources</description>
                        <bitOffset>0</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>PWR</name>
                        <description>POWER  1=The RESET reset signal is derived from nSIO_RESET, 0=The RESET reset signal is derived from VCC1_RESET</description>
                        <bitOffset>1</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>POLAR</name>
                        <description>POLARITY  1=The UART_TX and UART_RX pins functions are inverted, 0=The UART_TX and UART_RX pins functions are not inverted</description>
                        <bitOffset>2</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                  </fields>
               </register>
            </cluster>
            <cluster>
               <name>DLAB</name>
               <description>UART when DLAB=1</description>
               <alternateCluster>DATA</alternateCluster>
               <headerStructName>UartDlab</headerStructName>
               <addressOffset>0x0</addressOffset>
               <register>
                  <name>BAUDRT_LSB</name>
                  <description>UART Programmable BAUD Rate Generator (LSB) Register (DLAB=1)</description>
                  <addressOffset>0x0</addressOffset>
                  <size>8</size>
                  <resetValue>0x00</resetValue>
               </register>
               <register>
                  <name>BAUDRT_MSB</name>
                  <description>UART Programmable BAUD Rate Generator (MSB) Register (DLAB=1)[6:0] BAUD_RATE_DIVISOR_MSB, [7:7] BAUD_CLK_SEL \n       1=If CLK_SRC is '0', the baud clock is derived from the 1.8432MHz_Clk. If CLK_SRC is '1', this bit has no effect\n            0=If CLK_SRC is '0', the baud clock is derived from the 24MHz_Clk. If CLK_SRC is '1', this bit has no effect</description>
                  <addressOffset>0x1</addressOffset>
                  <size>8</size>
                  <resetValue>0x00</resetValue>
               </register>
               <register>
                  <name>FIFO_CR</name>
                  <description>UART FIFO Control Register</description>
                  <addressOffset>0x2</addressOffset>
                  <size>8</size>
                  <access>write-only</access>
                  <resetValue>0x00</resetValue>
                  <fields>
                     <field>
                        <name>EXRF</name>
                        <description>EXRF Enable XMIT and RECV FIFO.</description>
                        <bitOffset>0</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>CLR_RECV_FIFO</name>
                        <description>CLEAR_RECV_FIFO  Setting this bit to a logic '1' clears all bytes in the RCVR FIFO and resets its counter logic to '0'.</description>
                        <bitOffset>1</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>CLR_XMIT_FIFO</name>
                        <description>CLEAR_XMIT_FIFO  Setting this bit to a logic '1' clears all bytes in the XMIT FIFO and resets its counter logic to '0' . The shift register is not cleared. This bit is self-clearing.</description>
                        <bitOffset>2</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>DMA_MODE_SEL</name>
                        <description>DMA_MODE_SELECT  Writing to this bit has no effect on the operation of the UART. The RXRDY and TXRDY pins are not available on this chip.</description>
                        <bitOffset>3</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>RECV_FIFO_TRIG_LVL</name>
                        <description>RECV_FIFO_TRIGGER_LEVEL These bits are used to set the trigger level for the RCVR FIFO interrupt.</description>
                        <bitOffset>6</bitOffset>
                        <bitWidth>2</bitWidth>
                     </field>
                  </fields>
               </register>
               <register>
                  <name>INT_ID</name>
                  <description>UART Interrupt Identification Register</description>
                  <addressOffset>0x2</addressOffset>
                  <size>8</size>
                  <access>read-only</access>
                  <resetValue>0x00</resetValue>
                  <fields>
                     <field>
                        <name>IPEND</name>
                        <description>IPEND  This bit can be used in either a hardwired prioritized or polled environment to indicate whether an interrupt is pending.</description>
                        <bitOffset>0</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>INTID</name>
                        <description>INTID  These bits identify the highest priority interrupt pending</description>
                        <bitOffset>1</bitOffset>
                        <bitWidth>3</bitWidth>
                     </field>
                     <field>
                        <name>FIFO_EN</name>
                        <description>These two bits are set when the FIFO CONTROL Register bit 0 equals 1.</description>
                        <bitOffset>6</bitOffset>
                        <bitWidth>2</bitWidth>
                     </field>
                  </fields>
               </register>
               <register>
                  <name>LCR</name>
                  <description>UART Line Control Register</description>
                  <addressOffset>0x3</addressOffset>
                  <size>8</size>
                  <resetValue>0x00</resetValue>
                  <fields>
                     <field>
                        <name>WORD_LEN</name>
                        <description>WORD_LENGTH These two bits specify the number of bits in each transmitted or received serial character.</description>
                        <bitOffset>0</bitOffset>
                        <bitWidth>2</bitWidth>
                     </field>
                     <field>
                        <name>STOP_BITS</name>
                        <description>STOP_BITS  This bit specifies the number of stop bits in each transmitted or received serial character.</description>
                        <bitOffset>2</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>EN_PAR</name>
                        <description>ENABLE_PARITY  Parity Enable bit.</description>
                        <bitOffset>3</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>PAR_SEL</name>
                        <description>PARITY_SELECT Even Parity Select bit.</description>
                        <bitOffset>4</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>STICK_PAR</name>
                        <description>STICK_PARITY  Stick Parity bit.</description>
                        <bitOffset>5</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>BRK_CTRL</name>
                        <description>BREAK_CONTROL Set Break Control bit</description>
                        <bitOffset>6</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>DLAB</name>
                        <description>DLAB Divisor Latch Access Bit (DLAB).</description>
                        <bitOffset>7</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                  </fields>
               </register>
               <register>
                  <name>MCR</name>
                  <description>UART Modem Control Register</description>
                  <addressOffset>0x4</addressOffset>
                  <size>8</size>
                  <resetValue>0x00</resetValue>
                  <fields>
                     <field>
                        <name>DTR</name>
                        <description>DTR  This bit controls the Data Terminal Ready (nDTR) output.</description>
                        <bitOffset>0</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>RTS</name>
                        <description>RTS  This bit controls the Request To Send (nRTS) output.</description>
                        <bitOffset>1</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>OUT1</name>
                        <description>OUT1 This bit controls the Output 1 (OUT1) bit.</description>
                        <bitOffset>2</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>OUT2</name>
                        <description>OUT2  This bit is used to enable an UART interrupt.</description>
                        <bitOffset>3</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>LOOPBACK</name>
                        <description>LOOPBACK  This bit provides the loopback feature for diagnostic testing of the Serial Port.</description>
                        <bitOffset>4</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                  </fields>
               </register>
               <register>
                  <name>LSR</name>
                  <description>UART Line Status Register</description>
                  <addressOffset>0x5</addressOffset>
                  <size>8</size>
                  <access>read-only</access>
                  <resetValue>0x00</resetValue>
                  <fields>
                     <field>
                        <name>DATA_READY</name>
                        <description>DATA_READY  Data Ready. It is set to a logic '1' whenever a complete incoming character has been received and transferred into the Receiver Buffer Register or the FIFO</description>
                        <bitOffset>0</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>OVERRUN</name>
                        <description>OVERRUN  Overrun Error.</description>
                        <bitOffset>1</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>PE</name>
                        <description>PARITY ERROR  Parity Error.</description>
                        <bitOffset>2</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>FRAME_ERR</name>
                        <description>FRAME_ERROR Framing Error.</description>
                        <bitOffset>3</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>BRK_INTR</name>
                        <description>BREAK_INTERRUPT   Break Interrupt.</description>
                        <bitOffset>4</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>TRANS_EMPTY</name>
                        <description>TRANSMIT_EMPTY  Transmitter Holding Register Empty Bit 5 indicates that the Serial Port is ready to accept a new character for transmission.</description>
                        <bitOffset>5</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>TRANS_ERR</name>
                        <description>Transmitter Empty. Bit 6 is set to a logic '1' whenever the Transmitter Holding Register (THR) and Transmitter Shift Register (TSR) are both empty.</description>
                        <bitOffset>6</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>FIFO_ERR</name>
                        <description>FIFO_ERROR</description>
                        <bitOffset>7</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                  </fields>
               </register>
               <register>
                  <name>MSR</name>
                  <description>UART Modem Status Register</description>
                  <addressOffset>0x6</addressOffset>
                  <size>8</size>
                  <access>read-only</access>
                  <resetValue>0x00</resetValue>
                  <fields>
                     <field>
                        <name>CTS</name>
                        <description>CTS  Delta Clear To Send (DCTS).</description>
                        <bitOffset>0</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>DSR</name>
                        <description>DSR  Delta Data Set Ready (DDSR).</description>
                        <bitOffset>1</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>RI</name>
                        <description>RI  Trailing Edge of Ring Indicator (TERI).</description>
                        <bitOffset>2</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>DCD</name>
                        <description>DCD  Delta Data Carrier Detect (DDCD).</description>
                        <bitOffset>3</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>nCTS</name>
                        <description>nCTS  This bit is the complement of the Clear To Send (nCTS) input.</description>
                        <bitOffset>4</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>nDSR</name>
                        <description>This bit is the complement of the Data Set Ready (nDSR) input.</description>
                        <bitOffset>5</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>nRI</name>
                        <description>nRI This bit is the complement of the Ring Indicator (nRI) input.</description>
                        <bitOffset>6</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>nDCD</name>
                        <description>nDCD   This bit is the complement of the Data Carrier Detect (nDCD) input.</description>
                        <bitOffset>7</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                  </fields>
               </register>
               <register>
                  <name>SCR</name>
                  <description>UART Scratchpad Register    This 8 bit read/write register has no effect on the operation of the Serial Port. It is intended as a scratchpad register to be used by the programmer to hold data temporarily.</description>
                  <addressOffset>0x7</addressOffset>
                  <size>8</size>
                  <resetValue>0x00</resetValue>
               </register>
               <register>
                  <name>ACTIVATE</name>
                  <description>UART Activate Register. [0:0] ACTIVATE When this bit is 1, the UART logical device is powered and functional. When this bit is 0, the UART logical device is powered down and inactive.</description>
                  <addressOffset>0x330</addressOffset>
                  <size>8</size>
                  <resetValue>0x00</resetValue>
               </register>
               <register>
                  <name>CFG_SEL</name>
                  <description>UART Config Select Register</description>
                  <addressOffset>0x3F0</addressOffset>
                  <size>8</size>
                  <resetValue>0x00</resetValue>
                  <fields>
                     <field>
                        <name>CLK_SRC</name>
                        <description>CLK_SRC  1=The UART Baud Clock is derived from an external clock source, 0=The UART Baud Clock is derived from one of the two internal clock sources</description>
                        <bitOffset>0</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>PWR</name>
                        <description>POWER  1=The RESET reset signal is derived from nSIO_RESET, 0=The RESET reset signal is derived from VCC1_RESET</description>
                        <bitOffset>1</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                     <field>
                        <name>POLAR</name>
                        <description>POLARITY  1=The UART_TX and UART_RX pins functions are inverted, 0=The UART_TX and UART_RX pins functions are not inverted</description>
                        <bitOffset>2</bitOffset>
                        <bitWidth>1</bitWidth>
                     </field>
                  </fields>
               </register>
            </cluster>
         </registers>
      </peripheral>
      <peripheral derivedFrom="UART0">
         <name>UART1</name>
         <baseAddress>0x400F2800</baseAddress>
         <interrupt>
            <name>UART1</name>
            <value>41</value>
         </interrupt>
      </peripheral>
      <peripheral>
         <name>GPIO</name>
         <version>261.0</version>
         <description>GPIO Pin Control Registers</description>
         <groupName>GPIO</groupName>
         <prependToName>GPIO_</prependToName>
         <baseAddress>0x40081000</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x7B0</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>GIRQ08</name>
            <value>0</value>
         </interrupt>
         <interrupt>
            <name>GIRQ09</name>
            <value>1</value>
         </interrupt>
         <interrupt>
            <name>GIRQ10</name>
            <value>2</value>
         </interrupt>
         <interrupt>
            <name>GIRQ11</name>
            <value>3</value>
         </interrupt>
         <interrupt>
            <name>GIRQ12</name>
            <value>4</value>
         </interrupt>
         <interrupt>
            <name>GIRQ26</name>
            <value>17</value>
         </interrupt>
         <registers>
            <register>
               <dim>0xAC</dim>
               <dimIncrement>4</dimIncrement>
               <name>CTRL[%s]</name>
               <description>GPIO Pin Control Register</description>
               <addressOffset>0x0</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>PU_PD</name>
                     <description>These bits are used to enable an internal pull-up or pull-down resistor.\n                00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11 = None</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>PWR_GATING</name>
                     <description>The GPIO pin will be tristated when the selected power well is off.\n            00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined by the VCC_PWRGD input), 1x = Reserved</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>INTR_DET</name>
                     <description>When combined with the field INTERRUPT_DETECTION in this register, determines the interrupt capability of the GPIO input.\n           0 000 = Low Level Sensitive\n               0 001 = High Level Sensitive\n              0 100 = Interrupt events are disabled\n             1 101 = Rising Edge Triggered\n             1 110 = Falling Edge Triggered\n           1 111 = Either edge triggered</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>EDGE_EN</name>
                     <description>When combined with the field INTERRUPT_DETECTION in this register, determines the interrupt capability of the GPIO input.\n         0 = Edge detection disabled, 1 = Edge detection enabled</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>OUT_BUFF_TYPE</name>
                     <description>Unless explicitly stated otherwise, pins with (I/O/OD) or (O/OD) in their buffer type column in the tables are\n           compliant with the following Programmable OD/PP Multiplexing Design Rule: Each compliant pin has a programmable open drain/push-pull\n           buffer controlled by the Output Buffer Type bit in the associated Pin Control Register. The state of this bit controls the mode of\n          the interface buffer for all selected functions, including the GPIO function. 0 = Push-Pull, 1 = Open Drain</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_DIR</name>
                     <description>This bit controls the buffer direction only when the MUX_CONTROL field is '00' selecting the pin signal function to\n        be GPIO. When the MUX_CONTROL field is greater than '00' (i.e., a non-GPIO signal function is selected) this bit has no affect\n            and the selected signal function logic directly controls the pin direction. 0 = Input, 1 = Output</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_OUT_SEL</name>
                     <description>This control bit determines which register is used to update the data register for GPIO outputs.\n            0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA field of this register; writes to the bit representing\n              this GPIO in the GPIO Output Register do not affect the GPIO; 1=GPIO output data for this GPIO come from the bit representing\n          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA field of this register do not affect the GPIO.</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>POL</name>
                     <description>When the Polarity bit is set to '1' and the MUX_CONTROL bits are greater than '00', the selected signal function outputs\n       are inverted and Interrupt Detection sense is inverted. When the MUX_CONTROL field selects the GPIO signal function (Mux='00'), the\n          Polarity bit does not effect the output. Regardless of the state of the MUX_CONTROL field and the Polarity bit, the state of the pin\n         is always reported without inversion in the GPIO input register. 1=Inverted; 0=Non-inverted</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MUX_CTRL</name>
                     <description>This field determines the active signal function for a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,\n              10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>ALT_GPIO_DATA</name>
                     <description>Reads of this bit always return the last data written to the GPIO output data register bit; reads do not return the\n          current output value of the GPIO pin if it is configured as an output. If the GPIO_OUTPUT_SEL      T bit in this register is '1', then\n                  this bit is Read Only and the GPIO output data register bit is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT\n          bit in this register is '0', then this bit is R/W, and the bit corresponding to this GPIO in the GPIO Output Register is Read Only.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_INP</name>
                     <description>Reads of this bit always return the state of GPIO input from the pad, independent of the Mux selection for the pin\n      or the Direction. This bit is forced high when the selected power well is off as selected by the POWER_GATING field in this register.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>6</dim>
               <dimIncrement>4</dimIncrement>
               <name>PARIN[%s]</name>
               <description>The GPIO Input Registers.</description>
               <addressOffset>0x300</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <dim>6</dim>
               <dimIncrement>4</dimIncrement>
               <name>PAROUT[%s]</name>
               <description>The GPIO Output Registers.</description>
               <addressOffset>0x380</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <dim>0xAC</dim>
               <dimIncrement>4</dimIncrement>
               <name>CTRL2[%s]</name>
               <description>The GPIO PIN_CTRL2 Registers</description>
               <addressOffset>0x500</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SLEW_RATE</name>
                     <description>This bit is used to select the slew rate on the pin. 0 = slow (half frequency), 1 = fast</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DRIV_STREN</name>
                     <description>These bits are used to select the drive strength on the pin. The drive strength is the same whether the pin is\n          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>WDT</name>
         <version>881.0</version>
         <description>The function of the Watchdog Timer is to provide a mechanism to detect\n                          if the internal embedded controller has failed. When enabled, the Watchdog Timer (WDT) circuit\n              will generate a WDT Event if the user program fails to reload the WDT within a specified length\n              of time known as the WDT Interval.</description>
         <groupName>WDT</groupName>
         <prependToName>WDT_</prependToName>
         <baseAddress>0x40000000</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0xE</size>
            <usage>registers</usage>
         </addressBlock>
         <registers>
            <register>
               <name>LOAD</name>
               <description>Writing this field reloads the Watch Dog Timer counter.</description>
               <addressOffset>0x0</addressOffset>
               <size>16</size>
               <resetValue>0x000F</resetValue>
            </register>
            <register>
               <name>CTRL</name>
               <description>WDT Control Register</description>
               <addressOffset>0x4</addressOffset>
               <size>8</size>
               <resetValue>0x0000</resetValue>
               <fields>
                  <field>
                     <name>WDT_EN</name>
                     <description>WDT Block enabled</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>WDT_STS</name>
                     <description>WDT_STS is set by hardware if the last reset of the device was caused by an underflow of the WDT. This bit must\n                      be cleared by the EC firmware writing a '1' to this bit. Writing a '0' to this bit has no effect.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>HIB_TMR0_STL</name>
                     <description>This bit enables the WDT Stall function if the Hibernation Timer 0 is active.\n                1=The WDT is stalled while the Hibernation Timer 0 is active\n                                 0=The WDT is not affected by Hibernation Timer 0.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>WK_TMR_STL</name>
                     <description>This bit enables the WDT Stall function if the Week Timer is active.\n                          1=The WDT is stalled while the Week Timer is active\n                    0=The WDT is not affected by the Week Timer.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>JTAG_STL</name>
                     <description>This bit enables the WDT Stall function if JTAG or SWD debug functions are active\n                              1=The WDT is stalled while either JTAG or SWD is active\n                     0=The WDT is not affected by the JTAG debug interface.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>KICK</name>
               <description>The WDT Kick Register is a strobe. Reads of this register return 0.\n       Writes to this register cause the WDT to reload\n                        the WDT Load Register value and start decrementing when the WDT_ENABLE bit in the WDT Control Register is set to '1'. When the WDT_ENABLE\n           bit in the WDT Control Register is cleared to '0', writes to the WDT Kick Register have no effect.</description>
               <addressOffset>0x8</addressOffset>
               <size>8</size>
               <access>write-only</access>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>CNT</name>
               <description>This read-only register provides the current WDT count.</description>
               <addressOffset>0xC</addressOffset>
               <size>16</size>
               <access>read-only</access>
               <resetValue>0xFFFF</resetValue>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>TIMER16_0</name>
         <version>108a1.0</version>
         <description>This timer block offers a simple mechanism for firmware to maintain a time base. This timer may be instantiated as 16 bits.\n      The name of the timer instance indicates the size of the timer.</description>
         <groupName>TIMER16</groupName>
         <prependToName>TIMER16_</prependToName>
         <baseAddress>0x40000C00</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x14</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>TIMER16_0</name>
            <value>136</value>
         </interrupt>
         <registers>
            <register>
               <name>CNT</name>
               <description>This is the value of the Timer counter.\n       This is updated by Hardware but may be set by Firmware.</description>
               <addressOffset>0x0</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>PRLD</name>
               <description>This is the value of the Timer pre-load for the counter.\n       This is used by H/W when the counter is to be restarted\n      automatically; this will become the new value of the counter upon restart.</description>
               <addressOffset>0x4</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>STS</name>
               <description>This is the interrupt status that fires when the timer reaches its limit</description>
               <addressOffset>0x8</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>EVT_INT</name>
                     <description>This is the interrupt status that fires when the timer reaches its limit. This is the interrupt status that fires when\n      the timer reaches its limit. This may be level or a self clearing signal cycle pulse, based on the AUTO_RESTART bit in the Timer\n      Control Register. If the timer is set to automatically restart, it will provide a pulse, otherwise a level is provided.(R/WC)</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>IEN</name>
               <description>This is the interrupt enable for the status EVENT_INTERRUPT bit in the Timer Status Register</description>
               <addressOffset>0xC</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>EN</name>
                     <description>This is the interrupt enable for the status EVENT_INTERRUPT bit in the Timer Status Register.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CTRL</name>
               <description>Timer Control Register</description>
               <addressOffset>0x10</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>EN</name>
                     <description>This enables the block for operation. 1=This block will function normally;\n      0=This block will gate its clock and go into its lowest power state</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CNT_UP</name>
                     <description>This selects the counter direction. When the counter in incrementing the counter will saturate and trigger the event\n      when it reaches all F's. When the counter is decrementing the counter will saturate when it reaches 0h. 1=The counter will increment;\n      0=The counter will decrement</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>AU_RESTRT</name>
                     <description>This will select the action taken upon completing a count.\n      1=The counter will automatically restart the count, using the contents of the Timer Preload Register to load the Timer Count Register.\n      The interrupt will be set in edge mode\n      0=The counter will simply enter a done state and wait for further control inputs. The interrupt will be set in level mode.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SFT_RST</name>
                     <description>This is a soft reset. This is self clearing 1 cycle after it is written. Firmware does not need\n      to wait before reconfiguring the Basic Timer following soft reset.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>STRT</name>
                     <description>This bit triggers the timer counter. The counter will operate until it hits its terminating condition. This will\n      clear this bit. It should be noted that when operating in restart mode, there is no terminating condition for the counter, so\n      this bit will never clear. Clearing this bit will halt the timer counter.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RLD</name>
                     <description>This bit reloads the counter without interrupting it operation. This will not function if the timer has already\n      completed (when the START bit in this register is '0'). This is used to periodically prevent the timer from firing when an\n      event occurs. Usage while the timer is off may result in erroneous behaviour.</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>HLT</name>
                     <description>This is a halt bit. This will halt the timer as long as it is active. Once the halt is inactive, the timer will\n      start from where it left off. 1=Timer is halted. It stops counting. The clock divider will also be reset. 0=Timer runs normally.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PRESCALE</name>
                     <description>This is used to divide down the system clock through clock enables to lower the power consumption of the block and allow\n      slow timers. Updating this value during operation may result in erroneous clock enable pulses until the clock divider restarts.\n      The number of clocks per clock enable pulse is (Value + 1); a setting of 0 runs at the full clock speed, while a setting of 1\n      runs at half speed.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral derivedFrom="TIMER16_0">
         <name>TIMER16_1</name>
         <baseAddress>0x40000C20</baseAddress>
         <interrupt>
            <name>TIMER16_1</name>
            <value>137</value>
         </interrupt>
      </peripheral>
      <peripheral derivedFrom="TIMER16_0">
         <name>TIMER16_2</name>
         <baseAddress>0x40000C40</baseAddress>
         <interrupt>
            <name>TIMER16_2</name>
            <value>138</value>
         </interrupt>
      </peripheral>
      <peripheral derivedFrom="TIMER16_0">
         <name>TIMER16_3</name>
         <baseAddress>0x40000C80</baseAddress>
         <interrupt>
            <name>TIMER16_3</name>
            <value>139</value>
         </interrupt>
      </peripheral>
      <peripheral>
         <name>TIMER32_0</name>
         <version>108b1.0</version>
         <description>This timer block offers a simple mechanism for firmware to maintain a time base. This timer may be instantiated as \n      32 bits. The name of the timer instance indicates the size of the timer.</description>
         <groupName>TIMER32</groupName>
         <prependToName>TIMER32_</prependToName>
         <baseAddress>0x40000C80</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x14</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>TIMER32_0</name>
            <value>140</value>
         </interrupt>
         <registers>
            <register>
               <name>CNT</name>
               <description>This is the value of the Timer counter. This is updated by Hardware but may be set by Firmware.</description>
               <addressOffset>0x0</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>PRLD</name>
               <description>This is the value of the Timer pre-load for the counter.\n       This is used by H/W when the counter is to be restarted\n      automatically; this will become the new value of the counter upon restart.</description>
               <addressOffset>0x4</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>STS</name>
               <description>This is the interrupt status that fires when the timer reaches its limit</description>
               <addressOffset>0x8</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>EVT_INT</name>
                     <description>This is the interrupt status that fires when the timer reaches its limit. This is the interrupt status that fires when\n      the timer reaches its limit. This may be level or a self clearing signal cycle pulse, based on the AUTO_RESTART bit in the Timer\n      Control Register. If the timer is set to automatically restart, it will provide a pulse, otherwise a level is provided.(R/WC)</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>IEN</name>
               <description>This is the interrupt enable for the status EVENT_INTERRUPT bit in the Timer Status Register</description>
               <addressOffset>0xC</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>EN</name>
                     <description>This is the interrupt enable for the status EVENT_INTERRUPT bit in the Timer Status Register.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CTRL</name>
               <description>Timer Control Register</description>
               <addressOffset>0x10</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>EN</name>
                     <description>This enables the block for operation. 1=This block will function normally;\n      0=This block will gate its clock and go into its lowest power state</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CNT_UP</name>
                     <description>This selects the counter direction. When the counter in incrementing the counter will saturate and trigger the event\n      when it reaches all F's. When the counter is decrementing the counter will saturate when it reaches 0h. 1=The counter will increment;\n      0=The counter will decrement</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>AU_RESTRT</name>
                     <description>This will select the action taken upon completing a count.\n      1=The counter will automatically restart the count, using the contents of the Timer Preload Register to load the Timer Count Register.\n      The interrupt will be set in edge mode\n      0=The counter will simply enter a done state and wait for further control inputs. The interrupt will be set in level mode.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SFT_RST</name>
                     <description>This is a soft reset. This is self clearing 1 cycle after it is written. Firmware does not need\n      to wait before reconfiguring the Basic Timer following soft reset.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>STRT</name>
                     <description>This bit triggers the timer counter. The counter will operate until it hits its terminating condition. This will\n      clear this bit. It should be noted that when operating in restart mode, there is no terminating condition for the counter, so\n      this bit will never clear. Clearing this bit will halt the timer counter.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RLD</name>
                     <description>This bit reloads the counter without interrupting it operation. This will not function if the timer has already\n      completed (when the START bit in this register is '0'). This is used to periodically prevent the timer from firing when an\n      event occurs. Usage while the timer is off may result in erroneous behaviour.</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>HLT</name>
                     <description>This is a halt bit. This will halt the timer as long as it is active. Once the halt is inactive, the timer will\n      start from where it left off. 1=Timer is halted. It stops counting. The clock divider will also be reset. 0=Timer runs normally.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PRESCALE</name>
                     <description>This is used to divide down the system clock through clock enables to lower the power consumption of the block and allow\n      slow timers. Updating this value during operation may result in erroneous clock enable pulses until the clock divider restarts.\n      The number of clocks per clock enable pulse is (Value + 1); a setting of 0 runs at the full clock speed, while a setting of 1\n      runs at half speed.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral derivedFrom="TIMER32_0">
         <name>TIMER32_1</name>
         <baseAddress>0x40000CA0</baseAddress>
         <interrupt>
            <name>TIMER32_1</name>
            <value>141</value>
         </interrupt>
      </peripheral>
      <peripheral>
         <name>CNT_TMR0</name>
         <version>691.0</version>
         <description>This interface is a 16-bit auto-reloading timer/counter.</description>
         <groupName>CNT_TMR</groupName>
         <prependToName>CNT_TMR_</prependToName>
         <baseAddress>0x40000D00</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x10</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>CNT_TMR0</name>
            <value>142</value>
         </interrupt>
         <registers>
            <register>
               <name>TIMERX_CTRL</name>
               <description>This bit reflects the current state of the timer's Clock_Required output signal.</description>
               <addressOffset>0x0</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>EN</name>
                     <description>This bit is used to start and stop the timer. This bit does not reset the timer count but does reset the timer\n                       pulse output. This bit will be cleared when the timer stops counting in One-Shot mode. The ENABLE bit is cleared after a\n           RESET cycle has completed. Firmware must poll the RESET bit in order to determine when the timer is active after reset.\n        1=Timer is enabled; 0=Timer is disabled.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RST</name>
                     <description>This bit stops the timer and resets the internal counter to the value in the Timer Reload Register. This bit\n                   also clears the ENABLE bit if it is set. This bit is self-clearing after the timer is reset. Firmware must poll the\n          RESET bit in order to determine when the timer is active after reset. Interrupts are blocked only when RESET takes\n        effect and the ENABLE bit is cleared. If interrupts are not desired, firmware must mask the interrupt in the interrupt\n       block. 1=Timer reset; 0=Normal timer operation.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MODE</name>
                     <description>Timer Mode. 3=Measurement Mode; 2=One Shot Mode; 1=Event Mode; 0=Timer Mode.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>2</bitWidth>
                     <enumeratedValues>
                        <name>MODESelect</name>
                        <enumeratedValue>
                           <name>TIMER_MODE</name>
                           <description>0=Timer Mode</description>
                           <value>0x0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>EVENT_MODE</name>
                           <description>1=Event Mode</description>
                           <value>0x1</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>ONE_SHOT_MODE</name>
                           <description>2=One Shot Mode</description>
                           <value>0x2</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>MEASUREMENT_MODE</name>
                           <description>3=Measurement Mode</description>
                           <value>0x3</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>INPOL</name>
                     <description>This bit selects the polarity of the TINx input. 1=TINx is active low; 0=TINx is active high.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>UPDN</name>
                     <description>In Event Mode, this bit selects the timer count direction. In Timer Mode enables timer control by the TINx input pin.\n          Event Mode: 1=The timer counts up; 0=The timer counts down.\n                 Timer Mode:; 1=TINx pin pauses the timer when de-asserted; 0=TINx pin has no effect on the timer.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TOUT_EN</name>
                     <description>This bit enables the TOUTx pin. 1=TOUTx pin function is enabled; 0=TOUTx pin is inactive.</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RLOAD</name>
                     <description>Reload Control. This bit controls how the timer is reloaded on overflow or underflow in Event and Timer modes.\n                    It has no effect in One shot mode. 1=Reload timer from Timer Reload Register and continue counting;\n                    0=Roll timer over to FFFFh and continue counting when counting down and rolls over to 0000h and continues counting when counting up.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FIL_BYPASS</name>
                     <description>This bit is used to enable or disable the noise filter on the TINx input signal. 1=Bypass Mode: input filter disabled.\n                     The TINx input directly affects the timer; 0=Filter Mode: input filter enabled. The TINx input is filtered by the input filter.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PD</name>
                     <description>Power Down. 1=The timer is powered down and all clocks are gated; 0=The timer is in a running state.</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TOUT_POL</name>
                     <description>This bit determines the polarity of the TOUTx output signal. In timer modes that toggle the TOUTx signal,\n           this polarity bit will not have a perceivable difference, except to determine the inactive state. In One-Shot mode\n           this determines if the pulsed output is active high or active low. 1=Active low; 0=Active high.</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SLP_EN</name>
                     <description>This bit reflects the current state of the timer's Sleep_Enable input signal. 1=Normal operation; 0=Sleep Mode is requested.</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TMRX_CLK_REQ</name>
                     <description>This bit reflects the current state of the timer's Clock_Required output signal. 1=The main clock is required by this block;\n         0=The main clock is not required by this block.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>PRLD</name>
               <description>This is the value of the Timer pre-load for the counter.\n       This is used by H/W when the counter is to be restarted automatically; this will become the new value of the counter upon restart.</description>
               <addressOffset>0x4</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>TCLK</name>
                     <description>Timer Clock Select. This field determines the clock source for the 16-bit counter in the timer.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>EDGE</name>
                     <description>This field selects which edge of the TINx input signal affects the timer in Event Mode, One-Shot Mode and Measurement Mode.\n          Event Mode: 11b=No event selected; 10b=Counts rising and falling edges; 01b=Counts rising edges; 00b=Counts falling edges.\n         One-Shot Mode: 11b=Start counting when the Enable bit is set; 10b=Starts counting on a rising or falling edge; 01b=Starts\n       counting on a rising edge; 00b=Starts counting on a falling edge. Measurement Mode: 11b=No event selected; 10b=Measures\n         the time between rising edges and falling edges and the time between falling edges and rising edges; 01b=Measures the\n        time between rising edges; 00b=Measures the time between falling edges.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>EVENT</name>
                     <description>Event Select. This bit is used to select the count source when the timer is operating in Event Mode.\n          1=TINx is count source; 0=Timer x-1 overflow is count source.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FCLK</name>
                     <description>Timer Clock Select. This field determines the clock source for the TINx noise filter. The available frequencies\n                are the same as for TCLK.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>TIMERX_RLD</name>
               <description>This register is used in Timer and One-Shot modes to set the lower limit of the timer.</description>
               <addressOffset>0x8</addressOffset>
               <size>32</size>
               <resetValue>0x0000FFFF</resetValue>
               <fields>
                  <field>
                     <name>TMR_RLD</name>
                     <description>The Timer Reload register is used in Timer and One-Shot modes to set the lower limit of the timer.\n                 In Event mode the Timer Reload register sets either the upper or lower limit of the timer depending on if the\n            timer is counting up or down. Valid Timer Reload values are 0001h - FFFFh. If the timer is running, the\n                 reload value will not be updated until the timer overflows or underflows. Programming a 0000h as a preload\n             value is not a valid count value. Using a value of 0000h will cause unpredictable behavior.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>TIMERX_CNT</name>
               <description>This register returns the current value of the timer in all modes.</description>
               <addressOffset>0xC</addressOffset>
               <size>32</size>
               <resetValue>0x0000FFFF</resetValue>
               <fields>
                  <field>
                     <name>TMR_CNT</name>
                     <description>This is the current value of the timer in all modes.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral derivedFrom="CNT_TMR0">
         <name>CNT_TMR1</name>
         <baseAddress>0x40000D20</baseAddress>
         <interrupt>
            <name>CNT_TMR1</name>
            <value>143</value>
         </interrupt>
      </peripheral>
      <peripheral derivedFrom="CNT_TMR0">
         <name>CNT_TMR2</name>
         <baseAddress>0x40000D40</baseAddress>
         <interrupt>
            <name>CNT_TMR2</name>
            <value>144</value>
         </interrupt>
      </peripheral>
      <peripheral derivedFrom="CNT_TMR0">
         <name>CNT_TMR3</name>
         <baseAddress>0x40000D60</baseAddress>
         <interrupt>
            <name>CNT_TMR3</name>
            <value>145</value>
         </interrupt>
      </peripheral>
      <peripheral>
         <name>CCT</name>
         <version>121.0</version>
         <description>This is a 16-bit auto-reloading timer/counter.</description>
         <groupName>CCT</groupName>
         <prependToName>CCT_</prependToName>
         <baseAddress>0x40001000</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x30</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>CAPTURE_TIMER</name>
            <value>146</value>
         </interrupt>
         <interrupt>
            <name>CAPTURE_0</name>
            <value>147</value>
         </interrupt>
         <interrupt>
            <name>CAPTURE_1</name>
            <value>148</value>
         </interrupt>
         <interrupt>
            <name>CAPTURE_2</name>
            <value>149</value>
         </interrupt>
         <interrupt>
            <name>CAPTURE_3</name>
            <value>150</value>
         </interrupt>
         <interrupt>
            <name>CAPTURE_4</name>
            <value>151</value>
         </interrupt>
         <interrupt>
            <name>CAPTURE_5</name>
            <value>152</value>
         </interrupt>
         <interrupt>
            <name>COMPARE_0</name>
            <value>153</value>
         </interrupt>
         <interrupt>
            <name>COMPARE_1</name>
            <value>154</value>
         </interrupt>
         <registers>
            <register>
               <name>CTRL</name>
               <description>This register controls the capture and compare timer.</description>
               <addressOffset>0x0</addressOffset>
               <size>32</size>
               <resetValue>0x03030000</resetValue>
               <fields>
                  <field>
                     <name>ACT</name>
                     <description>This bit is used to start the capture and compare timer running and power it down.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FREE_EN</name>
                     <description>Free-Running Timer Enable. This bit is used to start and stop the free running timer.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FREE_RST</name>
                     <description>Free Running Timer Reset. This bit stops the timer and resets the internal counter to 0000_0000h.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TCLK</name>
                     <description>This 3-bit field sets the clock source for the Free-Running Counter.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>CMP_EN0</name>
                     <description>Compare Enable for Compare 0 Register.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CMP_EN1</name>
                     <description>Compare Enable for Compare 1 Register.</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CMP_SET1</name>
                     <description>When read, returns the current value off the Compare Timer Output 1 state.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CMP_SET0</name>
                     <description>When read, returns the current value off the Compare Timer Output 0 state.</description>
                     <bitOffset>17</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CMP_CLR1</name>
                     <description>When read, returns the current value off the Compare Timer Output 1 state.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CMP_CLR0</name>
                     <description>When read, returns the current value off the Compare Timer Output 0 state.</description>
                     <bitOffset>25</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CAP0_CTRL</name>
               <description>This register is used to configure capture and compare timers 0-3.</description>
               <addressOffset>0x4</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>CAP_EDGE0</name>
                     <description>This field selects the edge type that triggers the capture of the Free Running Counter into Capture Register 0.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>FILTER_BYP0</name>
                     <description>This bit enables bypassing the input noise filter for Capture Register 0, so that the input signal goes directly into the timer.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FCLK_SEL0</name>
                     <description>This 3-bit field sets the clock source for the input filter for Capture Register 0.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>CAP_EDGE1</name>
                     <description>This field selects the edge type that triggers the capture of the Free Running Counter into Capture Register 1.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>FILTER_BYP1</name>
                     <description>This bit enables bypassing the input noise filter for Capture Register 1, so that the input signal goes directly into the timer.</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FCLK_SEL1</name>
                     <description>This 3-bit field sets the clock source for the input filter for Capture Register 1.</description>
                     <bitOffset>13</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>CAP_EDGE2</name>
                     <description>This field selects the edge type that triggers the capture of the Free Running Counter into Capture Register 2.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>FILTER_BYP2</name>
                     <description>This bit enables bypassing the input noise filter for Capture Register 2, so that the input signal goes directly into the timer.</description>
                     <bitOffset>18</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FCLK_SEL2</name>
                     <description>This 3-bit field sets the clock source for the input filter for Capture Register 2.</description>
                     <bitOffset>21</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>CAP_EDGE3</name>
                     <description>This field selects the edge type that triggers the capture of the Free Running Counter into Capture Register 3.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>FILTER_BYP3</name>
                     <description>This bit enables bypassing the input noise filter for Capture Register 3, so that the input signal goes directly into the timer.</description>
                     <bitOffset>26</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FCLK_SEL3</name>
                     <description>This 3-bit field sets the clock source for the input filter for Capture Register 3.</description>
                     <bitOffset>29</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CAP1_CTRL</name>
               <description>This register is used to configure capture and compare timers 4-5.</description>
               <addressOffset>0x8</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>CAP_EDGE4</name>
                     <description>This field selects the edge type that triggers the capture of the Free Running Counter into Capture Register 4.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>FILTER_BYP4</name>
                     <description>This bit enables bypassing the input noise filter for Capture Register 4, so that the input signal goes directly into the timer.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FCLK_SEL4</name>
                     <description>This 3-bit field sets the clock source for the input filter for Capture Register 4.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>CAP_EDGE5</name>
                     <description>This field selects the edge type that triggers the capture of the Free Running Counter into Capture Register 5.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>FILTER_BYP5</name>
                     <description>This bit enables bypassing the input noise filter for Capture Register 5, so that the input signal goes directly into the timer.</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FCLK_SEL5</name>
                     <description>This 3-bit field sets the clock source for the input filter for Capture Register 5.</description>
                     <bitOffset>13</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>FREE_RUN</name>
               <description>This register contains the current value of the Free Running Timer.</description>
               <addressOffset>0xC</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>TMR</name>
                     <description>This register contains the current value of the Free Running Timer.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CAP0</name>
               <description>This register saves the value copied from the Free Running timer on a programmed edge of ICT0.</description>
               <addressOffset>0x10</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>CAP_0</name>
                     <description>This register saves the value copied from the Free Running timer on a programmed edge of ICT0.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CAP1</name>
               <description>This register saves the value copied from the Free Running timer on a programmed edge of ICT1.</description>
               <addressOffset>0x14</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>CAP_1</name>
                     <description>This register saves the value copied from the Free Running timer on a programmed edge of ICT1.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CAP2</name>
               <description>This register saves the value copied from the Free Running timer on a programmed edge of ICT0.</description>
               <addressOffset>0x18</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>CAP_2</name>
                     <description>This register saves the value copied from the Free Running timer on a programmed edge of ICT2.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CAP3</name>
               <description>This register saves the value copied from the Free Running timer on a programmed edge of ICT0.</description>
               <addressOffset>0x1C</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>CAP_3</name>
                     <description>This register saves the value copied from the Free Running timer on a programmed edge of ICT3.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CAP4</name>
               <description>This register saves the value copied from the Free Running timer on a programmed edge of ICT4.</description>
               <addressOffset>0x20</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>CAP_4</name>
                     <description>This register saves the value copied from the Free Running timer on a programmed edge of ICT4.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CAP5</name>
               <description>This register saves the value copied from the Free Running timer on a programmed edge of ICT5.</description>
               <addressOffset>0x24</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>CAP_5</name>
                     <description>This register saves the value copied from the Free Running timer on a programmed edge of ICT5.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>COMP0</name>
               <description>A COMPARE 0 interrupt is generated when this register matches the value in the Free Running Timer.</description>
               <addressOffset>0x28</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>COMP_0</name>
                     <description>A COMPARE 0 interrupt is generated when this register matches the value in the Free Running Timer.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>COMP1</name>
               <description>A COMPARE 1 interrupt is generated when this register matches the value in the Free Running Timer.</description>
               <addressOffset>0x2C</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>COMP_1</name>
                     <description>A COMPARE 1 interrupt is generated when this register matches the value in the Free Running Timer.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>HTM0</name>
         <version>291.0</version>
         <description>The Hibernation Timer can generate a wake event to the Embedded Controller (EC) when it is in a hibernation mode.\n        This block supports wake events up to 2 hours in duration. The timer is a 16-bit binary count-down timer that can be programmed\n        in 30.5us and 0.125 second increments for period ranges of 30.5us to 2s or 0.125s to 136.5 minutes, respectively.</description>
         <groupName>HTM</groupName>
         <prependToName>HTM_</prependToName>
         <baseAddress>0x40009800</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0xA</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>HTM0</name>
            <value>112</value>
         </interrupt>
         <registers>
            <register>
               <name>PRLD</name>
               <description>[15:0] This register is used to set the Hibernation Timer Preload value.</description>
               <addressOffset>0x0</addressOffset>
               <size>16</size>
               <resetValue>0x0000</resetValue>
            </register>
            <register>
               <name>CTRL</name>
               <description>HTimer Control Register</description>
               <addressOffset>0x4</addressOffset>
               <size>16</size>
               <resetValue>0x0000</resetValue>
               <fields>
                  <field>
                     <name>CTRL</name>
                     <description>1= The Hibernation Timer has a resolution of 0.125s per LSB, which yields a maximum time in excess of 2 hours.\n            0= The Hibernation Timer has a resolution of 30.5us per LSB, which yields a maximum time of ~2seconds.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CNT</name>
               <description>The current state of the Hibernation Timer.</description>
               <addressOffset>0x8</addressOffset>
               <size>16</size>
               <access>read-only</access>
               <resetValue>0x0000</resetValue>
            </register>
         </registers>
      </peripheral>
      <peripheral derivedFrom="HTM0">
         <name>HTM1</name>
         <baseAddress>0x40009820</baseAddress>
         <interrupt>
            <name>HTM1</name>
            <value>113</value>
         </interrupt>
      </peripheral>
      <peripheral>
         <name>RTOS</name>
         <version>1401.0</version>
         <description>The RTOS Timer is a low-power, 32-bit timer designed to operate on the 32kHz oscillator which is available during all\n      chip sleep states. This allows firmware the option to sleep the processor, enter heavy or deep chip sleep states, and\n      wake after a programmed amount of time. The timer may be used as a one-shot timer or a continuous timer. When the\n      timer transitions to 0 it is capable of generating a wake-capable interrupt to the embedded controller. This timer may be\n      halted during debug by hardware or via a software control bit.</description>
         <groupName>RTOS</groupName>
         <prependToName>RTOS_</prependToName>
         <baseAddress>0x40007400</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x10</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>TIMER</name>
            <value>111</value>
         </interrupt>
         <registers>
            <register>
               <name>CNT</name>
               <description>RTOS Timer Count Register.</description>
               <addressOffset>0x0</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>CNTR</name>
                     <description>This register contains the current value of the RTOS Timer counter. This register should be read as a DWORD. There is no latching mechanism \n      of the upper bytes implemented if the register is accessed as a byte or word. Reading the register with byte or word operations may give incorrect results.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>PRLD</name>
               <description>RTOS Timer Preload Register</description>
               <addressOffset>0x4</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>PRELOAD</name>
                     <description>The this register is loaded into the RTOS Timer counter either when the TIMER_START bit is written with a 1, or when the timer counter counts down to 0 and the AUTO_RELOAD bit is 1.\n       This register must be programmed with a new count value before the TIMER_START bit is set to 1. If this register is updated while the counter is operating, the new count value will only take effect if\n       the counter transitions form 1 to 0 while the AUTO_RELOAD bit is set.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CTRL</name>
               <description>RTOS Timer Control Register</description>
               <addressOffset>0x8</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>BLK_EN</name>
                     <description>1=RTOS timer counter is enabled\n      0=RTOS timer disabled. All register bits are reset to their default state</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>AU_RELOAD</name>
                     <description>1=The the RTOS Timer Preload Register is loaded into the timer counter and the counter is restarted when the counter transitions from 1 to 0\n      0=The timer counter halts when it transitions from 1 to 0 and will not restart.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TMR_STRT</name>
                     <description>Writing a 1 to this bit will load the timer counter with the RTOS Timer Preload Register and start counting.\n       If the Preload Register is 0, counting will not start and this bit will be cleared to 0.\n      Writing a 0 to this bit will halt the counter and clear its contents to 0. The RTOS timer interrupt will not be generated. This bit is automatically cleared if the AUTO_RELOAD bit is 0 and the\n      timer counter transitions from 1 to 0.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>EXT_HW_HALT_EN</name>
                     <description>1=The timer counter is halted when the external HALT signal is asserted. Counting is always enabled if HALT is de-asserted.\n      0=The HALT signal does not affect the RTOS Timer</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FW_TMR_HALT</name>
                     <description>1=The timer counter is halted. If the counter was running, clearing this bit will restart the counter from the value at which it halted\n      0=The timer counter, if enabled, will continue to run</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SOFTIRQ</name>
               <description>Soft Interrupt Register</description>
               <addressOffset>0xC</addressOffset>
               <size>32</size>
               <access>write-only</access>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SWI0</name>
                     <description>Software Interrupt. A write of a '1' to this bit will generate an SWI interrupt to the EC.\n      Writes of a '0' have no effect. Reads return '0'.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SWI1</name>
                     <description>Software Interrupt. A write of a '1' to this bit will generate an SWI interrupt to the EC.\n      Writes of a '0' have no effect. Reads return '0'.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SWI2</name>
                     <description>Software Interrupt. A write of a '1' to this bit will generate an SWI interrupt to the EC.\n      Writes of a '0' have no effect. Reads return '0'.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SWI3</name>
                     <description>Software Interrupt. A write of a '1' to this bit will generate an SWI interrupt to the EC.\n      Writes of a '0' have no effect. Reads return '0'.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>RTC</name>
         <version>1261.0</version>
         <description>This is the set of registers that are automatically counted by hardware every 1 second while the block is enabled\n      to run and to update. These registers are: Seconds, Minutes, Hours, Day of Week, Day of Month, Month, and Year.</description>
         <groupName>RTC</groupName>
         <prependToName>RTC_</prependToName>
         <baseAddress>0x400F5000</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x20</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>RTC</name>
            <value>119</value>
         </interrupt>
         <interrupt>
            <name>RTC_ALARM</name>
            <value>120</value>
         </interrupt>
         <registers>
            <register>
               <name>SEC</name>
               <description>Seconds Register</description>
               <addressOffset>0x0</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>SEC_ALARM</name>
               <description>Seconds Alarm Register</description>
               <addressOffset>0x1</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>MIN</name>
               <description>Minutes Register</description>
               <addressOffset>0x2</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>MIN_ALARM</name>
               <description>Minutes Alarm Register</description>
               <addressOffset>0x3</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>HR</name>
               <description>Hours Register</description>
               <addressOffset>0x4</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>HR_ALARM</name>
               <description>Hours Alarm Register</description>
               <addressOffset>0x5</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>DAY_OF_WK</name>
               <description>Day of Week Register</description>
               <addressOffset>0x6</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>DAY_OF_MON</name>
               <description>Day of Month Register</description>
               <addressOffset>0x7</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>MONTH</name>
               <description>Month Register</description>
               <addressOffset>0x8</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>YEAR</name>
               <description>Year Register</description>
               <addressOffset>0x9</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>REGA</name>
               <description>Register A</description>
               <addressOffset>0xA</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>REGB</name>
               <description>Register B</description>
               <addressOffset>0xB</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>REGC</name>
               <description>Register C</description>
               <addressOffset>0xC</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>REGD</name>
               <description>Register D</description>
               <addressOffset>0xD</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>CTRL</name>
               <description>RTC Control Register</description>
               <addressOffset>0x10</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>BLK_EN</name>
                     <description>BLK_EN This bit must be '1' in order for the block to function internally. Registers may be initialized first, before\n      setting this bit to '1' to start operation.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SOFT_RST</name>
                     <description>SOFT_RST A '1' written to this bit position will trigger the RTC_RST reset, resetting the block and all registers except\n      this one and the Test Register. This bit is self-clearing at the end of the reset, one cycle of Host Bus Clock later, and so requires\n      no waiting.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TEST</name>
                     <description>TEST</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ALM_EN</name>
                     <description>ALM_EN  1=Enables the Alarm features, 0=Disables the Alarm features</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>WK_ALARM</name>
               <description>Week Alarm Register[7:0] - ALARM_DAY_OF_WEEK This register, if written to a value in the range 1- -7, will inhibit the Alarm\n      interrupt unless this field matches the contents of the Day of Week Register also.</description>
               <addressOffset>0x14</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>DAYLT_SAVF</name>
               <description>Daylight Savings Forward Register</description>
               <addressOffset>0x18</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>DST_MON</name>
                     <description>This field matches the Month Register.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>DST_DAY_OF_WK</name>
                     <description>This field matches the Day of Week Register bits[2:0].</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>DST_WK</name>
                     <description>5=Last week of month, 4 =Fourth week of month, 3=Third week of month, 2=Second week of month, 1=First week of month</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>DST_HR</name>
                     <description>This field holds the matching value for bits[6:0] of the Hours register. The written value will be interpreted according\n      to the 24/12 Hour mode and DM mode settings at the time of writing.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>7</bitWidth>
                  </field>
                  <field>
                     <name>DST_AM_PM</name>
                     <description>This bit selects AM vs. PM, to match bit[7] of the Hours Register if 12-Hour mode is selected in Register B at the time\n      of writing.</description>
                     <bitOffset>31</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>DAYLT_SAVB</name>
               <description>Daylight Savings Backward Register</description>
               <addressOffset>0x1C</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>DST_MON</name>
                     <description>This field matches the Month Register.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>DST_DAY_OF_WK</name>
                     <description>This field matches the Day of Week Register bits[2:0].</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>DST_WK</name>
                     <description>5=Last week of month, 4 =Fourth week of month, 3=Third week of month, 2=Second week of month, 1=First week of month</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>DST_HR</name>
                     <description>This field holds the matching value for bits[6:0] of the Hours register. The written value will be interpreted according\n      to the 24/12 Hour mode and DM mode settings at the time of writing.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>7</bitWidth>
                  </field>
                  <field>
                     <name>DST_AM_PM</name>
                     <description>This bit selects AM vs. PM, to match bit[7] of the Hours Register if 12-Hour mode is selected in Register B at the time\n      of writing.</description>
                     <bitOffset>31</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>WEEK</name>
         <version>761.0</version>
         <description>The Week Alarm Interface provides two timekeeping functions: a Week Timer and a Sub-Week Timer. Both the Week Timer\n        and the Sub-Week Timer assert the Power-Up Event Output which automatically powers-up the system from the G3 state.</description>
         <groupName>WEEK</groupName>
         <prependToName>WEEK_</prependToName>
         <baseAddress>0x4000AC80</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x28</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>ALARM_INT</name>
            <value>114</value>
         </interrupt>
         <interrupt>
            <name>WKSUB</name>
            <value>115</value>
         </interrupt>
         <interrupt>
            <name>WKSEC</name>
            <value>116</value>
         </interrupt>
         <interrupt>
            <name>WKSUBSEC</name>
            <value>117</value>
         </interrupt>
         <interrupt>
            <name>SYSPWR</name>
            <value>118</value>
         </interrupt>
         <registers>
            <register>
               <name>CTRL</name>
               <description>Control Register</description>
               <addressOffset>0x0</addressOffset>
               <size>32</size>
               <resetValue>0x00000001</resetValue>
               <fields>
                  <field>
                     <name>WT_EN</name>
                     <description>The WT_EN bit is used to start and stop the Week Alarm Counter Register and the Clock Divider Register.\n           The value in the Counter Register is held when the WT_ENABLE bit is not asserted (0) and the count is resumed from the last value when the bit is asserted (1).\n             The 15-Bit Clock Divider is reset to 00h and the Week Alarm Interface is in its lowest power consumption state when the WT_ENABLE bit is not asserted.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWRUP_EN</name>
                     <description>This bit controls the state of the Power-Up Event Output and enables Week POWER-UP Event decoding in the VBAT-Powered Control Interface.\n        1=Power-Up Event Output Enabled\n       0=Power-Up Event Output Disabled and Reset</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>ALARM_CNT</name>
               <description>Week Alarm Counter Register</description>
               <addressOffset>0x4</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>WK_CNTR</name>
                     <description>While the WT_ENABLE bit is 1, this register is incremented at a 1 Hz rate. Writes of this register may require one second\n            to take effect. Reads return the current state of the register. Reads and writes complete independently of the state of WT_ENABLE.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>28</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>TMR_COMP</name>
               <description>Week Timer Compare Register</description>
               <addressOffset>0x8</addressOffset>
               <size>32</size>
               <resetValue>0x0FFFFFFF</resetValue>
               <fields>
                  <field>
                     <name>WK_COMP</name>
                     <description>A Week Alarm Interrupt and a Week Alarm Power-Up Event are asserted when the Week Alarm Counter Register is greater than\n         or equal to the contents of this register. Reads and writes complete independently of the state of WT_ENABLE.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>28</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CLKDIV</name>
               <description>Clock Divider Register</description>
               <addressOffset>0xC</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>DIV</name>
                     <description>Reads of this register return the current state of the Week Timer 15- bit clock divider.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>15</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SS_INTR_SEL</name>
               <description>Sub-Second Programmable Interrupt Select Register</description>
               <addressOffset>0x10</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SPISR</name>
                     <description>This field determines the rate at which Sub-Second interrupt events are generated.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SWK_CTRL</name>
               <description>Sub-Week Control Register</description>
               <addressOffset>0x14</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SWKTMR_PWRUP_EVT_STS</name>
                     <description>This bit is set to 1 when the Sub-Week Alarm Counter Register decrements from 1 to 0 and the POWERUP_EN is 1.\n          Writes of 1 clear this bit. Writes of 0 have no effect. Note: This bit MUST be cleared to remove a Sub-Week Timer Power-Up Event.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>WKTMR_PWRUP_EVT_STS</name>
                     <description>This bit is set to 1 when the Week Alarm Counter Register is greater than or equal the contents of the Week Timer Compare\n       Register and the POWERUP_EN is 1. Writes of 1 clear this bit. Writes of 0 have no effect.\n              Note: This bit does not have to be cleared to remove a Week Timer Power-Up Event.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TEST</name>
                     <description>Test</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TEST0</name>
                     <description>Test</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>AU_RLD</name>
                     <description>1= No reload occurs when the Sub-Week Counter expires\n       0= Reloads the SUBWEEK_COUNTER_LOAD field into the Sub- Week Counter when the counter expires.</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SWK_TICK</name>
                     <description>This field selects the clock source for the Sub-Week Counter.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SWK_ALARM</name>
               <description>Sub-Week Alarm Counter Register</description>
               <addressOffset>0x18</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>CNTR_LOAD</name>
                     <description>Writes with a non-zero value to this field reload the 9-bit Sub-Week Alarm counter. Writes of 0 disable the counter.\n       If the Sub-Week Alarm counter decrements to 0 and the AUTO_RELOAD bit is set, the value in this field is automatically loaded into the Sub-Week Alarm counter.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>9</bitWidth>
                  </field>
                  <field>
                     <name>CNTR_STS</name>
                     <description>Reads of this register return the current state of the 9-bit Sub-Week Alarm counter.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>9</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BGPO_DATA</name>
               <description>BGPO Data Register</description>
               <addressOffset>0x1C</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>BGPO</name>
                     <description>Battery powered General Purpose Output. Each output pin may be individually configured to be either a VBAT-power BGPO or a VTR\n          powered GPIO, based on the corresponding settings in the BGPO Power Register. Additionally, each output pin may be individually configured\n                 to reset to 0 on either RESET_VTR or RESET_SYS, based on the corresponding settings in the BGPO Reset Register.\n                  For each bit [i] in the field: 1=BGPO[i] output is high; 0=BGPO[i] output is low.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>10</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BGPO_PWR</name>
               <description>BGPO Power Register</description>
               <addressOffset>0x20</addressOffset>
               <size>32</size>
               <resetValue>0x0000003E</resetValue>
               <fields>
                  <field>
                     <name>BGPO_POWER</name>
                     <description>Battery powered General Purpose Output power source. For each bit [i] in the field:\n         1=BGPO[i] is powered by VBAT. The BGPO[i] pin is always determined by the corresponding bit in the BGPO Data Register. The GPIO Input register\n            for the GPIO that is multiplexed with the BGPO always returns a '1b'.\n              0=The pin for BGPO[i] functions as a GPIO. When VTR is powered, the pin associated with BGPO[i] is determined by the GPIO associated with the pin.\n            When VTR is unpowered, the pin is tristated.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>5</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BGPO_RST</name>
               <description>BGPO Reset Register</description>
               <addressOffset>0x24</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>BGPO_RESET</name>
                     <description>Battery powered General Purpose Output reset event. For each bit [i] in the field:\n                1=BGPO[i] is reset to 0 on RESET_VTR; 0=BGPO[i] is reset to 0 on RESET_SYS.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>10</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>TACH0</name>
         <version>661.0</version>
         <description>This block monitors TACH output signals (or locked rotor signals) from\n       various types of fans, and determines their speed.</description>
         <groupName>TACH</groupName>
         <prependToName>TACH_</prependToName>
         <baseAddress>0x40006000</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x10</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>TACH0</name>
            <value>71</value>
         </interrupt>
         <registers>
            <register>
               <name>CTRL</name>
               <description>TACHx Control Register</description>
               <addressOffset>0x0</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>OUTOF_LIM_EN</name>
                     <description>OUTOF_LIM_EN  This bit is used to enable the TACH_OUT_OF_LIMIT_STATUS bit in the TACHx Status Register to generate an interrupt event.\n        1=Enable interrupt output from Tach block\n             0=Disable interrupt output from Tach block (default)</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>EN</name>
                     <description>EN  1= TACH Monitoring enabled, clocks enabled. 0= TACH Idle, clocks gated</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FILT_EN</name>
                     <description>FILT_EN  This filter is used to remove high frequency glitches from Tach Input. When this filter is enabled, Tach input pulses less than two 100kHz_- Clk periods wide get filtered.\n         1= Filter enabled\n                0= Filter disabled (default)\n        It is recommended that the Tach input filter always be enabled.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RD_MOD_SEL</name>
                     <description>RD_MOD_SEL\n        1=Counter is incremented on the rising edge of the 100kHz_Clk input. The counter is latched into the TACHX_COUNTER field and reset when the programmed number of edges is detected.\n         0=Counter is incremented when Tach Input transitions from low-tohigh state (default)</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>EDGES</name>
                     <description>EDGES A Tach signal is a square wave with a 50% duty cycle. Typically, two Tach periods represents one revolution of the fan. A Tach period consists of three Tach edges.\n       This programmed value represents the number of Tach edges that will be used to determine the interval for which the number of 100kHz_Clk pulses will be counted\n        11b=9 Tach edges (4 Tach periods)\n              10b=5 Tach edges (2 Tach periods)\n                  01b=3 Tach edges (1 Tach period)\n                  00b=2 Tach edges (1/2 Tach period)</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>CNT_RDY_INT_EN</name>
                     <description>CNT_RDY_INT_EN 1=Enable Count Ready interrupt from Tach block, 0=Disable Count Ready interrupt from Tach block</description>
                     <bitOffset>14</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>IN_INT_EN</name>
                     <description>IN_INT_EN 1=Enable Tach Input toggle interrupt from Tach block, 0=Disable Tach Input toggle interrupt from Tach block</description>
                     <bitOffset>15</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CNTR</name>
                     <description>This 16-bit field contains the latched value of the internal Tach pulse counter, which may be configured by the \n       Tach Reading Mode Select field to operate as a free-running counter or to be gated by the Tach input signal.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>STS</name>
               <description>TACHx Status Register</description>
               <addressOffset>0x4</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>OUTOF_LIM_STS</name>
                     <description>OUTOF_LIM_STS  1=Tach is outside of limits, 0=Tach is within limits (R/WC)</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PIN_STS</name>
                     <description>PIN_STS  1= Tach Input is high, 0= Tach Input is low</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TOG_STS</name>
                     <description>TOG_STS  1=Tach Input changed state (this bit is set on a low-to-high or high-tolow transition), 0=Tach stable (R/WC)</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CNT_RDY_STS</name>
                     <description>CNT_RDY_STS  1=Reading ready, 0=Reading not ready</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>LIM_HI</name>
               <description>TACH HIGH LIMIT Register</description>
               <addressOffset>0x8</addressOffset>
               <size>32</size>
               <resetValue>0x0000FFFF</resetValue>
               <fields>
                  <field>
                     <name>T_HIGH</name>
                     <description>This value is compared with the value in the TACHX_COUNTER field. If the value in the counter is greater than the value\n            programmed in this register, the TACH_OUT_OF_LIMIT_STATUS bit will be set. The TACH_OUT_OF_LIMIT_STATUS status event may be enabled\n               to generate an interrupt to the embedded controller via the TACH_OUT_OF_LIMIT_ENABLE bit in the TACHx Control Register.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>LIM_LO</name>
               <description>TACHx Low Limit Register</description>
               <addressOffset>0xC</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>T_LOW</name>
                     <description>This value is compared with the value in the TACHX_COUNTER field of the TACHx Control Register. If the value in the counter\n          is less than the value programmed in this register, the TACH_OUT_OF_LIMIT_STATUS bit will be set. The TACH_OUT_OF_LIMIT_STATUS\n              status event may be enabled to generate an interrupt to the embedded controller via the TACH_OUT_OF_LIMIT_ENABLE bit in the TACHx\n         Control Register To disable the TACH_OUT_OF_LIMIT_STATUS low event, program 0000h into this register.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral derivedFrom="TACH0">
         <name>TACH1</name>
         <baseAddress>0x40006010</baseAddress>
         <interrupt>
            <name>TACH1</name>
            <value>72</value>
         </interrupt>
      </peripheral>
      <peripheral derivedFrom="TACH0">
         <name>TACH2</name>
         <baseAddress>0x40006020</baseAddress>
         <interrupt>
            <name>TACH2</name>
            <value>73</value>
         </interrupt>
      </peripheral>
      <peripheral>
         <name>PWM0</name>
         <version>541.0</version>
         <description>This block generates a PWM output that can be used to control 4-wire fans, blinking LEDs, and other\n      similar devices. Each PWM can generate an arbitrary duty cycle output at frequencies from less than 0.1 Hz to 24 MHz.\n      The PWM controller can also used to generate the PROCHOT output and Speaker output.</description>
         <groupName>PWM</groupName>
         <prependToName>PWM_</prependToName>
         <baseAddress>0x40005800</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0xC</size>
            <usage>registers</usage>
         </addressBlock>
         <registers>
            <register>
               <name>CNT_ON</name>
               <description>This field determines both the frequency and duty cycle of the PWM signal.\n       Setting this field to a value of n will\n      cause the On time of the PWM to be n+1 cycles of the PWM Clock Source.\n      When this field is set to zero and the PWMX_COUNTER_OFF_TIME is not set to zero, the PWM_OUTPUT is held low (Full Off).</description>
               <addressOffset>0x0</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>CNT_OFF</name>
               <description>This field determine both the frequency and duty cycle of the PWM signal.\n       Setting this field to a value of n will\n      cause the Off time of the PWM to be n+1 cycles of the PWM Clock Source.\n      When this field is set to zero, the PWM_OUTPUT is held high (Full On).</description>
               <addressOffset>0x4</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>CFG</name>
               <description>PWMx CFGURATION REGISTER</description>
               <addressOffset>0x8</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>PWM_EN</name>
                     <description>When the PWM_EN is set to 0 the internal counters are reset and the internal state machine is set to the OFF state.\n      In addition, the PWM_OUTPUT signal is set to the inactive state as determined by the Invert bit. The PWMx Counter ON Time Register\n      and PWMx Counter OFF Time Register are not affected by the PWM_ENABLE bit and may be read and written while the PWM enable bit is 0.\n      1=Enabled (default); 0=Disabled (gates clocks to save power).</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CLK_SEL</name>
                     <description>This bit determines the clock source used by the PWM duty cycle and frequency control logic.\n      1=CLOCK_LOW\n      0=CLOCK_HIGH</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>INV</name>
                     <description>1= PWM_OUTPUT ON State is active low; 0=PWM_OUTPUT ON State is active high.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CLK_PRE_DIV</name>
                     <description>The Clock source for the 16-bit down counter (see PWMx Counter ON Time Register and PWMx Counter OFF Time Register)\n      is determined by bit D1 of this register. The Clock source is then divided by the value of Pre-Divider+1 and the resulting\n      signal determines the rate at which the down counter will be decremented. For example, a Pre-Divider value of 1 divides\n      the input clock by 2 and a value of 2 divides the input clock by 3. A Pre-Divider of 0 will disable the Pre-Divider option.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral derivedFrom="PWM0">
         <name>PWM1</name>
         <baseAddress>0x40005810</baseAddress>
      </peripheral>
      <peripheral derivedFrom="PWM0">
         <name>PWM2</name>
         <baseAddress>0x40005820</baseAddress>
      </peripheral>
      <peripheral derivedFrom="PWM0">
         <name>PWM3</name>
         <baseAddress>0x40005830</baseAddress>
      </peripheral>
      <peripheral derivedFrom="PWM0">
         <name>PWM4</name>
         <baseAddress>0x40005840</baseAddress>
      </peripheral>
      <peripheral derivedFrom="PWM0">
         <name>PWM5</name>
         <baseAddress>0x40005850</baseAddress>
      </peripheral>
      <peripheral derivedFrom="PWM0">
         <name>PWM6</name>
         <baseAddress>0x40005860</baseAddress>
      </peripheral>
      <peripheral derivedFrom="PWM0">
         <name>PWM7</name>
         <baseAddress>0x40005870</baseAddress>
      </peripheral>
      <peripheral derivedFrom="PWM0">
         <name>PWM8</name>
         <baseAddress>0x40005880</baseAddress>
      </peripheral>
      <peripheral derivedFrom="PWM0">
         <name>PWM9</name>
         <baseAddress>0x40005890</baseAddress>
      </peripheral>
      <peripheral derivedFrom="PWM0">
         <name>PWM10</name>
         <baseAddress>0x400058A0</baseAddress>
      </peripheral>
      <peripheral derivedFrom="PWM0">
         <name>PWM11</name>
         <baseAddress>0x400058B0</baseAddress>
      </peripheral>
      <peripheral>
         <name>ADC</name>
         <description>This block is designed to convert external analog voltage readings into digital values.</description>
         <groupName>ADC</groupName>
         <prependToName>ADC_</prependToName>
         <baseAddress>0x40007C00</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x6C</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>SNGL</name>
            <value>78</value>
         </interrupt>
         <interrupt>
            <name>RPT</name>
            <value>79</value>
         </interrupt>
         <registers>
            <register>
               <name>CTRL</name>
               <description>The ADC Control Register is used to control the behavior of the Analog to Digital Converter.</description>
               <addressOffset>0x0</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>ACT</name>
                     <description>0: The ADC is disabled and placed in its lowest power state. 1: ADC block is enabled for operation.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>STRT_SIN</name>
                     <description>(STRT_SIN) 0: The ADC Single Mode is disabled. 1: The ADC Single Mode is enabled. Note: This bit is self-clearing</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>STRT_RPT</name>
                     <description>0: The ADC Repeat Mode is disabled. 1: The ADC Repeat Mode is enabled.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWR_SAV_DIS</name>
                     <description>0: Power saving feature is enabled. 1: Power saving feature is disabled.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SFT_RST</name>
                     <description>(SFT_RST) 1: writing one causes a reset of the ADC block hardware (not the registers) 0: writing zero takes the ADC block out of reset</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RPT_DONE_STS</name>
                     <description>0: ADC repeat-sample conversion is not complete. 1: ADC repeat-sample conversion is completed. (R/WC)</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SIN_DONE_STS</name>
                     <description>0: ADC single-sample conversion is not complete. 1: ADC single-sample conversion is completed. (R/WC)</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>DELAY</name>
               <description>The ADC Delay register determines the delay from setting Start_Repeat in the \n       ADC Control Register and the start of a conversion cycle. This register also controls the interval between conversion cycles in repeat mode.</description>
               <addressOffset>0x4</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>STRT_DLY</name>
                     <description>This field determines the starting delay before a conversion cycle is begun when Start_Repeat is written with a 1.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
                  <field>
                     <name>RPT_DLY</name>
                     <description>This field determines the interval between conversion cycles when Start_Repeat is 1.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CHAN_STS</name>
               <description>The ADC Status Register indicates whether the ADC has completed a conversion cycle.\n       All bits are cleared by being written with a 1. \n             0: conversion of the corresponding ADC channel is not complete\n        1: conversion of the corresponding ADC channel is complete</description>
               <addressOffset>0x8</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>STS</name>
                     <description>All bits are cleared by being written with a '1'. 1=conversion of the corresponding ADC channel is complete;\n          0=conversion of the corresponding ADC channel is not complete. For enabled single cycles, the SINGLE_DONE_STATUS bit in the\n              ADC Control Register is also set after all enabled channel conversion are done; for enabled repeat cycles, the REPEAT_DONE_STATUS\n          in the ADC Control Register is also set after all enabled channel conversion are done.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SNG_EN</name>
               <description>The ADC Single Register is used to control which ADC channel \n       is captured during a Single-Sample conversion cycle initiated by the Start_Single bit in the ADC Control Register. \n           APPLICATION NOTE: Do not change the bits in this register in the middle of a conversion cycle to insure proper operation.\n           0: single cycle conversions for this channel are disabled\n          1: single cycle conversions for this channel are enabled</description>
               <addressOffset>0xC</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>S_EN</name>
                     <description>Each bit in this field enables the corresponding ADC channel when a single cycle of conversions is started when the\n            START_SINGLE bit in the ADC Control Register is written with a 1. 1=single cycle conversions for this channel are enabled\n               0=single cycle conversions for this channel are disabled. Note: If this register is changed while a conversion.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>REPT_EN</name>
               <description>The ADC Repeat Register is used to control which ADC channels \n       are captured during a repeat conversion cycle initiated by the Start_Repeat bit in the ADC Control Register.</description>
               <addressOffset>0x10</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>R_EN</name>
                     <description>Each bit in this field enables the corresponding ADC channel for each pass of the Repeated ADC Conversion that is\n         controlled by bit START_REPEAT in the ADC Control Register. 1=repeat conversions for this channel are enabled;\n               0=repeat conversions for this channel are disabled</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>16</dim>
               <dimIncrement>4</dimIncrement>
               <name>CHAN_RD[%s]</name>
               <description>All 16 ADC channels return their results into \n       a 32-bit reading register. In each case the low 10 bits of the reading register\n       return the result of the Analog to Digital conversion and the upper 22 bits return 0.</description>
               <addressOffset>0x14</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>FAN0</name>
         <version>1071.0</version>
         <description>The RPM-PWM Interface is an RPM based Fan Control Algorithm that monitors the fan's speed and automatically adjusts\n       the drive to maintain the desired fan speed. This RPM based Fan Control Algorithm controls a PWM output based on a tachometer input.</description>
         <groupName>FAN</groupName>
         <prependToName>FAN_</prependToName>
         <baseAddress>0x4000A000</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x12</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>RPM2PWM_0_FAIL</name>
            <value>74</value>
         </interrupt>
         <interrupt>
            <name>RPM2PWM_0_STALL</name>
            <value>75</value>
         </interrupt>
         <registers>
            <register>
               <name>FAN_SET</name>
               <description>The Fan Driver Setting used to control the output of the Fan Driver.</description>
               <addressOffset>0x0</addressOffset>
               <size>16</size>
               <resetValue>0x0000</resetValue>
               <fields>
                  <field>
                     <name>FAN_SETTING</name>
                     <description>The Fan Driver Setting used to control the output of the Fan Driver.</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>10</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CFG</name>
               <description>The Fan Configuration Register controls the general operation of the RPM based Fan Control Algorithm used by the fan driver.</description>
               <addressOffset>0x2</addressOffset>
               <size>16</size>
               <resetValue>0x342B</resetValue>
               <fields>
                  <field>
                     <name>UPDATE</name>
                     <description>Determines the base time between fan driver updates. The Update Time, along with the Fan Step Register, is used to control\n       the ramp rate of the drive response to provide a cleaner transition of the actual fan operation as the desired fan speed changes.\n           7=1600ms\n          6=1200ms\n                  5=800ms\n            4=500ms\n            3=400ms\n                   2=300ms\n                 1=200ms\n                 0=100ms\n              Note: This ramp rate control applies for all changes to the active PWM output including when the RPM based Fan Speed Control Algorithm\n       is disabled.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>3</bitWidth>
                     <enumeratedValues>
                        <name>UPDATESelect</name>
                        <enumeratedValue>
                           <name>BASE_TIME_1600ms</name>
                           <description>7=1600ms</description>
                           <value>0x7</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>BASE_TIME_1200ms</name>
                           <description>6=1200ms</description>
                           <value>0x6</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>BASE_TIME_800ms </name>
                           <description>5=800ms </description>
                           <value>0x6</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>BASE_TIME_500ms </name>
                           <description>4=500ms </description>
                           <value>0x5</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>BASE_TIME_400ms </name>
                           <description>3=400ms </description>
                           <value>0x4</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>BASE_TIME_300ms </name>
                           <description>2=300ms </description>
                           <value>0x3</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>BASE_TIME_200ms </name>
                           <description>1=200ms </description>
                           <value>0x2</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>BASE_TIME_100ms </name>
                           <description>0=100ms </description>
                           <value>0x1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>EDGES</name>
                     <description>Determines the minimum number of edges that must be detected on the TACH signal to determine a single rotation. A typical\n      fan measured 5 edges (for a 2-pole fan). Increasing the number of edges measured with respect to the number of poles of the fan will\n         cause the TACH Reading registers to indicate a fan speed that is higher or lower than the actual speed. In order for the FSC Algorithm\n       to operate correctly, the TACH Target must be updated by the user to accommodate this shift. The Effective Tach Multiplier is used as\n        a direct multiplier term that is applied to the Actual RPM to achieve the Reported RPM. It should only be applied if the number of\n        edges measured does not match the number of edges expected based on the number of poles of the fan (which is fixed for any given fan).</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>RANGE</name>
                     <description>Adjusts the range of reported and programmed tachometer reading values. The RANGE bits determine the weighting of all\n        TACH values (including the Valid TACH Count, TACH Target, and TACH reading).\n                   3=Reported Minimum RPM: 4000. Tach Count Multiplier: 1\n               2=Reported Minimum RPM: 2000. Tach Count Multiplier: 2\n                1=Reported Minimum RPM: 1000. Tach Count Multiplier: 4\n                0=Reported Minimum RPM: 500. Tach Count Multiplier: 8</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>2</bitWidth>
                     <enumeratedValues>
                        <name>RANGESelect</name>
                        <enumeratedValue>
                           <name>TACH_COUNT_MULTIPLIER_8</name>
                           <description>3=Reported Minimum RPM: 4000. Tach Count Multiplier: 8</description>
                           <value>0x3</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>TACH_COUNT_MULTIPLIER_4</name>
                           <description>2=Reported Minimum RPM: 2000. Tach Count Multiplier: 4</description>
                           <value>0x2</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>TACH_COUNT_MULTIPLIER_2</name>
                           <description>1=Reported Minimum RPM: 1000. Tach Count Multiplier: 2</description>
                           <value>0x1</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>TACH_COUNT_MULTIPLIER_1</name>
                           <description>0=Reported Minimum RPM:  500. Tach Count Multiplier: 1</description>
                           <value>0x0</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>EN_ALGO</name>
                     <description>Enables the RPM based Fan Control Algorithm.\n                  1=The control circuitry is enabled and the Fan Driver output will be automatically updated to maintain the programmed fan speed\n        as indicated by the TACH Target Register.\n        0=The control circuitry is disabled and the fan driver output is determined by the Fan Driver Setting Register.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>POLARITY</name>
                     <description>Determines the polarity of the PWM driver. This does NOT affect the drive setting registers. A setting of 0% drive will\n      still correspond to 0% drive independent of the polarity.\n      1 - The Polarity of the PWM driver is inverted. A drive setting of 00h will cause the output to be set at 100% duty cycle and\n       a drive setting of FFh will cause the output to be set at 0% duty cycle.\n       0 - the Polarity of the PWM driver is normal. A drive setting of 00h will cause the output to be set at 0% duty cycle and\n      a drive setting of FFh will cause the output to be set at 100% duty cycle.</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ERR_RNG</name>
                     <description>Control some of the advanced options that affect the error window. When the measured fan speed is within the programmed\n         error window around the target speed, the fan drive setting is not updated. These bits only apply if the Fan Speed Control Algorithm is used.\n            3=200 RPM\n               2=100 RPM\n               1=50 RPM\n              0=0 RPM</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>2</bitWidth>
                     <enumeratedValues>
                        <name>ERR_RNGSelect</name>
                        <enumeratedValue>
                           <name>RPM_200</name>
                           <description>3=200 RPM</description>
                           <value>0x3</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>RPM_100</name>
                           <description>2=100 RPM</description>
                           <value>0x2</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>RPM_50 </name>
                           <description>1=50 RPM </description>
                           <value>0x1</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>RPM_0  </name>
                           <description>0=0 RPM  </description>
                           <value>0x0</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>DER_OPT</name>
                     <description>Control some of the advanced options that affect the derivative portion of the RPM based fan control algorithm.\n        These bits only apply if the Fan Speed Control Algorithm is used.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>DIS_GLITCH</name>
                     <description>Disables the low pass glitch filter that removes high frequency noise injected on the TACH pin.\n       1 - The glitch filter is disabled.\n      0 - The glitch filter is enabled.</description>
                     <bitOffset>14</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>EN_RRC</name>
                     <description>Enables the ramp rate control circuitry during the Manual Mode of operation.\n        1=The ramp rate control circuitry for the Manual Mode of operation is enabled. The PWM setting will follow the ramp rate controls\n       as determined by the Fan Step and Update Time settings. The maximum PWM step is capped at the Fan Step setting and is updated\n        based on the Update Time as given by the field UPDATE.\n         0=The ramp rate control circuitry for the Manual Mode of operation is disabled. When the Fan Drive Setting values are changed\n        and the RPM based Fan Control Algorithm is disabled, the fan driver will be set to the new setting immediately.</description>
                     <bitOffset>15</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>PWM_DIV</name>
               <description>PWM Divide</description>
               <addressOffset>0x4</addressOffset>
               <size>8</size>
               <resetValue>0x01</resetValue>
               <fields>
                  <field>
                     <name>PWM_DIV</name>
                     <description>The PWM Divide value determines the final frequency of the PWM driver. The driver base frequency is divided by the\n      PWM Divide value to determine the final frequency.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>GAIN</name>
               <description>Gain Register stores the gain terms used by the proportional and integral portions of the RPM based Fan Control Algorithm.</description>
               <addressOffset>0x5</addressOffset>
               <size>8</size>
               <resetValue>0x2A</resetValue>
               <fields>
                  <field>
                     <name>GAINP</name>
                     <description>The proportional gain term.\n       Gain Factor:\n          3=8x\n             2=4x\n              1=2x\n             0=1x</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>2</bitWidth>
                     <enumeratedValues>
                        <name>GAINPSelect</name>
                        <enumeratedValue>
                           <name>GAINP_8X</name>
                           <description>Gain Factor: 3=8x</description>
                           <value>0x3</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>GAINP_4X</name>
                           <description>Gain Factor: 2=4x</description>
                           <value>0x2</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>GAINP_2X</name>
                           <description>Gain Factor: 1=2x</description>
                           <value>0x1</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>GAINP_1X</name>
                           <description>Gain Factor: 0=1x</description>
                           <value>0x0</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>GAINI</name>
                     <description>The integral gain term.\n        Gain Factor:\n                3=8x\n               2=4x\n                 1=2x\n                 0=1x</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>2</bitWidth>
                     <enumeratedValues>
                        <name>GAINISelect</name>
                        <enumeratedValue>
                           <name>GAINI_8X</name>
                           <description>Gain Factor: 3=8x</description>
                           <value>0x3</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>GAINI_4X</name>
                           <description>Gain Factor: 2=4x</description>
                           <value>0x2</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>GAINI_2X</name>
                           <description>Gain Factor: 1=2x</description>
                           <value>0x1</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>GAINI_1X</name>
                           <description>Gain Factor: 0=1x</description>
                           <value>0x0</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>GAIND</name>
                     <description>The derivative gain term.\n      Gain Factor:\n       3=8x\n           2=4x\n           1=2x\n              0=1x</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>2</bitWidth>
                     <enumeratedValues>
                        <name>GAINDSelect</name>
                        <enumeratedValue>
                           <name>GAIND_8X</name>
                           <description>Gain Factor: 3=8x</description>
                           <value>0x3</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>GAIND_4X</name>
                           <description>Gain Factor: 2=4x</description>
                           <value>0x2</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>GAIND_2X</name>
                           <description>Gain Factor: 1=2x</description>
                           <value>0x1</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>GAIND_1X</name>
                           <description>Gain Factor: 0=1x</description>
                           <value>0x0</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
               </fields>
            </register>
            <register>
               <name>SPIN_UP_CFG</name>
               <description>The Fan Spin Up Configuration Register controls the settings of Spin Up Routine.</description>
               <addressOffset>0x6</addressOffset>
               <size>8</size>
               <resetValue>0x19</resetValue>
               <fields>
                  <field>
                     <name>SPINUP_TIME</name>
                     <description>Determines the maximum Spin Time that the Spin Up Routine will run for. If a valid tachometer measurement is not\n           detected before the Spin Time has elapsed, an interrupt will be generated. When the RPM based Fan Control Algorithm is active,\n         the fan driver will attempt to re-start the fan immediately after the end of the last spin up attempt.\n               3=2 seconds\n               2=1 second\n                 1=500 ms\n               0=250 ms</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>2</bitWidth>
                     <enumeratedValues>
                        <name>SPINUP_TIMESelect</name>
                        <enumeratedValue>
                           <name>SPINUP_2_SEC</name>
                           <description>3=2 seconds</description>
                           <value>0x3</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>SPINUP_1_SEC</name>
                           <description>2=1 second </description>
                           <value>0x2</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>SPINUP_500_MSEC</name>
                           <description>1=500 ms</description>
                           <value>0x1</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>SPINUP_250_MSEC</name>
                           <description>0=250 ms</description>
                           <value>0x0</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>SPIN_LVL</name>
                     <description>Determines the final drive level that is used by the Spin Up Routine.\n       7=65%\n             6=60%\n           5=55%\n            4=50%\n               3=45%\n            2=40%\n            1=35%\n           0=30%</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>3</bitWidth>
                     <enumeratedValues>
                        <name>SPIN_LVLSelect</name>
                        <enumeratedValue>
                           <name>SPIN_LVL_65</name>
                           <description>7=65%</description>
                           <value>0x7</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>SPIN_LVL_60</name>
                           <description>6=60%</description>
                           <value>0x6</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>SPIN_LVL_55</name>
                           <description>5=55%</description>
                           <value>0x5</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>SPIN_LVL_50</name>
                           <description>4=50%</description>
                           <value>0x4</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>SPIN_LVL_45</name>
                           <description>3=45%</description>
                           <value>0x3</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>SPIN_LVL_40</name>
                           <description>2=40%</description>
                           <value>0x2</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>SPIN_LVL_35</name>
                           <description>1=35%</description>
                           <value>0x1</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>SPIN_LVL_30</name>
                           <description>0=30%</description>
                           <value>0x0</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>NOKICK</name>
                     <description>Determines if the Spin Up Routine will drive the fan to 100% duty cycle for 1/4 of the programmed spin up time before\n            driving it at the programmed level.\n              1=The Spin Up Routine will not drive the PWM to 100%. It will set the drive at the programmed spin level for the entire duration of\n         the programmed spin up time\n         0=The Spin Up Routine will drive the PWM to 100% for 1/4 of the programmed spin up time before reverting to the programmed spin level.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DRIVE_FAIL_CNT</name>
                     <description>Determines how many update cycles are used for the Drive Fail detection function. This circuitry determines whether the\n      fan can be driven to the desired Tach target. These settings only apply if the Fan Speed Control Algorithm is enabled.\n        3=Drive Fail detection circuitry will count for 64 update periods\n       2=Drive Fail detection circuitry will count for 32 update periods\n         1=Drive Fail detection circuitry will count for 16 update periods\n          0=Drive Fail detection circuitry is disabled.</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>2</bitWidth>
                     <enumeratedValues>
                        <name>DRIVE_FAIL_CNTSelect</name>
                        <enumeratedValue>
                           <name>DRIVE_FAIL_CNT_64_PERIOD</name>
                           <description>3=Drive Fail detection circuitry will count for 64 update periods</description>
                           <value>0x3</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>DRIVE_FAIL_CNT_32_PERIOD</name>
                           <description>2=Drive Fail detection circuitry will count for 32 update periods</description>
                           <value>0x2</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>DRIVE_FAIL_CNT_16_PERIOD</name>
                           <description>1=Drive Fail detection circuitry will count for 16 update periods</description>
                           <value>0x1</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>DRIVE_FAIL_CNT_DIS</name>
                           <description>0=Drive Fail detection circuitry is disabled.</description>
                           <value>0x0</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
               </fields>
            </register>
            <register>
               <name>FAN_STEP</name>
               <description>FAN_STEP The Fan Step value represents the maximum step size the fan driver will take between update times</description>
               <addressOffset>0x7</addressOffset>
               <size>8</size>
               <resetValue>0x10</resetValue>
               <fields>
                  <field>
                     <name>FAN_STEP</name>
                     <description>The Fan Step value represents the maximum step size the fan driver will take between update times.\n      When the PWM_BASE frequency range field in the PWM Driver Base Frequency Register is set to the value 1, 2 or 3, this 8-bit field\n        is added to the 10-bit PWM duty cycle, for a maximum step size of 25%. When the PWM_BASE field is set to 0, the PWM operates in\n        an 8-bit mode. In 8-bit mode, this 8-bit field is added to the 8-bit duty cycle, for a maximum step size of 100%.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MIN_DRIVE</name>
               <description>the minimum drive setting for the RPM based Fan Control Algorithm.</description>
               <addressOffset>0x8</addressOffset>
               <size>8</size>
               <resetValue>0x66</resetValue>
               <fields>
                  <field>
                     <name>MIN_DRIVE</name>
                     <description>The minimum drive setting.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>VAL_TACH_CNT</name>
               <description>The maximum TACH Reading Register value to indicate that the fan is spinning properly.</description>
               <addressOffset>0x9</addressOffset>
               <size>8</size>
               <resetValue>0xF5</resetValue>
               <fields>
                  <field>
                     <name>VALID_TACH_CNT</name>
                     <description>The maximum TACH Reading Register value to indicate that the fan is spinning properly.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>FAN_DRIVE_FAIL_BAND</name>
               <description>The number of Tach counts used by the Fan Drive Fail detection circuitry</description>
               <addressOffset>0xA</addressOffset>
               <size>16</size>
               <resetValue>0x0000</resetValue>
               <fields>
                  <field>
                     <name>FAN_DRIVE_FAIL_BAND</name>
                     <description>The number of Tach counts used by the Fan Drive Fail detection circuitry.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>13</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>TACH_TGT</name>
               <description>The target tachometer value.</description>
               <addressOffset>0xC</addressOffset>
               <size>16</size>
               <resetValue>0x0000</resetValue>
               <fields>
                  <field>
                     <name>TACH_TGT</name>
                     <description>The target tachometer value.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>13</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>TACH_RD</name>
               <description>[15:3] The current tachometer reading value.</description>
               <addressOffset>0xE</addressOffset>
               <size>16</size>
               <resetValue>0x0000</resetValue>
               <fields>
                  <field>
                     <name>TACH_RD</name>
                     <description>The current tachometer reading value.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>13</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>DRIV_BASE_FREQ</name>
               <description>[1:0] Determines the frequency range of the PWM fan driver</description>
               <addressOffset>0x10</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>PWM_BASE</name>
                     <description>Determines the frequency range of the PWM fan driver (when enabled). PWM resolution is 10-bit, except when this field\n        is set to '0b', when it is 8-bit.\n                 3=2.34KHz\n                 2=4.67KHz\n                 1=23.4KHz\n                0=26.8KHz</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>2</bitWidth>
                     <enumeratedValues>
                        <name>PWM_BASESelect</name>
                        <enumeratedValue>
                           <name>PWM_FAN_FREQ_2KHZ</name>
                           <description>3=2.34KHz</description>
                           <value>0x3</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>PWM_FAN_FREQ_4KHZ</name>
                           <description>2=4.67KHz</description>
                           <value>0x2</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>PWM_FAN_FREQ_23KHZ</name>
                           <description>1=23.4KHz</description>
                           <value>0x1</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>PWM_FAN_FREQ_26KHZ</name>
                           <description>0=26.8KHz</description>
                           <value>0x0</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
               </fields>
            </register>
            <register>
               <name>STS</name>
               <description>The bits in this register are routed to interrupts.</description>
               <addressOffset>0x11</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>FAN_STALL</name>
                     <description>The bit Indicates that the tachometer measurement on the Fan detects a stalled fan.  (R/WC)\n       0 - Stalled fan not detected.\n               1 - Stalled fan detected.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FAN_SPIN</name>
                     <description>The bit Indicates that the Spin up Routine for the Fan could not detect a valid tachometer reading within its maximum\n           time window. (R/WC)\n            1 - The Spin up Routine for the Fan could not detect a valid tachometer reading within its maximum time window.\n          0 - The Spin up Routine for the Fan detected a valid tachometer reading within its maximum time window.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DRIVE_FAIL</name>
                     <description>The bit Indicates that the RPM-based Fan Speed Control Algorithm cannot drive the Fan to the desired target setting at\n       maximum drive. (R/WC)\n        1- The RPM-based Fan Speed Control Algorithm cannot drive Fan to the desired target setting at maximum drive.\n                0- The RPM-based Fan Speed Control Algorithm can drive Fan to the desired target setting.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral derivedFrom="FAN0">
         <name>FAN1</name>
         <baseAddress>0x4000A080</baseAddress>
         <interrupt>
            <name>RPM2PWM_1_FAIL</name>
            <value>76</value>
         </interrupt>
         <interrupt>
            <name>RPM2PWM_1_STALL</name>
            <value>77</value>
         </interrupt>
      </peripheral>
      <peripheral>
         <name>LED0</name>
         <version>1111.0</version>
         <description>The blinking/breathing hardware is implemented using a PWM. The PWM can be driven either by the 48 MHz\n      clock or by a 32.768 KHz clock input. When driven by the 48 MHz clock, the PWM can be used as a standard 8-bit\n      PWM in order to control a fan. When used to drive blinking or breathing LEDs, the 32.768 KHz clock source is used.</description>
         <groupName>LED</groupName>
         <prependToName>LED_</prependToName>
         <baseAddress>0x4000B800</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x18</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>LED0</name>
            <value>83</value>
         </interrupt>
         <registers>
            <register>
               <name>CFG</name>
               <description>LED Configuration</description>
               <addressOffset>0x0</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>CTRL</name>
                     <description>CTRL 3=PWM is always on\n      2=LED blinking (standard PWM)\n      1=LED breathing configuration\n      0=PWM is always off. All internal registers and counters are reset to 0. Clocks are gated</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>CLK_SRC</name>
                     <description>1=Clock source is the 48 MHz clock, 0=Clock source is the 32.768 KHz clock</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SYNCH</name>
                     <description>SYNCH  When this bit is '1', all counters for all LEDs are reset to their initial values.\n       When this bit is '0' in the LED Configuration Register for all LEDs, then all counters for LEDs that are configured to blink or breathe will increment or decrement, as required.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWM_SIZE</name>
                     <description>PWM_SIZE This bit controls the behavior of PWM:\n      3=Reserved\n      2=PWM is configured as a 6-bit PWM\n      1=PWM is configured as a 7-bit PWM\n      0=PWM is configured as an 8-bit PWM</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>EN_UPDATE</name>
                     <description>EN_UPDATE  This bit is set to 1 when written with a '1'. Writes of '0' have no effect.\n       Hardware clears this bit to 0 when the breathing configuration registers are updated at the end of a PWM period. The current state of the bit is readable any time.</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RST</name>
                     <description>RST  Writes of '1' to this bit resets the PWM registers to their default values. This bit is self clearing.\n       Writes of '0' to this bit have no effect.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>WDT_RELOAD</name>
                     <description>WDT_RELOAD  The PWM Watchdog Timer counter reload value. On system reset, it defaults to 14h, which corresponds to a 4 second Watchdog timeout value.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>SYMMETRY</name>
                     <description>SYMMETRY  1=The rising and falling ramp times are in Asymmetric mode.\n      0=The rising and falling ramp times are in Symmetric mode.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>LIMIT</name>
               <description>LED Limits This register may be written at any time.\n       Values written into the register are held in an holding register, which is transferred into the actual register at the end of a PWM period.\n       The two byte fields may be written independently. Reads of this register return the current contents and not the value of the holding register.</description>
               <addressOffset>0x4</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>MIN</name>
                     <description>In breathing mode, when the current duty cycle is less than or equal to this value the breathing apparatus holds \n       the current duty cycle for the period specified by the field LD in register LED_DELAY, then starts incrementing the current duty cycle In blinking mode,\n       this field defines the duty cycle of the blink function.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>MAX</name>
                     <description>In breathing mode, when the current duty cycle is greater than or equal to this value the breathing apparatus holds \n       the current duty cycle for the period specified by the field HD in register LED_DELAY, then starts decrementing the current duty cycle</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>DLY</name>
               <description>LED Delay</description>
               <addressOffset>0x8</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>LOW_PULSE</name>
                     <description>The number of PWM periods to wait before updating the current duty cycle when the current duty cycle is greater than or equal \n       to the value MIN in register LED_LIMIT.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>12</bitWidth>
                  </field>
                  <field>
                     <name>HIGH_PULSE</name>
                     <description>In breathing mode, the number of PWM periods to wait before updating the current duty cycle when the current duty cycle is greater\n       than or equal to the value MAX in register LED_LIMIT.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>12</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>STEP</name>
               <description>This register has eight segment fields which provide the amount the current duty cycle \n       is adjusted at the end of every PWM period. Segment field selection is decoded based on the segment index. The segment index equation utilized depends on the SYMMETRY bit in the LED Configuration Register Register)      . In Symmetric Mode the Segment_Index[2:0] = Duty Cycle Bits[7:5]\n      . In Asymmetric Mode the Segment_Index[2:0] is the bit concatenation of following: Segment_Index[2] = (FALLING RAMP TIME in Figure 30-3, Clipping Example) and Segment_Index[1:0] = Duty Cycle Bits[7:6].</description>
               <addressOffset>0xC</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>S0</name>
                     <description>Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 000.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>S1</name>
                     <description>Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 001.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>S2</name>
                     <description>Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 010.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>S3</name>
                     <description>Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 011.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>S4</name>
                     <description>Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 100.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>S5</name>
                     <description>Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 101</description>
                     <bitOffset>20</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>S6</name>
                     <description>Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 110.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>S7</name>
                     <description>Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 111.</description>
                     <bitOffset>28</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>INTRVL</name>
               <description>LED Update Interval</description>
               <addressOffset>0x10</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>I0</name>
                     <description>The number of PWM periods between updates to current duty cycle when the segment index is equal to 000b.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>I1</name>
                     <description>The number of PWM periods between updates to current duty cycle when the segment index is equal to 001b.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>I2</name>
                     <description>The number of PWM periods between updates to current duty cycle when the segment index is equal to 010b.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>I3</name>
                     <description>The number of PWM periods between updates to current duty cycle when the segment index is equal to 011b.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>I4</name>
                     <description>The number of PWM periods between updates to current duty cycle when the segment index is equal to 100b.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>I5</name>
                     <description>The number of PWM periods between updates to current duty cycle when the segment index is equal to 101b.</description>
                     <bitOffset>20</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>I6</name>
                     <description>The number of PWM periods between updates to current duty cycle when the segment index is equal to 110b.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>I7</name>
                     <description>The number of PWM periods between updates to current duty cycle when the segment index is equal to 111b.</description>
                     <bitOffset>28</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>OUTDLY</name>
               <description>LED Output Delay</description>
               <addressOffset>0x14</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>DELAY</name>
                     <description>The delay, in counts of the clock defined in Clock Source (CLKSRC), in which output transitions are delayed.\n      When this field is 0, there is no added transition delay. When the LED is programmed to be Always On or Always Off, the\n      Output Delay field has no effect.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral derivedFrom="LED0">
         <name>LED1</name>
         <baseAddress>0x4000B900</baseAddress>
         <interrupt>
            <name>LED1</name>
            <value>84</value>
         </interrupt>
      </peripheral>
      <peripheral derivedFrom="LED0">
         <name>LED2</name>
         <baseAddress>0x4000BA00</baseAddress>
         <interrupt>
            <name>LED2</name>
            <value>85</value>
         </interrupt>
      </peripheral>
      <peripheral derivedFrom="LED0">
         <name>LED3</name>
         <baseAddress>0x4000BB00</baseAddress>
         <interrupt>
            <name>LED3</name>
            <value>86</value>
         </interrupt>
      </peripheral>
      <peripheral>
         <name>RC_ID0</name>
         <version>551.0</version>
         <description>This interface provides a single pin interface which can discriminate a number of quantized RC constants.</description>
         <groupName>RC_ID</groupName>
         <prependToName>RC_ID_</prependToName>
         <baseAddress>0x40001400</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x8</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>RC_ID0</name>
            <value>80</value>
         </interrupt>
         <registers>
            <register>
               <name>RC_ID_CTRL</name>
               <description>RC_ID Control Register</description>
               <addressOffset>0x0</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>DONE</name>
                     <description>This bit is cleared to 0 when the RC_ID interface is in the Reset phase, and set to 1 when the interface completes an RC_ID measurement.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TC</name>
                     <description>This bit is cleared to 0 when the RC_ID interface is in the Reset phase, and set to 1 when the interface completes the Discharged phase of an RC_ID measurement.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CY_ER</name>
                     <description>This bit is 1 if an RC_ID measurement encountered an error and the reading in the RC_ID Data Register is invalid. This bit is cleared to 0 when the RC_ID interface is in the Reset phase.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>START</name>
                     <description>Setting this bit to 1 initiates the Discharged phase of an RC_ID measurement.</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ENABLE</name>
                     <description>Clearing the bit to 0 causes the RC_ID interface to enter the Reset state, gating its clocks, clearing the status bits in this register and entering \n       into its lowest power state. Setting this bit to 1 causes the RC_ID interface to enter the Armed phase of an RC_ID measurement.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CLOCK_SET</name>
                     <description>This field selects the frequency of the Counter circuit clock. This field must retain the same value as long as the ENABLE bit in this register is 1.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>RC_ID_DAT</name>
               <description>Reads of this register provide the result of an RC_ID measurement.</description>
               <addressOffset>0x4</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>RCID_DATA</name>
                     <description>Reads of this register provide the result of an RC_ID measurement.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral derivedFrom="RC_ID0">
         <name>RC_ID1</name>
         <baseAddress>0x40001480</baseAddress>
         <interrupt>
            <name>RC_ID1</name>
            <value>81</value>
         </interrupt>
      </peripheral>
      <peripheral derivedFrom="RC_ID0">
         <name>RC_ID2</name>
         <baseAddress>0x40001500</baseAddress>
         <interrupt>
            <name>RC_ID2</name>
            <value>82</value>
         </interrupt>
      </peripheral>
      <peripheral>
         <name>KMS</name>
         <version>331.0</version>
         <description>The Keyboard Scan Interface block provides a register interface to the EC\n      to directly scan an external keyboard matrix of size up to 18x8.</description>
         <groupName>KMS</groupName>
         <prependToName>KMS_</prependToName>
         <baseAddress>0x40009C00</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x18</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>KMS</name>
            <value>135</value>
         </interrupt>
         <registers>
            <register>
               <name>KSO_SEL</name>
               <description>KSO Select and control</description>
               <addressOffset>0x4</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SEL</name>
                     <description>This field selects a KSO line (00000b = KSO[0] etc.) for output according to the value off KSO_INVERT in this register.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>5</bitWidth>
                  </field>
                  <field>
                     <name>ALL</name>
                     <description>0=When key scan is enabled, KSO output controlled by the KSO_SELECT field.\n      1=KSO[x] driven high when selected.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>KSEN</name>
                     <description>0= Keyboard scan enabled, 1= Keyboard scan disabled. All KSO output buffers disabled.</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>INV</name>
                     <description>0= KSO[x] driven low when selected, 1= KSO[x] driven high when selected.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>KSI</name>
               <description>[7:0] This field returns the current state of the KSI pins.</description>
               <addressOffset>0x8</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>KSI_STS</name>
               <description>[7:0] Each bit in this field is set on the falling edge of the corresponding KSI input pin.\n      A KSI interrupt is generated when its corresponding status bit and interrupt enable bit are both set. KSI interrupts are logically ORed together to produce KSC_INT and KSC_INT_WAKE.\n      Writing a '1' to a bit will clear it. Writing a '0' to a bit has no effect.</description>
               <addressOffset>0xC</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>KSI_IEN</name>
               <description>[7:0] Each bit in KSI_IEN enables interrupt generation due to highto-low transition on a KSI input.\n       An interrupt is generated when the corresponding bits in KSI_STATUS and KSI_INT_EN are both set.</description>
               <addressOffset>0x10</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>EXT_CTRL</name>
               <description>[0:0] PREDRIVE_ENABLE enables the \n       PREDRIVE mode to actively drive the KSO pins high for approximately 100ns before switching to open-drain operation.\n      0=Disable predrive on KSO pins\n      1=Enable predrive on KSO pins.</description>
               <addressOffset>0x14</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>SMB0</name>
         <version>311.0</version>
         <description>The SMBus interface can handle standard SMBus 2.0 protocols as well as I2C interface.</description>
         <groupName>SMB</groupName>
         <prependToName>SMB_</prependToName>
         <baseAddress>0x40004000</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x68</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>SMB0</name>
            <value>20</value>
         </interrupt>
         <registers>
            <register>
               <name>WCTRL</name>
               <description>Control Register</description>
               <addressOffset>0x0</addressOffset>
               <size>32</size>
               <access>write-only</access>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>ACK</name>
                     <description>The Acknowledge bit (ACK) must normally be asserted ('1'). This causes the controller to send an acknowledge automatically after each byte (this occurs during the 9th clock pulse). The ACK bit must not be asserted ('0') when the controller is operating in master/receiver mode and requires no further data to be sent from the slave transmitter. This causes a negative acknowledge on the I2C bus, which halts further transmission from the slave device.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>STO</name>
                     <description>See STA description</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>STA</name>
                     <description>The STA and STO bits control the generation of the I2C Start condition and the transmission of the Slave Address and R/nW bit (from the Data Register), generation of repeated Start condition, and generation of the Stop condition</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ENI</name>
                     <description>Enable Interrupt bit (ENI) controls the Interrupt Interface</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ESO</name>
                     <description>The Enable Serial Output bit (ESO) enables and disables the SMB Controller Core serial data output (SDAT)</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PIN</name>
                     <description>The Pending Interrupt Not (PIN) bit serves as a software reset function. Writing the PIN bit to a logic '1' de-asserts all status bits except for the nBB bit which is not affected by the PIN bit. The PIN bit is a self-clearing bit. Writing this bit to a logic '0' has no effect.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>RSTS</name>
               <description>Status Register</description>
               <addressOffset>0x0</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>NBB</name>
                     <description>The Bus Busy bit (NBB) is a read-only flag indicating when the bus is in use. A zero indicates that the bus is busy and access is not possible.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>LAB</name>
                     <description>The Lost Arbitration Bit (LAB) is set when, in multi-master operation, arbitration is lost to another master on the bus</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>AAS</name>
                     <description>The Addressed As Slave bit (AAS) is valid only when PIN is asserted ('0'). When acting as slave, AAS is set when an incoming address over the bus matches the value in the Own Address Register or if the 'general call' address (00h) has been received</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>LRB_AD0</name>
                     <description>The Last Received Bit  or Address 0 (general call) bit (LRB/AD0) serves a dual function and is valid only while the PIN bit is asserted ('0').\n                When the AAS bit is not asserted ('0') (i.e., not addressed as a slave), the LRB/AD0 holds the value of the last received bit over the bus.\n                When the AAS bit is asserted ('1') (i.e., addressed as slave), the SMB Controller Core has been addressed as a slave.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BER</name>
                     <description>When Bus Error (BER) is asserted, a misplaced START or STOP condition or Bus Time-Outs have been detected.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>STS</name>
                     <description>When in slave receiver mode, STS is asserted ('1') when an externally generated STOP condition is detected. Note that STS is used only in slave receiver mode.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SAD</name>
                     <description>SMBus Address Decoded (SAD)</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PIN</name>
                     <description>Pending Interrupt bit</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>OWN_ADDR</name>
               <description>Own Address Register\n           Note that the Data Register and Own Address fields are offset by one bit, so that programming Own Address 1 with a value of 55h will result in the value AAh being recognized as the SMB Controller Core slave address.</description>
               <addressOffset>0x4</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>ADDR1</name>
                     <description>The Own Address 1 bits configure one of the two addresses to which the SMB Controller Core will respond when addressed as a slave.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>7</bitWidth>
                  </field>
                  <field>
                     <name>ADDR2</name>
                     <description>The Own Address 2 bits configure one of the two addresses to which the SMB Controller Core will respond when addressed as a slave.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>7</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>I2CDATA</name>
               <description>This register holds the data that are either shifted out to or shifted in from the I2C port.</description>
               <addressOffset>0x8</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <dim>3</dim>
               <dimIncrement>1</dimIncrement>
               <name>RSVD1[%s]</name>
               <description>Reserved</description>
               <addressOffset>0x9</addressOffset>
               <size>8</size>
               <access>read-only</access>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>MCMD_u32</name>
               <description>SMBus Master Command Register</description>
               <addressOffset>0xC</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>MRUN</name>
                     <description>While this bit is 1, transfer bytes over SMBus. As long as WriteCount is non-zero, a byte from the Master Transmit Buffer is transmitted to the slave device and WriteCount is decremented.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MPROCEED</name>
                     <description>When this bit is 0, the Master State Machine does not transition out of the IDLE or PAUSE states. When this bit is 1, the Master State Machine immediately transitions to the WAIT-BUSBUSY and MRUN-RECEIVE states, respectively.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>START0</name>
                     <description>If this bit is 1, send a Start bit on the SMBus before the first byte of the WriteCount is sent to the SMBus transmitter.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>STARTN</name>
                     <description>If this bit is 1, send a Start bit just before the last byte of the WriteCount is sent to the SMBus transmitter.</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>STOP</name>
                     <description>If this bit is 1, send a Stop bit after the transaction completes.</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PEC_TERM</name>
                     <description>If this bit is 1, a copy of the PEC register is transmitted when WriteCount is 0. After the PEC register is read, both the PEC register and this bit are cleared to 0.</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>READM</name>
                     <description>If this bit is 1, then the ReadCount field is replaced by the byte that is read from the SMBus when ReadCount[7:0] is 1. After ReadCount[7:0] is updated, this bit is cleared to 0.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RD_PEC</name>
                     <description>If this bit is 0, reading from the SMBus stops when ReadCount reaches 0. If this bit is 1, reading continues when ReadCount is 0 for one more byte.</description>
                     <bitOffset>13</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>WR_CNT</name>
                     <description>This field is a count of the number of bytes to transmit to the SMBus from the SMBus Master Transmit Buffer Register It is decremented by 1 for each byte written to the SMBus from the SMBus Master Transmit Buffer Register.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>RD_CNT</name>
                     <description>This field is a count of the number of bytes to read in from the SMBus to the SMBus Master Receive Buffer Register and must be greater than 0 in order for the Master State Machine to initiate a read phase. It is decremented by 1 for each byte read from the SMBus into the SMBus Master Receive Buffer Register. It can be overwritten by the first byte read in from the SMBus.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>2</dim>
               <dimIncrement>2</dimIncrement>
               <name>MCMD_u16[%s]</name>
               <description>SMBus Master Command Register</description>
               <addressOffset>0xC</addressOffset>
               <size>16</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>MRUN</name>
                     <description>While this bit is 1, transfer bytes over SMBus. As long as WriteCount is non-zero, a byte from the Master Transmit Buffer is transmitted to the slave device and WriteCount is decremented.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MPROCEED</name>
                     <description>When this bit is 0, the Master State Machine does not transition out of the IDLE or PAUSE states. When this bit is 1, the Master State Machine immediately transitions to the WAIT-BUSBUSY and MRUN-RECEIVE states, respectively.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>START0</name>
                     <description>If this bit is 1, send a Start bit on the SMBus before the first byte of the WriteCount is sent to the SMBus transmitter.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>STARTN</name>
                     <description>If this bit is 1, send a Start bit just before the last byte of the WriteCount is sent to the SMBus transmitter.</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>STOP</name>
                     <description>If this bit is 1, send a Stop bit after the transaction completes.</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PEC_TERM</name>
                     <description>If this bit is 1, a copy of the PEC register is transmitted when WriteCount is 0. After the PEC register is read, both the PEC register and this bit are cleared to 0.</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>READM</name>
                     <description>If this bit is 1, then the ReadCount field is replaced by the byte that is read from the SMBus when ReadCount[7:0] is 1. After ReadCount[7:0] is updated, this bit is cleared to 0.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>READ_PEC</name>
                     <description>If this bit is 0, reading from the SMBus stops when ReadCount reaches 0. If this bit is 1, reading continues when ReadCount is 0 for one more byte.</description>
                     <bitOffset>13</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>WR_CNT</name>
                     <description>This field is a count of the number of bytes to transmit to the SMBus from the SMBus Master Transmit Buffer Register It is decremented by 1 for each byte written to the SMBus from the SMBus Master Transmit Buffer Register.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>RD_CNT</name>
                     <description>This field is a count of the number of bytes to read in from the SMBus to the SMBus Master Receive Buffer Register and must be greater than 0 in order for the Master State Machine to initiate a read phase. It is decremented by 1 for each byte read from the SMBus into the SMBus Master Receive Buffer Register. It can be overwritten by the first byte read in from the SMBus.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>4</dim>
               <dimIncrement>1</dimIncrement>
               <name>MCMD_u08[%s]</name>
               <description>SMBus Master Command Register</description>
               <addressOffset>0xC</addressOffset>
               <size>8</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>MRUN</name>
                     <description>While this bit is 1, transfer bytes over SMBus. As long as WriteCount is non-zero, a byte from the Master Transmit Buffer is transmitted to the slave device and WriteCount is decremented.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MPROCEED</name>
                     <description>When this bit is 0, the Master State Machine does not transition out of the IDLE or PAUSE states. When this bit is 1, the Master State Machine immediately transitions to the WAIT-BUSBUSY and MRUN-RECEIVE states, respectively.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>START0</name>
                     <description>If this bit is 1, send a Start bit on the SMBus before the first byte of the WriteCount is sent to the SMBus transmitter.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>STARTN</name>
                     <description>If this bit is 1, send a Start bit just before the last byte of the WriteCount is sent to the SMBus transmitter.</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>STOP</name>
                     <description>If this bit is 1, send a Stop bit after the transaction completes.</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PEC_TERM</name>
                     <description>If this bit is 1, a copy of the PEC register is transmitted when WriteCount is 0. After the PEC register is read, both the PEC register and this bit are cleared to 0.</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>READM</name>
                     <description>If this bit is 1, then the ReadCount field is replaced by the byte that is read from the SMBus when ReadCount[7:0] is 1. After ReadCount[7:0] is updated, this bit is cleared to 0.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>READ_PEC</name>
                     <description>If this bit is 0, reading from the SMBus stops when ReadCount reaches 0. If this bit is 1, reading continues when ReadCount is 0 for one more byte.</description>
                     <bitOffset>13</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>WR_CNT</name>
                     <description>This field is a count of the number of bytes to transmit to the SMBus from the SMBus Master Transmit Buffer Register It is decremented by 1 for each byte written to the SMBus from the SMBus Master Transmit Buffer Register.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>RD_CNT</name>
                     <description>This field is a count of the number of bytes to read in from the SMBus to the SMBus Master Receive Buffer Register and must be greater than 0 in order for the Master State Machine to initiate a read phase. It is decremented by 1 for each byte read from the SMBus into the SMBus Master Receive Buffer Register. It can be overwritten by the first byte read in from the SMBus.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SCMD_u32</name>
               <description>SMBus Slave Command Register</description>
               <addressOffset>0x10</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SRUN</name>
                     <description>Setting this bit to 1 enables the Slave State Machine to operate.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SPROCEED</name>
                     <description>When this bit is 0, the Slave State Machine does not transition out of the IDLE, REPEAT_START_WRITE or REPEAT_START_READ states. When this bit is 1, the Slave State Machine immediately transitions to the START_WAIT, RECEIVE and TRANSMIT states, respectively.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PEC</name>
                     <description>If Slave_WriteCount is 0 and Slave_PEC is 1 when the Master requests data, the PEC Register is copied to the DATA register. After the PEC Register is copied to the SMBus, the PEC Register is cleared and Slave_PEC is set to 0.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>WR_CNT</name>
                     <description>This field is set to the number of bytes software expects to send to the Master.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>RD_CNT</name>
                     <description>This field is decremented each time a byte is copied from DATA to the SMBus Slave Receive Buffer Register.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>2</dim>
               <dimIncrement>2</dimIncrement>
               <name>SCMD_u16[%s]</name>
               <description>SMBus Slave Command Register</description>
               <addressOffset>0x10</addressOffset>
               <size>16</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SRUN</name>
                     <description>Setting this bit to 1 enables the Slave State Machine to operate.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SPROCEED</name>
                     <description>When this bit is 0, the Slave State Machine does not transition out of the IDLE, REPEAT_START_WRITE or REPEAT_START_READ states. When this bit is 1, the Slave State Machine immediately transitions to the START_WAIT, RECEIVE and TRANSMIT states, respectively.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PEC</name>
                     <description>If Slave_WriteCount is 0 and Slave_PEC is 1 when the Master requests data, the PEC Register is copied to the DATA register. After the PEC Register is copied to the SMBus, the PEC Register is cleared and Slave_PEC is set to 0.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>WR_CNT</name>
                     <description>This field is set to the number of bytes software expects to send to the Master.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>RD_CNT</name>
                     <description>This field is decremented each time a byte is copied from DATA to the SMBus Slave Receive Buffer Register.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>4</dim>
               <dimIncrement>1</dimIncrement>
               <name>SCMD_u08[%s]</name>
               <description>SMBus Slave Command Register</description>
               <addressOffset>0x10</addressOffset>
               <size>8</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SRUN</name>
                     <description>Setting this bit to 1 enables the Slave State Machine to operate.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SPROCEED</name>
                     <description>When this bit is 0, the Slave State Machine does not transition out of the IDLE, REPEAT_START_WRITE or REPEAT_START_READ states. When this bit is 1, the Slave State Machine immediately transitions to the START_WAIT, RECEIVE and TRANSMIT states, respectively.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PEC</name>
                     <description>If Slave_WriteCount is 0 and Slave_PEC is 1 when the Master requests data, the PEC Register is copied to the DATA register. After the PEC Register is copied to the SMBus, the PEC Register is cleared and Slave_PEC is set to 0.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>WR_CNT</name>
                     <description>This field is set to the number of bytes software expects to send to the Master.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>RD_CNT</name>
                     <description>This field is decremented each time a byte is copied from DATA to the SMBus Slave Receive Buffer Register.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>PEC</name>
               <description>Packet Error Check (PEC) Register</description>
               <addressOffset>0x14</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>PEC</name>
                     <description>The SMBus Packet Error Check (PEC) byte.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>RSHTM</name>
               <description>Repeated Start Hold Time Register</description>
               <addressOffset>0x18</addressOffset>
               <size>32</size>
               <resetValue>0x0000004D</resetValue>
               <fields>
                  <field>
                     <name>RSHTM</name>
                     <description>This is the value of the timing requirement tHd:Sta in the I2C specification for a repeated START bit. This is used to hold\n      the clock until the Hold Time for the repeated Start Bit has been satisfied.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>RSVD2</name>
               <description>Reserved</description>
               <addressOffset>0x1C</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>COMPL_u32</name>
               <description>Completion Register</description>
               <addressOffset>0x20</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>DTEN</name>
                     <description>When DTEN is asserted ('1'), Device Time-out checking is enabled. When DTEN is not asserted ('0'), Device Time-out checking is disabled.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MCEN</name>
                     <description>When MCEN is asserted ('1'), Master Cumulative Time-Out checking is enabled. When MCEN is not asserted ('0'), Master Cumulative Time-Out checking is disabled.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SCEN</name>
                     <description>When SCEN is asserted ('1'), Slave Cumulative Time-Out checking is enabled. When SCEN is not asserted ('0'), Slave Cumulative Time-Out checking is disabled.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BIDEN</name>
                     <description>When BIDEN is asserted ('1'), Bus Idle Detect Time-Out checking is enabled. When BIDEN is not asserted ('0'), Bus Idle Detect Time-Out checking is disabled.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TIMERR</name>
                     <description>The Time-out Error Detected bit (TIMERR) is asserted ('1') whenever any of the enabled time-out error detect status bits (CHDH, CHDL, SCTO, MCTO and DTO) are asserted.</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DTO</name>
                     <description>DTO is the Device Time-out bit. (R/WC)</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MCTO</name>
                     <description>MCTO is the Master Cumulative Time-out bit. (R/WC)</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SCTO</name>
                     <description>SCTO is the Slave Cumulative Time-out bit(R/WC)</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CHDL</name>
                     <description>CHDL is the clock high time-out detect bit(R/WC)</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CHDH</name>
                     <description>CHDH is the bus idle time-out detect bit(R/WC)</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BER</name>
                     <description>If this bit is 1, the BER bit in the Status register was set while either the Slave state machine or the Master state machine was not in the Idle state.(R/WC)</description>
                     <bitOffset>13</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>LAB</name>
                     <description>If this bit is 1, the LAB bit in the Status register was set while either the Slave state machine or the Master state machine was not in the Idle state.(R/WC)</description>
                     <bitOffset>14</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SNAKR</name>
                     <description>If this bit is 1, the Slave state machine sent a NACK to the transmitting Master while the Slave was receiving data from the SMBus interface.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>STR</name>
                     <description>0: Slave has just finished the receive phase of a transaction. \n                1: Slave has just finished the transmit phase of a transaction.</description>
                     <bitOffset>17</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SPROT</name>
                     <description>If this bit is 1, the WriteCount[7:0] counter in the Slave state machine either counted down to 0 before the Master sent a NACK signal, or the Slave received a NACK signal before the counter reached 0.</description>
                     <bitOffset>19</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>REP_RD</name>
                     <description>If this bit is 1, the Slave State Machine stopped because it detected a Repeat Start bit, with bit[0] of the byte containing the slave address equal to 1, indicating that the Master requested a Read operation.</description>
                     <bitOffset>20</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>REP_WR</name>
                     <description>If this bit is 1, the Slave State Machine stopped because it detected a Repeat Start bit, with bit[0] of the byte containing the slave address equal to 0, indicating that the Master requested a Write operation.</description>
                     <bitOffset>21</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MNAKX</name>
                     <description>If this bit is 1, the Master state machine received a NACK from the receiving Slave while the Master was transmitting data over the SMBus interface. (R/WC)</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MTR</name>
                     <description>0: Master has just finished the receive phase of a transaction. \n                1: Master has just finished the transmit phase of a transaction.</description>
                     <bitOffset>25</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>IDLE</name>
                     <description>This bit is set when the I2C bus becomes idle (on the rising edge of nBB). (R/WC)</description>
                     <bitOffset>29</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MDONE</name>
                     <description>If this bit is 1, Master State machine completed operation and returned to the Idle state. It is cleared when written with a 1. Writes of a 0 have no effect. (R/WC)</description>
                     <bitOffset>30</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SDONE</name>
                     <description>If this bit is 1, Slave State machine completed operation and returned to the Idle state. It is cleared when written with a 1. Writes of a 0 have no effect.(R/WC)</description>
                     <bitOffset>31</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>2</dim>
               <dimIncrement>2</dimIncrement>
               <name>COMPL_u16[%s]</name>
               <description>Completion Register</description>
               <addressOffset>0x20</addressOffset>
               <size>16</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>DTEN</name>
                     <description>When DTEN is asserted ('1'), Device Time-out checking is enabled. When DTEN is not asserted ('0'), Device Time-out checking is disabled.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MCEN</name>
                     <description>When MCEN is asserted ('1'), Master Cumulative Time-Out checking is enabled. When MCEN is not asserted ('0'), Master Cumulative Time-Out checking is disabled.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SCEN</name>
                     <description>When SCEN is asserted ('1'), Slave Cumulative Time-Out checking is enabled. When SCEN is not asserted ('0'), Slave Cumulative Time-Out checking is disabled.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BIDEN</name>
                     <description>When BIDEN is asserted ('1'), Bus Idle Detect Time-Out checking is enabled. When BIDEN is not asserted ('0'), Bus Idle Detect Time-Out checking is disabled.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TIMERR</name>
                     <description>The Time-out Error Detected bit (TIMERR) is asserted ('1') whenever any of the enabled time-out error detect status bits (CHDH, CHDL, SCTO, MCTO and DTO) are asserted.</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DTO</name>
                     <description>DTO is the Device Time-out bit. (R/WC)</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MCTO</name>
                     <description>MCTO is the Master Cumulative Time-out bit. (R/WC)</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SCTO</name>
                     <description>SCTO is the Slave Cumulative Time-out bit(R/WC)</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CHDL</name>
                     <description>CHDL is the clock high time-out detect bit(R/WC)</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CHDH</name>
                     <description>CHDH is the bus idle time-out detect bit(R/WC)</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BER</name>
                     <description>If this bit is 1, the BER bit in the Status register was set while either the Slave state machine or the Master state machine was not in the Idle state.(R/WC)</description>
                     <bitOffset>13</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>LAB</name>
                     <description>If this bit is 1, the LAB bit in the Status register was set while either the Slave state machine or the Master state machine was not in the Idle state.(R/WC)</description>
                     <bitOffset>14</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SNAKR</name>
                     <description>If this bit is 1, the Slave state machine sent a NACK to the transmitting Master while the Slave was receiving data from the SMBus interface.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>STR</name>
                     <description>0: Slave has just finished the receive phase of a transaction. \n                1: Slave has just finished the transmit phase of a transaction.</description>
                     <bitOffset>17</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SPROT</name>
                     <description>If this bit is 1, the WriteCount[7:0] counter in the Slave state machine either counted down to 0 before the Master sent a NACK signal, or the Slave received a NACK signal before the counter reached 0.</description>
                     <bitOffset>19</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>REP_RD</name>
                     <description>If this bit is 1, the Slave State Machine stopped because it detected a Repeat Start bit, with bit[0] of the byte containing the slave address equal to 1, indicating that the Master requested a Read operation.</description>
                     <bitOffset>20</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>REP_WR</name>
                     <description>If this bit is 1, the Slave State Machine stopped because it detected a Repeat Start bit, with bit[0] of the byte containing the slave address equal to 0, indicating that the Master requested a Write operation.</description>
                     <bitOffset>21</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MNAKX</name>
                     <description>If this bit is 1, the Master state machine received a NACK from the receiving Slave while the Master was transmitting data over the SMBus interface. (R/WC)</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MTR</name>
                     <description>0: Master has just finished the receive phase of a transaction. \n                1: Master has just finished the transmit phase of a transaction.</description>
                     <bitOffset>25</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>IDLE</name>
                     <description>This bit is set when the I2C bus becomes idle (on the rising edge of nBB). (R/WC)</description>
                     <bitOffset>29</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MDONE</name>
                     <description>If this bit is 1, Master State machine completed operation and returned to the Idle state. It is cleared when written with a 1. Writes of a 0 have no effect. (R/WC)</description>
                     <bitOffset>30</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SDONE</name>
                     <description>If this bit is 1, Slave State machine completed operation and returned to the Idle state. It is cleared when written with a 1. Writes of a 0 have no effect.(R/WC)</description>
                     <bitOffset>31</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>4</dim>
               <dimIncrement>1</dimIncrement>
               <name>COMPL_u08[%s]</name>
               <description>Completion Register</description>
               <addressOffset>0x20</addressOffset>
               <size>8</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>DTEN</name>
                     <description>When DTEN is asserted ('1'), Device Time-out checking is enabled. When DTEN is not asserted ('0'), Device Time-out checking is disabled.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MCEN</name>
                     <description>When MCEN is asserted ('1'), Master Cumulative Time-Out checking is enabled. When MCEN is not asserted ('0'), Master Cumulative Time-Out checking is disabled.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SCEN</name>
                     <description>When SCEN is asserted ('1'), Slave Cumulative Time-Out checking is enabled. When SCEN is not asserted ('0'), Slave Cumulative Time-Out checking is disabled.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BIDEN</name>
                     <description>When BIDEN is asserted ('1'), Bus Idle Detect Time-Out checking is enabled. When BIDEN is not asserted ('0'), Bus Idle Detect Time-Out checking is disabled.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TIMERR</name>
                     <description>The Time-out Error Detected bit (TIMERR) is asserted ('1') whenever any of the enabled time-out error detect status bits (CHDH, CHDL, SCTO, MCTO and DTO) are asserted.</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DTO</name>
                     <description>DTO is the Device Time-out bit. (R/WC)</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MCTO</name>
                     <description>MCTO is the Master Cumulative Time-out bit. (R/WC)</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SCTO</name>
                     <description>SCTO is the Slave Cumulative Time-out bit(R/WC)</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CHDL</name>
                     <description>CHDL is the clock high time-out detect bit(R/WC)</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CHDH</name>
                     <description>CHDH is the bus idle time-out detect bit(R/WC)</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BER</name>
                     <description>If this bit is 1, the BER bit in the Status register was set while either the Slave state machine or the Master state machine was not in the Idle state.(R/WC)</description>
                     <bitOffset>13</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>LAB</name>
                     <description>If this bit is 1, the LAB bit in the Status register was set while either the Slave state machine or the Master state machine was not in the Idle state.(R/WC)</description>
                     <bitOffset>14</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SNAKR</name>
                     <description>If this bit is 1, the Slave state machine sent a NACK to the transmitting Master while the Slave was receiving data from the SMBus interface.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>STR</name>
                     <description>0: Slave has just finished the receive phase of a transaction. \n                1: Slave has just finished the transmit phase of a transaction.</description>
                     <bitOffset>17</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SPROT</name>
                     <description>If this bit is 1, the WriteCount[7:0] counter in the Slave state machine either counted down to 0 before the Master sent a NACK signal, or the Slave received a NACK signal before the counter reached 0.</description>
                     <bitOffset>19</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>REP_RD</name>
                     <description>If this bit is 1, the Slave State Machine stopped because it detected a Repeat Start bit, with bit[0] of the byte containing the slave address equal to 1, indicating that the Master requested a Read operation.</description>
                     <bitOffset>20</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>REP_WR</name>
                     <description>If this bit is 1, the Slave State Machine stopped because it detected a Repeat Start bit, with bit[0] of the byte containing the slave address equal to 0, indicating that the Master requested a Write operation.</description>
                     <bitOffset>21</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MNAKX</name>
                     <description>If this bit is 1, the Master state machine received a NACK from the receiving Slave while the Master was transmitting data over the SMBus interface. (R/WC)</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MTR</name>
                     <description>0: Master has just finished the receive phase of a transaction. \n                1: Master has just finished the transmit phase of a transaction.</description>
                     <bitOffset>25</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>IDLE</name>
                     <description>This bit is set when the I2C bus becomes idle (on the rising edge of nBB). (R/WC)</description>
                     <bitOffset>29</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MDONE</name>
                     <description>If this bit is 1, Master State machine completed operation and returned to the Idle state. It is cleared when written with a 1. Writes of a 0 have no effect. (R/WC)</description>
                     <bitOffset>30</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SDONE</name>
                     <description>If this bit is 1, Slave State machine completed operation and returned to the Idle state. It is cleared when written with a 1. Writes of a 0 have no effect.(R/WC)</description>
                     <bitOffset>31</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>IDLSC</name>
               <description>Idle Scaling Register</description>
               <addressOffset>0x24</addressOffset>
               <size>32</size>
               <resetValue>0x01FC01ED</resetValue>
               <fields>
                  <field>
                     <name>FAIR_BUS_IDL_MIN</name>
                     <description>This field defines the number of ticks of the baud clock required to satisfy the fairness protocol. The default value for this field sets the idle window to 31us, which is the appropriate value for a 100 KHz bus</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>12</bitWidth>
                  </field>
                  <field>
                     <name>FAIR_IDL_DLY</name>
                     <description>This field defines the number of ticks of the baud clock required to program the delay. The default value for this field sets the delay period to 32us, which is the appropriate value for a 100 KHz bus</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>12</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CFG_u32</name>
               <description>Configuration Register</description>
               <addressOffset>0x28</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>PORT_SEL</name>
                     <description>The PORT SEL [3:0] bits determine which one of 16 possible bus ports apply to the active 2-wire SDAT and SCLK bus pair.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>TCEN</name>
                     <description>When the Timing Check Enable bit (TCEN) is asserted ('1'), Bus Time-Outs are enabled</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SLOW_CLK</name>
                     <description>When this bit is 1, the base period for the Bus Clock Register is multiplied by 4, and thus the frequency is divided by 4.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TEST</name>
                     <description>Must be always written with 0.</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PECEN</name>
                     <description>When the PEC Enable bit (PECEN) is asserted ('1'), Hardware PEC Support is enabled</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FEN</name>
                     <description>Input filtering enable. Input filtering is required by the I2C specification if external filtering is not available.\n      1=Input filtering is enabled; 0=Input filtering is disabled.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RST</name>
                     <description>When RESET is asserted ('1'), all logic and registers except for the RESET bit itself are initialized to the power-on default state.</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>EN</name>
                     <description>When ENAB (Enable) is not asserted ('0') (default), the SMB Controller Core is disabled and in the lowest power consumption state (Disabled State).\n                The ENAB bit must be asserted ('1') for normal operation.</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DSA</name>
                     <description>0: Slave Address I2C Compatibility Mode (default). 1: SMBus Address Decode Mode</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FAIR</name>
                     <description>If this bit is 1, the MCTP Fairness protocol is in effect.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TEST0</name>
                     <description>Must be always written with 0.</description>
                     <bitOffset>13</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GC_DIS</name>
                     <description>This is the General Call Disable bit.\n                0: the response to the General Call address as a slave is enabled\n                1: the response to the General Call address as a slave is disabled.</description>
                     <bitOffset>14</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FLUSH_SXBUF</name>
                     <description>A write of a 1 to this bit forces the SMBus Slave Transmit Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FLUSH_SRBUF</name>
                     <description>A write of a 1 to this bit forces the SMBus Slave Receive Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit.</description>
                     <bitOffset>17</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FLUSH_MXBUF</name>
                     <description>A write of a 1 to this bit forces the SMBus Master Transmit Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit.</description>
                     <bitOffset>18</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FLUSH_MRBUF</name>
                     <description>A write of a 1 to this bit forces the SMBus Master Receive Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit.</description>
                     <bitOffset>19</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>EN_AAS</name>
                     <description>0: Disable the AAS, 1: Enable the AAS Interrupt</description>
                     <bitOffset>28</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ENIDI</name>
                     <description>If this bit is 1, the Idle interrupt is enabled. If this bit is 0, the Idle interrupt is disabled.</description>
                     <bitOffset>29</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ENMI</name>
                     <description>If this bit is 1, the Master Done interrupt is enabled. If this bit is 0, the Master Done interrupt is disabled.</description>
                     <bitOffset>30</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ENSI</name>
                     <description>If this bit is 1, the Slave Done interrupt is enabled. If this bit is 0, the Slave Done interrupt is disabled</description>
                     <bitOffset>31</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>2</dim>
               <dimIncrement>2</dimIncrement>
               <name>CFG_u16[%s]</name>
               <description>Configuration Register</description>
               <addressOffset>0x28</addressOffset>
               <size>16</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>PORT_SEL</name>
                     <description>The PORT SEL [3:0] bits determine which one of 16 possible bus ports apply to the active 2-wire SDAT and SCLK bus pair.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>TCEN</name>
                     <description>When the Timing Check Enable bit (TCEN) is asserted ('1'), Bus Time-Outs are enabled</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SLOW_CLK</name>
                     <description>When this bit is 1, the base period for the Bus Clock Register is multiplied by 4, and thus the frequency is divided by 4.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TEST</name>
                     <description>Must be always written with 0.</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PECEN</name>
                     <description>When the PEC Enable bit (PECEN) is asserted ('1'), Hardware PEC Support is enabled</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FEN</name>
                     <description>Input filtering enable. Input filtering is required by the I2C specification if external filtering is not available.\n      1=Input filtering is enabled; 0=Input filtering is disabled.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RST</name>
                     <description>When RESET is asserted ('1'), all logic and registers except for the RESET bit itself are initialized to the power-on default state.</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>EN</name>
                     <description>When ENAB (Enable) is not asserted ('0') (default), the SMB Controller Core is disabled and in the lowest power consumption state (Disabled State).\n                The ENAB bit must be asserted ('1') for normal operation.</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DSA</name>
                     <description>0: Slave Address I2C Compatibility Mode (default). 1: SMBus Address Decode Mode</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FAIR</name>
                     <description>If this bit is 1, the MCTP Fairness protocol is in effect.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TEST0</name>
                     <description>Must be always written with 0.</description>
                     <bitOffset>13</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GC_DIS</name>
                     <description>This is the General Call Disable bit.\n                0: the response to the General Call address as a slave is enabled\n                1: the response to the General Call address as a slave is disabled.</description>
                     <bitOffset>14</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FLUSH_SXBUF</name>
                     <description>A write of a 1 to this bit forces the SMBus Slave Transmit Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FLUSH_SRBUF</name>
                     <description>A write of a 1 to this bit forces the SMBus Slave Receive Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit.</description>
                     <bitOffset>17</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FLUSH_MXBUF</name>
                     <description>A write of a 1 to this bit forces the SMBus Master Transmit Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit.</description>
                     <bitOffset>18</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FLUSH_MRBUF</name>
                     <description>A write of a 1 to this bit forces the SMBus Master Receive Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit.</description>
                     <bitOffset>19</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>EN_AAS</name>
                     <description>0: Disable the AAS, 1: Enable the AAS Interrupt</description>
                     <bitOffset>28</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ENIDI</name>
                     <description>If this bit is 1, the Idle interrupt is enabled. If this bit is 0, the Idle interrupt is disabled.</description>
                     <bitOffset>29</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ENMI</name>
                     <description>If this bit is 1, the Master Done interrupt is enabled. If this bit is 0, the Master Done interrupt is disabled.</description>
                     <bitOffset>30</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ENSI</name>
                     <description>If this bit is 1, the Slave Done interrupt is enabled. If this bit is 0, the Slave Done interrupt is disabled</description>
                     <bitOffset>31</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>4</dim>
               <dimIncrement>1</dimIncrement>
               <name>CFG_u08[%s]</name>
               <description>Configuration Register</description>
               <addressOffset>0x28</addressOffset>
               <size>8</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>PORT_SEL</name>
                     <description>The PORT SEL [3:0] bits determine which one of 16 possible bus ports apply to the active 2-wire SDAT and SCLK bus pair.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>TCEN</name>
                     <description>When the Timing Check Enable bit (TCEN) is asserted ('1'), Bus Time-Outs are enabled</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SLOW_CLK</name>
                     <description>When this bit is 1, the base period for the Bus Clock Register is multiplied by 4, and thus the frequency is divided by 4.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TEST</name>
                     <description>Must be always written with 0.</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PECEN</name>
                     <description>When the PEC Enable bit (PECEN) is asserted ('1'), Hardware PEC Support is enabled</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FEN</name>
                     <description>Input filtering enable. Input filtering is required by the I2C specification if external filtering is not available.\n      1=Input filtering is enabled; 0=Input filtering is disabled.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RST</name>
                     <description>When RESET is asserted ('1'), all logic and registers except for the RESET bit itself are initialized to the power-on default state.</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>EN</name>
                     <description>When ENAB (Enable) is not asserted ('0') (default), the SMB Controller Core is disabled and in the lowest power consumption state (Disabled State).\n                The ENAB bit must be asserted ('1') for normal operation.</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DSA</name>
                     <description>0: Slave Address I2C Compatibility Mode (default). 1: SMBus Address Decode Mode</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FAIR</name>
                     <description>If this bit is 1, the MCTP Fairness protocol is in effect.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TEST0</name>
                     <description>Must be always written with 0.</description>
                     <bitOffset>13</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GC_DIS</name>
                     <description>This is the General Call Disable bit.\n                0: the response to the General Call address as a slave is enabled\n                1: the response to the General Call address as a slave is disabled.</description>
                     <bitOffset>14</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FLUSH_SXBUF</name>
                     <description>A write of a 1 to this bit forces the SMBus Slave Transmit Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FLUSH_SRBUF</name>
                     <description>A write of a 1 to this bit forces the SMBus Slave Receive Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit.</description>
                     <bitOffset>17</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FLUSH_MXBUF</name>
                     <description>A write of a 1 to this bit forces the SMBus Master Transmit Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit.</description>
                     <bitOffset>18</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FLUSH_MRBUF</name>
                     <description>A write of a 1 to this bit forces the SMBus Master Receive Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit.</description>
                     <bitOffset>19</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>EN_AAS</name>
                     <description>0: Disable the AAS, 1: Enable the AAS Interrupt</description>
                     <bitOffset>28</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ENIDI</name>
                     <description>If this bit is 1, the Idle interrupt is enabled. If this bit is 0, the Idle interrupt is disabled.</description>
                     <bitOffset>29</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ENMI</name>
                     <description>If this bit is 1, the Master Done interrupt is enabled. If this bit is 0, the Master Done interrupt is disabled.</description>
                     <bitOffset>30</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ENSI</name>
                     <description>If this bit is 1, the Slave Done interrupt is enabled. If this bit is 0, the Slave Done interrupt is disabled</description>
                     <bitOffset>31</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BUSCLK</name>
               <description>Bus Clock Register</description>
               <addressOffset>0x2C</addressOffset>
               <size>32</size>
               <resetValue>0x00004F4F</resetValue>
               <fields>
                  <field>
                     <name>LOW_PER</name>
                     <description>This field defines the number of I2C Baud Clock periods that make up the low phase of the I2C/SMBus bus clock.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>HIGH_PER</name>
                     <description>This field defines the number of I2C Baud Clock periods that make up the high phase of the I2C/SMBus bus clock.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BLKID</name>
               <description>Block ID Register</description>
               <addressOffset>0x30</addressOffset>
               <size>8</size>
               <access>read-only</access>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>ID</name>
                     <description>Block ID.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BLKREV</name>
               <description>Revision Register</description>
               <addressOffset>0x34</addressOffset>
               <size>8</size>
               <access>read-only</access>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>REV</name>
                     <description>Block Revision Number</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BBCTRL</name>
               <description>Bit-Bang Control Register</description>
               <addressOffset>0x38</addressOffset>
               <size>32</size>
               <resetValue>0x00000060</resetValue>
               <fields>
                  <field>
                     <name>BBEN</name>
                     <description>Bit-Bang Mode Enable. 0 - Bit Bang Mode Disabled. 1 - Bit Bang Mode Enabled</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CLDIR</name>
                     <description>Bit-Bang Clock Direction. The CLDIR bit controls the direction of SCLK. 0 - Input, 1 - Output</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DADIR</name>
                     <description>Bit-Bang Data Direction. The DADIR bit controls the direction of SDAT. 0 - Input. 1 - Output</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BBCLK</name>
                     <description>Bit-Bang Clock. The BBCLK bit controls the state of SCLK when BBEN = and CLDIR = '1'</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BBDAT</name>
                     <description>Bit-Bang Data. The BBDAT bit controls the state of SDAT when BBEN = and DADIR = '1'</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BBCLKI</name>
                     <description>Bit-Bang Clock In. The BBCLKI bit always returns the state of SCLK.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BBDATI</name>
                     <description>Bit-Bang Data In. The BBDATI bit always returns the state of SDAT</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>TEST</name>
               <description>Test</description>
               <addressOffset>0x3C</addressOffset>
               <size>8</size>
               <access>read-only</access>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>TEST</name>
                     <description>This register must not be written, or undesirable results may occur.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>DATATM</name>
               <description>Data Timing Register</description>
               <addressOffset>0x40</addressOffset>
               <size>32</size>
               <resetValue>0x0C4D5006</resetValue>
               <fields>
                  <field>
                     <name>DATA_HOLD</name>
                     <description>The Data Hold [7:0] timer determines the SDAT hold time following SCLK driven low.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>RESTART_SETUP</name>
                     <description>The Restart Setup [7:0] timer determines the SDAT setup time from the rising edge of SCLK for a repeated START condition.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>STOP_SETUP</name>
                     <description>The Stop Setup [7:0] timer determines the SDAT setup time from the rising edge of SCLK for a STOP condition.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>FIRST_START_HOLD</name>
                     <description>This field determines the SCL hold time following SDA driven low during the first START bit in a transfer. It is the parameter\n      THD:STA in the I2C Specification for an initial START bit. Repeated START hold time is determined by the Repeated START Hold Time Register.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>TMOUTSC</name>
               <description>Time-Out Scaling Register</description>
               <addressOffset>0x44</addressOffset>
               <size>32</size>
               <resetValue>0x4B9CC2C7</resetValue>
               <fields>
                  <field>
                     <name>CLK_HIGH_TIM_OUT</name>
                     <description>Clock High time out period = Clock High Time-Out [7:0] x Baud_Clock_Period x 2</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>SLV_CUM_TIM_OUT</name>
                     <description>Slave Cumulative Time-Out duration = Slave Cum Time-Out [7:0] x Baud_Clock_Period x 1024</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>MAST_CUM_TIM_OUT</name>
                     <description>Master Cumulative Time-Out duration = Master Cum Time-Out [7:0] x Baud_Clock_Period x 512</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>BUS_IDLE_MIN</name>
                     <description>Bus Idle Minimum time = Bus Idle Min [7:0] x Baud_Clock_Period</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SLV_TXB</name>
               <description>SMBus Slave Transmit Buffer Register</description>
               <addressOffset>0x48</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>STXB</name>
                     <description>STXB</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SLV_RXB</name>
               <description>SMBus Slave Receive Buffer Register</description>
               <addressOffset>0x4C</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SRXB</name>
                     <description>SRXB</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MTR_TXB</name>
               <description>SMBus Master Transmit Buffer Register</description>
               <addressOffset>0x50</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>MTXB</name>
                     <description>MTXB</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MTR_RXB</name>
               <description>SMBus Master Receive Buffer Register</description>
               <addressOffset>0x54</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>MRXB</name>
                     <description>MRXB</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>WAKE_STS</name>
               <description>WAKE STATUS Register</description>
               <addressOffset>0x60</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>START_BIT_DET</name>
                     <description>This bit is set to '1' when a START bit is detected while the controller is enabled. This bit is cleared to '0' when\n      written with a '1'. Writes of '0' have no effect. (R/WC)</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>WAKE_EN</name>
               <description>WAKE ENABLE Register</description>
               <addressOffset>0x64</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>START_DET_INT_EN</name>
                     <description>Enable Start Bit Detection Interrupt. The Start Bit Detection Interrupt is wake-capable.\n      1=Start Bit Detection Interrupt enabled; 0=Start Bit Detection Interrupt disabled</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral derivedFrom="SMB0">
         <name>SMB1</name>
         <baseAddress>0x40004400</baseAddress>
         <interrupt>
            <name>SMB1</name>
            <value>21</value>
         </interrupt>
      </peripheral>
      <peripheral derivedFrom="SMB0">
         <name>SMB2</name>
         <baseAddress>0x40004800</baseAddress>
         <interrupt>
            <name>SMB2</name>
            <value>22</value>
         </interrupt>
      </peripheral>
      <peripheral derivedFrom="SMB0">
         <name>SMB3</name>
         <baseAddress>0x40004C00</baseAddress>
         <interrupt>
            <name>SMB3</name>
            <value>23</value>
         </interrupt>
      </peripheral>
      <peripheral>
         <name>GP_SPI0</name>
         <version>621.0</version>
         <description>The General Purpose Serial Peripheral Interface (GP-SPI) may be used\n       to communicate with various peripheral devices, e.g., EEPROMS, DACs, ADCs, that use a\n         standard Serial Peripheral Interface.</description>
         <groupName>GP_SPI</groupName>
         <prependToName>GP_SPI_</prependToName>
         <baseAddress>0x40009400</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x1C</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>TX0</name>
            <value>92</value>
         </interrupt>
         <interrupt>
            <name>RX0</name>
            <value>93</value>
         </interrupt>
         <registers>
            <register>
               <name>ENABLE</name>
               <description>[0:0]  1=Enabled. The device is fully operational\n          0=Disabled. Clocks are gated to conserve power and the SPDOUT and SPI_CLK signals are set to their inactive state</description>
               <addressOffset>0x0</addressOffset>
               <size>32</size>
               <resetValue>0x0000000F</resetValue>
            </register>
            <register>
               <name>CTRL</name>
               <description>SPI Control</description>
               <addressOffset>0x4</addressOffset>
               <size>32</size>
               <resetValue>0x00000002</resetValue>
               <fields>
                  <field>
                     <name>LSBF</name>
                     <description>Least Significant Bit First\n             1= The data is transferred in LSB-first order.\n        0= The data is transferred in MSB-first order. (default)</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BIOEN</name>
                     <description>Bidirectional Output Enable control.\n             1=The SPDOUT_Direction signal configures the SPDOUT signal as an output.\n         0=The SPDOUT_Direction signal configures the SPDOUT signal as an input.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SPDIN_SEL</name>
                     <description>[3:2] 1xb=SPDIN1 and SPDIN2. Select this option for Dual Mode\n        [3:2] 01b=SPDIN2 only. Select this option for Half Duplex\n                   [3:2] 00b=SPDIN1 only. Select this option for Full Duplex</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>SOFT_RST</name>
                     <description>Soft Reset is a self-clearing bit. Writing zero to this bit has no effect. \n      Writing a one to this bit resets the entire SPI Interface, including all counters and registers back to their initial state.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>AUTO_RD</name>
                     <description>Auto Read Enable.\n             1=A read of the SPI RX_DATA Register will clear both the RXBF status bit and the TXBE status bit\n          0=A read of the SPI RX_DATA Register will clear the RXBF status bit. The TXBE status bit will not be modified</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CE</name>
                     <description>SPI Chip Select Enable.\n                 1= SPI_CS# output signal is asserted, i.e., driven to logic '0' \n                    0= SPI_CS# output signal is deasserted, i.e., driven to logic '1'</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>STS</name>
               <description>SPI Status</description>
               <addressOffset>0x8</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>TXBE</name>
                     <description>1=TX_Data buffer is empty, 0=TX_Data buffer is not empty</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RXBF</name>
                     <description>1=RX_Data buffer is full, 0=RX_Data buffer is not full</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ACTIVE</name>
                     <description>ACTIVE status</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>TX_DAT</name>
               <description>[7:0]  A write to this register when the \n       Tx_Data buffer is empty (TXBE in the SPI Status Register is '1') initiates a SPI transaction.</description>
               <addressOffset>0xC</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>RX_DAT</name>
               <description>[7:0] This register is used to read the value returned by the external SPI device.</description>
               <addressOffset>0x10</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>CLK_CTRL</name>
               <description>SPI Clock Control. This register should not be changed during an active SPI transaction.</description>
               <addressOffset>0x14</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>TCLKPH</name>
                     <description>1=Valid data is clocked out on the first SPI_CLK edge on SPDOUT signal. The slave device should sample this data on the second and \n       following even SPI_CLK edges (i.e., sample data on falling edge) 0=Valid data is clocked out on the SPDOUT signal prior to the first SPI_CLK edge. \n       The slave device should sample this data on the first and following odd SPI_CLK edges (i.e., sample data on rising edge)</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RCLKPH</name>
                     <description>1=Valid data on SPDIN signal is expected after the first SPI_CLK edge. This data is sampled on the second and \n       following even SPI_CLK edges (i.e., sample data on falling edge) 0=Valid data is expected on the SPDIN signal on the first SPI_CLK edge. \n       This data is sampled on the first and following odd SPI_-CLK edges (i.e., sample data on rising edge)</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CLKPOL</name>
                     <description>1=The SPI_CLK signal is high when the interface is idle and the first clock edge is a falling edge\n            0=The SPI_CLK is low when the interface is idle and the first clock edge is a rising edge</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CLKSRC</name>
                     <description>1=2MHz, 0=48 MHz Ring Oscillator</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CLK_GEN</name>
               <description>[5:0] PRELOAD SPI Clock Generator Preload value.</description>
               <addressOffset>0x18</addressOffset>
               <size>32</size>
               <resetValue>0x00000002</resetValue>
               <fields>
                  <field>
                     <name>PRLD</name>
                     <description>SPI Clock Generator Preload Value</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>6</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral derivedFrom="GP_SPI0">
         <name>GP_SPI1</name>
         <baseAddress>0x40009480</baseAddress>
         <interrupt>
            <name>TX1</name>
            <value>94</value>
         </interrupt>
         <interrupt>
            <name>RX1</name>
            <value>95</value>
         </interrupt>
      </peripheral>
      <peripheral>
         <name>QMSPI</name>
         <version>1471.0</version>
         <description>The Quad SPI Master Controller may be used to communicate with various \n        peripheral devices that use a Serial Peripheral Interface, such as EEPROMS, DACs and ADCs.\n        The controller can be configured to support advanced SPI Flash devices with multi-phase access protocols.</description>
         <groupName>QMSPI</groupName>
         <prependToName>QMSPI_</prependToName>
         <baseAddress>0x40005400</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x44</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>QMSPI</name>
            <value>91</value>
         </interrupt>
         <registers>
            <register>
               <name>MODE</name>
               <description>QMSPI Mode Register</description>
               <addressOffset>0x0</addressOffset>
               <size>32</size>
               <resetValue>0x0000000F</resetValue>
               <fields>
                  <field>
                     <name>ACT</name>
                     <description>This bit is used to activate the QMSPI block.\n             1=Enabled. The block is fully operational\n           0=Disabled. Clocks are gated to conserve power and the output signals are set to their inactive state.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SOFT_RST</name>
                     <description>Writing this bit with a 1 will reset the Quad SPI block. It is self-clearing.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CPOL</name>
                     <description>Polarity of the SPI clock line when there are no transactions in process. 1=SPI Clock starts High; 0=SPI Clock starts Low.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CHPA_MOSI</name>
                     <description>Clock phase of the Master data out. Common SPI modes require this field to be programmed with the same value as CHPA_MISO in this register.\n         e.g. Mode 0: CPOL=0; CHPA_MISO=0; CHPA_MOSI=0; Mode 3: CPOL=1; CHPA_MISO=1; CHPA_MOSI=1. See datasheet for alternate mode settings.\n              If CPOL=1: 1=Data changes on the falling edge of the SPI clock; 0=Data changes on the rising edge of the SPI clock\n             If CPOL=0: 1=Data changes on the rising edge of the SPI clock; 0=Data changes on the falling edge of the SPI clock</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CHPA_MISO</name>
                     <description>Clock phase of the Master data in. Common SPI modes require this field to be programmed with the same value as CHPA_MOSI in this register.\n        e.g. Mode 0: CPOL=0; CHPA_MISO=0; CHPA_MOSI=0; Mode 3: CPOL=1; CHPA_MISO=1; CHPA_MOSI=1. See datasheet for alternate mode settings.\n           If CPOL=1: 1=Data are captured on the rising edge of the SPI clock; 0=Data are captured on the falling edge of the SPI clock\n                If CPOL=0: 1=Data are captured on the falling edge of the SPI clock; 0=Data are captured on the rising edge of the SPI clock</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CLK_DIV</name>
                     <description>The SPI clock divide in number of system clocks. A value of 1 divides the master clock by 1, a value of 255 divides the master clock by 255.\n       A value of 0 divides the master clock by 256.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>9</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CTRL</name>
               <description>QMSPI SPI Control</description>
               <addressOffset>0x4</addressOffset>
               <size>32</size>
               <resetValue>0x00000200</resetValue>
               <fields>
                  <field>
                     <name>TX_MODE</name>
                     <description>This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either \n            TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.\n                  3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>TX_TRANS_EN</name>
                     <description>This field bit selects the transmit function of the SPI interface.\n                3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used.\n                2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.\n               1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.\n                 0=Transmit is Disabled. Not data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>TX_DMA_EN</name>
                     <description>This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either\n        the interface reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.\n           1=DMA is enabled.and set to 1 Byte\n                  2=DMA is enabled and set to 2 Bytes\n                 3=DMA is enabled and set to 4 Bytes.\n          0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>RX_TRANS_EN</name>
                     <description>This bit enables the receive function of the SPI interface.\n             1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer\n             0=Receive is disabled</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RX_DMA_EN</name>
                     <description>This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO until either the interface\n          reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.\n         1=DMA is enabled.and set to 1 Byte\n                2=DMA is enabled and set to 2 Bytes\n              3=DMA is enabled and set to 4 Bytes\n              0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>CLOSE_TRANS_EN</name>
                     <description>This selects what action is taken at the end of a transfer. When the transaction closes, the Chip Select de-asserts, the SPI \n       interface returns to IDLE and the DMA interface terminates When Description Buffers are in use this bit must be set only on the Last Buffer.\n         1=The transaction is terminated\n                 0=The transaction is not terminated</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TRANS_UNITS</name>
                     <description>3=TRANSFER_LENGTH defined in units of 16-byte segments\n            2=TRANSFER_LENGTH defined in units of 4-byte segments\n              1=TRANSFER_LENGTH defined in units of bytes\n          0=TRANSFER_LENGTH defined in units of bits.</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>DESCR_BUFF_PTR</name>
                     <description>This field selects the first buffer used if Description Buffers are enabled.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>DESCR_BUFF_EN</name>
                     <description>This enables the Description Buffers to be used.\n                1=Description Buffers in use. The first buffer is defined in DESCRIPTION_BUFFER_POINTER\n          0=Description Buffers disabled.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TRANS_LEN</name>
                     <description>The length of the SPI transfer. The count is in bytes or bits, depending on the value of TRANS_LEN_BITS.\n          A value of 0 means an infinite length transfer.</description>
                     <bitOffset>17</bitOffset>
                     <bitWidth>15</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EXE</name>
               <description>QMSPI Execute Register</description>
               <addressOffset>0x8</addressOffset>
               <size>32</size>
               <resetValue>0x00000001</resetValue>
               <fields>
                  <field>
                     <name>START</name>
                     <description>Writing a 1 to this bit will start the SPI transfer. Writing a 0 to this bit has no effect. This bit is self-clearing.\n          This bit must not be set to 1 if the field STOP in this register is set to 1.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>STOP</name>
                     <description>Writing a 1 to this bit will stop any transfer in progress at the next byte boundary. Writing a 0 to this bit has no effect.\n       This bit is self clearing. This bit must not be set to 1 if the field START in this register is set to 1.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CLR_DAT_BUFF</name>
                     <description>Writing a 1 to this bit will clear out the Transmit and Receive FIFOs.\n       Any data stored in the FIFOs is discarded and all count fields are reset.\n            Writing a 0 to this bit has no effect. This bit is self clearing.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>IFCTRL</name>
               <description>QMSPI Interface Control Register</description>
               <addressOffset>0xC</addressOffset>
               <size>32</size>
               <resetValue>0x00000025</resetValue>
               <fields>
                  <field>
                     <name>WR_PRCT_OUT_VAL</name>
                     <description>This bit sets the value on the WRITE PROTECT SPI Output Port if it is driven.\n       1=WRITE PROTECT is driven to 1; 0=WRITE PROTECT is driven to 0</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>WR_PRCT_OUT_EN</name>
                     <description>1=WRITE PROTECT SPI Output Port is driven\n       0=WRITE PROTECT SPI Output Port is not driven</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>HLD_OUT_VAL</name>
                     <description>This bit sets the value on the HOLD SPI Output Port if it is driven.\n        1=HOLD is driven to 1; 0=HOLD is driven to 0.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>HLD_OUT_EN</name>
                     <description>1=HOLD SPI Output Port is driven\n           0=HOLD SPI Output Port is not driven.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PD_ON_NOT_SEL</name>
                     <description>1=Enable pull-down resistors on Receive pins while the SPI Chip Select signal is not asserted\n       0=No pull-down resistors enabled on Receive pins</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PU_ON_NOTSEL</name>
                     <description>1=Enable pull-up resistors on Receive pins while the SPI Chip Select signal is not asserted\n       0=No pull-up resistors enabled on Receive pins.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PD_ON_NOTDRIVEN</name>
                     <description>1=Enable pull-down resistors on Transmit pins while the pins are not driven\n                 0=No pull-down resistors enabled ion Transmit pins.</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PU_ON_NOTDRIVEN</name>
                     <description>1=Enable pull-up resistors on Transmit pins while the pins are not driven\n          0=No pull-up resistors enabled ion Transmit pins.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>STS</name>
               <description>QMSPI Status Register</description>
               <addressOffset>0x10</addressOffset>
               <size>32</size>
               <resetValue>0x00002000</resetValue>
               <fields>
                  <field>
                     <name>TRANS_COMPL</name>
                     <description>In Manual Mode (neither DMA nor Description Buffers are enabled), this bit will be set to 1 when the transfer matches TRANSFER_LENGTH.\n      If DMA Mode is enabled, this bit will be set to 1 when DMA_COMPLETE is set to 1. In Description Buffer Mode, this bit will be set to 1 only when the Last Buffer completes its transfer.\n      In all cases, this bit will be set to 1 if the STOP bit is set to 1 and the controller has completed the current 8 bits being copied.\n               1=Transfer completed; 0=Transfer not complete.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DMA_COMPL</name>
                     <description>This field has no meaning if DMA is not enabled. This bit will be set to 1 when the DMA controller asserts the DONE signal to the SPI controller.\n      This occurs either when the SPI controller has closed the DMA transfer, or the DMA channel has completed its count. If both Transmit and Receive DMA transfers are\n              active, then this bit will only assert after both have completed. If CLOSE_TRANSFER_ENABLE is enabled, DMA_COMPLETE and TRANSFER_COMPLETE will be asserted simultaneously.\n          This status is not inhibited by the description buffers, so it can fire on all valid description buffers while operating in that mode.\n                 1=DMA completed; 0=DMA not completed.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TX_BUFF_ERR</name>
                     <description>1=Overflow error occurred (attempt to write to a full Transmit Buffer)\n             0=No overflow occurred.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RX_BUFF_ERR</name>
                     <description>1=Underflow error occurred (attempt to read from an empty Receive Buffer)\n         0=No underflow occurred.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PRGM_ERR</name>
                     <description>This bit if a programming error is detected.\n             1=Programming Error detected; 0=No programming error detected.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TX_BUFF_FULL</name>
                     <description>1=The Transmit Buffer is full\n                   0=The Transmit Buffer is not full.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TX_BUFF_EMP</name>
                     <description>1=The Transmit Buffer is empty\n            0=The Transmit Buffer is not empty.</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TX_BUFF_REQ</name>
                     <description>This status is asserted if the Transmit Buffer reaches a high water mark established by the TRANSMIT_BUFFER_TRIGGER field.\n              1=TRANSMIT_BUFFER_COUNT is less than or equal to TRANSMIT_BUFFER_TRIGGER; 0=TRANSMIT_BUFFER_COUNT is greater than TRANSMIT_BUFFER_TRIGGER.</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TX_BUFF_STALL</name>
                     <description>1=The SPI interface had been stalled due to a flow issue (an attempt by the interface to read from an empty Transmit Buffer)\n        0=No stalls occurred.</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RX_BUFF_FULL</name>
                     <description>1=The Receive Buffer is full\n               0=The Receive Buffer is not full.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RX_BUFF_EMP</name>
                     <description>1=The Receive Buffer is empty\n             0=The Receive Buffer is not empty.</description>
                     <bitOffset>13</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RX_BUFF_REQ</name>
                     <description>This status is asserted if the Receive Buffer reaches a high water mark established by the RECEIVE_BUFFER_TRIGGER field.\n             1=RECEIVE_BUFFER_COUNT is greater than or equal to RECEIVE_BUFFER_TRIGGER\n                 0=RECEIVE_BUFFER_COUNT is less than RECEIVE_BUFFER_TRIGGER.</description>
                     <bitOffset>14</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RX_BUFF_STALL</name>
                     <description>1=The SPI interface had been stalled due to a flow issue (an attempt by the interface to write to a full Receive Buffer)\n          0=No stalls occurred.</description>
                     <bitOffset>15</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TRANS_ACTIV</name>
                     <description>1=A transfer is currently executing\n            0=No transfer currently in progress.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CUR_DESCR_BUF</name>
                     <description>This field shows the Description Buffer currently active. This field has no meaning if Description Buffers are not enabled.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BUF_CNT_STS</name>
               <description>QMSPI Buffer Count Status Register</description>
               <addressOffset>0x14</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>TX_BUFF_CNT</name>
                     <description>This is a count of the number of bytes currently valid in the Transmit Buffer.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
                  <field>
                     <name>RX_BUFF_CNT</name>
                     <description>This is a count of the number of bytes currently valid in the Receive Buffer.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>IEN</name>
               <description>QMSPI Interrupt Enable Register</description>
               <addressOffset>0x18</addressOffset>
               <size>32</size>
               <resetValue>0x00002000</resetValue>
               <fields>
                  <field>
                     <name>TRANS_COMPL_EN</name>
                     <description>1=Enable an interrupt if TRANSFER_COMPLETE is asserted\n         0=Disable the interrupt.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DMA_COMPL_EN</name>
                     <description>1=Enable an interrupt if DMA_COMPLETE is asserted\n           0=Disable the interrupt.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TX_BUF_ERR_EN</name>
                     <description>1=Enable an interrupt if TRANSMIT_BUFFER_ERROR is asserted\n         0=Disable the interrupt.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RX_BUF_ERR_EN</name>
                     <description>1=Enable an interrupt if RECEIVE_BUFFER_ERROR is asserted\n        0=Disable the interrupt.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PRGM_ERR_EN</name>
                     <description>1=Enable an interrupt if PROGRAMMING_ERROR is asserted\n              0=Disable the interrupt.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TX_BUF_FULL_EN</name>
                     <description>1=Enable an interrupt if TRANSMIT_BUFFER_FULL is asserted\n         0=Disable the interrupt.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TX_BUF_EMPTY_EN</name>
                     <description>1=Enable an interrupt if TRANSMIT_BUFFER_EMPTY is asserted\n           0=Disable the interrupt.</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TX_BUF_REQ_EN</name>
                     <description>1=Enable an interrupt if TRANSMIT_BUFFER_REQUEST is asserted\n         0=Disable the interrupt.</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RX_BUF_FUL_EN</name>
                     <description>1=Enable an interrupt if RECEIVE_BUFFER_FULL is asserted\n              0=Disable the interrupt.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RX_BUF_EMPTY_EN</name>
                     <description>1=Enable an interrupt if RECEIVE_BUFFER_EMPTY is asserted\n            0=Disable the interrupt.</description>
                     <bitOffset>13</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RX_BUF_REQ_EN</name>
                     <description>1=Enable an interrupt if RECEIVE_BUFFER_REQUEST is asserted\n         0=Disable the interrupt.</description>
                     <bitOffset>14</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BUF_CNT_TRIG</name>
               <description>QMSPI Buffer Count Trigger Register</description>
               <addressOffset>0x1C</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>TX_BUF_TRIG</name>
                     <description>An interrupt is triggered if the TRANSMIT_BUFFER_COUNT field is less than or equal to this value. A value of 0 disables the interrupt.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
                  <field>
                     <name>RX_BUF_TRIG</name>
                     <description>An interrupt is triggered if the RECEIVE_BUFFER_COUNT field is greater than or equal to this value. A value of 0 disables the interrupt.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>TX_FIFO_u32</name>
               <description>QMSPI Transmit Buffer Register</description>
               <addressOffset>0x20</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>TX_BUF</name>
                     <description>Writes to this register store data to be transmitted from the SPI Master to the external SPI Slave.\n              Writes to this block will be written to the Transmit FIFO. A 1 Byte write fills 1 byte of the FIFO. A Word write fills 2 Bytes and a Doubleword write fills 4 bytes.\n         The data must always be aligned to the bottom most byte (so 1 byte write is on bits [7:0] and Word write is on [15:0]).\n         An overflow condition, TRANSMIT_BUFFER_ERROR, if a write to a full FIFO occurs.\n       Write accesses to this register increment the TRANSMIT_BUFFER_COUNT field.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>2</dim>
               <dimIncrement>2</dimIncrement>
               <name>TX_FIFO_u16[%s]</name>
               <description>QMSPI Transmit Buffer Register</description>
               <addressOffset>0x20</addressOffset>
               <size>16</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>TX_BUF</name>
                     <description>Writes to this register store data to be transmitted from the SPI Master to the external SPI Slave.\n              Writes to this block will be written to the Transmit FIFO. A 1 Byte write fills 1 byte of the FIFO. A Word write fills 2 Bytes and a Doubleword write fills 4 bytes.\n         The data must always be aligned to the bottom most byte (so 1 byte write is on bits [7:0] and Word write is on [15:0]).\n         An overflow condition, TRANSMIT_BUFFER_ERROR, if a write to a full FIFO occurs.\n       Write accesses to this register increment the TRANSMIT_BUFFER_COUNT field.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>4</dim>
               <dimIncrement>1</dimIncrement>
               <name>TX_FIFO_u08[%s]</name>
               <description>QMSPI Transmit Buffer Register</description>
               <addressOffset>0x20</addressOffset>
               <size>8</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>TX_BUF</name>
                     <description>Writes to this register store data to be transmitted from the SPI Master to the external SPI Slave.\n              Writes to this block will be written to the Transmit FIFO. A 1 Byte write fills 1 byte of the FIFO. A Word write fills 2 Bytes and a Doubleword write fills 4 bytes.\n         The data must always be aligned to the bottom most byte (so 1 byte write is on bits [7:0] and Word write is on [15:0]).\n         An overflow condition, TRANSMIT_BUFFER_ERROR, if a write to a full FIFO occurs.\n       Write accesses to this register increment the TRANSMIT_BUFFER_COUNT field.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>RX_FIFO_u32</name>
               <description>QMSPI Receive Buffer Register</description>
               <addressOffset>0x24</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>RX_BUF</name>
                     <description>Buffer that stores data from the external SPI Slave device to the SPI Master (this block), which is received over MISO or IO.\n        Reads from this register will empty the Rx FIFO. A 1 Byte read will have valid data on bits [7:0] and a Word read will have data on bits [15:0].\n                 It is possible to request more data than the FIFO has (underflow condition), but this will cause an error (Rx Buffer Error).\n             Read accesses to this register decrement the RECEIVE_BUFFER_COUNT field.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>2</dim>
               <dimIncrement>2</dimIncrement>
               <name>RX_FIFO_u16[%s]</name>
               <description>QMSPI Receive Buffer Register</description>
               <addressOffset>0x24</addressOffset>
               <size>16</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>RX_BUF</name>
                     <description>Buffer that stores data from the external SPI Slave device to the SPI Master (this block), which is received over MISO or IO.\n        Reads from this register will empty the Rx FIFO. A 1 Byte read will have valid data on bits [7:0] and a Word read will have data on bits [15:0].\n                 It is possible to request more data than the FIFO has (underflow condition), but this will cause an error (Rx Buffer Error).\n             Read accesses to this register decrement the RECEIVE_BUFFER_COUNT field.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>4</dim>
               <dimIncrement>1</dimIncrement>
               <name>RX_FIFO_u08[%s]</name>
               <description>QMSPI Receive Buffer Register</description>
               <addressOffset>0x24</addressOffset>
               <size>8</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>RX_BUF</name>
                     <description>Buffer that stores data from the external SPI Slave device to the SPI Master (this block), which is received over MISO or IO.\n        Reads from this register will empty the Rx FIFO. A 1 Byte read will have valid data on bits [7:0] and a Word read will have data on bits [15:0].\n                 It is possible to request more data than the FIFO has (underflow condition), but this will cause an error (Rx Buffer Error).\n             Read accesses to this register decrement the RECEIVE_BUFFER_COUNT field.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>5</dim>
               <dimIncrement>4</dimIncrement>
               <name>DESCR[%s]</name>
               <description>QMSPI Description Buffer Register</description>
               <addressOffset>0x30</addressOffset>
               <size>32</size>
               <resetValue>0x00000200</resetValue>
               <fields>
                  <field>
                     <name>INFACE_MOD</name>
                     <description>This field sets the transmission mode. If this field is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE \n       or RX_TRANSFER_ENABLE must be 0.3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>TX_TRANS_EN</name>
                     <description>This field bit selects the transmit function of the SPI interface.\n          3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out only 1's. The Transmit Buffer will not be used\n            2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out only 0's. The Transmit Buffer will not be used.\n          1=Transmit Enabled. Data will be fetched from the Transmit Buffer and sent out on the MOSI or IO Bus.\n                0=Transmit is Disabled. No data is sent. This will cause the MOSI be to be undriven, or the IO bus to be undriven if Receive is also disabled.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>TX_DMA_EN</name>
                     <description>This bit enables DMA support for Transmit Transfer. If enabled, DMA will be requested to fill the FIFO until either the interface\n               reaches TRANSFER_LENGTH or the DMA sends a termination request. The size defined here must match DMA programmed access size.\n            1=DMA is enabled.and set to 1 Byte\n                  2=DMA is enabled and set to 2 Bytes\n                  3=DMA is enabled and set to 4 Bytes                    0=DMA is disabled. All data in the Transmit Buffer must be emptied by firmware.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>RX_TRANS_EN</name>
                     <description>This bit enables the receive function of the SPI interface.\n           1=Receive is enabled. Data received from the SPI Slave is stored in the Receive Buffer; 0=Receive is disabled.</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RX_DMA_EN</name>
                     <description>This bit enables DMA support for Receive Transfer. If enabled, DMA will be requested to empty the FIFO \n       until either the interface reaches TRANSFER_LENGTH or the DMA sends a termination request.\n The size defined here must match DMA programmed access size.\n            1=DMA is enabled.and set to 1 Byte\n          2=DMA is enabled and set to 2 Bytes\n          3=DMA is enabled and set to 4 Bytes\n           0=DMA is disabled. All data in the Receive Buffer must be emptied by firmware.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>CLOSE_TRANS_EN</name>
                     <description>This selects what action is taken at the end of a transfer. This bit must be set only on the Last Buffer.\n          1=The transfer is terminated. The Chip Select de-asserts, the SPI interface returns to IDLE and the DMA interface completes the transfer.\n                0=The transfer is not closed. Chip Select remains asserted and the DMA interface and the SPI interface remain active</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TRANS_LEN_BITS</name>
                     <description>1=TRANSFER_LENGTH defined in bits\n             0=TRANSFER_LENGTH defined in bytes</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DESCR_BUF_LAST</name>
                     <description>If this bit is 1 then this is the last Description Buffer in the chain. When the transfer described by this buffer \n       completes the TRANSFER_ COMPLETE status will be set to 1. If this bit is 0, then this is not the last buffer in use. When the transfer completes the next buffer \n       will be activated, and no additional status will be asserted.</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DESCR_BUF_NXT_PTR</name>
                     <description>This defines the next buffer to be used if Description Buffers are enabled and this is not the last buffer. \n       This can point to the current buffer, creating an infinite loop.</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>TX_LEN</name>
                     <description>The length of the SPI transfer. The count is in bytes or bits, depending on the value of TX_LEN_BITS. \n       A value of 0 means an infinite length transfer.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>TFDP</name>
         <version>681.0</version>
         <description>The TFDP serially transmits Embedded Controller (EC)-originated \n         diagnostic vectors to an external debug trace system.</description>
         <groupName>TFDP</groupName>
         <prependToName>TFDP_</prependToName>
         <baseAddress>0x40008C00</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x5</size>
            <usage>registers</usage>
         </addressBlock>
         <registers>
            <register>
               <name>MSDATA</name>
               <description>Debug data to be shifted out on the TFDP Debug port.\n       While data is being shifted out, the Host Interface will 'hold-off' additional writes to the data register until the transfer is complete.</description>
               <addressOffset>0x0</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>CTRL</name>
               <description>Debug Control Register</description>
               <addressOffset>0x4</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>EN</name>
                     <description>Enable. 1=Clock enabled, 0=Clock is disabled (Default)</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>EDGE_SEL</name>
                     <description>1= Data is shifted out on the falling edge of the debug clock, 0= Data is shifted out on the rising edge of the debug clock (Default)</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DIVSEL</name>
                     <description>Clock Divider Select.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>IP_DLY</name>
                     <description>Inter-packet Delay. The delay is in terms of TFDP Debug output clocks.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>VCI</name>
         <version>751.0</version>
         <description>The VBAT-Powered Control Interface has VBAT-powered combinational logic and input and output signal pins.\n       The block interfaces with the RTC With Date and DST Adjustment as well as the Week Alarm.</description>
         <groupName>VCI</groupName>
         <prependToName>VCI_</prependToName>
         <baseAddress>0x4000AE00</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x24</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>OVRD_IN</name>
            <value>121</value>
         </interrupt>
         <interrupt>
            <name>IN0</name>
            <value>122</value>
         </interrupt>
         <interrupt>
            <name>IN1</name>
            <value>123</value>
         </interrupt>
         <interrupt>
            <name>IN2</name>
            <value>124</value>
         </interrupt>
         <interrupt>
            <name>IN3</name>
            <value>125</value>
         </interrupt>
         <interrupt>
            <name>IN4</name>
            <value>126</value>
         </interrupt>
         <interrupt>
            <name>IN5</name>
            <value>127</value>
         </interrupt>
         <interrupt>
            <name>IN6</name>
            <value>128</value>
         </interrupt>
         <registers>
            <register>
               <name>VCI_CTRL_STS</name>
               <description>VCI Register</description>
               <addressOffset>0x0</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>VCI_IN</name>
                     <description>These bits provide the latched state of the associated VCI_IN# pin, if latching is enabled or the current state of the pin\n          if latching is not enabled. In both cases, the value is determined after the action of the VCI Polarity Register.\n          Note: The VCI_IN[6:0]# bits default to the state of their respective input pins.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>7</bitWidth>
                  </field>
                  <field>
                     <name>VCI_OVRD_IN</name>
                     <description>This bit provides the current status of the VCI_OVRD_IN pin.\n                   Note: The VCI_OVRD_IN bit defaults to the state of the respective input pin.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>VCI_OUT</name>
                     <description>This bit provides the current status of the VCI_OUT pin.</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>VCI_FW_CTRL</name>
                     <description>This bit can allow EC firmware to control the state of the VCI_OUT pin. For example, when VTR_PWRGD is asserted and the\n          FW_EXT bit is 1, clearing the VCI_FW_CNTRL bit de-asserts the active high VCI_OUT pin. BIOS must set this bit to 1 prior to setting\n                the FW_EXT bit to 1 on power up, in order to avoid glitches on the VCI_OUT pin.</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FW_EXT</name>
                     <description>This bit controls selecting between the external VBAT-Powered Control Interface inputs, or the VCI_FW_CNTRL bit output to control the VCI_OUT pin.\n        1=VCI_OUT is determined by the VCI_FW_CNTRL field, when VTR is active\n                   0=VCI_OUT is determined by the external inputs.\n               Note: This bit used to be called GPO/nEXT. The name was changed to distinguish it from the BGPOs, which are elsewhere, and to remove a / in a bit name.</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FLTRS_BYPASS</name>
                     <description>The Filters Bypass bit is used to enable and disable the input filters on the VCI_IN# pins.\n         1=Filters disabled; 0=Filters enabled (default).</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>WK_ALRM</name>
                     <description>If enabled by WK_ALRM_LE, this bit is set to 1 if the Week Alarm signal is asserted. It is reset by writes to WK_ALRM_LS.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RTC_ALRM</name>
                     <description>If enabled by RTC_ALRM_LE, this bit is set to 1 if the RTC Alarm signal is asserted. It is reset by writes to RTC_ALRM_LS.</description>
                     <bitOffset>17</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>LATCH_EN</name>
               <description>Latch Enable Register</description>
               <addressOffset>0x4</addressOffset>
               <size>32</size>
               <resetValue>0x00000030</resetValue>
               <fields>
                  <field>
                     <name>LE</name>
                     <description>Latching Enables. Latching occurs after the Polarity configuration, so a VCI_INi# pin is asserted when it is '0' if VCI_IN_POL is '0',\n       and asserted when it is '1' if VCI_IN_POL is '1'. For each bit in the field: \n          1=Enabled. Assertions of the VCI_INi# pin are held until the latch is reset by writing the corresponding LS bit\n          0=Not Enabled. The VCI_INi# signal is not latched but passed directly to the VCI_OUT logic</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>7</bitWidth>
                  </field>
                  <field>
                     <name>WK_ALRM_LE</name>
                     <description>Latch enable for the Week Alarm Power-Up signal.\n          1=Enabled. Assertions of the Week Alarm are held until the latch is reset by writing the corresponding LS bit\n        0=Not Enabled. The Week Alarm signal is not latched but passed directly to the VCI_OUT logic</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RTC_ALRM_LE</name>
                     <description>Latch enable for the RTC Power-Up signal.\n             1=Enabled. Assertions of the RTC Alarm are held until the latch is reset by writing the corresponding LS bit\n           0=Not Enabled. The RTC Alarm signal is not latched but passed directly to the VCI_OUT logic</description>
                     <bitOffset>17</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>LATCH_RST</name>
               <description>Latch Resets Register</description>
               <addressOffset>0x8</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>LS</name>
                     <description>Latch Resets. When a Latch Resets bit is written with a '1', the corresponding VCI_INi# latch is de-asserted ('1'). The VCI_INi#\n         input to the latch has priority over the Latch Reset input, so firmware cannot reset the latch while the VCI_INi# pin is asserted. Firmware\n                 should sample the state of the pin in the VCI Register before attempting to reset the latch. As noted in the Latch Enable Register,\n                 the assertion level is determined by the VCI_IN_POL bit. Reads of this register are undefined.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>7</bitWidth>
                  </field>
                  <field>
                     <name>WK_ALRM_LS</name>
                     <description>Week Alarm Latch Reset. When this bit is written with a '1', the Week Alarm Event latch is reset.\n          The Week Alarm input to the latch has priority over the Reset input Reads of this register are undefined.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RTC_ALRM_LS</name>
                     <description>RTC Alarm Latch Reset. When this bit is written with a '1', the RTC Alarm Event latch is reset.\n           The RTC Alarm input to the latch has priority over the Reset input Reads of this register are undefined.</description>
                     <bitOffset>17</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>INPUT_EN</name>
               <description>VCI Input Enable Register</description>
               <addressOffset>0xC</addressOffset>
               <size>32</size>
               <resetValue>0x0000000F</resetValue>
               <fields>
                  <field>
                     <name>IE</name>
                     <description>Input Enables for VCI_IN# signals. After changing the input enable for a VCI input, firmware should reset the input latch and clear\n         any potential interrupt that may have been triggered by the input, as changing the enable may cause the internal status to change.\n                For each bit in the field:\n             1=Enabled. The corresponding VCI_IN# input is not gated and toggling the pin will affect the VCI_OUT pin\n        0=Not Enabled. the corresponding VCI_IN# input does not affect the VCI_OUT pin, even if the input is '0'. Unless the corresponding bit\n            in the VCI Buffer Enable Register is 1, latches are not asserted, even if the VCI_IN# pin is low, during a VBAT power transition</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>7</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>HLDOFF_CNT</name>
               <description>Holdoff Count Register</description>
               <addressOffset>0x10</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>TIME</name>
                     <description>These bits determine the period of time the VCI_OUT logic is inhibited from re-asserting VCI_OUT after a SYS_SHDN# event.\n        FFh-01h=The Power On Inhibit Holdoff Time is set to a period between 125ms and 31.875 seconds.\n             0=The Power On Inhibit function is disabled.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>POLARITY</name>
               <description>VCI Polarity Register</description>
               <addressOffset>0x14</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>VCI_IN</name>
                     <description>These bits determine the polarity of the VCI_IN input signals: For each bit in the field:\n          1=Active High. The value on the pins is inverted before use\n                0=Active Low (default).</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>7</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>PEDGE_DET</name>
               <description>VCI Posedge Detect Register</description>
               <addressOffset>0x18</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>VCI_IN</name>
                     <description>These bits record a low to high transition on the VCI_IN# pins. A 1 indicates a transition occurred. For each bit in the field:\n          1=Positive Edge Detected; 0=No edge detected.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>7</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>NEDGE_DET</name>
               <description>VCI Negedge Detect Register</description>
               <addressOffset>0x1C</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>VCI_IN</name>
                     <description>These bits record a high to low transition on the VCI_IN# pins. A 1 indicates a transition occurred. For each bit in the field:\n       1=Negative Edge Detected; 0=No edge detected.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>7</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BUFFER_EN</name>
               <description>VCI Buffer Enable Register</description>
               <addressOffset>0x20</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>V_BUF</name>
                     <description>Input Buffer enable. After changing the buffer enable for a VCI input, firmware should reset the input latch and clear any\n       potential interrupt that may have been triggered by the input, as changing the buffer may cause the internal status to change. This register\n           has no effect when VTR is powered. When VTR is on, the input buffers are enabled only by the IE bit. For each bit in the field:\n                1=VCI_IN# input buffer enabled independent of the IE bit. The edge detection latches for this input are always enabled\n              0=VCI_IN# input buffer enabled by the IE bit. The edge detection latches are only enabled when the IE bit is 1 (default).</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>7</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>VBAT_RAM</name>
         <version>931.0</version>
         <description>The VBAT Powered RAM provides a 128 Byte Random Accessed Memory that is operational while the main \n        power rail is operational, and will retain its values powered by battery power while the main rail is unpowered.</description>
         <groupName>VBAT_RAM</groupName>
         <prependToName>VBAT_RAM_</prependToName>
         <baseAddress>0x4000A800</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0xC8</size>
            <usage>registers</usage>
         </addressBlock>
         <registers>
            <register>
               <dim>32</dim>
               <dimIncrement>4</dimIncrement>
               <name>MEM_u32[%s]</name>
               <description>32-bits of VBAT powered RAM.</description>
               <addressOffset>0x0</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>VBAT</name>
         <version>941.0</version>
         <description>The VBAT Register Bank block is a block implemented for aggregating miscellaneous\n         battery-backed registers required the host and by the Embedded Controller (EC) Subsystem that are\n       not unique to a block implemented in the EC subsystem.</description>
         <groupName>VBAT</groupName>
         <prependToName>VBAT_</prependToName>
         <baseAddress>0x4000A400</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x2C</size>
            <usage>registers</usage>
         </addressBlock>
         <registers>
            <register>
               <name>PFRS</name>
               <description>The Power-Fail and Reset Status Register collects and retains \n       the VBAT RST and WDT event status when VCC1 is unpowered.</description>
               <addressOffset>0x0</addressOffset>
               <size>8</size>
               <resetValue>0x80</resetValue>
               <fields>
                  <field>
                     <name>SOFT</name>
                     <description>This bit is set to '1b' if a was triggered by an assertion of the SOFT_SYS_RESET bit in the System Reset Register.\n            This bit is cleared to '0b' when written with a '1b'; writes of a '0b' have no effect. (R/WC)</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TEST</name>
                     <description>Test</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RSTI</name>
                     <description>This bit is set to '1b' if a RESET_SYS was triggered by a low signal on the RSTI# input pin. This bit is\n             cleared to '0b' when written with a '1b'; writes of a '0b' have no effect. (R/WC)</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>WDT_EVT</name>
                     <description>This bit is set to '1b' if a RESET_SYS was triggered by a Watchdog Timer event. This bit is cleared to '0b' when\n            written with a '1b'; writes of a '0b' have no effect. (R/WC)</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SYS_RSTREQ</name>
                     <description>This bit is set to '1b' if a RESET_SYS was triggered by an ARM SYS_RSTREQ event. This bit is cleared to '0b' when\n         written with a '1b'; writes of a '0b' have no effect. (R/WC)</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>VBAT_RST</name>
                     <description>The VBAT RST bit is set to '1' by hardware when a RESET_VBAT is detected. This is the register default value.\n          To clear VBAT RST EC firmware must write a '1' to this bit; writing a '0' to VBAT RST has no affect.(R/WC)</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CLK32_EN</name>
               <description>CLOCK ENABLE</description>
               <addressOffset>0x8</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>C32K_SUPPRESS</name>
                     <description>1=32KHz clock domain is off while VTR is off (i.e., while on VBAT only). The 32KHz domain is always on\n          while VTR is on, so the PLL always has a reference.\n         0=32KHz clock domain is enabled while VTR is off (i.e., while on VBAT only). The clock source for the 32KHz domain is\n         determined by the other bits in this register</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>EXT_32K</name>
                     <description>This bit selects the source for the 32KHz clock domain.\n             1=The 32KHZ_IN VTR-powered pin is used as a source for the 32KHz clock domain. If an activity detector does not detect a\n           clock on the selected source, the always-on 32KHz internal clock source is automatically selected\n                0=The always-on32Khz clock source is used as the source for the 32KHz clock domain.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>C32KHZ_SRC</name>
                     <description>This field determines the source for the always-on 32KHz internal clock source. If set to '1b', this bit\n       will only take effect if an active clock has been detected on the crystal pins. Once the 32KHz source has been switched,\n          activity detection on the crystal no longer functions. Therefore, if the crystal oscillator uses a single-ended\n                 input, once started that input must not stop while this bit is '1b'.\n                  1=Crystal Oscillator. The selection between a singled-ended input or a resonant crystal is determined by XOSEL in this register\n         0=Silicon Oscillator.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>XOSEL</name>
                     <description>This bit selects between a single-ended clock source for the crystal oscillator or an external parallel crystal.\n             1= the Crystal Oscillator is driven by a single-ended 32KHz clock source connected to the XTAL2 pin. \n                 0= the Crystal Oscillator requires a 32KHz parallel resonant crystal connected between the XTAL1 and XTAL2 pins (default).</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MCNT_LO</name>
               <description>MONOTONIC COUNTER</description>
               <addressOffset>0x20</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>MON_CNT</name>
                     <description>Read-only register that increments by 1 every time it is read. It is reset to 0 on a VBAT Power On Reset.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MCNT_HI</name>
               <description>COUNTER HIWORD</description>
               <addressOffset>0x24</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>CNT_HWRD</name>
                     <description>Thirty-two bit read/write register. If software sets this register to an incrementing value, based on an external\n         non-volatile store, this register may be combined with the Monotonic Counter Register to form a 64-bit monotonic counter.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>VWR_BCKP</name>
               <description>VWR_BCKP</description>
               <addressOffset>0x28</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>M2S_2H_BACKUP</name>
                     <description>The Boot ROM firmware will copy this field into the SRC3 to SRC0 bits of the Master-to-Slave Virtual Wire Register\n        that corresponds to Virtual Wire Index 2h on a RESET_SYS. If software always saves the state of the Index 2h SRC bits on the falling\n               edge of the SUSWARN# virtual wire, the state of the four SRC bits will be synchronized to the state of the four bits in the core logic.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>M2S_42H_BACKUP</name>
                     <description>The Boot ROM firmware will copy this field into the SRC3 to SRC0 bits of the Master-to-Slave Virtual Wire Register\n        that corresponds to Virtual Wire Index 42h on a RESET_SYS. If software always saves the state of the Index 2h SRC bits on the falling\n                  edge of the SUSWARN# virtual wire, the state of the four SRC bits will be synchronized to the state of the four bits in the core logic.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>EC_REG_BANK</name>
         <version>951.0</version>
         <description>This block is designed to be accessed internally by the EC via the register interface.</description>
         <groupName>EC_REG_BANK</groupName>
         <prependToName>EC_REG_BANK_</prependToName>
         <baseAddress>0x4000FC04</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x88</size>
            <usage>registers</usage>
         </addressBlock>
         <registers>
            <register>
               <name>AHB_ERR_ADDR</name>
               <description>AHB Error Address [0:0] AHB_ERR_ADDR, In priority order:\n        1. AHB address is registered when an AHB error occurs on the processor's AHB master port and the register value was\n          already 0. This way only the first address to generate an exception is captured.\n         2. The processor can clear this register by writing any 32-bit value to this register.</description>
               <addressOffset>0x4</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>AHB_ERR_CTRL</name>
               <description>AHB Error Control [0:0] AHB_ERROR_DISABLE,\n       0: EC memory exceptions are enabled. 1: EC memory exceptions are disabled.</description>
               <addressOffset>0x14</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>INTR_CTRL</name>
               <description>Interrupt Control [0:0] NVIC_EN (NVIC_EN) \n       This bit enables Alternate NVIC IRQ's Vectors. The Alternate NVIC Vectors provides each interrupt event with a dedicated (direct) NVIC vector.\n         0 = Alternate NVIC vectors disabled, 1= Alternate NVIC vectors enabled</description>
               <addressOffset>0x18</addressOffset>
               <size>32</size>
               <resetValue>0x00000001</resetValue>
            </register>
            <register>
               <name>ETM_CTRL</name>
               <description>ETM TRACE Enable [0:0] TRACE_EN (TRACE_EN) \n       This bit enables the ARM TRACE debug port (ETM/ITM). The Trace Debug Interface pins are forced to the TRACE functions.\n       0 = ARM TRACE port disabled, 1= ARM TRACE port enabled</description>
               <addressOffset>0x1C</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>DEBUG_CTRL</name>
               <description>Debug Enable Register</description>
               <addressOffset>0x20</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>EN</name>
                     <description>EN (JTAG_EN) This bit enables the JTAG/SWD debug port.\n           0= JTAG/SWD port disabled. JTAG/SWD cannot be enabled (i.e., the TRST# pin is ignored and the JTAG signals remain in their non-JTAG state)\n        1= JTAG/SWD port enabled. A high on TRST# enables JTAG or SWD, as determined by SWD_EN.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PIN_CFG</name>
                     <description>This field determines which pins are affected by the TRST# debug enable pin.3=Reserved\n           2=The pins associated with the JTAG TCK and TMS switch to the debug interface when TRST# is de-asserted high. The pins\n           associated with TDI and TDO remain controlled by the associated GPIO. This setting should be used when the ARM Serial\n          Wire Debug (SWD) is required for debugging and the Serial Wire Viewer is not required\n                1=The pins associated with the JTAG TCK, TMS and TDO switch to the debug interface when TRST# is de-asserted high. The pin\n           associated with TDI remains controlled by the associated GPIO. This setting should be used when the ARM Serial Wire Debug\n             (SWD) and Serial Wire Viewer (SWV) are both required for debugging\n          0=All four pins associated with JTAG (TCK, TMS, TDI and TDO) switch to the debug interface when TRST# is de-asserted high.\n         This setting should be used when the JTAG TAP controller is required for debugging.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>2</bitWidth>
                     <enumeratedValues>
                        <name>PIN_CFGSelect</name>
                        <enumeratedValue>
                           <name>JTAG_TCK_TMS</name>
                           <description>2=The pins associated with the JTAG TCK and TMS switch to the debug interface when TRST# is de-asserted high. The pins\n           associated with TDI and TDO remain controlled by the associated GPIO. This setting should be used when the ARM Serial\n          Wire Debug (SWD) is required for debugging and the Serial Wire Viewer is not required </description>
                           <value>0x2</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>JTAG_TCK_TMS_TDO</name>
                           <description>1=The pins associated with the JTAG TCK, TMS and TDO switch to the debug interface when TRST# is de-asserted high. The pin\n           associated with TDI remains controlled by the associated GPIO. This setting should be used when the ARM Serial Wire Debug\n             (SWD) and Serial Wire Viewer (SWV) are both required for debugging</description>
                           <value>0x1</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>JTAG_TCK_TMS_TDO_TDI</name>
                           <description>0=All four pins associated with JTAG (TCK, TMS, TDI and TDO) switch to the debug interface when TRST# is de-asserted high.\n         This setting should be used when the JTAG TAP controller is required for debugging.</description>
                           <value>0x0</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>PU_EN</name>
                     <description>If this bit is set to '1b' internal pull-up resistors are automatically enabled on the appropriate debugging port\n         wires whenever the debug port is enabled (the DEBUG_EN bit in this register is '1b' and the JTAG_RST# pin is high). The setting\n              of DEBUG_PIN_CFG determines which pins have pull-ups enabled when the debug port is enabled.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>OTP_LOCK</name>
               <description>OTP Lock</description>
               <addressOffset>0x24</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>TEST</name>
                     <description>Test</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MCHIP_LOCK</name>
                     <description>This bit controls access to Microchip region of the eFuse memory, bytes 32 to 127. Once written, this bit becomes Read Only.\n          If the JTAG_EN bit is 1 (enabled), the Private Key is inaccessible, independent of the state of this bit.\n             1=The Microchip region is inaccessible (i.e, always returns 0 or 1 for every bit); 0=The Microchip region is accessible.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PRIV_KEY_LOCK</name>
                     <description>This bit controls access to Private Key region of the eFuse memory, bytes 0 to 31. Once written, this bit becomes Read Only.\n        If the JTAG_EN bit is 1 (enabled), the Private Key is inaccessible, independent of the state of this bit.\n           1=The Private Key is inaccessible (i.e, always returns 0 or 1 for every bit); 0=The Private Key is accessible.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>USER_OTP_LOCK</name>
                     <description>This bit controls access to the User region of the eFuse memory, bytes 192 to 511. Once written, this bit becomes Read Only.\n           If the JTAG_EN bit is 1 (enabled), the User region is inaccessible, independent of the state of this bit.\n          1=The User region is inaccessible (i.e, always returns 0 or 1 for every bit); 0=The User region is accessible</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PUB_KEY_LOCK</name>
                     <description>This bit controls access to the Public Key region of the eFuse memory, bytes 128 to 191. Once written, this bit becomes Read Only.\n          If the JTAG_EN bit is 1 (enabled), the Public Key is inaccessible, independent of the state of this bit.\n            1=The Public Key is inaccessible (i.e, always returns 0 or 1 for every bit); 0=The Public Key is accessible</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>WDT_CNT</name>
               <description>WDT Event Count [3:0] WDT_COUNT (WDT_COUNT) These EC R/W bits are cleared to 0 on VCC1 POR,\n       but not on a WDT Note: This field is written by Boot ROM firmware to indicate the number of times a WDT fired before loading a good EC code image.</description>
               <addressOffset>0x28</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>AESH_BSWAP_CTRL</name>
               <description>AES HASH Byte Swap Control Register.</description>
               <addressOffset>0x2C</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>IP_BYTE_SWAP_EN</name>
                     <description>Used to enable byte swap on a DWORD during AHB read from AES / HASH block: 1=Enable; 0=Disable.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>OP_BYTE_SWAP_EN</name>
                     <description>Used to enable byte swap on a DWORD during AHB write from AES / HASH block: 1=Enable; 0=Disable.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>IP_BLK_SWAP_EN</name>
                     <description>Used to enable word swap on a DWORD during AHB read from AES / HASH block\n              4=Swap 32-bit doublewords in 128-byte blocks\n            3=Swap doublewords in 64-byte blocks. Useful for SHA-256. Bus references issued in the order 0x3C, 0x38, 0x34, 0x30, 0x2C,\n          0x28, 0x24, 0x20, 0x1C, 0x18, 0x14, 0x10, 0xC, 0x8, 0x4, 0x0,...\n              2=Swap doublewords in 16-byte blocks. Useful for AES. Bus references issued in the order 0xC, 0x8, 0x4, 0x0, 0x1C, 0x18,...\n          1=Swap doublewords in 8-byte blocks. Useful for SHA-512, which works on 64-bit words. Bus references issued in the order 0x4,\n       0x0, 0xC, 0x8, ...\n           0=Disable.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>3</bitWidth>
                     <enumeratedValues>
                        <name>IP_BLK_SWAP_ENSelect</name>
                        <enumeratedValue>
                           <name>SWAP_128_BYTE_BLOCK</name>
                           <description>4=Swap 32-bit doublewords in 128-byte blocks </description>
                           <value>0x4</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>SWAP_64_BYTE_BLOCK</name>
                           <description>3=Swap doublewords in 64-byte blocks. Useful for SHA-256. Bus references issued in the order 0x3C, 0x38, 0x34, 0x30, 0x2C,\n          0x28, 0x24, 0x20, 0x1C, 0x18, 0x14, 0x10, 0xC, 0x8, 0x4, 0x0,...</description>
                           <value>0x3</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>SWAP_16_BYTE_BLOCK</name>
                           <description>2=Swap doublewords in 16-byte blocks. Useful for AES. Bus references issued in the order 0xC, 0x8, 0x4, 0x0, 0x1C, 0x18,...</description>
                           <value>0x2</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>SWAP_8_BYTE_BLOCK</name>
                           <description>1=Swap doublewords in 8-byte blocks. Useful for SHA-512, which works on 64-bit words. Bus references issued in the order 0x4,\n       0x0, 0xC, 0x8, ...\n</description>
                           <value>0x1</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>DIS</name>
                           <description>0=Disable.</description>
                           <value>0x0</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>OP_BLK_SWAP_EN</name>
                     <description>Used to enable word swap on a DWORD during AHB write from AES / HASH block\n           4=Swap 32-bit doublewords in 128-byte blocks\n                  3=Swap doublewords in 64-byte blocks. Useful for SHA-256. Bus references issued in the order 0x3C, 0x38, 0x34, 0x30, 0x2C,\n              0x28, 0x24, 0x20, 0x1C, 0x18, 0x14, 0x10, 0xC, 0x8, 0x4, 0x0,...\n               2=Swap doublewords in 16-byte blocks. Useful for AES. Bus references issued in the order 0xC, 0x8, 0x4, 0x0, 0x1C, 0x18,...\n         1=Swap doublewords in 8-byte blocks. Useful for SHA-512, which works on 64-bit words. Bus references issued in the order 0x4,\n       0x0, 0xC, 0x8, ...\n            0=Disable.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>3</bitWidth>
                     <enumeratedValues>
                        <name>OP_BLK_SWAP_ENSelect</name>
                        <enumeratedValue>
                           <name>SWAP_128_BYTE_BLOCK</name>
                           <description>4=Swap 32-bit doublewords in 128-byte blocks </description>
                           <value>0x4</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>SWAP_64_BYTE_BLOCK</name>
                           <description>3=Swap doublewords in 64-byte blocks. Useful for SHA-256. Bus references issued in the order 0x3C, 0x38, 0x34, 0x30, 0x2C,\n          0x28, 0x24, 0x20, 0x1C, 0x18, 0x14, 0x10, 0xC, 0x8, 0x4, 0x0,...</description>
                           <value>0x3</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>SWAP_16_BYTE_BLOCK</name>
                           <description>2=Swap doublewords in 16-byte blocks. Useful for AES. Bus references issued in the order 0xC, 0x8, 0x4, 0x0, 0x1C, 0x18,...</description>
                           <value>0x2</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>SWAP_8_BYTE_BLOCK</name>
                           <description>1=Swap doublewords in 8-byte blocks. Useful for SHA-512, which works on 64-bit words. Bus references issued in the order 0x4,\n       0x0, 0xC, 0x8, ...\n</description>
                           <value>0x1</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>DIS</name>
                           <description>0=Disable.</description>
                           <value>0x0</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
               </fields>
            </register>
            <register>
               <name>SYS_SHUTDWN_RST</name>
               <description>AES HASH Byte Swap Control Register.</description>
               <addressOffset>0x38</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>SYS_SHDN_RST</name>
                     <description>When this bit is asserted 1, the SYS_SHDN# output is deasserted</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>PECI_DIS</name>
               <description>PECI Disable</description>
               <addressOffset>0x40</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>PECI_DISABLE</name>
                     <description>When this bit is asserted 1, it disables the PECI pads to reduce leakage.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CRYPTO_SRST</name>
               <description>System Shutdown Reset</description>
               <addressOffset>0x5C</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>RNG_SFT_RST</name>
                     <description>When this bit is asserted 1, the Random Number Generator block is reset.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PUB_KEY_SFT_RST</name>
                     <description>When this bit is asserted 1, the Public Key block is reset.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>AES_HASH_SFT_RST</name>
                     <description>When this bit is asserted 1, the AES and Hash blocks are reset.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>GPIO_BANK_PWR</name>
               <description>GPIO Bank Power Register</description>
               <addressOffset>0x64</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>VTR_LVL1</name>
                     <description>Voltage value on VTR1. This bit is set by hardware after a VTR Power On Reset, but may be overridden by software.\n               It must be set by software if the VTR power rail is not active when RESET_SYS is de-asserted. Write access is determined by bit 7.\n          1=VTR1 is powered by 3.3V\n               0=VTR1 is powered by 1.8V.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>VTR_LVL2</name>
                     <description>Voltage value on VTR2. This bit is set by hardware after a VTR Power On Reset, but may be overridden by software.\n        It must be set by software if the VTR power rail is not active when RESET_SYS is de-asserted. Write access is determined by bit 7.\n       1=VTR2 is powered by 3.3V\n                0=VTR2 is powered by 1.8V.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>VTR_LVL3</name>
                     <description>Voltage value on VTR3. This bit is set by hardware after a VTR Power On Reset, but may be overridden by software.\n           It must be set by software if the VTR power rail is not active when RESET_SYS is de-asserted. Write access is determined by bit 7.\n              1=VTR3 is powered by 3.3V\n                 0=VTR3 is powered by 1.8V.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>GPIO_BANK_PWR_LOCK</name>
                     <description>GPIO Bank Power Lock. 0: VTR_LEVEL bits[2:0] and GPIO Bank Power Lock bit are R/W\n        1 = VTR_LEVEL bits[2:0] and GPIO Bank Power Lock bit are Read Only.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>JTAG_MCFG</name>
               <description>JTAG Master Configuration Register</description>
               <addressOffset>0x70</addressOffset>
               <size>32</size>
               <resetValue>0x00000003</resetValue>
               <fields>
                  <field>
                     <name>JTM_CLK</name>
                     <description>This field determines the JTAG Master clock rate, derived from the 48MHz master clock.\n                7=375KHz; 6=750KHz; 5=1.5Mhz; 4=3Mhz; 3=6Mhz; 2=12Mhz; 1=24MHz; 0=Reserved.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>3</bitWidth>
                     <enumeratedValues>
                        <name>JTM_CLKSelect</name>
                        <enumeratedValue>
                           <name>JTM_CLK_375KHz</name>
                           <description>7=375KHz</description>
                           <value>0x7</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>JTM_CLK_750KHz</name>
                           <description>6=750KHz</description>
                           <value>0x6</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>JTM_CLK_1MHz</name>
                           <description>5=1.5Mhz</description>
                           <value>0x5</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>JTM_CLK_3Mhz</name>
                           <description>4=3Mhz</description>
                           <value>0x4</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>JTM_CLK_6Mhz</name>
                           <description>3=6Mhz</description>
                           <value>0x3</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>JTM_CLK_12Mhz</name>
                           <description>2=12Mhz</description>
                           <value>0x2</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>JTM_CLK_24MHz</name>
                           <description>1=24MHz</description>
                           <value>0x1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>MAS_SLV</name>
                     <description>This bit controls the direction of the JTAG port. 1=The JTAG Port is configured as a Master\n          0=The JTAG Port is configures as a Slave.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>JTAG_MSTS</name>
               <description>JTAG Master Status Register</description>
               <addressOffset>0x74</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>JTM_DONE</name>
                     <description>This bit is set to '1b' when the JTAG Master Command Register is written. It becomes '0b' when shifting has completed.\n         Software can poll this bit to determine when a command has completed and it is therefore safe to remove the data in the JTAG Master TDO\n        Register and load new data into the JTAG Master TMS Register and the JTAG Master TDI Register.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>JTAG_MTDO</name>
               <description>JTAG Master TDO Register</description>
               <addressOffset>0x78</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>JTM_TDO</name>
                     <description>When the JTAG Master Command Register is written, from 1 to 32 bits are shifted into this register, starting with bit 0,\n        from the JTAG_TDO pin. Shifting is at the rate determined by the JTM_CLK field in the JTAG Master Configuration Register.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>JTAG_MTDI</name>
               <description>JTAG Master TDI Register</description>
               <addressOffset>0x7C</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>JTM_TDI</name>
                     <description>When the JTAG Master Command Register is written, from 1 to 32 bits are shifted out of this register, starting with bit 0,\n       onto the JTAG_TDI pin. Shifting is at the rate determined by the JTM_CLK field in the JTAG Master Configuration Register.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>JTAG_MTMS</name>
               <description>JTAG Master TMS Register</description>
               <addressOffset>0x80</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>JTM_TMS</name>
                     <description>When the JTAG Master Command Register is written, from 1 to 32 bits are shifted out of this register, starting with bit 0,\n         onto the JTAG_TMS pin. Shifting is at the rate determined by the JTM_CLK field in the JTAG Master Configuration Register.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>JTAG_MCMD</name>
               <description>JTAG Master Command Register</description>
               <addressOffset>0x84</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>JTM_COUNT</name>
                     <description>If the JTAG Port is configured as a Master, writing this register starts clocking and shifting on the JTAG port. The JTAG\n         Master port will shift JTM_COUNT+1 times, so writing a '0h' will shift 1 bit, and writing '31h' will shift 32 bits. The signal JTAG_CLK\n             will cycle JTM_COUNT+1 times. The contents of the JTAG Master TMS Register and the JTAG Master TDI Register will be shifted out on\n         the falling edge of JTAG_CLK and the.JTAG Master TDO Register will get shifted in on the rising edge of JTAG_CLK.\n                 If the JTAG Port is configured as a Slave, writing this register has no effect.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>5</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>EFUSE</name>
         <version>961.0</version>
         <description>The eFUSE block provides a means of programming and accessing the eFUSE bits.</description>
         <groupName>EFUSE</groupName>
         <prependToName>EFUSE_</prependToName>
         <baseAddress>0x40082000</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x4B0</size>
            <usage>registers</usage>
         </addressBlock>
         <registers>
            <register>
               <name>CTRL</name>
               <description>eFUSE CTRL Register</description>
               <addressOffset>0x0</addressOffset>
               <size>16</size>
               <resetValue>0x00000010</resetValue>
               <fields>
                  <field>
                     <name>EN</name>
                     <description>Block enable: 1=block is enabled for operation; 0=block is disabled and in lowest power state.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RST</name>
                     <description>Block reset: 1=Block is reset; 0=Normal operation. This bit self-clears and always reads back 0.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>EXT_PGM</name>
                     <description>External programming enable: 1=eFUSE programming is done via external pin interface 0=Manual/Normal mode.\n         eFUSE programming is done via this block's register set.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FSOURCE_EN_PRGM</name>
                     <description>FSOURCE pin enable for programming: 1=FSOURCE switch logic connects eFUSE FSOURCE pin to a power pad for PROGRAM mode.\n         Only set this bit when FSOURCE_EN_READ bit is already 0 to avoid shorting the power pad to ground;\n                  0=FSOURCE switch logic isolates eFUSE FSOURCE pin from power pad.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FSOURCE_EN_READ</name>
                     <description>FSOURCE pin enable for reading: 1=FSOURCE switch logic connects eFUSE FSOURCE pin to a power pad for read mode.\n        Only set this bit when FSOURCE_EN_PRGM bit is already 0 to avoid shorting the power pad to ground;\n          0=FSOURCE switch logic isolates eFUSE FSOURCE pin from ground.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MAN_CTRL</name>
               <description>Manual Control Register</description>
               <addressOffset>0x4</addressOffset>
               <size>16</size>
               <resetValue>0x0000</resetValue>
               <fields>
                  <field>
                     <name>MAN_ENABLE</name>
                     <description>Manual mode enable bit: 1=Manual mode is enabled and this register interfaces to the eFUSE;\n         0=Normal mode, internal controller interfaces to eFUSE IP. This bit only takes affect when REG_CTRL.EXT_PRGM bit is 0.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>IP_CS</name>
                     <description>eFUSE chip select (CS) pin: 1=eFUSE is enabled for PROGRAM/READ modes; 0=eFUSE is disabled and in low power state.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>IP_PRGM_EN</name>
                     <description>eFUSE program enable. Can also be considered the write signal: 1=eFUSE is programming; 0=eFUSE is in read mode.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>IP_PRCHG</name>
                     <description>eFUSE precharge: 1=outputs are being precharged; 0=outputs are not precharged.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>IP_SENSE_PULSE</name>
                     <description>eFUSE sense, outputs are valid on falling edge of this bit.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>IP_OE</name>
                     <description>eFUSE output enable. The IP might tri-state at various times, so this bit isolates the outputs to avoid potential crowbar.\n        1=eFUSE outputs enabled for read; 0=eFUSE outputs isolated</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MAN_MOD_ADDR</name>
               <description>MANUAL MODE ADDRESS REGISTER</description>
               <addressOffset>0x6</addressOffset>
               <size>32</size>
               <resetValue>0x0000</resetValue>
               <fields>
                  <field>
                     <name>IP_ADDR_LO</name>
                     <description>Manual mode address, selecting the bit address within a 1K bit block.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>10</bitWidth>
                  </field>
                  <field>
                     <name>IP_ADDR_HI</name>
                     <description>Manual mode address, selecting a 1K bit block of eFuse data</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MAN_MOD_DATA</name>
               <description>MANUAL MODE DATA REGISTER</description>
               <addressOffset>0xC</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>IP_DATA</name>
                     <description>Manual mode data: This field connects to the eFUSE data output pins.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>128</dim>
               <dimIncrement>4</dimIncrement>
               <name>EFUSE_MEM_DW[%s]</name>
               <description>512 Bytes of EFUSE Memory (IP_MEM) Represented in 128 DW chunks:\n       eFUSE memory read-back data. Access to this region depends on the operating mode: NORMAL MODE: Reading any of the bytes\n       starting at this base will automatically start the controller to sequence all eFUSE signals to generate read data. Wait cycles added\n         to the read cycle as appropriate. MANUAL MODE: Refer to the manual mode section for the proper procedure for accessing data in this mode.\n       See REG_MAN_CTRL.MAN_EN and REG_CTRL.EXT_PRGM bits for controlling the operating mode of the block.</description>
               <addressOffset>0x10</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>PECI</name>
         <version>481.0</version>
         <description>The PECI Interface allows the EC to retrieve temperature readings from PECI-compliant devices.</description>
         <groupName>PECI</groupName>
         <prependToName>PECI_</prependToName>
         <baseAddress>0x40006400</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x48</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>PECI</name>
            <value>70</value>
         </interrupt>
         <registers>
            <register>
               <name>WDATA</name>
               <description>The Write Data Register provides access to a 32-byte Transmit FIFO.</description>
               <addressOffset>0x0</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>RDATA</name>
               <description>The Read Data Register provides access to a 32-byte Receive FIFO.</description>
               <addressOffset>0x4</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>CTRL</name>
               <description>Control Register</description>
               <addressOffset>0x8</addressOffset>
               <size>8</size>
               <resetValue>0x01</resetValue>
               <fields>
                  <field>
                     <name>PD</name>
                     <description>PD (Power Down) along with RST controls the Power Management Interface</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RST</name>
                     <description>RST indicates that the PECI Core should be reset.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FRST</name>
                     <description>FRST is the FIFO Reset bit.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TXEN</name>
                     <description>TXEN is the Transmit Enable bit.</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MIEN</name>
                     <description>MIEN is the Master Interrupt Enable</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>STS1</name>
               <description>Status Register 1</description>
               <addressOffset>0xC</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>BOF</name>
                     <description>BOF (Beginning of Frame) is asserted when the PECI Core begins Address Timing Negotiation. (R/WC)</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>EOF</name>
                     <description>EOF (End of Frame) is asserted following Message Stop (tSTOP). (R/WC)</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ERR</name>
                     <description>ERR Indicates that an error for the current transaction has been detected.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RDY</name>
                     <description>RDY represents the state of the READY signal function</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RDYLO</name>
                     <description>RDYLO is asserted '1' on the falling edge of the READY signal function (R/WC)</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RDYHI</name>
                     <description>RDYHI is asserted '1' on the rising edge of the READY signal function (R/WC)</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MINT</name>
                     <description>MINT is the Master Interrupt Status bit and is asserted when any interrupt status bit in the Interrupt Interface is asserted.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>STS2</name>
               <description>Status Register 2</description>
               <addressOffset>0x10</addressOffset>
               <size>8</size>
               <access>read-only</access>
               <resetValue>0x0A</resetValue>
               <fields>
                  <field>
                     <name>WFF</name>
                     <description>WFF indicates that the Write Data Register FIFO is full. WFF does not generate an interrupt.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>WFE</name>
                     <description>WFE indicates that the Write Data Register FIFO is empty.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RFF</name>
                     <description>RFF indicates that the Read Data Register FIFO is full.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RFE</name>
                     <description>RFE indicates that the Read Data Register FIFO is empty. RFE does not generate an interrupt.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>IDLE</name>
                     <description>The IDLE status bit indicates when the SST/PECI bus is idle and a new transaction may begin.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>ERROR</name>
               <description>Error Register</description>
               <addressOffset>0x14</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>FERR</name>
                     <description>FERR (Frame Check Sequence Error). (R/WC)</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BERR</name>
                     <description>BERR (Bus Error). Bus contention has been detected. BERR is asserted when the PECI Module reads a value that is different from what it has driven (R/WC)</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>REQERR</name>
                     <description>REQERR is asserted if PEC_AVAILABLE (READY) input is not asserted when the counts down to zero as shown in. When asserted, REQERR can generate interrupt. (R/WC)</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>WROV</name>
                     <description>WROV (Write Overrun). (R/WC)</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>WRUN</name>
                     <description>WRUN (Write Underrun). (R/WC)</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RDOV</name>
                     <description>RDOV (Read Overrun). RDOV indicates that the internal read buffer has overflowed (R/WC)</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CLKERR</name>
                     <description>CLKERR indicates that the READY signal function in the Hardware Interface was de-asserted in the middle of a transaction (R/WC)</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>IEN1</name>
               <description>Interrupt Enable 1 Register</description>
               <addressOffset>0x18</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>BIEN</name>
                     <description>When the BIEN bit is asserted '1' the BOF interrupt is enabled.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>EIEN</name>
                     <description>When the EIEN bit is asserted '1' the EOF interrupt is enabled.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>EREN</name>
                     <description>When the EREN bit is asserted '1' the ERR interrupt is enabled.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RLEN</name>
                     <description>When the RLEN bit is asserted '1' the RDYLO interrupt is enabled.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RHEN</name>
                     <description>When the RHEN bit is asserted '1' the RDYHI interrupt is enabled.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>IEN2</name>
               <description>Interrupt Enable 2 Register</description>
               <addressOffset>0x1C</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>ENWFE</name>
                     <description>When the ENWFE bit is asserted '1' the WFE interrupt is enabled.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ENRFF</name>
                     <description>When the ENRFF bit is asserted '1' the RFF interrupt is enabled.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>OPTBTLO</name>
               <description>Optimal Bit Time Register (Low Byte)</description>
               <addressOffset>0x20</addressOffset>
               <size>8</size>
               <resetValue>0x16</resetValue>
            </register>
            <register>
               <name>OPTBTHI</name>
               <description>Optimal Bit Time Register (High Byte)</description>
               <addressOffset>0x24</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>BDCTRL</name>
               <description>Baud Control Register.\n                     The baud div value divides down the sytem clock frequency to create the peci CORE_CLK frequency.\n</description>
               <addressOffset>0x30</addressOffset>
               <size>32</size>
               <resetValue>0x00000006</resetValue>
            </register>
            <register>
               <name>BLKID</name>
               <description>Block BLKID Register</description>
               <addressOffset>0x40</addressOffset>
               <size>32</size>
               <resetValue>0x0000000F</resetValue>
            </register>
            <register>
               <name>BLKREV</name>
               <description>Revision Register</description>
               <addressOffset>0x44</addressOffset>
               <size>32</size>
               <resetValue>0x0000000F</resetValue>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>KBC</name>
         <version>321.0</version>
         <description>The keyboard controller uses the EC to produce a superset of the features provided by the\n      industry-standard 8042 keyboard controller. The 8042 Emulated Keyboard Controller is a Host/EC\n      Message Interface with hardware assists to emulate 8042 behavior and provide Legacy GATEA20 support.</description>
         <groupName>KBC</groupName>
         <prependToName>KBC_</prependToName>
         <baseAddress>0x400F0400</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x331</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>KBC8042_OBE</name>
            <value>58</value>
         </interrupt>
         <interrupt>
            <name>KBC8042_IBF</name>
            <value>59</value>
         </interrupt>
         <registers>
            <register>
               <name>HOST_DATA</name>
               <description>READ_DATA. This 8-bit register is read-only. When read by the Host, the PCOBF and/or AUXOBF interrupts are cleared and the\n      OBF flag in the status register is cleared.</description>
               <addressOffset>0x0</addressOffset>
               <size>8</size>
               <access>read-only</access>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>HOST_EC_DATA</name>
               <description>WRITE_DATA. This 8-bit register is write-only. When written, the C/D bit in the Keyboard Status Read Register is cleared\n      to '0', signifying data, and the IBF in the same register is set to '1'. When the Runtime Register at offset 0h is read by the Host,\n      it functions as the EC_HOST Data / AUX Data Register.</description>
               <addressOffset>0x0</addressOffset>
               <size>8</size>
               <access>write-only</access>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>HOST_WC</name>
               <description>WRITE_CMD. This 8-bit register is write-only and is an alias of the register at offset 0h. When written, the C/D bit in the\n      Keyboard Status Read Register is set to '1', signifying a command, and the IBF in the same register is set to '1'. When the Runtime\n      Register at offset 4h is read by the Host, it functions as the Keyboard Status Read Register.</description>
               <addressOffset>0x4</addressOffset>
               <size>8</size>
               <access>write-only</access>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>HOST_RS</name>
               <description>Keyboard Status Read Register. This register is a read-only alias of the EC Keyboard Status Register.</description>
               <addressOffset>0x4</addressOffset>
               <size>8</size>
               <access>read-only</access>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>OBF</name>
                     <description>Output Buffer Full.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>IBF</name>
                     <description>Input Buffer Full.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>UD0</name>
                     <description>User-defined data.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CMD_DAT</name>
                     <description>Command Data. This bit specifies whether the input data register contains data or a command ('0' = data, '1' = command).</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>UD1</name>
                     <description>User-defined data.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>AUXOBF</name>
                     <description>Auxiliary Output Buffer Full.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>UD2</name>
                     <description>User-defined data.</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>H2EC_DATA</name>
               <description>Host_EC Data/Cmd Register  This register is an alias of the HOST_EC Data / CMD Register. When read at the EC-Only offset\n      of 0h, it returns the data written by the Host to either Runtime Register offset 0h or Runtime Register offset 04h.</description>
               <addressOffset>0x100</addressOffset>
               <size>8</size>
               <access>read-only</access>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>EC_DATA</name>
               <description>EC_Host Data Register</description>
               <addressOffset>0x100</addressOffset>
               <size>8</size>
               <access>write-only</access>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>EC_KBD_STS</name>
               <description>Keyboard Status Register</description>
               <addressOffset>0x104</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>OBF</name>
                     <description>Output Buffer Full.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>IBF</name>
                     <description>Input Buffer Full.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>UD0</name>
                     <description>User-defined data.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CMD_DAT</name>
                     <description>Command Data. This bit specifies whether the input data register contains data or a command ('0' = data, '1' = command).</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>UD1</name>
                     <description>User-defined data.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>AUXOBF</name>
                     <description>Auxiliary Output Buffer Full.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>UD2</name>
                     <description>User-defined data.</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>KBCTRL</name>
               <description>Keyboard Control Register</description>
               <addressOffset>0x108</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>UD3</name>
                     <description>User-defined data.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SAEN</name>
                     <description>Software-assist enable. 1=This bit allows control of the GATEA20 signal via firmware\n      0=GATEA20 corresponds to either the last Host-initiated control of GATEA20 or the firmware write to the Keyboard Control Register or the EC AUX Data Register.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PCOBFEN</name>
                     <description>1= reflects the value written to the PCOBF Register, 0=PCOBF reflects the status of writes to the EC Data Register</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>UD4</name>
                     <description>User-defined data.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>OBFEN</name>
                     <description>When this bit is '1', the system interrupt signal KIRQ is driven by the bit PCOBF and MIRQ is driven by AUXOBF. When this\n      bit is '0', KIRQ and MIRQ are driven low. This bit must not be changed when OBF of the status register is equal to '1'.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>UD5</name>
                     <description>User-defined data.</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>AUXH</name>
                     <description>AUX in Hardware. 1=AUXOBF of the Keyboard Status Read Register is set in hardware by a write to the EC AUX Data Register\n      0=AUXOBF is not modified in hardware, but can be read and written by the EC using the EC-Only alias of the EC Keyboard Status Register</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EC_AUX_DATA</name>
               <description>EC_Host Aux Register. This 8-bit register is write-only. When written, the C/D in the Keyboard Status Read Register is cleared\n      to '0', signifying data, and the IBF in the same register is set to '1'. When the Runtime Register at offset 0h is read by the Host, it\n      functions as the EC_HOST Data / AUX Data Register.</description>
               <addressOffset>0x10C</addressOffset>
               <size>8</size>
               <access>write-only</access>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>PCOBF</name>
               <description>8042 Emulated Keyboard Controller PCOBF Register</description>
               <addressOffset>0x114</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>PCOBF</name>
                     <description>PCOBF Register: If enabled by the bit OBFEN, the bit PCOBF is gated onto KIRQ. The KIRQ signal is a system interrupt\n      which signifies that the EC has written to the HOST2EC Data Register (EC-Only offset 0h).</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>ACTIVATE</name>
               <description>Activate Register</description>
               <addressOffset>0x330</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>ACT</name>
                     <description>1=The 8042 Interface is powered and functional. 0=The 8042 Interface is powered down and inactive.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>MBX</name>
         <version>1501.0</version>
         <description>The Mailbox provides a standard run-time mechanism for the host to communicate with the Embedded Controller (EC).</description>
         <groupName>MBX</groupName>
         <prependToName>MBX_</prependToName>
         <baseAddress>0x400F0000</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x130</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>MBX</name>
            <value>60</value>
         </interrupt>
         <registers>
            <register>
               <name>RT_IDX</name>
               <description>MBX_Index Register</description>
               <addressOffset>0x0</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>RT_DATA</name>
               <description>MBX_Data_Register</description>
               <addressOffset>0x1</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>H2EC</name>
               <description>If enabled, an interrupt to the EC marked by the MBX_DATA bit in the Interrupt Aggregator will be generated whenever the Host writes this register. This register is cleared when written with FFh.</description>
               <addressOffset>0x100</addressOffset>
               <size>32</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>EC2H</name>
               <description>An EC write to this register will set bit EC_WR in the SMI Interrupt Source Register to '1b'. If enabled, this will generate a Host SMI. This register is cleared when written with FFh.</description>
               <addressOffset>0x104</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>SMI_SRC</name>
               <description>SMI Interrupt Source Register</description>
               <addressOffset>0x108</addressOffset>
               <size>32</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>EC_WR</name>
                     <description>EC Mailbox Write. This bit is set automatically when the EC-to-Host Mailbox Register has been written. An SMI or SIRQ\n            to the Host is generated when n this bit is '1b' and the corresponding bit in the SMI Interrupt Mask Register register is '1b'.\n            This bit is automatically cleared by a read of the EC-to-Host Mailbox Register through the Host Access Port.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>EC_SWI</name>
                     <description>EC Software Interrupt. An SIRQ to the Host is generated when any bit in this register when this bit is set to '1b' and\n            the corresponding bit in the SMI Interrupt Mask Register register is '1b'.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>7</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SMI_MASK</name>
               <description>SMI Interrupt Mask Register</description>
               <addressOffset>0x10C</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>ECWR_EN</name>
                     <description>EC Mailbox Write.Interrupt Enable. Each bit in this field that is '1b' enables the generation of SIRQ interrupts when the\n            corresponding bit in the EC_SWI field in the SMI Interrupt Source Register is '1b'.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ECSWI_EN</name>
                     <description>EC Software Interrupt Enable. If this bit is '1b', the bit EC_WR in the SMI Interrupt Source Register is enabled for the\n            generation of SIRQ or nSMI events.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>7</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>8</dim>
               <dimIncrement>4</dimIncrement>
               <name>MBX_REG[%s]</name>
               <description>Mailbox Register</description>
               <addressOffset>0x110</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>PM1</name>
         <description>The device implements the ACPI fixed registers but includes only those bits\n that apply to the power button\n      sleep button and RTC alarm events. The ACPI WAK_STS, SLP_TYP and SLP_EN bits are also supported.</description>
         <groupName>PM1</groupName>
         <prependToName>PM1_</prependToName>
         <baseAddress>0x400F1C00</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x111</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>ACPIPM1_CTL</name>
            <value>55</value>
         </interrupt>
         <interrupt>
            <name>ACPIPM1_EN</name>
            <value>56</value>
         </interrupt>
         <interrupt>
            <name>ACPIPM1_STS</name>
            <value>57</value>
         </interrupt>
         <registers>
            <register>
               <name>H_PM1_STS2</name>
               <description>PM1 Status 2</description>
               <addressOffset>0x1</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>PWRBTN_STS</name>
                     <description>This bit can be set or cleared by the EC to simulate a Power button status if the power is controlled by the EC.\n      The Host writing a one to this bit can also clear this bit. The EC must generate the associated SCI interrupt under software control. (R/WC)</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SLPBTN_STS</name>
                     <description>This bit can be set or cleared by the EC to simulate a Sleep button status if the sleep state is controlled by\n      the EC. The Host writing a one to this bit can also clear this bit. The EC must generate the associated SCI interrupt under software\n      control.(R/WC)</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RTC_STS</name>
                     <description>This bit can be set or cleared by the EC to simulate a RTC status. The Host writing a one to this bit can also\n      clear this bit. The EC must generate the associated SCI interrupt under software control. (R/WC)</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWRBTNOR_STS</name>
                     <description>This bit can be set or cleared by the EC to simulate a Power button override event status if the power\n      is controlled by the EC. The Host writing a one to this bit can also clear this bit. The EC must generate the associated hardware\n      event under software control.(R/WC)</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>WAK_STS</name>
                     <description>This bit can be set or cleared by the EC. The Host writing a one to this bit can also clear this bit. (R/WC)</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>H_PM1_EN2</name>
               <description>PM1 Enable 2</description>
               <addressOffset>0x3</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>PWRBTN_EN</name>
                     <description>This bit can be read or written by the Host. It can be read by the EC.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SLPBTN_EN</name>
                     <description>This bit can be read or written by the Host. It can be read by the EC.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RTC_EN</name>
                     <description>This bit can be read or written by the Host. It can be read by the EC.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>H_PM1_CTRL2</name>
               <description>PM1 Control 2</description>
               <addressOffset>0x5</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>PWRBTNOR_EN</name>
                     <description>This bit can be set or cleared by the Host, read by the EC.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SLP_TYP</name>
                     <description>These bits can be set or cleared by the Host, read by the EC.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>SLP_EN</name>
                     <description>SLP_EN</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EC_PM1_STS2</name>
               <description>PM1 Status 2</description>
               <addressOffset>0x101</addressOffset>
               <size>8</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>PWRBTN_STS</name>
                     <description>This bit can be set or cleared by the EC to simulate a Power button status if the power is controlled by the EC.\n      The Host writing a one to this bit can also clear this bit. The EC must generate the associated SCI interrupt under software control. (R/WC)</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SLPBTN_STS</name>
                     <description>This bit can be set or cleared by the EC to simulate a Sleep button status if the sleep state is controlled by\n      the EC. The Host writing a one to this bit can also clear this bit. The EC must generate the associated SCI interrupt under software\n      control.(R/WC)</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RTC_STS</name>
                     <description>This bit can be set or cleared by the EC to simulate a RTC status. The Host writing a one to this bit can also\n      clear this bit. The EC must generate the associated SCI interrupt under software control. (R/WC)</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PWRBTNOR_STS</name>
                     <description>This bit can be set or cleared by the EC to simulate a Power button override event status if the power\n      is controlled by the EC. The Host writing a one to this bit can also clear this bit. The EC must generate the associated hardware\n      event under software control.(R/WC)</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>WAK_STS</name>
                     <description>This bit can be set or cleared by the EC. The Host writing a one to this bit can also clear this bit. (R/WC)</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EC_PM1_EN2</name>
               <description>PM1 Enable 2</description>
               <addressOffset>0x103</addressOffset>
               <size>8</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>PWRBTN_EN</name>
                     <description>This bit can be read or written by the Host. It can be read by the EC.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SLPBTN_EN</name>
                     <description>This bit can be read or written by the Host. It can be read by the EC.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RTC_EN</name>
                     <description>This bit can be read or written by the Host. It can be read by the EC.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EC_PM1_CTRL2</name>
               <description>PM1 Control 2</description>
               <addressOffset>0x105</addressOffset>
               <size>8</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>PWRBTNOR_EN</name>
                     <description>This bit can be set or cleared by the Host, read by the EC.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SLP_TYP</name>
                     <description>These bits can be set or cleared by the Host, read by the EC.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>SLP_EN</name>
                     <description>SLP_EN</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EC_PM_STS</name>
               <description>PM1 EC PM Status</description>
               <addressOffset>0x110</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>EC_SCI_STS</name>
                     <description>If the EC_SCI_STS bit is '1', an interrupt is generated on the EC_SCI# pin.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>UD</name>
                     <description>User Defined</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>7</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>EMI0</name>
         <version>841.0</version>
         <description>The Embedded Memory Interface (EMI) provides a standard run-time mechanism\n      for the system host to communicate with the Embedded Controller (EC) and other logical components.</description>
         <groupName>EMI</groupName>
         <prependToName>EMI_</prependToName>
         <baseAddress>0x400F4000</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x118</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>EMI0</name>
            <value>42</value>
         </interrupt>
         <registers>
            <register>
               <name>RT_HOST2EC</name>
               <description>Host-to-EC Mailbox Register</description>
               <addressOffset>0x0</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>RT_EC2HOST</name>
               <description>EC-to-Host Mailbox Register</description>
               <addressOffset>0x1</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>RT_EC_ADDR_LSB</name>
               <description>EC Address Access Control Register</description>
               <addressOffset>0x2</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>ACCESS_TYPE</name>
                     <description>This field defines the type of access that occurs when the EC Data Register is read or written.\n      11b=Auto-increment 32-bit access. 10b=32-bit access. 01b=16-bit access. 00b=8-bit access.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>ADDR</name>
                     <description>This field defines bits[7:2] of EC_Address [15:0]. Bits[1:0] of the EC_Address are always forced to 00b.\n      The EC_Address is aligned on a DWord boundary. It is the address of the memory being accessed by EC Data Byte 0 Register, which is\n      an offset from the programmed base address of the selected REGION.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>6</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>RT_EC_ADDR_MSB</name>
               <description>EC Address Access Control Register</description>
               <addressOffset>0x3</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>ADDR</name>
                     <description>This field defines bits[14:8] of EC_Address. Bits[1:0] of the EC_Address are always forced to 00b.\n      The EC_Address is aligned on a DWord boundary. It is the address of the memory being accessed by EC Data Byte 0 Register, which is\n      an offset from the programmed base address of the selected REGION.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>5</bitWidth>
                  </field>
                  <field>
                     <name>REGION</name>
                     <description>The field specifies which of two segments in the 32-bit internal address space is to be accessed by the EC_Address[14:2]\n      to generate accesses to the memory.\n      1=The address defined by EC_Address[14:2] is relative to the base address specified by the Memory Base Address 1 Register.\n      0=The address defined by EC_Address[14:2] is relative to the base address specified by the Memory Base Address 0 Register.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>4</dim>
               <dimIncrement>1</dimIncrement>
               <name>RT_DATA[%s]</name>
               <description>EC Data Byte Register</description>
               <addressOffset>0x4</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>RT_INTR_SRC_LSB</name>
               <description>Interrupt Source LSB Register</description>
               <addressOffset>0x8</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>EC_WR</name>
                     <description>EC Mailbox Write. This bit is set when the EC-to-HOST Mailbox Register has been written by the EC at offset 01h\n      of the EC-Only registers. Note: there is no corresponding mask bit in the Interrupt Mask LSB Register.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>EC_SWI_LSB</name>
                     <description>EC Software Interrupt Least Significant Bits. These bits are software interrupt bits that may be set by the EC to\n      notify the host of an event. The meaning of these bits is dependent on the firmware implementation. Each bit in this field is cleared\n      when written with a '1b'. The ability to clear the bit can be disabled by the EC if the corresponding bit in the Host Clear Enable\n      Register is set to '0b'. This may be used by firmware for events that cannot be cleared while the event is still active.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>7</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>RT_INTR_SRC_MSB</name>
               <description>Interrupt Source MSB Register</description>
               <addressOffset>0x9</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>EC_SWI_MSB</name>
                     <description>EC Software Interrupt Most Significant Bits. These bits are software interrupt bits that may be set by the EC to\n      notify the host of an event. The meaning of these bits is dependent on the firmware implementation. Each bit in this field is cleared\n      when written with a '1b'. The ability to clear the bit can be disabled by the EC if the corresponding bit in the Host Clear Enable\n      Register is set to '0b'. This may be used by firmware for events that cannot be cleared while the event is still active.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>RT_INTR_MASK_LSB</name>
               <description>Interrupt Mask LSB Register</description>
               <addressOffset>0xA</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>TEST</name>
                     <description>Test Bit.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>EC_SWI_EN_LSB</name>
                     <description>EC Software Interrupt Enable Least Significant Bits. Each bit that is set to '1b' in this field enables the generation\n      of a Host Event interrupt by the corresponding bit in the EC_SWI field in the Interrupt Source LSB Register.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>7</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>RT_INTR_MASK_MSB</name>
               <description>Interrupt Mask MSB Register</description>
               <addressOffset>0xB</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>EC_SWI_EN_MSB</name>
                     <description>EC Software Interrupt Enable Most Significant Bits. Each bit that is set to '1b' in this field enables the generation\n      of a Host Event interrupt by the corresponding bit in the EC_SWI field in the Interrupt Source MSB Register.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>7</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>RT_APP_ID</name>
               <description>Application ID Register, RT_APP_ID When this field is 00h it can be written with any value. When set to a non-zero value, writing that value will clear this register to 00h. When set to a non-zero value, writing any value other than the current contents will have no effect.</description>
               <addressOffset>0xC</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>HOST2EC</name>
               <description>Host-to-EC Mailbox Register, 8-bit mailbox used communicate information from the system host to the embedded controller. Writing this register generates an event to notify the embedded controller. (R/WC)</description>
               <addressOffset>0x100</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>EC2HOST</name>
               <description>EC-to-Host Mailbox Register, 8-bit mailbox used communicate information from the embedded controller to the system host. Writing this register generates an event to notify the system host.</description>
               <addressOffset>0x101</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>MEM0_BASE</name>
               <description>Memory Base Address 0 Register [31:2] This memory base address defines the beginning of region 0 in the Embedded Controller's 32-bit internal address space. Memory allocated to region 0 is intended to be shared between the Host and the EC. The region defined by this base register is used when bit 15 of the EC Address Register is 0. The access will be to a memory location at an offset defined by the EC_Address relative to the beginning of the region defined by this register. Therefore, a read or write to the memory that is triggered by the EC Data Register will occur at Memory_Base_Address_0 + EC_Address.</description>
               <addressOffset>0x104</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>MEM0_RD_LIMITS</name>
               <description>Memory Read Limit 0 Register [14:2] Whenever a read of any byte in the EC Data Register is attempted, and bit 15 of EC_Address is 0, the field EC_Address[14:2] in the EC_Address_Register is compared to this field. As long as EC_Address[14:2] is less than this field the EC_Data_Register will be loaded from the 24-bit internal address space.</description>
               <addressOffset>0x108</addressOffset>
               <size>16</size>
               <resetValue>0x0000</resetValue>
            </register>
            <register>
               <name>MEM0_WR_LIMITS</name>
               <description>Memory Write Limit 0 Register [14:2] Whenever a write of any byte in EC DATA Register is attempted and bit 15 of EC_Address is 0, the field EC_ADDRESS_MSB in the EC_Address Register is compared to this field. As long as EC_Address[14:2] is less than Memory_Write_Limit_0[14:2] the addressed bytes in the EC DATA Register will be written into the internal 24-bit address space. If EC_Address[14:2] is greater than or equal to the Memory_Write_Limit_0[14:2] no writes will take place.</description>
               <addressOffset>0x10A</addressOffset>
               <size>16</size>
               <resetValue>0x0000</resetValue>
            </register>
            <register>
               <name>MEM1_BASE</name>
               <description>Memory Base Address 1 Register. [31:2] This memory base address defines the beginning of region 1 in the Embedded Controller's 32-bit internal address space. Memory allocated to region 1 is intended to be shared between the Host and the EC. The region defined by this base register is used when bit 15 of the EC Address Register is 1. The access will be to a memory location at an offset defined by the EC_Address relative to the beginning of the region defined by this register. Therefore, a read or write to the memory that is triggered by the EC Data Register will occur at Memory_Base_Address_1 + EC_Address.</description>
               <addressOffset>0x10C</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>MEM1_RD_LIMITS</name>
               <description>Memory Read Limit 1 Register, [14:2]: Whenever a read of any byte in the EC Data Register is attempted, and bit 15 of EC_ADDRESS is 1, the field EC_ADDRESS in the EC_Address_Register is compared to this field. As long as EC_ADDRESS is less than this value, the EC_Data_Register will be loaded from the 24-bit internal address space.</description>
               <addressOffset>0x110</addressOffset>
               <size>16</size>
               <resetValue>0x0000</resetValue>
            </register>
            <register>
               <name>MEM1_WR_LIMITS</name>
               <description>Memory Write Limit 1 Register, [14:2]: Whenever a write of any byte in EC DATA Register is attempted and bit 15 of EC_Address is 1, the field EC_Address[14:2] in the EC_Address Register is compared to this field. As long as EC_Address[14:2] is less than Memory_Write_Limit_1[14:2] the addressed bytes in the EC DATA Register will be written into the internal 24-bit address space. If EC_Address[14:2] is greater than or equal to the Memory_Write_Limit_1[14:2] no writes will take place.</description>
               <addressOffset>0x112</addressOffset>
               <size>16</size>
               <resetValue>0x0000</resetValue>
            </register>
            <register>
               <name>INTR_SET</name>
               <description>[15:1] Interrupt Set Register, Writing a bit in this field with a '1b' sets the corresponding bit in the Interrupt Source Register to '1b'. Writing a bit in this field with a '0b' has no effect. Reading this field returns the current contents of the Interrupt Source Register.</description>
               <addressOffset>0x114</addressOffset>
               <size>16</size>
               <resetValue>0x0000</resetValue>
            </register>
            <register>
               <name>HOST_CLR_EN</name>
               <description>[15:1] Host Clear Enable Register, When a bit in this field is '0b', the corresponding bit in the Interrupt Source Register cannot be cleared by writes to the Interrupt Source Register. When a bit in this field is '1b', the corresponding bit in the Interrupt Source Register can be cleared when that register bit is written with a '1b'.</description>
               <addressOffset>0x116</addressOffset>
               <size>16</size>
               <resetValue>0x0000</resetValue>
            </register>
         </registers>
      </peripheral>
      <peripheral derivedFrom="EMI0">
         <name>EMI1</name>
         <baseAddress>0x400F4400</baseAddress>
         <interrupt>
            <name>EMI1</name>
            <value>43</value>
         </interrupt>
      </peripheral>
      <peripheral derivedFrom="EMI0">
         <name>EMI2</name>
         <baseAddress>0x400F4800</baseAddress>
         <interrupt>
            <name>EMI2</name>
            <value>44</value>
         </interrupt>
      </peripheral>
      <peripheral>
         <name>PS2_0</name>
         <version>521.0</version>
         <description>There are four PS/2 Ports which are directly controlled by the EC. The hardware implementation eliminates\n      the need to bit bang I/O ports to generate PS/2 traffic, however bit banging is available via the associated GPIO pins.</description>
         <groupName>PS2</groupName>
         <prependToName>PS2_</prependToName>
         <baseAddress>0x40009000</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0xC</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>PS2_0_ACT</name>
            <value>100</value>
         </interrupt>
         <interrupt>
            <name>PS2_0A_WK</name>
            <value>129</value>
         </interrupt>
         <interrupt>
            <name>PS2_0B_WK</name>
            <value>130</value>
         </interrupt>
         <registers>
            <register>
               <name>TX_DATA</name>
               <description>Writes to bits 7:0 of this register start a transmission of the data in this register to the peripheral</description>
               <addressOffset>0x0</addressOffset>
               <size>32</size>
               <access>write-only</access>
               <resetValue>0x00000000</resetValue>
            </register>
            <register>
               <name>RX_DATA</name>
               <description>Data received from a peripheral are recorded in this register in bits 7:0.</description>
               <addressOffset>0x0</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <resetValue>0x000000FF</resetValue>
            </register>
            <register>
               <name>CONTROL</name>
               <description>PS2 Control Register</description>
               <addressOffset>0x4</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>TR</name>
                     <description>PS/2 Transmit/Receive \n      0=The P2/2 channel is enabled to receive data.\n      1=The PS2 channel is enabled to transmit data.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>EN</name>
                     <description>PS/2 Enable. 0=The PS/2 state machine is disabled. 1=The PS/2 state machine is enabled.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PARITY</name>
                     <description>00b=Receiver expects Odd Parity (default). \n      01b=Receiver expects Even Parity.\n      10b=Receiver ignores level of the parity bit (10th bit is not interpreted as a parity bit).\n      11b=Reserved</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
                  <field>
                     <name>STOP</name>
                     <description>00b=Receiver expects an active high stop bit. \n      01b=Receiver expects an active low stop bit.\n      10b=Receiver ignores the level of the Stop bit (11th bit is not interpreted as a stop bit). \n      11b=Reserved.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>2</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>STATUS</name>
               <description>PS2 Status Register</description>
               <addressOffset>0x8</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>RDATA_RDY</name>
                     <description>Receive Data Ready. Reading the Receive Register clears this bit. A low to high transition on this bit generates a PS2 Activity interrupt.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>REC_TIMEOUT</name>
                     <description>Receive Timeout. The REC_TIMEOUT bit is cleared when the Status Register is read. A low to high transition on this bit generates a PS2 Activity interrupt. (R/WC)</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PE</name>
                     <description>Parity Error</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FE</name>
                     <description>Framing Error</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>XMIT_IDLE</name>
                     <description>Transmitter Idle. 0=The channel is actively transmitting PS/2 data. 1=The channel is not transmitting. A low to high transition on this bit generates a PS2 Activity interrupt.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>XMIT_TIME_OUT</name>
                     <description>Transmitter Time-out. When the XMIT_TIMEOUT bit is set, the PS2_T/R bit is held clear, the PS/2 channel's CLK line is pulled low for a minimum of 300us until the PS/2 Status register is read.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>RX_BUSY</name>
                     <description>Receive Channel Busy.\n      0=The channel is idle\n      1=The channel is actively receiving PS/2 data</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>XMIT_START_TIMEOUT</name>
                     <description>Transmit Start Timeout.\n      0=No transmit start timeout detected\n      1=A start bit was not received within 25 ms following the transmit start event. The transmit start bit time-out condition is also indicated by the XMIT_TIMEOUT bit.</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral derivedFrom="PS2_0">
         <name>PS2_1</name>
         <baseAddress>0x40009040</baseAddress>
         <interrupt>
            <name>PS2_1_ACT</name>
            <value>101</value>
         </interrupt>
         <interrupt>
            <name>PS2_1A_WK</name>
            <value>131</value>
         </interrupt>
         <interrupt>
            <name>PS2_1B_WK</name>
            <value>132</value>
         </interrupt>
      </peripheral>
      <peripheral derivedFrom="PS2_0">
         <name>PS2_2</name>
         <baseAddress>0x40009080</baseAddress>
         <interrupt>
            <name>PS2_2_ACT</name>
            <value>102</value>
         </interrupt>
         <interrupt>
            <name>PS2_2_WK</name>
            <value>133</value>
         </interrupt>
      </peripheral>
      <peripheral>
         <name>ACPI_EC0</name>
         <version>1151.0</version>
         <description>The ACPI Embedded Controller Interface (ACPI-ECI) provides a four byte full\n      duplex data interface which is a superset of the standard ACPI Embedded Controller Interface\n      (ACPI-ECI) one byte data interface. The ACPI Embedded Controller Interface (ACPI-ECI) defaults\n      to the standard one byte interface.</description>
         <groupName>ACPI_EC</groupName>
         <prependToName>ACPI_EC_</prependToName>
         <baseAddress>0x400F0800</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x10C</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>IBF0</name>
            <value>45</value>
         </interrupt>
         <interrupt>
            <name>OBE0</name>
            <value>46</value>
         </interrupt>
         <registers>
            <register>
               <dim>4</dim>
               <dimIncrement>1</dimIncrement>
               <name>OS_DATA[%s]</name>
               <description>This is byte n of the 32-bit ACPI-OS DATA BYTES[3:0]. Writes by the ACPI_OS to the ACPI-OS DATA BYTES[n] are aliased\n      to the OS2EC DATA BYTES[n]. Reads by the ACPI_OS from the ACPI-OS DATA BYTES[n] are aliased to the EC2OS DATA BYTES[n].</description>
               <addressOffset>0x0</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>OS_CMD</name>
               <description>Writes to the this register are aliased in the OS2EC Data EC Byte 0 Register.\n      Writes to this register also set the CMD and IBF bits in the OS STATUS OS Register</description>
               <addressOffset>0x4</addressOffset>
               <size>8</size>
               <access>write-only</access>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>OS_STS</name>
               <description>OS STATUS</description>
               <addressOffset>0x4</addressOffset>
               <size>8</size>
               <access>read-only</access>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>OBF</name>
                     <description>The Output Buffer Full bit is set to indicate that a the ACPI_EC has written a data to the ACPI_OS and that data is ready.\n      This bit is automatically cleared when all the data has been read by the ACPI_OS.      Note: The setting and clearing of this OBF varies depending on the setting FOUR_BYTE_ACCESS bit in the OS Byte Control Register.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>IBF</name>
                     <description>The Input Buffer Full bit is set to indicate that a the ACPI_OS has written a command or data to the ACPI_EC and that\n      data is ready. This bit is automatically cleared when data has been read by the ACPI_EC.\n      Note: The setting and clearing of this IBF varies depending on the setting of the following bits: CMD bit in this register\n      and FOUR_BYTE_ACCESS bit in the OS Byte Control Register.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>UD1B</name>
                     <description>User Defined</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CMD</name>
                     <description>This bit is set when the OS2EC Data EC Byte 0 Register contains a command byte written into ACPI OS COMMAND Register;\n      this bit is cleared when the OS2EC DATA BYTES[3:0] contains a data byte written into the ACPI-OS DATA BYTES[3:0].\n      This bit is hardware controlled:\n      ACPI_OS writes to any of the four ACPI-OS DATA BYTES[3:0] bytes clears this bit\n      ACPI_OS writes to the ACPI OS COMMAND Register sets this bit.\n      Note: This bit allows the embedded controller to differentiate the start of a command sequence from a data byte write operation.</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BURST</name>
                     <description>The BURST bit is set when the ACPI_EC is in Burst Mode for polled command processing; the BURST bit is cleared when the\n      ACPI_EC is in Normal mode for interrupt-driven command processing. The BURST bit is is an ACPI_EC-maintained software flag that\n      indicates the embedded controller has received the Burst Enable command from the host, has halted normal processing, and is\n      waiting for a series of commands to be sent from the host.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SCI_EVT</name>
                     <description>This bit is set by software when an SCI event is pending; i.e., the ACPI_EC is requesting an SCI query; SCI Event flag\n      is clear when no SCI events are pending. This bit is an ACPI_EC-maintained software flag that is set when the embedded controller\n      has detected an internal event that requires operating system attention. The ACPI_EC sets this bit before generating an SCI to the OS.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SMI_EVT</name>
                     <description>This bit is set when an SMI event is pending; i.e., the ACPI_EC is requesting an SMI query; This bit is cleared when\n      no SMI events are pending. This bit is an ACPI_EC-maintained software flag that is set when the ACPI_EC has detected an internal\n      event that requires system management interrupt handler attention. The ACPI_EC sets this bit before generating an SMI.</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>UD0B</name>
                     <description>User Defined</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>OS_BYTE_CTRL</name>
               <description>OS Byte Control Register</description>
               <addressOffset>0x5</addressOffset>
               <size>8</size>
               <access>read-only</access>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>FOUR_BYTE_ACCESS</name>
                     <description>When this bit is set to '1', the ACPI Embedded Controller Interface (ACPI-ECI) accesses four bytes through the\n      ACPI-OS DATA BYTES[3:0]. When this bit is cleared to '0', the ACPI Embedded Controller Interface (ACPI-ECI) accesses one byte\n      through the ACPI OS Data Register Byte 0 Register. This corresponds to Legacy Mode. This bit effects the behaviour of the IBF\n      and OBF bits in the OS STATUS OS Register.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>4</dim>
               <dimIncrement>1</dimIncrement>
               <name>EC2OS_DATA[%s]</name>
               <description>This is byte n of the 32-bit EC2OS DATA BYTES[3:0]. Writes by the ACPI_EC to the EC2OS DATA BYTES[3:0] are aliased to the\n      ACPI-OS DATA BYTES[3:0].</description>
               <addressOffset>0x100</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <name>EC_STATUS</name>
               <description>EC STATUS</description>
               <addressOffset>0x104</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>OBF</name>
                     <description>The Output Buffer Full bit is set to indicate that a the ACPI_EC has written a data to the ACPI_OS and that data is ready.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>IBF</name>
                     <description>The Input Buffer Full bit is set to indicate that a the ACPI_OS has written a command or data to the ACPI_EC and that data is ready.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>UD1A</name>
                     <description>UD1A User Defined</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>CMD</name>
                     <description>This bit is set when the OS2EC Data EC Byte 0 Register contains a command byte written into ACPI OS COMMAND Register</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BURST</name>
                     <description>The BURST bit is set when the ACPI_EC is in Burst Mode</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SCI_EVT</name>
                     <description>This bit is set by software when an SCI event is pending</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SMI_EVT</name>
                     <description>This bit is set when an SMI event is pending</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>UD0A</name>
                     <description>User Defined</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EC_BYTE_CTRL</name>
               <description>Byte Control EC-Register</description>
               <addressOffset>0x105</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
               <fields>
                  <field>
                     <name>FOUR_BYTE_ACCESS</name>
                     <description>When this bit is set to '1', the ACPI Embedded Controller Interface (ACPI-ECI) accesses four bytes through the\n      ACPI-OS DATA BYTES[3:0]. When this bit is cleared to '0', the ACPI Embedded Controller Interface (ACPI-ECI) accesses one byte\n      through the ACPI OS Data Register Byte 0 Register. This corresponds to Legacy Mode. This bit effects the behaviour of the IBF\n      and OBF bits in the OS STATUS OS Register.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>4</dim>
               <dimIncrement>1</dimIncrement>
               <name>OS2EC_DATA[%s]</name>
               <description>OS_TO_EC_DATA_BYTE_n. This is byte n of the 32-bit OS2EC DATA BYTES[3:0]. When the CMD bit in the OS STATUS OS Register\n      is cleared to '0', reads by the ACPI_EC from the OS2EC DATA BYTES[3:0] are aliased to the ACPI-OS DATA BYTES[3:0].</description>
               <addressOffset>0x108</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
            </register>
         </registers>
      </peripheral>
      <peripheral derivedFrom="ACPI_EC0">
         <name>ACPI_EC1</name>
         <baseAddress>0x400F0C00</baseAddress>
         <interrupt>
            <name>IBF1</name>
            <value>47</value>
         </interrupt>
         <interrupt>
            <name>OBE1</name>
            <value>48</value>
         </interrupt>
      </peripheral>
      <peripheral derivedFrom="ACPI_EC0">
         <name>ACPI_EC2</name>
         <baseAddress>0x400F1000</baseAddress>
         <interrupt>
            <name>IBF2</name>
            <value>49</value>
         </interrupt>
         <interrupt>
            <name>OBE2</name>
            <value>50</value>
         </interrupt>
      </peripheral>
      <peripheral derivedFrom="ACPI_EC0">
         <name>ACPI_EC3</name>
         <baseAddress>0x400F1400</baseAddress>
         <interrupt>
            <name>IBF3</name>
            <value>51</value>
         </interrupt>
         <interrupt>
            <name>OBE3</name>
            <value>52</value>
         </interrupt>
      </peripheral>
      <peripheral derivedFrom="ACPI_EC0">
         <name>ACPI_EC4</name>
         <baseAddress>0x400F1800</baseAddress>
         <interrupt>
            <name>IBF4</name>
            <value>53</value>
         </interrupt>
         <interrupt>
            <name>OBE4</name>
            <value>54</value>
         </interrupt>
      </peripheral>
      <peripheral>
         <name>EEPROM</name>
         <version>1251.0</version>
         <description>This block is the 2K x 8bit EEPROM.</description>
         <groupName>EEPROM</groupName>
         <prependToName>EEPROM_</prependToName>
         <baseAddress>0x40002C00</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x40</size>
            <usage>registers</usage>
         </addressBlock>
         <interrupt>
            <name>EEPROM</name>
            <value>155</value>
         </interrupt>
         <registers>
            <register>
               <name>MODE</name>
               <description>EEPROM Mode Register</description>
               <addressOffset>0x0</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>ACT</name>
                     <description>This bit is used to enable and disable the EEPROM controller.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SOFT_RST</name>
                     <description>This write-only bit is used to reset the EEPROM</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>EXE</name>
               <description>EEPROM Execute Register</description>
               <addressOffset>0x4</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>ADDR</name>
                     <description>This register represents a byte address in the EEPROM. Bits[15:11] should be 0, but there is error flagged if they\n     are not. This field only applies to READ and WRITE commands. It does not apply to READ STATUS and WRITE STATUS commands.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
                  <field>
                     <name>CMD</name>
                     <description>A write to this register automatically starts an EEPROM transfer between the fabric and the buffer.     3=WRITE STATUS; 2=READ STATUS; 1=WRITE; 0=READ.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>TRANS_SIZE</name>
                     <description>The number of bytes to be transferred between the EEPROM fabric and the buffer. A count of 0 is means\n     a transfer of 32 bytes. This field is only applicable for WRITE and READ commands.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>5</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>STS</name>
               <description>EEPROM Status Register</description>
               <addressOffset>0x8</addressOffset>
               <size>32</size>
               <resetValue>0xFFFFFFFF</resetValue>
               <fields>
                  <field>
                     <name>TRANS_COMPL</name>
                     <description>This bit indicated whether the transfer between the EEPROM fabric and the EEPROM Buffer Register has completed. (R/WC)     1=The transfer between the EEPROM fabric and the EEPROM Buffer Register has completed\n     0=The transfer between the EEPROM fabric and the EEPROM Buffer Register has not yet completed.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>EXE_ERR</name>
                     <description>This bit is set to '1b' if an illegal command has been programmed into the block. (R/WC)     A command is illegal if: The EEPROM Execute Register is written while a previous command has not yet completed\n     (that is, while TRANSFER_ACTIVE is '1b'); An illegal value was written into the COMMAND field.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TRANS_ACT</name>
                     <description>A transfer between the EEPROM fabric and the EEPROM Buffer Register is in progress.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>IEN</name>
               <description>EEPROM Interrupt Enable Register</description>
               <addressOffset>0xC</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>TRANS_COMPL</name>
                     <description>Assert an EEPROM interrupt when the TRANSFER_COMPLETE status is asserted.\n     1=Enable Interrupt; 0=Disable Interrupt.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>EXE_ERR</name>
                     <description>Assert an EEPROM interrupt when the EXECUTION_ERROR status is asserted.\n     1=Enable Interrupt; 0=Disable Interrupt.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>PSWD</name>
               <description>EEPROM Password Register</description>
               <addressOffset>0x10</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>PSWD</name>
                     <description>If this 31-bit value matches the key in the EEPROM Unlock Register then the EEPROM array can be read or written.\n     This register is write-once only. Once written, it can be neither read nor written until the next system reset.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>31</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>UNLOCK</name>
               <description>EEPROM Unlock Register</description>
               <addressOffset>0x14</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>UNLOCK</name>
                     <description>When this 31-bit register is written, the least significant 31 bits of the write are compared to the\n     EEPROM Password Register that stores the key. If all bits match, the LOCK bit in the EEPROM Status Register cleared,\n     and the EEPROM array can be read or written. This register is write only.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>31</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>LOCK</name>
               <description>EEPROM Lock Register</description>
               <addressOffset>0x18</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>JTAG_LOCK</name>
                     <description>If this bit is set to '1b' the LOCK bit is set to '1b' whenever the JTAG/SWD test interface is activated.\n     This has priority over the EEPROM Unlock Register register, so that writing the EEPROM Unlock Register register with\n     a value that matches the EEPROM Password Register if JTAG/SWD is active at the time.\n     1=The LOCK bit is set to '1b' whenever the JTAG/SWD test interface is activated\n     0=The JTAG/SWD test interface has no effect on the LOCK bit.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>LOCK</name>
                     <description>EEPROM Access Lock. When this bit is set to '1b', the EEPROM is locked from all accesses, including reads,\n     writes and status queries. Once set to '1b' it can only be cleared to '0b' by a RESET_SYS or by writing the EEPROM Unlock\n     Register with a value that matches the contents of the EEPROM Password Register.\n     1=EEPROM is locked and cannot be accessed\n     0=EEPROM is unlocked and may be accessed</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>RSVD1</name>
               <description>Reserved</description>
               <addressOffset>0x1C</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <dim>8</dim>
               <dimIncrement>4</dimIncrement>
               <name>EEBUF_u32[%s]</name>
               <description>One byte of EEPROM Buffer Register. The Data buffer of 32 bytes is used to transfer data to and from the EEPROM fabric.\n     For WRITES, it must be written before the WRITE command is started. For READ STATUS and WRITE STATUS commands, only the\n     first byte (offset 0 in this register) is used.</description>
               <addressOffset>0x20</addressOffset>
               <size>32</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <dim>16</dim>
               <dimIncrement>2</dimIncrement>
               <name>EEBUF_u16[%s]</name>
               <description>One byte of EEPROM Buffer Register. The Data buffer of 32 bytes is used to transfer data to and from the EEPROM fabric.\n     For WRITES, it must be written before the WRITE command is started. For READ STATUS and WRITE STATUS commands, only the\n     first byte (offset 0 in this register) is used.</description>
               <addressOffset>0x20</addressOffset>
               <size>16</size>
               <resetValue>0x00</resetValue>
            </register>
            <register>
               <dim>32</dim>
               <dimIncrement>1</dimIncrement>
               <name>EEBUF_u08[%s]</name>
               <description>One byte of EEPROM Buffer Register. The Data buffer of 32 bytes is used to transfer data to and from the EEPROM fabric.\n     For WRITES, it must be written before the WRITE command is started. For READ STATUS and WRITE STATUS commands, only the\n     first byte (offset 0 in this register) is used.</description>
               <addressOffset>0x20</addressOffset>
               <size>8</size>
               <resetValue>0x00</resetValue>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>MPU</name>
         <description>Memory Protection Unit Registers</description>
         <groupName>MPU</groupName>
         <prependToName>MPU_</prependToName>
         <baseAddress>0xE000ED90</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x14</size>
            <usage>registers</usage>
         </addressBlock>
         <registers>
            <register>
               <name>TYPE</name>
               <description>MPU Type Register</description>
               <addressOffset>0x00000000</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <resetValue>0x00000800</resetValue>
               <fields>
                  <field>
                     <name>SEPARATE</name>
                     <description>Indicates support for unified or separate instruction and date memory maps.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DREGION</name>
                     <description>Indicates the number of supported MPU instruction regions.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>IREGION</name>
                     <description>Indicates the number of supported MPU data regions.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CTRL</name>
               <description>MPU Control Register</description>
               <addressOffset>0x00000004</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>ENABLE</name>
                     <description>Enables the MPU</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>HFNMIENA</name>
                     <description>Enables the operation of MPU during hard fault, NMI, and FAULTMASK handlers.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PRIVDEFENA</name>
                     <description>Enables privileged software access to the default memory map.</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>RNR</name>
               <description>MPU Region Number Register</description>
               <addressOffset>0x00000008</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>REGION</name>
                     <description>Indicates the MPU region referenced by the MPU_RBAR and MPU_RASR registers.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>RBAR</name>
               <description>MPU Region Base Address Register</description>
               <addressOffset>0x0000000C</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>REGION</name>
                     <description>MPU region field.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>VALID</name>
                     <description>MPU Region Number valid bit.</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ADDR</name>
                     <description>Region base address field.</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>27</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>RASR</name>
               <description>MPU Region Attribute and Size Register</description>
               <addressOffset>0x00000010</addressOffset>
               <size>32</size>
               <resetValue>0x00000000</resetValue>
               <fields>
                  <field>
                     <name>ENABLE</name>
                     <description>Region enable bit.</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SIZE</name>
                     <description>Specifies the size of the MPU protection region.</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>5</bitWidth>
                  </field>
                  <field>
                     <name>SRD</name>
                     <description>Subregion disable bits.</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>B</name>
                     <description>MPU access permission attributes.</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>C</name>
                     <description>MPU access permission attributes.</description>
                     <bitOffset>17</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>S</name>
                     <description>Shareable bit.</description>
                     <bitOffset>18</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>TEX</name>
                     <description>MPU access permission attributes.</description>
                     <bitOffset>19</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>AP</name>
                     <description>Access permission field.</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>XN</name>
                     <description>Instruction access disable bit.</description>
                     <bitOffset>28</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>NVIC</name>
         <description>Nested Vectored Interrupt Controller</description>
         <groupName>NVIC</groupName>
         <prependToName>NVIC_</prependToName>
         <baseAddress>0xE000E100</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0xE04</size>
            <usage>registers</usage>
         </addressBlock>
         <registers>
            <register>
               <dim>1</dim>
               <dimIncrement>4</dimIncrement>
               <name>ISER[%s]</name>
               <description>Interrupt Set Enable Register</description>
               <addressOffset>0x0</addressOffset>
               <size>32</size>
               <resetValue>0</resetValue>
               <fields>
                  <field>
                     <name>SETENA</name>
                     <description>Interrupt set enable bits</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>1</dim>
               <dimIncrement>4</dimIncrement>
               <name>ICER[%s]</name>
               <description>Interrupt Clear Enable Register</description>
               <addressOffset>0x80</addressOffset>
               <size>32</size>
               <resetValue>0</resetValue>
               <fields>
                  <field>
                     <name>CLRENA</name>
                     <description>Interrupt clear-enable bits</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>1</dim>
               <dimIncrement>4</dimIncrement>
               <name>ISPR[%s]</name>
               <description>Interrupt Set Pending Register</description>
               <addressOffset>0x100</addressOffset>
               <size>32</size>
               <resetValue>0</resetValue>
               <fields>
                  <field>
                     <name>SETPEND</name>
                     <description>Interrupt set-pending bits</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>1</dim>
               <dimIncrement>4</dimIncrement>
               <name>ICPR[%s]</name>
               <description>Interrupt Clear Pending Register</description>
               <addressOffset>0x180</addressOffset>
               <size>32</size>
               <resetValue>0</resetValue>
               <fields>
                  <field>
                     <name>CLRPEND</name>
                     <description>Interrupt clear-pending bits</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>1</dim>
               <dimIncrement>4</dimIncrement>
               <name>IABR[%s]</name>
               <description>Interrupt Active Bit Register</description>
               <addressOffset>0x200</addressOffset>
               <size>32</size>
               <resetValue>0</resetValue>
               <fields>
                  <field>
                     <name>ACTIVE</name>
                     <description>Interrupt active bits</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>8</dim>
               <dimIncrement>1</dimIncrement>
               <name>IP[%s]</name>
               <description>Interrupt Priority Register n</description>
               <addressOffset>0x300</addressOffset>
               <size>8</size>
               <resetValue>0</resetValue>
               <fields>
                  <field>
                     <name>PRI0</name>
                     <description>Priority of interrupt n</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>STIR</name>
               <description>Software Trigger Interrupt Register</description>
               <addressOffset>0xE00</addressOffset>
               <size>32</size>
               <access>write-only</access>
               <fields>
                  <field>
                     <name>INTID</name>
                     <description>Interrupt ID to trigger</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>9</bitWidth>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>SysTick</name>
         <description>System timer</description>
         <groupName>SysTick</groupName>
         <prependToName>SysTick_</prependToName>
         <baseAddress>0xE000E010</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0x10</size>
            <usage>registers</usage>
         </addressBlock>
         <registers>
            <register>
               <name>CSR</name>
               <description>SysTick Control and Status Register</description>
               <addressOffset>0x0</addressOffset>
               <size>32</size>
               <resetValue>0x4</resetValue>
               <fields>
                  <field>
                     <name>ENABLE</name>
                     <description>SysTick Counter Enable</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <name>ENABLESelect</name>
                        <enumeratedValue>
                           <name>VALUE_0</name>
                           <description>Counter disabled</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>VALUE_1</name>
                           <description>Counter enabled</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>TICKINT</name>
                     <description>SysTick Exception Request Enable</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <name>TICKINTSelect</name>
                        <enumeratedValue>
                           <name>VALUE_0</name>
                           <description>Counting down to 0 does not assert the SysTick exception request</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>VALUE_1</name>
                           <description>Counting down to 0 asserts the SysTick exception request</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>CLKSOURCE</name>
                     <description>Clock Source 0=external, 1=processor</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <name>CLKSOURCESelect</name>
                        <enumeratedValue>
                           <name>VALUE_0</name>
                           <description>External clock</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>VALUE_1</name>
                           <description>Processor clock</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>COUNTFLAG</name>
                     <description>Timer counted to 0 since last read of register</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>RVR</name>
               <description>SysTick Reload Value Register</description>
               <addressOffset>0x4</addressOffset>
               <size>32</size>
               <fields>
                  <field>
                     <name>RELOAD</name>
                     <description>Value to load into the SysTick Current Value Register when the counter reaches 0</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>24</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CVR</name>
               <description>SysTick Current Value Register</description>
               <addressOffset>0x8</addressOffset>
               <size>32</size>
               <fields>
                  <field>
                     <name>CURRENT</name>
                     <description>Current value at the time the register is accessed</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>24</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CALIB</name>
               <description>SysTick Calibration Value Register</description>
               <addressOffset>0xC</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <resetValue>0</resetValue>
               <fields>
                  <field>
                     <name>TENMS</name>
                     <description>Reload value to use for 10ms timing</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>24</bitWidth>
                  </field>
                  <field>
                     <name>SKEW</name>
                     <description>TENMS is rounded from non-integer ratio</description>
                     <bitOffset>30</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <name>SKEWSelect</name>
                        <enumeratedValue>
                           <name>VALUE_0</name>
                           <description>10ms calibration value is exact</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>VALUE_1</name>
                           <description>10ms calibration value is inexact, because of the clock frequency</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>NOREF</name>
                     <description>No Separate Reference Clock</description>
                     <bitOffset>31</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <name>NOREFSelect</name>
                        <enumeratedValue>
                           <name>VALUE_0</name>
                           <description>The reference clock is provided</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>VALUE_1</name>
                           <description>The reference clock is not provided</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
      <peripheral>
         <name>SystemControl</name>
         <description>System Control Registers</description>
         <groupName>SystemControl</groupName>
         <prependToName>SystemControl_</prependToName>
         <baseAddress>0xE000E000</baseAddress>
         <addressBlock>
            <offset>0</offset>
            <size>0xD8C</size>
            <usage>registers</usage>
         </addressBlock>
         <registers>
            <register>
               <name>ICTR</name>
               <description>Interrupt Controller Type Register</description>
               <addressOffset>0x4</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <fields>
                  <field>
                     <name>INTLINESNUM</name>
                     <bitOffset>0</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>ACTLR</name>
               <description>Auxiliary Control Register</description>
               <addressOffset>0x8</addressOffset>
               <size>32</size>
               <fields>
                  <field>
                     <name>DISMCYCINT</name>
                     <description>Disable interruption of LDM/STM instructions</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DISDEFWBUF</name>
                     <description>Disable wruite buffer use during default memory map accesses</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DISFOLD</name>
                     <description>Disable IT folding</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DISFPCA</name>
                     <description>Disable automatic update of CONTROL.FPCA</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DISOOFP</name>
                     <description>Disable out-of-order FP instructions</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CPUID</name>
               <description>CPUID Base Register</description>
               <addressOffset>0xD00</addressOffset>
               <size>32</size>
               <access>read-only</access>
               <resetValue>0x410FC240</resetValue>
               <fields>
                  <field>
                     <name>REVISION</name>
                     <description>Processor revision number</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>PARTNO</name>
                     <description>Process Part Number, 0xC24=Cortex-M4</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>12</bitWidth>
                  </field>
                  <field>
                     <name>CONSTANT</name>
                     <description>Constant</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>VARIANT</name>
                     <description>Variant number</description>
                     <bitOffset>20</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
                  <field>
                     <name>IMPLEMENTER</name>
                     <description>Implementer code, 0x41=ARM</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>ICSR</name>
               <description>Interrupt Control and State Register</description>
               <addressOffset>0xD04</addressOffset>
               <size>32</size>
               <resetValue>0</resetValue>
               <fields>
                  <field>
                     <name>VECTACTIVE</name>
                     <description>Active exception number</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>9</bitWidth>
                  </field>
                  <field>
                     <name>RETTOBASE</name>
                     <description>No preempted active exceptions to execute</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>VECTPENDING</name>
                     <description>Exception number of the highest priority pending enabled exception</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>6</bitWidth>
                  </field>
                  <field>
                     <name>ISRPENDING</name>
                     <description>Interrupt pending flag</description>
                     <bitOffset>22</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>ISRPREEMPT</name>
                     <description>Debug only</description>
                     <bitOffset>23</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PENDSTCLR</name>
                     <description>SysTick clear-pending bit</description>
                     <bitOffset>25</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <name>PENDSTCLRSelect</name>
                        <enumeratedValue>
                           <name>VALUE_0</name>
                           <description>No effect</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>VALUE_1</name>
                           <description>Removes the pending state from the SysTick exception</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>PENDSTSET</name>
                     <description>SysTick set-pending bit</description>
                     <bitOffset>26</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <name>PENDSTSETSelect</name>
                        <enumeratedValue>
                           <name>VALUE_0</name>
                           <description>Write: no effect; read: SysTick exception is not pending</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>VALUE_1</name>
                           <description>Write: changes SysTick exception state to pending; read: SysTick exception is pending</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>PENDSVCLR</name>
                     <description>PendSV clear-pending bit</description>
                     <bitOffset>27</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <name>PENDSVCLRSelect</name>
                        <enumeratedValue>
                           <name>VALUE_0</name>
                           <description>No effect</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>VALUE_1</name>
                           <description>Removes the pending state from the PendSV exception</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>PENDSVSET</name>
                     <description>PendSV set-pending bit</description>
                     <bitOffset>28</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <name>PENDSVSETSelect</name>
                        <enumeratedValue>
                           <name>VALUE_0</name>
                           <description>Write: no effect; read: PendSV exception is not pending</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>VALUE_1</name>
                           <description>Write: changes PendSV exception state to pending; read: PendSV exception is pending</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>NMIPENDSET</name>
                     <description>NMI set-pending bit</description>
                     <bitOffset>31</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <name>NMIPENDSETSelect</name>
                        <enumeratedValue>
                           <name>VALUE_0</name>
                           <description>Write: no effect; read: NMI exception is not pending</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>VALUE_1</name>
                           <description>Write: changes NMI exception state to pending; read: NMI exception is pending</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
               </fields>
            </register>
            <register>
               <name>AIRCR</name>
               <description>Application Interrupt and Reset Control Register</description>
               <addressOffset>0xD0C</addressOffset>
               <size>32</size>
               <resetValue>0xFA050000</resetValue>
               <fields>
                  <field>
                     <name>VECTRESET</name>
                     <description>Must write 0</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>VECTCLRACTIVE</name>
                     <description>Must write 0</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SYSRESETREQ</name>
                     <description>System Reset Request</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <name>SYSRESETREQSelect</name>
                        <enumeratedValue>
                           <name>VALUE_0</name>
                           <description>No system reset request</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>VALUE_1</name>
                           <description>Asserts a signal to the outer system that requests a reset</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>PRIGROUP</name>
                     <description>Interrupt priority grouping</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>ENDIANNESS</name>
                     <description>Data endianness, 0=little, 1=big</description>
                     <bitOffset>15</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <name>ENDIANNESSSelect</name>
                        <enumeratedValue>
                           <name>VALUE_0</name>
                           <description>Little-endian</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>VALUE_1</name>
                           <description>Big-endian</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>VECTKEY</name>
                     <description>Register key</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>16</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SCR</name>
               <description>System Control Register</description>
               <addressOffset>0xD10</addressOffset>
               <size>32</size>
               <resetValue>0</resetValue>
               <fields>
                  <field>
                     <name>SLEEPONEXIT</name>
                     <description>Sleep-on-exit on handler return</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <name>SLEEPONEXITSelect</name>
                        <enumeratedValue>
                           <name>VALUE_0</name>
                           <description>Do not sleep when returning to Thread mode</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>VALUE_1</name>
                           <description>Enter sleep, or deep sleep, on return from an ISR</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>SLEEPDEEP</name>
                     <description>Deep Sleep used as low power mode</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <name>SLEEPDEEPSelect</name>
                        <enumeratedValue>
                           <name>VALUE_0</name>
                           <description>Sleep</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>VALUE_1</name>
                           <description>Deep sleep</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>SEVONPEND</name>
                     <description>Send Event on Pending bit</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <name>SEVONPENDSelect</name>
                        <enumeratedValue>
                           <name>VALUE_0</name>
                           <description>Only enabled interrupts or events can wakeup the processor, disabled interrupts are excluded</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>VALUE_1</name>
                           <description>Enabled events and all interrupts, including disabled interrupts, can wakeup the processor</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
               </fields>
            </register>
            <register>
               <name>CCR</name>
               <description>Configuration and Control Register</description>
               <addressOffset>0xD14</addressOffset>
               <size>32</size>
               <resetValue>0x00000200</resetValue>
               <fields>
                  <field>
                     <name>NONBASETHRDENA</name>
                     <description>Indicates how processor enters Thread mode</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>USERSETMPEND</name>
                     <description>Enables unprivileged software access to STIR register</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>UNALIGN_TRP</name>
                     <description>Enables unaligned access traps</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <name>UNALIGN_TRPSelect</name>
                        <enumeratedValue>
                           <name>VALUE_0</name>
                           <description>Do not trap unaligned halfword and word accesses</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>VALUE_1</name>
                           <description>Trap unaligned halfword and word accesses</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>DIV_0_TRP</name>
                     <description>Enables divide by 0 trap</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BFHFNMIGN</name>
                     <description>Ignore LDM/STM BusFault for -1/-2 priority handlers</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>STKALIGN</name>
                     <description>Indicates stack alignment on exception entry</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <name>STKALIGNSelect</name>
                        <enumeratedValue>
                           <name>VALUE_0</name>
                           <description>4-byte aligned</description>
                           <value>0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>VALUE_1</name>
                           <description>8-byte aligned</description>
                           <value>1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
               </fields>
            </register>
            <register>
               <name>SHPR1</name>
               <description>System Handler Priority Register 1</description>
               <addressOffset>0xD18</addressOffset>
               <size>32</size>
               <fields>
                  <field>
                     <name>PRI_4</name>
                     <description>Priority of system handler 4, MemManage</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>PRI_5</name>
                     <description>Priority of system handler 5, BusFault</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>PRI_6</name>
                     <description>Priority of system handler 6, UsageFault</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SHPR2</name>
               <description>System Handler Priority Register 2</description>
               <addressOffset>0xD1C</addressOffset>
               <size>32</size>
               <resetValue>0</resetValue>
               <fields>
                  <field>
                     <name>PRI_11</name>
                     <description>Priority of system handler 11, SVCall</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SHPR3</name>
               <description>System Handler Priority Register 3</description>
               <addressOffset>0xD20</addressOffset>
               <size>32</size>
               <resetValue>0</resetValue>
               <fields>
                  <field>
                     <name>PRI_14</name>
                     <description>Priority of system handler 14, PendSV</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
                  <field>
                     <name>PRI_15</name>
                     <description>Priority of system handler 15, SysTick exception</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>8</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>SHCSR</name>
               <description>System Handler Control and State Register</description>
               <addressOffset>0xD24</addressOffset>
               <size>32</size>
               <fields>
                  <field>
                     <name>MEMFAULTACT</name>
                     <description>MemManage exception active bit</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BUSFAULTACT</name>
                     <description>BusFault exception active bit</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>USGFAULTACT</name>
                     <description>UsageFault exception active bit</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SVCALLACT</name>
                     <description>SVCall active bit</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MONITORACT</name>
                     <description>DebugMonitor exception active bit</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PENDSVACT</name>
                     <description>PendSV exception active bit</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SYSTICKACT</name>
                     <description>SysTick exception active bit</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>USGFAULTPENDED</name>
                     <description>UsageFault exception pending bit</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MEMFAULTPENDED</name>
                     <description>MemManage exception pending bit</description>
                     <bitOffset>13</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BUSFAULTPENDED</name>
                     <description>BusFault exception pending bit</description>
                     <bitOffset>14</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>SVCALLPENDED</name>
                     <description>SVCall pending bit</description>
                     <bitOffset>15</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MEMFAULTENA</name>
                     <description>MemManage enable bit</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BUSFAULTENA</name>
                     <description>BusFault enable bit</description>
                     <bitOffset>17</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>USGFAULTENA</name>
                     <description>UsageFault enable bit</description>
                     <bitOffset>18</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CFSR</name>
               <description>Configurable Fault Status Register</description>
               <addressOffset>0xD28</addressOffset>
               <size>32</size>
               <fields>
                  <field>
                     <name>IACCVIOL</name>
                     <description>Instruction access violation</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DACCVIOL</name>
                     <description>Data access violation</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MUNSTKERR</name>
                     <description>MemManage Fault on unstacking for exception return</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MSTKERR</name>
                     <description>MemManage Fault on stacking for exception entry</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MLSPERR</name>
                     <description>MemManager Fault occured during FP lazy state preservation</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>MMARVALID</name>
                     <description>MemManage Fault Address Register valid</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>IBUSERR</name>
                     <description>Instruction bus error</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>PRECISERR</name>
                     <description>Precise data bus error</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>IMPRECISERR</name>
                     <description>Imprecise data bus error</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>UNSTKERR</name>
                     <description>BusFault on unstacking for exception return</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>STKERR</name>
                     <description>BusFault on stacking for exception entry</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>LSPERR</name>
                     <description>BusFault occured during FP lazy state preservation</description>
                     <bitOffset>13</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BFARVALID</name>
                     <description>BusFault Address Register valid</description>
                     <bitOffset>15</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>UNDEFINSTR</name>
                     <description>Undefined instruction UsageFault</description>
                     <bitOffset>16</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>INVSTATE</name>
                     <description>Invalid state UsageFault</description>
                     <bitOffset>17</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>INVPC</name>
                     <description>Invalid PC load UsageFault</description>
                     <bitOffset>18</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>NOCP</name>
                     <description>No coprocessor UsageFault</description>
                     <bitOffset>19</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>UNALIGNED</name>
                     <description>Unaligned access UsageFault</description>
                     <bitOffset>24</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DIVBYZERO</name>
                     <description>Divide by zero UsageFault</description>
                     <bitOffset>25</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>HFSR</name>
               <description>HardFault Status Register</description>
               <addressOffset>0xD2C</addressOffset>
               <size>32</size>
               <fields>
                  <field>
                     <name>VECTTBL</name>
                     <description>BusFault on a Vector Table read during exception processing</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>FORCED</name>
                     <description>Forced Hard Fault</description>
                     <bitOffset>30</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DEBUGEVT</name>
                     <description>Debug: always write 0</description>
                     <bitOffset>31</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>DFSR</name>
               <description>Debug Fault Status Register</description>
               <addressOffset>0xD30</addressOffset>
               <size>32</size>
               <fields>
                  <field>
                     <name>HALTED</name>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>BKPT</name>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>DWTTRAP</name>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>VCATCH</name>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>EXTERNAL</name>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>MMFAR</name>
               <description>MemManage Fault Address Register</description>
               <addressOffset>0xD34</addressOffset>
               <size>32</size>
               <fields>
                  <field>
                     <name>ADDRESS</name>
                     <description>Address that generated the MemManage fault</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BFAR</name>
               <description>BusFault Address Register</description>
               <addressOffset>0xD38</addressOffset>
               <size>32</size>
               <fields>
                  <field>
                     <name>ADDRESS</name>
                     <description>Address that generated the BusFault</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>AFSR</name>
               <description>Auxiliary Fault Status Register</description>
               <addressOffset>0xD3C</addressOffset>
               <size>32</size>
               <fields>
                  <field>
                     <name>IMPDEF</name>
                     <description>AUXFAULT input signals</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>32</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>2</dim>
               <dimIncrement>4</dimIncrement>
               <name>PFR[%s]</name>
               <description>Processor Feature Register</description>
               <addressOffset>0xD40</addressOffset>
               <size>32</size>
            </register>
            <register>
               <name>DFR</name>
               <description>Debug Feature Register</description>
               <addressOffset>0xD48</addressOffset>
               <size>32</size>
               <access>read-only</access>
            </register>
            <register>
               <name>ADR</name>
               <description>Auxiliary Feature Register</description>
               <addressOffset>0xD4C</addressOffset>
               <size>32</size>
               <access>read-only</access>
            </register>
            <register>
               <dim>4</dim>
               <dimIncrement>4</dimIncrement>
               <name>MMFR[%s]</name>
               <description>Memory Model Feature Register</description>
               <addressOffset>0xD50</addressOffset>
               <size>32</size>
               <access>read-only</access>
            </register>
            <register>
               <dim>5</dim>
               <dimIncrement>4</dimIncrement>
               <name>ISAR[%s]</name>
               <description>Instruction Set Attributes Register</description>
               <addressOffset>0xD60</addressOffset>
               <size>32</size>
               <access>read-only</access>
            </register>
            <register>
               <name>CPACR</name>
               <description>Coprocessor Access Control Register</description>
               <addressOffset>0xD88</addressOffset>
               <size>32</size>
               <fields>
                  <field>
                     <name>CP10</name>
                     <description>Access privileges for coprocessor 10</description>
                     <bitOffset>20</bitOffset>
                     <bitWidth>2</bitWidth>
                     <enumeratedValues>
                        <name>CP10Select</name>
                        <enumeratedValue>
                           <name>DENIED</name>
                           <description>Access denied</description>
                           <value>0x0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>PRIV</name>
                           <description>Privileged access only</description>
                           <value>0x1</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>FULL</name>
                           <description>Full access</description>
                           <value>0x3</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>CP11</name>
                     <description>Access privileges for coprocessor 11</description>
                     <bitOffset>22</bitOffset>
                     <bitWidth>2</bitWidth>
                     <enumeratedValues>
                        <name>CP11Select</name>
                        <enumeratedValue>
                           <name>DENIED</name>
                           <description>Access denied</description>
                           <value>0x0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>PRIV</name>
                           <description>Privileged access only</description>
                           <value>0x1</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>FULL</name>
                           <description>Full access</description>
                           <value>0x3</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>
   </peripherals>
</device>
