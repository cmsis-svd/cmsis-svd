<?xml version="1.0" encoding="utf-8"?>
<device schemaVersion="1.1" xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" xs:noNamespaceSchemaLocation="CMSIS-SVD_Schema_1_1.xsd">
	<vendor>Maxim Integrated</vendor>
	
	<vendorID>Maxim</vendorID>
	<name>MAX32550</name>
	<version>1.0</version>
	<description>32-bit ARM Cortex-M3 microcontroller, 1MB of flash, 256KB of system RAM, 4KB of One-Time-Programmable (OTP) memory, 64KB of Boot ROM, 8KB of battery-backed and AES self-encrypted SRAM.</description>
	<addressUnitBits>8</addressUnitBits>
	<width>32</width>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xFFFFFFFF</resetMask>
	<peripherals>
		<peripheral>
			<name>GlobalControl</name>
			<description>Registers controlling global functions</description>
			<baseAddress>0x40000000</baseAddress>
			<registers>
				<register>
					<name>SCON</name>
					<description>System Control</description>
					<addressOffset>0x00</addressOffset>
					<resetMask>0xFFFFFFFE</resetMask>
					<fields>
						<field>
							<name>BSTAPEN</name>
							<description>Boundary Scan TAP enable. When enabled, the JTAG port is connected to the Boundary Scan TAP. Otherwise, the port is connected to the ARM ICE function. This bit is reset by the POR. Reset value and access depend on the part number.</description>
							<lsb>0</lsb>
							<msb>0</msb>
							<enumeratedValues>
								<name>dis_en_enum</name>
								<enumeratedValue>
									<name>disable</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>enable</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>ONVMAIN</name>
							<description>Battery supply source flag</description>
							<lsb>3</lsb>
							<msb>3</msb>
							<enumeratedValues>
								<name>batt_supply_enum</name>
								<enumeratedValue>
									<name>vBat</name>
									<description>VBAT is selected to supply battery supply.</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>vMain</name>
									<description>VMAIN is selected to supply battery supply.</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>FLASH_PAGE_FLIP</name>
							<description>Flips the Flash bottom and top halves. (Depending on the total flash size, each half is either 256K or 512K). Initiating a flash page flip will cause a flush of both the data buffer on the DCODE bus and the internal instruction buffer.</description>
							<lsb>4</lsb>
							<msb>4</msb>
							<enumeratedValues>
								<name>flash_flip_enum</name>
								<enumeratedValue>
									<name>normal</name>
									<description>Physical layout matches logical layout.</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>swapped</name>
									<description>Bottom half mapped to logical top half and vice versa.</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>CCHK</name>
							<description>Compute ROM Checksum. This bit is self-cleared when calculation is completed. Once set, software clearing this bit is ignored and the bit will remain set until the operation is completed.</description>
							<lsb>13</lsb>
							<msb>13</msb>
							<enumeratedValues>
								<name>start_op_enum</name>
								<enumeratedValue>
									<name>complete</name>
									<description>No operation/complete</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>start</name>
									<description>Start operation</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>CHKRD</name>
							<description>ROM Checksum Ready. This bit is self-cleared when a new checksum calculation is started (CCHK is set).</description>
							<lsb>14</lsb>
							<msb>14</msb>
							<enumeratedValues>
								<name>op_status_enum</name>
								<enumeratedValue>
									<name>busy</name>
									<description>Result not ready</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>ready</name>
									<description>Operation complete and result ready</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>CHKRES</name>
							<description>ROM Checksum Result. This bit is only valid when CHKRD=1.</description>
							<lsb>15</lsb>
							<msb>15</msb>
							<enumeratedValues>
								<name>pass_fail_enum</name>
								<enumeratedValue>
									<name>pass</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>fail</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
					</fields>
				</register>
				<register>
					<name>RSTR</name>
					<description>Reset</description>
					<addressOffset>0x04</addressOffset>
					<fields>
						<field>
							<name>DMA</name>
							<description>DMA Reset</description>
							<lsb>0</lsb>
							<msb>0</msb>
							<enumeratedValues>
								<name>reset_write_enum</name>
								<usage>write</usage>
								<enumeratedValue>
									<name>RFU</name>
									<description>Reserved. Do not use.</description>
									<isDefault>true</isDefault>
								</enumeratedValue>
								<enumeratedValue>
									<name>reset</name>
									<description>Starts reset operation</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
							<enumeratedValues>
								<name>reset_read_enum</name>
								<usage>read</usage>
								<enumeratedValue>
									<name>reset</name>
									<description>Reset complete</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>busy</name>
									<description>Reset in progress</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="DMA">
							<name>WDT</name>
							<description>Watchdog Timer Reset</description>
							<lsb>1</lsb>
							<msb>1</msb>
						</field>
						<field derivedFrom="DMA">
							<name>GPIO0</name>
							<description>GPIO0 Reset. Setting this bit to 1 resets GPIO0 pins to their default states.</description>
							<lsb>2</lsb>
							<msb>2</msb>
						</field>
						<field derivedFrom="DMA">
							<name>GPIO1</name>
							<description>GPIO1 Reset. Setting this bit to 1 resets GPIO1 pins to their default states.</description>
							<lsb>3</lsb>
							<msb>3</msb>
						</field>
						<field derivedFrom="DMA">
							<name>GPIO2</name>
							<description>GPIO2 Reset. Setting this bit to 1 resets GPIO2 pins to their default states.</description>
							<lsb>4</lsb>
							<msb>4</msb>
						</field>
						<field derivedFrom="DMA">
							<name>TIMER0</name>
							<description>Timer0 Reset. Setting this bit to 1 resets Timer 0 blocks.</description>
							<lsb>5</lsb>
							<msb>5</msb>
						</field>
						<field derivedFrom="DMA">
							<name>TIMER1</name>
							<description>Timer1 Reset. Setting this bit to 1 resets Timer 1 blocks.</description>
							<lsb>6</lsb>
							<msb>6</msb>
						</field>
						<field derivedFrom="DMA">
							<name>TIMER2</name>
							<description>Timer2 Reset. Setting this bit to 1 resets Timer 2 blocks.</description>
							<lsb>7</lsb>
							<msb>7</msb>
						</field>
						<field derivedFrom="DMA">
							<name>TIMER3</name>
							<description>Timer3 Reset. Setting this bit to 1 resets Timer 3 blocks.</description>
							<lsb>8</lsb>
							<msb>8</msb>
						</field>
						<field derivedFrom="DMA">
							<name>TIMER4</name>
							<description>Timer4 Reset. Setting this bit to 1 resets Timer 4 blocks.</description>
							<lsb>9</lsb>
							<msb>9</msb>
						</field>
						<field derivedFrom="DMA">
							<name>TIMER5</name>
							<description>Timer5 Reset. Setting this bit to 1 resets Timer 5 blocks.</description>
							<lsb>10</lsb>
							<msb>10</msb>
						</field>
						<field derivedFrom="DMA">
							<name>UART0</name>
							<description>UART0 Reset. Setting this bit to 1 resets all UART 0 blocks.</description>
							<lsb>11</lsb>
							<msb>11</msb>
						</field>
						<field derivedFrom="DMA">
							<name>SPI0</name>
							<description>SPI0 Reset. Setting this bit to 1 resets all SPI 0 blocks.</description>
							<lsb>13</lsb>
							<msb>13</msb>
						</field>
						<field derivedFrom="DMA">
							<name>SPI1</name>
							<description>SPI1 Reset. Setting this bit to 1 resets all SPI 1 blocks.</description>
							<lsb>14</lsb>
							<msb>14</msb>
						</field>
						<field derivedFrom="DMA">
							<name>SPI2</name>
							<description>SPI2 Reset. Setting this bit to 1 resets all SPI 2 blocks.</description>
							<lsb>15</lsb>
							<msb>15</msb>
						</field>
						<field derivedFrom="DMA">
							<name>I2C</name>
							<description>I2C Reset</description>
							<lsb>16</lsb>
							<msb>16</msb>
						</field>
						<field derivedFrom="DMA">
							<name>RTC</name>
							<description>Real Time Clock Reset</description>
							<lsb>17</lsb>
							<msb>17</msb>
						</field>
						<field derivedFrom="DMA">
							<name>CRYPTO</name>
							<description>Cryptographic Reset. Setting this bit to 1 resets the AES block, the SHA block and the DES block.</description>
							<lsb>18</lsb>
							<msb>18</msb>
						</field>
						<field derivedFrom="DMA">
							<name>MAGDSP</name>
							<description>Magnetic Strip Reader Reset</description>
							<lsb>19</lsb>
							<msb>19</msb>
						</field>
						<field derivedFrom="DMA">
							<name>SC</name>
							<description>Smart Card Reader Reset</description>
							<lsb>20</lsb>
							<msb>20</msb>
						</field>
						<field derivedFrom="DMA">
							<name>KBD</name>
							<description>Secure Keypad Reset</description>
							<lsb>21</lsb>
							<msb>21</msb>
						</field>
						<field derivedFrom="DMA">
							<name>TFT_LCD</name>
							<description>TFT/LCD Reset. Setting this bit to 1 resets both the TFT and mono LCD blocks.</description>
							<lsb>22</lsb>
							<msb>22</msb>
						</field>
						<field derivedFrom="DMA">
							<name>USB</name>
							<description>USB Reset. Setting this bit resets both USB blocks.</description>
							<lsb>23</lsb>
							<msb>23</msb>
						</field>
						<field derivedFrom="DMA">
							<name>ADC</name>
							<description>Analog to Digital Reset</description>
							<lsb>25</lsb>
							<msb>25</msb>
						</field>
						<field derivedFrom="DMA">
							<name>DAC</name>
							<description>Digital to Analog Reset</description>
							<lsb>26</lsb>
							<msb>26</msb>
						</field>
						<field derivedFrom="DMA">
							<name>SRST</name>
							<description>Soft Reset. Setting this bit to 1 resets everything except the CPU and the watchdog timer.</description>
							<lsb>29</lsb>
							<msb>29</msb>
						</field>
						<field derivedFrom="DMA">
							<name>PRST</name>
							<description>Peripheral Reset. Setting this bit to 1 resets all peripherals. The CPU core, the watchdog timer, and all GPIO pins are unaffected by this reset.</description>
							<lsb>30</lsb>
							<msb>30</msb>
						</field>
						<field derivedFrom="DMA">
							<name>SYSTEM</name>
							<description>System Reset. Setting this bit to 1 resets the CPU core and all peripherals, including the watchdog timer.</description>
							<lsb>31</lsb>
							<msb>31</msb>
						</field>
					</fields>
				</register>
				<register>
					<name>CLKCN</name>
					<description>Clock Control</description>
					<addressOffset>0x08</addressOffset>
					<resetValue>0x00000008</resetValue>
					<fields>
						<field>
							<name>PSC</name>
							<description>Prescaler Select. This 3 bit field sets the system operating frequency by controlling the prescaler that divides the output of the PLL0.</description>
							<lsb>6</lsb>
							<msb>8</msb>
							<enumeratedValues>
								<name>clk_div_enum</name>
								<enumeratedValue>
									<name>div1</name>
									<description>Divide by 1</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>div2</name>
									<description>Divide by 2</description>
									<value>1</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>div4</name>
									<description>Divide by 4</description>
									<value>2</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>div8</name>
									<description>Divide by 8</description>
									<value>3</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>div16</name>
									<description>Divide by 16</description>
									<value>4</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>div32</name>
									<description>Divide by 32</description>
									<value>5</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>div64</name>
									<description>Divide by 64</description>
									<value>6</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>div128</name>
									<description>Divide by 128</description>
									<value>7</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>CLKSEL</name>
							<description>Clock Source Select. This 3 bit field selects the source for the system clock.</description>
							<lsb>9</lsb>
							<msb>11</msb>
							<enumeratedValues>
								<name>clk_sel_enum</name>
								<enumeratedValue>
									<name>cryptoOsc</name>
									<description>Crypto oscillator is used for the system clock.</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>pllOutput</name>
									<description>The PLL output is used for the system clock.</description>
									<value>1</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>hfxIn</name>
									<description>HFXIN is used for the system clock.</description>
									<value>2</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>nanoRing</name>
									<description>The nano-ring output is used for the system clock.</description>
									<value>3</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>RFU</name>
									<description>Reserved. Do not use.</description>
									<isDefault>true</isDefault>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>CKRDY</name>
							<description>Clock Ready. This read only bit reflects whether the currently selected system clock source is running.</description>
							<lsb>13</lsb>
							<msb>13</msb>
							<access>read-only</access>
							<enumeratedValues>
								<name>op_status_enum</name>
								<enumeratedValue>
									<name>busy</name>
									<description>Result not ready</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>ready</name>
									<description>Operation complete and result ready</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
					</fields>
				</register>
				<register>
					<name>PM</name>
					<description>Power Management</description><addressOffset>0x0C</addressOffset>
					<fields>
						<field>
							<name>MODE</name>
							<description>Operating Mode. This two bit field selects the current operating mode for the device. Note that code execution only occurs during ACTIVE mode.</description>
							<lsb>0</lsb>
							<msb>1</msb>
							<enumeratedValues>
								<name>op_mode_enum</name>
								<enumeratedValue>
									<name>active</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>idle</name>
									<value>1</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>standby</name>
									<value>2</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>shutdown</name>
									<value>3</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>GPIOWKEN</name>
							<description>GPIO Wake Up Enable. This bit enables all GPIO pins as potential wakeup sources. Any GPIO configured for wakeup is capable of causing an exit from IDLE or STANDBY modes when this bit is set.</description>
							<lsb>4</lsb>
							<msb>4</msb>
							<enumeratedValues>
								<name>dis_en_enum</name>
								<enumeratedValue>
									<name>disable</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>enable</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="GPIOWKEN">
							<name>RTCWKEN</name>
							<description>RTC Alarm Wake Up Enable. This bit enables RTC alarm as wakeup source. If enabled, the desired RTC alarm must be configured via the RTC control registers.</description>
							<lsb>5</lsb>
							<msb>5</msb>
						</field>
						<field derivedFrom="GPIOWKEN">
							<name>USBWKEN</name>
							<description>USB Wake Up Enable. This bit enables USB activity as wakeup source.</description>
							<lsb>6</lsb>
							<msb>6</msb>
						</field>
						<field derivedFrom="GPIOWKEN">
							<name>SCWKEN</name>
							<description>Smart Card Wake Up Enable. This bit enables Smart Card activity as a wakeup source.</description>
							<lsb>7</lsb>
							<msb>7</msb>
						</field>
						<field derivedFrom="GPIOWKEN">
							<name>OSCPD</name>
							<description>External Oscillator Power Down. Setting this bit prior to entering the STANDBY mode, powers down the External Oscillator circuit.</description>
							<lsb>12</lsb>
							<msb>12</msb>
						</field>
						<field>
							<name>PLL01PD</name>
							<description>PLL0/1 Power Down. This bit selects PLL power state in STANDBY mode.</description>
							<lsb>13</lsb>
							<msb>13</msb>
							<enumeratedValues>
								<name>powered_enum</name>
								<enumeratedValue>
									<name>active</name>
									<description>In active mode</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>standBy</name>
									<description>In standby mode</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="PLL01PD">
							<name>COPD</name>
							<description>Crypto Oscillator Power Down. This bit selects crypto oscillator power state in STANDBY mode.</description>
							<lsb>14</lsb>
							<msb>14</msb>
						</field>
						<field derivedFrom="GPIOWKEN">
							<name>CM3PMUEN</name>
							<description>CM3 Power Management Enable.  Setting this bit will allow the CM3_DEEPSLEEP or CM3_SLEEPING state to put the device into STANDBY mode.</description>
							<lsb>16</lsb>
							<msb>16</msb>
						</field>
						<field>
							<name>CM3WICACK</name>
							<description>CM3 WIC Acknowledge.  This status bit reflects the state of the CM3 WIC acknowledge to PMU request.</description>
							<lsb>17</lsb>
							<msb>17</msb>
							<access>read-only</access>
						</field>
					</fields>
				</register>
				<register>
					<dim>2</dim>
					<dimIncrement>4</dimIncrement>
					<name>PLL%sCN</name>
					<description>PLL Control</description>
					<addressOffset>0x10</addressOffset>
					<fields>
						<field>
							<name>PLLxEN</name>
							<description>PLL Enable. This bit enables system PLL for clock multiplication.</description>
							<lsb>0</lsb>
							<msb>0</msb>
							<enumeratedValues>
								<name>dis_en_enum</name>
								<enumeratedValue>
									<name>disable</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>enable</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>PLLxLOCK</name>
							<description>PLL Lock. This bit is set by hardware when the PLL is locked to the input clock. It is cleared when the PLL is disabled, lock is not yet achieved or when the lock is lost.</description>
							<lsb>1</lsb>
							<msb>1</msb>
							<access>read-only</access>
							<enumeratedValues>
								<name>locked_enum</name>
								<usage>read</usage>
								<enumeratedValue>
									<name>unlocked</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>locked</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
					</fields>
				</register>
				<register>
					<name>PCKDIV</name>
					<description>Peripheral Clock Divider</description>
					<addressOffset>0x18</addressOffset>
					<resetValue>0x00000003</resetValue>
					<fields>
						<field>
							<name>PCF</name>
							<description>These bits determine the clock frequency for the UART, I2C and Key Pad peripherals. These peripherals have an adaptive clock generator that dynamically adjusts the peripheral frequency based on the main system bus frequency. These bits are dynamically updated when the PLL0 is selected as the system clock source and are set by hardware. These bits determine the clock frequency for the UART, I2C and Key Pad peripherals. These peripherals have an adaptive clock generator that dynamically adjusts the peripheral frequency based on the main system bus frequency. These bits are dynamically updated when the PLL0 is selected as the system clock source and are set by hardware.</description>
							<lsb>0</lsb>
							<msb>2</msb>
						</field>
					</fields>
				</register>
				<register>
					<name>PERCKCN</name>
					<description>Peripheral Clock Disable</description>
					<addressOffset>0x24</addressOffset>
					<fields>
						<field>
							<name>GPIO0D</name>
							<description>GPIO0 Disable</description>
							<lsb>0</lsb>
							<msb>0</msb>
							<enumeratedValues>
								<name>en_dis_enum</name>
								<enumeratedValue>
									<name>enable</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>disable</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="GPIO0D">
							<name>GPIO1D</name>
							<description>GPIO1 Disable</description>
							<lsb>1</lsb>
							<msb>1</msb>
						</field>
						<field derivedFrom="GPIO0D">
							<name>GPIO2D</name>
							<description>GPIO2 Disable</description>
							<lsb>2</lsb>
							<msb>2</msb>
						</field>
						<field derivedFrom="GPIO0D">
							<name>USBD</name>
							<description>USB Disable</description>
							<lsb>3</lsb>
							<msb>3</msb>
						</field>
						<field derivedFrom="GPIO0D">
							<name>CLCDD</name>
							<description>Color LCD Controller Disable</description>
							<lsb>4</lsb>
							<msb>4</msb>
						</field>
						<field derivedFrom="GPIO0D">
							<name>DMAD</name>
							<description>DMA Disable</description>
							<lsb>5</lsb>
							<msb>5</msb>
						</field>
						<field derivedFrom="GPIO0D">
							<name>SPI0D</name>
							<description>SPI 0 Disable</description>
							<lsb>6</lsb>
							<msb>6</msb>
						</field>
						<field derivedFrom="GPIO0D">
							<name>SPI1D</name>
							<description>SPI 1 Disable</description>
							<lsb>7</lsb>
							<msb>7</msb>
						</field>
						<field derivedFrom="GPIO0D">
							<name>SPI2D</name>
							<description>SPI 2 Disable</description>
							<lsb>8</lsb>
							<msb>8</msb>
						</field>
						<field derivedFrom="GPIO0D">
							<name>UART0D</name>
							<description>UART 0 Disable</description>
							<lsb>9</lsb>
							<msb>9</msb>
						</field>
						<field derivedFrom="GPIO0D">
							<name>UART1D</name>
							<description>UART 1 Disable</description>
							<lsb>10</lsb>
							<msb>10</msb>
						</field>
						<field derivedFrom="GPIO0D">
							<name>MAGDSPD</name>
							<description>Magnetic Stripe DSP Disable</description>
							<lsb>11</lsb>
							<msb>11</msb>
						</field>
						<field derivedFrom="GPIO0D">
							<name>SCD</name>
							<description>Smart Card Disable</description>
							<lsb>12</lsb>
							<msb>12</msb>
						</field>
						<field derivedFrom="GPIO0D">
							<name>I2CD</name>
							<description>I2C Disable</description>
							<lsb>13</lsb>
							<msb>13</msb>
						</field>
						<field derivedFrom="GPIO0D">
							<name>CRYPTOD</name>
							<description>Crypto Disable</description>
							<lsb>14</lsb>
							<msb>14</msb>
						</field>
						<field derivedFrom="GPIO0D">
							<name>T0D</name>
							<description>Timer 0 Disable</description>
							<lsb>15</lsb>
							<msb>15</msb>
						</field>
						<field derivedFrom="GPIO0D">
							<name>T1D</name>
							<description>Timer 1 Disable</description>
							<lsb>16</lsb>
							<msb>16</msb>
						</field>
						<field derivedFrom="GPIO0D">
							<name>T2D</name>
							<description>Timer 2 Disable</description>
							<lsb>17</lsb>
							<msb>17</msb>
						</field>
						<field derivedFrom="GPIO0D">
							<name>T3D</name>
							<description>Timer 3 Disable</description>
							<lsb>18</lsb>
							<msb>18</msb>
						</field>
						<field derivedFrom="GPIO0D">
							<name>T4D</name>
							<description>Timer 4 Disable</description>
							<lsb>19</lsb>
							<msb>19</msb>
						</field>
						<field derivedFrom="GPIO0D">
							<name>T5D</name>
							<description>Timer 5 Disable</description>
							<lsb>20</lsb>
							<msb>20</msb>
						</field>
						<field derivedFrom="GPIO0D">
							<name>MLCDD</name>
							<description>Mono LCD Disable</description>
							<lsb>21</lsb>
							<msb>21</msb>
						</field>
						<field derivedFrom="GPIO0D">
							<name>KBDD</name>
							<description>Keypad Disable</description>
							<lsb>22</lsb>
							<msb>22</msb>
						</field>
						<field derivedFrom="GPIO0D">
							<name>ADCC</name>
							<description>ADC Disable</description>
							<lsb>23</lsb>
							<msb>23</msb>
						</field>
						<field derivedFrom="GPIO0D">
							<name>DACD</name>
							<description>DAC Disable</description>
							<lsb>24</lsb>
							<msb>24</msb>
						</field>
					</fields>
				</register>
				<register>
					<name>MEMZCN</name>
					<description>Memory Zeroize Control</description><addressOffset>0x2C</addressOffset>
					<fields>
						<field>
							<name>SRAM0</name>
							<description>System RAM Block 0</description>
							<lsb>0</lsb>
							<msb>0</msb>
							<enumeratedValues>
								<name>start_op_enum</name>
								<enumeratedValue>
									<name>nop</name>
									<description>No operation/complete</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>start</name>
									<description>Start operation</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="SRAM0">
							<name>SRAM1</name>
							<description>System RAM Block 1</description>
							<lsb>1</lsb>
							<msb>1</msb>
						</field>
						<field derivedFrom="SRAM0">
							<name>ICACHE</name>
							<description>Instruction Cache</description>
							<lsb>3</lsb>
							<msb>3</msb>
						</field>
						<field derivedFrom="SRAM0">
							<name>CRYPTO</name>
							<description>Crypto (MAA) Memory</description>
							<lsb>5</lsb>
							<msb>5</msb>
						</field>
					</fields>
				</register>
				<register>
					<name>SCCK</name>
					<description>Smart Card Clock Control</description><addressOffset>0x34</addressOffset>
					<resetValue>0x00000014</resetValue>
					<fields>
						<field>
							<name>SC0FRQ</name>
							<description>Smart Card 0 Clock Frequency.  These bits  define Smart Card 0 clock frequency.  f_SC0 = f_PLL1 / SC0FRQ</description>
							<lsb>0</lsb>
							<msb>5</msb>
						</field>
					</fields>
				</register>
			</registers>
			<addressBlock>
				<offset>0</offset>
				<size>0x400</size>
				<usage>registers</usage>
			</addressBlock>
		</peripheral>
		<peripheral>
			<name>SystemInitialization</name>
			<description>System Initialization Registers</description>
			<baseAddress>0x40000400</baseAddress>
			<registers>
				<register>
					<name>SISTAT</name>
					<description>System Initialization Status Register</description>
					<addressOffset>0x00</addressOffset>
					<fields>
						<field>
							<name>MAGIC</name>
							<description>Magic Word Validation.  This bit is set by the system initialization block following power-up.</description>
							<lsb>0</lsb>
							<msb>0</msb>
							<enumeratedValues>
								<name>magic_valid_enum</name>
								<usage>read</usage>
								<enumeratedValue>
									<name>magicNotSet</name>
									<description>Magic word was not set (OTP has not been initialized properly).</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>magicSet</name>
									<description>Magic word was set (OTP contains valid settings).</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>CRCERR</name>
							<description>CRC Error Status.  This bit is set by the system initialization block following power-up.</description>
							<lsb>1</lsb>
							<msb>1</msb>
							<enumeratedValues>
								<name>error_enum</name>
								<usage>read</usage>
								<enumeratedValue>
									<name>noError</name>
									<description>No CRC errors occurred during the read of the OTP memory block.</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>error</name>
									<description>A CRC error occurred while reading the OTP. The address of the failure location in the OTP memory is stored in the ERRADDR register.</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
					</fields>
				</register>
				<register>
					<name>ERRADDR</name>
					<description>Read-only field set by the SIB block if a CRC error occurs during the read of the OTP memory. Contains the failing address in OTP memory (when CRCERR equals 1).</description>
					<addressOffset>0x04</addressOffset>
				</register>
			</registers>
			<access>read-only</access>
			<addressBlock>
				<offset>0x00</offset>
				<size>0x400</size>
				<usage>registers</usage>
			</addressBlock>
		</peripheral>
		<peripheral>
			<name>InstructionCacheController</name>
			<description>Registers to control the instruction cache</description>
			<baseAddress>0x4002A000</baseAddress>
			<registers>
				<register>
					<name>CACHE_ID</name>
					<description>Cache ID Register</description>
					<addressOffset>0x0000</addressOffset>
					<access>read-only</access>
					<fields>
						<field>
							<name>RELNUM</name>
							<description>Release Number. Identifies the RTL release version.</description>
							<lsb>0</lsb>
							<msb>5</msb>
						</field>
						<field>
							<name>PARTNUM</name>
							<description>Part Number. This field reflects the value of C_ID_PART_NUMBER configuration parameter.</description>
							<lsb>6</lsb>
							<msb>9</msb>
						</field>
						<field>
							<name>CCHID</name>
							<description>Cache ID. This field reflects the value of the C_ID_CACHEID configuration parameter.</description>
							<lsb>10</lsb>
							<msb>15</msb>
						</field>
					</fields>
				</register>
				<register>
					<name>MEMCFG</name>
					<description>Memory Configuration Register</description>
					<addressOffset>0x0004</addressOffset>
					<access>read-only</access>
					<resetValue>0x00080008</resetValue>
					<fields>
						<field>
							<name>CCHSZ</name>
							<description>Cache Size. Indicates total size in Kbytes of cache.</description>
							<lsb>0</lsb>
							<msb>15</msb>
						</field>
						<field>
							<name>MEMSZ</name>
							<description>Main Memory Size. Indicates the total size, in units of 128 Kbytes, of code memory accessible to the cache controller.</description>
							<lsb>16</lsb>
							<msb>31</msb>
						</field>
					</fields>
				</register>
				<register>
					<name>CACHE_CTRL</name>
					<description>Cache Control and Status Register</description>
					<addressOffset>0x0100</addressOffset>
					<fields>
						<field>
							<name>CACHE_EN</name>
							<description>Cache Enable. Controls whether the cache is bypassed or is in use. Changing the state of this bit will cause the instruction cache to be flushed and its contents invalidated.</description>
							<lsb>0</lsb>
							<msb>0</msb>
							<enumeratedValues>
								<name>dis_en_enum</name>
								<enumeratedValue>
									<name>disable</name>
									<description>Cache Bypassed. Instruction data is stored in the line fill buffer but is not written to main cache memory array.</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>enable</name>
									<description>Cache Enabled</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>CACHE_RDY</name>
							<description>Cache Ready flag. Cleared by hardware when at any time the cache as a whole is invalidated (including a system reset). When this bit is 0, the cache is effectively in bypass mode (instruction fetches will come from main memory or from the line fill buffer). Set by hardware when the invalidate operation is complete and the cache is ready.</description>
							<lsb>16</lsb>
							<msb>16</msb>
							<enumeratedValues>
								<name>ready_enum</name>
								<enumeratedValue>
									<name>notReady</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>ready</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
					</fields>
				</register>
				<register>
					<name>INVALIDATE</name>
					<description>Invalidate All Registers</description>
					<addressOffset>0x0700</addressOffset>
				</register>
			</registers>
			<addressBlock>
				<offset>0x00</offset>
				<size>0x1000</size>
				<usage>registers</usage>
			</addressBlock>
		</peripheral>
		<peripheral>
			<name>GPIO_0</name>
			<description>Individual I/O for Port 0</description>
			<prependToName>GPIO0_</prependToName>
			<baseAddress>0x40008000</baseAddress>
			<interrupt><name>GPIO0</name><value>24</value></interrupt>
			<registers>
				<register>
					<name>EN</name>
					<description>GPIO Function Enable Register. Each bit controls the GPIO_EN setting for one GPIO pin on the associated port.</description>
					<addressOffset>0x00</addressOffset>
					<resetValue>0xFFFFFFFF</resetValue>
					<fields>
						<field>
							<name>BIT0</name>
							<lsb>0</lsb>
							<msb>0</msb>
							<enumeratedValues>
								<name>dis_en_enum</name>
								<enumeratedValue>
									<name>disable</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>enable</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT1</name>
							<lsb>1</lsb>
							<msb>1</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT2</name>
							<lsb>2</lsb>
							<msb>2</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT3</name>
							<lsb>3</lsb>
							<msb>3</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT4</name>
							<lsb>4</lsb>
							<msb>4</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT5</name>
							<lsb>5</lsb>
							<msb>5</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT6</name>
							<lsb>6</lsb>
							<msb>6</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT7</name>
							<lsb>7</lsb>
							<msb>7</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT8</name>
							<lsb>8</lsb>
							<msb>8</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT9</name>
							<lsb>9</lsb>
							<msb>9</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT10</name>
							<lsb>10</lsb>
							<msb>10</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT11</name>
							<lsb>11</lsb>
							<msb>11</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT12</name>
							<lsb>12</lsb>
							<msb>12</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT13</name>
							<lsb>13</lsb>
							<msb>13</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT14</name>
							<lsb>14</lsb>
							<msb>14</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT15</name>
							<lsb>15</lsb>
							<msb>15</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT16</name>
							<lsb>16</lsb>
							<msb>16</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT17</name>
							<lsb>17</lsb>
							<msb>17</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT18</name>
							<lsb>18</lsb>
							<msb>18</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT19</name>
							<lsb>19</lsb>
							<msb>19</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT20</name>
							<lsb>20</lsb>
							<msb>20</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT21</name>
							<lsb>21</lsb>
							<msb>21</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT22</name>
							<lsb>22</lsb>
							<msb>22</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT23</name>
							<lsb>23</lsb>
							<msb>23</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT24</name>
							<lsb>24</lsb>
							<msb>24</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT25</name>
							<lsb>25</lsb>
							<msb>25</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT26</name>
							<lsb>26</lsb>
							<msb>26</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT27</name>
							<lsb>27</lsb>
							<msb>27</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT28</name>
							<lsb>28</lsb>
							<msb>28</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT29</name>
							<lsb>29</lsb>
							<msb>29</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT30</name>
							<lsb>30</lsb>
							<msb>30</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT31</name>
							<lsb>31</lsb>
							<msb>31</msb>
						</field>
					</fields>
				</register>
				<register derivedFrom="EN">
					<name>OUT_EN</name>
					<description>GPIO Output Enable Register. Each bit controls the GPIO_OUT_EN setting for one GPIO pin in the associated port.</description>
					<addressOffset>0x0C</addressOffset>
					<resetValue>0x00000000</resetValue>
				</register>
				<register>
					<name>OUT</name>
					<description>GPIO Output Register. Each bit controls the GPIO_OUT setting for one pin in the associated port.  This register can be written either directly, or by using the GPIO_OUT_SET and GPIO_OUT_CLR registers.</description>
					<addressOffset>0x18</addressOffset>
					<fields>
						<field>
							<name>BIT0</name>
							<lsb>0</lsb>
							<msb>0</msb>
							<access>read-write</access>
							<enumeratedValues>
								<name>lo_hi_enum</name>
								<usage>read-write</usage>
								<enumeratedValue>
									<name>lo</name>
									<description>Logic 0 (low)</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>hi</name>
									<description>Logic 1 (high)</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT1</name>
							<lsb>1</lsb>
							<msb>1</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT2</name>
							<lsb>2</lsb>
							<msb>2</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT3</name>
							<lsb>3</lsb>
							<msb>3</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT4</name>
							<lsb>4</lsb>
							<msb>4</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT5</name>
							<lsb>5</lsb>
							<msb>5</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT6</name>
							<lsb>6</lsb>
							<msb>6</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT7</name>
							<lsb>7</lsb>
							<msb>7</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT8</name>
							<lsb>8</lsb>
							<msb>8</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT9</name>
							<lsb>9</lsb>
							<msb>9</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT10</name>
							<lsb>10</lsb>
							<msb>10</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT11</name>
							<lsb>11</lsb>
							<msb>11</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT12</name>
							<lsb>12</lsb>
							<msb>12</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT13</name>
							<lsb>13</lsb>
							<msb>13</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT14</name>
							<lsb>14</lsb>
							<msb>14</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT15</name>
							<lsb>15</lsb>
							<msb>15</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT16</name>
							<lsb>16</lsb>
							<msb>16</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT17</name>
							<lsb>17</lsb>
							<msb>17</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT18</name>
							<lsb>18</lsb>
							<msb>18</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT19</name>
							<lsb>19</lsb>
							<msb>19</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT20</name>
							<lsb>20</lsb>
							<msb>20</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT21</name>
							<lsb>21</lsb>
							<msb>21</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT22</name>
							<lsb>22</lsb>
							<msb>22</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT23</name>
							<lsb>23</lsb>
							<msb>23</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT24</name>
							<lsb>24</lsb>
							<msb>24</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT25</name>
							<lsb>25</lsb>
							<msb>25</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT26</name>
							<lsb>26</lsb>
							<msb>26</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT27</name>
							<lsb>27</lsb>
							<msb>27</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT28</name>
							<lsb>28</lsb>
							<msb>28</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT29</name>
							<lsb>29</lsb>
							<msb>29</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT30</name>
							<lsb>30</lsb>
							<msb>30</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT31</name>
							<lsb>31</lsb>
							<msb>31</msb>
						</field>
					</fields>
				</register>
				<register>
					<name>OUT_SET</name>
					<description>GPIO Output Set. Writing a 1 to one or more bits in this register sets the bits in the same positions in GPIO_OUT to 1, without affecting other bits in that register.</description>
					<addressOffset>0x1C</addressOffset>
					<access>write-only</access>
					<fields>
						<field>
							<name>BIT0</name>
							<lsb>0</lsb>
							<msb>0</msb>
							<enumeratedValues>
								<name>set_enum</name>
								<enumeratedValue>
									<name>nop</name>
									<description>No effect</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>set</name>
									<description>Set bit in this position</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT1</name>
							<lsb>1</lsb>
							<msb>1</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT2</name>
							<lsb>2</lsb>
							<msb>2</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT3</name>
							<lsb>3</lsb>
							<msb>3</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT4</name>
							<lsb>4</lsb>
							<msb>4</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT5</name>
							<lsb>5</lsb>
							<msb>5</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT6</name>
							<lsb>6</lsb>
							<msb>6</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT7</name>
							<lsb>7</lsb>
							<msb>7</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT8</name>
							<lsb>8</lsb>
							<msb>8</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT9</name>
							<lsb>9</lsb>
							<msb>9</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT10</name>
							<lsb>10</lsb>
							<msb>10</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT11</name>
							<lsb>11</lsb>
							<msb>11</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT12</name>
							<lsb>12</lsb>
							<msb>12</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT13</name>
							<lsb>13</lsb>
							<msb>13</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT14</name>
							<lsb>14</lsb>
							<msb>14</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT15</name>
							<lsb>15</lsb>
							<msb>15</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT16</name>
							<lsb>16</lsb>
							<msb>16</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT17</name>
							<lsb>17</lsb>
							<msb>17</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT18</name>
							<lsb>18</lsb>
							<msb>18</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT19</name>
							<lsb>19</lsb>
							<msb>19</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT20</name>
							<lsb>20</lsb>
							<msb>20</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT21</name>
							<lsb>21</lsb>
							<msb>21</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT22</name>
							<lsb>22</lsb>
							<msb>22</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT23</name>
							<lsb>23</lsb>
							<msb>23</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT24</name>
							<lsb>24</lsb>
							<msb>24</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT25</name>
							<lsb>25</lsb>
							<msb>25</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT26</name>
							<lsb>26</lsb>
							<msb>26</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT27</name>
							<lsb>27</lsb>
							<msb>27</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT28</name>
							<lsb>28</lsb>
							<msb>28</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT29</name>
							<lsb>29</lsb>
							<msb>29</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT30</name>
							<lsb>30</lsb>
							<msb>30</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT31</name>
							<lsb>31</lsb>
							<msb>31</msb>
						</field>
					</fields>
				</register>
				<register>
					<name>OUT_CLR</name>
					<description>GPIO Output Clear. Writing a 1 to one or more bits in this register clears the bits in the same positions in GPIO_OUT to 0, without affecting other bits in that register.</description>
					<addressOffset>0x20</addressOffset>
					<access>write-only</access>
					<fields>
						<field>
							<name>BIT0</name>
							<lsb>0</lsb>
							<msb>0</msb>
							<enumeratedValues>
								<name>clr_enum</name>
								<enumeratedValue>
									<name>nop</name>
									<description>No effect</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>clear</name>
									<description>Clear bit in this position</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT1</name>
							<lsb>1</lsb>
							<msb>1</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT2</name>
							<lsb>2</lsb>
							<msb>2</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT3</name>
							<lsb>3</lsb>
							<msb>3</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT4</name>
							<lsb>4</lsb>
							<msb>4</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT5</name>
							<lsb>5</lsb>
							<msb>5</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT6</name>
							<lsb>6</lsb>
							<msb>6</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT7</name>
							<lsb>7</lsb>
							<msb>7</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT8</name>
							<lsb>8</lsb>
							<msb>8</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT9</name>
							<lsb>9</lsb>
							<msb>9</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT10</name>
							<lsb>10</lsb>
							<msb>10</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT11</name>
							<lsb>11</lsb>
							<msb>11</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT12</name>
							<lsb>12</lsb>
							<msb>12</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT13</name>
							<lsb>13</lsb>
							<msb>13</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT14</name>
							<lsb>14</lsb>
							<msb>14</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT15</name>
							<lsb>15</lsb>
							<msb>15</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT16</name>
							<lsb>16</lsb>
							<msb>16</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT17</name>
							<lsb>17</lsb>
							<msb>17</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT18</name>
							<lsb>18</lsb>
							<msb>18</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT19</name>
							<lsb>19</lsb>
							<msb>19</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT20</name>
							<lsb>20</lsb>
							<msb>20</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT21</name>
							<lsb>21</lsb>
							<msb>21</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT22</name>
							<lsb>22</lsb>
							<msb>22</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT23</name>
							<lsb>23</lsb>
							<msb>23</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT24</name>
							<lsb>24</lsb>
							<msb>24</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT25</name>
							<lsb>25</lsb>
							<msb>25</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT26</name>
							<lsb>26</lsb>
							<msb>26</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT27</name>
							<lsb>27</lsb>
							<msb>27</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT28</name>
							<lsb>28</lsb>
							<msb>28</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT29</name>
							<lsb>29</lsb>
							<msb>29</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT30</name>
							<lsb>30</lsb>
							<msb>30</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT31</name>
							<lsb>31</lsb>
							<msb>31</msb>
						</field>
					</fields>
				</register>
				<register derivedFrom="OUT">
					<name>IN</name>
					<description>GPIO Input Register. Read-only register to read from the logic states of the GPIO pins on this port.</description>
					<addressOffset>0x24</addressOffset>
					<access>read-only</access>
				</register>
				<register>
					<name>INT_MOD</name>
					<description>GPIO Interrupt Mode Register. Each bit in this register controls the interrupt mode setting for the associated GPIO pin on this port.</description>
					<addressOffset>0x28</addressOffset>
					<fields>
						<field>
							<name>BIT0</name>
							<lsb>0</lsb>
							<msb>0</msb>
							<enumeratedValues>
								<name>int_mode_enum</name>
								<enumeratedValue>
									<name>level</name>
									<description>Interrupts for this pin are level triggered.</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>edge</name>
									<description>Interrupts for this pin are edge triggered.</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT1</name>
							<lsb>1</lsb>
							<msb>1</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT2</name>
							<lsb>2</lsb>
							<msb>2</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT3</name>
							<lsb>3</lsb>
							<msb>3</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT4</name>
							<lsb>4</lsb>
							<msb>4</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT5</name>
							<lsb>5</lsb>
							<msb>5</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT6</name>
							<lsb>6</lsb>
							<msb>6</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT7</name>
							<lsb>7</lsb>
							<msb>7</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT8</name>
							<lsb>8</lsb>
							<msb>8</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT9</name>
							<lsb>9</lsb>
							<msb>9</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT10</name>
							<lsb>10</lsb>
							<msb>10</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT11</name>
							<lsb>11</lsb>
							<msb>11</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT12</name>
							<lsb>12</lsb>
							<msb>12</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT13</name>
							<lsb>13</lsb>
							<msb>13</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT14</name>
							<lsb>14</lsb>
							<msb>14</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT15</name>
							<lsb>15</lsb>
							<msb>15</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT16</name>
							<lsb>16</lsb>
							<msb>16</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT17</name>
							<lsb>17</lsb>
							<msb>17</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT18</name>
							<lsb>18</lsb>
							<msb>18</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT19</name>
							<lsb>19</lsb>
							<msb>19</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT20</name>
							<lsb>20</lsb>
							<msb>20</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT21</name>
							<lsb>21</lsb>
							<msb>21</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT22</name>
							<lsb>22</lsb>
							<msb>22</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT23</name>
							<lsb>23</lsb>
							<msb>23</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT24</name>
							<lsb>24</lsb>
							<msb>24</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT25</name>
							<lsb>25</lsb>
							<msb>25</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT26</name>
							<lsb>26</lsb>
							<msb>26</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT27</name>
							<lsb>27</lsb>
							<msb>27</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT28</name>
							<lsb>28</lsb>
							<msb>28</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT29</name>
							<lsb>29</lsb>
							<msb>29</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT30</name>
							<lsb>30</lsb>
							<msb>30</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT31</name>
							<lsb>31</lsb>
							<msb>31</msb>
						</field>
					</fields>
				</register>
				<register>
					<name>INT_POL</name>
					<description>GPIO Interrupt Polarity Register. Each bit in this register controls the interrupt polarity setting for one GPIO pin in the associated port.</description>
					<addressOffset>0x2C</addressOffset>
					<fields>
						<field>
							<name>BIT0</name>
							<lsb>0</lsb>
							<msb>0</msb>
							<enumeratedValues>
								<name>int_pol_enum</name>
								<enumeratedValue>
									<name>lo</name>
									<description>Interrupts are latched on a falling edge or low level condition for this pin.</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>hi</name>
									<description>Interrupts are latched on a rising edge or high level condition for this pin.</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT1</name>
							<lsb>1</lsb>
							<msb>1</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT2</name>
							<lsb>2</lsb>
							<msb>2</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT3</name>
							<lsb>3</lsb>
							<msb>3</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT4</name>
							<lsb>4</lsb>
							<msb>4</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT5</name>
							<lsb>5</lsb>
							<msb>5</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT6</name>
							<lsb>6</lsb>
							<msb>6</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT7</name>
							<lsb>7</lsb>
							<msb>7</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT8</name>
							<lsb>8</lsb>
							<msb>8</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT9</name>
							<lsb>9</lsb>
							<msb>9</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT10</name>
							<lsb>10</lsb>
							<msb>10</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT11</name>
							<lsb>11</lsb>
							<msb>11</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT12</name>
							<lsb>12</lsb>
							<msb>12</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT13</name>
							<lsb>13</lsb>
							<msb>13</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT14</name>
							<lsb>14</lsb>
							<msb>14</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT15</name>
							<lsb>15</lsb>
							<msb>15</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT16</name>
							<lsb>16</lsb>
							<msb>16</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT17</name>
							<lsb>17</lsb>
							<msb>17</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT18</name>
							<lsb>18</lsb>
							<msb>18</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT19</name>
							<lsb>19</lsb>
							<msb>19</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT20</name>
							<lsb>20</lsb>
							<msb>20</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT21</name>
							<lsb>21</lsb>
							<msb>21</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT22</name>
							<lsb>22</lsb>
							<msb>22</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT23</name>
							<lsb>23</lsb>
							<msb>23</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT24</name>
							<lsb>24</lsb>
							<msb>24</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT25</name>
							<lsb>25</lsb>
							<msb>25</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT26</name>
							<lsb>26</lsb>
							<msb>26</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT27</name>
							<lsb>27</lsb>
							<msb>27</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT28</name>
							<lsb>28</lsb>
							<msb>28</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT29</name>
							<lsb>29</lsb>
							<msb>29</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT30</name>
							<lsb>30</lsb>
							<msb>30</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT31</name>
							<lsb>31</lsb>
							<msb>31</msb>
						</field>
					</fields>
				</register>
				<register derivedFrom="OUT_EN">
					<name>INT_EN</name>
					<description>GPIO Interrupt Enable Register. Each bit in this register controls the GPIO interrupt enable for the associated pin on the GPIO port.</description>
					<addressOffset>0x34</addressOffset>
				</register>
				<register derivedFrom="OUT_SET">
					<name>INT_EN_SET</name>
					<description>GPIO Interrupt Enable Set. Writing a 1 to one or more bits in this register sets the bits in the same positions in GPIO_INT_EN to 1, without affecting other bits in that register.</description>
					<addressOffset>0x38</addressOffset>
				</register>
				<register derivedFrom="OUT_CLR">
					<name>INT_EN_CLR</name>
					<description>GPIO Interrupt Enable Clear. Writing a 1 to one or more bits in this register clears the bits in the same positions in GPIO_INT_EN to 0, without affecting other bits in that register.</description>
					<addressOffset>0x3C</addressOffset>
				</register>
				<register>
					<name>INT_STAT</name>
					<description>GPIO Interrupt Status Register. Each bit in this register contains the pending interrupt status for the associated GPIO pin in this port.</description>
					<addressOffset>0x40</addressOffset>
					<access>read-only</access>
					<fields>
						<field>
							<name>BIT0</name>
							<lsb>0</lsb>
							<msb>0</msb>
							<enumeratedValues>
								<name>flag_enum</name>
								<enumeratedValue>
									<name>inactive</name>
									<description>No interrupt is pending.</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>pending</name>
									<description>An interrupt is pending.</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT1</name>
							<lsb>1</lsb>
							<msb>1</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT2</name>
							<lsb>2</lsb>
							<msb>2</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT3</name>
							<lsb>3</lsb>
							<msb>3</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT4</name>
							<lsb>4</lsb>
							<msb>4</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT5</name>
							<lsb>5</lsb>
							<msb>5</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT6</name>
							<lsb>6</lsb>
							<msb>6</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT7</name>
							<lsb>7</lsb>
							<msb>7</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT8</name>
							<lsb>8</lsb>
							<msb>8</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT9</name>
							<lsb>9</lsb>
							<msb>9</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT10</name>
							<lsb>10</lsb>
							<msb>10</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT11</name>
							<lsb>11</lsb>
							<msb>11</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT12</name>
							<lsb>12</lsb>
							<msb>12</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT13</name>
							<lsb>13</lsb>
							<msb>13</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT14</name>
							<lsb>14</lsb>
							<msb>14</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT15</name>
							<lsb>15</lsb>
							<msb>15</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT16</name>
							<lsb>16</lsb>
							<msb>16</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT17</name>
							<lsb>17</lsb>
							<msb>17</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT18</name>
							<lsb>18</lsb>
							<msb>18</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT19</name>
							<lsb>19</lsb>
							<msb>19</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT20</name>
							<lsb>20</lsb>
							<msb>20</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT21</name>
							<lsb>21</lsb>
							<msb>21</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT22</name>
							<lsb>22</lsb>
							<msb>22</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT23</name>
							<lsb>23</lsb>
							<msb>23</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT24</name>
							<lsb>24</lsb>
							<msb>24</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT25</name>
							<lsb>25</lsb>
							<msb>25</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT26</name>
							<lsb>26</lsb>
							<msb>26</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT27</name>
							<lsb>27</lsb>
							<msb>27</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT28</name>
							<lsb>28</lsb>
							<msb>28</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT29</name>
							<lsb>29</lsb>
							<msb>29</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT30</name>
							<lsb>30</lsb>
							<msb>30</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT31</name>
							<lsb>31</lsb>
							<msb>31</msb>
						</field>
					</fields>
				</register>
				<register derivedFrom="OUT_CLR">
					<name>INT_CLR</name>
					<description>GPIO Interrupt Status Clear. Writing a 1 to one or more bits in this register clears the bits in the same positions in GPIO_INT_STAT to 0, without affecting other bits in that register.</description>
					<addressOffset>0x48</addressOffset>
				</register>
				<register derivedFrom="OUT_EN">
					<name>WAKE_EN</name>
					<description>GPIO Wake Enable Register. Each bit in this register controls the PMU wakeup enable for the associated GPIO pin in this port.</description>
					<addressOffset>0x4C</addressOffset>
				</register>
				<register derivedFrom="OUT_EN">
					<name>INT_DUAL_EDGE</name>
					<description>GPIO Interrupt Dual Edge Mode Register. Each bit in this register selects dual edge mode for the associated GPIO pin in this port.</description>
					<addressOffset>0x5C</addressOffset>
				</register>
				<register derivedFrom="OUT_EN">
					<name>PAD_CFG1</name>
					<description>GPIO Input Mode Config 1. Each bit in this register enables the weak pull-up for the associated GPIO pin in this port.</description>
					<addressOffset>0x60</addressOffset>
				</register>
				<register derivedFrom="OUT_EN">
					<name>PAD_CFG2</name>
					<description>GPIO Input Mode Config 2. Each bit in this register enables the weak pull-down for the associated GPIO pin in this port.</description>
					<addressOffset>0x64</addressOffset>
				</register>
				<register>
					<name>EN1</name>
					<description>GPIO Alternate Function Enable Register. Each bit in this register selects between primary/secondary functions for the associated GPIO pin in this port.</description>
					<addressOffset>0x68</addressOffset>
					<fields>
						<field>
							<name>BIT0</name>
							<lsb>0</lsb>
							<msb>0</msb>
							<enumeratedValues>
								<name>pri_sec_enum</name>
								<enumeratedValue>
									<name>primary</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>secondary</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT1</name>
							<lsb>1</lsb>
							<msb>1</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT2</name>
							<lsb>2</lsb>
							<msb>2</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT3</name>
							<lsb>3</lsb>
							<msb>3</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT4</name>
							<lsb>4</lsb>
							<msb>4</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT5</name>
							<lsb>5</lsb>
							<msb>5</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT6</name>
							<lsb>6</lsb>
							<msb>6</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT7</name>
							<lsb>7</lsb>
							<msb>7</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT8</name>
							<lsb>8</lsb>
							<msb>8</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT9</name>
							<lsb>9</lsb>
							<msb>9</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT10</name>
							<lsb>10</lsb>
							<msb>10</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT11</name>
							<lsb>11</lsb>
							<msb>11</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT12</name>
							<lsb>12</lsb>
							<msb>12</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT13</name>
							<lsb>13</lsb>
							<msb>13</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT14</name>
							<lsb>14</lsb>
							<msb>14</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT15</name>
							<lsb>15</lsb>
							<msb>15</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT16</name>
							<lsb>16</lsb>
							<msb>16</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT17</name>
							<lsb>17</lsb>
							<msb>17</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT18</name>
							<lsb>18</lsb>
							<msb>18</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT19</name>
							<lsb>19</lsb>
							<msb>19</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT20</name>
							<lsb>20</lsb>
							<msb>20</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT21</name>
							<lsb>21</lsb>
							<msb>21</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT22</name>
							<lsb>22</lsb>
							<msb>22</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT23</name>
							<lsb>23</lsb>
							<msb>23</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT24</name>
							<lsb>24</lsb>
							<msb>24</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT25</name>
							<lsb>25</lsb>
							<msb>25</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT26</name>
							<lsb>26</lsb>
							<msb>26</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT27</name>
							<lsb>27</lsb>
							<msb>27</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT28</name>
							<lsb>28</lsb>
							<msb>28</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT29</name>
							<lsb>29</lsb>
							<msb>29</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT30</name>
							<lsb>30</lsb>
							<msb>30</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT31</name>
							<lsb>31</lsb>
							<msb>31</msb>
						</field>
					</fields>
				</register>
				<register>
					<name>DS</name>
					<description>GPIO Drive Strength Register. Each bit in this register selects the drive strength for the associated GPIO pin in this port. Refer to the Datasheet for sink/source current of GPIO pins in each mode.</description>
					<addressOffset>0xB0</addressOffset>
					<fields>
						<field>
							<name>BIT0</name>
							<lsb>0</lsb>
							<msb>0</msb>
							<enumeratedValues>
								<name>drive_enum</name>
								<enumeratedValue>
									<name>loDrive</name>
									<description>GPIO port pin is in low-drive mode.</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>hiDrive</name>
									<description>GPIO port pin is in high-drive mode.</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT1</name>
							<lsb>1</lsb>
							<msb>1</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT2</name>
							<lsb>2</lsb>
							<msb>2</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT3</name>
							<lsb>3</lsb>
							<msb>3</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT4</name>
							<lsb>4</lsb>
							<msb>4</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT5</name>
							<lsb>5</lsb>
							<msb>5</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT6</name>
							<lsb>6</lsb>
							<msb>6</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT7</name>
							<lsb>7</lsb>
							<msb>7</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT8</name>
							<lsb>8</lsb>
							<msb>8</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT9</name>
							<lsb>9</lsb>
							<msb>9</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT10</name>
							<lsb>10</lsb>
							<msb>10</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT11</name>
							<lsb>11</lsb>
							<msb>11</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT12</name>
							<lsb>12</lsb>
							<msb>12</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT13</name>
							<lsb>13</lsb>
							<msb>13</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT14</name>
							<lsb>14</lsb>
							<msb>14</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT15</name>
							<lsb>15</lsb>
							<msb>15</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT16</name>
							<lsb>16</lsb>
							<msb>16</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT17</name>
							<lsb>17</lsb>
							<msb>17</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT18</name>
							<lsb>18</lsb>
							<msb>18</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT19</name>
							<lsb>19</lsb>
							<msb>19</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT20</name>
							<lsb>20</lsb>
							<msb>20</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT21</name>
							<lsb>21</lsb>
							<msb>21</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT22</name>
							<lsb>22</lsb>
							<msb>22</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT23</name>
							<lsb>23</lsb>
							<msb>23</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT24</name>
							<lsb>24</lsb>
							<msb>24</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT25</name>
							<lsb>25</lsb>
							<msb>25</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT26</name>
							<lsb>26</lsb>
							<msb>26</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT27</name>
							<lsb>27</lsb>
							<msb>27</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT28</name>
							<lsb>28</lsb>
							<msb>28</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT29</name>
							<lsb>29</lsb>
							<msb>29</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT30</name>
							<lsb>30</lsb>
							<msb>30</msb>
						</field>
						<field derivedFrom="BIT0">
							<name>BIT31</name>
							<lsb>31</lsb>
							<msb>31</msb>
						</field>
					</fields>
				</register>
			</registers>
			<addressBlock>
				<offset>0x00</offset>
				<size>0x1000</size>
				<usage>registers</usage>
			</addressBlock>
		</peripheral>
		<peripheral derivedFrom="GPIO_0">
			<name>GPIO_1</name>
			<description>Individual I/O for Port 1</description>
			<prependToName>GPIO1_</prependToName>
			<baseAddress>0x40009000</baseAddress>
			<interrupt><name>GPIO1</name><value>25</value></interrupt>
		</peripheral>
		<peripheral derivedFrom="GPIO_0">
			<name>GPIO_2</name>
			<description>Individual I/O for Port 2</description>
			<prependToName>GPIO2_</prependToName>
			<baseAddress>0x4000A000</baseAddress>
			<interrupt><name>GPIO2</name><value>26</value></interrupt>
		</peripheral>
		<peripheral>
			<name>ADC</name>
			<description>Analog to Digital Converter</description>
			<prependToName>ADC_</prependToName>
			<baseAddress>0x40034000</baseAddress>
			<interrupt><name>ADC</name><value>20</value></interrupt>
			<registers>
				<register>
					<name>CN</name>
					<description>ADC Control Register</description>
					<addressOffset>0x00</addressOffset>
					<fields>
						<field>
							<name>ADEN</name>
							<description>ADC Enable</description>
							<lsb>0</lsb>
							<msb>0</msb>
							<enumeratedValues>
								<name>dis_en_enum</name>
								<enumeratedValue>
									<name>disable</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>enable</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="ADEN">
							<name>ADDAIE</name>
							<description>ADC Data Available Interrupt Enable</description>
							<lsb>1</lsb>
							<msb>1</msb>
						</field>
						<field>
							<name>ADALGN</name>
							<description>ADC Data Alignment Select. This bit selects the ADC data alignment mode.</description>
							<lsb>2</lsb>
							<msb>2</msb>
							<enumeratedValues>
								<name>align_enum</name>
								<enumeratedValue>
									<name>rightAlign</name>
									<description>ADC data is in right alignment format in ADDDATA[9:0] while ADDATA[15:10] is filled with zero.</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>leftAlign</name>
									<description>ADC data is in left alignment format in ADDDATA[15:6] while ADDATA[5:0] is filled with zero.</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>ADCH</name>
							<description>ADC Input Channel Select.  These bits select the input channel to the ADC converter.</description>
							<lsb>3</lsb>
							<msb>4</msb>
							<enumeratedValues>
								<name>adc_ch_enum</name>
								<enumeratedValue>
									<name>an0</name>
									<description>AN0</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>an1</name>
									<description>AN1</description>
									<value>1</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>RFU</name>
									<description>Reserved. Do not use.</description>
									<isDefault>true</isDefault>
								</enumeratedValue>
								<enumeratedValue>
									<name>tempSensor</name>
									<description>Internal Temp Sensor</description>
									<value>3</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="ADEN">
							<name>ADSCL</name>
							<description>ADC Input Scale.  This bit selects the scale factor applies to AN0 and AN1 inputs when using the internal reference. Note that the ADSCL setting is ignored when AVDD is selected as the reference. Note that the ADSCL setting is ignored when AVDD is selected as the reference. ADC Input Scale.  This bit selects the scale factor applies to AN0 and AN1 inputs when using the internal reference.  Note that the ADSCL setting is ignored when AVDD is selected as the reference. ADC Input Scale.  This bit enabled the 1/3 scale factor applied to AN0 and AN1 inputs when using the internal reference. Note that the ADSCL setting is ignored when AVDD is selected as the reference.</description>
							<lsb>5</lsb>
							<msb>5</msb>
						</field>
						<field>
							<name>ADREF</name>
							<description>ADC Reference Select.  This bit selects the reference voltage used in the ADC conversion.</description>
							<lsb>6</lsb>
							<msb>6</msb>
							<enumeratedValues>
								<name>adc_ref_enum</name>
								<enumeratedValue>
									<name>avdd</name>
									<description>AVDD</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>internalRef</name>
									<description>Internal Reference</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="ADREF">
							<name>IREFIN</name>
							<description>Internal Reference Enable.  This bit has the same value as ADREF.  This bit is read only.</description>
							<lsb>7</lsb>
							<msb>7</msb>
							<access>read-only</access>
						</field>
						<field>
							<name>ADCCLK</name>
							<description>ADC Clock Divider.  These bits select the ADC conversion clock in relationship to the APB Clock. The APB is first passed through a divide by 16 prescaler and passed to programmable divider so that ADC clock would be in the range of 8MHz with APB clock frequency of 100MHz.</description>
							<lsb>8</lsb>
							<msb>9</msb>
							<enumeratedValues>
								<name>adc_clk_enum</name>
								<enumeratedValue>
									<name>div16</name>
									<description>PCLK / 16</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>div32</name>
									<description>PCLK / 32</description>
									<value>1</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>div64</name>
									<description>PCLK / 64</description>
									<value>2</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>div128</name>
									<description>PCLK / 128</description>
									<value>3</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="ADEN">
							<name>ADLTIE</name>
							<description>ADC Low Threshold Interrupt Enable</description>
							<lsb>10</lsb>
							<msb>10</msb>
						</field>
						<field derivedFrom="ADEN">
							<name>ADHTIE</name>
							<description>ADC High Threshold Interrupt Enable</description>
							<lsb>11</lsb>
							<msb>11</msb>
						</field>
						<field derivedFrom="ADEN">
							<name>TSEN</name>
							<description>Temp Sensor Enable.  This bit enables the internal temp sensor available when ADC_CN.ADCH = b11.</description>
							<lsb>12</lsb>
							<msb>12</msb>
						</field>
						<field>
							<name>ADOVFDIS</name>
							<description>Overflow Disable</description>
							<lsb>15</lsb>
							<msb>15</msb>
							<enumeratedValues>
								<name>en_dis_enum</name>
								<enumeratedValue>
									<name>enable</name>
									<description>ADST.ADOVF bit will be set when the ADC overflows. In this case ADDATA will return a data of 0x3FF if an overflow occurs.</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>disable</name>
									<description>ADST.ADOVF bit will not be set when an overflow occurs. In this case ADDATA will return the overflowed data.</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
					</fields>
				</register>
				<register>
					<name>ST</name>
					<description>ADC Status Register</description>
					<addressOffset>0x04</addressOffset>
					<resetValue>0x00000080</resetValue>
					<fields>
						<field>
							<name>ADCONV</name>
							<description>ADC Start Conversion. Note that since this bit is not cleared on entry to STOP mode, it is up to the user software to clear ADCONV before entering STOP mode. If this bit is not cleared, the ADC will be held in its current state during STOP mode, and will resume operation at the point where it left off when STOP mode is exited. To avoid undesirable current draw by this block it is recommended to clear this bit prior to entering the STOP mode.</description>
							<lsb>0</lsb>
							<msb>0</msb>
							<enumeratedValues>
								<name>start_conv_enum</name>
								<enumeratedValue>
									<name>stop</name>
									<description>Stop ADC conversion. The ADC will stop acquiring data immediately.</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>start</name>
									<description>Starts an ADC conversion when the ADC is enabled (ADEN=1).</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>ADDAI</name>
							<description>ADC Data Available Interrupt Flag</description>
							<lsb>1</lsb>
							<msb>1</msb>
							<enumeratedValues>
								<name>flag_enum</name>
								<enumeratedValue>
									<name>inactive</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>pending</name>
									<description>Flag asserted</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="ADDAI">
							<name>ADOVF</name>
							<description>ADC Overflow Flag. Once set this bit will remain set unless cleared by software.</description>
							<lsb>2</lsb>
							<msb>2</msb>
						</field>
						<field>
							<name>ADLTIF</name>
							<description>ADC Low Threshold Interrupt Flag. Setting this bit to 1 by software will generate an interrupt if enabled.</description>
							<lsb>3</lsb>
							<msb>3</msb>
						</field>
						<field derivedFrom="ADDAI">
							<name>ADHTIF</name>
							<description>ADC High Threshold Interrupt Flag. Setting this bit to 1 by software will generate an interrupt if enabled.</description>
							<lsb>4</lsb>
							<msb>4</msb>
						</field>
					</fields>
				</register>
				<register>
					<name>DATA</name>
					<description>ADC Data Register. When read, this register returns the ADC conversion data. The ADC conversion result will be aligned according to the ADALGN setting.</description>
					<addressOffset>0x08</addressOffset>
					<size>16</size>
					<access>read-only</access>
				</register>
				<register>
					<dim>3</dim>
					<dimIncrement>0x04</dimIncrement>
					<name>LT%s</name>
					<description>ADC channel Low Threshold Value. When an ADC conversion result of channel is less than ADC Low Threshold value (ADLT), ADLTIF flag will be set.</description>
					<addressOffset>0x0C</addressOffset>
					<size>10</size>
				</register>
				<register>
					<dim>3</dim>
					<dimIncrement>0x04</dimIncrement>
					<name>HT%s</name>
					<description>ADC channel High Threshold Value. When an ADC conversion result of channel is greater than ADC High Threshold value (ADHT), ADHTIF flag will be set.</description>
					<addressOffset>0x18</addressOffset>
					<size>10</size>
				</register>
			</registers>
			<addressBlock>
				<offset>0x00</offset>
				<size>0x1000</size>
				<usage>registers</usage>
			</addressBlock>
		</peripheral>
		<peripheral>
			<name>CryptographicAccelerator</name>
			<description>The cryptographic accelerator used to assist the computationally intensive operations of several common algorithms.</description>
			<baseAddress>0x40001000</baseAddress>
			<interrupt><name>Crypto_Engine</name><value>27</value></interrupt>
			<registers>
				<register>
					<name>CRYPTO_CTRL</name>
					<description>Crypto Control Register</description>
					<addressOffset>0x00</addressOffset>
					<resetValue>0xC0000000</resetValue>
					<fields>
						<field>
							<name>RST</name>
							<description>Reset. This bit is used to reset the crypto accelerator.  All crypto internal states and related registers are reset to their default reset values. Control register such as CRYPTO_CTRL, CIPHER_CTRL, HASH_CTRL, CRC_CTRL, MAA_CTRL (with the exception of the STC bit), HASH_MSG_SZ_[3:0] and MAA_MAWS will retain their values. This bit will automatically clear itself after one cycle.</description>
							<lsb>0</lsb>
							<msb>0</msb>
							<enumeratedValues>
								<name>reset_write_enum</name>
								<usage>write</usage>
								<enumeratedValue>
									<name>RFU</name>
									<description>Reserved. Do not use.</description>
									<isDefault>true</isDefault>
								</enumeratedValue>
								<enumeratedValue>
									<name>reset</name>
									<description>Starts reset operation</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
							<enumeratedValues>
								<name>reset_read_enum</name>
								<usage>read</usage>
								<enumeratedValue>
									<name>reset</name>
									<description>Reset complete</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>busy</name>
									<description>Reset in progress</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>INT</name>
							<description>Interrupt Enable. Generates an interrupt when done or error set.</description>
							<lsb>1</lsb>
							<msb>1</msb>
							<enumeratedValues>
								<name>dis_en_enum</name>
								<enumeratedValue>
									<name>disable</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>enable</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>SRC</name>
							<description>Source Select.  This bit selects the hash function and CRC generator input source.</description>
							<lsb>2</lsb>
							<msb>2</msb>
							<enumeratedValues>
								<name>src_sel_enum</name>
								<enumeratedValue>
									<name>inputFIFO</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>outputFIFO</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="INT">
							<name>BSO</name>
							<description>Byte Swap Output. Note. No byte swap will occur if there is not a full word.</description>
							<lsb>4</lsb>
							<msb>4</msb>
						</field>
						<field derivedFrom="INT">
							<name>BSI</name>
							<description>Byte Swap Input. Note. No byte swap will occur if there is not a full word.</description>
							<lsb>5</lsb>
							<msb>5</msb>
						</field>
						<field derivedFrom="INT">
							<name>WAIT_EN</name>
							<description>Wait Pin Enable. This can be used to hold off the crypto DMA until an external memory is ready. This is useful for transferring pages from NAND flash which may take several microseconds to become ready.</description>
							<lsb>6</lsb>
							<msb>6</msb>
						</field>
						<field>
							<name>WAIT_POL</name>
							<description>Wait Pin Polarity. When the wait pin is enabled, this bit selects its active state.</description>
							<lsb>7</lsb>
							<msb>7</msb>
							<enumeratedValues>
								<name>pol_enum</name>
								<enumeratedValue>
									<name>activeLo</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>activeHi</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>WRSRC</name>
							<description>Write FIFO Source Select. This field determines where data written to the write FIFO comes from. When data is written to the write FIFO, it is always written out the DMA. To decrypt or encrypt data, the write FIFO source should be set to the cipher output. To implement memcpy() or memset() functions, or to fill memory with random data, the write FIFO source should be set to the read FIFO. When calculating a HASH or CMAC, the write FIFO should be disabled.</description>
							<lsb>8</lsb>
							<msb>9</msb>
							<enumeratedValues>
								<name>wr_fifo_src_enum</name>
								<enumeratedValue>
									<name>none</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>cipherOutput</name>
									<value>1</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>readFIFO</name>
									<value>2</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>RFU</name>
									<description>Reserved. Do not use.</description>
									<isDefault>true</isDefault>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>RDSRC</name>
							<description>Read FIFO Source Select. This field selects the source of the read FIFO. Typically, it is set to use the DMA. To implement a memset() function, the read FIFO DMA should be disabled. To fill memory with random data or to hash random numbers, the read FIFO source should be set to the random number generator.</description>
							<lsb>10</lsb>
							<msb>11</msb>
							<enumeratedValues>
								<name>rd_fifo_sel_enum</name>
								<enumeratedValue>
									<name>dmaDisabled</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>dmaOrApb</name>
									<value>1</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>RNG</name>
									<value>2</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>RFU</name>
									<description>Reserved. Do not use.</description>
									<isDefault>true</isDefault>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>DMA_DONE</name>
							<description>DMA Done. DMA write/read operation is complete. This bit must be cleared before starting a DMA operation.</description>
							<lsb>24</lsb>
							<msb>24</msb>
							<enumeratedValues>
								<name>op_done_enum</name>
								<enumeratedValue>
									<name>notDone</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>done</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="DMA_DONE">
							<name>GLS_DONE</name>
							<description>Galois Done. FIFO is full and CRC or Hamming Code Generator is enabled. This bit must be cleared before starting a CRC operation Note that DMA_DONE must be polled instead of this bit to determine the end of DMA operation during the utilization of Hamming Code Generator.</description>
							<lsb>25</lsb>
							<msb>25</msb>
						</field>
						<field derivedFrom="DMA_DONE">
							<name>HSH_DONE</name>
							<description>Hash Done. SHA operation is complete. This bit must be cleared before starting a HASH operation.</description>
							<lsb>26</lsb>
							<msb>26</msb>
						</field>
						<field derivedFrom="DMA_DONE">
							<name>CPH_DONE</name>
							<description>Cipher Done. Either AES or DES encryption/decryption operation is complete. This bit must be cleared before starting a cipher operation.</description>
							<lsb>27</lsb>
							<msb>27</msb>
						</field>
						<field derivedFrom="DMA_DONE">
							<name>MAA_DONE</name>
							<description>MAA Done. MAA operation is complete. This bit must be cleared before starting a new MAA operation. This bit is read only while the MAA is in progress. This bit is negate of MAA_CTRL.STC.</description>
							<lsb>28</lsb>
							<msb>28</msb>
						</field>
						<field>
							<name>ERR</name>
							<description>AHB Bus Error. This bit is set when the DMA encounters a bus error during a read or write operation. Once this bit is set, the DMA will stop. This bit can only be cleared by resetting the crypto block.</description>
							<lsb>29</lsb>
							<msb>29</msb>
							<enumeratedValues>
								<name>error_enum</name>
								<enumeratedValue>
									<name>noError</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>error</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>RDY</name>
							<description>Ready. Crypto block ready for more data.</description>
							<lsb>30</lsb>
							<msb>30</msb>
							<enumeratedValues>
								<name>ready_enum</name>
								<enumeratedValue>
									<name>busy</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>ready</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="DMA_DONE">
							<name>DONE</name>
							<description>Done. One or more cryptographic calculations complete (logical OR of done flags).</description>
							<lsb>31</lsb>
							<msb>31</msb>
						</field>
					</fields>
				</register>
				<register>
					<name>CIPHER_CTRL</name>
					<description>Cipher Control Register</description>
					<addressOffset>0x04</addressOffset>
					<fields>
						<field>
							<name>ENC</name>
							<description>Encrypt. Select encryption or decryption of input data.</description>
							<lsb>0</lsb>
							<msb>0</msb>
							<enumeratedValues>
								<name>enc_dec_enum</name>
								<enumeratedValue>
									<name>encrypt</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>decrypt</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>KEY</name>
							<description>Load Key from crypto DMA. This bit is automatically cleared by hardware after the DMA has completed loading the key. When the DMA operation is done, it sets the appropriate crypto DMA Done flag.</description>
							<lsb>1</lsb>
							<msb>1</msb>
							<enumeratedValues>
								<name>start_op_enum</name>
								<enumeratedValue>
									<name>complete</name>
									<description>No operation/complete</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>start</name>
									<description>Start operation</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>SRC</name>
							<description>Source of Random key</description>
							<lsb>3</lsb>
							<msb>3</msb>
							<enumeratedValues>
								<name>key_src_enum</name>
								<enumeratedValue>
									<name>cipherKey</name>
									<description>User cipher key (0x4000_1060)</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>regFile</name>
									<description>Key from battery-backed register file (0x4000_5000 to 0x4000_501F)</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>CIPHER</name>
							<description>Cipher Operation Select.  Symmetric Block Cipher algorithm selection or memory operation.</description>
							<lsb>4</lsb>
							<msb>6</msb>
							<enumeratedValues>
								<name>cipher_enum</name>
								<enumeratedValue>
									<name>disabled</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>aes128</name>
									<value>1</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>aes192</name>
									<value>2</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>aes256</name>
									<value>3</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>des</name>
									<value>4</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>tdea</name>
									<value>5</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>RFU</name>
									<description>Reserved. Do not use.</description>
									<isDefault>true</isDefault>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>MODE</name>
							<description>Mode Select. Mode of operation for block cipher or memory operation. DES/TDES cannot be used in CFB, OFB or CTR modes.</description>
							<lsb>8</lsb>
							<msb>10</msb>
							<enumeratedValues>
								<name>cipher_mode_enum</name>
								<enumeratedValue>
									<name>ECB</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>CBC</name>
									<value>1</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>CFB</name>
									<description>(AES only)</description>
									<value>2</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>OFB</name>
									<description>(AES only)</description>
									<value>3</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>CTR</name>
									<description>(AES only)</description>
									<value>4</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>RFU</name>
									<description>Reserved. Do not use.</description>
									<isDefault>true</isDefault>
								</enumeratedValue>
							</enumeratedValues>
						</field>
					</fields>
				</register>
				<register>
					<name>HASH_CTRL</name>
					<description>HASH Control Register</description>
					<addressOffset>0x08</addressOffset>
					<fields>
						<field>
							<name>INIT</name>
							<description>Initialize. Initializes hash registers with standard constants.</description>
							<lsb>0</lsb>
							<msb>0</msb>
							<enumeratedValues>
								<name>start_op_enum</name>
								<enumeratedValue>
									<name>nop</name>
									<description>No operation/complete</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>start</name>
									<description>Start operation</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>XOR</name>
							<description>XOR data with IV from cipher block. Useful when calculating HMAC to XOR the input pad and output pad.</description>
							<lsb>1</lsb>
							<msb>1</msb>
							<enumeratedValues>
								<name>dis_en_enum</name>
								<enumeratedValue>
									<name>disable</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>enable</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>HASH</name>
							<description>Hash function selection</description>
							<lsb>2</lsb>
							<msb>4</msb>
							<enumeratedValues>
								<name>hash_enum</name>
								<enumeratedValue>
									<name>disabled</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>sha1</name>
									<value>1</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>sha224</name>
									<value>2</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>sha256</name>
									<value>3</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>sha384</name>
									<value>4</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>sha512</name>
									<value>5</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>RFU</name>
									<description>Reserved. Do not use.</description>
									<isDefault>true</isDefault>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>LAST</name>
							<description>Last Message Bit. This bit shall be set along with the HASH_MSG_SZ register prior to hashing the last 512 or 1024-bit block of the message data. It will allow automatic preprocessing of the last message padding, which includes the trailing bit 1, followed by the respective number of zero bits for the last block size and finally the message length represented in bytes. The bit will be automatically cleared at the same time the HASH DONE is set, designating the completion of the last message hash.</description>
							<lsb>5</lsb>
							<msb>5</msb>
							<enumeratedValues>
								<name>last_bit_enum</name>
								<enumeratedValue>
									<name>noEffect</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>lastMsgData</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
					</fields>
				</register>
				<register>
					<name>CRC_CTRL</name>
					<description>CRC Control Register</description>
					<addressOffset>0x0C</addressOffset>
					<fields>
						<field>
							<name>CRC</name>
							<description>Cyclic Redundancy Check Enable. The CRC cannot be enabled if the PRNG is enabled.</description>
							<lsb>0</lsb>
							<msb>0</msb>
							<enumeratedValues>
								<name>dis_en_enum</name>
								<enumeratedValue>
									<name>disable</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>enable</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>MSB</name>
							<description>MSB select. This bit selects the order of calculating CRC on data.</description>
							<lsb>1</lsb>
							<msb>1</msb>
							<enumeratedValues>
								<name>msb_sel_enum</name>
								<enumeratedValue>
									<name>lsbFirst</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>msbFirst</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="CRC">
							<name>PRNG</name>
							<description>Pseudo Random Number Generator Enable. If entropy is disabled, this outputs one byte of pseudo random data per clock cycle. If entropy is enabled, data is output at a rate of one bit per clock cycle.</description>
							<lsb>2</lsb>
							<msb>2</msb>
						</field>
						<field derivedFrom="CRC">
							<name>ENT</name>
							<description>Entropy Enable. If the PRNG is enabled, this mixes the high frequency ring oscillator with the LFSR. If the PRNG is disabled, the raw entropy data is output at a rate of 1 bit per clock. This makes it possible to characterize the quality of the entropy source.</description>
							<lsb>3</lsb>
							<msb>3</msb>
						</field>
						<field derivedFrom="CRC">
							<name>HAM</name>
							<description>Hamming Code Enable. Enable hamming code calculation.</description>
							<lsb>4</lsb>
							<msb>4</msb>
						</field>
						<field>
							<name>HRST</name>
							<description>Hamming Reset. Reset Hamming code ECC generator for next block.</description>
							<lsb>5</lsb>
							<msb>5</msb>
							<access>write-only</access>
							<enumeratedValues>
								<name>reset_write_enum</name>
								<usage>write</usage>
								<enumeratedValue>
									<name>RFU</name>
									<description>Reserved. Do not use.</description>
									<isDefault>true</isDefault>
								</enumeratedValue>
								<enumeratedValue>
									<name>reset</name>
									<description>Starts reset operation</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
					</fields>
				</register>
				<register>
					<name>DMA_SRC</name>
					<description>Crypto DMA Source Address</description>
					<addressOffset>0x10</addressOffset>
				</register>
				<register>
					<name>DMA_DEST</name>
					<description>Crypto DMA Destination Address</description>
					<addressOffset>0x14</addressOffset>
				</register>
				<register>
					<name>DMA_CNT</name>
					<description>Crypto DMA Byte Count</description>
					<addressOffset>0x18</addressOffset>
				</register>
				<register>
					<name>MAA_CTRL</name>
					<description>MAA Control Register</description>
					<addressOffset>0x1C</addressOffset>
					<fields>
						<field>
							<name>STC</name>
							<description>Start Calculation. This bit functions as both the control and the status of the MAA. If the size value in the MAWS register is invalid, the STC bit will be cleared by hardware immediately.  Otherwise, the STC bit is automatically cleared following the completion of each calculation or detecting an error. Clearing the STC bit resets the controller to its default state.</description>
							<lsb>0</lsb>
							<msb>0</msb>
							<enumeratedValues>
								<name>start_op_enum</name>
								<enumeratedValue>
									<name>nop</name>
									<description>No operation/complete</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>start</name>
									<description>Start operation</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>CLC</name>
							<description>Calculation Configuration. These bits select desired calculation.</description>
							<lsb>1</lsb>
							<msb>3</msb>
							<enumeratedValues>
								<name>calc_enum</name>
								<enumeratedValue>
									<name>exp</name>
									<description>Exponentiation</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>sq</name>
									<description>Square operation</description>
									<value>1</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>mul</name>
									<description>Multiplication</description>
									<value>2</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>sqMul</name>
									<description>Square followed by a multiplication</description>
									<value>3</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>add</name>
									<description>Addition</description>
									<value>4</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>sub</name>
									<description>Subtraction</description>
									<value>5</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>RFU</name>
									<description>Reserved. Do no use.</description>
									<isDefault>true</isDefault>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>OCALC</name>
							<description>Optimized Calculation Control.  For optimized calculation, unnecessary multiply operations after normalizing the exponent are skipped.</description>
							<lsb>4</lsb>
							<msb>4</msb>
							<enumeratedValues>
								<name>dis_en_enum</name>
								<enumeratedValue>
									<name>disable</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>enable</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>MAAER</name>
							<description>MAA Error. The MAAER bit defaults to 0 and can only be set by hardware. Once set, it must be cleared by software otherwise no new operation can be initiated.  Software writes 1 to this bit has no effect and MAAER will maintain its original state.</description>
							<lsb>7</lsb>
							<msb>7</msb>
							<enumeratedValues>
								<name>error_enum</name>
								<enumeratedValue>
									<name>noError</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>error</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>AMS</name>
							<description>Multiplier A Memory Select.  These bits select the starting position of the parameter "a" within the logical segment specified by AMA.</description>
							<lsb>8</lsb>
							<msb>9</msb>
						</field>
						<field>
							<name>BMS</name>
							<description>Multiplicand B Memory Select.  These bits select the starting position of the parameter b within the logical segment specified by BMA.</description>
							<lsb>10</lsb>
							<msb>11</msb>
						</field>
						<field>
							<name>EMS</name>
							<description>Exponent Memory Select.  These bits select the starting position of the parameter e within the logical segment specified by EMA.</description>
							<lsb>12</lsb>
							<msb>13</msb>
						</field>
						<field>
							<name>MMS</name>
							<description>Modulus Memory Select.  These bits select the starting position of the parameter m within the logical segment 5.</description>
							<lsb>14</lsb>
							<msb>15</msb>
						</field>
						<field>
							<name>AMA</name>
							<description>Multiplier / Operand A Memory Assignment. These bits select the logical cryptographic RAM segment for the parameter a.</description>
							<lsb>16</lsb>
							<msb>19</msb>
						</field>
						<field>
							<name>BMA</name>
							<description>Multiplicand / Operand B Memory Assignment. These bits select the logical cryptographic RAM segment for the parameter b.</description>
							<lsb>20</lsb>
							<msb>23</msb>
						</field>
						<field>
							<name>RMA</name>
							<description>Result Memory Assignment. These bits select the logical cryptographic RAM segment for the parameter r.</description>
							<lsb>24</lsb>
							<msb>27</msb>
						</field>
						<field>
							<name>TMA</name>
							<description>Temporary Memory Assignment. These bits select the logical cryptographic RAM segment for the parameter t.</description>
							<lsb>28</lsb>
							<msb>31</msb>
						</field>
					</fields>
				</register>
				<register>
					<dim>4</dim>
					<dimIncrement>4</dimIncrement>
					<name>CRYPTO_DIN_%s</name>
					<description>Crypto Data Input. Data input can be written to this register instead of using the DMA. This register writes to the FIFO. This register occupies four successive words to allow the use of multi-store instructions. Words can be written to any location, they will be placed in the FIFO in the order they are written. The endian swap input control bit affects this register.</description>
					<addressOffset>0x20</addressOffset>
					<access>write-only</access>
				</register>
				<register>
					<dim>4</dim>
					<dimIncrement>4</dimIncrement>
					<name>CRYPTO_DOUT_%s</name>
					<description>Crypto Data Output. Resulting data from cipher calculation. Data is placed in the lower words of these four registers depending on the algorithm. For block cipher modes, this register holds the result of most recent encryption or decryption operation. These registers are affected by the endian swap bits.</description>
					<addressOffset>0x30</addressOffset>
					<access>read-only</access>
				</register>
				<register>
					<name>CRC_POLY</name>
					<description>CRC Polynomial. The polynomial to be used for Galois Field calculations (CRC or LFSR) should be written to this register. This register is affected by the MSB control bit.</description>
					<addressOffset>0x40</addressOffset>
					<resetValue>0xEDB88320</resetValue>
				</register>
				<register>
					<name>CRC_VAL</name>
					<description>CRC Value. This is the state for the Galois Field. This register holds the result of a CRC calculation or the current state of the LFSR. This register is affected by the MSB control bit.</description>
					<addressOffset>0x44</addressOffset>
					<resetValue>0xFFFFFFFF</resetValue>
				</register>
				<register>
					<name>CRC_PRNG</name>
					<description>Pseudo Random Value. Output of the Galois Field shift register. This holds the resulting pseudo-random number if entropy is disabled or true random number if entropy is enabled.</description>
					<addressOffset>0x48</addressOffset>
					<access>read-only</access>
				</register>
				<register>
					<name>HAM_ECC</name>
					<description>Hamming ECC Register</description>
					<addressOffset>0x4C</addressOffset>
					<fields>
						<field>
							<name>ECC</name>
							<description>Hamming ECC Value. These bits are the even parity of their corresponding bit groups.</description>
							<lsb>0</lsb>
							<msb>15</msb>
						</field>
						<field>
							<name>PAR</name>
							<description>Parity. This is the parity of the entire array.</description>
							<lsb>16</lsb>
							<msb>16</msb>
							<enumeratedValues>
								<name>parity_enum</name>
								<enumeratedValue>
									<name>even</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>odd</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
					</fields>
				</register>
				<register>
					<dim>4</dim>
					<dimIncrement>4</dimIncrement>
					<name>CIPHER_INIT_%s</name>
					<description>Initial Vector. For block cipher operations that use CBC, CFB, OFB, or CNTR modes, this register holds the initial value. This register is updated with each encryption or decryption operation. This register is affected by the endian swap bits.</description>
					<addressOffset>0x50</addressOffset>
				</register>
				<register>
					<dim>8</dim>
					<dimIncrement>4</dimIncrement>
					<name>CIPHER_KEY_%s</name>
					<description>Cipher Key.  This register holds the key used for block cipher operations. The lower words are used for block ciphers that use shorter key lengths. This register is affected by the endian swap input control bits.</description>
					<addressOffset>0x60</addressOffset>
					<access>write-only</access>
				</register>
				<register>
					<dim>16</dim>
					<dimIncrement>4</dimIncrement>
					<name>HASH_DIGEST_%s</name>
					<description>This register holds the calculated hash value. This register is affected by the endian swap bits.</description>
					<addressOffset>0x80</addressOffset>
				</register>
				<register>
					<dim>4</dim>
					<dimIncrement>4</dimIncrement>
					<name>HASH_MSG_SZ_%s</name>
					<description>Message Size. This register holds the lowest 32-bit of message size in bytes.</description>
					<addressOffset>0xC0</addressOffset>
				</register>
				<register>
					<name>MAA_MAWS</name>
					<description>MAA Word Size. This register defines the number of bits for a modular operation. This register must be set to a valid value prior to the MAA operation start. Valid values are from 1 to 2048.  Invalid values are ignored and will not initiate a MAA operation.</description>
					<addressOffset>0xD0</addressOffset>
					<size>12</size>
				</register>
			</registers>
			<addressBlock>
				<offset>0x00</offset>
				<size>0x1000</size>
				<usage>registers</usage>
			</addressBlock>
		</peripheral>
		<peripheral>
			<name>DAC</name>
			<description>Digital to Analog Converter</description>
			<prependToName>DAC_</prependToName>
			<baseAddress>0x40038000</baseAddress>
			<interrupt><name>DAC</name><value>21</value></interrupt>
			<registers>
				<register>
					<name>CTRL</name>
					<description>DAC Control Register</description>
					<addressOffset>0x00</addressOffset>
					<fields>
						<field>
							<name>DACFAECNT</name>
							<description>DAC FIFO Almost Empty Level.  This value serves as a threshold- if the write data pointer in the FIFO exceeds this count, then the DACFAE flag is set.</description>
							<lsb>0</lsb>
							<msb>3</msb>
						</field>
						<field>
							<name>DACFAF</name>
							<description>FIFO Almost Full</description>
							<lsb>5</lsb>
							<msb>5</msb>
							<access>read-only</access>
						</field>
						<field derivedFrom="DACFAF">
							<name>DACFE</name>
							<description>FIFO Empty</description>
							<lsb>6</lsb>
							<msb>6</msb>
							<access>read-only</access>
						</field>
						<field derivedFrom="DACFAF">
							<name>DACFAE</name>
							<description>FIFO Almost Empty</description>
							<lsb>7</lsb>
							<msb>7</msb>
						</field>
						<field>
							<name>DACINTERPMODE</name>
							<description>DAC Interpolation Mode</description>
							<lsb>8</lsb>
							<msb>10</msb>
							<enumeratedValues>
								<name>interp_mode_enum</name>
								<enumeratedValue>
									<name>disabled</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>interp1to2</name>
									<description>1:2 Interpolation</description>
									<value>1</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>interp1to4</name>
									<description>1:4 Interpolation</description>
									<value>2</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>interp1to8</name>
									<description>1:8 Interpolation</description>
									<value>3</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>RFU</name>
									<description>Reserved. Do not use.</description>
									<isDefault>true</isDefault>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>DACFFCNT</name>
							<description>DAC FIFO Almost Full Level.  This value serves as a threshold: if the write data pointer in the FIFO exceeds this count, then the DACFAF flag is set.</description>
							<lsb>12</lsb>
							<msb>15</msb>
						</field>
						<field>
							<name>DACSTMODE</name>
							<description>DAC Output Start Mode</description>
							<lsb>16</lsb>
							<msb>17</msb>
							<enumeratedValues>
								<name>start_mode_enum</name>
								<enumeratedValue>
									<name>notEmpty</name>
									<description>Start on FIFO not empty</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>strobe</name>
									<description>Start on local DAC Start Strobe</description>
									<value>2</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>RFU</name>
									<description>Reserved. Do not use.</description>
									<isDefault>true</isDefault>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>CPUDACST</name>
							<description>DAC Start Strobe.  The CPU may write this bit to a 1 to start a conversion when DACSTMODE = 10.</description>
							<lsb>20</lsb>
							<msb>20</msb>
							<access>write-only</access>
						</field>
						<field>
							<name>DACMODE</name>
							<description>DAC Operation Mode</description>
							<lsb>24</lsb>
							<msb>25</msb>
							<enumeratedValues>
								<name>dac_op_mode_enum</name>
								<enumeratedValue>
									<name>onAvail</name>
									<description>Output Data in FIFO as soon as available.</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>perDacRateCnt</name>
									<description>Output DacSmplCnt[15:0] Data points from FIFO at Ts defined by DacRateCnt[15:0].</description>
									<value>1</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>perDacReg</name>
									<description>Use DAC_REG control.</description>
									<value>2</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>toModeChange</name>
									<description>Output DacSmplCnt[15:0] Data points from FIFO at Ts until mode changed.</description>
									<value>3</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>DACPU</name>
							<description>DAC Power Up.  Writing this bit to a 1 will power up the DAC.</description>
							<lsb>28</lsb>
							<msb>28</msb>
							<enumeratedValues>
								<name>dis_en_enum</name>
								<enumeratedValue>
									<name>disable</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>enable</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="DACPU">
							<name>DACCLKEN</name>
							<description>DAC Interface Clk Gate Enable.  Writing this bit to a 1 will enable clock to use DAC.</description>
							<lsb>29</lsb>
							<msb>29</msb>
						</field>
						<field>
							<name>DACRST</name>
							<description>DAC Timing Generator Reset. Setting this bit to a 1 resets the FIFO and all state machines.</description>
							<lsb>31</lsb>
							<msb>31</msb>
							<access>write-only</access>
							<enumeratedValues>
								<name>reset_write_enum</name>
								<enumeratedValue>
									<name>RFU</name>
									<description>Reserved. Do not use.</description>
									<isDefault>true</isDefault>
								</enumeratedValue>
								<enumeratedValue>
									<name>reset</name>
									<description>Starts reset operation</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
					</fields>
				</register>
				<register>
					<name>RATE</name>
					<description>DAC Output Rate and Sample Control</description>
					<addressOffset>0x04</addressOffset>
					<fields>
						<field>
							<name>DACRATECNT</name>
							<description>Delay between output samples in DACMODE=01.  Ts = (DACRATECNT + 2)*(1/24MHz) based on a 12MHz crystal.</description>
							<lsb>0</lsb>
							<msb>15</msb>
						</field>
						<field>
							<name>DACSAMPLECNT</name>
							<description>Number of data points to output in DACMODE=01.  If DACINTERPMODE = 0, DACSMPLCNT = Number samples to output. Else, DACSMPLCNT = (Number uninterpolated samples -1) * 2^DACINTERPMODE + 1.</description>
							<lsb>16</lsb>
							<msb>31</msb>
						</field>
					</fields>
				</register>
				<register>
					<name>INT</name>
					<description>DAC Interrupt Register</description>
					<addressOffset>0x08</addressOffset>
					<fields>
						<field>
							<name>DACDONEISR</name>
							<description>DAC output Done Interrupt status.  This bit is set to a 1 by hardware when an interrupt is triggered by the DAC output Done condition.</description>
							<lsb>0</lsb>
							<msb>0</msb>
							<modifiedWriteValues>oneToClear</modifiedWriteValues>
							<enumeratedValues>
								<name>flag_enum</name>
								<usage>read</usage>
								<enumeratedValue>
									<name>inactive</name>
									<description>No interrupt is pending</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>pending</name>
									<description>An interrupt is pending</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
							<enumeratedValues>
								<name>w1c_enum</name>
								<usage>write</usage>
								<enumeratedValue>
									<name>RFU</name>
									<description>Reserved. Do not use.</description>
									<isDefault>true</isDefault>
								</enumeratedValue>
								<enumeratedValue>
									<name>clear</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="DACDONEISR">
							<name>DACFUFISR</name>
							<description>FIFO underflow interrupt status.  This bit is set to a 1 by hardware when an interrupt is triggered by the DAC FIFO Underflow condition.</description>
							<lsb>1</lsb>
							<msb>1</msb>
						</field>
						<field derivedFrom="DACDONEISR">
							<name>DACFAEISR</name>
							<description>FIFO almost empty interrupt status.  This bit is set to a 1 by hardware when an interrupt is triggered by the DAC FIFO Almost Empty condition.</description>
							<lsb>2</lsb>
							<msb>2</msb>
						</field>
						<field>
							<name>DACDONEIE</name>
							<description>DAC Output Done Interrupt enable.   Setting this bit to a 1 allows the DAC output condition to trigger an interrupt.</description>
							<lsb>16</lsb>
							<msb>16</msb>
							<enumeratedValues>
								<name>dis_en_enum</name>
								<enumeratedValue>
									<name>disable</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>enable</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="DACDONEIE">
							<name>DACFUFIE</name>
							<description>FIFO underflow interrupt enable.  Setting this bit to a 1 allows the FIFO underflow condition to trigger an interrupt.</description>
							<lsb>17</lsb>
							<msb>17</msb>
						</field>
						<field derivedFrom="DACDONEIE">
							<name>DACFAEIE</name>
							<description>FIFO almost empty interrupt enable.  Setting this bit to a 1 allows the FIFO almost empty condition to trigger an interrupt.</description>
							<lsb>18</lsb>
							<msb>18</msb>
						</field>
					</fields>
				</register>
				<register>
					<name>REG</name>
					<description>DAC Input Register</description>
					<addressOffset>0x0C</addressOffset>
				</register>
			</registers>
			<resetValue>0x00007004</resetValue>
			<addressBlock>
				<offset>0x00</offset>
				<size>0x1000</size>
				<usage>registers</usage>
			</addressBlock>
		</peripheral>
		<peripheral>
			<name>DMAController</name>
			<description>Fully programmable, chaining capable DMA channels</description>
			<prependToName>DMA</prependToName>
			<baseAddress>0x40028000</baseAddress>
			<interrupt><name>DMA0</name><value>28</value></interrupt>
			<interrupt><name>DMA1</name><value>29</value></interrupt>
			<interrupt><name>DMA2</name><value>30</value></interrupt>
			<interrupt><name>DMA3</name><value>31</value></interrupt>
			<registers>
				<register>
					<name>_CN</name>
					<description>DMA Control Register</description>
					<addressOffset>0x000</addressOffset>
					<size>4</size>
					<fields>
						<field>
							<name>CH0_IEN</name>
							<description>Channel 0 Interrupt Enable</description>
							<lsb>0</lsb>
							<msb>0</msb>
							<enumeratedValues>
								<name>dis_en_enum</name>
								<enumeratedValue>
									<name>disable</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>enable</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="CH0_IEN">
							<name>CH1_IEN</name>
							<description>Channel 1 Interrupt Enable</description>
							<lsb>1</lsb>
							<msb>1</msb>
						</field>
						<field derivedFrom="CH0_IEN">
							<name>CH2_IEN</name>
							<description>Channel 2 Interrupt Enable</description>
							<lsb>2</lsb>
							<msb>2</msb>
						</field>
						<field derivedFrom="CH0_IEN">
							<name>CH3_IEN</name>
							<description>Channel 3 Interrupt Enable</description>
							<lsb>3</lsb>
							<msb>3</msb>
						</field>
					</fields>
				</register>
				<register>
					<name>_INT</name>
					<description>DMA Interrupt Register</description>
					<addressOffset>0x004</addressOffset>
					<size>4</size>
					<access>read-only</access>
					<fields>
						<field>
							<name>CH0_IPEND</name>
							<description>Channel Interrupt.   To clear an interrupt, all active interrupt bits of the DMA_ST must be cleared. The interrupt bits are set only if their corresponding interrupt enable bits are set in DMA_CN.</description>
							<lsb>0</lsb>
							<msb>0</msb>
							<enumeratedValues>
								<name>flag_enum</name>
								<enumeratedValue>
									<name>inactive</name>
									<description>No interrupt is pending</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>pending</name>
									<description>An interrupt is pending</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="CH0_IPEND">
							<name>CH1_IPEND</name>
							<lsb>1</lsb>
							<msb>1</msb>
						</field>
						<field derivedFrom="CH0_IPEND">
							<name>CH2_IPEND</name>
							<lsb>2</lsb>
							<msb>2</msb>
						</field>
						<field derivedFrom="CH0_IPEND">
							<name>CH3_IPEND</name>
							<lsb>3</lsb>
							<msb>3</msb>
						</field>
					</fields>
				</register>
				<register>
					<dim>4</dim>
					<dimIncrement>0x20</dimIncrement>
					<name>_%s_CFG</name>
					<description>DMA Channel Configuration Register</description>
					<addressOffset>0x100</addressOffset>
					<fields>
						<field>
							<name>CHEN</name>
							<description>Channel Enable.  This bit is automatically cleared when DMA_ST.CH_ST changes from 1 to 0.</description>
							<lsb>0</lsb>
							<msb>0</msb>
							<enumeratedValues>
								<name>dis_en_enum</name>
								<enumeratedValue>
									<name>disable</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>enable</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="CHEN">
							<name>RLDEN</name>
							<description>Reload Enable. Setting this bit to 1 enables DMA_SRC, DMA_DST and DMA_CNT to be reloaded with their corresponding reload registers upon count-to-zero. This bit is also writeable in the Count Reload Register. Refer to the description on Buffer Chaining for use of this bit. If buffer chaining is not used this bit must be written with a 0. This bit should be set after the reload registers have been programmed.</description>
							<lsb>1</lsb>
							<msb>1</msb>
						</field>
						<field>
							<name>PRI</name>
							<description>DMA Priority</description>
							<lsb>2</lsb>
							<msb>3</msb>
							<enumeratedValues>
								<name>priority_enum</name>
								<enumeratedValue>
									<name>high</name>
									<description>Highest Priority</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>medHigh</name>
									<value>1</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>medLow</name>
									<value>2</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>low</name>
									<description>Lowest Priority</description>
									<value>3</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>REQSEL</name>
							<description>Request Select. Select DMA request line for this channel. If memory-to-memory is selected, the channel operates as if the request is always active.</description>
							<lsb>4</lsb>
							<msb>9</msb>
							<enumeratedValues>
								<name>dma_transfer_enum</name>
								<enumeratedValue>
									<name>memToMem</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>spi0Rx</name>
									<value>1</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>spi1Rx</name>
									<value>2</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>spi2Rx</name>
									<value>3</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>uart0Rx</name>
									<value>4</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>uart1Rx</name>
									<value>5</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>i2cRx</name>
									<value>7</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>msrT1Rx</name>
									<value>11</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>msrT2Rx</name>
									<value>12</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>msrT3Rx</name>
									<value>13</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>spi0Tx</name>
									<value>33</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>spi1Tx</name>
									<value>34</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>spi2Tx</name>
									<value>35</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>uart0Tx</name>
									<value>36</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>uart1Tx</name>
									<value>37</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>i2cTx</name>
									<value>39</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>RFU</name>
									<description>Reserved. Do no use.</description>
									<isDefault>true</isDefault>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="CHEN">
							<name>REQWAIT</name>
							<description>Request Wait Enable.  When enabled, delay timer start until DMA request transitions from active to inactive.</description>
							<lsb>10</lsb>
							<msb>10</msb>
						</field>
						<field>
							<name>TOSEL</name>
							<description>Time-Out Select. Selects the number of prescale clocks seen by the channel timer before a time-out conditions is generated for this channel. Important note: since the prescaler runs independent of the individual channel timers, the actual number of Pre-Scale clock edges seen has a margin of error equal to a single Pre-Scale clock.</description>
							<lsb>11</lsb>
							<msb>13</msb>
							<enumeratedValues>
								<name>timeout_enum</name>
								<enumeratedValue>
									<name>to4</name>
									<description>Timeout of 3 to 4 prescale clocks</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>to8</name>
									<description>Timeout of 7 to 8 prescale clocks</description>
									<value>1</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>to16</name>
									<description>Timeout of 15 to 16 prescale clocks</description>
									<value>2</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>to32</name>
									<description>Timeout of 31 to 32 prescale clocks</description>
									<value>3</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>to64</name>
									<description>Timeout of 63 to 64 prescale clocks</description>
									<value>4</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>to128</name>
									<description>Timeout of 127 to 128 prescale clocks</description>
									<value>5</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>to256</name>
									<description>Timeout of 255 to 256 prescale clocks</description>
									<value>6</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>to512</name>
									<description>Timeout of 511 to 512 prescale clocks</description>
									<value>7</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>PSSEL</name>
							<description>Pre-Scale Select. Selects the Pre-Scale divider for timer clock input.</description>
							<lsb>14</lsb>
							<msb>15</msb>
							<enumeratedValues>
								<name>prescale_enum</name>
								<enumeratedValue>
									<name>disable</name>
									<description>Disable timer</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>div256</name>
									<description>hclk / 256</description>
									<value>1</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>div64k</name>
									<description>hclk / 64k</description>
									<value>2</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>div16M</name>
									<description>hclk / 16M</description>
									<value>3</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>SRCWD</name>
							<description>Source Width. In most cases, this will be the data width of each AHB transactions. However, the width will be reduced in the cases where DMA_CNT indicates a smaller value.</description>
							<lsb>16</lsb>
							<msb>17</msb>
							<enumeratedValues>
								<name>width_enum</name>
								<enumeratedValue>
									<name>byte</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>halfWord</name>
									<value>1</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>word</name>
									<value>2</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>RFU</name>
									<description>Reserved. Do not use.</description>
									<isDefault>true</isDefault>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="CHEN">
							<name>SRCINC</name>
							<description>Source Increment Enable. This bit enables DMA_SRC increment upon every AHB transaction. This bit is forced to 0 for DMA receive from peripherals.</description>
							<lsb>18</lsb>
							<msb>18</msb>
						</field>
						<field derivedFrom="SRCWD">
							<name>DSTWD</name>
							<description>Destination Width. Indicates the width of the each AHB transactions to the destination peripheral or memory. (The actual width may be less than this if there are insufficient bytes in the DMA FIFO for the full width).</description>
							<lsb>20</lsb>
							<msb>21</msb>
						</field>
						<field derivedFrom="CHEN">
							<name>DSTINC</name>
							<description>Destination Increment Enable. This bit enables DMA_DST increment upon every AHB transaction. This bit is forced to 0 for DMA transmit to peripherals.</description>
							<lsb>22</lsb>
							<msb>22</msb>
						</field>
						<field>
							<name>BRST</name>
							<description>Burst Size. The number of bytes to be transferred into and out of the DMA FIFO in a single burst.  Burst size equals 1 + value stored in this field.</description>
							<lsb>24</lsb>
							<msb>28</msb>
						</field>
						<field derivedFrom="CHEN">
							<name>CHDIEN</name>
							<description>Channel Disable Interrupt Enable. When enabled, the IPEND will be set to 1 whenever CH_ST changes from 1 to 0.</description>
							<lsb>30</lsb>
							<msb>30</msb>
						</field>
						<field derivedFrom="CHEN">
							<name>CTZIEN</name>
							<description>Count-to-zero Interrupts Enable. When enabled, the IPEND will be set to 1 whenever a count-to-zero event occurs.</description>
							<lsb>31</lsb>
							<msb>31</msb>
						</field>
					</fields>
				</register>
				<register>
					<dim>4</dim>
					<dimIncrement>0x20</dimIncrement>
					<name>_%s_ST</name>
					<description>DMA Channel Status Register</description>
					<addressOffset>0x104</addressOffset>
					<fields>
						<field>
							<name>CH_ST</name>
							<description>Channel Status. This bit is used to indicate to the programmer when it is safe to change the configuration, address, and count registers for the channel. Whenever this bit is cleared by hardware,  the DMA_CFG.CHEN bit is also cleared (if not cleared already).</description>
							<lsb>0</lsb>
							<msb>0</msb>
							<access>read-only</access>
							<enumeratedValues>
								<name>dis_en_enum</name>
								<enumeratedValue>
									<name>disable</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>enable</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>IPEND</name>
							<description>Channel Interrupt</description>
							<lsb>1</lsb>
							<msb>1</msb>
							<access>read-only</access>
							<enumeratedValues>
								<name>flag_enum</name>
								<enumeratedValue>
									<name>inactive</name>
									<description>No interrupt is pending</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>pending</name>
									<description>An interrupt is pending</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>CTZ_ST</name>
							<description>Count-to-Zero (CTZ) Status</description>
							<lsb>2</lsb>
							<msb>2</msb>
							<modifiedWriteValues>oneToClear</modifiedWriteValues>
							<enumeratedValues>
								<name>event_flag_enum</name>
								<usage>read</usage>
								<enumeratedValue>
									<name>noEvent</name>
									<description>The event has not occurred</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>occurred</name>
									<description>The event has occurred</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
							<enumeratedValues>
								<name>w1c_enum</name>
								<usage>write</usage>
								<enumeratedValue>
									<name>RFU</name>
									<description>Reserved. Do not use.</description>
									<isDefault>true</isDefault>
								</enumeratedValue>
								<enumeratedValue>
									<name>clear</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="CTZ_ST">
							<name>RLD_ST</name>
							<description>Reload Status</description>
							<lsb>3</lsb>
							<msb>3</msb>
						</field>
						<field derivedFrom="CTZ_ST">
							<name>BUS_ERR</name>
							<description>Bus Error. Indicates that an AHB abort was received and the channel has been disabled.</description>
							<lsb>4</lsb>
							<msb>4</msb>
						</field>
						<field derivedFrom="CTZ_ST">
							<name>TO_ST</name>
							<description>Time-Out Status</description>
							<lsb>6</lsb>
							<msb>6</msb>
						</field>
					</fields>
				</register>
				<register>
					<dim>4</dim>
					<dimIncrement>0x20</dimIncrement>
					<name>_%s_SRC</name>
					<description>Source Device Address. If SRCINC=1, the counter bits are incremented by 1,2, or 4, depending on the data width of each AHB cycle. For peripheral transfers, some or all of the actual address bits are fixed. If SRCINC=0, this register remains constant. In the case where a count-to-zero condition occurs while RLDEN=1, the register is reloaded with the contents of DMA_SRC_RLD.</description>
					<addressOffset>0x108</addressOffset>
				</register>
				<register>
					<dim>4</dim>
					<dimIncrement>0x20</dimIncrement>
					<name>_%s_DST</name>
					<description>Destination Device Address. For peripheral transfers, some or all of the actual address bits are fixed. If DSTINC=1, this register is incremented on every AHB write out of the DMA FIFO. They are incremented by 1, 2, or 4, depending on the data width of each AHB cycle. In the case where a count-to-zero condition occurs while RLDEN=1, the register is reloaded with DMA_DST_RLD.</description>
					<addressOffset>0x10C</addressOffset>
				</register>
				<register>
					<dim>4</dim>
					<dimIncrement>0x20</dimIncrement>
					<name>_%s_CNT</name>
					<description>DMA Counter. The user loads this register with the number of bytes to transfer. This counter decreases on every AHB cycle into the DMA FIFO. The decrement will be 1, 2, or 4 depending on the data width of each AHB cycle. When the counter reaches 0, a count-to-zero condition is triggered.</description>
					<addressOffset>0x110</addressOffset>
					<size>24</size>
				</register>
				<register>
					<dim>4</dim>
					<dimIncrement>0x20</dimIncrement>
					<name>_%s_SRC_RLD</name>
					<description>Source Address Reload Value. The value of this register is loaded into DMA0_SRC upon a count-to-zero condition.</description>
					<addressOffset>0x0114</addressOffset>
					<size>31</size>
				</register>
				<register>
					<dim>4</dim>
					<dimIncrement>0x20</dimIncrement>
					<name>_%s_DST_RLD</name>
					<description>Destination Address Reload Value. The value of this register is loaded into DMA0_DST upon a count-to-zero condition.</description>
					<addressOffset>0x118</addressOffset>
					<size>31</size>
				</register>
				<register>
					<dim>4</dim>
					<dimIncrement>0x20</dimIncrement>
					<name>_%s_CNT_RLD</name>
					<description>DMA Channel Count Reload Register</description>
					<addressOffset>0x11C</addressOffset>
					<fields>
						<field>
							<name>CNT_RLD</name>
							<description>Count Reload Value. The value of this register is loaded into DMA0_CNT upon a count-to-zero condition.</description>
							<lsb>0</lsb>
							<msb>23</msb>
						</field>
						<field>
							<name>RLDEN</name>
							<description>Reload Enable. This bit should be set after the address reload registers have been programmed. This bit is automatically cleared to 0 when reload occurs.</description>
							<lsb>31</lsb>
							<msb>31</msb>
							<enumeratedValues>
								<name>dis_en_enum</name>
								<enumeratedValue>
									<name>disable</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>enable</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
					</fields>
				</register>
			</registers>
			<addressBlock>
				<offset>0x00</offset>
				<size>0x1000</size>
				<usage>registers</usage>
			</addressBlock>
		</peripheral>
		<peripheral>
			<name>FlashController</name>
			<description>Flash Memory Control</description>
			<baseAddress>0x40029000</baseAddress>
			<interrupt><name>Flash_Controller</name><value>23</value></interrupt>
			<registers>
				<register>
					<name>FLSH_ADDR</name>
					<description>Flash Write Address</description>
					<addressOffset>0x00</addressOffset>
				</register>
				<register>
					<name>FLSH_CLKDIV</name>
					<description>Flash Clock Divide. The clock (PLL0) is divided by this value to generate a 1 MHz clock for Flash controller.</description>
					<addressOffset>0x04</addressOffset>
					<size>8</size>
					<resetValue>0x00000064</resetValue>
				</register>
				<register>
					<name>FLSH_CN</name>
					<description>Flash Control Register</description>
					<addressOffset>0x08</addressOffset>
					<fields>
						<field>
							<name>WR</name>
							<description>Write.  This bit is automatically cleared after the operation.</description>
							<lsb>0</lsb>
							<msb>0</msb>
							<enumeratedValues>
								<name>start_op_enum</name>
								<enumeratedValue>
									<name>complete</name>
									<description>No operation/complete</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>start</name>
									<description>Start operation</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="WR">
							<name>ME</name>
							<description>Mass Erase.  This bit is automatically cleared after the operation.</description>
							<lsb>1</lsb>
							<msb>1</msb>
						</field>
						<field derivedFrom="WR">
							<name>PGE</name>
							<description>Page Erase.  This bit is automatically cleared after the operation.</description>
							<lsb>2</lsb>
							<msb>2</msb>
						</field>
						<field>
							<name>WDTH</name>
							<description>Data Width.  This bits selects write data width.</description>
							<lsb>4</lsb>
							<msb>4</msb>
							<enumeratedValues>
								<name>data_width_enum</name>
								<enumeratedValue>
									<name>size128</name>
									<description>128-bit</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>size32</name>
									<description>32-bit</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>ERASE_CODE</name>
							<description>Erase Code.  The ERASE_CODE must be set up property before erase operation can be initiated. These bits are automatically cleared after the operation is complete.</description>
							<lsb>8</lsb>
							<msb>15</msb>
							<enumeratedValues>
								<name>erase_code_enum</name>
								<enumeratedValue>
									<name>nop</name>
									<description>No operation</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>erasePage</name>
									<description>Enable Page Erase</description>
									<value>0x55</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>eraseAll</name>
									<description>Enable Mass Erase. The debug port must be enabled.</description>
									<value>0xAA</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>RFU</name>
									<description>Reserved. Do not use.</description>
									<isDefault>true</isDefault>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>PEND</name>
							<description>Flash Pending.  When Flash operation is in progress (busy), Flash reads and writes will fail. When PEND is set, write to all Flash registers, with exception of the Flash interrupt register, are ignored.</description>
							<lsb>24</lsb>
							<msb>24</msb>
							<access>read-only</access>
							<enumeratedValues>
								<name>busy_enum</name>
								<enumeratedValue>
									<name>idle</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>busy</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="PEND">
							<name>PREBOOT</name>
							<description>Preboot Status</description>
							<lsb>26</lsb>
							<msb>26</msb>
						</field>
						<field>
							<name>BRST</name>
							<description>Burst Mode Enable</description>
							<lsb>27</lsb>
							<msb>27</msb>
							<enumeratedValues>
								<name>dis_en_enum</name>
								<enumeratedValue>
									<name>disable</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>enable</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>UNLOCK</name>
							<description>Flash Unlock.  The correct unlock code must be written to these four bits before any Flash write or erase operation is allowed.</description>
							<lsb>28</lsb>
							<msb>31</msb>
							<enumeratedValues>
								<name>flash_lock_enum</name>
								<enumeratedValue>
									<name>unlocked</name>
									<value>2</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>locked</name>
									<isDefault>true</isDefault>
								</enumeratedValue>
							</enumeratedValues>
						</field>
					</fields>
				</register>
				<register>
					<name>FLSH_INT</name>
					<description>Flash Interrupt Register</description>
					<addressOffset>0x024</addressOffset>
					<fields>
						<field>
							<name>DONE</name>
							<description>Flash Done Interrupt.  This bit is set to 1 upon Flash write or erase completion.</description>
							<lsb>0</lsb>
							<msb>0</msb>
							<enumeratedValues>
								<name>flag_enum</name>
								<enumeratedValue>
									<name>inactive</name>
									<description>No interrupt is pending.</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>pending</name>
									<description>An interrupt is pending.</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>AF</name>
							<description>Flash Access Fail.  This bit is set when an attempt is made to write the flash while the flash is busy or the flash is locked. This bit can only be set to 1 by hardware.</description>
							<lsb>1</lsb>
							<msb>1</msb>
							<enumeratedValues>
								<name>error_enum</name>
								<enumeratedValue>
									<name>noError</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>error</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>DONEIE</name>
							<description>Flash Done Interrupt Enable</description>
							<lsb>8</lsb>
							<msb>8</msb>
							<enumeratedValues>
								<name>dis_en_enum</name>
								<enumeratedValue>
									<name>disable</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>enable</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="DONEIE">
							<name>AFIE</name>
							<lsb>9</lsb>
							<msb>9</msb>
						</field>
					</fields>
				</register>
				<register>
					<dim>4</dim>
					<dimIncrement>4</dimIncrement>
					<name>FLSH_DATA%s</name>
					<description>Flash Write Data</description>
					<addressOffset>0x30</addressOffset>
				</register>
				<register>
					<name>ACNTL</name>
					<description>Access Control Register. Writing the ACNTL register with the following values in the order shown, allows read and write access to the system and user Information block: pflc-&gt;acntl = 0x3a7f5ca3; pflc-&gt;acntl = 0xa1e34f20; pflc-&gt;acntl = 0x9608b2c1. When unlocked, a write of any word will disable access to system and user information block. Readback of this register is always zero.</description>
					<addressOffset>0x40</addressOffset>
					<access>write-only</access>
				</register>
			</registers>
			<addressBlock>
				<offset>0x00</offset>
				<size>0x1000</size>
				<usage>registers</usage>
			</addressBlock>
		</peripheral>
		<peripheral>
			<name>I2C</name>
			<description>Inter-Integrated Circuit</description>
			<prependToName>I2C_</prependToName>
			<baseAddress>0x4000C000</baseAddress>
			<baseAddress>0x4000C000</baseAddress>
			<interrupt><name>I2C</name><value>13</value></interrupt>
			<registers>
				<register>
					<name>CR</name>
					<description>Control Register</description>
					<addressOffset>0x00</addressOffset>
					<fields>
						<field>
							<name>RXTHD</name>
							<description>Receive FIFO Threshold. This field specifies the depth of receive FIFO for interrupt generation.</description>
							<lsb>0</lsb>
							<msb>3</msb>
							<enumeratedValues>
								<name>rx_thd_enum</name>
								<enumeratedValue>
									<name>ignored</name>
									<description>Reserved. Do not use.</description>
									<isDefault>true</isDefault>
								</enumeratedValue>
								<enumeratedValue>
									<name>word1</name>
									<description>1 word</description>
									<value>1</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>word2</name>
									<description>2 words</description>
									<value>2</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>word3</name>
									<description>3 words</description>
									<value>3</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>word4</name>
									<description>4 words</description>
									<value>4</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>word5</name>
									<description>5 words</description>
									<value>5</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>word6</name>
									<description>6 words</description>
									<value>6</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>word7</name>
									<description>7 words</description>
									<value>7</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>word8</name>
									<description>8 words</description>
									<value>8</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>AUTOSTT</name>
							<description>Auto Start. If this bit is 1, I2C communication starts automatically when a word is placed in the transmit FIFO.</description>
							<lsb>4</lsb>
							<msb>4</msb>
							<enumeratedValues>
								<name>dis_en_enum</name>
								<enumeratedValue>
									<name>disable</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>enable</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>START</name>
							<description>Start communication. When 1 is written, I2C communication is started. This bit is automatically cleared by hardware when the first byte is sent.</description>
							<lsb>5</lsb>
							<msb>5</msb>
							<access>write-only</access>
							<enumeratedValues>
								<name>start_op_enum</name>
								<enumeratedValue>
									<name>complete</name>
									<description>No operation/complete</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>start</name>
									<description>Start operation</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="START">
							<name>RESTART</name>
							<description>Restart. When 1 is written, the communication restarts if the slave does not acknowledge the first byte (the address byte).</description>
							<lsb>6</lsb>
							<msb>6</msb>
						</field>
						<field derivedFrom="START">
							<name>STOP</name>
							<description>Stop Read communication. No effect on write communication.</description>
							<lsb>7</lsb>
							<msb>7</msb>
							<access>read-write</access>
						</field>
						<field derivedFrom="STOP">
							<name>TXFLUSH</name>
							<description>Flush Transmit FIFO. This bit is cleared by hardware.</description>
							<lsb>8</lsb>
							<msb>8</msb>
						</field>
						<field derivedFrom="START">
							<name>RXFLUSH</name>
							<description>Flush Receive FIFO. This bit is cleared by hardware.</description>
							<lsb>9</lsb>
							<msb>9</msb>
						</field>
						<field derivedFrom="AUTOSTT">
							<name>AFREAD</name>
							<description>Auto Read. If set to 1, this bit indicates that the current transfer should not be stopped but restarted when the transmit FIFO becomes empty (generally used to perform a read after a write transfer). The FREEZE bit should be set to prevent any error on the read operation. Use the I2C_ISR.RDYRDIS bit to know when you can write the slave address (in read mode) in the transmit FIFO.</description>
							<lsb>10</lsb>
							<msb>10</msb>
							<access>write-only</access>
						</field>
						<field derivedFrom="AFREAD">
							<name>FREEZE</name>
							<description>Freeze.  If set to 1, the I2C bus is frozen if the transmit FIFO is empty during a write or if the receive FIFO is full during a read.</description>
							<lsb>11</lsb>
							<msb>11</msb>
						</field>
					</fields>
				</register>
				<register>
					<name>SR</name>
					<description>Status Register</description>
					<addressOffset>0x04</addressOffset>
					<access>read-only</access>
					<resetValue>0x00000050</resetValue>
					<fields>
						<field>
							<name>BUSY</name>
							<description>Busy. The I2C Bus is busy when another master is using the bus or this interface itself is using the bus.</description>
							<lsb>0</lsb>
							<msb>0</msb>
							<enumeratedValues>
								<name>busy_enum</name>
								<enumeratedValue>
									<name>idle</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>busy</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>FROZEN</name>
							<description>Bus Frozen. This occurs when the clock signal is stuck at 0, such as being held by another device.</description>
							<lsb>1</lsb>
							<msb>1</msb>
							<enumeratedValues>
								<name>frozen_enum</name>
								<enumeratedValue>
									<name>notFrozen</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>frozen</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>RXEMPTY</name>
							<description>Receive FIFO Empty</description>
							<lsb>4</lsb>
							<msb>4</msb>
							<enumeratedValues>
								<name>empty_enum</name>
								<enumeratedValue>
									<name>notEmpty</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>empty</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>RXFULL</name>
							<description>Receive FIFO Full</description>
							<lsb>5</lsb>
							<msb>5</msb>
							<enumeratedValues>
								<name>full_enum</name>
								<enumeratedValue>
									<name>notFull</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>full</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="RXEMPTY">
							<name>TXEMPTY</name>
							<description>Transmit FIFO Empty</description>
							<lsb>6</lsb>
							<msb>6</msb>
						</field>
						<field derivedFrom="RXFULL">
							<name>TXFULL</name>
							<description>Transmit FIFO Full</description>
							<lsb>7</lsb>
							<msb>7</msb>
						</field>
						<field>
							<name>RXELT</name>
							<description>Number of byte in the RX FIFO</description>
							<lsb>8</lsb>
							<msb>11</msb>
						</field>
						<field>
							<name>TXELT</name>
							<description>Number of byte in the TX FIFO</description>
							<lsb>12</lsb>
							<msb>15</msb>
						</field>
					</fields>
				</register>
				<register>
					<name>IER</name>
					<description>Interrupt Enable Register</description>
					<addressOffset>0x08</addressOffset>
					<fields>
						<field>
							<name>LOSTIE</name>
							<description>Loss of Transfer Interrupt Enable</description>
							<lsb>0</lsb>
							<msb>0</msb>
							<enumeratedValues>
								<name>dis_en_enum</name>
								<enumeratedValue>
									<name>disable</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>enable</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="LOSTIE">
							<name>NOANSIE</name>
							<description>Address NACK (not acknowledge) Interrupt Enable</description>
							<lsb>1</lsb>
							<msb>1</msb>
						</field>
						<field derivedFrom="LOSTIE">
							<name>COMENDIE</name>
							<description>Communication End Interrupt Enable</description>
							<lsb>2</lsb>
							<msb>2</msb>
						</field>
						<field derivedFrom="LOSTIE">
							<name>RDYRDIE</name>
							<description>Read Ready Interrupt Enable</description>
							<lsb>3</lsb>
							<msb>3</msb>
						</field>
						<field derivedFrom="LOSTIE">
							<name>FFRXIE</name>
							<description>Receive FIFO Threshold Enable</description>
							<lsb>4</lsb>
							<msb>4</msb>
						</field>
						<field derivedFrom="LOSTIE">
							<name>FFTXOIE</name>
							<description>Transmit FIFO Last Word Interrupt Enable</description>
							<lsb>5</lsb>
							<msb>5</msb>
						</field>
						<field derivedFrom="LOSTIE">
							<name>FFTXHIE</name>
							<description>Transmit FIFO Last Four Words Interrupt Enable</description>
							<lsb>6</lsb>
							<msb>6</msb>
						</field>
					</fields>
				</register>
				<register>
					<name>ISR</name>
					<description>Interrupt Status Register</description>
					<addressOffset>0x0C</addressOffset>
					<fields>
						<field>
							<name>LOSTIS</name>
							<description>Loss of Transfer Interrupt Status. This occurs when the current transfer is lost due to another master.</description>
							<lsb>0</lsb>
							<msb>0</msb>
							<enumeratedValues>
								<name>flag_enum</name>
								<enumeratedValue>
									<name>inactive</name>
									<description>No interrupt is pending.</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>pending</name>
									<description>An interrupt is pending.</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="LOSTIS">
							<name>NOANSIS</name>
							<description>Address NACK (not acknowledge) Interrupt Status. This occurs when no slave responds to the address.</description>
							<lsb>1</lsb>
							<msb>1</msb>
						</field>
						<field derivedFrom="LOSTIS">
							<name>COMENDIS</name>
							<description>Communication End Interrupt Status. This occurs when the current transfer is over.</description>
							<lsb>2</lsb>
							<msb>2</msb>
						</field>
						<field derivedFrom="LOSTIS">
							<name>RDYRDIS</name>
							<description>Read Ready Interrupt Status. This occurs when the current write transfer is done and the next read is ready to be processed (only if AFREAD=1).</description>
							<lsb>3</lsb>
							<msb>3</msb>
						</field>
						<field derivedFrom="LOSTIS">
							<name>FFRXIS</name>
							<description>Receive FIFO Threshold Status. This occurs when FIFO RX reaches the programmed threshold.</description>
							<lsb>4</lsb>
							<msb>4</msb>
						</field>
						<field derivedFrom="LOSTIS">
							<name>FFTXOIS</name>
							<description>Transmit FIFO Last Word Interrupt Status. This occurs when there is only one byte remaining in the TX FIFO.</description>
							<lsb>5</lsb>
							<msb>5</msb>
						</field>
						<field derivedFrom="LOSTIS">
							<name>FFTXHIS</name>
							<description>Transmit FIFO Last Four Words Interrupt Status. This occurs when there are four bytes remaining in the TX FIFO.</description>
							<lsb>6</lsb>
							<msb>6</msb>
						</field>
					</fields>
				</register>
				<register>
					<name>BRR</name>
					<description>Baud Rate Divisor. DIV = Nominal Frequency / (32 x Desired Frequency), where the nominal frequency  = 2 x fPLL0.</description>
					<addressOffset>0x10</addressOffset>
					<size>7</size>
				</register>
				<register>
					<name>RCR</name>
					<description>RX Count. Number of bytes to read. This register is used to specify how many bytes should be read from the device before stopping the communication.</description>
					<addressOffset>0x14</addressOffset>
					<size>16</size>
				</register>
				<register>
					<name>TXR</name>
					<description>TX FIFO Output. This register is used to read the output of the FIFO, reading this register does not read the FIFO itself. This register is mainly used for debug purpose.</description>
					<addressOffset>0x18</addressOffset>
					<size>8</size>
				</register>
				<register>
					<name>DR</name>
					<description>Data register. This register is used to obtain data from or place data into the FIFO. Read this register to retrieve the oldest data available in the RX FIFO. Write this register to place data in the TX FIFO.</description>
					<addressOffset>0x1C</addressOffset>
					<size>8</size>
				</register>
				<register>
					<name>DMR</name>
					<description>DMA Register</description>
					<addressOffset>0x2C</addressOffset>
					<fields>
						<field>
							<name>TXCNT</name>
							<description>TX threshold</description>
							<lsb>0</lsb>
							<msb>3</msb>
						</field>
						<field>
							<name>TXEN</name>
							<description>TX channel enable</description>
							<lsb>4</lsb>
							<msb>4</msb>
							<enumeratedValues>
								<name>dis_en_enum</name>
								<enumeratedValue>
									<name>disable</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>enable</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>RXCNT</name>
							<description>RX threshold</description>
							<lsb>5</lsb>
							<msb>8</msb>
						</field>
						<field derivedFrom="TXEN">
							<name>RXEN</name>
							<description>RX channel enable</description>
							<lsb>9</lsb>
							<msb>9</msb>
						</field>
					</fields>
				</register>
			</registers>
			<addressBlock>
				<offset>0x00</offset>
				<size>0x1000</size>
				<usage>registers</usage>
			</addressBlock>
		</peripheral>
		<peripheral>
			<name>MagneticStripeReader</name>
			<description>Magnetic Stripe Reader</description>
			<baseAddress>0x4002B000</baseAddress>
			<interrupt><name>MSR</name><value>22</value></interrupt>
			<registers>
				<register>
					<name>DSPADDR</name>
					<description>MSR Indirect Address Register Access. Indirectly access MSR settings registers by writing the index to this register. The register values are accessible by reading the DSPDATA register.</description>
					<addressOffset>0x00</addressOffset>
					<size>8</size>
					<fields>
						<field>
							<name>ADDR</name>
							<description>MSR Indirect Address Register Access</description>
							<lsb>0</lsb>
							<msb>7</msb>
							<enumeratedValues>
								<name>mcr_regs_enum</name>
								<enumeratedValue>
									<name>t13Scale</name>
									<description>Track 1 and 3 scale factor</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>t2Scale</name>
									<description>Track 2 scale factor</description>
									<value>1</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>t13ZctFast</name>
									<description>Zero Cross Threshold Fast for Tracks 1 and 3</description>
									<value>2</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>t13ZctMid</name>
									<description>Zero Cross Threshold Middle for Tracks 1 and 3</description>
									<value>3</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>t13ZctSlow</name>
									<description>Zero Cross Threshold Slow for Tracks 1 and 3</description>
									<value>4</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>t2ZctFast</name>
									<description>Zero Cross Threshold Fast for Track 2</description>
									<value>5</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>t2ZctMid</name>
									<description>Zero Cross Threshold Middle for Track 2</description>
									<value>6</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>t2ZctSlow</name>
									<description>Zero Cross Threshold Slow for Track 2</description>
									<value>7</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>startPcnt</name>
									<description>Leading 0 Detection Count</description>
									<value>8</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>t1DataCnt</name>
									<description>Track 1 Data Count</description>
									<value>9</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>t2DataCnt</name>
									<description>Track 2 Data Count</description>
									<value>10</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>t3DataCnt</name>
									<description>Track 3 Data Count</description>
									<value>11</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>adcCfg</name>
									<description>ADC Configuration</description>
									<value>18</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>RFU</name>
									<description>Reserved. Do no use.</description>
									<isDefault>true</isDefault>
								</enumeratedValue>
							</enumeratedValues>
						</field>
					</fields>
				</register>
				<register>
					<name>DSPCTRL</name>
					<description>MSR DSP Control Register</description>
					<addressOffset>0x04</addressOffset>
					<resetValue>0x00001A00</resetValue>
					<fields>
						<field>
							<name>DSPEN</name>
							<description>DSP Enable.  Setting this bit to 1 enables the DSP Functionality. Clearing this bit to 0 disables the DSP.</description>
							<lsb>0</lsb>
							<msb>0</msb>
							<enumeratedValues>
								<name>dis_en_enum</name>
								<enumeratedValue>
									<name>disable</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>enable</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>DSP_PKDETECT</name>
							<description>DSP Peak Detect Threshold Mode</description>
							<lsb>1</lsb>
							<msb>1</msb>
							<enumeratedValues>
								<name>pk_detect_enum</name>
								<enumeratedValue>
									<name>variable</name>
									<description>Select Variable Threshold Mode</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>fixed</name>
									<description>Select Fixed Threshold Mode</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="DSPEN">
							<name>FIFO_INT_EN</name>
							<description>DSP FIFO Interrupt Enable.  Enable the FIFO To cause an interrupt when ready to be read.</description>
							<lsb>2</lsb>
							<msb>2</msb>
						</field>
						<field>
							<name>DSP_INTF</name>
							<description>DSP Interrupt Flag.  Set to 1 by hardware when swipe is complete.  Can be set or cleared by software.</description>
							<lsb>4</lsb>
							<msb>4</msb>
							<enumeratedValues>
								<name>flag_enum</name>
								<enumeratedValue>
									<name>inactive</name>
									<description>No interrupt is pending.</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>pending</name>
									<description>An interrupt is pending.</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="DSP_INTF">
							<name>T1_INTF</name>
							<description>T1 FIFO Interrupt Flag.  Set by hardware when FIFO is ready for reading.  Can be set or cleared by software.</description>
							<lsb>5</lsb>
							<msb>5</msb>
						</field>
						<field derivedFrom="DSP_INTF">
							<name>T2_INTF</name>
							<description>T2 FIFO Interrupt Flag.  Set by hardware when FIFO is ready for reading.  Can be set or cleared by software.</description>
							<lsb>6</lsb>
							<msb>6</msb>
						</field>
						<field derivedFrom="DSP_INTF">
							<name>T3_INTF</name>
							<description>T3 FIFO Interrupt Flag.  Set by hardware when FIFO is ready for reading.  Can be set or cleared by software.</description>
							<lsb>7</lsb>
							<msb>7</msb>
						</field>
						<field>
							<name>DIV_RATIO</name>
							<description>ADC clock divide ratio.  ADC_CLK freq. = PCLK freq. / (DIV_RATIO + 1)</description>
							<lsb>8</lsb>
							<msb>14</msb>
						</field>
					</fields>
				</register>
				<register>
					<name>DSPDATA</name>
					<description>MSR Indirect Data Register. Indirectly access MSR settings registers by access this register. This register represents an index register whose index is written to DSPADDR register.</description>
					<addressOffset>0x08</addressOffset>
					<resetMask>0x00000000</resetMask>
				</register>
				<register>
					<dim>3</dim>
					<dimIncrement>4</dimIncrement>
					<dimIndex>1,2,3</dimIndex>
					<name>T%sFIFO</name>
					<description>Track FIFO Data Output Register</description>
					<addressOffset>0x0C</addressOffset>
					<size>16</size>
					<access>read-only</access>
				</register>
			</registers>
			<addressBlock>
				<offset>0x00</offset>
				<size>0x1000</size>
				<usage>registers</usage>
			</addressBlock>
		</peripheral>
		<peripheral>
			<name>MonoLCDController</name>
			<description>LCD Interface</description>
			<prependToName>LCD_</prependToName>
			<baseAddress>0x40030000</baseAddress>
			<interrupt><name>LCD_TFT</name><value>12</value></interrupt>
			<registers>
				<register>
					<name>CN</name>
					<description>LCD Control Register</description>
					<addressOffset>0x00</addressOffset>
					<resetValue>0x00000080</resetValue>
					<fields>
						<field>
							<name>TXIE</name>
							<description>Data Transmit Interrupt Enable</description>
							<lsb>0</lsb>
							<msb>0</msb>
							<enumeratedValues>
								<name>dis_en_enum</name>
								<enumeratedValue>
									<name>disable</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>enable</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="TXIE">
							<name>RXIE</name>
							<description>Data Receive Interrupt Enable</description>
							<lsb>1</lsb>
							<msb>1</msb>
						</field>
						<field derivedFrom="TXIE">
							<name>AE</name>
							<description>Automatic Mode Enable</description>
							<lsb>2</lsb>
							<msb>2</msb>
						</field>
						<field>
							<name>NIBBLE</name>
							<description>Bus Width Select</description>
							<lsb>3</lsb>
							<msb>3</msb>
							<enumeratedValues>
								<name>bus_width_enum</name>
								<enumeratedValue>
									<name>width8bit</name>
									<description>8 bit bus width</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>width4bit</name>
									<description>4 bit bus width (This feature is only available when AUTOEN=1)</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>RS</name>
							<description>Register Select. This bit sets the logic level of the LCD_RS pin.</description>
							<lsb>4</lsb>
							<msb>4</msb>
							<enumeratedValues>
								<name>lo_hi_enum</name>
								<enumeratedValue>
									<name>lo</name>
									<description>Logic 0 (low)</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>hi</name>
									<description>Logic 1 (high)</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="RS">
							<name>RW</name>
							<lsb>5</lsb>
							<msb>5</msb>
						</field>
						<field>
							<name>ENB</name>
							<description>Enable (Active Low). In Automatic Mode, this bit sets the polarity of the LCD_EN pin. (0: LCD_EN is active high. 1: LCD_EN is active low.) In Manual Mode, this bit directly sets the LCD_EN pin state.</description>
							<lsb>6</lsb>
							<msb>6</msb>
							<enumeratedValues>
								<name>enb_enum</name>
								<enumeratedValue>
									<name>loOrActiveHi</name>
									<description>If automatic mode, LCD_EN is active high, else LCD is set low.</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>hiOrActiveLo</name>
									<description>If automatic mode, LCD_EN is active low, else LCD is set high.</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>READ</name>
							<lsb>7</lsb>
							<msb>7</msb>
							<enumeratedValues>
								<name>start_op_enum</name>
								<enumeratedValue>
									<name>complete</name>
									<description>No operation/complete</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>start</name>
									<description>Start operation</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
					</fields>
				</register>
				<register>
					<name>EPR</name>
					<description>LCD Enable Period Register. This register specifies the number of system clock cycles for an access. It is twice the asserted time of the enable signal (LCD_EN pin). This register has a minimum value of 4.  Any value less than 4 will be set to 4.</description>
					<addressOffset>0x04</addressOffset>
					<size>8</size>
					<resetValue>0x00000018</resetValue>
				</register>
				<register>
					<name>SR</name>
					<description>LCD Status Register</description>
					<addressOffset>0x08</addressOffset>
					<resetValue>0x00000004</resetValue>
					<fields>
						<field>
							<name>TXIS</name>
							<description>Transmission Status</description>
							<lsb>0</lsb>
							<msb>0</msb>
							<enumeratedValues>
								<name>sent_enum</name>
								<enumeratedValue>
									<name>notSent</name>
									<description>The content of the data register has not yet been sent.</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>sent</name>
									<description>The content of the data register has been sent. This bit is set by hardware and must be cleared by software to be acknowledged.</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>RXIS</name>
							<description>Receive Status</description>
							<lsb>1</lsb>
							<msb>1</msb>
							<enumeratedValues>
								<name>rcvd_enum</name>
								<enumeratedValue>
									<name>noDataAvailable</name>
									<description>No data has been received.</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>dataAvailable</name>
									<description>Data is available in LCD_DATA register. This bit is set by hardware and must be cleared by software to be acknowledged.</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>READY</name>
							<description>LCD Ready</description>
							<lsb>2</lsb>
							<msb>2</msb>
							<access>read-only</access>
							<enumeratedValues>
								<name>ready_enum</name>
								<enumeratedValue>
									<name>busy</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>ready</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
					</fields>
				</register>
				<register>
					<name>DATA</name>
					<description>Data register for LCD read/write operation</description>
					<addressOffset>0x0C</addressOffset>
					<size>8</size>
				</register>
			</registers>
			<addressBlock>
				<offset>0x00</offset>
				<size>0x1000</size>
				<usage>registers</usage>
			</addressBlock>
		</peripheral>
		<peripheral>
			<name>RealTimeClock</name>
			<description>Real Time Clock and Alarm</description>
			<prependToName>RTC_</prependToName>
			<baseAddress>0x40006000</baseAddress>
			<interrupt><name>RTC</name><value>3</value></interrupt>
			<registers>
				<register>
					<name>SEC</name>
					<description>RTC Second Counter. This register contains the 32-bit second counter.</description>
					<addressOffset>0x00</addressOffset>
					<resetMask>0x00000000</resetMask>
				</register>
				<register>
					<name>SSEC</name>
					<description>RTC Sub-second Counter. This counter increments at 256Hz. RTC_SEC is incremented when this register rolls over from 0xFF to 0x00.</description>
					<addressOffset>0x04</addressOffset>
					<size>8</size>
					<resetMask>0x00000000</resetMask>
				</register>
				<register>
					<name>RAS</name>
					<description>Time-of-day Alarm</description>
					<addressOffset>0x08</addressOffset>
					<size>20</size>
					<resetMask>0x00000000</resetMask>
				</register>
				<register>
					<name>RSSA</name>
					<description>RTC sub-second alarm.  This register contains the reload value for the sub-second alarm.</description>
					<addressOffset>0x0C</addressOffset>
					<size>8</size>
					<resetMask>0x00000000</resetMask>
				</register>
				<register>
					<name>CN</name>
					<description>RTC Control Register</description>
					<addressOffset>0x10</addressOffset>
					<resetValue>0x00000008</resetValue>
					<resetMask>0xFFFFFF38</resetMask>
					<fields>
						<field>
							<name>RTCE</name>
							<description>Real Time Clock Enable. This bit enables the Real Time Clock. This bit can only be written when WE=1 and BUSY =0. Change to this bit is effective only after BUSY is cleared from 1 to 0.</description>
							<lsb>0</lsb>
							<msb>0</msb>
							<enumeratedValues>
								<name>dis_en_enum</name>
								<enumeratedValue>
									<name>disable</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>enable</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="RTCE">
							<name>ADE</name>
							<description>Alarm Time-of-Day Interrupt Enable. Change to this bit is effective only after BUSY is cleared from 1 to 0.</description>
							<lsb>1</lsb>
							<msb>1</msb>
						</field>
						<field derivedFrom="RTCE">
							<name>ASE</name>
							<description>Alarm Sub-second Interrupt Enable.  Change to this bit is effective only after BUSY is cleared from 1 to 0.</description>
							<lsb>2</lsb>
							<msb>2</msb>
						</field>
						<field>
							<name>BUSY</name>
							<description>RTC Busy. This bit is set to 1 by hardware when changes to RTC registers required a synchronized version of the register to be in place.  This bit is automatically cleared by hardware.</description>
							<lsb>3</lsb>
							<msb>3</msb>
							<access>read-only</access>
							<enumeratedValues>
								<name>busy_enum</name>
								<enumeratedValue>
									<name>idle</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>busy</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>RDY</name>
							<description>RTC Ready. This bit is set to 1 by hardware when the RTC count registers update.  It can be cleared to 0 by software at any time. It will also be cleared to 0 by hardware just prior to an update of the RTC count register.</description>
							<lsb>4</lsb>
							<msb>4</msb>
							<enumeratedValues>
								<name>ready_enum</name>
								<enumeratedValue>
									<name>busy</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>ready</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="RTCE">
							<name>RDYE</name>
							<description>RTC Ready Interrupt Enable</description>
							<lsb>5</lsb>
							<msb>5</msb>
						</field>
						<field>
							<name>ALDF</name>
							<description>Time-of-Day Alarm Interrupt Flag.  This alarm is qualified as wake-up source to the processor.</description>
							<lsb>6</lsb>
							<msb>6</msb>
							<access>read-only</access>
							<enumeratedValues>
								<name>flag_enum</name>
								<enumeratedValue>
									<name>inactive</name>
									<description>No interrupt is pending.</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>pending</name>
									<description>An interrupt is pending.</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="ALDF">
							<name>ALSF</name>
							<description>Sub-second Alarm Interrupt Flag. This alarm is qualified as wake-up source to the processor.</description>
							<lsb>7</lsb>
							<msb>7</msb>
						</field>
						<field derivedFrom="RTCE">
							<name>SQE</name>
							<description>Square Wave Output Enable</description>
							<lsb>8</lsb>
							<msb>8</msb>
						</field>
						<field>
							<name>FT</name>
							<description>Frequency Output Selection. When SQE=1, these bits specify the output frequency on the SQW pin.</description>
							<lsb>9</lsb>
							<msb>10</msb>
							<enumeratedValues>
								<name>freq_sel_enum</name>
								<enumeratedValue>
									<name>freq1Hz</name>
									<description>1 Hz (Compensated)</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>freq512Hz</name>
									<description>512 Hz (Compensated)</description>
									<value>1</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>rtcInput</name>
									<description>RTC Input Clock</description>
									<isDefault>true</isDefault>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>X32KMD</name>
							<description>32KHz Oscillator Mode.</description>
							<lsb>11</lsb>
							<msb>12</msb>
							<enumeratedValues>
								<name>osc_mode_enum</name>
								<enumeratedValue>
									<name>noiseImmuneMode</name>
									<description>Always operate in Noise Immune Mode.  Oscillator warm-up required.</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>quietMode</name>
									<description>Always operate in Quiet Mode.  No oscillator warm-up required.</description>
									<value>1</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>quietInStopWithWarmup</name>
									<description>Operate in Noise Immune Mode normally, switch to Quiet Mode on Stop Mode entry.  Will wait for 32K oscillator warm-up before code execution on Stop Mode exit.</description>
									<value>2</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>quietInStopNoWarmup</name>
									<description>Operate in Noise Immune Mode normally, switch to Quiet Mode on Stop Mode entry.  Will not wait for 32K oscillator warm-up before code execution on Stop Mode exit.</description>
									<value>3</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="RTCE">
							<name>WE</name>
							<description>Write Enable. This register bit serves as a protection mechanism against unintentional writes to critical RTC bits.</description>
							<lsb>15</lsb>
							<msb>15</msb>
						</field>
					</fields>
				</register>
				<register>
					<name>TRIM</name>
					<description>RTC Trim.  This register contains the 2's complement value that specifies the trim resolution. Each increment or decrement of the bit adds or subtracts 1ppm at each 4KHz clock value, with a maximum correction of +/- 127ppm.</description>
					<addressOffset>0x14</addressOffset>
					<size>8</size>
					<resetMask>0x00000000</resetMask>
				</register>
			</registers>
			<addressBlock>
				<offset>0x00</offset>
				<size>0x1000</size>
				<usage>registers</usage>
			</addressBlock>
		</peripheral>
		<peripheral>
			<name>SecureKeyboard</name>
			<description>Secure Keyboard</description>
			<prependToName>KBD_</prependToName>
			<baseAddress>0x40032000</baseAddress>
			<interrupt><name>Secure_Keypad</name><value>19</value></interrupt>
			<registers>
				<register>
					<name>CR0</name>
					<description>Input Output Select Bits.  Each bit of IOSEL selects the pin direction for the corresponding KBDIO pin.  If IOSEL[0] = 1, KBDIO0 is an output.</description>
					<addressOffset>0x00</addressOffset>
					<size>8</size>
					<fields>
						<field>
							<name>KBDIO_0</name>
							<description>Input Output Select for KBDIO0 pin.</description>
							<lsb>0</lsb>
							<msb>0</msb>
							<enumeratedValues>
								<name>input_output_enum</name>
								<enumeratedValue>
									<name>input</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>output</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="KBDIO_0">
							<name>KBDIO_1</name>
							<description>Input Output Select for KBDIO1 pin.</description>
							<lsb>1</lsb>
							<msb>1</msb>
						</field>
						<field derivedFrom="KBDIO_0">
							<name>KBDIO_2</name>
							<description>Input Output Select for KBDIO2 pin.</description>
							<lsb>2</lsb>
							<msb>2</msb>
						</field>
						<field derivedFrom="KBDIO_0">
							<name>KBDIO_3</name>
							<description>Input Output Select for KBDIO3 pin.</description>
							<lsb>3</lsb>
							<msb>3</msb>
						</field>
						<field derivedFrom="KBDIO_0">
							<name>KBDIO_4</name>
							<description>Input Output Select for KBDIO4 pin.</description>
							<lsb>4</lsb>
							<msb>4</msb>
						</field>
						<field derivedFrom="KBDIO_0">
							<name>KBDIO_5</name>
							<description>Input Output Select for KBDIO5 pin.</description>
							<lsb>5</lsb>
							<msb>5</msb>
						</field>
						<field derivedFrom="KBDIO_0">
							<name>KBDIO_6</name>
							<description>Input Output Select for KBDIO6 pin.</description>
							<lsb>6</lsb>
							<msb>6</msb>
						</field>
						<field derivedFrom="KBDIO_0">
							<name>KBDIO_7</name>
							<description>Input Output Select for KBDIO7 pin.</description>
							<lsb>7</lsb>
							<msb>7</msb>
						</field>
					</fields>
				</register>
				<register>
					<name>CR1</name>
					<description>Control Register 1</description>
					<addressOffset>0x04</addressOffset>
					<fields>
						<field>
							<name>AUTOEN</name>
							<description>Automatic Keyboard Scan Enable</description>
							<lsb>0</lsb>
							<msb>0</msb>
							<enumeratedValues>
								<name>dis_en_enum</name>
								<enumeratedValue>
									<name>disable</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>enable</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="AUTOEN">
							<name>CLEAR</name>
							<description>Auto Clear Bit</description>
							<lsb>1</lsb>
							<msb>1</msb>
						</field>
						<field>
							<name>OUTNB</name>
							<description>Output Number. Number of KBDIO pins selected as outputs. NOTE: Output pins must be allocated contiguously starting with KBDIO0 and continuing through to KBDIO7.</description>
							<lsb>8</lsb>
							<msb>10</msb>
						</field>
						<field>
							<name>DBTM</name>
							<description>Debounce Time. Number of milliseconds a keypress event must be active before it is considered actual. NOTE: Debounce time values based on system running from an external 12MHz clock source with PLL0 enabled.  Other external crystal values will cause the debounce time to scale linearly.</description>
							<lsb>13</lsb>
							<msb>15</msb>
							<enumeratedValues>
								<name>debounce_enum</name>
								<enumeratedValue>
									<name>time4ms</name>
									<description>4.1 ms</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>time5ms</name>
									<description>5.3 ms</description>
									<value>1</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>time6ms</name>
									<description>6.5 ms</description>
									<value>2</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>time7ms</name>
									<description>7.6 ms</description>
									<value>3</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>time8ms</name>
									<description>8.8 ms</description>
									<value>4</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>time10ms</name>
									<description>10.0 ms</description>
									<value>5</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>time11ms</name>
									<description>11.2 ms</description>
									<value>6</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>time12ms</name>
									<description>12.3 ms</description>
									<value>7</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
					</fields>
				</register>
				<register>
					<name>SR</name>
					<description>Status Register</description>
					<addressOffset>0x08</addressOffset>
					<size>1</size>
					<access>read-only</access>
					<fields>
						<field>
							<name>BUSY</name>
							<description>Busy bit. This bit is set by hardware when the automatic keyboard scan is enabled and running.  This bit is clear at all other times.</description>
							<lsb>0</lsb>
							<msb>0</msb>
							<enumeratedValues>
								<name>busy_enum</name>
								<enumeratedValue>
									<name>idle</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>busy</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
					</fields>
				</register>
				<register>
					<name>IER</name>
					<description>Interrupt Enable Register</description>
					<addressOffset>0x0C</addressOffset>
					<fields>
						<field>
							<name>PUSHIE</name>
							<description>Push Event Enable Bit. When set, this bit enables an interrupt to be generated on a key push event.  Automatic keyboard scan must be enabled.</description>
							<lsb>0</lsb>
							<msb>0</msb>
							<enumeratedValues>
								<name>dis_en_enum</name>
								<enumeratedValue>
									<name>disable</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>enable</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="PUSHIE">
							<name>RELEASEIE</name>
							<description>Release Event Enable Bit. When set, this bit enables an interrupt to be generated on a key release event.  Automatic keyboard scan must be enabled.</description>
							<lsb>1</lsb>
							<msb>1</msb>
						</field>
						<field derivedFrom="PUSHIE">
							<name>OVERIE</name>
							<description>Overrun Event Enable Bit. When set, this bit enables an interrupt to be generated on an overrun event.  Automatic keyboard scan must be enabled.</description>
							<lsb>2</lsb>
							<msb>2</msb>
						</field>
					</fields>
				</register>
				<register>
					<name>ISR</name>
					<description>Interrupt Status Register</description>
					<addressOffset>0x10</addressOffset>
					<fields>
						<field>
							<name>PUSHIS</name>
							<description>Push Interrupt Flag. This bit is set by hardware when a key has been pushed.  If the interrupt is enabled for this flag, a system interrupt will be fired.  If the interrupt enable is not set, the flag will be set, but no interrupt will fire.  This bit must be cleared by software.</description>
							<lsb>0</lsb>
							<msb>0</msb>
							<enumeratedValues>
								<name>flag_enum</name>
								<enumeratedValue>
									<name>inactive</name>
									<description>No interrupt is pending.</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>pending</name>
									<description>An interrupt is pending.</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="PUSHIS">
							<name>RELEASEIS</name>
							<description>Release Interrupt Flag. This bit is set by hardware when a key has been released.  If the interrupt is enabled for this flag, a system interrupt will be fired.  If the interrupt enable is not set, the flag will be set, but no interrupt will fire.  This bit must be cleared by software.</description>
							<lsb>1</lsb>
							<msb>1</msb>
						</field>
						<field derivedFrom="PUSHIS">
							<name>OVERIS</name>
							<description>Overrun Event Enable Bit. This bit is set by hardware when an overrun event has occurred.  If the interrupt is enabled for this flag, a system interrupt will be fired.  If the interrupt enable is not set, the flag will be set, but no interrupt will fire.  This bit must be cleared by software.</description>
							<lsb>2</lsb>
							<msb>2</msb>
						</field>
					</fields>
				</register>
				<register>
					<dim>4</dim>
					<dimIncrement>4</dimIncrement>
					<name>K%sR</name>
					<description>Key Register</description>
					<addressOffset>0x14</addressOffset>
					<access>read-only</access>
					<resetValue>0x00000C00</resetValue>
					<fields>
						<field>
							<name>IOIN</name>
							<description>IO Input. Input pin of key event.</description>
							<lsb>0</lsb>
							<msb>2</msb>
						</field>
						<field>
							<name>IOOUT</name>
							<description>IO Output. Output pin of key event.</description>
							<lsb>5</lsb>
							<msb>7</msb>
						</field>
						<field>
							<name>PUSH</name>
							<description>If set to 1 the key has been released.  If set to 0 the key has been pushed.</description>
							<lsb>10</lsb>
							<msb>10</msb>
							<enumeratedValues>
								<name>push_event_enum</name>
								<enumeratedValue>
									<name>pushed</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>released</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>READ</name>
							<description>If set to 1 this register has been read.  If set to 0 the key register has not been read since its last change.</description>
							<lsb>11</lsb>
							<msb>11</msb>
							<enumeratedValues>
								<name>read_state_enum</name>
								<enumeratedValue>
									<name>notRead</name>
									<description>This register has not been read since its last change.</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>read</name>
									<description>This register has been read.</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>NEXT</name>
							<description>If set to 1 one of the next key registers (x+1 to 3) contains a key event.</description>
							<lsb>12</lsb>
							<msb>12</msb>
							<enumeratedValues>
								<name>next_enum</name>
								<enumeratedValue>
									<name>none</name>
									<description>No more key register contain a key event.</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>more</name>
									<description>Other key registers contain a key event.</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
					</fields>
				</register>
			</registers>
			<addressBlock>
				<offset>0x00</offset>
				<size>0x1000</size>
				<usage>registers</usage>
			</addressBlock>
		</peripheral>
		<peripheral>
			<name>SecurityMonitor</name>
			<description>The Security Monitor block used to monitor system threat conditions</description>
			<baseAddress>0x40004000</baseAddress>
			<registers>
				<register>
					<name>EXTSCN</name>
					<description>External Sensor Control Register</description>
					<addressOffset>0x00</addressOffset>
					<resetMask>0x3800FFC0</resetMask>
					<fields>
						<field>
							<name>EXTS_EN0</name>
							<description>External Sensor Enable for input/output pair 0</description>
							<lsb>0</lsb>
							<msb>0</msb>
							<enumeratedValues>
								<name>dis_en_enum</name>
								<enumeratedValue>
									<name>disable</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>enable</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="EXTS_EN0">
							<name>EXTS_EN1</name>
							<description>External Sensor Enable for input/output pair 1</description>
							<lsb>1</lsb>
							<msb>1</msb>
						</field>
						<field derivedFrom="EXTS_EN0">
							<name>EXTS_EN2</name>
							<description>External Sensor Enable for input/output pair 2</description>
							<lsb>2</lsb>
							<msb>2</msb>
						</field>
						<field derivedFrom="EXTS_EN0">
							<name>EXTS_EN3</name>
							<description>External Sensor Enable for input/output pair 3</description>
							<lsb>3</lsb>
							<msb>3</msb>
						</field>
						<field derivedFrom="EXTS_EN0">
							<name>EXTS_EN4</name>
							<description>External Sensor Enable for input/output pair 4</description>
							<lsb>4</lsb>
							<msb>4</msb>
						</field>
						<field derivedFrom="EXTS_EN0">
							<name>EXTS_EN5</name>
							<description>External Sensor Enable for input/output pair 5</description>
							<lsb>5</lsb>
							<msb>5</msb>
						</field>
						<field>
							<name>EXTCNT</name>
							<description>External Sensor Error Counter. These bits set the number of external sensor accepted mismatches that have to occur within a single bit period before an external sensor alarm is triggered.</description>
							<lsb>16</lsb>
							<msb>20</msb>
						</field>
						<field>
							<name>EXTFRQ</name>
							<description>External Sensor Frequency. These bits define the frequency at which the external sensors are clocked to/from the EXTS_IN and EXTS_OUT pair.</description>
							<lsb>21</lsb>
							<msb>23</msb>
							<enumeratedValues>
								<name>exts_freq_enum</name>
								<enumeratedValue>
									<name>freq2000Hz</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>freq1000Hz</name>
									<value>1</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>freq500Hz</name>
									<value>2</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>freq250Hz</name>
									<value>3</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>freq125Hz</name>
									<value>4</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>freq63Hz</name>
									<value>5</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>freq31Hz</name>
									<value>6</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>RFU</name>
									<description>Reserved. Do not use.</description>
									<value>7</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>DIVCLK</name>
							<description>Clock Divide.  These bits are used to divide the 8KHz input clock. The resulting divided clock is used for all logic within the Security Monitor Block. Note: If the input clock is divided with these bits, the error count threshold table and output frequency will be affected accordingly with the same divide factor.</description>
							<lsb>24</lsb>
							<msb>26</msb>
							<enumeratedValues>
								<name>clk_div_enum</name>
								<enumeratedValue>
									<name>div1</name>
									<description>Divide by 1 (8000 Hz)</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>div2</name>
									<description>Divide by 2 (4000 Hz)</description>
									<value>1</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>div4</name>
									<description>Divide by 4 (2000 Hz)</description>
									<value>2</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>div8</name>
									<description>Divide by 8 (1000 Hz)</description>
									<value>3</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>div16</name>
									<description>Divide by 16 (500 Hz)</description>
									<value>4</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>div32</name>
									<description>Divide by 32 (250 Hz)</description>
									<value>5</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>div64</name>
									<description>Divide by 64 (125 Hz)</description>
									<value>6</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>RFU</name>
									<description>Reserved. Do not use.</description>
									<value>7</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>BUSY</name>
							<description>Busy. This bit is set to 1 by hardware after EXTSCN register is written to. This bit is automatically cleared to 0 after this register information has been transferred to the security monitor domain.</description>
							<lsb>30</lsb>
							<msb>30</msb>
							<access>read-only</access>
							<enumeratedValues>
								<name>busy_enum</name>
								<enumeratedValue>
									<name>idle</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>busy</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>LOCK</name>
							<description>Lock Register. Once locked, the EXTSCN register can no longer be modified.  Only a battery disconnect will clear this bit. VBAT powers this register.</description>
							<lsb>31</lsb>
							<msb>31</msb>
							<enumeratedValues>
								<name>locked_enum</name>
								<enumeratedValue>
									<name>unlocked</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>locked</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
					</fields>
				</register>
				<register>
					<name>INTSCN</name>
					<description>Internal Sensor Control Register</description>
					<addressOffset>0x04</addressOffset>
					<resetMask>0x7F00FFF7</resetMask>
					<fields>
						<field>
							<name>SHIELD_EN</name>
							<description>Die Shield Enable</description>
							<lsb>0</lsb>
							<msb>0</msb>
							<enumeratedValues>
								<name>dis_en_enum</name>
								<enumeratedValue>
									<name>disable</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>enable</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="SHIELD_EN">
							<name>TEMP_EN</name>
							<description>Temperature Sensor Enable</description>
							<lsb>1</lsb>
							<msb>1</msb>
						</field>
						<field derivedFrom="SHIELD_EN">
							<name>VBAT_EN</name>
							<description>Battery Monitor Enable</description>
							<lsb>2</lsb>
							<msb>2</msb>
						</field>
						<field>
							<name>LOTEMP_SEL</name>
							<description>Low Temperature Detection Select</description>
							<lsb>16</lsb>
							<msb>16</msb>
							<enumeratedValues>
								<name>temp_sel_enum</name>
								<enumeratedValue>
									<name>neg50C</name>
									<description>-50 degrees C</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>neg30C</name>
									<description>-30 degrees C</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="SHIELD_EN">
							<name>VCORELOEN</name>
							<description>VCORE Undervoltage Detect Enable</description>
							<lsb>18</lsb>
							<msb>18</msb>
						</field>
						<field derivedFrom="SHIELD_EN">
							<name>VCOREHIEN</name>
							<description>VCORE Overvoltage Detect Enable</description>
							<lsb>19</lsb>
							<msb>19</msb>
						</field>
						<field derivedFrom="SHIELD_EN">
							<name>VDDLOEN</name>
							<description>VDD Undervoltage Detect Enable</description>
							<lsb>20</lsb>
							<msb>20</msb>
						</field>
						<field derivedFrom="SHIELD_EN">
							<name>VDDHIEN</name>
							<description>VDD Overvoltage Detect Enable</description>
							<lsb>21</lsb>
							<msb>21</msb>
						</field>
						<field derivedFrom="SHIELD_EN">
							<name>VGLEN</name>
							<description>Voltage Glitch Detection Enable</description>
							<lsb>22</lsb>
							<msb>22</msb>
						</field>
						<field>
							<name>LOCK</name>
							<description>Lock Register. Once locked, the INTSCN register can no longer be modified.  Only a battery disconnect will clear this bit. VBAT powers this register.</description>
							<lsb>31</lsb>
							<msb>31</msb>
							<enumeratedValues>
								<name>locked_enum</name>
								<enumeratedValue>
									<name>unlocked</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>locked</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
					</fields>
				</register>
				<register>
					<name>SECALM</name>
					<description>Security Alarm Register</description>
					<addressOffset>0x08</addressOffset>
					<resetValue>0x00000020</resetValue>
					<resetMask>0x00000000</resetMask>
					<fields>
						<field>
							<name>DRS</name>
							<description>Destructive Reset Trigger. Setting this bit will generate a DRS. This bit is self-cleared by hardware.</description>
							<lsb>0</lsb>
							<msb>0</msb>
							<enumeratedValues>
								<name>start_op_enum</name>
								<enumeratedValue>
									<name>complete</name>
									<description>No operation/complete</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>start</name>
									<description>Start operation</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="DRS">
							<name>KEYWIPE</name>
							<description>Key Wipe Trigger. Set to 1 to initiate a wipe of the AES key register. It does not reset the part, or log a timestamp. AES and DES registers are not affected by this bit. This bit is automatically cleared to 0 after the keys have been wiped.</description>
							<lsb>1</lsb>
							<msb>1</msb>
						</field>
						<field>
							<name>SHIELDF</name>
							<description>Die Shield Flag</description>
							<lsb>2</lsb>
							<msb>2</msb>
							<enumeratedValues>
								<name>event_flag_enum</name>
								<enumeratedValue>
									<name>noEvent</name>
									<description>The event has not occurred</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>occurred</name>
									<description>The event has occurred</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="SHIELDF">
							<name>LOTEMP</name>
							<description>Low Temperature Detect</description>
							<lsb>3</lsb>
							<msb>3</msb>
						</field>
						<field derivedFrom="SHIELDF">
							<name>HITEMP</name>
							<description>High Temperature Detect</description>
							<lsb>4</lsb>
							<msb>4</msb>
						</field>
						<field derivedFrom="SHIELDF">
							<name>BATLO</name>
							<description>Battery Undervoltage Detect</description>
							<lsb>5</lsb>
							<msb>5</msb>
						</field>
						<field derivedFrom="SHIELDF">
							<name>BATHI</name>
							<description>Battery Overvoltage Detect</description>
							<lsb>6</lsb>
							<msb>6</msb>
						</field>
						<field derivedFrom="SHIELDF">
							<name>EXTF</name>
							<description>External Sensor Flag.   This bit is set to 1 when any of the EXTSTAT bits are set.</description>
							<lsb>7</lsb>
							<msb>7</msb>
						</field>
						<field derivedFrom="SHIELDF">
							<name>VDDLO</name>
							<description>VDD Undervoltage Detect Flag</description>
							<lsb>8</lsb>
							<msb>8</msb>
						</field>
						<field derivedFrom="SHIELDF">
							<name>VCORELO</name>
							<description>VCORE Undervoltage Detect Flag</description>
							<lsb>9</lsb>
							<msb>9</msb>
						</field>
						<field derivedFrom="SHIELDF">
							<name>VCOREHI</name>
							<description>VCORE Overvoltage Detect Flag</description>
							<lsb>10</lsb>
							<msb>10</msb>
						</field>
						<field derivedFrom="SHIELDF">
							<name>VDDHI</name>
							<description>VDD Overvoltage Flag</description>
							<lsb>11</lsb>
							<msb>11</msb>
						</field>
						<field derivedFrom="SHIELDF">
							<name>VGL</name>
							<description>Voltage Glitch Detection Flag</description>
							<lsb>12</lsb>
							<msb>12</msb>
						</field>
						<field derivedFrom="SHIELDF">
							<name>EXTSTAT0</name>
							<description>External Sensor 0 Detect. The tamper detect is only active when it is enabled. This bits needs to be cleared in software after a tamper event to re-arm the sensor.</description>
							<lsb>16</lsb>
							<msb>16</msb>
						</field>
						<field derivedFrom="SHIELDF">
							<name>EXTSTAT1</name>
							<description>External Sensor 1 Detect. The tamper detect is only active when it is enabled. This bits needs to be cleared in software after a tamper event to re-arm the sensor.</description>
							<lsb>17</lsb>
							<msb>17</msb>
						</field>
						<field derivedFrom="SHIELDF">
							<name>EXTSTAT2</name>
							<description>External Sensor 2 Detect. The tamper detect is only active when it is enabled. This bits needs to be cleared in software after a tamper event to re-arm the sensor.</description>
							<lsb>18</lsb>
							<msb>18</msb>
						</field>
						<field derivedFrom="SHIELDF">
							<name>EXTSTAT3</name>
							<description>External Sensor 3 Detect. The tamper detect is only active when it is enabled. This bits needs to be cleared in software after a tamper event to re-arm the sensor.</description>
							<lsb>19</lsb>
							<msb>19</msb>
						</field>
						<field derivedFrom="SHIELDF">
							<name>EXTSTAT4</name>
							<description>External Sensor 4 Detect. The tamper detect is only active when it is enabled. This bits needs to be cleared in software after a tamper event to re-arm the sensor.</description>
							<lsb>20</lsb>
							<msb>20</msb>
						</field>
						<field derivedFrom="SHIELDF">
							<name>EXTSTAT5</name>
							<description>External Sensor 5 Detect. The tamper detect is only active when it is enabled. This bits needs to be cleared in software after a tamper event to re-arm the sensor.</description>
							<lsb>21</lsb>
							<msb>21</msb>
						</field>
						<field derivedFrom="SHIELDF">
							<name>EXTSWARN0</name>
							<description>External Sensor 0 Warning Ready flag. The tamper detect warning flags are set, regardless of whether the external sensors are enabled.</description>
							<lsb>24</lsb>
							<msb>24</msb>
						</field>
						<field derivedFrom="SHIELDF">
							<name>EXTSWARN1</name>
							<description>External Sensor 1 Warning Ready flag. The tamper detect warning flags are set, regardless of whether the external sensors are enabled.</description>
							<lsb>25</lsb>
							<msb>25</msb>
						</field>
						<field derivedFrom="SHIELDF">
							<name>EXTSWARN2</name>
							<description>External Sensor 2 Warning Ready flag. The tamper detect warning flags are set, regardless of whether the external sensors are enabled.</description>
							<msb>26</msb>
							<bitRange>26</bitRange>
						</field>
						<field derivedFrom="SHIELDF">
							<name>EXTSWARN3</name>
							<description>External Sensor 3 Warning Ready flag. The tamper detect warning flags are set, regardless of whether the external sensors are enabled.</description>
							<lsb>27</lsb>
							<msb>27</msb>
						</field>
						<field derivedFrom="SHIELDF">
							<name>EXTSWARN4</name>
							<description>External Sensor 4 Warning Ready flag. The tamper detect warning flags are set, regardless of whether the external sensors are enabled.</description>
							<lsb>28</lsb>
							<msb>28</msb>
						</field>
						<field derivedFrom="SHIELDF">
							<name>EXTSWARN5</name>
							<description>External Sensor 5 Warning Ready flag. The tamper detect warning flags are set, regardless of whether the external sensors are enabled.</description>
							<lsb>29</lsb>
							<msb>29</msb>
						</field>
					</fields>
				</register>
				<register>
					<name>SECDIAG</name>
					<description>Security Diagnostic Register</description>
					<addressOffset>0x0C</addressOffset>
					<resetValue>0x00000020</resetValue>
					<resetMask>0xFFC0FF03</resetMask>
					<fields>
						<field>
							<name>SHIELDF</name>
							<description>Die Shield Flag</description>
							<lsb>2</lsb>
							<msb>2</msb>
							<enumeratedValues>
								<name>event_flag_enum</name>
								<enumeratedValue>
									<name>noEvent</name>
									<description>The event has not occurred</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>occurred</name>
									<description>The event has occurred</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="SHIELDF">
							<name>LOTEMP</name>
							<description>Low Temperature Detect</description>
							<lsb>3</lsb>
							<msb>3</msb>
						</field>
						<field derivedFrom="SHIELDF">
							<name>HITEMP</name>
							<description>High Temperature Detect</description>
							<lsb>4</lsb>
							<msb>4</msb>
						</field>
						<field derivedFrom="SHIELDF">
							<name>BATLO</name>
							<description>Battery Undervoltage Detect</description>
							<lsb>5</lsb>
							<msb>5</msb>
						</field>
						<field derivedFrom="SHIELDF">
							<name>BATHI</name>
							<description>Battery Overvoltage Detect</description>
							<lsb>6</lsb>
							<msb>6</msb>
						</field>
						<field derivedFrom="SHIELDF">
							<name>DYNF</name>
							<description>Dynamic Sensor Flag.  This bit is set to 1 when any of the EXTSTAT bits are set.</description>
							<lsb>7</lsb>
							<msb>7</msb>
						</field>
						<field>
							<name>AESKT</name>
							<description>AES Key Transfer.  This bit is set to 1 when AES Key has been transferred from the TRNG to the battery backed AES key register. This bit can only be reset by a BOR.</description>
							<lsb>8</lsb>
							<msb>8</msb>
							<enumeratedValues>
								<name>transfer_status_enum</name>
								<enumeratedValue>
									<name>incomplete</name>
									<description>Key has not been transferred.</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>complete</name>
									<description>Key has been transferred.</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="SHIELDF">
							<name>EXTSTAT0</name>
							<description>External Sensor 0 Detect</description>
							<lsb>16</lsb>
							<msb>16</msb>
						</field>
						<field derivedFrom="SHIELDF">
							<name>EXTSTAT1</name>
							<description>External Sensor 1 Detect</description>
							<lsb>17</lsb>
							<msb>17</msb>
						</field>
						<field derivedFrom="SHIELDF">
							<name>EXTSTAT2</name>
							<description>External Sensor 2 Detect</description>
							<lsb>18</lsb>
							<msb>18</msb>
						</field>
						<field derivedFrom="SHIELDF">
							<name>EXTSTAT3</name>
							<description>External Sensor 3 Detect</description>
							<lsb>19</lsb>
							<msb>19</msb>
						</field>
						<field derivedFrom="SHIELDF">
							<name>EXTSTAT4</name>
							<description>External Sensor 4 Detect</description>
							<lsb>20</lsb>
							<msb>20</msb>
						</field>
						<field derivedFrom="SHIELDF">
							<name>EXTSTAT5</name>
							<description>External Sensor 5 Detect</description>
							<lsb>21</lsb>
							<msb>21</msb>
						</field>
					</fields>
				</register>
				<register>
					<name>DLRTC</name>
					<description>DRS Log RTC Value. This register contains the 32 bit value in the RTC second register when the last DRS event occurred.</description>
					<addressOffset>0x10</addressOffset>
					<access>read-only</access>
					<resetMask>0x00000000</resetMask>
				</register>
				<register>
					<name>SECST</name>
					<description>Security Monitor Status Register</description>
					<addressOffset>0x34</addressOffset>
					<access>read-only</access>
					<fields>
						<field>
							<name>EXTSRS</name>
							<description>External Sensor Control Register Status</description>
							<lsb>0</lsb>
							<msb>0</msb>
							<enumeratedValues>
								<name>access_enum</name>
								<enumeratedValue>
									<name>allowed</name>
									<description>Access authorized</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>notAllowed</name>
									<description>Access not authorized</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="EXTSRS">
							<name>INTSRS</name>
							<description>Internal Sensor Control Register Status</description>
							<lsb>1</lsb>
							<msb>1</msb>
						</field>
						<field derivedFrom="EXTSRS">
							<name>SECALRS</name>
							<description>Security Alarm Register Status</description>
							<lsb>2</lsb>
							<msb>2</msb>
						</field>
						<field derivedFrom="EXTSRS">
							<name>KEY0RS</name>
							<description>AES Cipher Key Register x Status</description>
							<lsb>3</lsb>
							<msb>3</msb>
						</field>
					</fields>
				</register>
			</registers>
			<addressBlock>
				<offset>0x00</offset>
				<size>0x1000</size>
				<usage>registers</usage>
			</addressBlock>
		</peripheral>
		<peripheral>
			<name>SPI0</name>
			<description>Serial Peripheral Interface</description>
			<prependToName>SPI0_</prependToName>
			<baseAddress>0x40018000</baseAddress>
			<interrupt><name>SPI0</name><value>16</value></interrupt>
			<registers>
				<register>
					<name>DATA</name>
					<description>SPI Data</description>
					<addressOffset>0x00</addressOffset>
					<size>16</size>
				</register>
				<register>
					<name>CNTL</name>
					<description>SPI Control Register</description>
					<addressOffset>0x04</addressOffset>
					<fields>
						<field>
							<name>SPIEN</name>
							<description>SPI Enable</description>
							<lsb>0</lsb>
							<msb>0</msb>
							<enumeratedValues>
								<name>dis_en_enum</name>
								<enumeratedValue>
									<name>disable</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>enable</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>MMEN</name>
							<description>SPI Master Mode Enable</description>
							<lsb>1</lsb>
							<msb>1</msb>
							<enumeratedValues>
								<name>slv_mst_enum</name>
								<enumeratedValue>
									<name>slave</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>master</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="SPIEN">
							<name>WOR</name>
							<description>Wired OR (open drain) Enable</description>
							<lsb>2</lsb>
							<msb>2</msb>
						</field>
						<field>
							<name>CLKPOL</name>
							<description>Clock Polarity</description>
							<lsb>3</lsb>
							<msb>3</msb>
							<enumeratedValues>
								<name>spi_pol_enum</name>
								<enumeratedValue>
									<name>idleLo</name>
									<description>SCLK idles Low (0) after character transmission/reception.</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>idleHi</name>
									<description>SCLK idles High (1) after character transmission/reception.</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>PHASE</name>
							<description>Phase Select</description>
							<lsb>4</lsb>
							<msb>4</msb>
							<enumeratedValues>
								<name>spi_phase_enum</name>
								<enumeratedValue>
									<name>activeEdge</name>
									<description>Transmit on active edge of SCLK</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>inactiveEdge</name>
									<description>Transmit on inactive edge of SCLK</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="SPIEN">
							<name>BIRQ</name>
							<description>Baud Rate Generator Timer Interrupt Request</description>
							<lsb>5</lsb>
							<msb>5</msb>
						</field>
						<field>
							<name>STR</name>
							<description>Start SPI Interrupt</description>
							<lsb>6</lsb>
							<msb>6</msb>
							<enumeratedValues>
								<name>start_op_enum</name>
								<enumeratedValue>
									<name>complete</name>
									<description>No operation/complete</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>start</name>
									<description>Start operation</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="SPIEN">
							<name>IRQE</name>
							<description>Interrupt Request Enable</description>
							<lsb>7</lsb>
							<msb>7</msb>
						</field>
					</fields>
				</register>
				<register>
					<name>STATUS</name>
					<description>SPI Status Register</description>
					<addressOffset>0x08</addressOffset>
					<resetValue>0x00000001</resetValue>
					<fields>
						<field>
							<name>SLAS</name>
							<description>Slave Select. If the SPI is in slave mode, this bit indicates if the SPI is selected. If the SPI is in master mode this bit has no meaning.</description>
							<lsb>0</lsb>
							<msb>0</msb>
							<access>read-only</access>
							<enumeratedValues>
								<name>sel_enum</name>
								<enumeratedValue>
									<name>selected</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>notSelected</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>TXST</name>
							<description>Transmit Status</description>
							<lsb>1</lsb>
							<msb>1</msb>
							<access>read-only</access>
							<enumeratedValues>
								<name>busy_enum</name>
								<enumeratedValue>
									<name>idle</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>busy</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>TUND</name>
							<description>Transmit Underrun</description>
							<lsb>2</lsb>
							<msb>2</msb>
							<modifiedWriteValues>oneToClear</modifiedWriteValues>
							<enumeratedValues>
								<name>event_flag_enum</name>
								<enumeratedValue>
									<name>noEvent</name>
									<description>The event has not occurred</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>occurred</name>
									<description>The event has occurred.</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="TUND">
							<name>ROVR</name>
							<description>Receive Overrun</description>
							<lsb>3</lsb>
							<msb>3</msb>
						</field>
						<field derivedFrom="TUND">
							<name>ABT</name>
							<description>Slave Mode Transaction Abort</description>
							<lsb>4</lsb>
							<msb>4</msb>
						</field>
						<field derivedFrom="TUND">
							<name>COL</name>
							<description>Collision</description>
							<lsb>5</lsb>
							<msb>5</msb>
						</field>
						<field derivedFrom="TUND">
							<name>TOVR</name>
							<description>Transmit Overrun</description>
							<lsb>6</lsb>
							<msb>6</msb>
						</field>
						<field>
							<name>IRQ</name>
							<description>SPI Interrupt Request</description>
							<lsb>7</lsb>
							<msb>7</msb>
							<modifiedWriteValues>oneToClear</modifiedWriteValues>
							<enumeratedValues>
								<name>flag_enum</name>
								<enumeratedValue>
									<name>inactive</name>
									<description>No interrupt is pending.</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>pending</name>
									<description>An interrupt is pending.</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
					</fields>
				</register>
				<register>
					<name>MOD</name>
					<description>SPI Mode Register</description>
					<addressOffset>0x0C</addressOffset>
					<fields>
						<field>
							<name>SSV</name>
							<description>Slave Select Value</description>
							<lsb>0</lsb>
							<msb>0</msb>
							<enumeratedValues>
								<name>lo_hi_enum</name>
								<enumeratedValue>
									<name>lo</name>
									<description>The SSEL pin will be driven low.</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>hi</name>
									<description>The SSEL pin will be driven high.</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>SSIO</name>
							<description>Slave Select I/O</description>
							<lsb>1</lsb>
							<msb>1</msb>
							<enumeratedValues>
								<name>input_output_enum</name>
								<enumeratedValue>
									<name>input</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>output</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>NUMBITS</name>
							<lsb>2</lsb>
							<msb>5</msb>
							<enumeratedValues>
								<name>spi_bits_enum</name>
								<enumeratedValue>
									<name>bits16</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>bits1</name>
									<value>1</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>bits2</name>
									<value>2</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>bits3</name>
									<value>3</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>bits4</name>
									<value>4</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>bits5</name>
									<value>5</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>bits6</name>
									<value>6</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>bits7</name>
									<value>7</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>bits8</name>
									<value>8</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>bits9</name>
									<value>9</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>bits10</name>
									<value>10</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>bits11</name>
									<value>11</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>bits12</name>
									<value>12</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>bits13</name>
									<value>13</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>bits14</name>
									<value>14</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>bits15</name>
									<value>15</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>TX_LJ</name>
							<description>Transmit Left Justify</description>
							<lsb>7</lsb>
							<msb>7</msb>
							<enumeratedValues>
								<name>dis_en_enum</name>
								<enumeratedValue>
									<name>disable</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>enable</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>SSL1</name>
							<description>Slave Select 1.  If SPI is enabled and in master mode, the SSEL_1 is driven according to this bit.</description>
							<lsb>8</lsb>
							<msb>8</msb>
							<enumeratedValues>
								<name>hi_lo_enum</name>
								<enumeratedValue>
									<name>hi</name>
									<description>High</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>lo</name>
									<description>Low</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="SSL1">
							<name>SSL2</name>
							<description>Slave Select 2.  If SPI is enabled and in master mode, the SSEL_2 is driven according to this bit.</description>
							<lsb>9</lsb>
							<msb>9</msb>
						</field>
						<field derivedFrom="SSL1">
							<name>SSL3</name>
							<description>Slave Select 3.  If SPI is enabled and in master mode, the SSEL_3 is driven according to this bit.</description>
							<lsb>10</lsb>
							<msb>10</msb>
						</field>
					</fields>
				</register>
				<register>
					<name>BRG</name>
					<description>Baud Rate Reload Value. The SPI Baud Rate register is a 16-bit reload value for the SPI Baud Rate Generator. The reload value must be greater than or equal to 0002H for proper SPI operation (maximum baud rate is PCLK frequency divided by 4).</description>
					<addressOffset>0x14</addressOffset>
					<size>16</size>
					<resetValue>0x0000FFFF</resetValue>
				</register>
				<register>
					<name>DMA</name>
					<description>SPI DMA Register</description>
					<addressOffset>0x18</addressOffset>
					<resetValue>0x00070007</resetValue>
					<fields>
						<field>
							<name>TX_FIFO_LEVEL</name>
							<description>Transmit FIFO Level. Set the number of free entries in the TxFIFO when a TxDMA request occurs.</description>
							<lsb>0</lsb>
							<msb>2</msb>
							<enumeratedValues>
								<name>fifo_level_enum</name>
								<enumeratedValue>
									<name>entry1</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>entries2</name>
									<value>1</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>entries3</name>
									<value>2</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>entries4</name>
									<value>3</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>entries5</name>
									<value>4</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>entries6</name>
									<value>5</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>entries7</name>
									<value>6</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>entries8</name>
									<value>7</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>TX_FIFO_CLEAR</name>
							<description>Transmit FIFO Clear</description>
							<lsb>4</lsb>
							<msb>4</msb>
							<access>write-only</access>
							<enumeratedValues>
								<name>start_op_enum</name>
								<enumeratedValue>
									<name>complete</name>
									<description>No operation/complete</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>start</name>
									<description>Start operation</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>TX_FIFO_CNT</name>
							<description>Transmit FIFO Count.</description>
							<lsb>8</lsb>
							<msb>11</msb>
							<access>read-only</access>
						</field>
						<field>
							<name>TX_DMA_EN</name>
							<description>Transmit DMA Enable</description>
							<lsb>15</lsb>
							<msb>15</msb>
							<enumeratedValues>
								<name>dis_en_enum</name>
								<enumeratedValue>
									<name>disable</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>enable</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="TX_FIFO_LEVEL">
							<name>RX_FIFO_LEVEL</name>
							<description>Receive FIFO Level. Sets the RX FIFO DMA request threshold. This configures the number of filled RxFIFO entries before activating an RxDMA request.</description>
							<lsb>16</lsb>
							<msb>18</msb>
						</field>
						<field derivedFrom="TX_FIFO_CLEAR">
							<name>RX_FIFO_CLEAR</name>
							<description>Receive FIFO Clear</description>
							<lsb>20</lsb>
							<msb>20</msb>
						</field>
						<field derivedFrom="TX_FIFO_CNT">
							<name>RX_FIFO_CNT</name>
							<description>Receive FIFO Count</description>
							<lsb>24</lsb>
							<msb>27</msb>
						</field>
						<field derivedFrom="TX_DMA_EN">
							<name>RX_DMA_EN</name>
							<description>Receive DMA Enable</description>
							<lsb>31</lsb>
							<msb>31</msb>
						</field>
					</fields>
				</register>
				<register>
					<name>I2S_CNTL</name>
					<description>I2S Control Register</description>
					<addressOffset>0x1C</addressOffset>
					<fields>
						<field>
							<name>I2S_EN</name>
							<description>I2S Mode Enable</description>
							<lsb>0</lsb>
							<msb>0</msb>
							<enumeratedValues>
								<name>dis_en_enum</name>
								<enumeratedValue>
									<name>disable</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>enable</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="I2S_EN">
							<name>I2S_MUTE</name>
							<description>I2S Mute transmit</description>
							<lsb>1</lsb>
							<msb>1</msb>
						</field>
						<field derivedFrom="I2S_EN">
							<name>I2S_PAUSE</name>
							<description>I2S Pause transmit/receive</description>
							<lsb>2</lsb>
							<msb>2</msb>
						</field>
						<field derivedFrom="I2S_EN">
							<name>I2S_MONO</name>
							<description>I2S Monophonic Audio Mode</description>
							<lsb>3</lsb>
							<msb>3</msb>
						</field>
						<field derivedFrom="I2S_EN">
							<name>I2S_LJ</name>
							<description>I2S Left Justify</description>
							<lsb>4</lsb>
							<msb>4</msb>
						</field>
					</fields>
				</register>
			</registers>
			<addressBlock>
				<offset>0x00</offset>
				<size>0x1000</size>
				<usage>registers</usage>
			</addressBlock>
		</peripheral>
		<peripheral derivedFrom="SPI0">
			<name>SPI1</name>
			<description>Serial Peripheral Interface</description>
			<prependToName>SPI1_</prependToName>
			<baseAddress>0x40019000</baseAddress>
			<interrupt><name>SPI1</name><value>17</value></interrupt>
		</peripheral>
		<peripheral derivedFrom="SPI0">
			<name>SPI2</name>
			<description>Serial Peripheral Interface</description>
			<prependToName>SPI2_</prependToName>
			<baseAddress>0x4001A000</baseAddress>
			<interrupt><name>SPI2</name><value>18</value></interrupt>
		</peripheral>
		<peripheral>
			<name>SmartCard</name>
			<description>LCD Clock Register</description>
			<prependToName>SC_</prependToName>
			<baseAddress>0x4002C000</baseAddress>
			<interrupt><name>Smart_Card</name><value>11</value></interrupt>
			<registers>
				<register>
					<name>CR</name>
					<description>Control Register</description>
					<addressOffset>0x00</addressOffset>
					<fields>
						<field>
							<name>CONV</name>
							<description>Convention Select Bit</description>
							<lsb>0</lsb>
							<msb>0</msb>
							<enumeratedValues>
								<name>convention_enum</name>
								<enumeratedValue>
									<name>direct</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>indirect</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>CREP</name>
							<description>Character Repeat Enable Bit.  Enables character retransmit on parity error.</description>
							<lsb>1</lsb>
							<msb>1</msb>
							<enumeratedValues>
								<name>dis_en_enum</name>
								<enumeratedValue>
									<name>disable</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>enable</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="CREP">
							<name>WTEN</name>
							<description>Waiting Time Counter Enable Bit.</description>
							<lsb>2</lsb>
							<msb>2</msb>
						</field>
						<field>
							<name>UART</name>
							<description>Smart Card Mode Bit.  Selects manual control or smart card UART control of smart card pins.</description>
							<lsb>3</lsb>
							<msb>3</msb>
							<enumeratedValues>
								<name>manual_auto_enum</name>
								<enumeratedValue>
									<name>manual</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>auto</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="CREP">
							<name>CCEN</name>
							<description>Clock Counter Enable Bit.</description>
							<lsb>4</lsb>
							<msb>4</msb>
						</field>
						<field>
							<name>RXFLUSH</name>
							<description>Receive FIFO Flush Bit.  This bit is cleared automatically by hardware.</description>
							<lsb>5</lsb>
							<msb>5</msb>
							<enumeratedValues>
								<name>start_op_enum</name>
								<enumeratedValue>
									<name>complete</name>
									<description>No operation/complete</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>start</name>
									<description>Start operation</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="RXFLUSH">
							<name>TXFLUSH</name>
							<description>Transmit FIFO Flush Bit.  This bit is cleared automatically by hardware.</description>
							<lsb>6</lsb>
							<msb>6</msb>
						</field>
						<field>
							<name>RXTHD</name>
							<description>Receive FIFO depth.  Valid range 1 to 7.</description>
							<lsb>8</lsb>
							<msb>11</msb>
						</field>
						<field derivedFrom="RXTHD">
							<name>TXTHD</name>
							<description>Transmit FIFO depth.  Valid range 1 to 7.</description>
							<lsb>12</lsb>
							<msb>15</msb>
						</field>
						<field>
							<name>START</name>
							<description>Start bit. This bit controls software activation/deactivation of the card interface. When this bit is set, the activation sequence for the selected card is performed.  When this bit is cleared, the deactivation sequence for the selected card is performed.  Hardware should automatically reset the START bit during emergency deactivation.</description>
							<lsb>16</lsb>
							<msb>16</msb>
							<enumeratedValues>
								<name>activation_enum</name>
								<enumeratedValue>
									<name>deactivation</name>
									<description>Deactivation performed.</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>activation</name>
									<description>Activation performed.</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="CREP">
							<name>BYPASS_PHY</name>
							<description>Bypass mode for smart card PHY.</description>
							<lsb>17</lsb>
							<msb>17</msb>
						</field>
						<field>
							<name>PRPOL</name>
							<description>Presence detect polarity. When PRPOL = 0,  card presence pin shall interpret a logic 1 as card presence.  When PRPOL = 1, card presence pin shall interpret a logic 0 as card presence.</description>
							<lsb>18</lsb>
							<msb>18</msb>
							<enumeratedValues>
								<name>pr_pol_enum</name>
								<enumeratedValue>
									<name>activeHi</name>
									<description>Logic 1 presence detect</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>activeLo</name>
									<description>Logic 0 presence detect</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="CREP">
							<name>DEBNCE</name>
							<description>Enable Debounce on card insertion.  When set to logic 1, this will enable the hardware debounce of the card detect pin.  The debounce function shall wait for fixed timer period of stable card detect assertion before setting the SC_ISR.PRIS bit.  De-assertion of SC_ISR.PRIS is immediate upon de-assertion of card detect pin.</description>
							<lsb>19</lsb>
							<msb>19</msb>
						</field>
						<field derivedFrom="CREP">
							<name>BYPASS_SEQ</name>
							<description>Sequencer bypass.  Disable sequencer for activation and deactivation.</description>
							<lsb>20</lsb>
							<msb>20</msb>
						</field>
					</fields>
				</register>
				<register>
					<name>SR</name>
					<description>Status Register</description>
					<addressOffset>0x04</addressOffset>
					<access>read-only</access>
					<resetValue>0x00000050</resetValue>
					<fields>
						<field>
							<name>PAR</name>
							<description>Parity Error Detected Flag. Set to 1 by hardware if parity error is detected.  Cleared by software.</description>
							<lsb>0</lsb>
							<msb>0</msb>
							<access>read-only</access>
							<enumeratedValues>
								<name>event_flag_enum</name>
								<usage>read</usage>
								<enumeratedValue>
									<name>noEvent</name>
									<description>The event has not occurred</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>occurred</name>
									<description>The event has occurred</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="PAR">
							<name>WTOV</name>
							<description>Waiting Time Counter Overflow Flag. Set to 1 by hardware when waiting time counter overflows.</description>
							<lsb>1</lsb>
							<msb>1</msb>
							<access>read-only</access>
						</field>
						<field derivedFrom="WTOV">
							<name>CCOV</name>
							<description>Clock Counter Overflow Flag. Set to 1 by hardware when clock counter has reached its maximum value.</description>
							<lsb>2</lsb>
							<msb>2</msb>
						</field>
						<field derivedFrom="PAR">
							<name>TXCF</name>
							<description>Transmit Complete Flag. Set to 1 by hardware when character has been transmitted.  Cleared by software.</description>
							<lsb>3</lsb>
							<msb>3</msb>
						</field>
						<field>
							<name>RXEMPTY</name>
							<description>Receive FIFO Empty Flag</description>
							<lsb>4</lsb>
							<msb>4</msb>
							<enumeratedValues>
								<name>empty_enum</name>
								<enumeratedValue>
									<name>notEmpty</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>empty</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>RXFULL</name>
							<description>Receive FIFO Full Flag</description>
							<lsb>5</lsb>
							<msb>5</msb>
							<enumeratedValues>
								<name>full_enum</name>
								<enumeratedValue>
									<name>notFull</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>full</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="RXEMPTY">
							<name>TXEMPTY</name>
							<description>Transmit FIFO Empty Flag</description>
							<lsb>6</lsb>
							<msb>6</msb>
						</field>
						<field derivedFrom="RXFULL">
							<name>TXFULL</name>
							<description>Receive FIFO Full Flag</description>
							<lsb>7</lsb>
							<msb>7</msb>
						</field>
						<field>
							<name>RXELT</name>
							<description>Number of bytes in Receive FIFO.</description>
							<lsb>8</lsb>
							<msb>11</msb>
						</field>
						<field>
							<name>TXELT</name>
							<description>Number of bytes in Transmit FIFO.</description>
							<lsb>12</lsb>
							<msb>15</msb>
						</field>
						<field derivedFrom="PAR">
							<name>PRES</name>
							<description>Card Presence Indication. The presence indication depends on the polarity bit (SC_CR.PRPOL): PRPOL = 0=&gt; PRES=1 on rising edge of SC_DETECT, PRPOL = 1=&gt;PRES=1 on falling edge of SC_DETECT pin.  Cleared by hardware.</description>
							<lsb>16</lsb>
							<msb>16</msb>
						</field>
						<field derivedFrom="PAR">
							<name>PRC</name>
							<description>Protection Card Interface Status Flag.  This bit is set to a 1 by hardware when a fault is detected on the card reader interface.  A fault is defined as a detection of a short-circuit condition on the RST or Vcc pin.  This bit may be cleared by software to a 0.</description>
							<lsb>18</lsb>
							<msb>18</msb>
						</field>
						<field derivedFrom="PAR">
							<name>PDL</name>
							<description>Presence detect Level Status Flag.  This bit is set to a 1 when a level change has been detected on the SC_DETECT pin. If the interrupt is enabled for this flag, a system interrupt will be fired. If the interrupt enable is not set, the flag will be set, but no interrupt will fire.  This bit cleared by software.</description>
							<lsb>19</lsb>
							<msb>19</msb>
						</field>
						<field>
							<name>ACTIV</name>
							<description>Activation Sequencer Status Flag.</description>
							<lsb>20</lsb>
							<msb>20</msb>
							<access>read-write</access>
							<enumeratedValues>
								<name>op_status_enum</name>
								<enumeratedValue>
									<name>busy</name>
									<description>Result not ready</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>ready</name>
									<description>Operation complete and result ready</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
					</fields>
				</register>
				<register>
					<name>PN</name>
					<description>Pin Register</description>
					<addressOffset>0x08</addressOffset>
					<fields>
						<field>
							<name>CRDRST</name>
							<description>Smart Card Reset Pin Control.  Writes to this bit set the associated pin logic level.  Reads from this bit return the logic value present on the associated pin.</description>
							<lsb>0</lsb>
							<msb>0</msb>
							<enumeratedValues>
								<name>lo_hi_enum</name>
								<usage>read-write</usage>
								<enumeratedValue>
									<name>lo</name>
									<description>Logic 0 (low)</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>hi</name>
									<description>Logic 1 (high)</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="CRDRST">
							<name>CRDCLK</name>
							<description>Smart Card Clock Pin Control.  Writes to this bit set the associated pin logic level.  Reads from this bit return the logic value present on the associated pin.</description>
							<lsb>1</lsb>
							<msb>1</msb>
						</field>
						<field derivedFrom="CRDRST">
							<name>CRDIO</name>
							<description>Smart Card I/O Pin Control.  Writes to this bit set the associated pin logic level.  Reads from this bit return the logic value present on the associated pin.</description>
							<lsb>2</lsb>
							<msb>2</msb>
						</field>
						<field derivedFrom="CRDRST">
							<name>CRDC4</name>
							<description>Smart Card C4 Pin Control.  Writes to this bit set the associated pin logic level.  Reads from this bit return the logic value present on the associated pin.</description>
							<lsb>3</lsb>
							<msb>3</msb>
						</field>
						<field derivedFrom="CRDRST">
							<name>CRDC8</name>
							<description>Smart Card C8 Pin Control.  Writes to this bit set the associated pin logic level.  Reads from this bit return the logic value present on the associated pin.</description>
							<lsb>4</lsb>
							<msb>4</msb>
						</field>
						<field>
							<name>CLKSEL</name>
							<description>Smart Card Clock Control Select</description>
							<lsb>5</lsb>
							<msb>5</msb>
							<enumeratedValues>
								<name>manual_auto_enum</name>
								<enumeratedValue>
									<name>manual</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>auto</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>VCCSEL</name>
							<description>Selects supply for smart card. This value must be set to select a target Vcc during card activation.</description>
							<lsb>8</lsb>
							<msb>9</msb>
							<enumeratedValues>
								<name>sc_vcc_enum</name>
								<enumeratedValue>
									<name>v18</name>
									<description>1.8 V</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>v30</name>
									<description>3.0 V</description>
									<value>1</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>v50</name>
									<description>5.0 V</description>
									<isDefault>true</isDefault>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>IO_C48_EN</name>
							<description>Smart Card IOs enable control, manual mode only (if SC_CR.BYPASS_SEQ= 1).</description>
							<lsb>16</lsb>
							<msb>16</msb>
							<enumeratedValues>
								<name>dis_en_enum</name>
								<enumeratedValue>
									<name>disable</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>enable</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="IO_C48_EN">
							<name>CLK_EN</name>
							<description>Smart Card CLK enable control, manual mode only (if SC_CR.BYPASS_SEQ= 1).</description>
							<lsb>17</lsb>
							<msb>17</msb>
						</field>
						<field derivedFrom="IO_C48_EN">
							<name>RST_EN</name>
							<description>Smart Card RST enable control, manual mode only (if SC_CR.BYPASS_SEQ= 1).</description>
							<lsb>18</lsb>
							<msb>18</msb>
						</field>
						<field derivedFrom="IO_C48_EN">
							<name>VCC_EN</name>
							<description>Smart Card supply enable control, manual mode only (if SC_CR.BYPASS_SEQ= 1).</description>
							<lsb>19</lsb>
							<msb>19</msb>
						</field>
						<field derivedFrom="IO_C48_EN">
							<name>RAMP_EN</name>
							<description>Smart Card LDO ramp enable control, manual mode only(if SC_CR.BYPASS_SEQ=1).</description>
							<lsb>20</lsb>
							<msb>20</msb>
						</field>
					</fields>
				</register>
				<register>
					<name>ETUR</name>
					<description>ETU Register</description>
					<addressOffset>0x0C</addressOffset>
					<fields>
						<field>
							<name>ETU</name>
							<description>Elemental Time Unit value. If HALF=0, Number of clocks in one asynchronous bit time. If HALF=1, Number of clocks in one half of one asynchronous bit time.</description>
							<lsb>0</lsb>
							<msb>14</msb>
						</field>
						<field>
							<name>COMP</name>
							<description>Compensation Mode Enable Bit. Controls 1 clock cycle subtraction of ETU value on odd bits.</description>
							<lsb>15</lsb>
							<msb>15</msb>
							<enumeratedValues>
								<name>dis_en_enum</name>
								<enumeratedValue>
									<name>disable</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>enable</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="COMP">
							<name>HALF</name>
							<description>Half ETU Count Selection Bit. NOTE: Guard Time (GT) and Wait Time (WT) must be doubled if HALF=1.</description>
							<lsb>16</lsb>
							<msb>16</msb>
						</field>
					</fields>
				</register>
				<register>
					<name>GTR</name>
					<description>Guard Time. Minimum time between two consecutive start bits in transmit mode.  Guard Time is expressed in ETUs. Guard Time must be doubled if ETUR.HALF=1. Writes to this register may be delayed up to two ETU cycles.</description>
					<addressOffset>0x10</addressOffset>
					<size>16</size>
				</register>
				<register>
					<name>WT0R</name>
					<description>Wait Time. Least Significant 32 bits of the Wait Time Counter expressed in ETU. Wait Time must be doubled if ETUR.HALF=1. writes to this register may be delayed up to two ETU cycles.</description>
					<addressOffset>0x14</addressOffset>
				</register>
				<register>
					<name>WT1R</name>
					<description>Wait Time. Most Significant 8 bits of the Wait Time Counter expressed in ETU. Wait Time must be doubled if ETUR.HALF=1. Writes to this register may be delayed up to two ETU cycles.</description>
					<addressOffset>0x18</addressOffset>
					<size>8</size>
				</register>
				<register>
					<name>IER</name>
					<description>Interrupt Enable Register</description>
					<addressOffset>0x1C</addressOffset>
					<fields>
						<field>
							<name>PARIE</name>
							<description>Parity Error Interrupt Enable</description>
							<lsb>0</lsb>
							<msb>0</msb>
						</field>
						<field derivedFrom="PARIE">
							<name>WTIE</name>
							<description>Waiting Time Overflow Interrupt Enable</description>
							<lsb>1</lsb>
							<msb>1</msb>
						</field>
						<field derivedFrom="PARIE">
							<name>CTIE</name>
							<description>Clock Counter Overflow Interrupt Enable</description>
							<lsb>2</lsb>
							<msb>2</msb>
						</field>
						<field derivedFrom="PARIE">
							<name>TCIE</name>
							<description>Character Transmission Completion Interrupt Enable</description>
							<lsb>3</lsb>
							<msb>3</msb>
						</field>
						<field derivedFrom="PARIE">
							<name>RXEIE</name>
							<description>Receive FIFO Empty Interrupt Enable</description>
							<lsb>4</lsb>
							<msb>4</msb>
						</field>
						<field derivedFrom="PARIE">
							<name>RXTIE</name>
							<description>Receive FIFO Threshold Reached Interrupt Enable</description>
							<lsb>5</lsb>
							<msb>5</msb>
						</field>
						<field derivedFrom="PARIE">
							<name>RXFIE</name>
							<description>Receive FIFO Full Interrupt Enable</description>
							<lsb>6</lsb>
							<msb>6</msb>
						</field>
						<field derivedFrom="PARIE">
							<name>TXEIE</name>
							<description>Transmit FIFO Empty Interrupt Enable</description>
							<lsb>7</lsb>
							<msb>7</msb>
						</field>
						<field derivedFrom="PARIE">
							<name>TXTIE</name>
							<description>Transmit FIFO Threshold Reached Interrupt Enable</description>
							<lsb>8</lsb>
							<msb>8</msb>
						</field>
						<field derivedFrom="PARIE">
							<name>PRCIE</name>
							<description>Protection Card Interface Interrupt Enable</description>
							<lsb>9</lsb>
							<msb>9</msb>
						</field>
						<field derivedFrom="PARIE">
							<name>PDLIE</name>
							<description>Presence Detect Interrupt Enable</description>
							<lsb>10</lsb>
							<msb>10</msb>
						</field>
						<field derivedFrom="PARIE">
							<name>ACTIVIE</name>
							<description>Activation Sequencer Interrupt Enable</description>
							<lsb>11</lsb>
							<msb>11</msb>
						</field>
					</fields>
				</register>
				<register>
					<name>ISR</name>
					<description>Interrupt Status Register</description>
					<addressOffset>0x20</addressOffset>
					<resetValue>0x00000800</resetValue>
					<fields>
						<field>
							<name>PARIS</name>
							<description>Parity Error Interrupt Status</description>
							<lsb>0</lsb>
							<msb>0</msb>
							<enumeratedValues>
								<name>flag_enum</name>
								<enumeratedValue>
									<name>inactive</name>
									<description>No interrupt is pending.</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>pending</name>
									<description>An interrupt is pending.</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="PARIS">
							<name>WTIS</name>
							<description>Waiting Time Overflow Interrupt Status Flag</description>
							<lsb>1</lsb>
							<msb>1</msb>
						</field>
						<field derivedFrom="PARIS">
							<name>CTIS</name>
							<description>Clock Counter Overflow Interrupt Status Flag</description>
							<lsb>2</lsb>
							<msb>2</msb>
						</field>
						<field derivedFrom="PARIS">
							<name>TCIS</name>
							<description>Character Transmission Completion Interrupt Status Flag</description>
							<lsb>3</lsb>
							<msb>3</msb>
						</field>
						<field derivedFrom="PARIS">
							<name>RXEIS</name>
							<description>Receive FIFO Empty Interrupt Status Flag</description>
							<lsb>4</lsb>
							<msb>4</msb>
						</field>
						<field derivedFrom="PARIS">
							<name>RXTIS</name>
							<description>Receive FIFO Threshold Reached Interrupt Status Flag</description>
							<lsb>5</lsb>
							<msb>5</msb>
						</field>
						<field derivedFrom="PARIS">
							<name>RXFIS</name>
							<description>Receive FIFO Full Interrupt Status</description>
							<lsb>6</lsb>
							<msb>6</msb>
						</field>
						<field derivedFrom="PARIS">
							<name>TXEIS</name>
							<description>Transmit FIFO Empty Interrupt Status Flag</description>
							<lsb>7</lsb>
							<msb>7</msb>
						</field>
						<field derivedFrom="PARIS">
							<name>TXTIS</name>
							<description>Transmit FIFO Threshold Reached Interrupt Status Flag</description>
							<lsb>8</lsb>
							<msb>8</msb>
						</field>
						<field derivedFrom="PARIS">
							<name>PRCIS</name>
							<description>Protection Card Interface Interrupt Status Flag</description>
							<lsb>9</lsb>
							<msb>9</msb>
						</field>
						<field derivedFrom="PARIS">
							<name>PDLIS</name>
							<description>Presence detect Interrupt Status Flag</description>
							<lsb>10</lsb>
							<msb>10</msb>
						</field>
						<field derivedFrom="PARIS">
							<name>ACTIVIS</name>
							<description>Activation Sequencer Interrupt Status Flag</description>
							<lsb>11</lsb>
							<msb>11</msb>
						</field>
					</fields>
				</register>
				<register>
					<name>TXR</name>
					<description>Transmit Data. Writes to this register will load the 8 bit input data into the FIFO.</description>
					<addressOffset>0x24</addressOffset>
					<size>8</size>
					<access>write-only</access>
				</register>
				<register>
					<name>RXR</name>
					<description>Receive Register</description>
					<addressOffset>0x28</addressOffset>
					<access>read-only</access>
					<fields>
						<field>
							<name>DATA</name>
							<description>Receive Data. Reads from this register will unload 8 bit receive data from the FIFO.</description>
							<lsb>0</lsb>
							<msb>7</msb>
						</field>
						<field>
							<name>PARER</name>
							<description>Parity Error Detect Bit. Parity error bit associated with lower bits 7:0.</description>
							<lsb>8</lsb>
							<msb>8</msb>
							<enumeratedValues>
								<name>error_enum</name>
								<usage>read</usage>
								<enumeratedValue>
									<name>noError</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>error</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
					</fields>
				</register>
				<register>
					<name>CCR</name>
					<description>Clock Counter Register</description>
					<addressOffset>0x2C</addressOffset>
					<fields>
						<field>
							<name>CCYC</name>
							<description>Number of Clock Cycles to Count. Writes to this register may be delayed up to two ETU cycles.</description>
							<lsb>0</lsb>
							<msb>23</msb>
						</field>
						<field>
							<name>MAN</name>
							<description>Manual Mode. The counter starts counting-down on if this bit is set instead of an AUTOMATIC hardware mechanism.</description>
							<lsb>31</lsb>
							<msb>31</msb>
							<enumeratedValues>
								<name>dis_en_enum</name>
								<enumeratedValue>
									<name>disable</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>enable</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
					</fields>
				</register>
			</registers>
			<addressBlock>
				<offset>0x00</offset>
				<size>0x1000</size>
				<usage>registers</usage>
			</addressBlock>
		</peripheral>
		<peripheral>
			<name>TFTController</name>
			<description>Color LCD Controller</description>
			<prependToName>CLDC_</prependToName>
			<baseAddress>0x40031000</baseAddress>
			<registers>
				<register>
					<name>CLK</name>
					<description>LCD Clock Register</description>
					<addressOffset>0x00</addressOffset>
					<fields>
						<field>
							<name>CLKDIV</name>
							<description>LCD Clock Divide Value. Pixel clock frequency is PClk divided by (CLKDIV +1)</description>
							<lsb>0</lsb>
							<msb>7</msb>
						</field>
						<field>
							<name>ACB</name>
							<description>AC Bias frequency. AC bias pin toggles when the specified ACB +1 number of line clocks are applied (this field is ignored in TFT mode)</description>
							<lsb>8</lsb>
							<msb>15</msb>
						</field>
						<field>
							<name>DPOL</name>
							<description>Video Enable polarity</description>
							<lsb>16</lsb>
							<msb>16</msb>
							<enumeratedValues>
								<name>hi_lo_pol_enum</name>
								<enumeratedValue>
									<name>activeHi</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>activeLo</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="DPOL">
							<name>VPOL</name>
							<description>Vertical Sync Polarity</description>
							<lsb>17</lsb>
							<msb>17</msb>
						</field>
						<field>
							<name>HPOL</name>
							<description>Horizontal Sync Polarity</description>
							<lsb>18</lsb>
							<msb>18</msb>
							<enumeratedValues>
								<name>lo_hi_pol_enum</name>
								<enumeratedValue>
									<name>activeLo</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>activeHi</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>EDGE</name>
							<description>Clock Edge Select</description>
							<lsb>19</lsb>
							<msb>19</msb>
							<enumeratedValues>
								<name>edge_sel_enum</name>
								<enumeratedValue>
									<name>posEdge</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>negEdge</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>PASCLK</name>
							<description>Passive Clock (for STN, set to 0 for TFT)</description>
							<lsb>20</lsb>
							<msb>20</msb>
							<enumeratedValues>
								<name>pas_clk_enum</name>
								<enumeratedValue>
									<name>alwaysActive</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>activeOnData</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
					</fields>
				</register>
				<register>
					<name>VTIM_0</name>
					<description>LCD Vertical Timing 0 Register</description>
					<addressOffset>0x04</addressOffset>
					<fields>
						<field>
							<name>VLINES</name>
							<description>Vertical Lines.  Actual number of lines is 1 + register contents.</description>
							<lsb>0</lsb>
							<msb>11</msb>
						</field>
						<field>
							<name>VBACKPORCH</name>
							<description>Vertical Back Porch Lines</description>
							<lsb>16</lsb>
							<msb>23</msb>
						</field>
					</fields>
				</register>
				<register>
					<name>VTIM_1</name>
					<description>LCD Vertical Timing 1 Register</description>
					<addressOffset>0x08</addressOffset>
					<fields>
						<field>
							<name>VSYNCWIDTH</name>
							<description>Vertical Sync Width. Actual number of lines is 1 + register contents.</description>
							<lsb>0</lsb>
							<msb>7</msb>
						</field>
						<field>
							<name>VFRONTPORCH</name>
							<description>Vertical Front Porch Lines</description>
							<lsb>16</lsb>
							<msb>23</msb>
						</field>
					</fields>
				</register>
				<register>
					<name>HTIM</name>
					<description>LCD Horizontal  Timing Register</description>
					<addressOffset>0x0C</addressOffset>
					<fields>
						<field>
							<name>HSYNCWIDTH</name>
							<description>Horizontal Sync Width.  Actual number of clocks is 1 + register contents.</description>
							<lsb>0</lsb>
							<msb>7</msb>
						</field>
						<field>
							<name>HFRONTPORCH</name>
							<description>Horizontal front porch in LCD clocks.  Actual number of clocks is 1 + register contents.</description>
							<lsb>8</lsb>
							<msb>15</msb>
						</field>
						<field>
							<name>HSIZE</name>
							<description>Horizontal Size (Pixels).  Actual number of pixels is 16 x (1 + register contents).</description>
							<lsb>16</lsb>
							<msb>23</msb>
						</field>
						<field>
							<name>HBACKPORCH</name>
							<description>Horizontal back porch in LCD clocks.  Actual number of clocks is 1 + register contents.</description>
							<lsb>24</lsb>
							<msb>31</msb>
						</field>
					</fields>
				</register>
				<register>
					<name>CTRL</name>
					<description>LCD Control Register</description>
					<addressOffset>0x10</addressOffset>
					<fields>
						<field>
							<name>LCDEN</name>
							<description>LCD Enable</description>
							<lsb>0</lsb>
							<msb>0</msb>
							<enumeratedValues>
								<name>dis_en_enum</name>
								<enumeratedValue>
									<name>disable</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>enable</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>VISEL</name>
							<description>Vertical Compare Interrupt select</description>
							<lsb>1</lsb>
							<msb>2</msb>
							<enumeratedValues>
								<name>vci_sel_enum</name>
								<enumeratedValue>
									<name>onVertSync</name>
									<description>VCI on start of vertical sync</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>onVertBackPorch</name>
									<description>VCI on start of vertical back porch</description>
									<value>1</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>onActiveVideo</name>
									<description>VCI on start of active video</description>
									<value>2</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>onVertFrontPorch</name>
									<description>VCI on start of vertical front porch</description>
									<value>3</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>DISPTYPE</name>
							<description>Display Type</description>
							<lsb>4</lsb>
							<msb>7</msb>
							<enumeratedValues>
								<name>disp_type_enum</name>
								<enumeratedValue>
									<name>stnColor8Bit</name>
									<description>STN Color 8 Bit</description>
									<value>4</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>tft</name>
									<description>TFT</description>
									<value>8</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>RFU</name>
									<description>Reserved. Do not use.</description>
									<isDefault>true</isDefault>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>BPP</name>
							<description>Bits per pixel</description>
							<lsb>8</lsb>
							<msb>10</msb>
							<enumeratedValues>
								<name>bits_per_pix_enum</name>
								<enumeratedValue>
									<name>bpp1</name>
									<description>1 bit per pixel</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>bpp2</name>
									<description>2 bits per pixel</description>
									<value>1</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>bpp4</name>
									<description>4 bits per pixel</description>
									<value>2</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>bpp8</name>
									<description>8 bits per pixel</description>
									<value>3</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>bpp16</name>
									<description>16 bits per pixel</description>
									<value>4</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>bpp24</name>
									<description>24 bits per pixel</description>
									<value>5</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>RFU</name>
									<description>Reserved. Do not use.</description>
									<isDefault>true</isDefault>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>MODE565</name>
							<description>5:6:5 Mode Select</description>
							<lsb>11</lsb>
							<msb>11</msb>
							<enumeratedValues>
								<name>tft_mod_sel_enum</name>
								<enumeratedValue>
									<name>mode555</name>
									<description>5:5:5 Mode Select</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>mode565</name>
									<description>5:6:5 Mode Select ( available from B1)</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>EMODE</name>
							<description>Endian Mode</description>
							<lsb>12</lsb>
							<msb>13</msb>
							<enumeratedValues>
								<name>endian_sel_enum</name>
								<enumeratedValue>
									<name>llbp</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>bbbp</name>
									<value>1</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>lbbp</name>
									<value>2</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>RFU</name>
									<description>Reserved. Do not use.</description>
									<value>3</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="LCDEN">
							<name>C24</name>
							<description>Compact 24 bit. This bit changes the TFT 24 bit color mode to compact display data storage. When set to one, each word contains 1 1/3 pixels of information. When 0 only the three bytes of the word are used for LCD data.</description>
							<lsb>15</lsb>
							<msb>15</msb>
						</field>
						<field>
							<name>BURST</name>
							<description>Threshold and Burst Size Select</description>
							<lsb>19</lsb>
							<msb>20</msb>
							<enumeratedValues>
								<name>burst_size_enum</name>
								<enumeratedValue>
									<name>words4</name>
									<description>FIFO burst size = 4 words</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>words8</name>
									<description>FIFO burst size = 8 words</description>
									<value>1</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>words16</name>
									<description>FIFO burst size = 16 words</description>
									<isDefault>true</isDefault>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>LPOL</name>
							<description>LEND (Line End)  Polarity</description>
							<lsb>21</lsb>
							<msb>21</msb>
							<enumeratedValues>
								<name>hi_lo_pol_enum</name>
								<enumeratedValue>
									<name>activeHi</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>activeLo</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="LCDEN">
							<name>PEN</name>
							<description>Power Enable to the panel</description>
							<lsb>22</lsb>
							<msb>22</msb>
						</field>
					</fields>
				</register>
				<register>
					<dim>2</dim>
					<dimIncrement>4</dimIncrement>
					<name>FRBUF_%s</name>
					<description>Frame Buffer Address. This address points to the start of the frame Buffer. This address is always word aligned and bits 1:0 are ignored.</description>
					<addressOffset>0x18</addressOffset>
				</register>
				<register>
					<name>INT_EN</name>
					<description>LCD Interrupt Enable Register</description>
					<addressOffset>0x20</addressOffset>
					<fields>
						<field>
							<name>UFLO</name>
							<description>FIFO underflow interrupt enable</description>
							<lsb>0</lsb>
							<msb>0</msb>
						</field>
						<field derivedFrom="UFLO">
							<name>ADRRDY</name>
							<description>Address ready interrupt enable</description>
							<lsb>1</lsb>
							<msb>1</msb>
						</field>
						<field derivedFrom="UFLO">
							<name>VCI</name>
							<description>Vertical control interrupt enable</description>
							<lsb>2</lsb>
							<msb>2</msb>
						</field>
						<field derivedFrom="UFLO">
							<name>BERR</name>
							<description>Bus Error interrupt enable</description>
							<lsb>3</lsb>
							<msb>3</msb>
						</field>
					</fields>
				</register>
				<register>
					<name>STAT</name>
					<description>LCD Status Register</description>
					<addressOffset>0x24</addressOffset>
					<resetValue>0x0000100</resetValue>
					<fields>
						<field>
							<name>UFLO</name>
							<description>FIFO underflow interrupt</description>
							<lsb>0</lsb>
							<msb>0</msb>
							<access>read-only</access>
							<modifiedWriteValues>oneToClear</modifiedWriteValues>
							<enumeratedValues>
								<name>flag_enum</name>
								<usage>read</usage>
								<enumeratedValue>
									<name>inactive</name>
									<description>No interrupt is pending.</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>pending</name>
									<description>An interrupt is pending.</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
							<enumeratedValues>
								<name>w1c_enum</name>
								<usage>write</usage>
								<enumeratedValue>
									<name>RFU</name>
									<description>Reserved. Do not use.</description>
									<isDefault>true</isDefault>
								</enumeratedValue>
								<enumeratedValue>
									<name>clear</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="UFLO">
							<name>ADRRDY</name>
							<description>Address ready interrupt</description>
							<lsb>1</lsb>
							<msb>1</msb>
						</field>
						<field derivedFrom="UFLO">
							<name>VCI</name>
							<description>Vertical control interrupt</description>
							<lsb>2</lsb>
							<msb>2</msb>
						</field>
						<field derivedFrom="UFLO">
							<name>BERR</name>
							<description>Bus Error interrupt</description>
							<lsb>3</lsb>
							<msb>3</msb>
						</field>
						<field>
							<name>LCDIDLE</name>
							<description>LCD Idle. This bit can be read after the LCD enable bit is cleared to determine when the current frame is complete.</description>
							<lsb>8</lsb>
							<msb>8</msb>
							<enumeratedValues>
								<name>op_status_enum</name>
								<enumeratedValue>
									<name>busy</name>
									<description>Result not ready</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>ready</name>
									<description>Operation complete and result ready</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
					</fields>
				</register>
				<register>
					<name>HV_PHASE</name>
					<description>HSYNC-VSYNC Phase Difference in number of pixel clocks</description>
					<addressOffset>0x30</addressOffset>
					<size>8</size>
				</register>
			</registers>
			<addressBlock>
				<offset>0x00</offset>
				<size>0x1000</size>
				<usage>registers</usage>
			</addressBlock>
		</peripheral>
		<peripheral>
			<name>Timer_0</name>
			<description>32-bit reloadable timer that can be used for timing and event counting.</description>
			<prependToName>TMR0_</prependToName>
			<baseAddress>0x40010000</baseAddress>
			<interrupt><name>Timer0</name><value>5</value></interrupt>
			<registers>
				<register>
					<name>CNT</name>
					<description>Count.  This register stores the current timer count.</description>
					<addressOffset>0x00</addressOffset>
					<resetValue>0x00000001</resetValue>
				</register>
				<register>
					<name>CMP</name>
					<description>Compare.  This register stores the compare value, which is used to set the maximum count value to initiate a reload of the timer to 0x0001.</description>
					<addressOffset>0x04</addressOffset>
					<resetValue>0x0000FFFF</resetValue>
				</register>
				<register>
					<name>PWM</name>
					<description>PWM.  This register stores the value that is compared to the current timer count.</description>
					<addressOffset>0x08</addressOffset>
				</register>
				<register>
					<name>INT</name>
					<description>Clear Interrupt. Writing a value (0 or 1) to a bit in this register clears the associated interrupt.</description>
					<addressOffset>0x0C</addressOffset>
					<size>1</size>
					<modifiedWriteValues>clear</modifiedWriteValues>
				</register>
				<register>
					<name>CN</name>
					<description>Timer Control Register</description>
					<addressOffset>0x10</addressOffset>
					<fields>
						<field>
							<name>TMODE</name>
							<description>Timer Mode</description>
							<lsb>0</lsb>
							<msb>2</msb>
							<enumeratedValues>
								<name>timer_mod_enum</name>
								<enumeratedValue>
									<name>oneShot</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>continuous</name>
									<value>1</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>counter</name>
									<value>2</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>pwm</name>
									<value>3</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>capture</name>
									<value>4</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>compare</name>
									<value>5</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>gated</name>
									<value>6</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>captureCompare</name>
									<value>7</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>PRES</name>
							<description>Prescaler.  The prescaler bits are formed from PRES3:PRES[2:0]</description>
							<lsb>3</lsb>
							<msb>5</msb>
							<enumeratedValues>
								<name>pres_enum</name>
								<enumeratedValue>
									<name>div1</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>div2</name>
									<value>1</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>div4</name>
									<value>2</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>div8</name>
									<value>3</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>div16</name>
									<value>4</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>div32</name>
									<value>5</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>div64</name>
									<value>6</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>div128</name>
									<value>7</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>TPOL</name>
							<description>Timer input/output polarity bit</description>
							<lsb>6</lsb>
							<msb>6</msb>
							<enumeratedValues>
								<name>hi_lo_pol_enum</name>
								<enumeratedValue>
									<name>activeHi</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>activeLo</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>TEN</name>
							<description>Timer Enable</description>
							<lsb>7</lsb>
							<msb>7</msb>
							<enumeratedValues>
								<name>dis_en_enum</name>
								<enumeratedValue>
									<name>disable</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>enable</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>PRES3</name>
							<description>MSB of prescaler value.</description>
							<lsb>8</lsb>
							<msb>8</msb>
							<enumeratedValues>
								<name>pres3_enum</name>
								<enumeratedValue>
									<name>div1</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>div256</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="TEN">
							<name>PWMSYNC</name>
							<description>Timer PWM Synchronization Mode Enable</description>
							<lsb>9</lsb>
							<msb>9</msb>
						</field>
						<field derivedFrom="TEN">
							<name>NOLHPOL</name>
							<description>Timer PWM output 0A polarity bit.</description>
							<lsb>10</lsb>
							<msb>10</msb>
						</field>
						<field derivedFrom="TEN">
							<name>NOLLPOL</name>
							<description>Timer PWM output 0A' polarity bit.</description>
							<lsb>11</lsb>
							<msb>11</msb>
						</field>
					</fields>
				</register>
				<register>
					<name>NOLCMP</name>
					<description>Timer Non-Overlapping Compare Register</description>
					<addressOffset>0x14</addressOffset>
					<fields>
						<field>
							<name>NOLLCMP</name>
							<description>Non-overlapping Low Compare.  The 8-bit timer count value of non-overlapping time between falling edge of PWM output 0A and next rising edge of PWM output 0A'.</description>
							<lsb>0</lsb>
							<msb>7</msb>
						</field>
						<field>
							<name>NOLHCMP</name>
							<description>Non-overlapping High Compare.  The 8-bit timer count value of non-overlapping time between falling edge of PWM output 0A' and next rising edge of PWM output 0A.</description>
							<lsb>8</lsb>
							<msb>15</msb>
						</field>
					</fields>
				</register>
			</registers>
			<addressBlock>
				<offset>0x00</offset>
				<size>0x1000</size>
				<usage>registers</usage>
			</addressBlock>
		</peripheral>
		<peripheral derivedFrom="Timer_0">
			<name>Timer_1</name>
			<description>32-bit reloadable timer that can be used for timing and event counting.</description>
			<prependToName>TMR1_</prependToName>
			<baseAddress>0x40011000</baseAddress>
			<interrupt><name>Timer1</name><value>6</value></interrupt>
		</peripheral>
		<peripheral derivedFrom="Timer_0">
			<name>Timer_2</name>
			<description>32-bit reloadable timer that can be used for timing and event counting.</description>
			<prependToName>TMR2_</prependToName>
			<baseAddress>0x40012000</baseAddress>
			<interrupt><name>Timer2</name><value>7</value></interrupt>
		</peripheral>
		<peripheral derivedFrom="Timer_0">
			<name>Timer_3</name>
			<description>32-bit reloadable timer that can be used for timing and event counting.</description>
			<prependToName>TMR3_</prependToName>
			<baseAddress>0x40013000</baseAddress>
			<interrupt><name>Timer3</name><value>8</value></interrupt>
		</peripheral>
		<peripheral derivedFrom="Timer_0">
			<name>Timer_4</name>
			<description>32-bit reloadable timer that can be used for timing and event counting.</description>
			<prependToName>TMR14_</prependToName>
			<baseAddress>0x40014000</baseAddress>
			<interrupt><name>Timer4</name><value>9</value></interrupt>
		</peripheral>
		<peripheral derivedFrom="Timer_0">
			<name>Timer_5</name>
			<description>32-bit reloadable timer that can be used for timing and event counting.</description>
			<prependToName>TMR5_</prependToName>
			<baseAddress>0x40015000</baseAddress>
			<interrupt><name>Timer5</name><value>10</value></interrupt>
		</peripheral>
		<peripheral>
			<name>TrueRandomNumberGenerator</name>
			<description>Random Number Generator</description>
			<prependToName>TRNG_</prependToName>
			<baseAddress>0x400B5000</baseAddress>
			<interrupt><name>TRNG</name><value>4</value></interrupt>
			<registers>
				<register>
					<name>CN</name>
					<description>TRNG Control Register</description>
					<addressOffset>0x00</addressOffset>
					<resetValue>0x00000003</resetValue>
					<fields>
						<field>
							<name>RNG_IE</name>
							<description>Random Number Interrupt Enable. This bit enables an interrupt to be generated when a new, 128 bit, random number is ready to be read.</description>
							<lsb>2</lsb>
							<msb>2</msb>
							<enumeratedValues>
								<name>dis_en_enum</name>
								<enumeratedValue>
									<name>disable</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>enable</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>RNG_ISC</name>
							<description>Random Number Interrupt Status Clear. Setting this bit to 1 clears the RNG_I4S bit and acknowledges the interrupt, if enabled. This bit is a write only bit and always reads as zero.</description>
							<lsb>3</lsb>
							<msb>3</msb>
							<access>write-only</access>
							<enumeratedValues>
								<name>w1c_enum</name>
								<usage>write</usage>
								<enumeratedValue>
									<name>RFU</name>
									<description>Reserved. Do not use.</description>
									<isDefault>true</isDefault>
								</enumeratedValue>
								<enumeratedValue>
									<name>clear</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>RNG_I4S</name>
							<description>Random Number 4 Word Status. This bit is set when a new 128 bit random number is ready to be read (using 4 consecutive reads of the TRNG Data Register). When set, an interrupt will be generated if the RNG_IE bit is also set. This bit is cleared by setting the RNG_ISC bit.</description>
							<lsb>4</lsb>
							<msb>4</msb>
							<access>read-only</access>
							<enumeratedValues>
								<name>op_status_enum</name>
								<enumeratedValue>
									<name>busy</name>
									<description>Result not ready</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>ready</name>
									<description>Operation complete and result ready</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="RNG_I4S">
							<name>RNG_IS</name>
							<description>Random Number Word Status. This bit is set when at least one 32 bit random number is ready to be read. This bit is cleared by hardware if all the random words have been read. It is needed to poll this bit before reading the TRNG Data Register</description>
							<lsb>5</lsb>
							<msb>5</msb>
						</field>
						<field>
							<name>AESKG</name>
							<description>AES Key Generate. When enabled, the key for securing NVSRAM is generated and transferred to the secure key register automatically without user visibility or intervention. This bit is cleared by hardware once the key has been transferred to the secure key register.</description>
							<lsb>6</lsb>
							<msb>6</msb>
							<enumeratedValues>
								<name>start_op_enum</name>
								<enumeratedValue>
									<name>complete</name>
									<description>No operation/complete</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>start</name>
									<description>Start operation</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
					</fields>
				</register>
				<register>
					<name>DATA</name>
					<description>Data. The content of this register is valid only when RNG_IS = 1. When TRNG is disabled, read returns 0x0000 0000.</description>
					<addressOffset>0x04</addressOffset>
					<access>read-only</access>
				</register>
			</registers>
			<addressBlock>
				<offset>0x00</offset>
				<size>0x1000</size>
				<usage>registers</usage>
			</addressBlock>
		</peripheral>
		<peripheral>
			<name>UART0</name>
			<description>UART0 (Serial Port 0)</description>
			<prependToName>UART0_</prependToName>
			<baseAddress>0x40020000</baseAddress>
			<interrupt><name>UART0</name><value>14</value></interrupt>
			<registers>
				<register>
					<name>CTRL</name>
					<description>UART Control Register</description>
					<addressOffset>0x00</addressOffset>
					<fields>
						<field>
							<name>RXTHD</name>
							<description>Number of bytes that must be loaded into the receive FIFO before the FFRXIS interrupt will be triggered.</description>
							<lsb>0</lsb>
							<msb>3</msb>
							<enumeratedValues>
								<name>rx_thd_enum</name>
								<enumeratedValue>
									<name>ignored</name>
									<isDefault>true</isDefault>
								</enumeratedValue>
								<enumeratedValue>
									<name>bytes1</name>
									<description>Interrupt will be triggered when the number of bytes in the RX FIFO reaches 1 byte or higher.</description>
									<value>1</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>bytes2</name>
									<description>Interrupt will be triggered when the number of bytes in the RX FIFO reaches 2 bytes or higher.</description>
									<value>2</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>bytes3</name>
									<description>Interrupt will be triggered when the number of bytes in the RX FIFO reaches 3 bytes or higher.</description>
									<value>3</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>bytes4</name>
									<description>Interrupt will be triggered when the number of bytes in the RX FIFO reaches 4 bytes or higher.</description>
									<value>4</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>bytes5</name>
									<description>Interrupt will be triggered when the number of bytes in the RX FIFO reaches 5 bytes or higher.</description>
									<value>5</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>bytes6</name>
									<description>Interrupt will be triggered when the number of bytes in the RX FIFO reaches 6 bytes or higher.</description>
									<value>6</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>bytes7</name>
									<description>Interrupt will be triggered when the number of bytes in the RX FIFO reaches 7 bytes or higher.</description>
									<value>7</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>bytes8</name>
									<description>Interrupt will be triggered when the number of bytes in the RX FIFO reaches 8 bytes or higher.</description>
									<value>8</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>PAREN</name>
							<description>Enables/disables generation and testing of parity bit.</description>
							<lsb>4</lsb>
							<msb>4</msb>
							<enumeratedValues>
								<name>dis_en_enum</name>
								<enumeratedValue>
									<name>disable</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>enable</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>PAREO</name>
							<description>Selects odd or even parity (when PAREN=1).</description>
							<lsb>5</lsb>
							<msb>5</msb>
							<enumeratedValues>
								<name>parity_enum</name>
								<enumeratedValue>
									<name>even</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>odd</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>PARMD</name>
							<description>Selects parity based on 1s or 0s count (when PAREN=1).</description>
							<lsb>6</lsb>
							<msb>6</msb>
							<enumeratedValues>
								<name>par_md_enum</name>
								<enumeratedValue>
									<name>count1s</name>
									<description>Parity calculation is based on number of 1s in frame.</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>count0s</name>
									<description>Parity calculation is based on number of 0s in frame.</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>TXFLUSH</name>
							<description>Flushes the TX FIFO buffer.</description>
							<lsb>8</lsb>
							<msb>8</msb>
							<enumeratedValues>
								<name>start_op_enum</name>
								<enumeratedValue>
									<name>complete</name>
									<description>No operation/complete</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>start</name>
									<description>Start operation</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="TXFLUSH">
							<name>RXFLUSH</name>
							<description>Flushes the RX FIFO buffer.</description>
							<lsb>9</lsb>
							<msb>9</msb>
						</field>
						<field>
							<name>SIZE</name>
							<description>Selects UART character size.</description>
							<lsb>10</lsb>
							<msb>11</msb>
							<enumeratedValues>
								<name>ch_size_enum</name>
								<enumeratedValue>
									<name>bits5</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>bits6</name>
									<value>1</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>bits7</name>
									<value>2</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>bits8</name>
									<value>3</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>STOP</name>
							<description>Selects the number of stop bits that will be generated.</description>
							<lsb>12</lsb>
							<msb>12</msb>
							<enumeratedValues>
								<name>stop_bit_enum</name>
								<enumeratedValue>
									<name>stop1</name>
									<description>1 stop bit</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>stop15</name>
									<description>1.5 stop bits (for 5 bit mode) or 2 stop bits (for 6/7/8 bit mode)</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="PAREN">
							<name>RTSCTSF</name>
							<description>Enables/disables hardware flow control.</description>
							<lsb>13</lsb>
							<msb>13</msb>
						</field>
					</fields>
				</register>
				<register>
					<name>STAT</name>
					<description>UART Status Register</description>
					<addressOffset>0x04</addressOffset>
					<access>read-only</access>
					<resetValue>0x00000050</resetValue>
					<fields>
						<field>
							<name>TXBUSY</name>
							<description>Read-only flag indicating the UART transmit status.</description>
							<lsb>0</lsb>
							<msb>0</msb>
							<enumeratedValues>
								<name>busy_enum</name>
								<enumeratedValue>
									<name>idle</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>busy</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="TXBUSY">
							<name>RXBUSY</name>
							<description>Read-only flag indicating the UART receiver status.</description>
							<lsb>1</lsb>
							<msb>1</msb>
						</field>
						<field>
							<name>RXEMPTY</name>
							<description>Read-only flag indicating the RX FIFO state.</description>
							<lsb>4</lsb>
							<msb>4</msb>
							<enumeratedValues>
								<name>empty_enum</name>
								<enumeratedValue>
									<name>notEmpty</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>empty</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>RXFULL</name>
							<description>Read-only flag indicating the RX FIFO state.</description>
							<lsb>5</lsb>
							<msb>5</msb>
							<enumeratedValues>
								<name>full_enum</name>
								<enumeratedValue>
									<name>notFull</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>full</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="RXEMPTY">
							<name>TXEMPTY</name>
							<description>Read-only flag indicating the TX FIFO state.</description>
							<lsb>6</lsb>
							<msb>6</msb>
						</field>
						<field derivedFrom="RXFULL">
							<name>TXFULL</name>
							<description>Read-only flag indicating the TX FIFO state.</description>
							<lsb>7</lsb>
							<msb>7</msb>
						</field>
						<field>
							<name>RXELT</name>
							<description>Indicates the number of bytes currently in the RX FIFO (0-8)</description>
							<lsb>8</lsb>
							<msb>11</msb>
						</field>
						<field>
							<name>TXELT</name>
							<description>Indicates the number of bytes currently in the TX FIFO (0-8)</description>
							<lsb>12</lsb>
							<msb>15</msb>
						</field>
					</fields>
				</register>
				<register>
					<name>INT_EN</name>
					<description>UART Interrupt Enable Register</description>
					<addressOffset>0x08</addressOffset>
					<fields>
						<field>
							<name>FRAMIE</name>
							<description>Enable for RX Frame Error Interrupt.</description>
							<lsb>0</lsb>
							<msb>0</msb>
							<enumeratedValues>
								<name>dis_en_enum</name>
								<enumeratedValue>
									<name>disable</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>enable</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="FRAMIE">
							<name>PARITYIE</name>
							<description>Enable for RX Parity Error interrupt.</description>
							<lsb>1</lsb>
							<msb>1</msb>
						</field>
						<field derivedFrom="FRAMIE">
							<name>SIGNALIE</name>
							<description>Enable for CTS signal change interrupt (hardware flow control disabled).</description>
							<lsb>2</lsb>
							<msb>2</msb>
						</field>
						<field derivedFrom="FRAMIE">
							<name>OVERIE</name>
							<description>Enable for RX FIFO Overrun interrupt.</description>
							<lsb>3</lsb>
							<msb>3</msb>
						</field>
						<field derivedFrom="FRAMIE">
							<name>FFRXIE</name>
							<description>Enable for interrupt when RX FIFO reaches the number of bytes configured by the RXTHD field.</description>
							<lsb>4</lsb>
							<msb>4</msb>
						</field>
						<field derivedFrom="FRAMIE">
							<name>FFTXOIE</name>
							<description>Enable for interrupt when TX FIFO has only one byte remaining.</description>
							<lsb>5</lsb>
							<msb>5</msb>
						</field>
						<field derivedFrom="FRAMIE">
							<name>FFTXHIE</name>
							<description>Enable for interrupt when TX FIFO is half empty or less.</description>
							<lsb>6</lsb>
							<msb>6</msb>
						</field>
					</fields>
				</register>
				<register>
					<name>INT_STAT</name>
					<description>UART Interrupt Status Register</description>
					<addressOffset>0x0C</addressOffset>
					<fields>
						<field>
							<name>FRAMIS</name>
							<description>Flag for RX Frame Error Interrupt.</description>
							<lsb>0</lsb>
							<msb>0</msb>
							<modifiedWriteValues>zeroToClear</modifiedWriteValues>
						</field>
						<field derivedFrom="FRAMIS">
							<name>PARITYIS</name>
							<description>Flag for RX Parity Error interrupt.</description>
							<lsb>1</lsb>
							<msb>1</msb>
						</field>
						<field derivedFrom="FRAMIS">
							<name>SIGNALIS</name>
							<description>Flag for CTS signal change interrupt (hardware flow control disabled).</description>
							<lsb>2</lsb>
							<msb>2</msb>
						</field>
						<field derivedFrom="FRAMIS">
							<name>OVERIS</name>
							<description>Flag for RX FIFO Overrun interrupt.</description>
							<lsb>3</lsb>
							<msb>3</msb>
						</field>
						<field derivedFrom="FRAMIS">
							<name>FFRXIS</name>
							<description>Flag for interrupt when RX FIFO reaches the number of bytes configured by the RXTHD field.</description>
							<lsb>4</lsb>
							<msb>4</msb>
						</field>
						<field derivedFrom="FRAMIS">
							<name>FFTXOIS</name>
							<description>Flag for interrupt when TX FIFO has only one byte remaining.</description>
							<lsb>5</lsb>
							<msb>5</msb>
						</field>
						<field derivedFrom="FRAMIS">
							<name>FFTXHIS</name>
							<description>Flag for interrupt when TX FIFO is half empty or less.</description>
							<lsb>6</lsb>
							<msb>6</msb>
						</field>
					</fields>
				</register>
				<register>
					<name>BAUD0</name>
					<description>UART Baud Rate 0 Register. Integer portion of baud rate divisor value. Use the following formula to obtain the proper value for this field: IDIV = (integer portion of) 'Nominal Frequency' / (128 x Baud Rate Frequency) where the 'Nominal Frequency' = 2xfPLL0. The integer portion is rounded value (i.e. 5.7 becomes 5).</description>
					<addressOffset>0x10</addressOffset>
					<size>12</size>
				</register>
				<register>
					<name>BAUD1</name>
					<description>UART Baud Rate 1 Register. Decimal portion of baud rate divisor value. Use the following formula to obtain the proper value for this field after obtaining IDIV: DIV = 'Nominal Frequency' / (128 x Baud Rate Frequency).  DDIV = (DIV - IDIV) x 128, where the 'Nominal Frequency' = 2xfPLL0.</description>
					<addressOffset>0x14</addressOffset>
					<size>7</size>
				</register>
				<register>
					<name>PIN</name>
					<description>UART Pin Control Register</description>
					<addressOffset>0x1C</addressOffset>
					<resetValue>0X00000003</resetValue>
					<fields>
						<field>
							<name>CTS</name>
							<description>Current state of CTS I/O pin.</description>
							<lsb>0</lsb>
							<msb>0</msb>
							<access>read-only</access>
							<enumeratedValues>
								<name>lo_hi_enum</name>
								<usage>read-write</usage>
								<enumeratedValue>
									<name>lo</name>
									<description>Logic 0 (low)</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>hi</name>
									<description>Logic 1 (high)</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="CTS">
							<name>RTS</name>
							<description>If hardware flow control is disabled, this bit is used to control the RTS I/O pin output state. This bit has no effect when RTSCTSF=1.</description>
							<lsb>1</lsb>
							<msb>1</msb>
							<access>read-write</access>
						</field>
					</fields>
				</register>
				<register>
					<name>DATA</name>
					<description>UART Data Buffer Register</description>
					<addressOffset>0x20</addressOffset>
					<fields>
						<field>
							<name>DATA</name>
							<description>Load/unload location for TX and RX FIFO buffers.</description>
							<lsb>0</lsb>
							<msb>7</msb>
						</field>
						<field>
							<name>PARITY</name>
							<description>Parity error flag for next byte to be read from FIFO.</description>
							<lsb>8</lsb>
							<msb>8</msb>
							<access>read-only</access>
							<enumeratedValues>
								<name>error_enum</name>
								<usage>read</usage>
								<enumeratedValue>
									<name>noError</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>error</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
					</fields>
				</register>
				<register>
					<name>DMA</name>
					<description>UART DMA Register</description>
					<addressOffset>0x30</addressOffset>
					<fields>
						<field>
							<name>TXCNT</name>
							<description>TX threshold for DMA transmission</description>
							<lsb>0</lsb>
							<msb>3</msb>
						</field>
						<field>
							<name>TXEN</name>
							<description>TX DMA channel enable</description>
							<lsb>4</lsb>
							<msb>4</msb>
							<enumeratedValues>
								<name>dis_en_enum</name>
								<enumeratedValue>
									<name>disable</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>enable</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>RXCNT</name>
							<description>RX threshold for DMA transmission</description>
							<lsb>5</lsb>
							<msb>8</msb>
						</field>
						<field derivedFrom="TXEN">
							<name>RXEN</name>
							<description>RX DMA channel enable</description>
							<lsb>9</lsb>
							<msb>9</msb>
						</field>
					</fields>
				</register>
			</registers>
			<addressBlock>
				<offset>0x00</offset>
				<size>0x1000</size>
				<usage>registers</usage>
			</addressBlock>
		</peripheral>
		<peripheral derivedFrom="UART0">
			<name>UART1</name>
			<description>UART1 (Serial Port 1)</description>
			<prependToName>UART1_</prependToName>
			<baseAddress>0x40021000</baseAddress>
			<interrupt><name>UART1</name><value>15</value></interrupt>
		</peripheral>
		<peripheral>
			<name>USB</name>
			<description>Universal Serial Bus</description>
			<prependToName>USB_</prependToName>
			<baseAddress>0x400B0000</baseAddress>
			<interrupt><name>USB</name><value>2</value></interrupt>
			<registers>
				<register>
					<name>CN</name>
					<description>USB Control Register</description>
					<addressOffset>0x000</addressOffset>
					<resetValue>0x000000B0</resetValue>
					<fields>
						<field>
							<name>USB_EN</name>
							<description>USB Enable</description>
							<lsb>0</lsb>
							<msb>0</msb>
							<enumeratedValues>
								<name>dis_en_enum</name>
								<enumeratedValue>
									<name>disable</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>enable</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
					</fields>
				</register>
				<register>
					<name>DEV_ADDR</name>
					<description>USB Device Address Register</description>
					<addressOffset>0x200</addressOffset>
					<size>7</size>
				</register>
				<register>
					<name>DEV_CN</name>
					<description>USB Device Control Register</description>
					<addressOffset>0x204</addressOffset>
					<fields>
						<field>
							<name>SIGRWU</name>
							<description>USB Signal Remote Wakeup</description>
							<lsb>2</lsb>
							<msb>2</msb>
							<enumeratedValues>
								<name>dis_en_enum</name>
								<enumeratedValue>
									<name>disable</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>enable</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>CONNECT</name>
							<description>Connect to USB</description>
							<lsb>3</lsb>
							<msb>3</msb>
							<enumeratedValues>
								<name>connect_enum</name>
								<enumeratedValue>
									<name>disconnect</name>
									<description>Disconnect pull up resistor between DPLUS and VBUS.</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>connect</name>
									<description>Connect pull up resistor between DPLUS and VBUS.</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="SIGRWU">
							<name>ULPM</name>
							<description>USB Low Power Mode. On receiving a USB suspend interrupt, software can put the USB transceiver into a low power state by setting this bit to 1.  To return the USB transceiver to normal operation, software can clear this bit to 0.</description>
							<lsb>4</lsb>
							<msb>4</msb>
						</field>
						<field>
							<name>URST</name>
							<description>USB Device Controller Reset. When URST is set to 1, the USB controller shall disconnect the device from the USB bus and then reset its states.</description>
							<lsb>5</lsb>
							<msb>5</msb>
							<enumeratedValues>
								<name>reset_enum</name>
								<usage>read-write</usage>
								<enumeratedValue>
									<name>notReset</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>reset</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>VBGATE</name>
							<description>VBUS Gate</description>
							<lsb>6</lsb>
							<msb>6</msb>
							<enumeratedValues>
								<name>gate_enum</name>
								<enumeratedValue>
									<name>alwaysConnect</name>
									<description>CONNECT operation independent of VBUS status</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>connectOnVBUS</name>
									<description>CONNECT operation conditional on VBUS present</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="SIGRWU">
							<name>OSCEN</name>
							<description>Oscillator Enable. The oscillator is assumed to be ready when the USB controller is enabled.</description>
							<lsb>7</lsb>
							<msb>7</msb>
						</field>
						<field derivedFrom="SIGRWU">
							<name>BACT_OE</name>
							<description>Bus Activity Output Enable</description>
							<lsb>8</lsb>
							<msb>8</msb>
						</field>
						<field>
							<name>FIFO_MODE</name>
							<description>FIFO Mode. This setting reduces the likelihood of the device returning NAK due to a busy system bus. In the event of a data underflow (FIFO empty when more data is needed), the device controller will force a bit stuff error on the bus and terminate the packet.</description>
							<lsb>9</lsb>
							<msb>9</msb>
							<enumeratedValues>
								<name>fifo_mod_enum</name>
								<enumeratedValue>
									<name>nakUntilComplete</name>
									<description>The device controller will return NAK to an IN request until the entire packet has been read from system memory into its internal FIFO.</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>responOnDataAvail</name>
									<description>The device controller will respond to an IN request as soon as data becomes available in the FIFO.</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
					</fields>
				</register>
				<register>
					<name>DEV_INT</name>
					<description>USB Device Interrupt Register</description>
					<addressOffset>0x208</addressOffset>
					<resetMask>0xFFFEFFFF</resetMask>
					<fields>
						<field>
							<name>DPACT</name>
							<description>DPLUS Activity. DPLUS activity is an interrupt source that will bring the core out of low power mode.</description>
							<lsb>0</lsb>
							<msb>0</msb>
							<enumeratedValues>
								<name>flag_enum</name>
								<enumeratedValue>
									<name>inactive</name>
									<description>No interrupt is pending.</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>pending</name>
									<description>An interrupt is pending.</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="DPACT">
							<name>RWU_DN</name>
							<description>Remote Wakeup Signaling Done. This bit is cleared by a USB bus reset.</description>
							<lsb>1</lsb>
							<msb>1</msb>
						</field>
						<field derivedFrom="DPACT">
							<name>BACT</name>
							<description>USB Bus Active. This bit is cleared by a USB bus reset.</description>
							<lsb>2</lsb>
							<msb>2</msb>
						</field>
						<field derivedFrom="DPACT">
							<name>BRST</name>
							<description>USB Bus Reset. This bit is self-cleared by hardware at the end of the USB reset condition.</description>
							<lsb>3</lsb>
							<msb>3</msb>
						</field>
						<field derivedFrom="DPACT">
							<name>SUSP</name>
							<description>Suspend. This bit is cleared by a USB bus reset.</description>
							<lsb>4</lsb>
							<msb>4</msb>
						</field>
						<field derivedFrom="DPACT">
							<name>NO_VBUS</name>
							<description>No VBUS. This bit is cleared by a USB bus reset. This bit can be an interrupt source that will bring the core out of low power mode</description>
							<lsb>5</lsb>
							<msb>5</msb>
						</field>
						<field derivedFrom="DPACT">
							<name>VBUS</name>
							<description>VBUS Detect. This bit is cleared by a USB bus reset. This bit can be an interrupt source that will bring the core out of low power mode</description>
							<lsb>6</lsb>
							<msb>6</msb>
						</field>
						<field derivedFrom="DPACT">
							<name>BRST_DN</name>
							<description>Bus Reset Done</description>
							<lsb>7</lsb>
							<msb>7</msb>
						</field>
						<field derivedFrom="DPACT">
							<name>SETUP</name>
							<description>Setup Interrupt</description>
							<lsb>8</lsb>
							<msb>8</msb>
						</field>
						<field derivedFrom="DPACT">
							<name>EP_IN</name>
							<description>Endpoint IN Interrupt</description>
							<lsb>9</lsb>
							<msb>9</msb>
						</field>
						<field derivedFrom="DPACT">
							<name>EP_OUT</name>
							<description>Endpoint OUT Interrupt</description>
							<lsb>10</lsb>
							<msb>10</msb>
						</field>
						<field derivedFrom="DPACT">
							<name>EP_NAK</name>
							<description>Endpoint NAK Interrupt</description>
							<lsb>11</lsb>
							<msb>11</msb>
						</field>
						<field derivedFrom="DPACT">
							<name>DMA_ERR</name>
							<description>DMA Error</description>
							<lsb>12</lsb>
							<msb>12</msb>
						</field>
						<field derivedFrom="DPACT">
							<name>BUF_OVR</name>
							<description>Buffer Overflow</description>
							<lsb>13</lsb>
							<msb>13</msb>
						</field>
						<field>
							<name>VBUS_ST</name>
							<description>VBUS Status</description>
							<lsb>16</lsb>
							<msb>16</msb>
							<access>read-only</access>
							<enumeratedValues>
								<name>lo_hi_enum</name>
								<usage>read-write</usage>
								<enumeratedValue>
									<name>lo</name>
									<description>Logic 0 (low)</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>hi</name>
									<description>Logic 1 (high)</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
					</fields>
				</register>
				<register>
					<name>DEV_INT_EN</name>
					<description>USB Device Interrupt Enable Register</description>
					<addressOffset>0x20C</addressOffset>
					<fields>
						<field>
							<name>DPACT</name>
							<description>DPLUS Activity Interrupt Enable</description>
							<lsb>0</lsb>
							<msb>0</msb>
							<enumeratedValues>
								<name>dis_en_enum</name>
								<enumeratedValue>
									<name>disable</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>enable</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="DPACT">
							<name>RWU_DN</name>
							<description>Remote Wakeup Signaling Done Interrupt Enable</description>
							<lsb>1</lsb>
							<msb>1</msb>
						</field>
						<field derivedFrom="DPACT">
							<name>BACT</name>
							<description>USB Bus Active Interrupt Enable</description>
							<lsb>2</lsb>
							<msb>2</msb>
						</field>
						<field derivedFrom="DPACT">
							<name>BRST</name>
							<description>USB Bus Reset Interrupt Enable</description>
							<lsb>3</lsb>
							<msb>3</msb>
						</field>
						<field derivedFrom="DPACT">
							<name>SUSP</name>
							<description>Suspend Interrupt Enable</description>
							<lsb>4</lsb>
							<msb>4</msb>
						</field>
						<field derivedFrom="DPACT">
							<name>NO_VBUS</name>
							<description>No VBUS Interrupt Enable</description>
							<lsb>5</lsb>
							<msb>5</msb>
						</field>
						<field derivedFrom="DPACT">
							<name>VBUS</name>
							<description>VBUS Detect Interrupt Enable</description>
							<lsb>6</lsb>
							<msb>6</msb>
						</field>
						<field derivedFrom="DPACT">
							<name>BRST_DN</name>
							<description>Bus Reset Done Interrupt Enable</description>
							<lsb>7</lsb>
							<msb>7</msb>
						</field>
						<field derivedFrom="DPACT">
							<name>SETUP</name>
							<description>Endpoint SETUP Interrupt Enable</description>
							<lsb>8</lsb>
							<msb>8</msb>
						</field>
						<field derivedFrom="DPACT">
							<name>EP_IN</name>
							<description>Endpoint IN Interrupt Enable</description>
							<lsb>9</lsb>
							<msb>9</msb>
						</field>
						<field derivedFrom="DPACT">
							<name>EP_OUT</name>
							<description>Endpoint OUT Interrupt Enable</description>
							<lsb>10</lsb>
							<msb>10</msb>
						</field>
						<field derivedFrom="DPACT">
							<name>EP_NAK</name>
							<description>Endpoint NAK Interrupt Enable</description>
							<lsb>11</lsb>
							<msb>11</msb>
						</field>
						<field derivedFrom="DPACT">
							<name>DMA_ERR</name>
							<description>DMA Error Interrupt Enable</description>
							<lsb>12</lsb>
							<msb>12</msb>
						</field>
						<field derivedFrom="DPACT">
							<name>BUF_OVR</name>
							<description>Buffer Overflow</description>
							<lsb>13</lsb>
							<msb>13</msb>
						</field>
					</fields>
				</register>
				<register>
					<name>EP_BASE</name>
					<description>USB Endpoint Descriptor Base Address Register</description>
					<addressOffset>0x220</addressOffset>
					<fields>
						<field>
							<name>EP_BASE</name>
							<description>USB_Endpoint Descriptor Base Address.  This register defines the starting address of the endpoint descriptor in system memory. The descriptor address of each buffer in the endpoint is formed by: EP_BASE[31:9] : EP_DESCRIPTOR_OFFSET.</description>
							<lsb>9</lsb>
							<msb>31</msb>
						</field>
					</fields>
				</register>
				<register>
					<name>CUR_BUF</name>
					<description>USB Current Buffer Register</description>
					<addressOffset>0x224</addressOffset>
					<fields>
						<field>
							<name>OUT_BUF_EP0</name>
							<description>EP0 OUT Transfer Current Buffer</description>
							<lsb>0</lsb>
							<msb>0</msb>
						</field>
						<field derivedFrom="OUT_BUF_EP0">
							<name>OUT_BUF_EP1</name>
							<description>EP1 OUT Transfer Current Buffer</description>
							<lsb>1</lsb>
							<msb>1</msb>
						</field>
						<field derivedFrom="OUT_BUF_EP0">
							<name>OUT_BUF_EP2</name>
							<description>EP2 OUT Transfer Current Buffer</description>
							<lsb>2</lsb>
							<msb>2</msb>
						</field>
						<field derivedFrom="OUT_BUF_EP0">
							<name>OUT_BUF_EP3</name>
							<description>EP3 OUT Transfer Current Buffer</description>
							<lsb>3</lsb>
							<msb>3</msb>
						</field>
						<field derivedFrom="OUT_BUF_EP0">
							<name>OUT_BUF_EP4</name>
							<description>EP4 OUT Transfer Current Buffer</description>
							<lsb>4</lsb>
							<msb>4</msb>
						</field>
						<field derivedFrom="OUT_BUF_EP0">
							<name>OUT_BUF_EP5</name>
							<description>EP5 OUT Transfer Current Buffer</description>
							<lsb>5</lsb>
							<msb>5</msb>
						</field>
						<field derivedFrom="OUT_BUF_EP0">
							<name>OUT_BUF_EP6</name>
							<description>EP6 OUT Transfer Current Buffer</description>
							<lsb>6</lsb>
							<msb>6</msb>
						</field>
						<field derivedFrom="OUT_BUF_EP0">
							<name>OUT_BUF_EP7</name>
							<description>EP7 OUT Transfer Current Buffer</description>
							<lsb>7</lsb>
							<msb>7</msb>
						</field>
						<field derivedFrom="OUT_BUF_EP0">
							<name>OUT_BUF_EP8</name>
							<description>EP8 OUT Transfer Current Buffer</description>
							<lsb>8</lsb>
							<msb>8</msb>
						</field>
						<field derivedFrom="OUT_BUF_EP0">
							<name>OUT_BUF_EP9</name>
							<description>EP9 OUT Transfer Current Buffer</description>
							<lsb>9</lsb>
							<msb>9</msb>
						</field>
						<field derivedFrom="OUT_BUF_EP0">
							<name>OUT_BUF_EP10</name>
							<description>EP10 OUT Transfer Current Buffer</description>
							<lsb>10</lsb>
							<msb>10</msb>
						</field>
						<field derivedFrom="OUT_BUF_EP0">
							<name>OUT_BUF_EP11</name>
							<description>EP11 OUT Transfer Current Buffer</description>
							<lsb>11</lsb>
							<msb>11</msb>
						</field>
						<field derivedFrom="OUT_BUF_EP0">
							<name>OUT_BUF_EP12</name>
							<description>EP12 OUT Transfer Current Buffer</description>
							<lsb>12</lsb>
							<msb>12</msb>
						</field>
						<field derivedFrom="OUT_BUF_EP0">
							<name>OUT_BUF_EP13</name>
							<description>EP13 OUT Transfer Current Buffer</description>
							<lsb>13</lsb>
							<msb>13</msb>
						</field>
						<field derivedFrom="OUT_BUF_EP0">
							<name>OUT_BUF_EP14</name>
							<description>EP14 OUT Transfer Current Buffer</description>
							<lsb>14</lsb>
							<msb>14</msb>
						</field>
						<field derivedFrom="OUT_BUF_EP0">
							<name>OUT_BUF_EP15</name>
							<description>EP15 OUT Transfer Current Buffer</description>
							<lsb>15</lsb>
							<msb>15</msb>
						</field>
						<field derivedFrom="OUT_BUF_EP0">
							<name>IN_BUF_EP0</name>
							<description>EP0 IN Transfer Current Buffer</description>
							<lsb>16</lsb>
							<msb>16</msb>
						</field>
						<field derivedFrom="OUT_BUF_EP0">
							<name>IN_BUF_EP1</name>
							<description>EP1 IN Transfer Current Buffer</description>
							<lsb>17</lsb>
							<msb>17</msb>
						</field>
						<field derivedFrom="OUT_BUF_EP0">
							<name>IN_BUF_EP2</name>
							<description>EP2 IN Transfer Current Buffer</description>
							<lsb>18</lsb>
							<msb>18</msb>
						</field>
						<field derivedFrom="OUT_BUF_EP0">
							<name>IN_BUF_EP3</name>
							<description>EP3 IN Transfer Current Buffer</description>
							<lsb>19</lsb>
							<msb>19</msb>
						</field>
						<field derivedFrom="OUT_BUF_EP0">
							<name>IN_BUF_EP4</name>
							<description>EP4 IN Transfer Current Buffer</description>
							<lsb>20</lsb>
							<msb>20</msb>
						</field>
						<field derivedFrom="OUT_BUF_EP0">
							<name>IN_BUF_EP5</name>
							<description>EP5 IN Transfer Current Buffer</description>
							<lsb>21</lsb>
							<msb>21</msb>
						</field>
						<field derivedFrom="OUT_BUF_EP0">
							<name>IN_BUF_EP6</name>
							<description>EP6 IN Transfer Current Buffer</description>
							<lsb>22</lsb>
							<msb>22</msb>
						</field>
						<field derivedFrom="OUT_BUF_EP0">
							<name>IN_BUF_EP7</name>
							<description>EP7 IN Transfer Current Buffer</description>
							<lsb>23</lsb>
							<msb>23</msb>
						</field>
						<field derivedFrom="OUT_BUF_EP0">
							<name>IN_BUF_EP8</name>
							<description>EP8 IN Transfer Current Buffer</description>
							<lsb>24</lsb>
							<msb>24</msb>
						</field>
						<field derivedFrom="OUT_BUF_EP0">
							<name>IN_BUF_EP9</name>
							<description>EP9 IN Transfer Current Buffer</description>
							<lsb>25</lsb>
							<msb>25</msb>
						</field>
						<field derivedFrom="OUT_BUF_EP0">
							<name>IN_BUF_EP10</name>
							<description>EP10 IN Transfer Current Buffer</description>
							<lsb>26</lsb>
							<msb>26</msb>
						</field>
						<field derivedFrom="OUT_BUF_EP0">
							<name>IN_BUF_EP11</name>
							<description>EP11 IN Transfer Current Buffer</description>
							<lsb>27</lsb>
							<msb>27</msb>
						</field>
						<field derivedFrom="OUT_BUF_EP0">
							<name>IN_BUF_EP12</name>
							<description>EP12 IN Transfer Current Buffer</description>
							<lsb>28</lsb>
							<msb>28</msb>
						</field>
						<field derivedFrom="OUT_BUF_EP0">
							<name>IN_BUF_EP13</name>
							<description>EP13 IN Transfer Current Buffer</description>
							<lsb>29</lsb>
							<msb>29</msb>
						</field>
						<field derivedFrom="OUT_BUF_EP0">
							<name>IN_BUF_EP14</name>
							<description>EP14 IN Transfer Current Buffer</description>
							<lsb>30</lsb>
							<msb>30</msb>
						</field>
						<field derivedFrom="OUT_BUF_EP0">
							<name>IN_BUF_EP15</name>
							<description>EP15 IN Transfer Current Buffer</description>
							<lsb>31</lsb>
							<msb>31</msb>
						</field>
					</fields>
				</register>
				<register>
					<name>IN_OWNER</name>
					<description>USB IN Buffer Owner Register</description>
					<addressOffset>0x228</addressOffset>
					<fields>
						<field>
							<name>INBUF0_OWNER_EP0</name>
							<description>EP0 IN Buffer 0 Owner</description>
							<lsb>0</lsb>
							<msb>0</msb>
							<enumeratedValues>
								<name>owner_enum</name>
								<enumeratedValue>
									<name>software</name>
									<description>This endpoint's IN buffer 0 is owned by the software.</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>usbController</name>
									<description>This endpoint's IN buffer 0 is owned by the USB controller.</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="INBUF0_OWNER_EP0">
							<name>INBUF0_OWNER_EP1</name>
							<description>EP1 IN Buffer 0 Owner</description>
							<lsb>1</lsb>
							<msb>1</msb>
						</field>
						<field derivedFrom="INBUF0_OWNER_EP0">
							<name>INBUF0_OWNER_EP2</name>
							<description>EP2 IN Buffer 0 Owner</description>
							<lsb>2</lsb>
							<msb>2</msb>
						</field>
						<field derivedFrom="INBUF0_OWNER_EP0">
							<name>INBUF0_OWNER_EP3</name>
							<description>EP3 IN Buffer 0 Owner</description>
							<lsb>3</lsb>
							<msb>3</msb>
						</field>
						<field derivedFrom="INBUF0_OWNER_EP0">
							<name>INBUF0_OWNER_EP4</name>
							<description>EP4 IN Buffer 0 Owner</description>
							<lsb>4</lsb>
							<msb>4</msb>
						</field>
						<field derivedFrom="INBUF0_OWNER_EP0">
							<name>INBUF0_OWNER_EP5</name>
							<description>EP5 IN Buffer 0 Owner</description>
							<lsb>5</lsb>
							<msb>5</msb>
						</field>
						<field derivedFrom="INBUF0_OWNER_EP0">
							<name>INBUF0_OWNER_EP6</name>
							<description>EP6 IN Buffer 0 Owner</description>
							<lsb>6</lsb>
							<msb>6</msb>
						</field>
						<field derivedFrom="INBUF0_OWNER_EP0">
							<name>INBUF0_OWNER_EP7</name>
							<description>EP7 IN Buffer 0 Owner</description>
							<lsb>7</lsb>
							<msb>7</msb>
						</field>
						<field derivedFrom="INBUF0_OWNER_EP0">
							<name>INBUF0_OWNER_EP8</name>
							<description>EP8 IN Buffer 0 Owner</description>
							<lsb>8</lsb>
							<msb>8</msb>
						</field>
						<field derivedFrom="INBUF0_OWNER_EP0">
							<name>INBUF0_OWNER_EP9</name>
							<description>EP9 IN Buffer 0 Owner</description>
							<lsb>9</lsb>
							<msb>9</msb>
						</field>
						<field derivedFrom="INBUF0_OWNER_EP0">
							<name>INBUF0_OWNER_EP10</name>
							<description>EP10 IN Buffer 0 Owner</description>
							<lsb>10</lsb>
							<msb>10</msb>
						</field>
						<field derivedFrom="INBUF0_OWNER_EP0">
							<name>INBUF0_OWNER_EP11</name>
							<description>EP11 IN Buffer 0 Owner</description>
							<lsb>11</lsb>
							<msb>11</msb>
						</field>
						<field derivedFrom="INBUF0_OWNER_EP0">
							<name>INBUF0_OWNER_EP12</name>
							<description>EP12 IN Buffer 0 Owner</description>
							<lsb>12</lsb>
							<msb>12</msb>
						</field>
						<field derivedFrom="INBUF0_OWNER_EP0">
							<name>INBUF0_OWNER_EP13</name>
							<description>EP13 IN Buffer 0 Owner</description>
							<lsb>13</lsb>
							<msb>13</msb>
						</field>
						<field derivedFrom="INBUF0_OWNER_EP0">
							<name>INBUF0_OWNER_EP14</name>
							<description>EP14 IN Buffer 0 Owner</description>
							<lsb>14</lsb>
							<msb>14</msb>
						</field>
						<field derivedFrom="INBUF0_OWNER_EP0">
							<name>INBUF0_OWNER_EP15</name>
							<description>EP15 IN Buffer 0 Owner</description>
							<lsb>15</lsb>
							<msb>15</msb>
						</field>
						<field>
							<name>INBUF1_OWNER_EP0</name>
							<description>EP0 IN Buffer 1 Owner</description>
							<lsb>16</lsb>
							<msb>16</msb>
							<enumeratedValues>
								<name>owner_enum</name>
								<enumeratedValue>
									<name>software</name>
									<description>This endpoint's IN buffer 1 is owned by the software.</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>usbController</name>
									<description>This endpoint's IN buffer 1 is owned by the USB controller.</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="INBUF1_OWNER_EP0">
							<name>INBUF1_OWNER_EP1</name>
							<description>EP1 IN Buffer 1 Owner</description>
							<lsb>17</lsb>
							<msb>17</msb>
						</field>
						<field derivedFrom="INBUF1_OWNER_EP0">
							<name>INBUF1_OWNER_EP2</name>
							<description>EP2 IN Buffer 1 Owner</description>
							<lsb>18</lsb>
							<msb>18</msb>
						</field>
						<field derivedFrom="INBUF1_OWNER_EP0">
							<name>INBUF1_OWNER_EP3</name>
							<description>EP3 IN Buffer 1 Owner</description>
							<lsb>19</lsb>
							<msb>19</msb>
						</field>
						<field derivedFrom="INBUF1_OWNER_EP0">
							<name>INBUF1_OWNER_EP4</name>
							<description>EP4 IN Buffer 1 Owner</description>
							<lsb>20</lsb>
							<msb>20</msb>
						</field>
						<field derivedFrom="INBUF1_OWNER_EP0">
							<name>INBUF1_OWNER_EP5</name>
							<description>EP5 IN Buffer 1 Owner</description>
							<lsb>21</lsb>
							<msb>21</msb>
						</field>
						<field derivedFrom="INBUF1_OWNER_EP0">
							<name>INBUF1_OWNER_EP6</name>
							<description>EP6 IN Buffer 1 Owner</description>
							<lsb>22</lsb>
							<msb>22</msb>
						</field>
						<field derivedFrom="INBUF1_OWNER_EP0">
							<name>INBUF1_OWNER_EP7</name>
							<description>EP7 IN Buffer 1 Owner</description>
							<lsb>23</lsb>
							<msb>23</msb>
						</field>
						<field derivedFrom="INBUF1_OWNER_EP0">
							<name>INBUF1_OWNER_EP8</name>
							<description>EP8 IN Buffer 1 Owner</description>
							<lsb>24</lsb>
							<msb>24</msb>
						</field>
						<field derivedFrom="INBUF1_OWNER_EP0">
							<name>INBUF1_OWNER_EP9</name>
							<description>EP9 IN Buffer 1 Owner</description>
							<lsb>25</lsb>
							<msb>25</msb>
						</field>
						<field derivedFrom="INBUF1_OWNER_EP0">
							<name>INBUF1_OWNER_EP10</name>
							<description>EP10 IN Buffer 1 Owner</description>
							<lsb>26</lsb>
							<msb>26</msb>
						</field>
						<field derivedFrom="INBUF1_OWNER_EP0">
							<name>INBUF1_OWNER_EP11</name>
							<description>EP11 IN Buffer 1 Owner</description>
							<lsb>27</lsb>
							<msb>27</msb>
						</field>
						<field derivedFrom="INBUF1_OWNER_EP0">
							<name>INBUF1_OWNER_EP12</name>
							<description>EP12 IN Buffer 1 Owner</description>
							<lsb>28</lsb>
							<msb>28</msb>
						</field>
						<field derivedFrom="INBUF1_OWNER_EP0">
							<name>INBUF1_OWNER_EP13</name>
							<description>EP13 IN Buffer 1 Owner</description>
							<lsb>29</lsb>
							<msb>29</msb>
						</field>
						<field derivedFrom="INBUF1_OWNER_EP0">
							<name>INBUF1_OWNER_EP14</name>
							<description>EP14 IN Buffer 1 Owner</description>
							<lsb>30</lsb>
							<msb>30</msb>
						</field>
						<field derivedFrom="INBUF1_OWNER_EP0">
							<name>INBUF1_OWNER_EP15</name>
							<description>EP15 IN Buffer 1 Owner</description>
							<lsb>31</lsb>
							<msb>31</msb>
						</field>
					</fields>
				</register>
				<register>
					<name>OUT_OWNER</name>
					<description>USB OUT Buffer Owner Register</description>
					<addressOffset>0x22C</addressOffset>
					<fields>
						<field>
							<name>OUTBUF0_OWNER_EP0</name>
							<description>EP0 OUT Buffer 0 Owner</description>
							<lsb>0</lsb>
							<msb>0</msb>
							<enumeratedValues>
								<name>owner_enum</name>
								<enumeratedValue>
									<name>software</name>
									<description>This endpoint's OUT buffer 0 is owned by the software.</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>usbController</name>
									<description>This endpoint's OUT buffer 0 is owned by the USB controller.</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="OUTBUF0_OWNER_EP0">
							<name>OUTBUF0_OWNER_EP1</name>
							<description>EP1 OUT Buffer 0 Owner</description>
							<lsb>1</lsb>
							<msb>1</msb>
						</field>
						<field derivedFrom="OUTBUF0_OWNER_EP0">
							<name>OUTBUF0_OWNER_EP2</name>
							<description>EP2 OUT Buffer 0 Owner</description>
							<lsb>2</lsb>
							<msb>2</msb>
						</field>
						<field derivedFrom="OUTBUF0_OWNER_EP0">
							<name>OUTBUF0_OWNER_EP3</name>
							<description>EP3 OUT Buffer 0 Owner</description>
							<lsb>3</lsb>
							<msb>3</msb>
						</field>
						<field derivedFrom="OUTBUF0_OWNER_EP0">
							<name>OUTBUF0_OWNER_EP4</name>
							<description>EP4 OUT Buffer 0 Owner</description>
							<lsb>4</lsb>
							<msb>4</msb>
						</field>
						<field derivedFrom="OUTBUF0_OWNER_EP0">
							<name>OUTBUF0_OWNER_EP5</name>
							<description>EP5 OUT Buffer 0 Owner</description>
							<lsb>5</lsb>
							<msb>5</msb>
						</field>
						<field derivedFrom="OUTBUF0_OWNER_EP0">
							<name>OUTBUF0_OWNER_EP6</name>
							<description>EP6 OUT Buffer 0 Owner</description>
							<lsb>6</lsb>
							<msb>6</msb>
						</field>
						<field derivedFrom="OUTBUF0_OWNER_EP0">
							<name>OUTBUF0_OWNER_EP7</name>
							<description>EP7 OUT Buffer 0 Owner</description>
							<lsb>7</lsb>
							<msb>7</msb>
						</field>
						<field derivedFrom="OUTBUF0_OWNER_EP0">
							<name>OUTBUF0_OWNER_EP8</name>
							<description>EP8 OUT Buffer 0 Owner</description>
							<lsb>8</lsb>
							<msb>8</msb>
						</field>
						<field derivedFrom="OUTBUF0_OWNER_EP0">
							<name>OUTBUF0_OWNER_EP9</name>
							<description>EP9 OUT Buffer 0 Owner</description>
							<lsb>9</lsb>
							<msb>9</msb>
						</field>
						<field derivedFrom="OUTBUF0_OWNER_EP0">
							<name>OUTBUF0_OWNER_EP10</name>
							<description>EP10 OUT Buffer 0 Owner</description>
							<lsb>10</lsb>
							<msb>10</msb>
						</field>
						<field derivedFrom="OUTBUF0_OWNER_EP0">
							<name>OUTBUF0_OWNER_EP11</name>
							<description>EP11 OUT Buffer 0 Owner</description>
							<lsb>11</lsb>
							<msb>11</msb>
						</field>
						<field derivedFrom="OUTBUF0_OWNER_EP0">
							<name>OUTBUF0_OWNER_EP12</name>
							<description>EP12 OUT Buffer 0 Owner</description>
							<lsb>12</lsb>
							<msb>12</msb>
						</field>
						<field derivedFrom="OUTBUF0_OWNER_EP0">
							<name>OUTBUF0_OWNER_EP13</name>
							<description>EP13 OUT Buffer 0 Owner</description>
							<lsb>13</lsb>
							<msb>13</msb>
						</field>
						<field derivedFrom="OUTBUF0_OWNER_EP0">
							<name>OUTBUF0_OWNER_EP14</name>
							<description>EP14 OUT Buffer 0 Owner</description>
							<lsb>14</lsb>
							<msb>14</msb>
						</field>
						<field derivedFrom="OUTBUF0_OWNER_EP0">
							<name>OUTBUF0_OWNER_EP15</name>
							<description>EP15 OUT Buffer 0 Owner</description>
							<lsb>15</lsb>
							<msb>15</msb>
						</field>
						<field>
							<name>OUTBUF1_OWNER_EP0</name>
							<description>EP0 OUT Buffer 1 Owner</description>
							<lsb>16</lsb>
							<msb>16</msb>
							<enumeratedValues>
								<name>owner_enum</name>
								<enumeratedValue>
									<name>software</name>
									<description>This endpoint's OUT buffer 1 is owned by the software.</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>usbController</name>
									<description>This endpoint's OUT buffer 1 is owned by the USB controller.</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="OUTBUF1_OWNER_EP0">
							<name>OUTBUF1_OWNER_EP1</name>
							<description>EP1 OUT Buffer 1 Owner</description>
							<lsb>17</lsb>
							<msb>17</msb>
						</field>
						<field derivedFrom="OUTBUF1_OWNER_EP0">
							<name>OUTBUF1_OWNER_EP2</name>
							<description>EP2 OUT Buffer 1 Owner</description>
							<lsb>18</lsb>
							<msb>18</msb>
						</field>
						<field derivedFrom="OUTBUF1_OWNER_EP0">
							<name>OUTBUF1_OWNER_EP3</name>
							<description>EP3 OUT Buffer 1 Owner</description>
							<lsb>19</lsb>
							<msb>19</msb>
						</field>
						<field derivedFrom="OUTBUF1_OWNER_EP0">
							<name>OUTBUF1_OWNER_EP4</name>
							<description>EP4 OUT Buffer 1 Owner</description>
							<lsb>20</lsb>
							<msb>20</msb>
						</field>
						<field derivedFrom="OUTBUF1_OWNER_EP0">
							<name>OUTBUF1_OWNER_EP5</name>
							<description>EP5 OUT Buffer 1 Owner</description>
							<lsb>21</lsb>
							<msb>21</msb>
						</field>
						<field derivedFrom="OUTBUF1_OWNER_EP0">
							<name>OUTBUF1_OWNER_EP6</name>
							<description>EP6 OUT Buffer 1 Owner</description>
							<lsb>22</lsb>
							<msb>22</msb>
						</field>
						<field derivedFrom="OUTBUF1_OWNER_EP0">
							<name>OUTBUF1_OWNER_EP7</name>
							<description>EP7 OUT Buffer 1 Owner</description>
							<lsb>23</lsb>
							<msb>23</msb>
						</field>
						<field derivedFrom="OUTBUF1_OWNER_EP0">
							<name>OUTBUF1_OWNER_EP8</name>
							<description>EP8 OUT Buffer 1 Owner</description>
							<lsb>24</lsb>
							<msb>24</msb>
						</field>
						<field derivedFrom="OUTBUF1_OWNER_EP0">
							<name>OUTBUF1_OWNER_EP9</name>
							<description>EP9 OUT Buffer 1 Owner</description>
							<lsb>25</lsb>
							<msb>25</msb>
						</field>
						<field derivedFrom="OUTBUF1_OWNER_EP0">
							<name>OUTBUF1_OWNER_EP10</name>
							<description>EP10 OUT Buffer 1 Owner</description>
							<lsb>26</lsb>
							<msb>26</msb>
						</field>
						<field derivedFrom="OUTBUF1_OWNER_EP0">
							<name>OUTBUF1_OWNER_EP11</name>
							<description>EP11 OUT Buffer 1 Owner</description>
							<lsb>27</lsb>
							<msb>27</msb>
						</field>
						<field derivedFrom="OUTBUF1_OWNER_EP0">
							<name>OUTBUF1_OWNER_EP12</name>
							<description>EP12 OUT Buffer 1 Owner</description>
							<lsb>28</lsb>
							<msb>28</msb>
						</field>
						<field derivedFrom="OUTBUF1_OWNER_EP0">
							<name>OUTBUF1_OWNER_EP13</name>
							<description>EP13 OUT Buffer 1 Owner</description>
							<lsb>29</lsb>
							<msb>29</msb>
						</field>
						<field derivedFrom="OUTBUF1_OWNER_EP0">
							<name>OUTBUF1_OWNER_EP14</name>
							<description>EP14 OUT Buffer 1 Owner</description>
							<lsb>30</lsb>
							<msb>30</msb>
						</field>
						<field derivedFrom="OUTBUF1_OWNER_EP0">
							<name>OUTBUF1_OWNER_EP15</name>
							<description>EP15 OUT Buffer 1 Owner</description>
							<lsb>31</lsb>
							<msb>31</msb>
						</field>
					</fields>
				</register>
				<register>
					<name>IN_INT</name>
					<description>USB IN Interrupt Register</description>
					<addressOffset>0x230</addressOffset>
					<fields>
						<field>
							<name>INBAV_EP0</name>
							<description>EP0 IN Buffer Available Interrupt</description>
							<lsb>0</lsb>
							<msb>0</msb>
							<enumeratedValues>
								<name>flag_enum</name>
								<enumeratedValue>
									<name>inactive</name>
									<description>No interrupt is pending.</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>pending</name>
									<description>An interrupt is pending.</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="INBAV_EP0">
							<name>INBAV_EP1</name>
							<description>EP1 IN Buffer Available Interrupt</description>
							<lsb>1</lsb>
							<msb>1</msb>
						</field>
						<field derivedFrom="INBAV_EP0">
							<name>INBAV_EP2</name>
							<description>EP2 IN Buffer Available Interrupt</description>
							<lsb>2</lsb>
							<msb>2</msb>
						</field>
						<field derivedFrom="INBAV_EP0">
							<name>INBAV_EP3</name>
							<description>EP3 IN Buffer Available Interrupt</description>
							<lsb>3</lsb>
							<msb>3</msb>
						</field>
						<field derivedFrom="INBAV_EP0">
							<name>INBAV_EP4</name>
							<description>EP4 IN Buffer Available Interrupt</description>
							<lsb>4</lsb>
							<msb>4</msb>
						</field>
						<field derivedFrom="INBAV_EP0">
							<name>INBAV_EP5</name>
							<description>EP5 IN Buffer Available Interrupt</description>
							<lsb>5</lsb>
							<msb>5</msb>
						</field>
						<field derivedFrom="INBAV_EP0">
							<name>INBAV_EP6</name>
							<description>EP6 IN Buffer Available Interrupt</description>
							<lsb>6</lsb>
							<msb>6</msb>
						</field>
						<field derivedFrom="INBAV_EP0">
							<name>INBAV_EP7</name>
							<description>EP7 IN Buffer Available Interrupt</description>
							<lsb>7</lsb>
							<msb>7</msb>
						</field>
						<field derivedFrom="INBAV_EP0">
							<name>INBAV_EP8</name>
							<description>EP8 IN Buffer Available Interrupt</description>
							<lsb>8</lsb>
							<msb>8</msb>
						</field>
						<field derivedFrom="INBAV_EP0">
							<name>INBAV_EP9</name>
							<description>EP9 IN Buffer Available Interrupt</description>
							<lsb>9</lsb>
							<msb>9</msb>
						</field>
						<field derivedFrom="INBAV_EP0">
							<name>INBAV_EP10</name>
							<description>EP10 IN Buffer Available Interrupt</description>
							<lsb>10</lsb>
							<msb>10</msb>
						</field>
						<field derivedFrom="INBAV_EP0">
							<name>INBAV_EP11</name>
							<description>EP11 IN Buffer Available Interrupt</description>
							<lsb>11</lsb>
							<msb>11</msb>
						</field>
						<field derivedFrom="INBAV_EP0">
							<name>INBAV_EP12</name>
							<description>EP12 IN Buffer Available Interrupt</description>
							<lsb>12</lsb>
							<msb>12</msb>
						</field>
						<field derivedFrom="INBAV_EP0">
							<name>INBAV_EP13</name>
							<description>EP13 IN Buffer Available Interrupt</description>
							<lsb>13</lsb>
							<msb>13</msb>
						</field>
						<field derivedFrom="INBAV_EP0">
							<name>INBAV_EP14</name>
							<description>EP14 IN Buffer Available Interrupt</description>
							<lsb>14</lsb>
							<msb>14</msb>
						</field>
						<field derivedFrom="INBAV_EP0">
							<name>INBAV_EP15</name>
							<description>EP15 IN Buffer Available Interrupt</description>
							<lsb>15</lsb>
							<msb>15</msb>
						</field>
					</fields>
				</register>
				<register>
					<name>OUT_INT</name>
					<description>USB OUT Interrupt Register</description>
					<addressOffset>0x234</addressOffset>
					<fields>
						<field>
							<name>OUTDAV_EP0</name>
							<description>EP0 OUT Buffer Data Available Interrupt</description>
							<lsb>0</lsb>
							<msb>0</msb>
							<enumeratedValues>
								<name>flag_enum</name>
								<enumeratedValue>
									<name>inactive</name>
									<description>No interrupt is pending.</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>pending</name>
									<description>An interrupt is pending.</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="OUTDAV_EP0">
							<name>OUTDAV_EP1</name>
							<description>EP1 OUT Buffer Data Available Interrupt</description>
							<lsb>1</lsb>
							<msb>1</msb>
						</field>
						<field derivedFrom="OUTDAV_EP0">
							<name>OUTDAV_EP2</name>
							<description>EP2 OUT Buffer Data Available Interrupt</description>
							<lsb>2</lsb>
							<msb>2</msb>
						</field>
						<field derivedFrom="OUTDAV_EP0">
							<name>OUTDAV_EP3</name>
							<description>EP3 OUT Buffer Data Available Interrupt</description>
							<lsb>3</lsb>
							<msb>3</msb>
						</field>
						<field derivedFrom="OUTDAV_EP0">
							<name>OUTDAV_EP4</name>
							<description>EP4 OUT Buffer Data Available Interrupt</description>
							<lsb>4</lsb>
							<msb>4</msb>
						</field>
						<field derivedFrom="OUTDAV_EP0">
							<name>OUTDAV_EP5</name>
							<description>EP5 OUT Buffer Data Available Interrupt</description>
							<lsb>5</lsb>
							<msb>5</msb>
						</field>
						<field derivedFrom="OUTDAV_EP0">
							<name>OUTDAV_EP6</name>
							<description>EP6 OUT Buffer Data Available Interrupt</description>
							<lsb>6</lsb>
							<msb>6</msb>
						</field>
						<field derivedFrom="OUTDAV_EP0">
							<name>OUTDAV_EP7</name>
							<description>EP7 OUT Buffer Data Available Interrupt</description>
							<lsb>7</lsb>
							<msb>7</msb>
						</field>
						<field derivedFrom="OUTDAV_EP0">
							<name>OUTDAV_EP8</name>
							<description>EP8 OUT Buffer Data Available Interrupt</description>
							<lsb>8</lsb>
							<msb>8</msb>
						</field>
						<field derivedFrom="OUTDAV_EP0">
							<name>OUTDAV_EP9</name>
							<description>EP9 OUT Buffer Data Available Interrupt</description>
							<lsb>9</lsb>
							<msb>9</msb>
						</field>
						<field derivedFrom="OUTDAV_EP0">
							<name>OUTDAV_EP10</name>
							<description>EP10 OUT Buffer Data Available Interrupt</description>
							<lsb>10</lsb>
							<msb>10</msb>
						</field>
						<field derivedFrom="OUTDAV_EP0">
							<name>OUTDAV_EP11</name>
							<description>EP11 OUT Buffer Data Available Interrupt</description>
							<lsb>11</lsb>
							<msb>11</msb>
						</field>
						<field derivedFrom="OUTDAV_EP0">
							<name>OUTDAV_EP12</name>
							<description>EP12 OUT Buffer Data Available Interrupt</description>
							<lsb>12</lsb>
							<msb>12</msb>
						</field>
						<field derivedFrom="OUTDAV_EP0">
							<name>OUTDAV_EP13</name>
							<description>EP13 OUT Buffer Data Available Interrupt</description>
							<lsb>13</lsb>
							<msb>13</msb>
						</field>
						<field derivedFrom="OUTDAV_EP0">
							<name>OUTDAV_EP14</name>
							<description>EP14 OUT Buffer Data Available Interrupt</description>
							<lsb>14</lsb>
							<msb>14</msb>
						</field>
						<field derivedFrom="OUTDAV_EP0">
							<name>OUTDAV_EP15</name>
							<description>EP15 OUT Buffer Data Available Interrupt</description>
							<lsb>15</lsb>
							<msb>15</msb>
						</field>
					</fields>
				</register>
				<register>
					<name>NAK_INT</name>
					<description>USB NAK Interrupt Register</description>
					<addressOffset>0x238</addressOffset>
					<fields>
						<field>
							<name>NAK_EP0</name>
							<description>EP0 NAK Interrupt</description>
							<lsb>0</lsb>
							<msb>0</msb>
							<enumeratedValues>
								<name>flag_enum</name>
								<enumeratedValue>
									<name>inactive</name>
									<description>No interrupt is pending.</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>pending</name>
									<description>An interrupt is pending.</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="NAK_EP0">
							<name>NAK_EP1</name>
							<description>EP1 NAK Interrupt</description>
							<lsb>1</lsb>
							<msb>1</msb>
						</field>
						<field derivedFrom="NAK_EP0">
							<name>NAK_EP2</name>
							<description>EP2 NAK Interrupt</description>
							<lsb>2</lsb>
							<msb>2</msb>
						</field>
						<field derivedFrom="NAK_EP0">
							<name>NAK_EP3</name>
							<description>EP3 NAK Interrupt</description>
							<lsb>3</lsb>
							<msb>3</msb>
						</field>
						<field derivedFrom="NAK_EP0">
							<name>NAK_EP4</name>
							<description>EP4 NAK Interrupt</description>
							<lsb>4</lsb>
							<msb>4</msb>
						</field>
						<field derivedFrom="NAK_EP0">
							<name>NAK_EP5</name>
							<description>EP5 NAK Interrupt</description>
							<lsb>5</lsb>
							<msb>5</msb>
						</field>
						<field derivedFrom="NAK_EP0">
							<name>NAK_EP6</name>
							<description>EP6 NAK Interrupt</description>
							<lsb>6</lsb>
							<msb>6</msb>
						</field>
						<field derivedFrom="NAK_EP0">
							<name>NAK_EP7</name>
							<description>EP7 NAK Interrupt</description>
							<lsb>7</lsb>
							<msb>7</msb>
						</field>
						<field derivedFrom="NAK_EP0">
							<name>NAK_EP8</name>
							<description>EP8 NAK Interrupt</description>
							<lsb>8</lsb>
							<msb>8</msb>
						</field>
						<field derivedFrom="NAK_EP0">
							<name>NAK_EP9</name>
							<description>EP9 NAK Interrupt</description>
							<lsb>9</lsb>
							<msb>9</msb>
						</field>
						<field derivedFrom="NAK_EP0">
							<name>NAK_EP10</name>
							<description>EP10 NAK Interrupt</description>
							<lsb>10</lsb>
							<msb>10</msb>
						</field>
						<field derivedFrom="NAK_EP0">
							<name>NAK_EP11</name>
							<description>EP11 NAK Interrupt</description>
							<lsb>11</lsb>
							<msb>11</msb>
						</field>
						<field derivedFrom="NAK_EP0">
							<name>NAK_EP12</name>
							<description>EP12 NAK Interrupt</description>
							<lsb>12</lsb>
							<msb>12</msb>
						</field>
						<field derivedFrom="NAK_EP0">
							<name>NAK_EP13</name>
							<description>EP13 NAK Interrupt</description>
							<lsb>13</lsb>
							<msb>13</msb>
						</field>
						<field derivedFrom="NAK_EP0">
							<name>NAK_EP14</name>
							<description>EP14 NAK Interrupt</description>
							<lsb>14</lsb>
							<msb>14</msb>
						</field>
						<field derivedFrom="NAK_EP0">
							<name>NAK_EP15</name>
							<description>EP15 NAK Interrupt</description>
							<lsb>15</lsb>
							<msb>15</msb>
						</field>
					</fields>
				</register>
				<register>
					<name>DMA_ERR_INT</name>
					<description>USB DMA Error Interrupt Register</description>
					<addressOffset>0x23C</addressOffset>
					<fields>
						<field>
							<name>DMA_ERR_EP0</name>
							<description>EP0 DMA Error Interrupt</description>
							<lsb>0</lsb>
							<msb>0</msb>
							<enumeratedValues>
								<name>flag_enum</name>
								<enumeratedValue>
									<name>inactive</name>
									<description>No interrupt is pending.</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>pending</name>
									<description>An interrupt is pending.</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="DMA_ERR_EP0">
							<name>DMA_ERR_EP1</name>
							<description>EP1 DMA Error Interrupt</description>
							<lsb>1</lsb>
							<msb>1</msb>
						</field>
						<field derivedFrom="DMA_ERR_EP0">
							<name>DMA_ERR_EP2</name>
							<description>EP2 DMA Error Interrupt</description>
							<lsb>2</lsb>
							<msb>2</msb>
						</field>
						<field derivedFrom="DMA_ERR_EP0">
							<name>DMA_ERR_EP3</name>
							<description>EP3 DMA Error Interrupt</description>
							<lsb>3</lsb>
							<msb>3</msb>
						</field>
						<field derivedFrom="DMA_ERR_EP0">
							<name>DMA_ERR_EP4</name>
							<description>EP4 DMA Error Interrupt</description>
							<lsb>4</lsb>
							<msb>4</msb>
						</field>
						<field derivedFrom="DMA_ERR_EP0">
							<name>DMA_ERR_EP5</name>
							<description>EP5 DMA Error Interrupt</description>
							<lsb>5</lsb>
							<msb>5</msb>
						</field>
						<field derivedFrom="DMA_ERR_EP0">
							<name>DMA_ERR_EP6</name>
							<description>EP6 DMA Error Interrupt</description>
							<lsb>6</lsb>
							<msb>6</msb>
						</field>
						<field derivedFrom="DMA_ERR_EP0">
							<name>DMA_ERR_EP7</name>
							<description>EP7 DMA Error Interrupt</description>
							<lsb>7</lsb>
							<msb>7</msb>
						</field>
						<field derivedFrom="DMA_ERR_EP0">
							<name>DMA_ERR_EP8</name>
							<description>EP8 DMA Error Interrupt</description>
							<lsb>8</lsb>
							<msb>8</msb>
						</field>
						<field derivedFrom="DMA_ERR_EP0">
							<name>DMA_ERR_EP9</name>
							<description>EP9 DMA Error Interrupt</description>
							<lsb>9</lsb>
							<msb>9</msb>
						</field>
						<field derivedFrom="DMA_ERR_EP0">
							<name>DMA_ERR_EP10</name>
							<description>EP10 DMA Error Interrupt</description>
							<lsb>10</lsb>
							<msb>10</msb>
						</field>
						<field derivedFrom="DMA_ERR_EP0">
							<name>DMA_ERR_EP11</name>
							<description>EP11 DMA Error Interrupt</description>
							<lsb>11</lsb>
							<msb>11</msb>
						</field>
						<field derivedFrom="DMA_ERR_EP0">
							<name>DMA_ERR_EP12</name>
							<description>EP12 DMA Error Interrupt</description>
							<lsb>12</lsb>
							<msb>12</msb>
						</field>
						<field derivedFrom="DMA_ERR_EP0">
							<name>DMA_ERR_EP13</name>
							<description>EP13 DMA Error Interrupt</description>
							<lsb>13</lsb>
							<msb>13</msb>
						</field>
						<field derivedFrom="DMA_ERR_EP0">
							<name>DMA_ERR_EP14</name>
							<description>EP14 DMA Error Interrupt</description>
							<lsb>14</lsb>
							<msb>14</msb>
						</field>
						<field derivedFrom="DMA_ERR_EP0">
							<name>DMA_ERR_EP15</name>
							<description>EP15 DMA Error Interrupt</description>
							<lsb>15</lsb>
							<msb>15</msb>
						</field>
					</fields>
				</register>
				<register>
					<name>BUF_OVR_INT</name>
					<description>USB Buffer Overflow Interrupt Register</description>
					<addressOffset>0x240</addressOffset>
					<fields>
						<field>
							<name>BUF_OVR_EP0</name>
							<description>EP0 Buffer Overflow Interrupt</description>
							<lsb>0</lsb>
							<msb>0</msb>
							<enumeratedValues>
								<name>flag_enum</name>
								<enumeratedValue>
									<name>inactive</name>
									<description>No interrupt is pending.</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>pending</name>
									<description>An interrupt is pending.</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="BUF_OVR_EP0">
							<name>BUF_OVR_EP1</name>
							<description>EP1 Buffer Overflow Interrupt</description>
							<lsb>1</lsb>
							<msb>1</msb>
						</field>
						<field derivedFrom="BUF_OVR_EP0">
							<name>BUF_OVR_EP2</name>
							<description>EP2 Buffer Overflow Interrupt</description>
							<lsb>2</lsb>
							<msb>2</msb>
						</field>
						<field derivedFrom="BUF_OVR_EP0">
							<name>BUF_OVR_EP3</name>
							<description>EP3 Buffer Overflow Interrupt</description>
							<lsb>3</lsb>
							<msb>3</msb>
						</field>
						<field derivedFrom="BUF_OVR_EP0">
							<name>BUF_OVR_EP4</name>
							<description>EP4 Buffer Overflow Interrupt</description>
							<lsb>4</lsb>
							<msb>4</msb>
						</field>
						<field derivedFrom="BUF_OVR_EP0">
							<name>BUF_OVR_EP5</name>
							<description>EP5 Buffer Overflow Interrupt</description>
							<lsb>5</lsb>
							<msb>5</msb>
						</field>
						<field derivedFrom="BUF_OVR_EP0">
							<name>BUF_OVR_EP6</name>
							<description>EP6 Buffer Overflow Interrupt</description>
							<lsb>6</lsb>
							<msb>6</msb>
						</field>
						<field derivedFrom="BUF_OVR_EP0">
							<name>BUF_OVR_EP7</name>
							<description>EP7 Buffer Overflow Interrupt</description>
							<lsb>7</lsb>
							<msb>7</msb>
						</field>
						<field derivedFrom="BUF_OVR_EP0">
							<name>BUF_OVR_EP8</name>
							<description>EP8 Buffer Overflow Interrupt</description>
							<lsb>8</lsb>
							<msb>8</msb>
						</field>
						<field derivedFrom="BUF_OVR_EP0">
							<name>BUF_OVR_EP9</name>
							<description>EP9 Buffer Overflow Interrupt</description>
							<lsb>9</lsb>
							<msb>9</msb>
						</field>
						<field derivedFrom="BUF_OVR_EP0">
							<name>BUF_OVR_EP10</name>
							<description>EP10 Buffer Overflow Interrupt</description>
							<lsb>10</lsb>
							<msb>10</msb>
						</field>
						<field derivedFrom="BUF_OVR_EP0">
							<name>BUF_OVR_EP11</name>
							<description>EP11 Buffer Overflow Interrupt</description>
							<lsb>11</lsb>
							<msb>11</msb>
						</field>
						<field derivedFrom="BUF_OVR_EP0">
							<name>BUF_OVR_EP12</name>
							<description>EP12 Buffer Overflow Interrupt</description>
							<lsb>12</lsb>
							<msb>12</msb>
						</field>
						<field derivedFrom="BUF_OVR_EP0">
							<name>BUF_OVR_EP13</name>
							<description>EP13 Buffer Overflow Interrupt</description>
							<lsb>13</lsb>
							<msb>13</msb>
						</field>
						<field derivedFrom="BUF_OVR_EP0">
							<name>BUF_OVR_EP14</name>
							<description>EP14 Buffer Overflow Interrupt</description>
							<lsb>14</lsb>
							<msb>14</msb>
						</field>
						<field derivedFrom="BUF_OVR_EP0">
							<name>BUF_OVR_EP15</name>
							<description>EP15 Buffer Overflow Interrupt</description>
							<lsb>15</lsb>
							<msb>15</msb>
						</field>
					</fields>
				</register>
				<register>
					<dim>2</dim>
					<dimIncrement>4</dimIncrement>
					<name>SETUP%s</name>
					<description>USB SETUP Register</description>
					<addressOffset>0x260</addressOffset>
					<access>read-only</access>
				</register>
				<register>
					<dim>16</dim>
					<dimIncrement>4</dimIncrement>
					<name>EP%s</name>
					<description>USB Endpoint Control Register</description>
					<addressOffset>0x280</addressOffset>
					<fields>
						<field>
							<name>EP_DIR</name>
							<description>Endpoint Direction</description>
							<lsb>0</lsb>
							<msb>1</msb>
							<enumeratedValues>
								<name>ep_dir_enum</name>
								<enumeratedValue>
									<name>disable</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>out</name>
									<value>1</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>in</name>
									<value>2</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>control</name>
									<description>This configures the endpoint to be a CONTROL pipe accepting IN, OUT and SETUP packets.</description>
									<value>3</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>EP_BUF2</name>
							<description>Double Buffer Enable. For a single buffered endpoint, the SIE will only use buffer 0 associated with the endpoint transfer direction. For a doubled buffered endpoint, the SIE will ping pong between the two buffers.  This allows the SIE to transfer data to/from system memory while still communicating data to/from the host.</description>
							<lsb>3</lsb>
							<msb>3</msb>
							<enumeratedValues>
								<name>dis_en_enum</name>
								<enumeratedValue>
									<name>disable</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>enable</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="EP_BUF2">
							<name>EP_INT_EN</name>
							<description>Endpoint Interrupt Enable</description>
							<lsb>4</lsb>
							<msb>4</msb>
						</field>
						<field derivedFrom="EP_BUF2">
							<name>EP_NAK_EN</name>
							<description>Endpoint NAK Interrupt Enable</description>
							<lsb>5</lsb>
							<msb>5</msb>
						</field>
						<field>
							<name>EP_DT</name>
							<description>Endpoint Data Toggle Clear</description>
							<lsb>6</lsb>
							<msb>6</msb>
							<enumeratedValues>
								<name>start_op_enum</name>
								<enumeratedValue>
									<name>complete</name>
									<description>No operation/complete</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>start</name>
									<description>Start operation</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>EP_STALL</name>
							<description>Endpoint Stalled. Any access to a stalled endpoint will cause the USB interface to return a STALL handshake.  For CONTROL endpoint, this bit is automatically cleared to 0 upon receiving a SETUP packet.</description>
							<lsb>8</lsb>
							<msb>8</msb>
							<enumeratedValues>
								<name>stalled_enum</name>
								<enumeratedValue>
									<name>notStalled</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>stalled</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="EP_BUF2">
							<name>EP_ST_STALL</name>
							<description>Stall Status Stage of Control Transfer. This bit determines whether a STALL will be returned to the Status Stage of a control transfer. The Stall Status Stage bit, together with the EP_ST_ACK bit, indicates to the SIE how to respond in the status stage of a Control transfer.   The EP_ST_STALL has priority over EP_ST_ACK.  Until software either acknowledges (EP_ST_ACK=1) or stalls the transfer (EP_ST_STALL=1), the SIE answers the status stage of a CONTROL transfer with the NAK handshake. Regardless of the setting of this bit, a CONTROL endpoint must receive a SETUP packet and respond with ACK if the packet is received successfully.  Upon receiving a SETUP packet, this bit is automatically cleared to 0.</description>
							<lsb>9</lsb>
							<msb>9</msb>
						</field>
						<field derivedFrom="EP_BUF2">
							<name>EP_ST_ACK</name>
							<description>Acknowledge Status Stage of Control Transfer. This bit determines whether an ACK will be returned to the Status Stage of a control transfer. Until software either acknowledges (EP_ST_ACK=1) or stalls the transfer (EP_ST_STALL=1), the SIE answers the status stage of a CONTROL transfer with the NAK handshake. Regardless of the setting of this bit, a CONTROL endpoint must receive a SETUP packet and respond with ACK if the packet is received successfully.  Upon receiving a SETUP packet, this bit is automatically cleared to 0.</description>
							<lsb>10</lsb>
							<msb>10</msb>
						</field>
					</fields>
				</register>
			</registers>
			<addressBlock>
				<offset>0x00</offset>
				<size>0x1000</size>
				<usage>registers</usage>
			</addressBlock>
		</peripheral>
		<peripheral>
			<name>WatchdogTimer</name>
			<description>Watchdog Timer</description>
			<prependToName>WDT_</prependToName>
			<baseAddress>0x40003000</baseAddress>
			<interrupt><name>Watchdog_Timer</name><value>1</value></interrupt>
			<registers>
				<register>
					<name>CTRL</name>
					<description>Watchdog Timer Control Register</description>
					<addressOffset>0x00</addressOffset>
					<resetMask>0x7FFFF000</resetMask>
					<fields>
						<field>
							<name>INT_PERIOD</name>
							<description>Watchdog Interrupt Period. The watchdog timer will assert an interrupt, if enabled, if the CPU does not write the watchdog reset sequence to the WDT_RST register before the watchdog timer has counted this time period since the last timer reset.</description>
							<lsb>0</lsb>
							<msb>3</msb>
							<enumeratedValues>
								<name>wdt_time_enum</name>
								<enumeratedValue>
									<name>wdt2pow31</name>
									<description>2**31 clock cycles</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>wdt2pow30</name>
									<description>2**30 clock cycles</description>
									<value>1</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>wdt2pow29</name>
									<description>2**29 clock cycles</description>
									<value>2</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>wdt2pow28</name>
									<description>2**28 clock cycles</description>
									<value>3</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>wdt2pow27</name>
									<description>2**27 clock cycles</description>
									<value>4</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>wdt2pow26</name>
									<description>2**26 clock cycles</description>
									<value>5</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>wdt2pow25</name>
									<description>2**25 clock cycles</description>
									<value>6</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>wdt2pow24</name>
									<description>2**24 clock cycles</description>
									<value>7</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>wdt2pow23</name>
									<description>2**23 clock cycles</description>
									<value>8</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>wdt2pow22</name>
									<description>2**22 clock cycles</description>
									<value>9</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>wdt2pow21</name>
									<description>2**21 clock cycles</description>
									<value>10</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>wdt2pow20</name>
									<description>2**20 clock cycles</description>
									<value>11</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>wdt2pow19</name>
									<description>2**19 clock cycles</description>
									<value>12</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>wdt2pow18</name>
									<description>2**18 clock cycles</description>
									<value>13</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>wdt2pow17</name>
									<description>2**17 clock cycles</description>
									<value>14</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>wdt2pow16</name>
									<description>2**16 clock cycles</description>
									<value>15</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="INT_PERIOD">
							<name>RST_PERIOD</name>
							<description>Watchdog Reset Period. The watchdog timer will assert a reset, if enabled, if the CPU does not write the watchdog reset sequence to the WDT_RST register before the watchdog timer has counted this time period since the last timer reset.</description>
							<lsb>4</lsb>
							<msb>7</msb>
						</field>
						<field>
							<name>WDT_EN</name>
							<description>Watchdog Timer Enable</description>
							<lsb>8</lsb>
							<msb>8</msb>
							<enumeratedValues>
								<name>dis_en_enum</name>
								<enumeratedValue>
									<name>disable</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>enable</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>INT_FLAG</name>
							<description>Watchdog Timer Interrupt Flag</description>
							<lsb>9</lsb>
							<msb>9</msb>
							<enumeratedValues>
								<name>flag_enum</name>
								<enumeratedValue>
									<name>inactive</name>
									<description>No interrupt is pending.</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>pending</name>
									<description>An interrupt is pending.</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field derivedFrom="WDT_EN">
							<name>INT_EN</name>
							<description>Watchdog Timer Interrupt Enable</description>
							<lsb>10</lsb>
							<msb>10</msb>
						</field>
						<field derivedFrom="WDT_EN">
							<name>RST_EN</name>
							<description>Watchdog Timer Reset Enable</description>
							<lsb>11</lsb>
							<msb>11</msb>
						</field>
						<field>
							<name>RST_FLAG</name>
							<description>Watchdog Timer Reset Flag</description>
							<lsb>31</lsb>
							<msb>31</msb>
							<enumeratedValues>
								<name>event_flag_enum</name>
								<usage>read-write</usage>
								<enumeratedValue>
									<name>noEvent</name>
									<description>The event has not occurred</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>occurred</name>
									<description>The event has occurred</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
					</fields>
				</register>
				<register>
					<name>RST</name>
					<description>Watchdog Timer Reset Register</description>
					<addressOffset>0x04</addressOffset>
					<access>write-only</access>
					<fields>
						<field>
							<name>WDT_RST</name>
							<description>Writing the watchdog counter 'reset sequence' to this register resets the watchdog counter. If the watchdog count exceeds INT_PERIOD then a watchdog interrupt will occur, if enabled. If the watchdog count exceeds RST_PERIOD then a watchdog reset will occur, if enabled.</description>
							<lsb>0</lsb>
							<msb>7</msb>
							<enumeratedValues>
								<name>wdt_seq_enum</name>
								<enumeratedValue>
									<name>seq0</name>
									<description>The first value to be written to reset the WDT.</description>
									<value>0x00A5</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>seq1</name>
									<description>The second value to be written to reset the WDT.</description>
									<value>0x005A</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
					</fields>
				</register>
			</registers>
			<addressBlock>
				<offset>0x00</offset>
				<size>0x1000</size>
				<usage>registers</usage>
			</addressBlock>
		</peripheral>
	</peripherals>
</device>
