<?xml version='1.0' encoding='UTF-8'?>
<!--automatically generated with svd_converter.py-->
<!--Based on verilog file from: 190308_0616-->
<!--SVN Revision: $Rev: 1158 $        release-1.4.0.1               -->

<device xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" schemaVersion="1.0" xs:noNamespaceSchemaLocation="CMSIS-SVD_Schema_1_0.xsd">
  <name>netx90_app</name>
  <version>1.0</version>
  <description>netX 90 Application CPU</description>
  <cpu>
    <name>CM4</name>
    <revision>r0p1</revision>
    <endian>little</endian>
    <mpuPresent>true</mpuPresent>
    <fpuPresent>true</fpuPresent>
    <nvicPrioBits>4</nvicPrioBits>
    <vendorSystickConfig>false</vendorSystickConfig>
    <deviceNumInterrupts>78</deviceNumInterrupts>
  </cpu>
  <addressUnitBits>8</addressUnitBits>
  <width>32</width>
  <size>32</size>
  <access>read-write</access>
  <resetValue>0x00000000</resetValue>
  <headerSystemFilename>netx</headerSystemFilename>
  <resetMask>0xFFFFFFFF</resetMask>
  <peripherals>
    <peripheral>
      <name>cm4_scs</name>
      <description>cm4_scs</description>
      <baseAddress>0xE000E000</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>4096</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <!--Absolute address of 'cm4_scs_actlr': 0xE000E008-->
          <name>cm4_scs_actlr</name>
          <description>Auxiliary control register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_scs_stcsr': 0xE000E010-->
          <name>cm4_scs_stcsr</name>
          <description>SysTick control and status register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_scs_strvr': 0xE000E014-->
          <name>cm4_scs_strvr</name>
          <description>SysTick Reload Value register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_scs_stcvr': 0xE000E018-->
          <name>cm4_scs_stcvr</name>
          <description>SysTick current value register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000018</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_scs_stcr': 0xE000E01C-->
          <name>cm4_scs_stcr</name>
          <description>SysTick calibration value register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000001C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_scs_nvic_iser0': 0xE000E100-->
          <name>cm4_scs_nvic_iser0</name>
          <description>Interrupt set-enable register 0 Enables, or reads the enable state of a group of interrupts. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>setena</name>
              <bitRange>[31:0]</bitRange>
              <description>For register cm4_scs_nvic_iser[n], enables or shows the current enabled state of interrupt (m+(32*n)): 0: On reads, interrupt disabled. On writes, no effect. 1: On reads, interrupt enabled. On writes, enable interrupt. Software can enable multiple interrupts in a single write to cm4_scs_nvic_iser[n]. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_scs_nvic_iser1': 0xE000E104-->
          <name>cm4_scs_nvic_iser1</name>
          <description>Interrupt set-enable register 1 Enables, or reads the enable state of a group of interrupts. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000104</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>setena</name>
              <bitRange>[31:0]</bitRange>
              <description>For register cm4_scs_nvic_iser[n], enables or shows the current enabled state of interrupt (m+(32*n)): 0: On reads, interrupt disabled. On writes, no effect. 1: On reads, interrupt enabled. On writes, enable interrupt. Software can enable multiple interrupts in a single write to cm4_scs_nvic_iser[n]. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_scs_nvic_iser2': 0xE000E108-->
          <name>cm4_scs_nvic_iser2</name>
          <description>Interrupt set-enable register 2 Enables, or reads the enable state of a group of interrupts. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000108</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>setena</name>
              <bitRange>[31:0]</bitRange>
              <description>For register cm4_scs_nvic_iser[n], enables or shows the current enabled state of interrupt (m+(32*n)): 0: On reads, interrupt disabled. On writes, no effect. 1: On reads, interrupt enabled. On writes, enable interrupt. Software can enable multiple interrupts in a single write to cm4_scs_nvic_iser[n]. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_scs_nvic_icer0': 0xE000E180-->
          <name>cm4_scs_nvic_icer0</name>
          <description>Interrupt clear-enable register 0 Disables, or reads the enable state of a group of interrupts. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000180</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>clrena</name>
              <bitRange>[31:0]</bitRange>
              <description>For register cm4_scs_nvic_icer[n], disables or shows the current enabled state of interrupt (m+(32*n)): 0: On reads, interrupt disabled. On writes, no effect. 1: On reads, interrupt enabled. On writes, disable interrupt. Software can disable multiple interrupts in a single write to cm4_scs_nvic_icer[n]. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_scs_nvic_icer1': 0xE000E184-->
          <name>cm4_scs_nvic_icer1</name>
          <description>Interrupt clear-enable register 1 Disables, or reads the enable state of a group of interrupts. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000184</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>clrena</name>
              <bitRange>[31:0]</bitRange>
              <description>For register cm4_scs_nvic_icer[n], disables or shows the current enabled state of interrupt (m+(32*n)): 0: On reads, interrupt disabled. On writes, no effect. 1: On reads, interrupt enabled. On writes, disable interrupt. Software can disable multiple interrupts in a single write to cm4_scs_nvic_icer[n]. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_scs_nvic_icer2': 0xE000E188-->
          <name>cm4_scs_nvic_icer2</name>
          <description>Interrupt clear-enable register 2 Disables, or reads the enable state of a group of interrupts. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000188</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>clrena</name>
              <bitRange>[31:0]</bitRange>
              <description>For register cm4_scs_nvic_icer[n], disables or shows the current enabled state of interrupt (m+(32*n)): 0: On reads, interrupt disabled. On writes, no effect. 1: On reads, interrupt enabled. On writes, disable interrupt. Software can disable multiple interrupts in a single write to cm4_scs_nvic_icer[n]. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_scs_nvic_ispr0': 0xE000E200-->
          <name>cm4_scs_nvic_ispr0</name>
          <description>Interrupt set-pending register 0 For a group of interrupts, changes interrupt status to pending, or shows the current   pending status. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>setpend</name>
              <bitRange>[31:0]</bitRange>
              <description>For register cm4_scs_nvic_ispr[n], changes the state of interrupt (m+(32*n)) to pending, or shows whether the state of the interrupt is pending: 0: On reads, interrupt is not pending. On writes, no effect. 1: On reads, interrupt is pending. On writes, change state of interrupt to pending. Software can set multiple interrupts to pending state in a single write to cm4_scs_nvic_ispr[n]. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_scs_nvic_ispr1': 0xE000E204-->
          <name>cm4_scs_nvic_ispr1</name>
          <description>Interrupt set-pending register 1 For a group of interrupts, changes interrupt status to pending, or shows the current   pending status. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000204</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>setpend</name>
              <bitRange>[31:0]</bitRange>
              <description>For register cm4_scs_nvic_ispr[n], changes the state of interrupt (m+(32*n)) to pending, or shows whether the state of the interrupt is pending: 0: On reads, interrupt is not pending. On writes, no effect. 1: On reads, interrupt is pending. On writes, change state of interrupt to pending. Software can set multiple interrupts to pending state in a single write to cm4_scs_nvic_ispr[n]. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_scs_nvic_ispr2': 0xE000E208-->
          <name>cm4_scs_nvic_ispr2</name>
          <description>Interrupt set-pending register 2 For a group of interrupts, changes interrupt status to pending, or shows the current   pending status. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000208</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>setpend</name>
              <bitRange>[31:0]</bitRange>
              <description>For register cm4_scs_nvic_ispr[n], changes the state of interrupt (m+(32*n)) to pending, or shows whether the state of the interrupt is pending: 0: On reads, interrupt is not pending. On writes, no effect. 1: On reads, interrupt is pending. On writes, change state of interrupt to pending. Software can set multiple interrupts to pending state in a single write to cm4_scs_nvic_ispr[n]. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_scs_nvic_icpr0': 0xE000E280-->
          <name>cm4_scs_nvic_icpr0</name>
          <description>Interrupt clear-pending register 0 For a group of interrupts, clears the interrupt pending status, or shows the current   pending status. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000280</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>clrpend</name>
              <bitRange>[31:0]</bitRange>
              <description>For register cm4_scs_nvic_ispr[n], clears the pending state of interrupt (m+(32*n)), or shows whether the state of the interrupt is pending: 0: On reads, interrupt is not pending. On writes, no effect. 1: On reads, interrupt is pending. On writes, clears the pending state of interrupt. Software can clear the pending state of multiple interrupts in a single write to cm4_scs_nvic_icpr[n]. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_scs_nvic_icpr1': 0xE000E284-->
          <name>cm4_scs_nvic_icpr1</name>
          <description>Interrupt clear-pending register 1 For a group of interrupts, clears the interrupt pending status, or shows the current   pending status. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000284</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>clrpend</name>
              <bitRange>[31:0]</bitRange>
              <description>For register cm4_scs_nvic_ispr[n], clears the pending state of interrupt (m+(32*n)), or shows whether the state of the interrupt is pending: 0: On reads, interrupt is not pending. On writes, no effect. 1: On reads, interrupt is pending. On writes, clears the pending state of interrupt. Software can clear the pending state of multiple interrupts in a single write to cm4_scs_nvic_icpr[n]. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_scs_nvic_icpr2': 0xE000E288-->
          <name>cm4_scs_nvic_icpr2</name>
          <description>Interrupt clear-pending register 2 For a group of interrupts, clears the interrupt pending status, or shows the current   pending status. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000288</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>clrpend</name>
              <bitRange>[31:0]</bitRange>
              <description>For register cm4_scs_nvic_ispr[n], clears the pending state of interrupt (m+(32*n)), or shows whether the state of the interrupt is pending: 0: On reads, interrupt is not pending. On writes, no effect. 1: On reads, interrupt is pending. On writes, clears the pending state of interrupt. Software can clear the pending state of multiple interrupts in a single write to cm4_scs_nvic_icpr[n]. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_scs_nvic_iabr0': 0xE000E300-->
          <name>cm4_scs_nvic_iabr0</name>
          <description>Interrupt active bit register 0 For a group of 32 interrupts, shows whether each interrupt is active. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000300</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>active</name>
              <bitRange>[31:0]</bitRange>
              <description>For register cm4_scs_nvic_iabr[n], shows whether interrupt (m+(32*n)) is active. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_scs_nvic_iabr1': 0xE000E304-->
          <name>cm4_scs_nvic_iabr1</name>
          <description>Interrupt active bit register 1 For a group of 32 interrupts, shows whether each interrupt is active. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000304</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>active</name>
              <bitRange>[31:0]</bitRange>
              <description>For register cm4_scs_nvic_iabr[n], shows whether interrupt (m+(32*n)) is active. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_scs_nvic_iabr2': 0xE000E308-->
          <name>cm4_scs_nvic_iabr2</name>
          <description>Interrupt active bit register 2 For a group of 32 interrupts, shows whether each interrupt is active. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000308</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>active</name>
              <bitRange>[31:0]</bitRange>
              <description>For register cm4_scs_nvic_iabr[n], shows whether interrupt (m+(32*n)) is active. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_scs_nvic_ipr0': 0xE000E400-->
          <name>cm4_scs_nvic_ipr0</name>
          <description>Interrupt priority register 0 Sets or reads interrupt priorities. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000400</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>pri_n3</name>
              <bitRange>[31:24]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+3. </description>
            </field>
            <field>
              <name>pri_n2</name>
              <bitRange>[23:16]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+2. </description>
            </field>
            <field>
              <name>pri_n1</name>
              <bitRange>[15:8]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+1. </description>
            </field>
            <field>
              <name>pri_n0</name>
              <bitRange>[7:0]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_scs_nvic_ipr1': 0xE000E404-->
          <name>cm4_scs_nvic_ipr1</name>
          <description>Interrupt priority register 1 Sets or reads interrupt priorities. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000404</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>pri_n3</name>
              <bitRange>[31:24]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+3. </description>
            </field>
            <field>
              <name>pri_n2</name>
              <bitRange>[23:16]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+2. </description>
            </field>
            <field>
              <name>pri_n1</name>
              <bitRange>[15:8]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+1. </description>
            </field>
            <field>
              <name>pri_n0</name>
              <bitRange>[7:0]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_scs_nvic_ipr2': 0xE000E408-->
          <name>cm4_scs_nvic_ipr2</name>
          <description>Interrupt priority register 2 Sets or reads interrupt priorities. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000408</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>pri_n3</name>
              <bitRange>[31:24]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+3. </description>
            </field>
            <field>
              <name>pri_n2</name>
              <bitRange>[23:16]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+2. </description>
            </field>
            <field>
              <name>pri_n1</name>
              <bitRange>[15:8]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+1. </description>
            </field>
            <field>
              <name>pri_n0</name>
              <bitRange>[7:0]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_scs_nvic_ipr3': 0xE000E40C-->
          <name>cm4_scs_nvic_ipr3</name>
          <description>Interrupt priority register 3 Sets or reads interrupt priorities. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000040C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>pri_n3</name>
              <bitRange>[31:24]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+3. </description>
            </field>
            <field>
              <name>pri_n2</name>
              <bitRange>[23:16]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+2. </description>
            </field>
            <field>
              <name>pri_n1</name>
              <bitRange>[15:8]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+1. </description>
            </field>
            <field>
              <name>pri_n0</name>
              <bitRange>[7:0]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_scs_nvic_ipr4': 0xE000E410-->
          <name>cm4_scs_nvic_ipr4</name>
          <description>Interrupt priority register 4 Sets or reads interrupt priorities. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000410</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>pri_n3</name>
              <bitRange>[31:24]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+3. </description>
            </field>
            <field>
              <name>pri_n2</name>
              <bitRange>[23:16]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+2. </description>
            </field>
            <field>
              <name>pri_n1</name>
              <bitRange>[15:8]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+1. </description>
            </field>
            <field>
              <name>pri_n0</name>
              <bitRange>[7:0]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_scs_nvic_ipr5': 0xE000E414-->
          <name>cm4_scs_nvic_ipr5</name>
          <description>Interrupt priority register 5 Sets or reads interrupt priorities. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000414</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>pri_n3</name>
              <bitRange>[31:24]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+3. </description>
            </field>
            <field>
              <name>pri_n2</name>
              <bitRange>[23:16]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+2. </description>
            </field>
            <field>
              <name>pri_n1</name>
              <bitRange>[15:8]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+1. </description>
            </field>
            <field>
              <name>pri_n0</name>
              <bitRange>[7:0]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_scs_nvic_ipr6': 0xE000E418-->
          <name>cm4_scs_nvic_ipr6</name>
          <description>Interrupt priority register 6 Sets or reads interrupt priorities. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000418</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>pri_n3</name>
              <bitRange>[31:24]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+3. </description>
            </field>
            <field>
              <name>pri_n2</name>
              <bitRange>[23:16]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+2. </description>
            </field>
            <field>
              <name>pri_n1</name>
              <bitRange>[15:8]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+1. </description>
            </field>
            <field>
              <name>pri_n0</name>
              <bitRange>[7:0]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_scs_nvic_ipr7': 0xE000E41C-->
          <name>cm4_scs_nvic_ipr7</name>
          <description>Interrupt priority register 7 Sets or reads interrupt priorities. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000041C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>pri_n3</name>
              <bitRange>[31:24]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+3. </description>
            </field>
            <field>
              <name>pri_n2</name>
              <bitRange>[23:16]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+2. </description>
            </field>
            <field>
              <name>pri_n1</name>
              <bitRange>[15:8]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+1. </description>
            </field>
            <field>
              <name>pri_n0</name>
              <bitRange>[7:0]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_scs_nvic_ipr8': 0xE000E420-->
          <name>cm4_scs_nvic_ipr8</name>
          <description>Interrupt priority register 8 Sets or reads interrupt priorities. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000420</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>pri_n3</name>
              <bitRange>[31:24]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+3. </description>
            </field>
            <field>
              <name>pri_n2</name>
              <bitRange>[23:16]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+2. </description>
            </field>
            <field>
              <name>pri_n1</name>
              <bitRange>[15:8]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+1. </description>
            </field>
            <field>
              <name>pri_n0</name>
              <bitRange>[7:0]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_scs_nvic_ipr9': 0xE000E424-->
          <name>cm4_scs_nvic_ipr9</name>
          <description>Interrupt priority register 9 Sets or reads interrupt priorities. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000424</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>pri_n3</name>
              <bitRange>[31:24]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+3. </description>
            </field>
            <field>
              <name>pri_n2</name>
              <bitRange>[23:16]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+2. </description>
            </field>
            <field>
              <name>pri_n1</name>
              <bitRange>[15:8]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+1. </description>
            </field>
            <field>
              <name>pri_n0</name>
              <bitRange>[7:0]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_scs_nvic_ipr10': 0xE000E428-->
          <name>cm4_scs_nvic_ipr10</name>
          <description>Interrupt priority register 10 Sets or reads interrupt priorities. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000428</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>pri_n3</name>
              <bitRange>[31:24]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+3. </description>
            </field>
            <field>
              <name>pri_n2</name>
              <bitRange>[23:16]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+2. </description>
            </field>
            <field>
              <name>pri_n1</name>
              <bitRange>[15:8]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+1. </description>
            </field>
            <field>
              <name>pri_n0</name>
              <bitRange>[7:0]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_scs_nvic_ipr11': 0xE000E42C-->
          <name>cm4_scs_nvic_ipr11</name>
          <description>Interrupt priority register 11 Sets or reads interrupt priorities. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000042C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>pri_n3</name>
              <bitRange>[31:24]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+3. </description>
            </field>
            <field>
              <name>pri_n2</name>
              <bitRange>[23:16]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+2. </description>
            </field>
            <field>
              <name>pri_n1</name>
              <bitRange>[15:8]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+1. </description>
            </field>
            <field>
              <name>pri_n0</name>
              <bitRange>[7:0]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_scs_nvic_ipr12': 0xE000E430-->
          <name>cm4_scs_nvic_ipr12</name>
          <description>Interrupt priority register 12 Sets or reads interrupt priorities. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000430</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>pri_n3</name>
              <bitRange>[31:24]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+3. </description>
            </field>
            <field>
              <name>pri_n2</name>
              <bitRange>[23:16]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+2. </description>
            </field>
            <field>
              <name>pri_n1</name>
              <bitRange>[15:8]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+1. </description>
            </field>
            <field>
              <name>pri_n0</name>
              <bitRange>[7:0]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_scs_nvic_ipr13': 0xE000E434-->
          <name>cm4_scs_nvic_ipr13</name>
          <description>Interrupt priority register 13 Sets or reads interrupt priorities. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000434</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>pri_n3</name>
              <bitRange>[31:24]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+3. </description>
            </field>
            <field>
              <name>pri_n2</name>
              <bitRange>[23:16]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+2. </description>
            </field>
            <field>
              <name>pri_n1</name>
              <bitRange>[15:8]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+1. </description>
            </field>
            <field>
              <name>pri_n0</name>
              <bitRange>[7:0]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_scs_nvic_ipr14': 0xE000E438-->
          <name>cm4_scs_nvic_ipr14</name>
          <description>Interrupt priority register 14 Sets or reads interrupt priorities. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000438</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>pri_n3</name>
              <bitRange>[31:24]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+3. </description>
            </field>
            <field>
              <name>pri_n2</name>
              <bitRange>[23:16]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+2. </description>
            </field>
            <field>
              <name>pri_n1</name>
              <bitRange>[15:8]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+1. </description>
            </field>
            <field>
              <name>pri_n0</name>
              <bitRange>[7:0]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_scs_nvic_ipr15': 0xE000E43C-->
          <name>cm4_scs_nvic_ipr15</name>
          <description>Interrupt priority register 15 Sets or reads interrupt priorities. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000043C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>pri_n3</name>
              <bitRange>[31:24]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+3. </description>
            </field>
            <field>
              <name>pri_n2</name>
              <bitRange>[23:16]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+2. </description>
            </field>
            <field>
              <name>pri_n1</name>
              <bitRange>[15:8]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+1. </description>
            </field>
            <field>
              <name>pri_n0</name>
              <bitRange>[7:0]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_scs_nvic_ipr16': 0xE000E440-->
          <name>cm4_scs_nvic_ipr16</name>
          <description>Interrupt priority register 16 Sets or reads interrupt priorities. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000440</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>pri_n3</name>
              <bitRange>[31:24]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+3. </description>
            </field>
            <field>
              <name>pri_n2</name>
              <bitRange>[23:16]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+2. </description>
            </field>
            <field>
              <name>pri_n1</name>
              <bitRange>[15:8]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+1. </description>
            </field>
            <field>
              <name>pri_n0</name>
              <bitRange>[7:0]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_scs_nvic_ipr17': 0xE000E444-->
          <name>cm4_scs_nvic_ipr17</name>
          <description>Interrupt priority register 17 Sets or reads interrupt priorities. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000444</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>pri_n3</name>
              <bitRange>[31:24]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+3. </description>
            </field>
            <field>
              <name>pri_n2</name>
              <bitRange>[23:16]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+2. </description>
            </field>
            <field>
              <name>pri_n1</name>
              <bitRange>[15:8]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+1. </description>
            </field>
            <field>
              <name>pri_n0</name>
              <bitRange>[7:0]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_scs_nvic_ipr18': 0xE000E448-->
          <name>cm4_scs_nvic_ipr18</name>
          <description>Interrupt priority register 18 Sets or reads interrupt priorities. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000448</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>pri_n3</name>
              <bitRange>[31:24]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+3. </description>
            </field>
            <field>
              <name>pri_n2</name>
              <bitRange>[23:16]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+2. </description>
            </field>
            <field>
              <name>pri_n1</name>
              <bitRange>[15:8]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+1. </description>
            </field>
            <field>
              <name>pri_n0</name>
              <bitRange>[7:0]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_scs_nvic_ipr19': 0xE000E44C-->
          <name>cm4_scs_nvic_ipr19</name>
          <description>Interrupt priority register 19 Sets or reads interrupt priorities. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000044C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>pri_n3</name>
              <bitRange>[31:24]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+3. </description>
            </field>
            <field>
              <name>pri_n2</name>
              <bitRange>[23:16]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+2. </description>
            </field>
            <field>
              <name>pri_n1</name>
              <bitRange>[15:8]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n+1. </description>
            </field>
            <field>
              <name>pri_n0</name>
              <bitRange>[7:0]</bitRange>
              <description>For register cm4_scs_nvic_ipr[n], priority of interrupt number 4n. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_scs_cpuid': 0xE000ED00-->
          <name>cm4_scs_cpuid</name>
          <description>CPUID base register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000D00</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_scs_icsr': 0xE000ED04-->
          <name>cm4_scs_icsr</name>
          <description>Interrupt control and state register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000D04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_scs_vtor': 0xE000ED08-->
          <name>cm4_scs_vtor</name>
          <description>Vector table offset register Holds the vector table address. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000D08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFF80</resetMask>
          <fields>
            <field>
              <name>tbloff</name>
              <bitRange>[31:7]</bitRange>
              <description>Bits[31:7] of the vector table address. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[6:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_scs_aircr': 0xE000ED0C-->
          <name>cm4_scs_aircr</name>
          <description>Application interrupt and reset control reister Sets or returns interrupt control data. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000D0C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFA050000</resetValue>
          <resetMask>0xFFFF8707</resetMask>
          <fields>
            <field>
              <name>vectkey</name>
              <bitRange>[31:16]</bitRange>
              <description>Vector Key. Register writes must write 0x05FA to this field, otherwise the write is ignored. On reads, returns 0xFA05. </description>
            </field>
            <field>
              <name>endianness</name>
              <bitRange>[15:15]</bitRange>
              <description>Indicates the memory system endianness: 0 - Little endian, 1 - Big endian. This bit is static or configured by a hardware input on reset. This bit is read only. </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[14:11]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>prigroup</name>
              <bitRange>[10:8]</bitRange>
              <description>Priority grouping, indicates the binary point position. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[7:3]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sysresetreq</name>
              <bitRange>[2:2]</bitRange>
              <description>System Reset Request. Writing 1 to this bit asserts a signal to the external system to request a Local reset. A Local or Power-on reset clears this bit to 0. </description>
            </field>
            <field>
              <name>vectclractive</name>
              <bitRange>[1:1]</bitRange>
              <description>Writing 1 to this bit clears all active state information for fixed and configurable exceptions. This includes clearing the IPSR to zero. The effect of writing a 1 to this bit if the processor is not halted in Debug state is UNPREDICTABLE. This bit is write only. </description>
            </field>
            <field>
              <name>vectreset</name>
              <bitRange>[0:0]</bitRange>
              <description>Writing 1 to this bit causes a local system reset. This bit self-clears. The effect of writing a 1 to this bit if the processor is not halted in Debug state is UNPREDICTABLE. When the processor is halted in Debug state, if a write to the register writes a 1 to both VECTRESET and SYSRESETREQ, the behavior is UNPREDICTABLE. This bit is write only. Note: The netx90 doesn't support a local system reset. Writing 1 results in UNPREDICTABLE behaviour of the whole system! Use sysresetreq instead! </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_scs_scr': 0xE000ED10-->
          <name>cm4_scs_scr</name>
          <description>System control Register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000D10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_scs_ccr': 0xE000ED14-->
          <name>cm4_scs_ccr</name>
          <description>Configuration and control Register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000D14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_scs_shpr1': 0xE000ED18-->
          <name>cm4_scs_shpr1</name>
          <description>System Handler Priority Register 1 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000D18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_scs_shpr2': 0xE000ED1C-->
          <name>cm4_scs_shpr2</name>
          <description>System Handler Priority Register 2 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000D1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_scs_shpr3': 0xE000ED20-->
          <name>cm4_scs_shpr3</name>
          <description>System Handler Priority Register 3 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000D20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_scs_shcsr': 0xE000ED24-->
          <name>cm4_scs_shcsr</name>
          <description>System Handler Control and State Register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000D24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_scs_cfsr': 0xE000ED28-->
          <name>cm4_scs_cfsr</name>
          <description>Configurable Fault Status Register Contains the three Configurable Fault Status Registers. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000D28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x030FBFBB</resetMask>
          <fields>
            <field>
              <name>bf_align4</name>
              <bitRange>[31:26]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ufsr_divbyzero</name>
              <bitRange>[25:25]</bitRange>
              <description>Divide by zero error has occurred. </description>
            </field>
            <field>
              <name>ufsr_unaligned</name>
              <bitRange>[24:24]</bitRange>
              <description>Unaligned access error has occurred. Multi-word accesses always fault if not word aligned. Software can configure unaligned word and halfword accesses to fault, by enabling UNALIGN_TRP in the CCR. </description>
            </field>
            <field>
              <name>bf_align3</name>
              <bitRange>[23:20]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ufsr_nocp</name>
              <bitRange>[19:19]</bitRange>
              <description>A coprocessor access error has occurred. This shows that the coprocessor is disabled or not present. </description>
            </field>
            <field>
              <name>ufsr_invpc</name>
              <bitRange>[18:18]</bitRange>
              <description>An integrity check error has occurred on EXC_RETURN. </description>
            </field>
            <field>
              <name>ufsr_invstate</name>
              <bitRange>[17:17]</bitRange>
              <description>Instruction executed with invalid EPSR.T or EPSR.IT field. </description>
            </field>
            <field>
              <name>ufsr_undefinstr</name>
              <bitRange>[16:16]</bitRange>
              <description>The processor has attempted to execute an undefined instruction. This might be an undefined instruction associated with an enabled coprocessor. </description>
            </field>
            <field>
              <name>bfsr_bfarvalid</name>
              <bitRange>[15:15]</bitRange>
              <description>BFAR has valid contents. </description>
            </field>
            <field>
              <name>bf_align2</name>
              <bitRange>[14:14]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>bfsr_lsperr</name>
              <bitRange>[13:13]</bitRange>
              <description>A bus fault occurred during FP lazy state preservation. </description>
            </field>
            <field>
              <name>bfsr_stkerr</name>
              <bitRange>[12:12]</bitRange>
              <description>A derived bus fault has occurred on exception entry. </description>
            </field>
            <field>
              <name>bfsr_unstkerr</name>
              <bitRange>[11:11]</bitRange>
              <description>A derived bus fault has occurred on exception return. </description>
            </field>
            <field>
              <name>bfsr_impreciserr</name>
              <bitRange>[10:10]</bitRange>
              <description>Imprecise data access error has occurred. </description>
            </field>
            <field>
              <name>bfsr_preciserr</name>
              <bitRange>[9:9]</bitRange>
              <description>A precise data access error has occurred, and the processor has written the faulting address to the BFAR. </description>
            </field>
            <field>
              <name>bfsr_ibuserr</name>
              <bitRange>[8:8]</bitRange>
              <description>A bus fault on an instruction prefetch has occurred. The fault is signaled only if the instruction is issued. </description>
            </field>
            <field>
              <name>mmfsr_mmarvalid</name>
              <bitRange>[7:7]</bitRange>
              <description>MMFAR has valid contents. </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[6:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>mmfsr_lsperr</name>
              <bitRange>[5:5]</bitRange>
              <description>A MemManage fault occurred during FP lazy state preservation. </description>
            </field>
            <field>
              <name>mmfsr_mstkerr</name>
              <bitRange>[4:4]</bitRange>
              <description>A derived MemManage fault occurred on exception entry. </description>
            </field>
            <field>
              <name>mmfsr_munstkerr</name>
              <bitRange>[3:3]</bitRange>
              <description>A derived MemManage fault occurred on exception return. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[2:2]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>mmfsr_daccviol</name>
              <bitRange>[1:1]</bitRange>
              <description>Data access violation. The MMFAR shows the data address that the load or store tried to access. </description>
            </field>
            <field>
              <name>mmfsr_iaccviol</name>
              <bitRange>[0:0]</bitRange>
              <description>MPU or Execute Never (XN) default memory map access violation on an instruction fetch has occurred. The fault is signalled only if the instruction is issued. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_scs_hfsr': 0xE000ED2C-->
          <name>cm4_scs_hfsr</name>
          <description>HardFault Status Register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000D2C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_scs_dfsr': 0xE000ED30-->
          <name>cm4_scs_dfsr</name>
          <description>Debug fault status Register Shows which debug event occurred. Note: Writing 1 to a register bit clears the bit to 0. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000D30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000001F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>external</name>
              <bitRange>[4:4]</bitRange>
              <description>Indicates a debug event generated because of the assertion of an external debug request. </description>
            </field>
            <field>
              <name>vcatch</name>
              <bitRange>[3:3]</bitRange>
              <description>Indicates triggering of a Vector catch. </description>
            </field>
            <field>
              <name>dwttrap</name>
              <bitRange>[2:2]</bitRange>
              <description>Indicates a debug event generated by the DWT. </description>
            </field>
            <field>
              <name>bkpt</name>
              <bitRange>[1:1]</bitRange>
              <description>Indicates a debug event generated by BKPT instruction execution or a breakpoint match in FPB. </description>
            </field>
            <field>
              <name>halted</name>
              <bitRange>[0:0]</bitRange>
              <description>Indicates a debug event generated by either: - A C_HALT or C_STEP request, triggered by a write to the DHCSR. - A step request triggered by setting DEMCR.MON_STEP to 1. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_scs_mmfar': 0xE000ED34-->
          <name>cm4_scs_mmfar</name>
          <description>MemManage Faul Address Register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000D34</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_scs_bfar': 0xE000ED38-->
          <name>cm4_scs_bfar</name>
          <description>BusFault Address Register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000D38</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_scs_afsr': 0xE000ED3C-->
          <name>cm4_scs_afsr</name>
          <description>Auxiliary Fault Status Register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000D3C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_scs_cpacr': 0xE000ED88-->
          <name>cm4_scs_cpacr</name>
          <description>Coprocessor Access Control Register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000D88</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_scs_dhcsr': 0xE000EDF0-->
          <name>cm4_scs_dhcsr</name>
          <description>Debug halting control and status register Controls halting debug. Note: On writes bits 31-16 (dbgkey) must be set to 0xA05F. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000DF0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x030F002F</resetMask>
          <fields>
            <field>
              <name>bf_align3</name>
              <bitRange>[31:26]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>s_reset_st</name>
              <bitRange>[25:25]</bitRange>
              <description>Indicates whether the processor has been reset since the last read of DHCSR. This is a sticky bit, that clears to 0 on a read of DHCSR. This bit is read-only. </description>
            </field>
            <field>
              <name>s_retire_st</name>
              <bitRange>[24:24]</bitRange>
              <description>Set to 1 every time the processor retires one or more instructions. This is a sticky bit, that clears to 0 on a read of DHCSR. The architecture does not define precisely when this bit is set to 1. It requires only that this happen periodically in Non-debug state to indicate that software execution is progressing. This bit is UNKNOWN after a Power-on or Local reset, but then is set to 1 as soon as the processor executes and retires an instruction. This bit is read-only. </description>
            </field>
            <field>
              <name>bf_align2</name>
              <bitRange>[23:20]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>s_lockup</name>
              <bitRange>[19:19]</bitRange>
              <description>Indicates whether the processor is locked up because of an unrecoverable exception. This bit can only be read as 1 by a remote debugger, using the DAP. The value of 1 indicates that the processor is running but locked up. The bit clears to 0 when the processor enters Debug state. This bit is read-only. </description>
            </field>
            <field>
              <name>s_sleep</name>
              <bitRange>[18:18]</bitRange>
              <description>Indicates whether the processor is sleeping. The debugger must set the C_HALT bit to 1 to gain control, or wait for an interrupt or other wakeup event to wakeup the system. This bit is read-only. </description>
            </field>
            <field>
              <name>s_halt</name>
              <bitRange>[17:17]</bitRange>
              <description>Indicates whether the processor is in Debug state. This bit is read-only. </description>
            </field>
            <field>
              <name>s_regrdy</name>
              <bitRange>[16:16]</bitRange>
              <description>A handshake flag for transfers through the DCRDR: - Writing to DCRSR clears the bit to 0. - Completion of the DCRDR transfer then sets the bit to 1. For more information about DCRDR transfers see Debug Core Register Data Register, DCRDR. This bit is valid only when the processor is in Debug state, otherwise the bit is UNKNOWN. This bit is read-only. </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[15:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>c_snapstall</name>
              <bitRange>[5:5]</bitRange>
              <description>Allow imprecise entry to Debug state. The actions on writing to this bit are: - 0: No action. - 1: Allow imprecise entry to Debug state, for example by forcing any stalled load or store instruction to complete. Setting this bit to 1 allows a debugger to request imprecise entry to Debug state. The effect of setting this bit to 1 is UNPREDICTABLE unless the DHCSR write also sets C_DEBUGEN and C_HALT to 1. This means that if the processor is not already in Debug stateit enters Debug state when the stalled instruction completes. Writing 1 to this bit makes the state of the memory system UNPREDICTABLE. Therefore, if a debugger writes 1 to this bit it must reset the processor before leaving Debug state. Note: - A debugger can write to the DHCSR to clear this bit to 0. However, this does not remove the UNPREDICTABLE state of the memory system caused by setting C_SNAPSTALL to 1. - The architecture does not guarantee that setting this bit to 1 will force entry to Debug state. - ARM strongly recommends that a value of 1 is never written to C_SNAPSTALL when the processor is in Debug state. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[4:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>c_maskints</name>
              <bitRange>[3:3]</bitRange>
              <description>When debug is enabled, the debugger can write to this bit to mask PendSV, SysTick and external configurable interrupts: - 0: Do not mask. - 1: Mask PendSV, SysTick and external configurable interrupts. The effect of any attempt to change the value of this bit is UNPREDICTABLE unless both: - Before the write to DHCSR, the value of the C_HALT bit is 1. - The write to the DHCSR that changes the C_MASKINTS bit also writes 1 to the C_HALT bit. This means that a single write to DHCSR cannot set the C_HALT to 0 and change the value of the C_MASKINTS bit. The bit does not affect NMI. When DHCSR.C_DEBUGEN is set to 0, the value of this bit is UNKNOWN. This bit is UNKNOWN after a Power-on reset. </description>
            </field>
            <field>
              <name>c_step</name>
              <bitRange>[2:2]</bitRange>
              <description>Processor step bit. The effects of writes to this bit are: - 0: No effect. - 1: Single step enabled. This bit is UNKNOWN after a Power-on reset. </description>
            </field>
            <field>
              <name>c_halt</name>
              <bitRange>[1:1]</bitRange>
              <description>Processor halt bit. The effects of writes to this bit are: - 0: Causes the processor to leave Debug state, if in Debug state. - 1: Halt the processor. This bit is UNKNOWN after a Power-on reset, and is 0 after a Local reset. </description>
            </field>
            <field>
              <name>c_debugen</name>
              <bitRange>[0:0]</bitRange>
              <description>Halting debug enable bit. If a debugger writes to DHCSR to change the value of this bit from 0 to 1, it must also write 0 to the C_MASKINTS bit, otherwise behavior is UNPREDICTABLE. This bit can only be written by the DAP, it ignores writes from software. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_scs_dcrsr': 0xE000EDF4-->
          <name>cm4_scs_dcrsr</name>
          <description>Debug core register selector register With the DCRDR, the DCRSR provides debug access to the ARM core registers, special-purpose registers, and   Floating-point extension registers. A write to DCRSR specifies the register to transfer,   whether the transfer is a read or a write, and starts the transfer. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000DF4</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0001007F</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:17]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>regwnr</name>
              <bitRange>[16:16]</bitRange>
              <description>Specifies the access type for the transfer: 0 : Read. 1 : Write. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[15:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>regsel</name>
              <bitRange>[6:0]</bitRange>
              <description>Specifies the ARM core register, special-purpose register, or Floating-point extension register, to transfer: {         | 0 - 12    ARM core registers R0-R12. 13    The current SP. See also values 17 (MSP) and 18 (PSP). 14    LR. 15    DebugReturnAddress. 16    xPSR. 17    Main stack pointer, MSP. 18    Process stack pointer, PSP. 20    Bits[31:24]: CONTROL, Bits[23:16]: FAULTMASK, Bits[15:8]: BASEPRI, Bits[7:0]: PRIMASK. In each field, the valid bits are packed with leading zeros. For example, FAULTMASK is always a single bit, DCRDR[16], and DCRDR[23:17] is 0. 33    Floating-point Status and Control Register, FPSCR. 64 - 95   FP registers S0-S31. } All other values are Reserved. If the processor does not implement the FP extension the REGSEL field is bits[4:0], and bits[6:5] are Reserved, SBZ. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_scs_dcrdr': 0xE000EDF8-->
          <name>cm4_scs_dcrdr</name>
          <description>Debug core register data register With the DCRSR, the DCRDR provides debug access to the ARM core registers,   special-purpose registers, and Floating-point extension registers. The DCRDR is the   data register for these accesses. Used on its own, the DCRDR provides a message passing resource between an   external debugger and a debug agent running on the processor. Note: The architecture does not define any handshaking mechanism for this use of DCRDR. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000DF8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>dbgtmp</name>
              <bitRange>[31:0]</bitRange>
              <description>Data temporary cache, for reading and writing the ARM core registers, special-purpose registers, and Floating-point extension registers. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_scs_demcr': 0xE000EDFC-->
          <name>cm4_scs_demcr</name>
          <description>Debug exception and monitor control register Manages vector catch behavior and DebugMonitor handling when debugging. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000DFC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x010F07F1</resetMask>
          <fields>
            <field>
              <name>bf_align3</name>
              <bitRange>[31:25]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>trcena</name>
              <bitRange>[24:24]</bitRange>
              <description>Global enable for all DWT and ITM features: - 0: DWT and ITM units disabled. - 1: DWT and ITM units enabled. If the DWT and ITM units are not implemented, this bit is UNK/SBZP. When TRCENA is set to 0: - DWT registers return UNKNOWN values on reads. Whether the processor ignores writes to the DWT unit is IMPLEMENTATION DEFINED. - ITM registers return UNKNOWN values on reads. Whether the processor ignores writes to the ITM unit is IMPLEMENTATION DEFINED. Setting this bit to 0 might not stop all events. To ensure all events are stopped, software must set all DWT and ITM feature enable bits to 0, and then set this bit to 0. </description>
            </field>
            <field>
              <name>bf_align2</name>
              <bitRange>[23:20]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>mon_req</name>
              <bitRange>[19:19]</bitRange>
              <description>DebugMonitor semaphore bit. The processor does not use this bit. The monitor software defines the meaning and use of this bit. </description>
            </field>
            <field>
              <name>mon_step</name>
              <bitRange>[18:18]</bitRange>
              <description>When MON_EN is set to 0, this feature is disabled and the processor ignores MON_STEP. When MON_EN is set to 1, the meaning of MON_STEP is: - 0: Do not step the processor. - 1: Step the processor. Setting this bit to 1 makes the step request pending. The effect of changing this bit at an execution priority that is lower than the priority of the DebugMonitor exception is UNPREDICTABLE. </description>
            </field>
            <field>
              <name>mon_pend</name>
              <bitRange>[17:17]</bitRange>
              <description>Sets or clears the pending state of the DebugMonitor exception: - 0: Clear the status of the DebugMonitor exception to not pending. - 1: Set the status of the DebugMonitor exception to pending. When the DebugMonitor exception is pending it becomes active subject to the exception priority rules. A debugger can use this bit to wakeup the monitor using the DAP. The effect of setting this bit to 1 is not affected by the value of the MON_EN bit. A debugger can set MON_PEND to 1, and force the processor to take a DebugMonitor exception, even when MON_EN is set to 0. </description>
            </field>
            <field>
              <name>mon_en</name>
              <bitRange>[16:16]</bitRange>
              <description>Enable the DebugMonitor exception. If DHCSR.C_DEBUGEN is set to 1, the processor ignores the value of this bit. </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[15:11]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>vc_harderr</name>
              <bitRange>[10:10]</bitRange>
              <description>Enable halting debug trap on a HardFault exception. If DHCSR.C_DEBUGEN is set to 0, the processor ignores the value of this bit. </description>
            </field>
            <field>
              <name>vc_interr</name>
              <bitRange>[9:9]</bitRange>
              <description>Enable halting debug trap on a fault occurring during exception entry or exception return. If DHCSR.C_DEBUGEN is set to 0, the processor ignores the value of this bit. </description>
            </field>
            <field>
              <name>vc_buserr</name>
              <bitRange>[8:8]</bitRange>
              <description>Enable halting debug trap on a BusFault exception. If DHCSR.C_DEBUGEN is set to 0, the processor ignores the value of this bit. </description>
            </field>
            <field>
              <name>vc_staterr</name>
              <bitRange>[7:7]</bitRange>
              <description>Enable halting debug trap on a UsageFault exception caused by a state information error, for example an Undefined Instruction exception. If DHCSR.C_DEBUGEN is set to 0, the processor ignores the value of this bit. </description>
            </field>
            <field>
              <name>vc_chkerr</name>
              <bitRange>[6:6]</bitRange>
              <description>Enable halting debug trap on a UsageFault exception caused by a checking error, for example an alignment check error. If DHCSR.C_DEBUGEN is set to 0, the processor ignores the value of this bit. </description>
            </field>
            <field>
              <name>vc_nocperr</name>
              <bitRange>[5:5]</bitRange>
              <description>Enable halting debug trap on a UsageFault caused by an access to a Coprocessor. If DHCSR.C_DEBUGEN is set to 0, the processor ignores the value of this bit. </description>
            </field>
            <field>
              <name>vc_mmerr</name>
              <bitRange>[4:4]</bitRange>
              <description>Enable halting debug trap on a MemManage exception. If DHCSR.C_DEBUGEN is set to 0, the processor ignores the value of this bit. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>vc_corereset</name>
              <bitRange>[0:0]</bitRange>
              <description>Enable Reset Vector Catch. This causes a Local reset to halt a running system. If DHCSR.C_DEBUGEN is set to 0, the processor ignores the value of this bit. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_scs_pidr4': 0xE000EFD0-->
          <name>cm4_scs_pidr4</name>
          <description>Peripheral ID Register 4 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000FD0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_scs_pidr0': 0xE000EFE0-->
          <name>cm4_scs_pidr0</name>
          <description>Peripheral ID Register 0 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000FE0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_scs_pidr1': 0xE000EFE4-->
          <name>cm4_scs_pidr1</name>
          <description>Peripheral ID Register 1 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000FE4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_scs_pidr2': 0xE000EFE8-->
          <name>cm4_scs_pidr2</name>
          <description>Peripheral ID Register 2 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000FE8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_scs_pidr3': 0xE000EFEC-->
          <name>cm4_scs_pidr3</name>
          <description>Peripheral ID Register 3 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000FEC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_scs_cidr0': 0xE000EFF0-->
          <name>cm4_scs_cidr0</name>
          <description>Component ID Register 0 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000FF0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>prmbl_0</name>
              <bitRange>[7:0]</bitRange>
              <description>Preamble byte 0. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_scs_cidr1': 0xE000EFF4-->
          <name>cm4_scs_cidr1</name>
          <description>Component ID Register 1 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000FF4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>cclass</name>
              <bitRange>[7:4]</bitRange>
              <description>Component class. </description>
            </field>
            <field>
              <name>prmbl_1</name>
              <bitRange>[3:0]</bitRange>
              <description>Preamble bits[11:8]. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_scs_cidr2': 0xE000EFF8-->
          <name>cm4_scs_cidr2</name>
          <description>Component ID Register 2 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000FF8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>prmbl_2</name>
              <bitRange>[7:0]</bitRange>
              <description>Preamble byte 2. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_scs_cidr3': 0xE000EFFC-->
          <name>cm4_scs_cidr3</name>
          <description>Component ID Register 3 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000FFC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>prmbl_3</name>
              <bitRange>[7:0]</bitRange>
              <description>Preamble byte 3. </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>cm4_misc_ctrl</name>
      <description>cm4_misc_ctrl</description>
      <baseAddress>0xE0043000</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>4096</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>fpu_arm_app</name>
        <value>77</value>
      </interrupt>
      <registers>
        <register>
          <!--Absolute address of 'cm4_misc_ctrl_cpu_info': 0xE0043000-->
          <name>cm4_misc_ctrl_cpu_info</name>
          <description>CPU information register Provides a processor identification mechanism to distinguish between Com ARM and App ARM. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:2]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>fpu</name>
              <bitRange>[1:1]</bitRange>
              <description>CPU has FPU If '0' all cm4_misc_ctrl_fpu_* registers have no effect and are read as zero. </description>
            </field>
            <field>
              <name>id</name>
              <bitRange>[0:0]</bitRange>
              <description>CPU identification 0: Com ARM 1: App ARM </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_misc_ctrl_fpu_irq_raw': 0xE0043004-->
          <name>cm4_misc_ctrl_fpu_irq_raw</name>
          <description>FPU raw IRQ Read access shows status of unmasked IRQs.   IRQs are set automatically and reset by writing to this register: Write access with '1' resets the appropriate IRQ. Write access with '0' does not influence this bit. Note: Before clearing an IRQ in this register, the corresponding exception status must be cleared within the FPU. Otherwise the IRQ will be re-asserted immediately. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000003F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>idc</name>
              <bitRange>[5:5]</bitRange>
              <description>Input denormal (ARM-specific exception). </description>
            </field>
            <field>
              <name>ioc</name>
              <bitRange>[4:4]</bitRange>
              <description>Invalid operation (IEEE 754-2008 defined exception). </description>
            </field>
            <field>
              <name>dzc</name>
              <bitRange>[3:3]</bitRange>
              <description>Division by zero (IEEE 754-2008 defined exception). </description>
            </field>
            <field>
              <name>ofc</name>
              <bitRange>[2:2]</bitRange>
              <description>Overflow (IEEE 754-2008 defined exception). </description>
            </field>
            <field>
              <name>ufc</name>
              <bitRange>[1:1]</bitRange>
              <description>Underflow (IEEE 754-2008 defined exception). </description>
            </field>
            <field>
              <name>ixc</name>
              <bitRange>[0:0]</bitRange>
              <description>Inexact (IEEE 754-2008 defined exception). </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_misc_ctrl_fpu_irq_masked': 0xE0043008-->
          <name>cm4_misc_ctrl_fpu_irq_masked</name>
          <description>FPU masked IRQ Shows status of masked IRQs. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000003F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>idc</name>
              <bitRange>[5:5]</bitRange>
              <description>Input denormal (ARM-specific exception). </description>
            </field>
            <field>
              <name>ioc</name>
              <bitRange>[4:4]</bitRange>
              <description>Invalid operation (IEEE 754-2008 defined exception). </description>
            </field>
            <field>
              <name>dzc</name>
              <bitRange>[3:3]</bitRange>
              <description>Division by zero (IEEE 754-2008 defined exception). </description>
            </field>
            <field>
              <name>ofc</name>
              <bitRange>[2:2]</bitRange>
              <description>Overflow (IEEE 754-2008 defined exception). </description>
            </field>
            <field>
              <name>ufc</name>
              <bitRange>[1:1]</bitRange>
              <description>Underflow (IEEE 754-2008 defined exception). </description>
            </field>
            <field>
              <name>ixc</name>
              <bitRange>[0:0]</bitRange>
              <description>Inexact (IEEE 754-2008 defined exception). </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_misc_ctrl_fpu_irq_msk_set': 0xE004300C-->
          <name>cm4_misc_ctrl_fpu_irq_msk_set</name>
          <description>FPU IRQ mask set The IRQ mask enables interrupt requests for corresponding interrupt sources.   As its bits might be changed by different software tasks,   the IRQ mask register is not writable directly, but by set and reset masks: Write access with '1' sets interrupt mask bit. Write access with '0' does not influence this bit. Read access shows actual interrupt mask. Attention: Before activating interrupt mask, delete old pending interrupts by writing the same value to cm4_misc_ctrl_fpu_irq_raw. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000003F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>idc</name>
              <bitRange>[5:5]</bitRange>
              <description>Input denormal (ARM-specific exception). </description>
            </field>
            <field>
              <name>ioc</name>
              <bitRange>[4:4]</bitRange>
              <description>Invalid operation (IEEE 754-2008 defined exception). </description>
            </field>
            <field>
              <name>dzc</name>
              <bitRange>[3:3]</bitRange>
              <description>Division by zero (IEEE 754-2008 defined exception). </description>
            </field>
            <field>
              <name>ofc</name>
              <bitRange>[2:2]</bitRange>
              <description>Overflow (IEEE 754-2008 defined exception). </description>
            </field>
            <field>
              <name>ufc</name>
              <bitRange>[1:1]</bitRange>
              <description>Underflow (IEEE 754-2008 defined exception). </description>
            </field>
            <field>
              <name>ixc</name>
              <bitRange>[0:0]</bitRange>
              <description>Inexact (IEEE 754-2008 defined exception). </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'cm4_misc_ctrl_fpu_irq_msk_reset': 0xE0043010-->
          <name>cm4_misc_ctrl_fpu_irq_msk_reset</name>
          <description>FPU IRQ mask reset This is the corresponding reset mask to disable interrupt requests for corresponding interrupt sources: Write access with '1' resets interrupt mask bit. Write access with '0' does not influence this bit. Read access shows actual interrupt mask. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000003F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>idc</name>
              <bitRange>[5:5]</bitRange>
              <description>Input denormal (ARM-specific exception). </description>
            </field>
            <field>
              <name>ioc</name>
              <bitRange>[4:4]</bitRange>
              <description>Invalid operation (IEEE 754-2008 defined exception). </description>
            </field>
            <field>
              <name>dzc</name>
              <bitRange>[3:3]</bitRange>
              <description>Division by zero (IEEE 754-2008 defined exception). </description>
            </field>
            <field>
              <name>ofc</name>
              <bitRange>[2:2]</bitRange>
              <description>Overflow (IEEE 754-2008 defined exception). </description>
            </field>
            <field>
              <name>ufc</name>
              <bitRange>[1:1]</bitRange>
              <description>Underflow (IEEE 754-2008 defined exception). </description>
            </field>
            <field>
              <name>ixc</name>
              <bitRange>[0:0]</bitRange>
              <description>Inexact (IEEE 754-2008 defined exception). </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>idpm_com</name>
      <description>idpm_com</description>
      <baseAddress>0xFF001B00</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>256</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>idpm_com_host</name>
        <value>31</value>
      </interrupt>
      <interrupt>
        <name>hs_com_host_hsc0</name>
        <value>32</value>
      </interrupt>
      <interrupt>
        <name>hs_com_host_hsc1</name>
        <value>33</value>
      </interrupt>
      <interrupt>
        <name>hs_com_host_hsc2</name>
        <value>34</value>
      </interrupt>
      <interrupt>
        <name>hs_com_host_hsc3</name>
        <value>35</value>
      </interrupt>
      <interrupt>
        <name>hs_com_host_hsc4</name>
        <value>36</value>
      </interrupt>
      <interrupt>
        <name>hs_com_host_hsc5</name>
        <value>37</value>
      </interrupt>
      <interrupt>
        <name>hs_com_host_hsc6</name>
        <value>38</value>
      </interrupt>
      <interrupt>
        <name>hs_com_host_hsc7</name>
        <value>39</value>
      </interrupt>
      <interrupt>
        <name>hs_com_host_hsc8to15</name>
        <value>40</value>
      </interrupt>
      <registers>
        <register>
          <!--Absolute address of 'idpm_cfg0x0': 0xFF001B00-->
          <name>idpm_cfg0x0</name>
          <description>DPM IO Control Register 0. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000031</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>endian</name>
              <bitRange>[5:4]</bitRange>
              <description>Endianess of 32 bit (DWord) address alignment (B0: least significant byte, B3: most significant byte): {      |                     |      |      |      | coding   Address               A+3    A+2    A+1    A+0 00     little endian         B3     B2     B1     B0 01     16 bit big endian     B2     B3     B0     B1 10     32 bit big endian     B0     B1     B2     B3 11     reserved                                        } Little endian is used netX inside. If big endian host device is used, set to this 01 or 10 according to host device data width. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>enable</name>
              <bitRange>[0:0]</bitRange>
              <description>Global IDPM enable bit. The IDPM module must be enabled by the INTLOGIC area before the host area (i.e. DPM mirrors of INTRAMHS) can be used. While disabled all host access (access to DPM mirrors of INTRAMHS) will be ignored. Read will return 0x0bad0bad. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'idpm_addr_cfg': 0xFF001B10-->
          <name>idpm_addr_cfg</name>
          <description>DPM External Address Configuration Register. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000030</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>cfg_win_addr_cfg</name>
              <bitRange>[5:4]</bitRange>
              <description>Location of the DPM Configuration Window (Window 0). Supported settings are: 00: Low Configuration Window: The Configuration Window is located in the first 256 bytes of external DPM address range (0x0 to 0xff). It is located before the first enabled Data Window (1 to 4). 01: High Configuration Window: The Configuration Window is located in the last 256 bytes of external DPM address range. Example: 'addr_range' is 8kB: Configuration Window is located in 0x1F00..0x1FFF. 10: reserved. 11: Configuration Window is disabled for external DPM access. Full DPM address range can be used for Windows 1 to 4. Note: The Configuration Window 0 has higher priority than normal DPM Window. The location of the Configuration Window does not depend on the Data Window configuration (the setting of the 'dpm_winX_end' or 'dpm_winX_map' registers). I.e. for setting '00' (low Configuration Window) the first enabled Data Window starts at address 0x100. For setting '01' (high Configuration Window) it would hide the last 256 bytes of the last enabled Data Window when this is configured to end on the last external address. The Configuration Window 0 has lower priority than Access Tunnel. I.e. the Access Tunnel could be laid over the configuration window. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'idpm_status': 0xFF001B1C-->
          <name>idpm_status</name>
          <description>DPM Status Register. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000001C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>unlocked</name>
              <bitRange>[0:0]</bitRange>
              <description>DPM is locked during netX power up and boot phase. DPM access to other addresses than DPM configuration window 0 cannot be done before this bit is set to 1. Write access to data windows (netX AHB area) will be ignored and read access will deliver invalid data while locked. Poll for 1 after power-up or reset. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'idpm_tunnel_cfg': 0xFF001B38-->
          <name>idpm_tunnel_cfg</name>
          <!--DPM Access Tunnel Configuration Register. -->
          <!--The DPM Access Tunnel (DATunnel) is a 64 byte (16DWord) address window which can be mapped on any 64 byte boundary of the external -->
          <!--visible address space. At the last DWord (offset 0x3C) of the DATunnel the Internal Target Base Address (ITBAddr) can be programmed. -->
          <!--This is the base address of the 64 byte tunnel target area inside the full 32-bit netX address range (however some address areas -->
          <!--could not be reachable as connections could be cut from the DPM inside the netX dataswitch, refer to the dataswitch documentation -->
          <!--of your netX). -->
          <!--By the DWords 0 to 14 of the tunnel the internal netX addresses starting at ITBAddr can be reached. The 'enable'-bit must be active -->
          <!--for this (read-only functionality can be configured by 'wp_data'-bit). -->
          <!--For access to netX data with ITBAddr DWord offset 15, the lower bits 5 to 2 of the programmed ITBAddr are interpreted as a mapping -->
          <!--value. This value will be added to the internal access address before tunneling (wrapping around at the 64 byte boundary). Hence it -->
          <!--is possible to access always 15 of the 16 netX DWord while the one hidden by the ITBAddr can be selected by an appropriate mapping -->
          <!--value. -->
          <!--The ITBAddr can also be programmed by the 'idpm_itbaddr' register of the configuration window 0 (or the INTLOGIC area). The ITBAddr on -->
          <!--tunnel offset 0x3C can be write-protected by the 'wp_itbaddr'-bit. This could be useful to protect the NETX from reconfiguring the -->
          <!--tunnel from the host side but provides the host the internal NETX destination address anyhow. However this only makes sense when -->
          <!--the configuration window 0 is disabled ('idpm_addr_cfg' register). Otherwise the host could reconfigure the tunnel by the 'idpm_itbaddr' -->
          <!--register. -->
          <!--Additionally the 'tunnel_all'-bit provides the possibility of tunneling all 16DWords to the NETX side. -->
          <!--To protect the NETX from reconfiguring the tunnel from the host side when the configuration window 0 is enabled, the 'wp_cfg_win' -->
          <!--can be activated. Then the tunnel configuration can only be changed from the NETX side (INTLOGIC area) but not from configuration -->
          <!--window 0 (in contrast to the 'wp_itbaddr'-bit which protects only offset 0x3C). -->
          <!-- -->
          <!--External to internal address mapping for DATunnel area can be calculated by following formula: -->
          <!--   INAAdr = (ITBAddr & 0xffffffc0) + ((EDAAdr + ITBAddr) & 0x3C) -->
          <!-- -->
          <!--With: -->
          <!--   INAAdr:  Internal netX Access Address -->
          <!--   ITBAddr: Internal netX 32-bit Tunnel Target Base Address -->
          <!--   EDAAdr:  External DPM Access Address -->
          <!-- -->
          <!--Condition for DATunnel access is: -->
          <!--   EDAAdr>>6 equals value of bit field 'base' from this register. -->
          <!-- -->
          <!--To map netX internal DWord N to invisible last external DWord (15), use mapping value -->
          <!--   map = (N - 15) & 0xf -->
          <!--on bits 5 to 2. -->
          <!--Internal to external address offset inside DATunnel area for internal DWord N can be calculated by following formula: -->
          <!--   External offset = (N*4 - map*4) & 0x3C = (N*4 - ITBAddr) & 0x3C -->
          <!-- -->
          <!--Example 1: -->
          <!--   Access to netX sys_time module by host via DATunnel on external DPM addresses are starting at 0x240. -->
          <!--   - Set bit field 'base' of this register to 9 (0x240>>6), set 'enable'-bit (and write protection depending on application). -->
          <!--     DATunnel now is enabled on external DPM addresses 0x240 to 0x27f. -->
          <!--   - ITBAddr of netX4000 sys_time module is 0xf409c180. -->
          <!--     For direct DATunnel to this address, host must write 0xf409c180 to external DPM address 0x27c. This -->
          <!--     can be done e.g. by four byte accesses to 0x27c, 0x27d, 0x27e and 0x27f or by two 16-bit accesses to 0x27c and 0x27e. -->
          <!--     Now sys_time module registers 0 to 14 can be accessed on external DPM address 0x240 to 0x27b. -->
          <!-- -->
          <!--Example 2: -->
          <!--   Register 15 of sys_time is hidden by ITBAddr configuration on 0x27c in example 1 but must also be accessed. However, sys_time -->
          <!--   Register 6 is never kind of interest. -->
          <!--   - Configure this register like described in example 1. -->
          <!--   - To map Register 6 (Module offset 6*4) to external offset 0x3C (hidden data on DWord 15), -->
          <!--     the following rule must be complied: -->
          <!--        0x3C + map*4 = 6*4. -->
          <!--     That leads to a mapping value of: -->
          <!--        map*4 = (6*4 - 0x3C) & 0x3C = 1C -->
          <!--     Hence, write 0x101c101C to DATunnel DWord 15 (external DPM address 0x27c) to map sys_time Register 6 to -->
          <!--     hidden DWord 15. -->
          <!--     INAAdr now will be derived from EDAAdr before tunneling as follows: -->
          <!--        INAAdr = 0xf409c180 + ((EDAAdr + 0x1C) & 0x3C) -->
          <!--     External offset of Module DWord N results from: -->
          <!--        External offset = (N*4 - 0x1C) & 0x3C -->
          <!--     Register 15 of sys_time unit now can be accessed by external DPM address 0x240+((0xf*4-0x1C) & 0x3C) = 0x260 (i.e. Tunnel DWord 8). -->
          <!--     Register 0  of sys_time unit now can be accessed by external DPM address 0x240+((0x0*4-0x1C) & 0x3C) = 0x264 (i.e. Tunnel DWord 9). -->
          <!--     Register 1  of sys_time unit now can be accessed by external DPM address 0x240+((0x1*4-0x1C) & 0x3C) = 0x268 (i.e. Tunnel DWord 10). -->
          <!--     and so on. -->
          <!--     Register 6  of sys_time unit can not be accessed as it is hidden by ITBAddr configuration on 0x27c (i.e. Tunnel DWord 15). -->
          <!--     Register 7  of sys_time unit now can be accessed by external DPM address 0x240+((0x7*4-0x1C) & 0x3C) = 0x240 (i.e. Tunnel DWord 0). -->
          <!-- -->
          <!--Note: -->
          <!--  The IDPM tunnel is capable to target the INTRAMHS-memory associated to the IDPM and additionally the INTLOGIC_SYS -->
          <!--  area (addresses 0xf4080000 to 0xf80fffff, e.g. for SYSTIME). Other address areas can not be reached even when ITBAddr -->
          <!--  is configured for it. Write access to non-reachable addresses will be ignored, read access will deliver invalid data. -->
          <!-- -->
          <!--Attention: -->
          <!--  The IDPM tunnel could bypass the AHB firewalls. Example: -->
          <!--  The INTLOGIC_SYS firewall is configured to deny CA9 accesses while the CA9 is permitted for the INTRAMHS0 firewall. However, when -->
          <!--  the tunnel is programmed to target the INTLOGIC_SYS area the CA9 can reach it as the initial access (before tunnel remapping) is -->
          <!--  handled by the INTRAMHS0 firewall and not by the INTLOGIC_SYS firewall. To avoid abuse the 'tunnel_all' or the 'wp_itbaddr' bit -->
          <!--  and the 'wp_cfg_win' must be enabled. Then the tunnel e.g. can be used to access the SYSTIME registers but it cannot be reconfigured -->
          <!--  by the CA9 for abuse to other addresses. -->
          <!-- -->
          <!--Note: -->
          <!--  Configuration Window 0 access detection has higher priority than normal DPM Window -->
          <!--  detection but lower priority than Access Tunnel access detection. -->
          <!-- -->
          <!-- -->
          <description>description too long, please enter short description.</description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000038</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000101</resetValue>
          <resetMask>0x80007FCF</resetMask>
          <fields>
            <field>
              <name>wp_cfg_win</name>
              <bitRange>[31:31]</bitRange>
              <description>Write-protect tunnel configuration inside the configuration window 0. 0: The two tunnel configuration registers ('idpm_tunnel_cfg' and 'idpm_itbaddr') can be programmed via configuration window 0 and the INTLOGIC_SYS-IDPM address area. 1: The tunnel configuration registers ('idpm_tunnel_cfg' and 'idpm_itbaddr') cannot be programmed by the host via configuration window 0 (they are read-only for the host there). They can only be programmed via the INTLOGIC_SYS-IDPM address area. Note: Set this bit to protect the NETX from reconfiguring the tunnel by the host when configuration window 0 is activated for the host (e.g. for IRQ handling). </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[30:15]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>base</name>
              <bitRange>[14:6]</bitRange>
              <description>DPM Access Tunnel (DATunnel) Base Address divided by 64 on external visible address space. Note: Default setting for tunnel base is starting on external address 0x100. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[5:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>tunnel_all</name>
              <bitRange>[3:3]</bitRange>
              <description>Enable/disable the ITBAddr configuration register at tunnel offset 0x3C. 0: Only 15 DWords are tunneled to the internal tunnel target. The idpm_itbaddr is available at offset 0x3C. One DWord of the tunnel target area is hidden by idpm_itbaddr. 1: All 16 DWords are tunneled to the internal tunnel target. The idpm_itbaddr is not available at offset 0x3C. All 64 tunnel target bytes can be reached (no hidden register). Note: Target mapping (base and map) will not be affected by this bit. Using a 'map' value not equal 0 will always rotate the tunnel target addresses. </description>
            </field>
            <field>
              <name>enable</name>
              <bitRange>[2:2]</bitRange>
              <description>Enable/disable Access Tunnel function. </description>
            </field>
            <field>
              <name>wp_itbaddr</name>
              <bitRange>[1:1]</bitRange>
              <description>ITBAddr is write-protected from host. 0: The ITBAddr is mirrored to offset 0x3C of the tunnel and can also be programmed there. 1: ITBAddr (Internal netX 32 bit Tunnel Target Base Address) is read-only for tunnel offset 0x3C. It can only be changed via configuration window 0 idpm_itbaddr address or the INTLOGIC IDPM area. </description>
            </field>
            <field>
              <name>wp_data</name>
              <bitRange>[0:0]</bitRange>
              <description>Access Tunnel function is write-protected for data access (DWords 0 to 14 (15 for 'tunnel_all') of DATunnel). 0: Write access is forwarded through the tunnel. 1: Write access to DWords 0 to 14 (15 for 'tunnel_all') of DATunnel will be ignored. Data write protection for host is enabled by default and can be disabled by clearing this bit. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'idpm_itbaddr': 0xFF001B3C-->
          <name>idpm_itbaddr</name>
          <description>DPM Access Tunnel (DATunnel) netX Internal Target Base Address (ITBAddr) Configuration Register. For DPM Access Tunnel (DATunnel) function view description of dpm_tunnel_cfg register. This register contains ITBAddr value that can also be changed by host on last offset 0x3c (last DWord) of external DATunnel area (defined by bit field 'base' in 'dpm_tunnel_cfg' register). However this register can also be write-protected from host if bit 'wp_itbaddr' in 'dpm_tunnel_cfg' register is set. Write protection bits of DATunnel configured in 'dpm_tunnel_cfg' register can also be read from this register. Host can read access rights from these bits on last DWord of external DATunnel address area.  Note: This register can be write-protected by the 'wp_cfg_win' and the 'wp_itbaddr'-bit of the 'idpm_tunnel_cfg' register.  </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000003C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>base</name>
              <bitRange>[31:6]</bitRange>
              <description>Internal netX Tunnel Target Base Address (ITBAddr) divided by 64. View description of dpm_tunnel_cfg register. </description>
            </field>
            <field>
              <name>map</name>
              <bitRange>[5:2]</bitRange>
              <description>Mapping part of ITBAddr. View description of dpm_tunnel_cfg register. </description>
            </field>
            <field>
              <name>wp_itbaddr_ro</name>
              <bitRange>[1:1]</bitRange>
              <description>ITBAddr is write-protected from host. This is a read-only bit here. Its setting can be changed in 'dpm_tunnel_cfg' register. View description of dpm_tunnel_cfg register. </description>
            </field>
            <field>
              <name>wp_data_ro</name>
              <bitRange>[0:0]</bitRange>
              <description>Access Tunnel function is write-protected from data access (DWords 0 to 14 of DATunnel). This is a read-only bit here. Its setting can be changed in 'dpm_tunnel_cfg' register. View description of dpm_tunnel_cfg register. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'idpm_win1_end': 0xFF001B40-->
          <name>idpm_win1_end</name>
          <description>DPM Window 1 End Address Configuration Register. Smallest DPM window configuration unit is 128 bytes (i.e. lowest 7 bits of address configuration are always 0). At address 0x0 DPM configuration window is mapped after reset (length: 256 bytes, containing all DPM addresses defined here). Each window starts at window end address of the preceding window. Hence external window 1 start address is 0x100, window 2 starts at value programmed in this register and so on.  Note:   This register can be write-protected by the 'wp_cfg_win'-bit of the 'idpm_win1_map' register.  Note:   Configuration Window 0 access detection has higher priority than normal DPM Window   detection but lower priority than Access Tunnel access detection.  </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000040</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FF80</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>win_end</name>
              <bitRange>[15:7]</bitRange>
              <description>Window 1 End Address divided by 128. Last external address is win_end*128-1. Setting win_end to 0 will disable this window. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[6:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'idpm_win1_map': 0xFF001B44-->
          <name>idpm_win1_map</name>
          <description>DPM Window 1 Address Map Configuration Register. Smallest DPM window configuration unit is 128 bytes (i.e. lowest 7 bits of address configuration are always 0). For further information view description of 'dpm_win1_end' register.  </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000044</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00007FAC</resetMask>
          <fields>
            <field>
              <name>bf_align3</name>
              <bitRange>[31:15]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>win_map</name>
              <bitRange>[14:7]</bitRange>
              <description>Window 1 Address Mapping. Internal access address HADDR to netX logic is combined by DPM interface by: HADDR[31:16]: unchanged, as it comes form accessing master HADDR[15:0]:  mapped DPM address. This part of address is defined by programmed win_map value for each window. The value to be programmed is address bits 15 to 0 of netX internal window start address minus start address of the external window (i.e. end address of preceding window) . Example: Window n starts at 0x400 of external DPM address range (i.e. programmed win_end value of window (n-1) and targets netX address 0x05218000. For address calculation only lower 16 bits of netX address are relevant, i.e. 0x8000. The complete 16 bit address map value is then:0x8000-0x400=0x7C00. Hence the programmed 9 bit value must be 0x7C00&gt;&gt;7=0xf8. </description>
            </field>
            <field>
              <name>bf_align2</name>
              <bitRange>[6:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>wp_cfg_win</name>
              <bitRange>[5:5]</bitRange>
              <description>Write-protect window configuration inside the configuration window 0. 0: All 8 window configuration registers ('dpm_winX_and' and 'dpm_winX_map') can be programmed via configuration window 0 and the INTLOGIC-DPM address area. 1: All 8 window configuration registers ('dpm_winX_and' and 'dpm_winX_map') cannot be programmed by the host via configuration window 0 (they are read-only for the host there). They can only be programmed via the INTLOGIC-DPM address area. Note: Set this bit to protect the NETX from reconfiguring the window mapping by the host when configuration window 0 is activated for the host (e.g. for IRQ handling). Note: To protect the netX completely from host-access to not permitted address areas it must be ensured that also the remapping of the DPM tunne cannot be changed by the host (refer to register 'dpm_tunnel_cfg'). Note: This bit does only exist in the 'dpm_win1_map'-register but not in the registers for the higher windows. However this bit protect all DPM 'dpm_winX_and' and 'dpm_winX_map'-registers from being written via configuration window 0. Note: The 'wp_cfg_win'-bit is a new feature since netX4000 and netX6. </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[4:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>win_map_alt</name>
              <bitRange>[3:2]</bitRange>
              <description>Window 1 Alternative Address Mapping Configuration. Alternative Address Mapping can be generated by Triple Buffer Managers inside HANDSHAKE_CTRL unit. Coding: 00 : Alternative Address Mapping disabled. 01 : Alternative Address Mapping enabled: Use Triple Buffer Manager 0 from HANDSHAKE_CTRL unit. 10 : Alternative Address Mapping enabled: Use Triple Buffer Manager 1 from HANDSHAKE_CTRL unit. 11 : reserved If Alternative Address Mapping is enabled, mapping value is taken according to buffer status of related HANDSHAKE_CTRL Triple Buffer Manager as follows. {                    | buffer status        used mapping value 00 (buffer 0)        win_map entry of this register 01 (buffer 1)        Alternative win_map value 1 of related HANDSHAKE_CTRL Triple Buffer Manager. 10 (buffer 2)        Alternative win_map value 2 of related HANDSHAKE_CTRL Triple Buffer Manager. 11 (invalid buffer)  win_map entry of this register } Note: Alternative Triple Buffer Manager win_map values can be programmed in HANDSHAKE_CTRL address area. Note: For netX4000 there are 2 IDPM and 2 HANDSHAKE_CTRL units. IDPM0 is always associated with HANDSHAKE_CTRL0 while IDPM1 is always associated with HANDSHAKE_CTRL1. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[1:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'idpm_win2_end': 0xFF001B48-->
          <name>idpm_win2_end</name>
          <description>DPM Window 2 End Address Configuration Register. For detailed information refer to 'idpm_win1_end' register description.  Note:   This register can be write-protected by the 'wp_cfg_win'-bit of the 'idpm_win1_map' register.  </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000048</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FF80</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>win_end</name>
              <bitRange>[15:7]</bitRange>
              <description>Window 2 End Address divided by 128. Last external address is win_end*128-1. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[6:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'idpm_win2_map': 0xFF001B4C-->
          <name>idpm_win2_map</name>
          <description>DPM Window 2 Address Map Configuration Register. For detailed information refer to 'dpm_win1_map' register description.  Note:   This register can be write-protected by the 'wp_cfg_win'-bit of the 'idpm_win1_map' register.  </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000004C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00007F8C</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:15]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>win_map</name>
              <bitRange>[14:7]</bitRange>
              <description>Window address mapping. </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[6:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>win_map_alt</name>
              <bitRange>[3:2]</bitRange>
              <description>Window Alternative Address Mapping Configuration. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[1:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'idpm_win3_end': 0xFF001B50-->
          <name>idpm_win3_end</name>
          <description>DPM Window 3 End Address Configuration Register. For detailed information refer to 'idpm_win1_end' register description.  Note:   This register can be write-protected by the 'wp_cfg_win'-bit of the 'idpm_win1_map' register.  </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000050</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FF80</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>win_end</name>
              <bitRange>[15:7]</bitRange>
              <description>Window 3 End Address divided by 128. Last external address is win_end*128-1. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[6:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'idpm_win3_map': 0xFF001B54-->
          <name>idpm_win3_map</name>
          <description>DPM Window 3 Address Map Configuration Register. For detailed information refer to 'dpm_win1_map' register description.  Note:   This register can be write-protected by the 'wp_cfg_win'-bit of the 'idpm_win1_map' register.  </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000054</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00007F8C</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:15]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>win_map</name>
              <bitRange>[14:7]</bitRange>
              <description>Window map address. </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[6:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>win_map_alt</name>
              <bitRange>[3:2]</bitRange>
              <description>Window Alternative Address Mapping Configuration. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[1:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'idpm_win4_end': 0xFF001B58-->
          <name>idpm_win4_end</name>
          <description>DPM Window 4 End Address Configuration Register. For detailed information refer to 'idpm_win1_end' register description.  Note:   This register can be write-protected by the 'wp_cfg_win'-bit of the 'idpm_win1_map' register.  </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000058</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FF80</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>win_end</name>
              <bitRange>[15:7]</bitRange>
              <description>Window 4 End Address divided by 128. Last external address is win_end*128-1. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[6:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'idpm_win4_map': 0xFF001B5C-->
          <name>idpm_win4_map</name>
          <description>DPM Window 4 Address Map Configuration Register. For detailed information refer to 'dpm_win1_map' register description.  Note:   This register can be write-protected by the 'wp_cfg_win'-bit of the 'idpm_win1_map' register.  </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000005C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00007F8C</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:15]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>win_map</name>
              <bitRange>[14:7]</bitRange>
              <description>Window map address. </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[6:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>win_map_alt</name>
              <bitRange>[3:2]</bitRange>
              <description>Window Alternative Address Mapping Configuration. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[1:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'idpm_irq_raw': 0xFF001B80-->
          <name>idpm_irq_raw</name>
          <description>DPM Raw (before masking) IRQ Status Register. If a bit is set, the related interrupt is asserted. Interrupts must be reset in interrupt generating module. Interrupts cannot be cleared here.  Important: There are two completely independent sets of IRQ registers:    IRQ register-set 1: 'dpm_irq_raw' (and related registers e.g. 'dpm_irq_irq_*' registers).    IRQ register-set 2: 'dpm_firmware_irq_* registers' (netx50 compatible register set: DPM_HOST_INT_EN0,2 DPM_HOST_INT_STA0,2).    Programming (masking or clearing IRQs) of one register-set has no impact to the other register-set even if some IRQs    can be found in both sets (e.g. com0).  Note:    The 'dpm_sw' IRQ can be controlled by the 'dpm_sw_irq' register.    for each IRQ target. The 'dpm_sw' will be set inside the 'dpm_irq_raw' register    when the 'dpm_sw' is activated for at least one IRQ target. But each IRQ target    obtains only the 'dpm_sw' IRQ state programmed for this target inside the 'dpm_sw_irq'    register. For an example view description of 'dpm_sw_irq' register.  Note:     The 'firmware' IRQ can be used to flag handshake and netX firmware system status events to the     host. Firmware IRQ generation can be controlled by dpm_firmware_irq_mask register. Detailed     firmware IRQ status can be read from dpm_firmware_irq_raw register.  </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000080</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000005</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:3]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>firmware</name>
              <bitRange>[2:2]</bitRange>
              <description>raw combined handshake-cell and SYS_STA firmware interrupt </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[1:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>dpm_sw</name>
              <bitRange>[0:0]</bitRange>
              <description>raw software IRQ for IRQ targets interrupt </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'idpm_irq_host_mask_set': 0xFF001B84-->
          <name>idpm_irq_host_mask_set</name>
          <description>DPM Interrupt Mask Register for IDPM host interrupt. Write access with '1' sets related interrupt mask bits (enables interrupt request for corresponding interrupt source). Write access with '0' does not influence related interrupt mask bit. Read access shows actual interrupt mask. If a mask bit is set, the related interrupt will activate the IRQ for IDPM host interrupt. Interrupts must be reset in interrupt generating module. Interrupts cannot be cleared here. To release IRQ for IDPM host interrupt without clearing interrupt in module, reset related mask bit to 0.  Note:    For further information view description of 'dpm_irq_raw' register.  </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000084</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000005</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:3]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>firmware</name>
              <bitRange>[2:2]</bitRange>
              <description>set combined handshake-cell and SYS_STA firmware interrupt mask for IDPM host interrupt </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[1:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>dpm_sw</name>
              <bitRange>[0:0]</bitRange>
              <description>set software IRQ for IRQ targets interrupt mask for IDPM host interrupt </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'idpm_irq_host_mask_reset': 0xFF001B88-->
          <name>idpm_irq_host_mask_reset</name>
          <description>DPM Interrupt Mask Reset Register for IDPM host interrupt. Write access with '1' resets related interrupt mask bits (disables interrupt request for corresponding interrupt source). Write access with '0' does not influence related interrupt mask bit. Read access shows actual interrupt mask. If a mask bit is set, the related interrupt will activate the IRQ for IDPM host interrupt. Interrupts must be reset in interrupt generating module. Interrupts cannot be cleared here. To release IRQ for IDPM host interrupt without clearing interrupt in module, reset related mask bit to 0.  Note:    For further information view description of 'dpm_irq_raw' register.  </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000088</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000005</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:3]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>firmware</name>
              <bitRange>[2:2]</bitRange>
              <description>reset combined handshake-cell and SYS_STA firmware interrupt mask for IDPM host interrupt </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[1:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>dpm_sw</name>
              <bitRange>[0:0]</bitRange>
              <description>reset software IRQ for IRQ targets interrupt mask for IDPM host interrupt </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'idpm_irq_host_masked': 0xFF001B8C-->
          <name>idpm_irq_host_masked</name>
          <description>DPM Masked Interrupt Status Register for IDPM host interrupt. A bit is set, when the related mask bit is set in 'dpm_irq_host_mask'-register and the related interrupt is asserted. IRQ for IDPM host interrupt is asserted if at least one bit is set here. Interrupts must be reset in interrupt generating module. Interrupts cannot be cleared here. To release IRQ for IDPM host interrupt without clearing interrupt in module, reset related mask bit to 0.  Note:    For further information view description of 'dpm_irq_raw' register.  </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000008C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000005</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:3]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>firmware</name>
              <bitRange>[2:2]</bitRange>
              <description>masked combined handshake-cell and SYS_STA firmware interrupt state for IDPM host interrupt </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[1:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>dpm_sw</name>
              <bitRange>[0:0]</bitRange>
              <description>masked software IRQ for IRQ targets interrupt state for IDPM host interrupt </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'idpm_sw_irq': 0xFF001BC0-->
          <name>idpm_sw_irq</name>
          <description>DPM Register for Software Interrupt Generation to Host and netX Interrupt Targets. Host and netX masters can generate an interrupt to netX interrupt targets (e.g. ARM-VIC) by this register. To propagate interrupt states from this register to the interrupt target the 'idpm_sw' IRQ must be enabled inside the appropriate interrupt controller (e.g. the ARM-VIC).  Note:    There is a set and a reset bit for the sw-IRQ to avoid read-modify-write sequences.    When both (set and reset) bits are set at the same time, the interrupt will be set (set will win).    The reset-bit is always 0 for read. The set-bit shows the current interrupt status when read. Note:    This register is a new netx51/52 feature.. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000C0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000101</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:9]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>reset_host</name>
              <bitRange>[8:8]</bitRange>
              <description>Reset 'dpm_sw' IRQ for host (always 0 when read) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[7:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>set_host</name>
              <bitRange>[0:0]</bitRange>
              <description>Set 'dpm_sw' IRQ for host (current 'dpm_sw' status for host when read) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'idpm_sys_sta': 0xFF001BD8-->
          <name>idpm_sys_sta</name>
          <description>DPM System Status Information Register. This register can be used for firmware status information.  Note:    This register is NOT fully compatible to netx50 DPM_HOST_SYS_STAT register:    Only the HOST_STATE-bits of DPM0 can be read from the 'netx_status'-register inside ASIC_CTRL address area.    The HOST_STATE-bits of DPM1 and IDPM can not be read from the 'netx_status'-register inside    ASIC_CTRL address area.  </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000D8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>NETX_STA_CODE_ro</name>
              <bitRange>[15:8]</bitRange>
              <description>Bit field for Hilscher firmware compatibility (read only). Note: This bit field can be changed by 'netx_status'-register inside ASIC_CTRL address area. </description>
            </field>
            <field>
              <name>HOST_STATE</name>
              <bitRange>[7:4]</bitRange>
              <description>Bit field for Hilscher firmware. Note: This bit field can NOT be read from 'netx_status'-register inside ASIC_CTRL address area. </description>
            </field>
            <field>
              <name>NETX_STATE_ro</name>
              <bitRange>[3:2]</bitRange>
              <description>Bit field for Hilscher firmware compatibility. Note: This bit field can be changed by 'netx_status'-register inside ASIC_CTRL address area. </description>
            </field>
            <field>
              <name>RUN_ro</name>
              <bitRange>[1:1]</bitRange>
              <description>Output state of netX RUN LED IO. Note: This bit field can be changed by 'rdy_run_cfg'-register inside ASIC_CTRL address area. </description>
            </field>
            <field>
              <name>RDY_ro</name>
              <bitRange>[0:0]</bitRange>
              <description>Output state of netX RDY LED IO. Note: This bit field can be changed by 'rdy_run_cfg'-register inside ASIC_CTRL address area. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'idpm_reset_request': 0xFF001BDC-->
          <name>idpm_reset_request</name>
          <description>DPM Reset Request Register.  Note: This register is compatible to netx50 DPM_HOST_RESET_REQ register  </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000DC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>reset_key</name>
              <bitRange>[7:0]</bitRange>
              <description>Reset key sequence register. A netx hardware reset is generated if the following sequence is written to this register: 1st access:    write 0x00 2nd access:    write 0x01 3rd access:    write 0x03 4th access:    write 0x07 5th access:    write 0x0f 6th access:    write 0x1f 7th access:    write 0x3f 8th access:    write 0x7f To issue a reset the sequence must not be interrupted by a write access to another register of this DPM module register area. Writing 0x00 will always restart the sequence. Reading this register will always provide the next write data. Hence it is also possible performing 8 times a read-write sequence to this register (however this is not required, simply writing the sequence will also succeed). Writing any other value than the next expected by the DPM module, the internal reset FSM will be cleared and the register will return 0x00 for the next read. The FSM will also be cleared if the sequence is interrupted by a write access to any other register of this DPM register area. The sequence must be restarted with the 1st access (writing 0x00) in this case. Note: The DPM reset request is internally a level-signal, not only a pulse. Additionally the DPM reset request could be masked (disabled) by the global reset controller (netX4000). If the DPM reset request is disabled globally but issued by the DPM module there are two possibilities to get out of this: 1.: Enable the DPM reset in the global reset controller. The NETX will be reset then immediately (typically this must be done by the NETX-side CPU and cannot be done by a host). 2.: Write 0x00 (or any other value except 0xFF) to this register or perform a write access to any other register of this DPM register area. This will clear the DPM reset FSM and the reset request of this DPM module to the global reset controller. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'idpm_firmware_irq_raw': 0xFF001BE0-->
          <name>idpm_firmware_irq_raw</name>
          <description>1st netx50 compatible DPM Interrupt Status Register (related to 'dpm_firmware_irq_mask'-register). Writing a '1' to an IRQ flag will clear the Interrupt. This is always done even if related bit inside 'dpm_firmware_irq_mask'-register is not set (this is compatible to netx50).  Important:    There are two completely independent sets of IRQ registers:    IRQ register-set 1: 'dpm_irq_raw' (and related registers e.g. 'dpm_irq_irq_*' registers).    IRQ register-set 2: 'dpm_firmware_irq_* registers' (netx50 compatible register set: DPM_HOST_INT_EN0,2 DPM_HOST_INT_STA0,2).    Programming (masking or clearing IRQs) of one register-set has no impact to the other register-set even if some IRQs    can be found in both sets (e.g. com0).  Note:    This register is compatible to netx50 DPM_HOST_INT_STAT0 register, however some unused    IRQs have been removed.  Note:    For netX4000 there are 2 IDPM and 2 HANDSHAKE_CTRL units. IDPM0 is always associated with HANDSHAKE_CTRL0    while IDPM1 is always associated with HANDSHAKE_CTRL1.  Note:    The 2nd firmware IRQ register set (dpm_firmware_irq_mask2, DPM_HOST_INT_EN2, dpm_firmware_irq_raw2, DPM_HOST_INT_STAT2)    are obsolete since netx4000. Some functions moved to the main DPM IRQ register set (view dpm_irq_raw).  </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000E0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xF6FFFFFF</resetMask>
          <fields>
            <field>
              <name>INT_REQ</name>
              <bitRange>[31:31]</bitRange>
              <description>Interrupt Request for IRQs handled in this register. 0: No Interrupts to host requested by IRQ sources handled in this register. 1: IRQ sources handled in this register request a host IRQ. Note: This bit is masked by INT_EN-bit in dpm_firmware_irq_mask register. For propagation of INT_REQ to host, ARM or xPIC, INT_EN-bit must be set and firmware IRQ must be activated in related dpm_irq_* register. </description>
            </field>
            <field>
              <name>res_MEM_LCK_ro</name>
              <bitRange>[30:30]</bitRange>
              <description>reserved for Memory Lock IRQ flag (not available in this netX version). </description>
            </field>
            <field>
              <name>res_WDG_NETX_ro</name>
              <bitRange>[29:29]</bitRange>
              <description>reserved for netX supervision Watchdog Timeout IRQ flag (not available in this netX version). </description>
            </field>
            <field>
              <name>res_RDY_TIMEOUT_ro</name>
              <bitRange>[28:28]</bitRange>
              <description>reserved, DPM_RDY timeout error does not exist for IDPM. </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[27:27]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>SYS_STA</name>
              <bitRange>[26:26]</bitRange>
              <description>System Status Change IRQ flag. </description>
            </field>
            <field>
              <name>res_TMR_ro</name>
              <bitRange>[25:25]</bitRange>
              <description>reserved for Timer IRQ flag (not available in this netX version). </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[24:24]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>IRQ_VECTOR</name>
              <bitRange>[23:16]</bitRange>
              <description>Interrupt Vector according to status flags generated by enabled IRQ sources. {     | Code   IRQ status 0x00   No IRQ. ----   ------- 0x10   Handshake Cell 0 IRQ. 0x11   Handshake Cell 1 IRQ. 0x12   Handshake Cell 2 IRQ. 0x13   Handshake Cell 3 IRQ. 0x14   Handshake Cell 4 IRQ. 0x15   Handshake Cell 5 IRQ. 0x16   Handshake Cell 6 IRQ. 0x17   Handshake Cell 7 IRQ. 0x18   Handshake Cell 8 IRQ. 0x19   Handshake Cell 9 IRQ. 0x1a   Handshake Cell 10 IRQ. 0x1b   Handshake Cell 11 IRQ. 0x1c   Handshake Cell 12 IRQ. 0x1d   Handshake Cell 13 IRQ. 0x1e   Handshake Cell 14 IRQ. 0x1f   Handshake Cell 15 IRQ. ----   ------- 0x70   SYS_STA IRQ Other  values are reserved.} Note: The current IRQ state in VECTOR depends only on the single IRQ enable bits. It does not depend on global IRQ enable INT_EN. VECTOR shows always the highest priority enabled flagged IRQ even is INT_EN is '0'. </description>
            </field>
            <field>
              <name>HS_EVENT15</name>
              <bitRange>[15:15]</bitRange>
              <description>Handshake Event 15 IRQ status flag. </description>
            </field>
            <field>
              <name>HS_EVENT14</name>
              <bitRange>[14:14]</bitRange>
              <description>Handshake Event 14 IRQ status flag. </description>
            </field>
            <field>
              <name>HS_EVENT13</name>
              <bitRange>[13:13]</bitRange>
              <description>Handshake Event 13 IRQ status flag. </description>
            </field>
            <field>
              <name>HS_EVENT12</name>
              <bitRange>[12:12]</bitRange>
              <description>Handshake Event 12 IRQ status flag. </description>
            </field>
            <field>
              <name>HS_EVENT11</name>
              <bitRange>[11:11]</bitRange>
              <description>Handshake Event 11 IRQ status flag. </description>
            </field>
            <field>
              <name>HS_EVENT10</name>
              <bitRange>[10:10]</bitRange>
              <description>Handshake Event 10 IRQ status flag. </description>
            </field>
            <field>
              <name>HS_EVENT9</name>
              <bitRange>[9:9]</bitRange>
              <description>Handshake Event 9  IRQ status flag. </description>
            </field>
            <field>
              <name>HS_EVENT8</name>
              <bitRange>[8:8]</bitRange>
              <description>Handshake Event 8  IRQ status flag. </description>
            </field>
            <field>
              <name>HS_EVENT7</name>
              <bitRange>[7:7]</bitRange>
              <description>Handshake Event 7  IRQ status flag. </description>
            </field>
            <field>
              <name>HS_EVENT6</name>
              <bitRange>[6:6]</bitRange>
              <description>Handshake Event 6  IRQ status flag. </description>
            </field>
            <field>
              <name>HS_EVENT5</name>
              <bitRange>[5:5]</bitRange>
              <description>Handshake Event 5  IRQ status flag. </description>
            </field>
            <field>
              <name>HS_EVENT4</name>
              <bitRange>[4:4]</bitRange>
              <description>Handshake Event 4  IRQ status flag. </description>
            </field>
            <field>
              <name>HS_EVENT3</name>
              <bitRange>[3:3]</bitRange>
              <description>Handshake Event 3  IRQ status flag. </description>
            </field>
            <field>
              <name>HS_EVENT2</name>
              <bitRange>[2:2]</bitRange>
              <description>Handshake Event 2  IRQ status flag. </description>
            </field>
            <field>
              <name>HS_EVENT1</name>
              <bitRange>[1:1]</bitRange>
              <description>Handshake Event 1  IRQ status flag. </description>
            </field>
            <field>
              <name>HS_EVENT0</name>
              <bitRange>[0:0]</bitRange>
              <description>Handshake Event 0  IRQ status flag. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'idpm_firmware_irq_mask': 0xFF001BF0-->
          <name>idpm_firmware_irq_mask</name>
          <description>DPM Handshake Interrupt Enable Register. Only netx50 compatible 'dpm_firmware_irq' registers are related to settings of this register.  Note: This register is compatible to netx50 DPM_HOST_INT_EN0 register, however some unused    IRQs have been removed.  Note: HS_EVENT-bits are not read-only. This is netX50 compliant.    Recent netX50 Documentation marks HS_EVENT-bits as read-only. This is an dokumentation error.    For netX50 compatibility, these bits can also be controlled from netX-side in HANDSHAKE_CTRL address area.  Note: The 2nd firmware IRQ register set (dpm_firmware_irq_mask2, DPM_HOST_INT_EN2, dpm_firmware_irq_raw2, DPM_HOST_INT_STAT2)    are obsolete since netx4000. Some functions moved to the main DPM IRQ register set (view dpm_irq_raw).  </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000F0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xF600FFFF</resetMask>
          <fields>
            <field>
              <name>INT_EN</name>
              <bitRange>[31:31]</bitRange>
              <description>Interrupt Enable for IRQs handled in this register. Only if this bit is set, global firmware IRQ will be asserted to host CPU, ARM or xPIC by dpm_irq_* registers. 0: No Interrupts to host, ARM or xPIC are generated by IRQ sources handled in this register. 1: Enabled IRQ sources handled in this register generate a host, ARM or xPIC IRQ if asserted. Note: Enable bits for single IRQ events are not affected if this bit is set or reset. </description>
            </field>
            <field>
              <name>res_MEM_LCK_ro</name>
              <bitRange>[30:30]</bitRange>
              <description>reserved for Memory Lock IRQ (not available in this netX version). </description>
            </field>
            <field>
              <name>res_WDG_NETX_ro</name>
              <bitRange>[29:29]</bitRange>
              <description>reserved for netX supervision Watchdog Timeout IRQ (not available in this netX version). </description>
            </field>
            <field>
              <name>res_RDY_TIMEOUT_ro</name>
              <bitRange>[28:28]</bitRange>
              <description>reserved, DPM_RDY timeout error does not exist for IDPM. </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[27:27]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>SYS_STA</name>
              <bitRange>[26:26]</bitRange>
              <description>System Status Change IRQ Enable. </description>
            </field>
            <field>
              <name>res_TMR_ro</name>
              <bitRange>[25:25]</bitRange>
              <description>reserved for Timer IRQ (not available in this netX version). </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[24:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>HS_EVENT15</name>
              <bitRange>[15:15]</bitRange>
              <description>Handshake Event 15 IRQ Enable (also netX-controllable by HANDSHAKE_CTRL, netX50 comp.). </description>
            </field>
            <field>
              <name>HS_EVENT14</name>
              <bitRange>[14:14]</bitRange>
              <description>Handshake Event 14 IRQ Enable (also netX-controllable by HANDSHAKE_CTRL, netX50 comp.). </description>
            </field>
            <field>
              <name>HS_EVENT13</name>
              <bitRange>[13:13]</bitRange>
              <description>Handshake Event 13 IRQ Enable (also netX-controllable by HANDSHAKE_CTRL, netX50 comp.). </description>
            </field>
            <field>
              <name>HS_EVENT12</name>
              <bitRange>[12:12]</bitRange>
              <description>Handshake Event 12 IRQ Enable (also netX-controllable by HANDSHAKE_CTRL, netX50 comp.). </description>
            </field>
            <field>
              <name>HS_EVENT11</name>
              <bitRange>[11:11]</bitRange>
              <description>Handshake Event 11 IRQ Enable (also netX-controllable by HANDSHAKE_CTRL, netX50 comp.). </description>
            </field>
            <field>
              <name>HS_EVENT10</name>
              <bitRange>[10:10]</bitRange>
              <description>Handshake Event 10 IRQ Enable (also netX-controllable by HANDSHAKE_CTRL, netX50 comp.). </description>
            </field>
            <field>
              <name>HS_EVENT9</name>
              <bitRange>[9:9]</bitRange>
              <description>Handshake Event 9  IRQ Enable (also netX-controllable by HANDSHAKE_CTRL, netX50 comp.). </description>
            </field>
            <field>
              <name>HS_EVENT8</name>
              <bitRange>[8:8]</bitRange>
              <description>Handshake Event 8  IRQ Enable (also netX-controllable by HANDSHAKE_CTRL, netX50 comp.). </description>
            </field>
            <field>
              <name>HS_EVENT7</name>
              <bitRange>[7:7]</bitRange>
              <description>Handshake Event 7  IRQ Enable (also netX-controllable by HANDSHAKE_CTRL, netX50 comp.). </description>
            </field>
            <field>
              <name>HS_EVENT6</name>
              <bitRange>[6:6]</bitRange>
              <description>Handshake Event 6  IRQ Enable (also netX-controllable by HANDSHAKE_CTRL, netX50 comp.). </description>
            </field>
            <field>
              <name>HS_EVENT5</name>
              <bitRange>[5:5]</bitRange>
              <description>Handshake Event 5  IRQ Enable (also netX-controllable by HANDSHAKE_CTRL, netX50 comp.). </description>
            </field>
            <field>
              <name>HS_EVENT4</name>
              <bitRange>[4:4]</bitRange>
              <description>Handshake Event 4  IRQ Enable (also netX-controllable by HANDSHAKE_CTRL, netX50 comp.). </description>
            </field>
            <field>
              <name>HS_EVENT3</name>
              <bitRange>[3:3]</bitRange>
              <description>Handshake Event 3  IRQ Enable (also netX-controllable by HANDSHAKE_CTRL, netX50 comp.). </description>
            </field>
            <field>
              <name>HS_EVENT2</name>
              <bitRange>[2:2]</bitRange>
              <description>Handshake Event 2  IRQ Enable (also netX-controllable by HANDSHAKE_CTRL, netX50 comp.). </description>
            </field>
            <field>
              <name>HS_EVENT1</name>
              <bitRange>[1:1]</bitRange>
              <description>Handshake Event 1  IRQ Enable (also netX-controllable by HANDSHAKE_CTRL, netX50 comp.). </description>
            </field>
            <field>
              <name>HS_EVENT0</name>
              <bitRange>[0:0]</bitRange>
              <description>Handshake Event 0  IRQ Enable (also netX-controllable by HANDSHAKE_CTRL, netX50 comp.). </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'idpm_netx_version': 0xFF001BFC-->
          <name>idpm_netx_version</name>
          <description>DPM netX Version Register. This register is mirrored form asic_ctrl register area and can be set during netX booting phase by netX firmware. This register is not valid if unlocked bit is not set in dpm_status register. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000FC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>netx_version</name>
              <bitRange>[31:0]</bitRange>
              <description>netX version from version register. </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>hash</name>
      <description>hash</description>
      <baseAddress>0xFF080000</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>128</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>hash</name>
        <value>27</value>
      </interrupt>
      <registers>
        <register>
          <!--Absolute address of 'hash_din': 0xFF080000-->
          <name>hash_din</name>
          <description>Hash FIFO input: Unlike all other registers, this address can be written with DWord(32 Bit), Word(16 Bit) or Byte acccss. The FIFO controller will automatically collect data and start HASH-calculation, if enough data (complete DWords) are collected. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_cfg': 0xFF080004-->
          <name>hash_cfg</name>
          <description>Hash config register: </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000020</resetValue>
          <resetMask>0x0000003F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>dma_burst_only</name>
              <bitRange>[5:5]</bitRange>
              <description>Generate DMAC burst signal only. When set to '1' the DMAC logic will only generate burst requests to the DMAC. This is to overcome limitations of the current DMA controller implementation that only accepts burst requests for DMAC controlled memory to peripheral transfers. </description>
            </field>
            <field>
              <name>dma_en</name>
              <bitRange>[4:4]</bitRange>
              <description>Enable DMAC control signals </description>
            </field>
            <field>
              <name>reset</name>
              <bitRange>[3:3]</bitRange>
              <description>Reset of SHA engine: After writing '1', this bit will automatically be reset. 1: reset internal registers, use this to start calculation of new hash 0: start calculation as soon as enough data in FIFO buffer </description>
            </field>
            <field>
              <name>mode</name>
              <bitRange>[2:0]</bitRange>
              <description>Hash core mode 101: MD5 100: SHA2-512 011: SHA2-384 010: SHA2-256 001: SHA2-224 000: SHA1-160 Note: When changing the mode, a reset must be performed to correctly initialize the SHA/MD5 core. This can be done by setting the 'reset' bit together with the new mode or in a second access after setting the mode. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_stat': 0xFF080008-->
          <name>hash_stat</name>
          <description>Hash status register: </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000001FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:9]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>fifo_fill</name>
              <bitRange>[8:0]</bitRange>
              <description>Fill level of FIFO in bytes (0..256) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_debug_info': 0xFF08000C-->
          <name>hash_debug_info</name>
          <description>Hash info register: </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000007F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sha_round</name>
              <bitRange>[6:0]</bitRange>
              <description>7bit current state counter of the SHA core. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_irq_raw': 0xFF080010-->
          <name>hash_irq_raw</name>
          <description>Hash raw IRQ: Read access shows status of unmasked IRQs.   IRQs are set automatically and reset by writing to this register: Write access with '1' resets the appropriate IRQ. Write access with '0' does not influence this bit. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000007</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:3]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>fifo_overflow</name>
              <bitRange>[2:2]</bitRange>
              <description>input buffer was overflown, set hash_cfg-reset=1 to reset this bit. </description>
            </field>
            <field>
              <name>fifo_underrun</name>
              <bitRange>[1:1]</bitRange>
              <description>input buffer was underrun, set hash_cfg-reset=1 to reset this bit. Note: underrun is only a theoretical FIFO status, because the hardware logic of the hash core won't fetch data from the FIFO when it's empty. </description>
            </field>
            <field>
              <name>hash_ready</name>
              <bitRange>[0:0]</bitRange>
              <description>Hash core has finished calculation and hash value inside the registers crypt_hash[15:0] is valid. Note: This interrupt will be asserted when the hash FIFO is empty and the calculation of the last block from the FIFO has finished. The interrupt will be re-asserted after clearing as long as no new data has been fed into the FIFO or a software reset has been performed (hash_cfg-reset=1). Note: This interrupt could have got asserted in situations where the FIFO runs empty, the hash core finished the operation and new data blocks will be fed into the FIFO afterwards. In this case the IRQ will have been asserted before the very last block has been processed. In such situations it is advised to either disable the interrupt (hash_irq_mask_reset) and enable it after putting the very last data into the FIFO (hash_irq_mask_set) or to clear the IRQ once after putting the very last data and ignore any previous IRQs. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_irq_masked': 0xFF080014-->
          <name>hash_irq_masked</name>
          <description>Hash masked IRQ: Shows status of masked IRQs. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000014</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000007</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:3]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>fifo_overflow</name>
              <bitRange>[2:2]</bitRange>
              <description>input buffer was overflown, set hash_cfg-reset=1 to reset this bit </description>
            </field>
            <field>
              <name>fifo_underrun</name>
              <bitRange>[1:1]</bitRange>
              <description>input buffer was underrun, set hash_cfg-reset=1 to reset this bit </description>
            </field>
            <field>
              <name>hash_ready</name>
              <bitRange>[0:0]</bitRange>
              <description>Hash core has finished calculation and hash value inside the registers crypt_hash[15:0] is valid </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_irq_msk_set': 0xFF080018-->
          <name>hash_irq_msk_set</name>
          <description>Hash IRQ mask set: The IRQ mask enables interrupt requests for corresponding interrupt sources.   As its bits might be changed by different software tasks,   the IRQ mask register is not writable directly, but by set and reset masks: Write access with '1' sets interrupt mask bit. Write access with '0' does not influence this bit. Read access shows actual interrupt mask. Attention: Before activating interrupt mask, delete old pending interrupts by writing the same value to crypt_hash_irq_raw. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000018</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000007</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:3]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>fifo_overflow</name>
              <bitRange>[2:2]</bitRange>
              <description>input buffer was overflown, set hash_cfg-reset=1 to reset this bit </description>
            </field>
            <field>
              <name>fifo_underrun</name>
              <bitRange>[1:1]</bitRange>
              <description>input buffer was underrun, set hash_cfg-reset=1 to reset this bit </description>
            </field>
            <field>
              <name>hash_ready</name>
              <bitRange>[0:0]</bitRange>
              <description>Hash core has finished calculation and hash value inside the registers crypt_hash[15:0] is valid </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_irq_msk_reset': 0xFF08001C-->
          <name>hash_irq_msk_reset</name>
          <description>Hash IRQ mask reset: This is the corresponding reset mask to disable interrupt requests for corresponding interrupt sources: Write access with '1' resets interrupt mask bit. Write access with '0' does not influence this bit. Read access shows actual interrupt mask. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000001C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000007</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:3]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>fifo_overflow</name>
              <bitRange>[2:2]</bitRange>
              <description>input buffer was overflown, set hash_cfg-reset=1 to reset this bit </description>
            </field>
            <field>
              <name>fifo_underrun</name>
              <bitRange>[1:1]</bitRange>
              <description>input buffer was underrun, set hash_cfg-reset=1 to reset this bit </description>
            </field>
            <field>
              <name>hash_ready</name>
              <bitRange>[0:0]</bitRange>
              <description>Hash core has finished calculation and hash value inside the registers crypt_hash[15:0] is valid </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_dout0': 0xFF080020-->
          <name>hash_dout0</name>
          <description>Hash value0 register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000020</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 31..0 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_dout1': 0xFF080024-->
          <name>hash_dout1</name>
          <description>Hash value1 register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000024</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 63..32 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_dout2': 0xFF080028-->
          <name>hash_dout2</name>
          <description>Hash value2 register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000028</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 95..64 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_dout3': 0xFF08002C-->
          <name>hash_dout3</name>
          <description>Hash value3 register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000002C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 127..96 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_dout4': 0xFF080030-->
          <name>hash_dout4</name>
          <description>Hash value4 register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000030</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 159..128 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_dout5': 0xFF080034-->
          <name>hash_dout5</name>
          <description>Hash value5 register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000034</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 191..160 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_dout6': 0xFF080038-->
          <name>hash_dout6</name>
          <description>Hash value6 register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000038</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 223..192 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_dout7': 0xFF08003C-->
          <name>hash_dout7</name>
          <description>Hash value7 register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000003C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 255..224 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_dout8': 0xFF080040-->
          <name>hash_dout8</name>
          <description>Hash value8 register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000040</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 287..256 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_dout9': 0xFF080044-->
          <name>hash_dout9</name>
          <description>Hash value9 register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000044</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 319..288 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_dout10': 0xFF080048-->
          <name>hash_dout10</name>
          <description>Hash value10 register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000048</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 351..320 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_dout11': 0xFF08004C-->
          <name>hash_dout11</name>
          <description>Hash value11 register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000004C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 383..352 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_dout12': 0xFF080050-->
          <name>hash_dout12</name>
          <description>Hash value12 register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000050</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 415..384 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_dout13': 0xFF080054-->
          <name>hash_dout13</name>
          <description>Hash value13 register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000054</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 447..416 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_dout14': 0xFF080058-->
          <name>hash_dout14</name>
          <description>Hash value14 register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000058</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 479..448 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_dout15': 0xFF08005C-->
          <name>hash_dout15</name>
          <description>Hash value15 register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000005C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 511..480 </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>hash_ctx_sha</name>
      <description>hash_ctx_sha</description>
      <baseAddress>0xFF080100</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>256</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <!--Absolute address of 'hash_ctx_sha_w0_0': 0xFF080100-->
          <name>hash_ctx_sha_w0_0</name>
          <description>SHA context register w0 part 0 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Register w0 part 0 value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_ctx_sha_w0_1': 0xFF080104-->
          <name>hash_ctx_sha_w0_1</name>
          <description>SHA context register w0 part 1 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Register w0 part 1 value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_ctx_sha_w1_0': 0xFF080108-->
          <name>hash_ctx_sha_w1_0</name>
          <description>SHA context register w1 part 0 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Register w1 part 0 value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_ctx_sha_w1_1': 0xFF08010C-->
          <name>hash_ctx_sha_w1_1</name>
          <description>SHA context register w1 part 1 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Register w1 part 1 value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_ctx_sha_w2_0': 0xFF080110-->
          <name>hash_ctx_sha_w2_0</name>
          <description>SHA context register w2 part 0 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Register w2 part 0 value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_ctx_sha_w2_1': 0xFF080114-->
          <name>hash_ctx_sha_w2_1</name>
          <description>SHA context register w2 part 1 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Register w2 part 1 value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_ctx_sha_w3_0': 0xFF080118-->
          <name>hash_ctx_sha_w3_0</name>
          <description>SHA context register w3 part 0 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000018</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Register w3 part 0 value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_ctx_sha_w3_1': 0xFF08011C-->
          <name>hash_ctx_sha_w3_1</name>
          <description>SHA context register w3 part 1 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000001C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Register w3 part 1 value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_ctx_sha_w4_0': 0xFF080120-->
          <name>hash_ctx_sha_w4_0</name>
          <description>SHA context register w4 part 0 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Register w4 part 0 value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_ctx_sha_w4_1': 0xFF080124-->
          <name>hash_ctx_sha_w4_1</name>
          <description>SHA context register w4 part 1 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000024</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Register w4 part 1 value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_ctx_sha_w5_0': 0xFF080128-->
          <name>hash_ctx_sha_w5_0</name>
          <description>SHA context register w5 part 0 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000028</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Register w5 part 0 value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_ctx_sha_w5_1': 0xFF08012C-->
          <name>hash_ctx_sha_w5_1</name>
          <description>SHA context register w5 part 1 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000002C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Register w5 part 1 value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_ctx_sha_w6_0': 0xFF080130-->
          <name>hash_ctx_sha_w6_0</name>
          <description>SHA context register w6 part 0 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000030</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Register w6 part 0 value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_ctx_sha_w6_1': 0xFF080134-->
          <name>hash_ctx_sha_w6_1</name>
          <description>SHA context register w6 part 1 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000034</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Register w6 part 1 value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_ctx_sha_w7_0': 0xFF080138-->
          <name>hash_ctx_sha_w7_0</name>
          <description>SHA context register w7 part 0 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000038</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Register w7 part 0 value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_ctx_sha_w7_1': 0xFF08013C-->
          <name>hash_ctx_sha_w7_1</name>
          <description>SHA context register w7 part 1 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000003C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Register w7 part 1 value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_ctx_sha_w8_0': 0xFF080140-->
          <name>hash_ctx_sha_w8_0</name>
          <description>SHA context register w8 part 0 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000040</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Register w8 part 0 value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_ctx_sha_w8_1': 0xFF080144-->
          <name>hash_ctx_sha_w8_1</name>
          <description>SHA context register w8 part 1 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000044</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Register w8 part 1 value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_ctx_sha_w9_0': 0xFF080148-->
          <name>hash_ctx_sha_w9_0</name>
          <description>SHA context register w9 part 0 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000048</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Register w9 part 0 value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_ctx_sha_w9_1': 0xFF08014C-->
          <name>hash_ctx_sha_w9_1</name>
          <description>SHA context register w9 part 1 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000004C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Register w9 part 1 value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_ctx_sha_w10_0': 0xFF080150-->
          <name>hash_ctx_sha_w10_0</name>
          <description>SHA context register w10 part 0 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000050</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Register w10 part 0 value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_ctx_sha_w10_1': 0xFF080154-->
          <name>hash_ctx_sha_w10_1</name>
          <description>SHA context register w10 part 1 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000054</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Register w10 part 1 value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_ctx_sha_w11_0': 0xFF080158-->
          <name>hash_ctx_sha_w11_0</name>
          <description>SHA context register w11 part 0 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000058</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Register w11 part 0 value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_ctx_sha_w11_1': 0xFF08015C-->
          <name>hash_ctx_sha_w11_1</name>
          <description>SHA context register w11 part 1 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000005C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Register w11 part 1 value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_ctx_sha_w12_0': 0xFF080160-->
          <name>hash_ctx_sha_w12_0</name>
          <description>SHA context register w12 part 0 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000060</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Register w12 part 0 value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_ctx_sha_w12_1': 0xFF080164-->
          <name>hash_ctx_sha_w12_1</name>
          <description>SHA context register w12 part 1 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000064</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Register w12 part 1 value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_ctx_sha_w13_0': 0xFF080168-->
          <name>hash_ctx_sha_w13_0</name>
          <description>SHA context register w13 part 0 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000068</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Register w13 part 0 value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_ctx_sha_w13_1': 0xFF08016C-->
          <name>hash_ctx_sha_w13_1</name>
          <description>SHA context register w13 part 1 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000006C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Register w13 part 1 value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_ctx_sha_w14_0': 0xFF080170-->
          <name>hash_ctx_sha_w14_0</name>
          <description>SHA context register w14 part 0 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000070</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Register w14 part 0 value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_ctx_sha_w14_1': 0xFF080174-->
          <name>hash_ctx_sha_w14_1</name>
          <description>SHA context register w14 part 1 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000074</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Register w14 part 1 value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_ctx_sha_wt_0': 0xFF080178-->
          <name>hash_ctx_sha_wt_0</name>
          <description>SHA context register wt part 0 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000078</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Register wt part 0 value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_ctx_sha_wt_1': 0xFF08017C-->
          <name>hash_ctx_sha_wt_1</name>
          <description>SHA context register wt part 1 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000007C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Register wt part 1 value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_ctx_sha_a_0': 0xFF080180-->
          <name>hash_ctx_sha_a_0</name>
          <description>SHA context register a part 0 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000080</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Register a part 0 value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_ctx_sha_a_1': 0xFF080184-->
          <name>hash_ctx_sha_a_1</name>
          <description>SHA context register a part 1 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000084</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Register a part 1 value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_ctx_sha_b_0': 0xFF080188-->
          <name>hash_ctx_sha_b_0</name>
          <description>SHA context register b part 0 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000088</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Register b part 0 value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_ctx_sha_b_1': 0xFF08018C-->
          <name>hash_ctx_sha_b_1</name>
          <description>SHA context register b part 1 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000008C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Register b part 1 value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_ctx_sha_c_0': 0xFF080190-->
          <name>hash_ctx_sha_c_0</name>
          <description>SHA context register c part 0 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000090</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Register c part 0 value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_ctx_sha_c_1': 0xFF080194-->
          <name>hash_ctx_sha_c_1</name>
          <description>SHA context register c part 1 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000094</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Register c part 1 value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_ctx_sha_d_0': 0xFF080198-->
          <name>hash_ctx_sha_d_0</name>
          <description>SHA context register d part 0 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000098</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Register d part 0 value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_ctx_sha_d_1': 0xFF08019C-->
          <name>hash_ctx_sha_d_1</name>
          <description>SHA context register d part 1 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000009C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Register d part 1 value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_ctx_sha_e_0': 0xFF0801A0-->
          <name>hash_ctx_sha_e_0</name>
          <description>SHA context register e part 0 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000A0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Register e part 0 value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_ctx_sha_e_1': 0xFF0801A4-->
          <name>hash_ctx_sha_e_1</name>
          <description>SHA context register e part 1 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000A4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Register e part 1 value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_ctx_sha_f_0': 0xFF0801A8-->
          <name>hash_ctx_sha_f_0</name>
          <description>SHA context register f part 0 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000A8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Register f part 0 value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_ctx_sha_f_1': 0xFF0801AC-->
          <name>hash_ctx_sha_f_1</name>
          <description>SHA context register f part 1 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000AC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Register f part 1 value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_ctx_sha_g_0': 0xFF0801B0-->
          <name>hash_ctx_sha_g_0</name>
          <description>SHA context register g part 0 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000B0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Register g part 0 value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_ctx_sha_g_1': 0xFF0801B4-->
          <name>hash_ctx_sha_g_1</name>
          <description>SHA context register g part 1 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000B4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Register g part 1 value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_ctx_sha_h_0': 0xFF0801B8-->
          <name>hash_ctx_sha_h_0</name>
          <description>SHA context register h part 0 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000B8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Register h part 0 value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_ctx_sha_h_1': 0xFF0801BC-->
          <name>hash_ctx_sha_h_1</name>
          <description>SHA context register h part 1 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000BC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Register h part 1 value </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>hash_ctx_md5</name>
      <description>hash_ctx_md5</description>
      <baseAddress>0xFF080200</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>32</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <!--Absolute address of 'hash_ctx_md5_a': 0xFF080200-->
          <name>hash_ctx_md5_a</name>
          <description>MD5 context register a </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Register a value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_ctx_md5_b': 0xFF080204-->
          <name>hash_ctx_md5_b</name>
          <description>MD5 context register b </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Register b value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_ctx_md5_c': 0xFF080208-->
          <name>hash_ctx_md5_c</name>
          <description>MD5 context register c </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Register c value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_ctx_md5_d': 0xFF08020C-->
          <name>hash_ctx_md5_d</name>
          <description>MD5 context register d </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Register d value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_ctx_md5_ar': 0xFF080210-->
          <name>hash_ctx_md5_ar</name>
          <description>MD5 context register ar </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Register ar value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_ctx_md5_br': 0xFF080214-->
          <name>hash_ctx_md5_br</name>
          <description>MD5 context register br </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Register br value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_ctx_md5_cr': 0xFF080218-->
          <name>hash_ctx_md5_cr</name>
          <description>MD5 context register cr </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000018</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Register cr value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hash_ctx_md5_dr': 0xFF08021C-->
          <name>hash_ctx_md5_dr</name>
          <description>MD5 context register dr </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000001C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Register dr value </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>aes</name>
      <description>aes</description>
      <baseAddress>0xFF080300</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>64</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>aes</name>
        <value>28</value>
      </interrupt>
      <registers>
        <register>
          <!--Absolute address of 'aes_cfg': 0xFF080300-->
          <name>aes_cfg</name>
          <description>AES config register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00148200</resetValue>
          <resetMask>0x001FFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:21]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>out_fifo_dma_burst_only</name>
              <bitRange>[20:20]</bitRange>
              <description>Generate DMAC burst signal only (output FIFO). When set to '1' the DMAC logic will only generate burst requests to the DMAC. This is not strictly needed for the DMAC implementation, but could result in better system performance. </description>
            </field>
            <field>
              <name>out_fifo_dma_en</name>
              <bitRange>[19:19]</bitRange>
              <description>Enable DMAC control signals for the output FIFO. </description>
            </field>
            <field>
              <name>in_fifo_dma_burst_only</name>
              <bitRange>[18:18]</bitRange>
              <description>Generate DMAC burst signal only (input FIFO). When set to '1' the DMAC logic will only generate burst requests to the DMAC. This is to overcome limitations of the current DMA controller implementation that only accepts burst requests for DMAC controlled memory to peripheral transfers. </description>
            </field>
            <field>
              <name>in_fifo_dma_en</name>
              <bitRange>[17:17]</bitRange>
              <description>Enable DMAC control signals for the input FIFO </description>
            </field>
            <field>
              <name>out_fifo_wm</name>
              <bitRange>[16:11]</bitRange>
              <description>Output FIFO watermark level (0..63) used for out_fifo_wm interrupt </description>
            </field>
            <field>
              <name>in_fifo_wm</name>
              <bitRange>[10:5]</bitRange>
              <description>Input FIFO watermark level (0..63) used for in_fifo_wm interrupt </description>
            </field>
            <field>
              <name>key_exp_start</name>
              <bitRange>[4:4]</bitRange>
              <description>Start AES key expansion After writing '1', this bit will automatically be reset. Data input can be started when key expansion is ready (see crypt_aes_stat bit 'key_exp_ready'). </description>
            </field>
            <field>
              <name>key_len</name>
              <bitRange>[3:2]</bitRange>
              <description>AES key length 0: 128 bit 1: 192 bit 2: 256 bit 3: reserved </description>
            </field>
            <field>
              <name>mode</name>
              <bitRange>[1:1]</bitRange>
              <description>AES core operation mode 0: Encrypt 1: Decrypt </description>
            </field>
            <field>
              <name>enable</name>
              <bitRange>[0:0]</bitRange>
              <description>Enables the AES core operation. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'aes_stat': 0xFF080304-->
          <name>aes_stat</name>
          <description>AES status register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0FFFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:28]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>out_fifo_overflow</name>
              <bitRange>[27:27]</bitRange>
              <description>Output FIFO was overflown, set aes_cfg-enable=0 to reset this bit Note: overflow is only a theoretical FIFO status, because the hardware logic of the AES core won't put data into the FIFO when it's full. </description>
            </field>
            <field>
              <name>out_fifo_underrun</name>
              <bitRange>[26:26]</bitRange>
              <description>Output FIFO was underrun, set aes_cfg-enable=0 to reset this bit </description>
            </field>
            <field>
              <name>out_fifo_not_full</name>
              <bitRange>[25:25]</bitRange>
              <description>Output FIFO is not full </description>
            </field>
            <field>
              <name>out_fifo_full</name>
              <bitRange>[24:24]</bitRange>
              <description>Output FIFO is full </description>
            </field>
            <field>
              <name>out_fifo_not_empty</name>
              <bitRange>[23:23]</bitRange>
              <description>Output FIFO is not empty </description>
            </field>
            <field>
              <name>out_fifo_empty</name>
              <bitRange>[22:22]</bitRange>
              <description>Output FIFO is empty </description>
            </field>
            <field>
              <name>out_fifo_fill</name>
              <bitRange>[21:15]</bitRange>
              <description>Fill level of output FIFO in bytes (0..64) </description>
            </field>
            <field>
              <name>in_fifo_overflow</name>
              <bitRange>[14:14]</bitRange>
              <description>Input FIFO was overflown, set aes_cfg-enable=0 to reset this bit </description>
            </field>
            <field>
              <name>in_fifo_underrun</name>
              <bitRange>[13:13]</bitRange>
              <description>Input FIFO was underrun, set aes_cfg-enable=0 to reset this bit Note: underrun is only a theoretical FIFO status, because the hardware logic of the AES core won't fetch data from the FIFO when it's empty. </description>
            </field>
            <field>
              <name>in_fifo_not_full</name>
              <bitRange>[12:12]</bitRange>
              <description>Input FIFO is not full </description>
            </field>
            <field>
              <name>in_fifo_full</name>
              <bitRange>[11:11]</bitRange>
              <description>Input FIFO is full </description>
            </field>
            <field>
              <name>in_fifo_not_empty</name>
              <bitRange>[10:10]</bitRange>
              <description>Input FIFO is not empty </description>
            </field>
            <field>
              <name>in_fifo_empty</name>
              <bitRange>[9:9]</bitRange>
              <description>Input FIFO is empty </description>
            </field>
            <field>
              <name>in_fifo_fill</name>
              <bitRange>[8:2]</bitRange>
              <description>Fill level of input FIFO in bytes (0..64) </description>
            </field>
            <field>
              <name>op_ready</name>
              <bitRange>[1:1]</bitRange>
              <description>Set when AES operation ready, i.e. AES core not busy and input FIFO is empty </description>
            </field>
            <field>
              <name>key_exp_ready</name>
              <bitRange>[0:0]</bitRange>
              <description>Set when key expansion procedure is done </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'aes_irq_raw': 0xFF080308-->
          <name>aes_irq_raw</name>
          <description>AES raw IRQ: Read access shows status of unmasked IRQs.   IRQs are set automatically and reset by writing to this register: Write access with '1' resets the appropriate IRQ. Write access with '0' does not influence this bit. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>out_fifo_overflow</name>
              <bitRange>[15:15]</bitRange>
              <description>Output FIFO was overflown, set aes_cfg-enable=0 to reset this bit Note: overflow is only a theoretical FIFO status, because the hardware logic of the AES core won't put data into the FIFO when it's full. </description>
            </field>
            <field>
              <name>out_fifo_underrun</name>
              <bitRange>[14:14]</bitRange>
              <description>Output FIFO was underrun, set aes_cfg-enable=0 to reset this bit </description>
            </field>
            <field>
              <name>out_fifo_not_full</name>
              <bitRange>[13:13]</bitRange>
              <description>Output FIFO is not full </description>
            </field>
            <field>
              <name>out_fifo_full</name>
              <bitRange>[12:12]</bitRange>
              <description>Output FIFO is full </description>
            </field>
            <field>
              <name>out_fifo_not_empty</name>
              <bitRange>[11:11]</bitRange>
              <description>Output FIFO is not empty </description>
            </field>
            <field>
              <name>out_fifo_empty</name>
              <bitRange>[10:10]</bitRange>
              <description>Output FIFO is empty </description>
            </field>
            <field>
              <name>out_fifo_wm</name>
              <bitRange>[9:9]</bitRange>
              <description>Fill level of output FIFO is above watermark (see crypt_aes_cfg bits 'out_fifo_wm') </description>
            </field>
            <field>
              <name>in_fifo_overflow</name>
              <bitRange>[8:8]</bitRange>
              <description>Input FIFO was overflown, set aes_cfg-enable=0 to reset this bit </description>
            </field>
            <field>
              <name>in_fifo_underrun</name>
              <bitRange>[7:7]</bitRange>
              <description>Input FIFO was underrun, set aes_cfg-enable=0 to reset this bit Note: underrun is only a theoretical FIFO status, because the hardware logic of the AES core won't fetch data from the FIFO when it's empty. </description>
            </field>
            <field>
              <name>in_fifo_not_full</name>
              <bitRange>[6:6]</bitRange>
              <description>Input FIFO is not full </description>
            </field>
            <field>
              <name>in_fifo_full</name>
              <bitRange>[5:5]</bitRange>
              <description>Input FIFO is full </description>
            </field>
            <field>
              <name>in_fifo_not_empty</name>
              <bitRange>[4:4]</bitRange>
              <description>Input FIFO is not empty </description>
            </field>
            <field>
              <name>in_fifo_empty</name>
              <bitRange>[3:3]</bitRange>
              <description>Input FIFO is empty </description>
            </field>
            <field>
              <name>in_fifo_wm</name>
              <bitRange>[2:2]</bitRange>
              <description>Fill level of input FIFO is below or equal watermark (see crypt_aes_cfg bits 'in_fifo_wm') </description>
            </field>
            <field>
              <name>op_ready</name>
              <bitRange>[1:1]</bitRange>
              <description>Set when AES operation ready, i.e. AES core not busy and input FIFO is empty </description>
            </field>
            <field>
              <name>key_exp_ready</name>
              <bitRange>[0:0]</bitRange>
              <description>Set when key expansion procedure is done </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'aes_irq_masked': 0xFF08030C-->
          <name>aes_irq_masked</name>
          <description>AES masked IRQ: Shows status of masked IRQs. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>out_fifo_overflow</name>
              <bitRange>[15:15]</bitRange>
              <description>Output FIFO was overflown, set aes_cfg-enable=0 to reset this bit </description>
            </field>
            <field>
              <name>out_fifo_underrun</name>
              <bitRange>[14:14]</bitRange>
              <description>Output FIFO was underrun, set aes_cfg-enable=0 to reset this bit </description>
            </field>
            <field>
              <name>out_fifo_not_full</name>
              <bitRange>[13:13]</bitRange>
              <description>Output FIFO is not full </description>
            </field>
            <field>
              <name>out_fifo_full</name>
              <bitRange>[12:12]</bitRange>
              <description>Output FIFO is full </description>
            </field>
            <field>
              <name>out_fifo_not_empty</name>
              <bitRange>[11:11]</bitRange>
              <description>Output FIFO is not empty </description>
            </field>
            <field>
              <name>out_fifo_empty</name>
              <bitRange>[10:10]</bitRange>
              <description>Output FIFO is empty </description>
            </field>
            <field>
              <name>out_fifo_wm</name>
              <bitRange>[9:9]</bitRange>
              <description>Fill level of output FIFO is above watermark (see crypt_aes_cfg bits 'out_fifo_wm') </description>
            </field>
            <field>
              <name>in_fifo_overflow</name>
              <bitRange>[8:8]</bitRange>
              <description>Input FIFO was overflown, set aes_cfg-enable=0 to reset this bit </description>
            </field>
            <field>
              <name>in_fifo_underrun</name>
              <bitRange>[7:7]</bitRange>
              <description>Input FIFO was underrun, set aes_cfg-enable=0 to reset this bit </description>
            </field>
            <field>
              <name>in_fifo_not_full</name>
              <bitRange>[6:6]</bitRange>
              <description>Input FIFO is not full </description>
            </field>
            <field>
              <name>in_fifo_full</name>
              <bitRange>[5:5]</bitRange>
              <description>Input FIFO is full </description>
            </field>
            <field>
              <name>in_fifo_not_empty</name>
              <bitRange>[4:4]</bitRange>
              <description>Input FIFO is not empty </description>
            </field>
            <field>
              <name>in_fifo_empty</name>
              <bitRange>[3:3]</bitRange>
              <description>Input FIFO is empty </description>
            </field>
            <field>
              <name>in_fifo_wm</name>
              <bitRange>[2:2]</bitRange>
              <description>Fill level of input FIFO is below or equal watermark (see crypt_aes_cfg bits 'in_fifo_wm') </description>
            </field>
            <field>
              <name>op_ready</name>
              <bitRange>[1:1]</bitRange>
              <description>Set when AES operation ready, i.e. AES core not busy and input FIFO is empty </description>
            </field>
            <field>
              <name>key_exp_ready</name>
              <bitRange>[0:0]</bitRange>
              <description>Set when key expansion procedure is done </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'aes_irq_msk_set': 0xFF080310-->
          <name>aes_irq_msk_set</name>
          <description>AES IRQ mask set: The IRQ mask enables interrupt requests for corresponding interrupt sources.   As its bits might be changed by different software tasks,   the IRQ mask register is not writable directly, but by set and reset masks: Write access with '1' sets interrupt mask bit. Write access with '0' does not influence this bit. Read access shows actual interrupt mask. Attention: Before activating interrupt mask, delete old pending interrupts by writing the same value to crypt_aes_irq_raw. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>out_fifo_overflow</name>
              <bitRange>[15:15]</bitRange>
              <description>Output FIFO was overflown, set aes_cfg-enable=0 to reset this bit </description>
            </field>
            <field>
              <name>out_fifo_underrun</name>
              <bitRange>[14:14]</bitRange>
              <description>Output FIFO was underrun, set aes_cfg-enable=0 to reset this bit </description>
            </field>
            <field>
              <name>out_fifo_not_full</name>
              <bitRange>[13:13]</bitRange>
              <description>Output FIFO is not full </description>
            </field>
            <field>
              <name>out_fifo_full</name>
              <bitRange>[12:12]</bitRange>
              <description>Output FIFO is full </description>
            </field>
            <field>
              <name>out_fifo_not_empty</name>
              <bitRange>[11:11]</bitRange>
              <description>Output FIFO is not empty </description>
            </field>
            <field>
              <name>out_fifo_empty</name>
              <bitRange>[10:10]</bitRange>
              <description>Output FIFO is empty </description>
            </field>
            <field>
              <name>out_fifo_wm</name>
              <bitRange>[9:9]</bitRange>
              <description>Fill level of output FIFO is above watermark (see crypt_aes_cfg bits 'out_fifo_wm') </description>
            </field>
            <field>
              <name>in_fifo_overflow</name>
              <bitRange>[8:8]</bitRange>
              <description>Input FIFO was overflown, set aes_cfg-enable=0 to reset this bit </description>
            </field>
            <field>
              <name>in_fifo_underrun</name>
              <bitRange>[7:7]</bitRange>
              <description>Input FIFO was underrun, set aes_cfg-enable=0 to reset this bit </description>
            </field>
            <field>
              <name>in_fifo_not_full</name>
              <bitRange>[6:6]</bitRange>
              <description>Input FIFO is not full </description>
            </field>
            <field>
              <name>in_fifo_full</name>
              <bitRange>[5:5]</bitRange>
              <description>Input FIFO is full </description>
            </field>
            <field>
              <name>in_fifo_not_empty</name>
              <bitRange>[4:4]</bitRange>
              <description>Input FIFO is not empty </description>
            </field>
            <field>
              <name>in_fifo_empty</name>
              <bitRange>[3:3]</bitRange>
              <description>Input FIFO is empty </description>
            </field>
            <field>
              <name>in_fifo_wm</name>
              <bitRange>[2:2]</bitRange>
              <description>Fill level of input FIFO is below or equal watermark (see crypt_aes_cfg bits 'in_fifo_wm') </description>
            </field>
            <field>
              <name>op_ready</name>
              <bitRange>[1:1]</bitRange>
              <description>Set when AES operation ready, i.e. AES core not busy and input FIFO is empty </description>
            </field>
            <field>
              <name>key_exp_ready</name>
              <bitRange>[0:0]</bitRange>
              <description>Set when key expansion procedure is done </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'aes_irq_msk_reset': 0xFF080314-->
          <name>aes_irq_msk_reset</name>
          <description>AES IRQ mask reset: This is the corresponding reset mask to disable interrupt requests for corresponding interrupt sources: Write access with '1' resets interrupt mask bit. Write access with '0' does not influence this bit. Read access shows actual interrupt mask. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>out_fifo_overflow</name>
              <bitRange>[15:15]</bitRange>
              <description>Output FIFO was overflown, set aes_cfg-enable=0 to reset this bit </description>
            </field>
            <field>
              <name>out_fifo_underrun</name>
              <bitRange>[14:14]</bitRange>
              <description>Output FIFO was underrun, set aes_cfg-enable=0 to reset this bit </description>
            </field>
            <field>
              <name>out_fifo_not_full</name>
              <bitRange>[13:13]</bitRange>
              <description>Output FIFO is not full </description>
            </field>
            <field>
              <name>out_fifo_full</name>
              <bitRange>[12:12]</bitRange>
              <description>Output FIFO is full </description>
            </field>
            <field>
              <name>out_fifo_not_empty</name>
              <bitRange>[11:11]</bitRange>
              <description>Output FIFO is not empty </description>
            </field>
            <field>
              <name>out_fifo_empty</name>
              <bitRange>[10:10]</bitRange>
              <description>Output FIFO is empty </description>
            </field>
            <field>
              <name>out_fifo_wm</name>
              <bitRange>[9:9]</bitRange>
              <description>Fill level of output FIFO is above watermark (see crypt_aes_cfg bits 'out_fifo_wm') </description>
            </field>
            <field>
              <name>in_fifo_overflow</name>
              <bitRange>[8:8]</bitRange>
              <description>Input FIFO was overflown, set aes_cfg-enable=0 to reset this bit </description>
            </field>
            <field>
              <name>in_fifo_underrun</name>
              <bitRange>[7:7]</bitRange>
              <description>Input FIFO was underrun, set aes_cfg-enable=0 to reset this bit </description>
            </field>
            <field>
              <name>in_fifo_not_full</name>
              <bitRange>[6:6]</bitRange>
              <description>Input FIFO is not full </description>
            </field>
            <field>
              <name>in_fifo_full</name>
              <bitRange>[5:5]</bitRange>
              <description>Input FIFO is full </description>
            </field>
            <field>
              <name>in_fifo_not_empty</name>
              <bitRange>[4:4]</bitRange>
              <description>Input FIFO is not empty </description>
            </field>
            <field>
              <name>in_fifo_empty</name>
              <bitRange>[3:3]</bitRange>
              <description>Input FIFO is empty </description>
            </field>
            <field>
              <name>in_fifo_wm</name>
              <bitRange>[2:2]</bitRange>
              <description>Fill level of input FIFO is below or equal watermark (see crypt_aes_cfg bits 'in_fifo_wm') </description>
            </field>
            <field>
              <name>op_ready</name>
              <bitRange>[1:1]</bitRange>
              <description>Set when AES operation ready, i.e. AES core not busy and input FIFO is empty </description>
            </field>
            <field>
              <name>key_exp_ready</name>
              <bitRange>[0:0]</bitRange>
              <description>Set when key expansion procedure is done </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'aes_key0': 0xFF080318-->
          <name>aes_key0</name>
          <description>AES key register 0 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000018</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>key bits 31..0 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'aes_key1': 0xFF08031C-->
          <name>aes_key1</name>
          <description>AES key register 1 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000001C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>key bits 63..32 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'aes_key2': 0xFF080320-->
          <name>aes_key2</name>
          <description>AES key register 2 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>key bits 95..64 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'aes_key3': 0xFF080324-->
          <name>aes_key3</name>
          <description>AES key register 3 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000024</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>key bits 127..96 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'aes_key4': 0xFF080328-->
          <name>aes_key4</name>
          <description>AES key register 4 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000028</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>key bits 159..128 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'aes_key5': 0xFF08032C-->
          <name>aes_key5</name>
          <description>AES key register 5 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000002C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>key bits 191..160 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'aes_key6': 0xFF080330-->
          <name>aes_key6</name>
          <description>AES key register 6 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000030</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>key bits 223..192 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'aes_key7': 0xFF080334-->
          <name>aes_key7</name>
          <description>AES key register 7 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000034</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>key bits 255..224 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'aes_din': 0xFF080338-->
          <name>aes_din</name>
          <description>AES FIFO input Unlike all other registers, this address can be written with DWord(32 Bit), Word(16 Bit) or Byte acccss. The FIFO controller will automatically collect data and start AES-calculation, if enough data (4 DWords) are collected. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000038</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'aes_dout': 0xFF08033C-->
          <name>aes_dout</name>
          <description>AES FIFO output </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000003C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>random</name>
      <description>random</description>
      <baseAddress>0xFF080340</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>8</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <!--Absolute address of 'random_init': 0xFF080340-->
          <name>random_init</name>
          <description>Random initialization value: Write a value depending on Chip ID to this register to generate a random sequence different for each netX. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x55555555</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>random init value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'random_random': 0xFF080344-->
          <name>random_random</name>
          <description>Random value: This random value sequence is derived from many random events inside netX chip. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>random value </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>mtgy</name>
      <description>mtgy</description>
      <baseAddress>0xFF082000</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>8192</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>mtgy</name>
        <value>29</value>
      </interrupt>
      <registers>
        <register>
          <!--Absolute address of 'mtgy_cmd': 0xFF082000-->
          <name>mtgy_cmd</name>
          <description>MWMM command register: </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000094</resetValue>
          <resetMask>0xFFFFFFF7</resetMask>
          <fields>
            <field>
              <name>src_addr_x</name>
              <bitRange>[31:27]</bitRange>
              <description>Source address X specification. The source address X specification will be interpreted as vertical RAM location source address offset of auxiliary operand E. </description>
            </field>
            <field>
              <name>src_addr_e</name>
              <bitRange>[26:22]</bitRange>
              <description>Source Address E specification. The source address E specification will be interpreted as vertical RAM location source address offset of exponent E. </description>
            </field>
            <field>
              <name>dest_addr</name>
              <bitRange>[21:17]</bitRange>
              <description>Destination Address / Source Address A specification. Depending on the operation the destination address specification will be interpreted as horizontal or vertical RAM location offset or as vertical RAM location source address offset of operand A. </description>
            </field>
            <field>
              <name>src_addr</name>
              <bitRange>[16:12]</bitRange>
              <description>Source Address specification. Depending on the operation the source address specification will be interpreted as horizontal or vertical RAM location offset. </description>
            </field>
            <field>
              <name>op</name>
              <bitRange>[11:8]</bitRange>
              <description>The operation code of the core. Following operations codes are supported: 0: MontMult (Montgomery Multiplication Step) 1: MontR (Montgomery Parameter R) 2: MontR2 (Montgomery Parameter R2 ) 3: MontExp (Montgomery Exponentiation Step) 4: ModAdd (Modular Addition) 5: ModSub (Modular Subtraction) 6: CopyH2V (Copy from horizontal to vertical RAM location) 7: CopyV2V (Copy from vertical to vertical RAM location) 8: CopyH2H (Copy from horizontal to horizontal RAM location) 9: CopyV2H (Copy from vertical to horizontal RAM location) 10: MontMult1 (Montgomery Multiplication Step with '1' as A Operand) </description>
            </field>
            <field>
              <name>precision</name>
              <bitRange>[7:4]</bitRange>
              <description>Precision of executed operations. 0: 192 bit 1: 224 bit 2: 256 bit 3: 320 bit 4: 384 bit 5: 512 bit 6: 768 bit 7: 1024 bit 8: 1536 bit 9: 2048 bit 10: 3072 bit 11: 4096 bit 15 - 12: reserved </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:3]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>f_sel</name>
              <bitRange>[2:2]</bitRange>
              <description>Finite Field Selection signal. Defines if the calculations will be performed in 1: GF(p) or 0: GF(2^m). </description>
            </field>
            <field>
              <name>abort</name>
              <bitRange>[1:1]</bitRange>
              <description>Abort Signal of the MWMM Core. A running calculation can be aborted by issuing this signal. After writing '1', this bit will automatically be reset. </description>
            </field>
            <field>
              <name>start</name>
              <bitRange>[0:0]</bitRange>
              <description>Start Signal of the MWMM Core. Setting this signal will instruct the Core to start the operation given by 'op' with precision specified by 'precision'. Depending on the operation the core will use the RAM location specified by 'src_addr', 'dest_addr', 'src_addr_e' and 'src_addr_x'. Calculations will be performed in the underlying finite field specified by 'f_sel'. After writing '1', this bit will automatically be reset. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_stat': 0xFF082004-->
          <name>mtgy_stat</name>
          <description>MWMM status register: </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>done</name>
              <bitRange>[0:0]</bitRange>
              <description>Done signal from the MWMM core. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_irq_raw': 0xFF082008-->
          <name>mtgy_irq_raw</name>
          <description>MWMM raw IRQ: Read access shows status of unmasked IRQs.   IRQs are set automatically and reset by writing to this register: Write access with '1' resets the appropriate IRQ. Write access with '0' does not influence this bit. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>done</name>
              <bitRange>[0:0]</bitRange>
              <description>Done signal from the MWMM core. Only a posedge on this signal will set the interrupt. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_irq_masked': 0xFF08200C-->
          <name>mtgy_irq_masked</name>
          <description>MWMM masked IRQ: Shows status of masked IRQs. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>done</name>
              <bitRange>[0:0]</bitRange>
              <description>Done signal from the MWMM core. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_irq_msk_set': 0xFF082010-->
          <name>mtgy_irq_msk_set</name>
          <description>MWMM IRQ mask set: The IRQ mask enables interrupt requests for corresponding interrupt sources.   As its bits might be changed by different software tasks,   the IRQ mask register is not writable directly, but by set and reset masks: Write access with '1' sets interrupt mask bit. Write access with '0' does not influence this bit. Read access shows actual interrupt mask. Attention: Before activating interrupt mask, delete old pending interrupts by writing the same value to mtgy_irq_raw. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>done</name>
              <bitRange>[0:0]</bitRange>
              <description>Done signal from the MWMM core. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_irq_msk_reset': 0xFF082014-->
          <name>mtgy_irq_msk_reset</name>
          <description>MWMM IRQ mask reset: This is the corresponding reset mask to disable interrupt requests for corresponding interrupt sources: Write access with '1' resets interrupt mask bit. Write access with '0' does not influence this bit. Read access shows actual interrupt mask. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>done</name>
              <bitRange>[0:0]</bitRange>
              <description>Done signal from the MWMM core. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc0': 0xFF083000-->
          <name>mtgy_op_tc0</name>
          <description>MWMM TC register 0 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 31..0 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc1': 0xFF083004-->
          <name>mtgy_op_tc1</name>
          <description>MWMM TC register 1 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 63..32 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc2': 0xFF083008-->
          <name>mtgy_op_tc2</name>
          <description>MWMM TC register 2 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 95..64 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc3': 0xFF08300C-->
          <name>mtgy_op_tc3</name>
          <description>MWMM TC register 3 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000100C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 127..96 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc4': 0xFF083010-->
          <name>mtgy_op_tc4</name>
          <description>MWMM TC register 4 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 159..128 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc5': 0xFF083014-->
          <name>mtgy_op_tc5</name>
          <description>MWMM TC register 5 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 191..160 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc6': 0xFF083018-->
          <name>mtgy_op_tc6</name>
          <description>MWMM TC register 6 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001018</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 223..192 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc7': 0xFF08301C-->
          <name>mtgy_op_tc7</name>
          <description>MWMM TC register 7 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000101C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 255..224 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc8': 0xFF083020-->
          <name>mtgy_op_tc8</name>
          <description>MWMM TC register 8 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 287..256 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc9': 0xFF083024-->
          <name>mtgy_op_tc9</name>
          <description>MWMM TC register 9 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001024</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 319..288 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc10': 0xFF083028-->
          <name>mtgy_op_tc10</name>
          <description>MWMM TC register 10 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001028</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 351..320 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc11': 0xFF08302C-->
          <name>mtgy_op_tc11</name>
          <description>MWMM TC register 11 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000102C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 383..352 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc12': 0xFF083030-->
          <name>mtgy_op_tc12</name>
          <description>MWMM TC register 12 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001030</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 415..384 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc13': 0xFF083034-->
          <name>mtgy_op_tc13</name>
          <description>MWMM TC register 13 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001034</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 447..416 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc14': 0xFF083038-->
          <name>mtgy_op_tc14</name>
          <description>MWMM TC register 14 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001038</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 479..448 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc15': 0xFF08303C-->
          <name>mtgy_op_tc15</name>
          <description>MWMM TC register 15 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000103C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 511..480 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc16': 0xFF083040-->
          <name>mtgy_op_tc16</name>
          <description>MWMM TC register 16 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001040</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 543..512 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc17': 0xFF083044-->
          <name>mtgy_op_tc17</name>
          <description>MWMM TC register 17 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001044</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 575..544 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc18': 0xFF083048-->
          <name>mtgy_op_tc18</name>
          <description>MWMM TC register 18 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001048</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 607..576 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc19': 0xFF08304C-->
          <name>mtgy_op_tc19</name>
          <description>MWMM TC register 19 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000104C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 639..608 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc20': 0xFF083050-->
          <name>mtgy_op_tc20</name>
          <description>MWMM TC register 20 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001050</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 671..640 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc21': 0xFF083054-->
          <name>mtgy_op_tc21</name>
          <description>MWMM TC register 21 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001054</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 703..672 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc22': 0xFF083058-->
          <name>mtgy_op_tc22</name>
          <description>MWMM TC register 22 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001058</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 735..704 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc23': 0xFF08305C-->
          <name>mtgy_op_tc23</name>
          <description>MWMM TC register 23 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000105C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 767..736 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc24': 0xFF083060-->
          <name>mtgy_op_tc24</name>
          <description>MWMM TC register 24 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001060</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 799..768 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc25': 0xFF083064-->
          <name>mtgy_op_tc25</name>
          <description>MWMM TC register 25 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001064</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 831..800 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc26': 0xFF083068-->
          <name>mtgy_op_tc26</name>
          <description>MWMM TC register 26 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001068</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 863..832 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc27': 0xFF08306C-->
          <name>mtgy_op_tc27</name>
          <description>MWMM TC register 27 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000106C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 895..864 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc28': 0xFF083070-->
          <name>mtgy_op_tc28</name>
          <description>MWMM TC register 28 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001070</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 927..896 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc29': 0xFF083074-->
          <name>mtgy_op_tc29</name>
          <description>MWMM TC register 29 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001074</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 959..928 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc30': 0xFF083078-->
          <name>mtgy_op_tc30</name>
          <description>MWMM TC register 30 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001078</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 991..960 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc31': 0xFF08307C-->
          <name>mtgy_op_tc31</name>
          <description>MWMM TC register 31 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000107C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1023..992 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc32': 0xFF083080-->
          <name>mtgy_op_tc32</name>
          <description>MWMM TC register 32 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001080</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1055..1024 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc33': 0xFF083084-->
          <name>mtgy_op_tc33</name>
          <description>MWMM TC register 33 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001084</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1087..1056 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc34': 0xFF083088-->
          <name>mtgy_op_tc34</name>
          <description>MWMM TC register 34 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001088</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1119..1088 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc35': 0xFF08308C-->
          <name>mtgy_op_tc35</name>
          <description>MWMM TC register 35 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000108C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1151..1120 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc36': 0xFF083090-->
          <name>mtgy_op_tc36</name>
          <description>MWMM TC register 36 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001090</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1183..1152 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc37': 0xFF083094-->
          <name>mtgy_op_tc37</name>
          <description>MWMM TC register 37 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001094</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1215..1184 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc38': 0xFF083098-->
          <name>mtgy_op_tc38</name>
          <description>MWMM TC register 38 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001098</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1247..1216 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc39': 0xFF08309C-->
          <name>mtgy_op_tc39</name>
          <description>MWMM TC register 39 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000109C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1279..1248 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc40': 0xFF0830A0-->
          <name>mtgy_op_tc40</name>
          <description>MWMM TC register 40 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000010A0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1311..1280 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc41': 0xFF0830A4-->
          <name>mtgy_op_tc41</name>
          <description>MWMM TC register 41 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000010A4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1343..1312 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc42': 0xFF0830A8-->
          <name>mtgy_op_tc42</name>
          <description>MWMM TC register 42 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000010A8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1375..1344 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc43': 0xFF0830AC-->
          <name>mtgy_op_tc43</name>
          <description>MWMM TC register 43 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000010AC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1407..1376 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc44': 0xFF0830B0-->
          <name>mtgy_op_tc44</name>
          <description>MWMM TC register 44 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000010B0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1439..1408 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc45': 0xFF0830B4-->
          <name>mtgy_op_tc45</name>
          <description>MWMM TC register 45 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000010B4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1471..1440 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc46': 0xFF0830B8-->
          <name>mtgy_op_tc46</name>
          <description>MWMM TC register 46 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000010B8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1503..1472 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc47': 0xFF0830BC-->
          <name>mtgy_op_tc47</name>
          <description>MWMM TC register 47 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000010BC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1535..1504 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc48': 0xFF0830C0-->
          <name>mtgy_op_tc48</name>
          <description>MWMM TC register 48 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000010C0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1567..1536 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc49': 0xFF0830C4-->
          <name>mtgy_op_tc49</name>
          <description>MWMM TC register 49 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000010C4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1599..1568 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc50': 0xFF0830C8-->
          <name>mtgy_op_tc50</name>
          <description>MWMM TC register 50 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000010C8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1631..1600 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc51': 0xFF0830CC-->
          <name>mtgy_op_tc51</name>
          <description>MWMM TC register 51 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000010CC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1663..1632 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc52': 0xFF0830D0-->
          <name>mtgy_op_tc52</name>
          <description>MWMM TC register 52 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000010D0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1695..1664 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc53': 0xFF0830D4-->
          <name>mtgy_op_tc53</name>
          <description>MWMM TC register 53 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000010D4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1727..1696 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc54': 0xFF0830D8-->
          <name>mtgy_op_tc54</name>
          <description>MWMM TC register 54 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000010D8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1759..1728 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc55': 0xFF0830DC-->
          <name>mtgy_op_tc55</name>
          <description>MWMM TC register 55 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000010DC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1791..1760 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc56': 0xFF0830E0-->
          <name>mtgy_op_tc56</name>
          <description>MWMM TC register 56 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000010E0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1823..1792 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc57': 0xFF0830E4-->
          <name>mtgy_op_tc57</name>
          <description>MWMM TC register 57 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000010E4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1855..1824 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc58': 0xFF0830E8-->
          <name>mtgy_op_tc58</name>
          <description>MWMM TC register 58 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000010E8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1887..1856 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc59': 0xFF0830EC-->
          <name>mtgy_op_tc59</name>
          <description>MWMM TC register 59 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000010EC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1919..1888 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc60': 0xFF0830F0-->
          <name>mtgy_op_tc60</name>
          <description>MWMM TC register 60 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000010F0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1951..1920 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc61': 0xFF0830F4-->
          <name>mtgy_op_tc61</name>
          <description>MWMM TC register 61 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000010F4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1983..1952 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc62': 0xFF0830F8-->
          <name>mtgy_op_tc62</name>
          <description>MWMM TC register 62 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000010F8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2015..1984 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc63': 0xFF0830FC-->
          <name>mtgy_op_tc63</name>
          <description>MWMM TC register 63 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000010FC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2047..2016 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc64': 0xFF083100-->
          <name>mtgy_op_tc64</name>
          <description>MWMM TC register 64 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2079..2048 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc65': 0xFF083104-->
          <name>mtgy_op_tc65</name>
          <description>MWMM TC register 65 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001104</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2111..2080 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc66': 0xFF083108-->
          <name>mtgy_op_tc66</name>
          <description>MWMM TC register 66 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001108</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2143..2112 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc67': 0xFF08310C-->
          <name>mtgy_op_tc67</name>
          <description>MWMM TC register 67 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000110C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2175..2144 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc68': 0xFF083110-->
          <name>mtgy_op_tc68</name>
          <description>MWMM TC register 68 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001110</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2207..2176 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc69': 0xFF083114-->
          <name>mtgy_op_tc69</name>
          <description>MWMM TC register 69 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001114</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2239..2208 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc70': 0xFF083118-->
          <name>mtgy_op_tc70</name>
          <description>MWMM TC register 70 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001118</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2271..2240 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc71': 0xFF08311C-->
          <name>mtgy_op_tc71</name>
          <description>MWMM TC register 71 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000111C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2303..2272 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc72': 0xFF083120-->
          <name>mtgy_op_tc72</name>
          <description>MWMM TC register 72 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001120</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2335..2304 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc73': 0xFF083124-->
          <name>mtgy_op_tc73</name>
          <description>MWMM TC register 73 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001124</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2367..2336 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc74': 0xFF083128-->
          <name>mtgy_op_tc74</name>
          <description>MWMM TC register 74 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001128</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2399..2368 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc75': 0xFF08312C-->
          <name>mtgy_op_tc75</name>
          <description>MWMM TC register 75 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000112C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2431..2400 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc76': 0xFF083130-->
          <name>mtgy_op_tc76</name>
          <description>MWMM TC register 76 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001130</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2463..2432 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc77': 0xFF083134-->
          <name>mtgy_op_tc77</name>
          <description>MWMM TC register 77 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001134</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2495..2464 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc78': 0xFF083138-->
          <name>mtgy_op_tc78</name>
          <description>MWMM TC register 78 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001138</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2527..2496 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc79': 0xFF08313C-->
          <name>mtgy_op_tc79</name>
          <description>MWMM TC register 79 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000113C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2559..2528 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc80': 0xFF083140-->
          <name>mtgy_op_tc80</name>
          <description>MWMM TC register 80 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001140</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2591..2560 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc81': 0xFF083144-->
          <name>mtgy_op_tc81</name>
          <description>MWMM TC register 81 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001144</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2623..2592 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc82': 0xFF083148-->
          <name>mtgy_op_tc82</name>
          <description>MWMM TC register 82 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001148</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2655..2624 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc83': 0xFF08314C-->
          <name>mtgy_op_tc83</name>
          <description>MWMM TC register 83 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000114C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2687..2656 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc84': 0xFF083150-->
          <name>mtgy_op_tc84</name>
          <description>MWMM TC register 84 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001150</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2719..2688 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc85': 0xFF083154-->
          <name>mtgy_op_tc85</name>
          <description>MWMM TC register 85 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001154</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2751..2720 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc86': 0xFF083158-->
          <name>mtgy_op_tc86</name>
          <description>MWMM TC register 86 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001158</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2783..2752 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc87': 0xFF08315C-->
          <name>mtgy_op_tc87</name>
          <description>MWMM TC register 87 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000115C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2815..2784 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc88': 0xFF083160-->
          <name>mtgy_op_tc88</name>
          <description>MWMM TC register 88 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001160</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2847..2816 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc89': 0xFF083164-->
          <name>mtgy_op_tc89</name>
          <description>MWMM TC register 89 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001164</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2879..2848 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc90': 0xFF083168-->
          <name>mtgy_op_tc90</name>
          <description>MWMM TC register 90 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001168</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2911..2880 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc91': 0xFF08316C-->
          <name>mtgy_op_tc91</name>
          <description>MWMM TC register 91 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000116C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2943..2912 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc92': 0xFF083170-->
          <name>mtgy_op_tc92</name>
          <description>MWMM TC register 92 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001170</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2975..2944 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc93': 0xFF083174-->
          <name>mtgy_op_tc93</name>
          <description>MWMM TC register 93 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001174</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3007..2976 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc94': 0xFF083178-->
          <name>mtgy_op_tc94</name>
          <description>MWMM TC register 94 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001178</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3039..3008 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc95': 0xFF08317C-->
          <name>mtgy_op_tc95</name>
          <description>MWMM TC register 95 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000117C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3071..3040 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc96': 0xFF083180-->
          <name>mtgy_op_tc96</name>
          <description>MWMM TC register 96 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001180</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3103..3072 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc97': 0xFF083184-->
          <name>mtgy_op_tc97</name>
          <description>MWMM TC register 97 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001184</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3135..3104 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc98': 0xFF083188-->
          <name>mtgy_op_tc98</name>
          <description>MWMM TC register 98 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001188</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3167..3136 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc99': 0xFF08318C-->
          <name>mtgy_op_tc99</name>
          <description>MWMM TC register 99 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000118C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3199..3168 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc100': 0xFF083190-->
          <name>mtgy_op_tc100</name>
          <description>MWMM TC register 100 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001190</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3231..3200 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc101': 0xFF083194-->
          <name>mtgy_op_tc101</name>
          <description>MWMM TC register 101 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001194</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3263..3232 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc102': 0xFF083198-->
          <name>mtgy_op_tc102</name>
          <description>MWMM TC register 102 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001198</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3295..3264 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc103': 0xFF08319C-->
          <name>mtgy_op_tc103</name>
          <description>MWMM TC register 103 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000119C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3327..3296 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc104': 0xFF0831A0-->
          <name>mtgy_op_tc104</name>
          <description>MWMM TC register 104 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000011A0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3359..3328 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc105': 0xFF0831A4-->
          <name>mtgy_op_tc105</name>
          <description>MWMM TC register 105 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000011A4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3391..3360 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc106': 0xFF0831A8-->
          <name>mtgy_op_tc106</name>
          <description>MWMM TC register 106 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000011A8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3423..3392 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc107': 0xFF0831AC-->
          <name>mtgy_op_tc107</name>
          <description>MWMM TC register 107 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000011AC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3455..3424 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc108': 0xFF0831B0-->
          <name>mtgy_op_tc108</name>
          <description>MWMM TC register 108 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000011B0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3487..3456 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc109': 0xFF0831B4-->
          <name>mtgy_op_tc109</name>
          <description>MWMM TC register 109 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000011B4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3519..3488 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc110': 0xFF0831B8-->
          <name>mtgy_op_tc110</name>
          <description>MWMM TC register 110 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000011B8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3551..3520 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc111': 0xFF0831BC-->
          <name>mtgy_op_tc111</name>
          <description>MWMM TC register 111 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000011BC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3583..3552 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc112': 0xFF0831C0-->
          <name>mtgy_op_tc112</name>
          <description>MWMM TC register 112 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000011C0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3615..3584 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc113': 0xFF0831C4-->
          <name>mtgy_op_tc113</name>
          <description>MWMM TC register 113 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000011C4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3647..3616 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc114': 0xFF0831C8-->
          <name>mtgy_op_tc114</name>
          <description>MWMM TC register 114 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000011C8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3679..3648 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc115': 0xFF0831CC-->
          <name>mtgy_op_tc115</name>
          <description>MWMM TC register 115 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000011CC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3711..3680 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc116': 0xFF0831D0-->
          <name>mtgy_op_tc116</name>
          <description>MWMM TC register 116 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000011D0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3743..3712 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc117': 0xFF0831D4-->
          <name>mtgy_op_tc117</name>
          <description>MWMM TC register 117 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000011D4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3775..3744 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc118': 0xFF0831D8-->
          <name>mtgy_op_tc118</name>
          <description>MWMM TC register 118 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000011D8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3807..3776 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc119': 0xFF0831DC-->
          <name>mtgy_op_tc119</name>
          <description>MWMM TC register 119 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000011DC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3839..3808 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc120': 0xFF0831E0-->
          <name>mtgy_op_tc120</name>
          <description>MWMM TC register 120 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000011E0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3871..3840 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc121': 0xFF0831E4-->
          <name>mtgy_op_tc121</name>
          <description>MWMM TC register 121 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000011E4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3903..3872 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc122': 0xFF0831E8-->
          <name>mtgy_op_tc122</name>
          <description>MWMM TC register 122 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000011E8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3935..3904 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc123': 0xFF0831EC-->
          <name>mtgy_op_tc123</name>
          <description>MWMM TC register 123 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000011EC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3967..3936 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc124': 0xFF0831F0-->
          <name>mtgy_op_tc124</name>
          <description>MWMM TC register 124 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000011F0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3999..3968 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc125': 0xFF0831F4-->
          <name>mtgy_op_tc125</name>
          <description>MWMM TC register 125 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000011F4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 4031..4000 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc126': 0xFF0831F8-->
          <name>mtgy_op_tc126</name>
          <description>MWMM TC register 126 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000011F8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 4063..4032 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_tc127': 0xFF0831FC-->
          <name>mtgy_op_tc127</name>
          <description>MWMM TC register 127 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000011FC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 4095..4064 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts0': 0xFF083200-->
          <name>mtgy_op_ts0</name>
          <description>MWMM TS register 0 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 31..0 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts1': 0xFF083204-->
          <name>mtgy_op_ts1</name>
          <description>MWMM TS register 1 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001204</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 63..32 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts2': 0xFF083208-->
          <name>mtgy_op_ts2</name>
          <description>MWMM TS register 2 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001208</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 95..64 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts3': 0xFF08320C-->
          <name>mtgy_op_ts3</name>
          <description>MWMM TS register 3 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000120C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 127..96 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts4': 0xFF083210-->
          <name>mtgy_op_ts4</name>
          <description>MWMM TS register 4 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001210</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 159..128 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts5': 0xFF083214-->
          <name>mtgy_op_ts5</name>
          <description>MWMM TS register 5 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001214</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 191..160 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts6': 0xFF083218-->
          <name>mtgy_op_ts6</name>
          <description>MWMM TS register 6 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001218</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 223..192 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts7': 0xFF08321C-->
          <name>mtgy_op_ts7</name>
          <description>MWMM TS register 7 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000121C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 255..224 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts8': 0xFF083220-->
          <name>mtgy_op_ts8</name>
          <description>MWMM TS register 8 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001220</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 287..256 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts9': 0xFF083224-->
          <name>mtgy_op_ts9</name>
          <description>MWMM TS register 9 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001224</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 319..288 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts10': 0xFF083228-->
          <name>mtgy_op_ts10</name>
          <description>MWMM TS register 10 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001228</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 351..320 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts11': 0xFF08322C-->
          <name>mtgy_op_ts11</name>
          <description>MWMM TS register 11 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000122C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 383..352 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts12': 0xFF083230-->
          <name>mtgy_op_ts12</name>
          <description>MWMM TS register 12 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001230</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 415..384 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts13': 0xFF083234-->
          <name>mtgy_op_ts13</name>
          <description>MWMM TS register 13 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001234</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 447..416 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts14': 0xFF083238-->
          <name>mtgy_op_ts14</name>
          <description>MWMM TS register 14 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001238</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 479..448 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts15': 0xFF08323C-->
          <name>mtgy_op_ts15</name>
          <description>MWMM TS register 15 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000123C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 511..480 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts16': 0xFF083240-->
          <name>mtgy_op_ts16</name>
          <description>MWMM TS register 16 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001240</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 543..512 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts17': 0xFF083244-->
          <name>mtgy_op_ts17</name>
          <description>MWMM TS register 17 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001244</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 575..544 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts18': 0xFF083248-->
          <name>mtgy_op_ts18</name>
          <description>MWMM TS register 18 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001248</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 607..576 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts19': 0xFF08324C-->
          <name>mtgy_op_ts19</name>
          <description>MWMM TS register 19 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000124C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 639..608 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts20': 0xFF083250-->
          <name>mtgy_op_ts20</name>
          <description>MWMM TS register 20 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001250</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 671..640 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts21': 0xFF083254-->
          <name>mtgy_op_ts21</name>
          <description>MWMM TS register 21 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001254</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 703..672 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts22': 0xFF083258-->
          <name>mtgy_op_ts22</name>
          <description>MWMM TS register 22 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001258</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 735..704 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts23': 0xFF08325C-->
          <name>mtgy_op_ts23</name>
          <description>MWMM TS register 23 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000125C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 767..736 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts24': 0xFF083260-->
          <name>mtgy_op_ts24</name>
          <description>MWMM TS register 24 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001260</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 799..768 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts25': 0xFF083264-->
          <name>mtgy_op_ts25</name>
          <description>MWMM TS register 25 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001264</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 831..800 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts26': 0xFF083268-->
          <name>mtgy_op_ts26</name>
          <description>MWMM TS register 26 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001268</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 863..832 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts27': 0xFF08326C-->
          <name>mtgy_op_ts27</name>
          <description>MWMM TS register 27 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000126C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 895..864 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts28': 0xFF083270-->
          <name>mtgy_op_ts28</name>
          <description>MWMM TS register 28 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001270</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 927..896 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts29': 0xFF083274-->
          <name>mtgy_op_ts29</name>
          <description>MWMM TS register 29 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001274</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 959..928 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts30': 0xFF083278-->
          <name>mtgy_op_ts30</name>
          <description>MWMM TS register 30 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001278</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 991..960 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts31': 0xFF08327C-->
          <name>mtgy_op_ts31</name>
          <description>MWMM TS register 31 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000127C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1023..992 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts32': 0xFF083280-->
          <name>mtgy_op_ts32</name>
          <description>MWMM TS register 32 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001280</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1055..1024 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts33': 0xFF083284-->
          <name>mtgy_op_ts33</name>
          <description>MWMM TS register 33 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001284</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1087..1056 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts34': 0xFF083288-->
          <name>mtgy_op_ts34</name>
          <description>MWMM TS register 34 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001288</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1119..1088 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts35': 0xFF08328C-->
          <name>mtgy_op_ts35</name>
          <description>MWMM TS register 35 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000128C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1151..1120 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts36': 0xFF083290-->
          <name>mtgy_op_ts36</name>
          <description>MWMM TS register 36 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001290</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1183..1152 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts37': 0xFF083294-->
          <name>mtgy_op_ts37</name>
          <description>MWMM TS register 37 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001294</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1215..1184 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts38': 0xFF083298-->
          <name>mtgy_op_ts38</name>
          <description>MWMM TS register 38 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001298</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1247..1216 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts39': 0xFF08329C-->
          <name>mtgy_op_ts39</name>
          <description>MWMM TS register 39 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000129C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1279..1248 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts40': 0xFF0832A0-->
          <name>mtgy_op_ts40</name>
          <description>MWMM TS register 40 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000012A0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1311..1280 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts41': 0xFF0832A4-->
          <name>mtgy_op_ts41</name>
          <description>MWMM TS register 41 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000012A4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1343..1312 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts42': 0xFF0832A8-->
          <name>mtgy_op_ts42</name>
          <description>MWMM TS register 42 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000012A8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1375..1344 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts43': 0xFF0832AC-->
          <name>mtgy_op_ts43</name>
          <description>MWMM TS register 43 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000012AC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1407..1376 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts44': 0xFF0832B0-->
          <name>mtgy_op_ts44</name>
          <description>MWMM TS register 44 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000012B0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1439..1408 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts45': 0xFF0832B4-->
          <name>mtgy_op_ts45</name>
          <description>MWMM TS register 45 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000012B4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1471..1440 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts46': 0xFF0832B8-->
          <name>mtgy_op_ts46</name>
          <description>MWMM TS register 46 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000012B8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1503..1472 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts47': 0xFF0832BC-->
          <name>mtgy_op_ts47</name>
          <description>MWMM TS register 47 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000012BC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1535..1504 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts48': 0xFF0832C0-->
          <name>mtgy_op_ts48</name>
          <description>MWMM TS register 48 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000012C0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1567..1536 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts49': 0xFF0832C4-->
          <name>mtgy_op_ts49</name>
          <description>MWMM TS register 49 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000012C4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1599..1568 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts50': 0xFF0832C8-->
          <name>mtgy_op_ts50</name>
          <description>MWMM TS register 50 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000012C8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1631..1600 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts51': 0xFF0832CC-->
          <name>mtgy_op_ts51</name>
          <description>MWMM TS register 51 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000012CC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1663..1632 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts52': 0xFF0832D0-->
          <name>mtgy_op_ts52</name>
          <description>MWMM TS register 52 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000012D0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1695..1664 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts53': 0xFF0832D4-->
          <name>mtgy_op_ts53</name>
          <description>MWMM TS register 53 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000012D4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1727..1696 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts54': 0xFF0832D8-->
          <name>mtgy_op_ts54</name>
          <description>MWMM TS register 54 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000012D8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1759..1728 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts55': 0xFF0832DC-->
          <name>mtgy_op_ts55</name>
          <description>MWMM TS register 55 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000012DC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1791..1760 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts56': 0xFF0832E0-->
          <name>mtgy_op_ts56</name>
          <description>MWMM TS register 56 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000012E0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1823..1792 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts57': 0xFF0832E4-->
          <name>mtgy_op_ts57</name>
          <description>MWMM TS register 57 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000012E4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1855..1824 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts58': 0xFF0832E8-->
          <name>mtgy_op_ts58</name>
          <description>MWMM TS register 58 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000012E8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1887..1856 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts59': 0xFF0832EC-->
          <name>mtgy_op_ts59</name>
          <description>MWMM TS register 59 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000012EC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1919..1888 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts60': 0xFF0832F0-->
          <name>mtgy_op_ts60</name>
          <description>MWMM TS register 60 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000012F0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1951..1920 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts61': 0xFF0832F4-->
          <name>mtgy_op_ts61</name>
          <description>MWMM TS register 61 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000012F4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1983..1952 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts62': 0xFF0832F8-->
          <name>mtgy_op_ts62</name>
          <description>MWMM TS register 62 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000012F8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2015..1984 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts63': 0xFF0832FC-->
          <name>mtgy_op_ts63</name>
          <description>MWMM TS register 63 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000012FC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2047..2016 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts64': 0xFF083300-->
          <name>mtgy_op_ts64</name>
          <description>MWMM TS register 64 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2079..2048 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts65': 0xFF083304-->
          <name>mtgy_op_ts65</name>
          <description>MWMM TS register 65 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001304</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2111..2080 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts66': 0xFF083308-->
          <name>mtgy_op_ts66</name>
          <description>MWMM TS register 66 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001308</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2143..2112 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts67': 0xFF08330C-->
          <name>mtgy_op_ts67</name>
          <description>MWMM TS register 67 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000130C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2175..2144 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts68': 0xFF083310-->
          <name>mtgy_op_ts68</name>
          <description>MWMM TS register 68 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001310</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2207..2176 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts69': 0xFF083314-->
          <name>mtgy_op_ts69</name>
          <description>MWMM TS register 69 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001314</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2239..2208 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts70': 0xFF083318-->
          <name>mtgy_op_ts70</name>
          <description>MWMM TS register 70 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001318</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2271..2240 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts71': 0xFF08331C-->
          <name>mtgy_op_ts71</name>
          <description>MWMM TS register 71 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000131C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2303..2272 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts72': 0xFF083320-->
          <name>mtgy_op_ts72</name>
          <description>MWMM TS register 72 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001320</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2335..2304 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts73': 0xFF083324-->
          <name>mtgy_op_ts73</name>
          <description>MWMM TS register 73 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001324</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2367..2336 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts74': 0xFF083328-->
          <name>mtgy_op_ts74</name>
          <description>MWMM TS register 74 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001328</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2399..2368 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts75': 0xFF08332C-->
          <name>mtgy_op_ts75</name>
          <description>MWMM TS register 75 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000132C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2431..2400 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts76': 0xFF083330-->
          <name>mtgy_op_ts76</name>
          <description>MWMM TS register 76 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001330</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2463..2432 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts77': 0xFF083334-->
          <name>mtgy_op_ts77</name>
          <description>MWMM TS register 77 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001334</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2495..2464 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts78': 0xFF083338-->
          <name>mtgy_op_ts78</name>
          <description>MWMM TS register 78 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001338</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2527..2496 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts79': 0xFF08333C-->
          <name>mtgy_op_ts79</name>
          <description>MWMM TS register 79 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000133C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2559..2528 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts80': 0xFF083340-->
          <name>mtgy_op_ts80</name>
          <description>MWMM TS register 80 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001340</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2591..2560 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts81': 0xFF083344-->
          <name>mtgy_op_ts81</name>
          <description>MWMM TS register 81 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001344</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2623..2592 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts82': 0xFF083348-->
          <name>mtgy_op_ts82</name>
          <description>MWMM TS register 82 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001348</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2655..2624 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts83': 0xFF08334C-->
          <name>mtgy_op_ts83</name>
          <description>MWMM TS register 83 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000134C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2687..2656 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts84': 0xFF083350-->
          <name>mtgy_op_ts84</name>
          <description>MWMM TS register 84 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001350</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2719..2688 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts85': 0xFF083354-->
          <name>mtgy_op_ts85</name>
          <description>MWMM TS register 85 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001354</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2751..2720 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts86': 0xFF083358-->
          <name>mtgy_op_ts86</name>
          <description>MWMM TS register 86 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001358</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2783..2752 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts87': 0xFF08335C-->
          <name>mtgy_op_ts87</name>
          <description>MWMM TS register 87 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000135C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2815..2784 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts88': 0xFF083360-->
          <name>mtgy_op_ts88</name>
          <description>MWMM TS register 88 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001360</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2847..2816 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts89': 0xFF083364-->
          <name>mtgy_op_ts89</name>
          <description>MWMM TS register 89 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001364</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2879..2848 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts90': 0xFF083368-->
          <name>mtgy_op_ts90</name>
          <description>MWMM TS register 90 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001368</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2911..2880 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts91': 0xFF08336C-->
          <name>mtgy_op_ts91</name>
          <description>MWMM TS register 91 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000136C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2943..2912 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts92': 0xFF083370-->
          <name>mtgy_op_ts92</name>
          <description>MWMM TS register 92 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001370</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2975..2944 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts93': 0xFF083374-->
          <name>mtgy_op_ts93</name>
          <description>MWMM TS register 93 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001374</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3007..2976 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts94': 0xFF083378-->
          <name>mtgy_op_ts94</name>
          <description>MWMM TS register 94 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001378</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3039..3008 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts95': 0xFF08337C-->
          <name>mtgy_op_ts95</name>
          <description>MWMM TS register 95 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000137C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3071..3040 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts96': 0xFF083380-->
          <name>mtgy_op_ts96</name>
          <description>MWMM TS register 96 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001380</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3103..3072 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts97': 0xFF083384-->
          <name>mtgy_op_ts97</name>
          <description>MWMM TS register 97 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001384</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3135..3104 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts98': 0xFF083388-->
          <name>mtgy_op_ts98</name>
          <description>MWMM TS register 98 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001388</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3167..3136 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts99': 0xFF08338C-->
          <name>mtgy_op_ts99</name>
          <description>MWMM TS register 99 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000138C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3199..3168 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts100': 0xFF083390-->
          <name>mtgy_op_ts100</name>
          <description>MWMM TS register 100 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001390</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3231..3200 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts101': 0xFF083394-->
          <name>mtgy_op_ts101</name>
          <description>MWMM TS register 101 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001394</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3263..3232 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts102': 0xFF083398-->
          <name>mtgy_op_ts102</name>
          <description>MWMM TS register 102 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001398</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3295..3264 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts103': 0xFF08339C-->
          <name>mtgy_op_ts103</name>
          <description>MWMM TS register 103 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000139C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3327..3296 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts104': 0xFF0833A0-->
          <name>mtgy_op_ts104</name>
          <description>MWMM TS register 104 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000013A0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3359..3328 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts105': 0xFF0833A4-->
          <name>mtgy_op_ts105</name>
          <description>MWMM TS register 105 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000013A4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3391..3360 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts106': 0xFF0833A8-->
          <name>mtgy_op_ts106</name>
          <description>MWMM TS register 106 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000013A8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3423..3392 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts107': 0xFF0833AC-->
          <name>mtgy_op_ts107</name>
          <description>MWMM TS register 107 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000013AC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3455..3424 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts108': 0xFF0833B0-->
          <name>mtgy_op_ts108</name>
          <description>MWMM TS register 108 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000013B0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3487..3456 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts109': 0xFF0833B4-->
          <name>mtgy_op_ts109</name>
          <description>MWMM TS register 109 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000013B4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3519..3488 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts110': 0xFF0833B8-->
          <name>mtgy_op_ts110</name>
          <description>MWMM TS register 110 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000013B8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3551..3520 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts111': 0xFF0833BC-->
          <name>mtgy_op_ts111</name>
          <description>MWMM TS register 111 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000013BC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3583..3552 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts112': 0xFF0833C0-->
          <name>mtgy_op_ts112</name>
          <description>MWMM TS register 112 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000013C0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3615..3584 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts113': 0xFF0833C4-->
          <name>mtgy_op_ts113</name>
          <description>MWMM TS register 113 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000013C4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3647..3616 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts114': 0xFF0833C8-->
          <name>mtgy_op_ts114</name>
          <description>MWMM TS register 114 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000013C8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3679..3648 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts115': 0xFF0833CC-->
          <name>mtgy_op_ts115</name>
          <description>MWMM TS register 115 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000013CC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3711..3680 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts116': 0xFF0833D0-->
          <name>mtgy_op_ts116</name>
          <description>MWMM TS register 116 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000013D0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3743..3712 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts117': 0xFF0833D4-->
          <name>mtgy_op_ts117</name>
          <description>MWMM TS register 117 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000013D4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3775..3744 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts118': 0xFF0833D8-->
          <name>mtgy_op_ts118</name>
          <description>MWMM TS register 118 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000013D8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3807..3776 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts119': 0xFF0833DC-->
          <name>mtgy_op_ts119</name>
          <description>MWMM TS register 119 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000013DC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3839..3808 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts120': 0xFF0833E0-->
          <name>mtgy_op_ts120</name>
          <description>MWMM TS register 120 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000013E0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3871..3840 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts121': 0xFF0833E4-->
          <name>mtgy_op_ts121</name>
          <description>MWMM TS register 121 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000013E4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3903..3872 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts122': 0xFF0833E8-->
          <name>mtgy_op_ts122</name>
          <description>MWMM TS register 122 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000013E8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3935..3904 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts123': 0xFF0833EC-->
          <name>mtgy_op_ts123</name>
          <description>MWMM TS register 123 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000013EC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3967..3936 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts124': 0xFF0833F0-->
          <name>mtgy_op_ts124</name>
          <description>MWMM TS register 124 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000013F0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3999..3968 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts125': 0xFF0833F4-->
          <name>mtgy_op_ts125</name>
          <description>MWMM TS register 125 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000013F4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 4031..4000 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts126': 0xFF0833F8-->
          <name>mtgy_op_ts126</name>
          <description>MWMM TS register 126 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000013F8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 4063..4032 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_ts127': 0xFF0833FC-->
          <name>mtgy_op_ts127</name>
          <description>MWMM TS register 127 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000013FC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 4095..4064 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p0': 0xFF083400-->
          <name>mtgy_op_p0</name>
          <description>MWMM operand P register 0 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001400</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 31..0 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p1': 0xFF083404-->
          <name>mtgy_op_p1</name>
          <description>MWMM operand P register 1 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001404</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 63..32 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p2': 0xFF083408-->
          <name>mtgy_op_p2</name>
          <description>MWMM operand P register 2 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001408</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 95..64 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p3': 0xFF08340C-->
          <name>mtgy_op_p3</name>
          <description>MWMM operand P register 3 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000140C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 127..96 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p4': 0xFF083410-->
          <name>mtgy_op_p4</name>
          <description>MWMM operand P register 4 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001410</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 159..128 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p5': 0xFF083414-->
          <name>mtgy_op_p5</name>
          <description>MWMM operand P register 5 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001414</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 191..160 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p6': 0xFF083418-->
          <name>mtgy_op_p6</name>
          <description>MWMM operand P register 6 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001418</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 223..192 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p7': 0xFF08341C-->
          <name>mtgy_op_p7</name>
          <description>MWMM operand P register 7 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000141C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 255..224 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p8': 0xFF083420-->
          <name>mtgy_op_p8</name>
          <description>MWMM operand P register 8 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001420</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 287..256 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p9': 0xFF083424-->
          <name>mtgy_op_p9</name>
          <description>MWMM operand P register 9 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001424</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 319..288 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p10': 0xFF083428-->
          <name>mtgy_op_p10</name>
          <description>MWMM operand P register 10 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001428</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 351..320 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p11': 0xFF08342C-->
          <name>mtgy_op_p11</name>
          <description>MWMM operand P register 11 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000142C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 383..352 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p12': 0xFF083430-->
          <name>mtgy_op_p12</name>
          <description>MWMM operand P register 12 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001430</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 415..384 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p13': 0xFF083434-->
          <name>mtgy_op_p13</name>
          <description>MWMM operand P register 13 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001434</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 447..416 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p14': 0xFF083438-->
          <name>mtgy_op_p14</name>
          <description>MWMM operand P register 14 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001438</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 479..448 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p15': 0xFF08343C-->
          <name>mtgy_op_p15</name>
          <description>MWMM operand P register 15 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000143C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 511..480 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p16': 0xFF083440-->
          <name>mtgy_op_p16</name>
          <description>MWMM operand P register 16 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001440</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 543..512 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p17': 0xFF083444-->
          <name>mtgy_op_p17</name>
          <description>MWMM operand P register 17 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001444</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 575..544 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p18': 0xFF083448-->
          <name>mtgy_op_p18</name>
          <description>MWMM operand P register 18 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001448</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 607..576 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p19': 0xFF08344C-->
          <name>mtgy_op_p19</name>
          <description>MWMM operand P register 19 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000144C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 639..608 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p20': 0xFF083450-->
          <name>mtgy_op_p20</name>
          <description>MWMM operand P register 20 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001450</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 671..640 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p21': 0xFF083454-->
          <name>mtgy_op_p21</name>
          <description>MWMM operand P register 21 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001454</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 703..672 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p22': 0xFF083458-->
          <name>mtgy_op_p22</name>
          <description>MWMM operand P register 22 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001458</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 735..704 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p23': 0xFF08345C-->
          <name>mtgy_op_p23</name>
          <description>MWMM operand P register 23 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000145C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 767..736 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p24': 0xFF083460-->
          <name>mtgy_op_p24</name>
          <description>MWMM operand P register 24 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001460</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 799..768 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p25': 0xFF083464-->
          <name>mtgy_op_p25</name>
          <description>MWMM operand P register 25 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001464</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 831..800 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p26': 0xFF083468-->
          <name>mtgy_op_p26</name>
          <description>MWMM operand P register 26 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001468</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 863..832 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p27': 0xFF08346C-->
          <name>mtgy_op_p27</name>
          <description>MWMM operand P register 27 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000146C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 895..864 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p28': 0xFF083470-->
          <name>mtgy_op_p28</name>
          <description>MWMM operand P register 28 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001470</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 927..896 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p29': 0xFF083474-->
          <name>mtgy_op_p29</name>
          <description>MWMM operand P register 29 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001474</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 959..928 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p30': 0xFF083478-->
          <name>mtgy_op_p30</name>
          <description>MWMM operand P register 30 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001478</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 991..960 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p31': 0xFF08347C-->
          <name>mtgy_op_p31</name>
          <description>MWMM operand P register 31 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000147C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1023..992 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p32': 0xFF083480-->
          <name>mtgy_op_p32</name>
          <description>MWMM operand P register 32 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001480</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1055..1024 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p33': 0xFF083484-->
          <name>mtgy_op_p33</name>
          <description>MWMM operand P register 33 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001484</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1087..1056 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p34': 0xFF083488-->
          <name>mtgy_op_p34</name>
          <description>MWMM operand P register 34 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001488</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1119..1088 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p35': 0xFF08348C-->
          <name>mtgy_op_p35</name>
          <description>MWMM operand P register 35 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000148C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1151..1120 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p36': 0xFF083490-->
          <name>mtgy_op_p36</name>
          <description>MWMM operand P register 36 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001490</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1183..1152 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p37': 0xFF083494-->
          <name>mtgy_op_p37</name>
          <description>MWMM operand P register 37 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001494</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1215..1184 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p38': 0xFF083498-->
          <name>mtgy_op_p38</name>
          <description>MWMM operand P register 38 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001498</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1247..1216 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p39': 0xFF08349C-->
          <name>mtgy_op_p39</name>
          <description>MWMM operand P register 39 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000149C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1279..1248 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p40': 0xFF0834A0-->
          <name>mtgy_op_p40</name>
          <description>MWMM operand P register 40 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000014A0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1311..1280 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p41': 0xFF0834A4-->
          <name>mtgy_op_p41</name>
          <description>MWMM operand P register 41 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000014A4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1343..1312 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p42': 0xFF0834A8-->
          <name>mtgy_op_p42</name>
          <description>MWMM operand P register 42 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000014A8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1375..1344 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p43': 0xFF0834AC-->
          <name>mtgy_op_p43</name>
          <description>MWMM operand P register 43 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000014AC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1407..1376 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p44': 0xFF0834B0-->
          <name>mtgy_op_p44</name>
          <description>MWMM operand P register 44 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000014B0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1439..1408 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p45': 0xFF0834B4-->
          <name>mtgy_op_p45</name>
          <description>MWMM operand P register 45 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000014B4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1471..1440 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p46': 0xFF0834B8-->
          <name>mtgy_op_p46</name>
          <description>MWMM operand P register 46 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000014B8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1503..1472 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p47': 0xFF0834BC-->
          <name>mtgy_op_p47</name>
          <description>MWMM operand P register 47 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000014BC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1535..1504 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p48': 0xFF0834C0-->
          <name>mtgy_op_p48</name>
          <description>MWMM operand P register 48 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000014C0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1567..1536 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p49': 0xFF0834C4-->
          <name>mtgy_op_p49</name>
          <description>MWMM operand P register 49 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000014C4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1599..1568 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p50': 0xFF0834C8-->
          <name>mtgy_op_p50</name>
          <description>MWMM operand P register 50 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000014C8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1631..1600 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p51': 0xFF0834CC-->
          <name>mtgy_op_p51</name>
          <description>MWMM operand P register 51 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000014CC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1663..1632 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p52': 0xFF0834D0-->
          <name>mtgy_op_p52</name>
          <description>MWMM operand P register 52 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000014D0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1695..1664 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p53': 0xFF0834D4-->
          <name>mtgy_op_p53</name>
          <description>MWMM operand P register 53 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000014D4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1727..1696 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p54': 0xFF0834D8-->
          <name>mtgy_op_p54</name>
          <description>MWMM operand P register 54 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000014D8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1759..1728 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p55': 0xFF0834DC-->
          <name>mtgy_op_p55</name>
          <description>MWMM operand P register 55 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000014DC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1791..1760 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p56': 0xFF0834E0-->
          <name>mtgy_op_p56</name>
          <description>MWMM operand P register 56 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000014E0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1823..1792 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p57': 0xFF0834E4-->
          <name>mtgy_op_p57</name>
          <description>MWMM operand P register 57 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000014E4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1855..1824 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p58': 0xFF0834E8-->
          <name>mtgy_op_p58</name>
          <description>MWMM operand P register 58 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000014E8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1887..1856 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p59': 0xFF0834EC-->
          <name>mtgy_op_p59</name>
          <description>MWMM operand P register 59 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000014EC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1919..1888 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p60': 0xFF0834F0-->
          <name>mtgy_op_p60</name>
          <description>MWMM operand P register 60 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000014F0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1951..1920 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p61': 0xFF0834F4-->
          <name>mtgy_op_p61</name>
          <description>MWMM operand P register 61 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000014F4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1983..1952 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p62': 0xFF0834F8-->
          <name>mtgy_op_p62</name>
          <description>MWMM operand P register 62 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000014F8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2015..1984 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p63': 0xFF0834FC-->
          <name>mtgy_op_p63</name>
          <description>MWMM operand P register 63 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000014FC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2047..2016 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p64': 0xFF083500-->
          <name>mtgy_op_p64</name>
          <description>MWMM operand P register 64 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001500</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2079..2048 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p65': 0xFF083504-->
          <name>mtgy_op_p65</name>
          <description>MWMM operand P register 65 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001504</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2111..2080 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p66': 0xFF083508-->
          <name>mtgy_op_p66</name>
          <description>MWMM operand P register 66 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001508</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2143..2112 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p67': 0xFF08350C-->
          <name>mtgy_op_p67</name>
          <description>MWMM operand P register 67 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000150C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2175..2144 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p68': 0xFF083510-->
          <name>mtgy_op_p68</name>
          <description>MWMM operand P register 68 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001510</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2207..2176 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p69': 0xFF083514-->
          <name>mtgy_op_p69</name>
          <description>MWMM operand P register 69 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001514</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2239..2208 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p70': 0xFF083518-->
          <name>mtgy_op_p70</name>
          <description>MWMM operand P register 70 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001518</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2271..2240 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p71': 0xFF08351C-->
          <name>mtgy_op_p71</name>
          <description>MWMM operand P register 71 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000151C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2303..2272 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p72': 0xFF083520-->
          <name>mtgy_op_p72</name>
          <description>MWMM operand P register 72 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001520</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2335..2304 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p73': 0xFF083524-->
          <name>mtgy_op_p73</name>
          <description>MWMM operand P register 73 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001524</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2367..2336 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p74': 0xFF083528-->
          <name>mtgy_op_p74</name>
          <description>MWMM operand P register 74 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001528</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2399..2368 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p75': 0xFF08352C-->
          <name>mtgy_op_p75</name>
          <description>MWMM operand P register 75 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000152C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2431..2400 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p76': 0xFF083530-->
          <name>mtgy_op_p76</name>
          <description>MWMM operand P register 76 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001530</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2463..2432 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p77': 0xFF083534-->
          <name>mtgy_op_p77</name>
          <description>MWMM operand P register 77 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001534</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2495..2464 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p78': 0xFF083538-->
          <name>mtgy_op_p78</name>
          <description>MWMM operand P register 78 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001538</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2527..2496 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p79': 0xFF08353C-->
          <name>mtgy_op_p79</name>
          <description>MWMM operand P register 79 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000153C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2559..2528 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p80': 0xFF083540-->
          <name>mtgy_op_p80</name>
          <description>MWMM operand P register 80 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001540</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2591..2560 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p81': 0xFF083544-->
          <name>mtgy_op_p81</name>
          <description>MWMM operand P register 81 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001544</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2623..2592 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p82': 0xFF083548-->
          <name>mtgy_op_p82</name>
          <description>MWMM operand P register 82 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001548</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2655..2624 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p83': 0xFF08354C-->
          <name>mtgy_op_p83</name>
          <description>MWMM operand P register 83 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000154C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2687..2656 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p84': 0xFF083550-->
          <name>mtgy_op_p84</name>
          <description>MWMM operand P register 84 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001550</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2719..2688 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p85': 0xFF083554-->
          <name>mtgy_op_p85</name>
          <description>MWMM operand P register 85 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001554</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2751..2720 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p86': 0xFF083558-->
          <name>mtgy_op_p86</name>
          <description>MWMM operand P register 86 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001558</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2783..2752 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p87': 0xFF08355C-->
          <name>mtgy_op_p87</name>
          <description>MWMM operand P register 87 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000155C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2815..2784 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p88': 0xFF083560-->
          <name>mtgy_op_p88</name>
          <description>MWMM operand P register 88 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001560</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2847..2816 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p89': 0xFF083564-->
          <name>mtgy_op_p89</name>
          <description>MWMM operand P register 89 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001564</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2879..2848 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p90': 0xFF083568-->
          <name>mtgy_op_p90</name>
          <description>MWMM operand P register 90 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001568</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2911..2880 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p91': 0xFF08356C-->
          <name>mtgy_op_p91</name>
          <description>MWMM operand P register 91 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000156C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2943..2912 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p92': 0xFF083570-->
          <name>mtgy_op_p92</name>
          <description>MWMM operand P register 92 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001570</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2975..2944 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p93': 0xFF083574-->
          <name>mtgy_op_p93</name>
          <description>MWMM operand P register 93 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001574</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3007..2976 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p94': 0xFF083578-->
          <name>mtgy_op_p94</name>
          <description>MWMM operand P register 94 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001578</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3039..3008 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p95': 0xFF08357C-->
          <name>mtgy_op_p95</name>
          <description>MWMM operand P register 95 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000157C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3071..3040 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p96': 0xFF083580-->
          <name>mtgy_op_p96</name>
          <description>MWMM operand P register 96 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001580</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3103..3072 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p97': 0xFF083584-->
          <name>mtgy_op_p97</name>
          <description>MWMM operand P register 97 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001584</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3135..3104 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p98': 0xFF083588-->
          <name>mtgy_op_p98</name>
          <description>MWMM operand P register 98 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001588</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3167..3136 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p99': 0xFF08358C-->
          <name>mtgy_op_p99</name>
          <description>MWMM operand P register 99 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000158C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3199..3168 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p100': 0xFF083590-->
          <name>mtgy_op_p100</name>
          <description>MWMM operand P register 100 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001590</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3231..3200 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p101': 0xFF083594-->
          <name>mtgy_op_p101</name>
          <description>MWMM operand P register 101 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001594</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3263..3232 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p102': 0xFF083598-->
          <name>mtgy_op_p102</name>
          <description>MWMM operand P register 102 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001598</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3295..3264 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p103': 0xFF08359C-->
          <name>mtgy_op_p103</name>
          <description>MWMM operand P register 103 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000159C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3327..3296 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p104': 0xFF0835A0-->
          <name>mtgy_op_p104</name>
          <description>MWMM operand P register 104 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000015A0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3359..3328 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p105': 0xFF0835A4-->
          <name>mtgy_op_p105</name>
          <description>MWMM operand P register 105 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000015A4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3391..3360 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p106': 0xFF0835A8-->
          <name>mtgy_op_p106</name>
          <description>MWMM operand P register 106 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000015A8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3423..3392 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p107': 0xFF0835AC-->
          <name>mtgy_op_p107</name>
          <description>MWMM operand P register 107 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000015AC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3455..3424 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p108': 0xFF0835B0-->
          <name>mtgy_op_p108</name>
          <description>MWMM operand P register 108 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000015B0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3487..3456 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p109': 0xFF0835B4-->
          <name>mtgy_op_p109</name>
          <description>MWMM operand P register 109 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000015B4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3519..3488 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p110': 0xFF0835B8-->
          <name>mtgy_op_p110</name>
          <description>MWMM operand P register 110 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000015B8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3551..3520 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p111': 0xFF0835BC-->
          <name>mtgy_op_p111</name>
          <description>MWMM operand P register 111 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000015BC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3583..3552 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p112': 0xFF0835C0-->
          <name>mtgy_op_p112</name>
          <description>MWMM operand P register 112 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000015C0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3615..3584 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p113': 0xFF0835C4-->
          <name>mtgy_op_p113</name>
          <description>MWMM operand P register 113 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000015C4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3647..3616 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p114': 0xFF0835C8-->
          <name>mtgy_op_p114</name>
          <description>MWMM operand P register 114 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000015C8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3679..3648 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p115': 0xFF0835CC-->
          <name>mtgy_op_p115</name>
          <description>MWMM operand P register 115 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000015CC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3711..3680 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p116': 0xFF0835D0-->
          <name>mtgy_op_p116</name>
          <description>MWMM operand P register 116 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000015D0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3743..3712 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p117': 0xFF0835D4-->
          <name>mtgy_op_p117</name>
          <description>MWMM operand P register 117 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000015D4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3775..3744 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p118': 0xFF0835D8-->
          <name>mtgy_op_p118</name>
          <description>MWMM operand P register 118 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000015D8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3807..3776 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p119': 0xFF0835DC-->
          <name>mtgy_op_p119</name>
          <description>MWMM operand P register 119 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000015DC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3839..3808 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p120': 0xFF0835E0-->
          <name>mtgy_op_p120</name>
          <description>MWMM operand P register 120 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000015E0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3871..3840 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p121': 0xFF0835E4-->
          <name>mtgy_op_p121</name>
          <description>MWMM operand P register 121 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000015E4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3903..3872 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p122': 0xFF0835E8-->
          <name>mtgy_op_p122</name>
          <description>MWMM operand P register 122 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000015E8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3935..3904 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p123': 0xFF0835EC-->
          <name>mtgy_op_p123</name>
          <description>MWMM operand P register 123 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000015EC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3967..3936 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p124': 0xFF0835F0-->
          <name>mtgy_op_p124</name>
          <description>MWMM operand P register 124 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000015F0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3999..3968 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p125': 0xFF0835F4-->
          <name>mtgy_op_p125</name>
          <description>MWMM operand P register 125 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000015F4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 4031..4000 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p126': 0xFF0835F8-->
          <name>mtgy_op_p126</name>
          <description>MWMM operand P register 126 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000015F8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 4063..4032 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_p127': 0xFF0835FC-->
          <name>mtgy_op_p127</name>
          <description>MWMM operand P register 127 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000015FC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 4095..4064 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b0': 0xFF083600-->
          <name>mtgy_op_b0</name>
          <description>MWMM operand B register 0 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001600</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 31..0 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b1': 0xFF083604-->
          <name>mtgy_op_b1</name>
          <description>MWMM operand B register 1 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001604</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 63..32 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b2': 0xFF083608-->
          <name>mtgy_op_b2</name>
          <description>MWMM operand B register 2 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001608</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 95..64 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b3': 0xFF08360C-->
          <name>mtgy_op_b3</name>
          <description>MWMM operand B register 3 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000160C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 127..96 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b4': 0xFF083610-->
          <name>mtgy_op_b4</name>
          <description>MWMM operand B register 4 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001610</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 159..128 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b5': 0xFF083614-->
          <name>mtgy_op_b5</name>
          <description>MWMM operand B register 5 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001614</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 191..160 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b6': 0xFF083618-->
          <name>mtgy_op_b6</name>
          <description>MWMM operand B register 6 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001618</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 223..192 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b7': 0xFF08361C-->
          <name>mtgy_op_b7</name>
          <description>MWMM operand B register 7 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000161C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 255..224 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b8': 0xFF083620-->
          <name>mtgy_op_b8</name>
          <description>MWMM operand B register 8 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001620</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 287..256 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b9': 0xFF083624-->
          <name>mtgy_op_b9</name>
          <description>MWMM operand B register 9 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001624</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 319..288 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b10': 0xFF083628-->
          <name>mtgy_op_b10</name>
          <description>MWMM operand B register 10 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001628</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 351..320 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b11': 0xFF08362C-->
          <name>mtgy_op_b11</name>
          <description>MWMM operand B register 11 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000162C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 383..352 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b12': 0xFF083630-->
          <name>mtgy_op_b12</name>
          <description>MWMM operand B register 12 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001630</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 415..384 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b13': 0xFF083634-->
          <name>mtgy_op_b13</name>
          <description>MWMM operand B register 13 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001634</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 447..416 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b14': 0xFF083638-->
          <name>mtgy_op_b14</name>
          <description>MWMM operand B register 14 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001638</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 479..448 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b15': 0xFF08363C-->
          <name>mtgy_op_b15</name>
          <description>MWMM operand B register 15 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000163C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 511..480 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b16': 0xFF083640-->
          <name>mtgy_op_b16</name>
          <description>MWMM operand B register 16 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001640</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 543..512 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b17': 0xFF083644-->
          <name>mtgy_op_b17</name>
          <description>MWMM operand B register 17 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001644</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 575..544 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b18': 0xFF083648-->
          <name>mtgy_op_b18</name>
          <description>MWMM operand B register 18 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001648</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 607..576 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b19': 0xFF08364C-->
          <name>mtgy_op_b19</name>
          <description>MWMM operand B register 19 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000164C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 639..608 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b20': 0xFF083650-->
          <name>mtgy_op_b20</name>
          <description>MWMM operand B register 20 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001650</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 671..640 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b21': 0xFF083654-->
          <name>mtgy_op_b21</name>
          <description>MWMM operand B register 21 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001654</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 703..672 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b22': 0xFF083658-->
          <name>mtgy_op_b22</name>
          <description>MWMM operand B register 22 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001658</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 735..704 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b23': 0xFF08365C-->
          <name>mtgy_op_b23</name>
          <description>MWMM operand B register 23 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000165C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 767..736 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b24': 0xFF083660-->
          <name>mtgy_op_b24</name>
          <description>MWMM operand B register 24 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001660</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 799..768 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b25': 0xFF083664-->
          <name>mtgy_op_b25</name>
          <description>MWMM operand B register 25 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001664</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 831..800 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b26': 0xFF083668-->
          <name>mtgy_op_b26</name>
          <description>MWMM operand B register 26 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001668</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 863..832 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b27': 0xFF08366C-->
          <name>mtgy_op_b27</name>
          <description>MWMM operand B register 27 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000166C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 895..864 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b28': 0xFF083670-->
          <name>mtgy_op_b28</name>
          <description>MWMM operand B register 28 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001670</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 927..896 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b29': 0xFF083674-->
          <name>mtgy_op_b29</name>
          <description>MWMM operand B register 29 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001674</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 959..928 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b30': 0xFF083678-->
          <name>mtgy_op_b30</name>
          <description>MWMM operand B register 30 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001678</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 991..960 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b31': 0xFF08367C-->
          <name>mtgy_op_b31</name>
          <description>MWMM operand B register 31 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000167C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1023..992 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b32': 0xFF083680-->
          <name>mtgy_op_b32</name>
          <description>MWMM operand B register 32 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001680</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1055..1024 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b33': 0xFF083684-->
          <name>mtgy_op_b33</name>
          <description>MWMM operand B register 33 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001684</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1087..1056 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b34': 0xFF083688-->
          <name>mtgy_op_b34</name>
          <description>MWMM operand B register 34 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001688</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1119..1088 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b35': 0xFF08368C-->
          <name>mtgy_op_b35</name>
          <description>MWMM operand B register 35 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000168C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1151..1120 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b36': 0xFF083690-->
          <name>mtgy_op_b36</name>
          <description>MWMM operand B register 36 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001690</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1183..1152 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b37': 0xFF083694-->
          <name>mtgy_op_b37</name>
          <description>MWMM operand B register 37 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001694</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1215..1184 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b38': 0xFF083698-->
          <name>mtgy_op_b38</name>
          <description>MWMM operand B register 38 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001698</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1247..1216 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b39': 0xFF08369C-->
          <name>mtgy_op_b39</name>
          <description>MWMM operand B register 39 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000169C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1279..1248 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b40': 0xFF0836A0-->
          <name>mtgy_op_b40</name>
          <description>MWMM operand B register 40 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000016A0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1311..1280 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b41': 0xFF0836A4-->
          <name>mtgy_op_b41</name>
          <description>MWMM operand B register 41 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000016A4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1343..1312 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b42': 0xFF0836A8-->
          <name>mtgy_op_b42</name>
          <description>MWMM operand B register 42 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000016A8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1375..1344 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b43': 0xFF0836AC-->
          <name>mtgy_op_b43</name>
          <description>MWMM operand B register 43 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000016AC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1407..1376 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b44': 0xFF0836B0-->
          <name>mtgy_op_b44</name>
          <description>MWMM operand B register 44 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000016B0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1439..1408 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b45': 0xFF0836B4-->
          <name>mtgy_op_b45</name>
          <description>MWMM operand B register 45 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000016B4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1471..1440 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b46': 0xFF0836B8-->
          <name>mtgy_op_b46</name>
          <description>MWMM operand B register 46 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000016B8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1503..1472 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b47': 0xFF0836BC-->
          <name>mtgy_op_b47</name>
          <description>MWMM operand B register 47 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000016BC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1535..1504 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b48': 0xFF0836C0-->
          <name>mtgy_op_b48</name>
          <description>MWMM operand B register 48 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000016C0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1567..1536 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b49': 0xFF0836C4-->
          <name>mtgy_op_b49</name>
          <description>MWMM operand B register 49 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000016C4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1599..1568 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b50': 0xFF0836C8-->
          <name>mtgy_op_b50</name>
          <description>MWMM operand B register 50 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000016C8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1631..1600 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b51': 0xFF0836CC-->
          <name>mtgy_op_b51</name>
          <description>MWMM operand B register 51 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000016CC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1663..1632 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b52': 0xFF0836D0-->
          <name>mtgy_op_b52</name>
          <description>MWMM operand B register 52 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000016D0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1695..1664 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b53': 0xFF0836D4-->
          <name>mtgy_op_b53</name>
          <description>MWMM operand B register 53 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000016D4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1727..1696 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b54': 0xFF0836D8-->
          <name>mtgy_op_b54</name>
          <description>MWMM operand B register 54 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000016D8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1759..1728 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b55': 0xFF0836DC-->
          <name>mtgy_op_b55</name>
          <description>MWMM operand B register 55 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000016DC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1791..1760 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b56': 0xFF0836E0-->
          <name>mtgy_op_b56</name>
          <description>MWMM operand B register 56 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000016E0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1823..1792 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b57': 0xFF0836E4-->
          <name>mtgy_op_b57</name>
          <description>MWMM operand B register 57 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000016E4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1855..1824 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b58': 0xFF0836E8-->
          <name>mtgy_op_b58</name>
          <description>MWMM operand B register 58 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000016E8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1887..1856 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b59': 0xFF0836EC-->
          <name>mtgy_op_b59</name>
          <description>MWMM operand B register 59 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000016EC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1919..1888 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b60': 0xFF0836F0-->
          <name>mtgy_op_b60</name>
          <description>MWMM operand B register 60 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000016F0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1951..1920 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b61': 0xFF0836F4-->
          <name>mtgy_op_b61</name>
          <description>MWMM operand B register 61 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000016F4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1983..1952 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b62': 0xFF0836F8-->
          <name>mtgy_op_b62</name>
          <description>MWMM operand B register 62 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000016F8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2015..1984 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b63': 0xFF0836FC-->
          <name>mtgy_op_b63</name>
          <description>MWMM operand B register 63 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000016FC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2047..2016 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b64': 0xFF083700-->
          <name>mtgy_op_b64</name>
          <description>MWMM operand B register 64 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001700</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2079..2048 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b65': 0xFF083704-->
          <name>mtgy_op_b65</name>
          <description>MWMM operand B register 65 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001704</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2111..2080 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b66': 0xFF083708-->
          <name>mtgy_op_b66</name>
          <description>MWMM operand B register 66 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001708</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2143..2112 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b67': 0xFF08370C-->
          <name>mtgy_op_b67</name>
          <description>MWMM operand B register 67 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000170C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2175..2144 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b68': 0xFF083710-->
          <name>mtgy_op_b68</name>
          <description>MWMM operand B register 68 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001710</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2207..2176 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b69': 0xFF083714-->
          <name>mtgy_op_b69</name>
          <description>MWMM operand B register 69 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001714</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2239..2208 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b70': 0xFF083718-->
          <name>mtgy_op_b70</name>
          <description>MWMM operand B register 70 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001718</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2271..2240 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b71': 0xFF08371C-->
          <name>mtgy_op_b71</name>
          <description>MWMM operand B register 71 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000171C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2303..2272 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b72': 0xFF083720-->
          <name>mtgy_op_b72</name>
          <description>MWMM operand B register 72 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001720</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2335..2304 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b73': 0xFF083724-->
          <name>mtgy_op_b73</name>
          <description>MWMM operand B register 73 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001724</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2367..2336 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b74': 0xFF083728-->
          <name>mtgy_op_b74</name>
          <description>MWMM operand B register 74 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001728</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2399..2368 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b75': 0xFF08372C-->
          <name>mtgy_op_b75</name>
          <description>MWMM operand B register 75 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000172C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2431..2400 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b76': 0xFF083730-->
          <name>mtgy_op_b76</name>
          <description>MWMM operand B register 76 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001730</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2463..2432 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b77': 0xFF083734-->
          <name>mtgy_op_b77</name>
          <description>MWMM operand B register 77 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001734</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2495..2464 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b78': 0xFF083738-->
          <name>mtgy_op_b78</name>
          <description>MWMM operand B register 78 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001738</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2527..2496 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b79': 0xFF08373C-->
          <name>mtgy_op_b79</name>
          <description>MWMM operand B register 79 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000173C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2559..2528 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b80': 0xFF083740-->
          <name>mtgy_op_b80</name>
          <description>MWMM operand B register 80 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001740</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2591..2560 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b81': 0xFF083744-->
          <name>mtgy_op_b81</name>
          <description>MWMM operand B register 81 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001744</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2623..2592 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b82': 0xFF083748-->
          <name>mtgy_op_b82</name>
          <description>MWMM operand B register 82 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001748</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2655..2624 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b83': 0xFF08374C-->
          <name>mtgy_op_b83</name>
          <description>MWMM operand B register 83 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000174C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2687..2656 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b84': 0xFF083750-->
          <name>mtgy_op_b84</name>
          <description>MWMM operand B register 84 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001750</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2719..2688 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b85': 0xFF083754-->
          <name>mtgy_op_b85</name>
          <description>MWMM operand B register 85 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001754</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2751..2720 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b86': 0xFF083758-->
          <name>mtgy_op_b86</name>
          <description>MWMM operand B register 86 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001758</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2783..2752 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b87': 0xFF08375C-->
          <name>mtgy_op_b87</name>
          <description>MWMM operand B register 87 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000175C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2815..2784 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b88': 0xFF083760-->
          <name>mtgy_op_b88</name>
          <description>MWMM operand B register 88 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001760</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2847..2816 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b89': 0xFF083764-->
          <name>mtgy_op_b89</name>
          <description>MWMM operand B register 89 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001764</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2879..2848 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b90': 0xFF083768-->
          <name>mtgy_op_b90</name>
          <description>MWMM operand B register 90 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001768</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2911..2880 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b91': 0xFF08376C-->
          <name>mtgy_op_b91</name>
          <description>MWMM operand B register 91 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000176C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2943..2912 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b92': 0xFF083770-->
          <name>mtgy_op_b92</name>
          <description>MWMM operand B register 92 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001770</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2975..2944 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b93': 0xFF083774-->
          <name>mtgy_op_b93</name>
          <description>MWMM operand B register 93 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001774</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3007..2976 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b94': 0xFF083778-->
          <name>mtgy_op_b94</name>
          <description>MWMM operand B register 94 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001778</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3039..3008 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b95': 0xFF08377C-->
          <name>mtgy_op_b95</name>
          <description>MWMM operand B register 95 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000177C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3071..3040 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b96': 0xFF083780-->
          <name>mtgy_op_b96</name>
          <description>MWMM operand B register 96 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001780</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3103..3072 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b97': 0xFF083784-->
          <name>mtgy_op_b97</name>
          <description>MWMM operand B register 97 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001784</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3135..3104 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b98': 0xFF083788-->
          <name>mtgy_op_b98</name>
          <description>MWMM operand B register 98 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001788</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3167..3136 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b99': 0xFF08378C-->
          <name>mtgy_op_b99</name>
          <description>MWMM operand B register 99 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000178C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3199..3168 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b100': 0xFF083790-->
          <name>mtgy_op_b100</name>
          <description>MWMM operand B register 100 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001790</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3231..3200 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b101': 0xFF083794-->
          <name>mtgy_op_b101</name>
          <description>MWMM operand B register 101 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001794</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3263..3232 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b102': 0xFF083798-->
          <name>mtgy_op_b102</name>
          <description>MWMM operand B register 102 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001798</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3295..3264 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b103': 0xFF08379C-->
          <name>mtgy_op_b103</name>
          <description>MWMM operand B register 103 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000179C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3327..3296 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b104': 0xFF0837A0-->
          <name>mtgy_op_b104</name>
          <description>MWMM operand B register 104 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000017A0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3359..3328 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b105': 0xFF0837A4-->
          <name>mtgy_op_b105</name>
          <description>MWMM operand B register 105 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000017A4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3391..3360 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b106': 0xFF0837A8-->
          <name>mtgy_op_b106</name>
          <description>MWMM operand B register 106 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000017A8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3423..3392 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b107': 0xFF0837AC-->
          <name>mtgy_op_b107</name>
          <description>MWMM operand B register 107 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000017AC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3455..3424 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b108': 0xFF0837B0-->
          <name>mtgy_op_b108</name>
          <description>MWMM operand B register 108 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000017B0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3487..3456 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b109': 0xFF0837B4-->
          <name>mtgy_op_b109</name>
          <description>MWMM operand B register 109 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000017B4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3519..3488 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b110': 0xFF0837B8-->
          <name>mtgy_op_b110</name>
          <description>MWMM operand B register 110 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000017B8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3551..3520 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b111': 0xFF0837BC-->
          <name>mtgy_op_b111</name>
          <description>MWMM operand B register 111 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000017BC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3583..3552 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b112': 0xFF0837C0-->
          <name>mtgy_op_b112</name>
          <description>MWMM operand B register 112 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000017C0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3615..3584 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b113': 0xFF0837C4-->
          <name>mtgy_op_b113</name>
          <description>MWMM operand B register 113 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000017C4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3647..3616 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b114': 0xFF0837C8-->
          <name>mtgy_op_b114</name>
          <description>MWMM operand B register 114 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000017C8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3679..3648 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b115': 0xFF0837CC-->
          <name>mtgy_op_b115</name>
          <description>MWMM operand B register 115 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000017CC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3711..3680 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b116': 0xFF0837D0-->
          <name>mtgy_op_b116</name>
          <description>MWMM operand B register 116 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000017D0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3743..3712 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b117': 0xFF0837D4-->
          <name>mtgy_op_b117</name>
          <description>MWMM operand B register 117 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000017D4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3775..3744 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b118': 0xFF0837D8-->
          <name>mtgy_op_b118</name>
          <description>MWMM operand B register 118 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000017D8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3807..3776 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b119': 0xFF0837DC-->
          <name>mtgy_op_b119</name>
          <description>MWMM operand B register 119 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000017DC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3839..3808 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b120': 0xFF0837E0-->
          <name>mtgy_op_b120</name>
          <description>MWMM operand B register 120 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000017E0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3871..3840 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b121': 0xFF0837E4-->
          <name>mtgy_op_b121</name>
          <description>MWMM operand B register 121 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000017E4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3903..3872 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b122': 0xFF0837E8-->
          <name>mtgy_op_b122</name>
          <description>MWMM operand B register 122 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000017E8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3935..3904 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b123': 0xFF0837EC-->
          <name>mtgy_op_b123</name>
          <description>MWMM operand B register 123 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000017EC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3967..3936 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b124': 0xFF0837F0-->
          <name>mtgy_op_b124</name>
          <description>MWMM operand B register 124 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000017F0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3999..3968 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b125': 0xFF0837F4-->
          <name>mtgy_op_b125</name>
          <description>MWMM operand B register 125 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000017F4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 4031..4000 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b126': 0xFF0837F8-->
          <name>mtgy_op_b126</name>
          <description>MWMM operand B register 126 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000017F8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 4063..4032 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_b127': 0xFF0837FC-->
          <name>mtgy_op_b127</name>
          <description>MWMM operand B register 127 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000017FC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 4095..4064 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a0': 0xFF083800-->
          <name>mtgy_op_a0</name>
          <description>MWMM operand A register 0 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001800</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 31..0 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a1': 0xFF083804-->
          <name>mtgy_op_a1</name>
          <description>MWMM operand A register 1 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001804</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 63..32 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a2': 0xFF083808-->
          <name>mtgy_op_a2</name>
          <description>MWMM operand A register 2 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001808</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 95..64 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a3': 0xFF08380C-->
          <name>mtgy_op_a3</name>
          <description>MWMM operand A register 3 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000180C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 127..96 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a4': 0xFF083810-->
          <name>mtgy_op_a4</name>
          <description>MWMM operand A register 4 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001810</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 159..128 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a5': 0xFF083814-->
          <name>mtgy_op_a5</name>
          <description>MWMM operand A register 5 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001814</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 191..160 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a6': 0xFF083818-->
          <name>mtgy_op_a6</name>
          <description>MWMM operand A register 6 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001818</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 223..192 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a7': 0xFF08381C-->
          <name>mtgy_op_a7</name>
          <description>MWMM operand A register 7 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000181C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 255..224 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a8': 0xFF083820-->
          <name>mtgy_op_a8</name>
          <description>MWMM operand A register 8 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001820</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 287..256 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a9': 0xFF083824-->
          <name>mtgy_op_a9</name>
          <description>MWMM operand A register 9 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001824</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 319..288 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a10': 0xFF083828-->
          <name>mtgy_op_a10</name>
          <description>MWMM operand A register 10 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001828</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 351..320 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a11': 0xFF08382C-->
          <name>mtgy_op_a11</name>
          <description>MWMM operand A register 11 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000182C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 383..352 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a12': 0xFF083830-->
          <name>mtgy_op_a12</name>
          <description>MWMM operand A register 12 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001830</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 415..384 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a13': 0xFF083834-->
          <name>mtgy_op_a13</name>
          <description>MWMM operand A register 13 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001834</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 447..416 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a14': 0xFF083838-->
          <name>mtgy_op_a14</name>
          <description>MWMM operand A register 14 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001838</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 479..448 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a15': 0xFF08383C-->
          <name>mtgy_op_a15</name>
          <description>MWMM operand A register 15 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000183C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 511..480 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a16': 0xFF083840-->
          <name>mtgy_op_a16</name>
          <description>MWMM operand A register 16 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001840</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 543..512 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a17': 0xFF083844-->
          <name>mtgy_op_a17</name>
          <description>MWMM operand A register 17 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001844</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 575..544 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a18': 0xFF083848-->
          <name>mtgy_op_a18</name>
          <description>MWMM operand A register 18 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001848</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 607..576 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a19': 0xFF08384C-->
          <name>mtgy_op_a19</name>
          <description>MWMM operand A register 19 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000184C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 639..608 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a20': 0xFF083850-->
          <name>mtgy_op_a20</name>
          <description>MWMM operand A register 20 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001850</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 671..640 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a21': 0xFF083854-->
          <name>mtgy_op_a21</name>
          <description>MWMM operand A register 21 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001854</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 703..672 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a22': 0xFF083858-->
          <name>mtgy_op_a22</name>
          <description>MWMM operand A register 22 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001858</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 735..704 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a23': 0xFF08385C-->
          <name>mtgy_op_a23</name>
          <description>MWMM operand A register 23 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000185C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 767..736 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a24': 0xFF083860-->
          <name>mtgy_op_a24</name>
          <description>MWMM operand A register 24 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001860</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 799..768 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a25': 0xFF083864-->
          <name>mtgy_op_a25</name>
          <description>MWMM operand A register 25 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001864</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 831..800 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a26': 0xFF083868-->
          <name>mtgy_op_a26</name>
          <description>MWMM operand A register 26 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001868</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 863..832 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a27': 0xFF08386C-->
          <name>mtgy_op_a27</name>
          <description>MWMM operand A register 27 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000186C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 895..864 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a28': 0xFF083870-->
          <name>mtgy_op_a28</name>
          <description>MWMM operand A register 28 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001870</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 927..896 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a29': 0xFF083874-->
          <name>mtgy_op_a29</name>
          <description>MWMM operand A register 29 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001874</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 959..928 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a30': 0xFF083878-->
          <name>mtgy_op_a30</name>
          <description>MWMM operand A register 30 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001878</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 991..960 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a31': 0xFF08387C-->
          <name>mtgy_op_a31</name>
          <description>MWMM operand A register 31 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000187C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1023..992 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a32': 0xFF083880-->
          <name>mtgy_op_a32</name>
          <description>MWMM operand A register 32 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001880</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1055..1024 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a33': 0xFF083884-->
          <name>mtgy_op_a33</name>
          <description>MWMM operand A register 33 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001884</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1087..1056 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a34': 0xFF083888-->
          <name>mtgy_op_a34</name>
          <description>MWMM operand A register 34 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001888</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1119..1088 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a35': 0xFF08388C-->
          <name>mtgy_op_a35</name>
          <description>MWMM operand A register 35 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000188C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1151..1120 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a36': 0xFF083890-->
          <name>mtgy_op_a36</name>
          <description>MWMM operand A register 36 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001890</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1183..1152 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a37': 0xFF083894-->
          <name>mtgy_op_a37</name>
          <description>MWMM operand A register 37 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001894</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1215..1184 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a38': 0xFF083898-->
          <name>mtgy_op_a38</name>
          <description>MWMM operand A register 38 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001898</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1247..1216 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a39': 0xFF08389C-->
          <name>mtgy_op_a39</name>
          <description>MWMM operand A register 39 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000189C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1279..1248 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a40': 0xFF0838A0-->
          <name>mtgy_op_a40</name>
          <description>MWMM operand A register 40 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000018A0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1311..1280 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a41': 0xFF0838A4-->
          <name>mtgy_op_a41</name>
          <description>MWMM operand A register 41 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000018A4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1343..1312 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a42': 0xFF0838A8-->
          <name>mtgy_op_a42</name>
          <description>MWMM operand A register 42 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000018A8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1375..1344 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a43': 0xFF0838AC-->
          <name>mtgy_op_a43</name>
          <description>MWMM operand A register 43 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000018AC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1407..1376 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a44': 0xFF0838B0-->
          <name>mtgy_op_a44</name>
          <description>MWMM operand A register 44 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000018B0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1439..1408 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a45': 0xFF0838B4-->
          <name>mtgy_op_a45</name>
          <description>MWMM operand A register 45 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000018B4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1471..1440 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a46': 0xFF0838B8-->
          <name>mtgy_op_a46</name>
          <description>MWMM operand A register 46 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000018B8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1503..1472 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a47': 0xFF0838BC-->
          <name>mtgy_op_a47</name>
          <description>MWMM operand A register 47 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000018BC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1535..1504 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a48': 0xFF0838C0-->
          <name>mtgy_op_a48</name>
          <description>MWMM operand A register 48 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000018C0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1567..1536 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a49': 0xFF0838C4-->
          <name>mtgy_op_a49</name>
          <description>MWMM operand A register 49 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000018C4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1599..1568 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a50': 0xFF0838C8-->
          <name>mtgy_op_a50</name>
          <description>MWMM operand A register 50 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000018C8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1631..1600 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a51': 0xFF0838CC-->
          <name>mtgy_op_a51</name>
          <description>MWMM operand A register 51 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000018CC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1663..1632 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a52': 0xFF0838D0-->
          <name>mtgy_op_a52</name>
          <description>MWMM operand A register 52 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000018D0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1695..1664 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a53': 0xFF0838D4-->
          <name>mtgy_op_a53</name>
          <description>MWMM operand A register 53 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000018D4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1727..1696 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a54': 0xFF0838D8-->
          <name>mtgy_op_a54</name>
          <description>MWMM operand A register 54 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000018D8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1759..1728 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a55': 0xFF0838DC-->
          <name>mtgy_op_a55</name>
          <description>MWMM operand A register 55 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000018DC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1791..1760 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a56': 0xFF0838E0-->
          <name>mtgy_op_a56</name>
          <description>MWMM operand A register 56 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000018E0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1823..1792 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a57': 0xFF0838E4-->
          <name>mtgy_op_a57</name>
          <description>MWMM operand A register 57 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000018E4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1855..1824 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a58': 0xFF0838E8-->
          <name>mtgy_op_a58</name>
          <description>MWMM operand A register 58 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000018E8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1887..1856 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a59': 0xFF0838EC-->
          <name>mtgy_op_a59</name>
          <description>MWMM operand A register 59 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000018EC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1919..1888 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a60': 0xFF0838F0-->
          <name>mtgy_op_a60</name>
          <description>MWMM operand A register 60 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000018F0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1951..1920 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a61': 0xFF0838F4-->
          <name>mtgy_op_a61</name>
          <description>MWMM operand A register 61 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000018F4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1983..1952 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a62': 0xFF0838F8-->
          <name>mtgy_op_a62</name>
          <description>MWMM operand A register 62 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000018F8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2015..1984 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a63': 0xFF0838FC-->
          <name>mtgy_op_a63</name>
          <description>MWMM operand A register 63 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000018FC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2047..2016 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a64': 0xFF083900-->
          <name>mtgy_op_a64</name>
          <description>MWMM operand A register 64 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001900</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2079..2048 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a65': 0xFF083904-->
          <name>mtgy_op_a65</name>
          <description>MWMM operand A register 65 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001904</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2111..2080 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a66': 0xFF083908-->
          <name>mtgy_op_a66</name>
          <description>MWMM operand A register 66 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001908</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2143..2112 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a67': 0xFF08390C-->
          <name>mtgy_op_a67</name>
          <description>MWMM operand A register 67 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000190C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2175..2144 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a68': 0xFF083910-->
          <name>mtgy_op_a68</name>
          <description>MWMM operand A register 68 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001910</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2207..2176 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a69': 0xFF083914-->
          <name>mtgy_op_a69</name>
          <description>MWMM operand A register 69 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001914</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2239..2208 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a70': 0xFF083918-->
          <name>mtgy_op_a70</name>
          <description>MWMM operand A register 70 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001918</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2271..2240 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a71': 0xFF08391C-->
          <name>mtgy_op_a71</name>
          <description>MWMM operand A register 71 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000191C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2303..2272 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a72': 0xFF083920-->
          <name>mtgy_op_a72</name>
          <description>MWMM operand A register 72 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001920</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2335..2304 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a73': 0xFF083924-->
          <name>mtgy_op_a73</name>
          <description>MWMM operand A register 73 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001924</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2367..2336 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a74': 0xFF083928-->
          <name>mtgy_op_a74</name>
          <description>MWMM operand A register 74 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001928</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2399..2368 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a75': 0xFF08392C-->
          <name>mtgy_op_a75</name>
          <description>MWMM operand A register 75 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000192C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2431..2400 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a76': 0xFF083930-->
          <name>mtgy_op_a76</name>
          <description>MWMM operand A register 76 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001930</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2463..2432 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a77': 0xFF083934-->
          <name>mtgy_op_a77</name>
          <description>MWMM operand A register 77 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001934</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2495..2464 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a78': 0xFF083938-->
          <name>mtgy_op_a78</name>
          <description>MWMM operand A register 78 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001938</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2527..2496 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a79': 0xFF08393C-->
          <name>mtgy_op_a79</name>
          <description>MWMM operand A register 79 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000193C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2559..2528 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a80': 0xFF083940-->
          <name>mtgy_op_a80</name>
          <description>MWMM operand A register 80 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001940</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2591..2560 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a81': 0xFF083944-->
          <name>mtgy_op_a81</name>
          <description>MWMM operand A register 81 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001944</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2623..2592 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a82': 0xFF083948-->
          <name>mtgy_op_a82</name>
          <description>MWMM operand A register 82 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001948</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2655..2624 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a83': 0xFF08394C-->
          <name>mtgy_op_a83</name>
          <description>MWMM operand A register 83 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000194C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2687..2656 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a84': 0xFF083950-->
          <name>mtgy_op_a84</name>
          <description>MWMM operand A register 84 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001950</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2719..2688 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a85': 0xFF083954-->
          <name>mtgy_op_a85</name>
          <description>MWMM operand A register 85 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001954</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2751..2720 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a86': 0xFF083958-->
          <name>mtgy_op_a86</name>
          <description>MWMM operand A register 86 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001958</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2783..2752 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a87': 0xFF08395C-->
          <name>mtgy_op_a87</name>
          <description>MWMM operand A register 87 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000195C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2815..2784 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a88': 0xFF083960-->
          <name>mtgy_op_a88</name>
          <description>MWMM operand A register 88 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001960</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2847..2816 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a89': 0xFF083964-->
          <name>mtgy_op_a89</name>
          <description>MWMM operand A register 89 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001964</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2879..2848 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a90': 0xFF083968-->
          <name>mtgy_op_a90</name>
          <description>MWMM operand A register 90 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001968</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2911..2880 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a91': 0xFF08396C-->
          <name>mtgy_op_a91</name>
          <description>MWMM operand A register 91 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000196C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2943..2912 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a92': 0xFF083970-->
          <name>mtgy_op_a92</name>
          <description>MWMM operand A register 92 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001970</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2975..2944 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a93': 0xFF083974-->
          <name>mtgy_op_a93</name>
          <description>MWMM operand A register 93 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001974</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3007..2976 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a94': 0xFF083978-->
          <name>mtgy_op_a94</name>
          <description>MWMM operand A register 94 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001978</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3039..3008 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a95': 0xFF08397C-->
          <name>mtgy_op_a95</name>
          <description>MWMM operand A register 95 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000197C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3071..3040 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a96': 0xFF083980-->
          <name>mtgy_op_a96</name>
          <description>MWMM operand A register 96 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001980</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3103..3072 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a97': 0xFF083984-->
          <name>mtgy_op_a97</name>
          <description>MWMM operand A register 97 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001984</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3135..3104 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a98': 0xFF083988-->
          <name>mtgy_op_a98</name>
          <description>MWMM operand A register 98 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001988</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3167..3136 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a99': 0xFF08398C-->
          <name>mtgy_op_a99</name>
          <description>MWMM operand A register 99 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000198C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3199..3168 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a100': 0xFF083990-->
          <name>mtgy_op_a100</name>
          <description>MWMM operand A register 100 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001990</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3231..3200 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a101': 0xFF083994-->
          <name>mtgy_op_a101</name>
          <description>MWMM operand A register 101 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001994</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3263..3232 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a102': 0xFF083998-->
          <name>mtgy_op_a102</name>
          <description>MWMM operand A register 102 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001998</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3295..3264 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a103': 0xFF08399C-->
          <name>mtgy_op_a103</name>
          <description>MWMM operand A register 103 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000199C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3327..3296 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a104': 0xFF0839A0-->
          <name>mtgy_op_a104</name>
          <description>MWMM operand A register 104 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000019A0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3359..3328 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a105': 0xFF0839A4-->
          <name>mtgy_op_a105</name>
          <description>MWMM operand A register 105 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000019A4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3391..3360 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a106': 0xFF0839A8-->
          <name>mtgy_op_a106</name>
          <description>MWMM operand A register 106 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000019A8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3423..3392 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a107': 0xFF0839AC-->
          <name>mtgy_op_a107</name>
          <description>MWMM operand A register 107 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000019AC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3455..3424 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a108': 0xFF0839B0-->
          <name>mtgy_op_a108</name>
          <description>MWMM operand A register 108 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000019B0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3487..3456 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a109': 0xFF0839B4-->
          <name>mtgy_op_a109</name>
          <description>MWMM operand A register 109 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000019B4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3519..3488 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a110': 0xFF0839B8-->
          <name>mtgy_op_a110</name>
          <description>MWMM operand A register 110 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000019B8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3551..3520 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a111': 0xFF0839BC-->
          <name>mtgy_op_a111</name>
          <description>MWMM operand A register 111 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000019BC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3583..3552 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a112': 0xFF0839C0-->
          <name>mtgy_op_a112</name>
          <description>MWMM operand A register 112 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000019C0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3615..3584 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a113': 0xFF0839C4-->
          <name>mtgy_op_a113</name>
          <description>MWMM operand A register 113 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000019C4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3647..3616 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a114': 0xFF0839C8-->
          <name>mtgy_op_a114</name>
          <description>MWMM operand A register 114 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000019C8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3679..3648 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a115': 0xFF0839CC-->
          <name>mtgy_op_a115</name>
          <description>MWMM operand A register 115 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000019CC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3711..3680 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a116': 0xFF0839D0-->
          <name>mtgy_op_a116</name>
          <description>MWMM operand A register 116 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000019D0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3743..3712 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a117': 0xFF0839D4-->
          <name>mtgy_op_a117</name>
          <description>MWMM operand A register 117 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000019D4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3775..3744 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a118': 0xFF0839D8-->
          <name>mtgy_op_a118</name>
          <description>MWMM operand A register 118 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000019D8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3807..3776 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a119': 0xFF0839DC-->
          <name>mtgy_op_a119</name>
          <description>MWMM operand A register 119 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000019DC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3839..3808 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a120': 0xFF0839E0-->
          <name>mtgy_op_a120</name>
          <description>MWMM operand A register 120 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000019E0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3871..3840 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a121': 0xFF0839E4-->
          <name>mtgy_op_a121</name>
          <description>MWMM operand A register 121 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000019E4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3903..3872 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a122': 0xFF0839E8-->
          <name>mtgy_op_a122</name>
          <description>MWMM operand A register 122 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000019E8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3935..3904 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a123': 0xFF0839EC-->
          <name>mtgy_op_a123</name>
          <description>MWMM operand A register 123 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000019EC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3967..3936 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a124': 0xFF0839F0-->
          <name>mtgy_op_a124</name>
          <description>MWMM operand A register 124 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000019F0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3999..3968 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a125': 0xFF0839F4-->
          <name>mtgy_op_a125</name>
          <description>MWMM operand A register 125 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000019F4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 4031..4000 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a126': 0xFF0839F8-->
          <name>mtgy_op_a126</name>
          <description>MWMM operand A register 126 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000019F8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 4063..4032 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_a127': 0xFF0839FC-->
          <name>mtgy_op_a127</name>
          <description>MWMM operand A register 127 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000019FC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 4095..4064 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e0': 0xFF083A00-->
          <name>mtgy_op_e0</name>
          <description>MWMM operand E register 0 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001A00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 31..0 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e1': 0xFF083A04-->
          <name>mtgy_op_e1</name>
          <description>MWMM operand E register 1 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001A04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 63..32 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e2': 0xFF083A08-->
          <name>mtgy_op_e2</name>
          <description>MWMM operand E register 2 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001A08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 95..64 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e3': 0xFF083A0C-->
          <name>mtgy_op_e3</name>
          <description>MWMM operand E register 3 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001A0C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 127..96 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e4': 0xFF083A10-->
          <name>mtgy_op_e4</name>
          <description>MWMM operand E register 4 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001A10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 159..128 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e5': 0xFF083A14-->
          <name>mtgy_op_e5</name>
          <description>MWMM operand E register 5 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001A14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 191..160 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e6': 0xFF083A18-->
          <name>mtgy_op_e6</name>
          <description>MWMM operand E register 6 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001A18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 223..192 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e7': 0xFF083A1C-->
          <name>mtgy_op_e7</name>
          <description>MWMM operand E register 7 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001A1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 255..224 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e8': 0xFF083A20-->
          <name>mtgy_op_e8</name>
          <description>MWMM operand E register 8 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001A20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 287..256 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e9': 0xFF083A24-->
          <name>mtgy_op_e9</name>
          <description>MWMM operand E register 9 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001A24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 319..288 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e10': 0xFF083A28-->
          <name>mtgy_op_e10</name>
          <description>MWMM operand E register 10 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001A28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 351..320 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e11': 0xFF083A2C-->
          <name>mtgy_op_e11</name>
          <description>MWMM operand E register 11 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001A2C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 383..352 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e12': 0xFF083A30-->
          <name>mtgy_op_e12</name>
          <description>MWMM operand E register 12 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001A30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 415..384 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e13': 0xFF083A34-->
          <name>mtgy_op_e13</name>
          <description>MWMM operand E register 13 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001A34</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 447..416 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e14': 0xFF083A38-->
          <name>mtgy_op_e14</name>
          <description>MWMM operand E register 14 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001A38</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 479..448 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e15': 0xFF083A3C-->
          <name>mtgy_op_e15</name>
          <description>MWMM operand E register 15 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001A3C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 511..480 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e16': 0xFF083A40-->
          <name>mtgy_op_e16</name>
          <description>MWMM operand E register 16 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001A40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 543..512 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e17': 0xFF083A44-->
          <name>mtgy_op_e17</name>
          <description>MWMM operand E register 17 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001A44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 575..544 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e18': 0xFF083A48-->
          <name>mtgy_op_e18</name>
          <description>MWMM operand E register 18 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001A48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 607..576 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e19': 0xFF083A4C-->
          <name>mtgy_op_e19</name>
          <description>MWMM operand E register 19 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001A4C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 639..608 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e20': 0xFF083A50-->
          <name>mtgy_op_e20</name>
          <description>MWMM operand E register 20 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001A50</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 671..640 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e21': 0xFF083A54-->
          <name>mtgy_op_e21</name>
          <description>MWMM operand E register 21 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001A54</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 703..672 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e22': 0xFF083A58-->
          <name>mtgy_op_e22</name>
          <description>MWMM operand E register 22 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001A58</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 735..704 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e23': 0xFF083A5C-->
          <name>mtgy_op_e23</name>
          <description>MWMM operand E register 23 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001A5C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 767..736 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e24': 0xFF083A60-->
          <name>mtgy_op_e24</name>
          <description>MWMM operand E register 24 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001A60</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 799..768 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e25': 0xFF083A64-->
          <name>mtgy_op_e25</name>
          <description>MWMM operand E register 25 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001A64</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 831..800 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e26': 0xFF083A68-->
          <name>mtgy_op_e26</name>
          <description>MWMM operand E register 26 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001A68</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 863..832 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e27': 0xFF083A6C-->
          <name>mtgy_op_e27</name>
          <description>MWMM operand E register 27 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001A6C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 895..864 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e28': 0xFF083A70-->
          <name>mtgy_op_e28</name>
          <description>MWMM operand E register 28 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001A70</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 927..896 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e29': 0xFF083A74-->
          <name>mtgy_op_e29</name>
          <description>MWMM operand E register 29 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001A74</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 959..928 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e30': 0xFF083A78-->
          <name>mtgy_op_e30</name>
          <description>MWMM operand E register 30 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001A78</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 991..960 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e31': 0xFF083A7C-->
          <name>mtgy_op_e31</name>
          <description>MWMM operand E register 31 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001A7C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1023..992 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e32': 0xFF083A80-->
          <name>mtgy_op_e32</name>
          <description>MWMM operand E register 32 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001A80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1055..1024 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e33': 0xFF083A84-->
          <name>mtgy_op_e33</name>
          <description>MWMM operand E register 33 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001A84</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1087..1056 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e34': 0xFF083A88-->
          <name>mtgy_op_e34</name>
          <description>MWMM operand E register 34 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001A88</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1119..1088 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e35': 0xFF083A8C-->
          <name>mtgy_op_e35</name>
          <description>MWMM operand E register 35 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001A8C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1151..1120 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e36': 0xFF083A90-->
          <name>mtgy_op_e36</name>
          <description>MWMM operand E register 36 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001A90</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1183..1152 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e37': 0xFF083A94-->
          <name>mtgy_op_e37</name>
          <description>MWMM operand E register 37 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001A94</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1215..1184 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e38': 0xFF083A98-->
          <name>mtgy_op_e38</name>
          <description>MWMM operand E register 38 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001A98</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1247..1216 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e39': 0xFF083A9C-->
          <name>mtgy_op_e39</name>
          <description>MWMM operand E register 39 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001A9C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1279..1248 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e40': 0xFF083AA0-->
          <name>mtgy_op_e40</name>
          <description>MWMM operand E register 40 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001AA0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1311..1280 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e41': 0xFF083AA4-->
          <name>mtgy_op_e41</name>
          <description>MWMM operand E register 41 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001AA4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1343..1312 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e42': 0xFF083AA8-->
          <name>mtgy_op_e42</name>
          <description>MWMM operand E register 42 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001AA8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1375..1344 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e43': 0xFF083AAC-->
          <name>mtgy_op_e43</name>
          <description>MWMM operand E register 43 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001AAC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1407..1376 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e44': 0xFF083AB0-->
          <name>mtgy_op_e44</name>
          <description>MWMM operand E register 44 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001AB0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1439..1408 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e45': 0xFF083AB4-->
          <name>mtgy_op_e45</name>
          <description>MWMM operand E register 45 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001AB4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1471..1440 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e46': 0xFF083AB8-->
          <name>mtgy_op_e46</name>
          <description>MWMM operand E register 46 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001AB8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1503..1472 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e47': 0xFF083ABC-->
          <name>mtgy_op_e47</name>
          <description>MWMM operand E register 47 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001ABC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1535..1504 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e48': 0xFF083AC0-->
          <name>mtgy_op_e48</name>
          <description>MWMM operand E register 48 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001AC0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1567..1536 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e49': 0xFF083AC4-->
          <name>mtgy_op_e49</name>
          <description>MWMM operand E register 49 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001AC4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1599..1568 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e50': 0xFF083AC8-->
          <name>mtgy_op_e50</name>
          <description>MWMM operand E register 50 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001AC8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1631..1600 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e51': 0xFF083ACC-->
          <name>mtgy_op_e51</name>
          <description>MWMM operand E register 51 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001ACC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1663..1632 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e52': 0xFF083AD0-->
          <name>mtgy_op_e52</name>
          <description>MWMM operand E register 52 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001AD0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1695..1664 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e53': 0xFF083AD4-->
          <name>mtgy_op_e53</name>
          <description>MWMM operand E register 53 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001AD4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1727..1696 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e54': 0xFF083AD8-->
          <name>mtgy_op_e54</name>
          <description>MWMM operand E register 54 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001AD8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1759..1728 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e55': 0xFF083ADC-->
          <name>mtgy_op_e55</name>
          <description>MWMM operand E register 55 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001ADC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1791..1760 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e56': 0xFF083AE0-->
          <name>mtgy_op_e56</name>
          <description>MWMM operand E register 56 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001AE0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1823..1792 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e57': 0xFF083AE4-->
          <name>mtgy_op_e57</name>
          <description>MWMM operand E register 57 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001AE4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1855..1824 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e58': 0xFF083AE8-->
          <name>mtgy_op_e58</name>
          <description>MWMM operand E register 58 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001AE8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1887..1856 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e59': 0xFF083AEC-->
          <name>mtgy_op_e59</name>
          <description>MWMM operand E register 59 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001AEC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1919..1888 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e60': 0xFF083AF0-->
          <name>mtgy_op_e60</name>
          <description>MWMM operand E register 60 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001AF0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1951..1920 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e61': 0xFF083AF4-->
          <name>mtgy_op_e61</name>
          <description>MWMM operand E register 61 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001AF4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1983..1952 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e62': 0xFF083AF8-->
          <name>mtgy_op_e62</name>
          <description>MWMM operand E register 62 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001AF8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2015..1984 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e63': 0xFF083AFC-->
          <name>mtgy_op_e63</name>
          <description>MWMM operand E register 63 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001AFC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2047..2016 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e64': 0xFF083B00-->
          <name>mtgy_op_e64</name>
          <description>MWMM operand E register 64 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001B00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2079..2048 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e65': 0xFF083B04-->
          <name>mtgy_op_e65</name>
          <description>MWMM operand E register 65 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001B04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2111..2080 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e66': 0xFF083B08-->
          <name>mtgy_op_e66</name>
          <description>MWMM operand E register 66 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001B08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2143..2112 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e67': 0xFF083B0C-->
          <name>mtgy_op_e67</name>
          <description>MWMM operand E register 67 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001B0C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2175..2144 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e68': 0xFF083B10-->
          <name>mtgy_op_e68</name>
          <description>MWMM operand E register 68 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001B10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2207..2176 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e69': 0xFF083B14-->
          <name>mtgy_op_e69</name>
          <description>MWMM operand E register 69 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001B14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2239..2208 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e70': 0xFF083B18-->
          <name>mtgy_op_e70</name>
          <description>MWMM operand E register 70 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001B18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2271..2240 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e71': 0xFF083B1C-->
          <name>mtgy_op_e71</name>
          <description>MWMM operand E register 71 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001B1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2303..2272 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e72': 0xFF083B20-->
          <name>mtgy_op_e72</name>
          <description>MWMM operand E register 72 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001B20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2335..2304 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e73': 0xFF083B24-->
          <name>mtgy_op_e73</name>
          <description>MWMM operand E register 73 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001B24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2367..2336 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e74': 0xFF083B28-->
          <name>mtgy_op_e74</name>
          <description>MWMM operand E register 74 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001B28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2399..2368 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e75': 0xFF083B2C-->
          <name>mtgy_op_e75</name>
          <description>MWMM operand E register 75 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001B2C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2431..2400 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e76': 0xFF083B30-->
          <name>mtgy_op_e76</name>
          <description>MWMM operand E register 76 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001B30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2463..2432 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e77': 0xFF083B34-->
          <name>mtgy_op_e77</name>
          <description>MWMM operand E register 77 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001B34</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2495..2464 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e78': 0xFF083B38-->
          <name>mtgy_op_e78</name>
          <description>MWMM operand E register 78 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001B38</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2527..2496 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e79': 0xFF083B3C-->
          <name>mtgy_op_e79</name>
          <description>MWMM operand E register 79 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001B3C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2559..2528 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e80': 0xFF083B40-->
          <name>mtgy_op_e80</name>
          <description>MWMM operand E register 80 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001B40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2591..2560 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e81': 0xFF083B44-->
          <name>mtgy_op_e81</name>
          <description>MWMM operand E register 81 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001B44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2623..2592 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e82': 0xFF083B48-->
          <name>mtgy_op_e82</name>
          <description>MWMM operand E register 82 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001B48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2655..2624 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e83': 0xFF083B4C-->
          <name>mtgy_op_e83</name>
          <description>MWMM operand E register 83 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001B4C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2687..2656 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e84': 0xFF083B50-->
          <name>mtgy_op_e84</name>
          <description>MWMM operand E register 84 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001B50</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2719..2688 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e85': 0xFF083B54-->
          <name>mtgy_op_e85</name>
          <description>MWMM operand E register 85 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001B54</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2751..2720 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e86': 0xFF083B58-->
          <name>mtgy_op_e86</name>
          <description>MWMM operand E register 86 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001B58</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2783..2752 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e87': 0xFF083B5C-->
          <name>mtgy_op_e87</name>
          <description>MWMM operand E register 87 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001B5C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2815..2784 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e88': 0xFF083B60-->
          <name>mtgy_op_e88</name>
          <description>MWMM operand E register 88 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001B60</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2847..2816 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e89': 0xFF083B64-->
          <name>mtgy_op_e89</name>
          <description>MWMM operand E register 89 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001B64</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2879..2848 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e90': 0xFF083B68-->
          <name>mtgy_op_e90</name>
          <description>MWMM operand E register 90 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001B68</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2911..2880 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e91': 0xFF083B6C-->
          <name>mtgy_op_e91</name>
          <description>MWMM operand E register 91 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001B6C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2943..2912 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e92': 0xFF083B70-->
          <name>mtgy_op_e92</name>
          <description>MWMM operand E register 92 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001B70</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2975..2944 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e93': 0xFF083B74-->
          <name>mtgy_op_e93</name>
          <description>MWMM operand E register 93 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001B74</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3007..2976 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e94': 0xFF083B78-->
          <name>mtgy_op_e94</name>
          <description>MWMM operand E register 94 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001B78</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3039..3008 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e95': 0xFF083B7C-->
          <name>mtgy_op_e95</name>
          <description>MWMM operand E register 95 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001B7C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3071..3040 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e96': 0xFF083B80-->
          <name>mtgy_op_e96</name>
          <description>MWMM operand E register 96 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001B80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3103..3072 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e97': 0xFF083B84-->
          <name>mtgy_op_e97</name>
          <description>MWMM operand E register 97 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001B84</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3135..3104 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e98': 0xFF083B88-->
          <name>mtgy_op_e98</name>
          <description>MWMM operand E register 98 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001B88</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3167..3136 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e99': 0xFF083B8C-->
          <name>mtgy_op_e99</name>
          <description>MWMM operand E register 99 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001B8C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3199..3168 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e100': 0xFF083B90-->
          <name>mtgy_op_e100</name>
          <description>MWMM operand E register 100 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001B90</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3231..3200 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e101': 0xFF083B94-->
          <name>mtgy_op_e101</name>
          <description>MWMM operand E register 101 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001B94</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3263..3232 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e102': 0xFF083B98-->
          <name>mtgy_op_e102</name>
          <description>MWMM operand E register 102 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001B98</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3295..3264 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e103': 0xFF083B9C-->
          <name>mtgy_op_e103</name>
          <description>MWMM operand E register 103 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001B9C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3327..3296 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e104': 0xFF083BA0-->
          <name>mtgy_op_e104</name>
          <description>MWMM operand E register 104 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001BA0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3359..3328 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e105': 0xFF083BA4-->
          <name>mtgy_op_e105</name>
          <description>MWMM operand E register 105 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001BA4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3391..3360 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e106': 0xFF083BA8-->
          <name>mtgy_op_e106</name>
          <description>MWMM operand E register 106 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001BA8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3423..3392 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e107': 0xFF083BAC-->
          <name>mtgy_op_e107</name>
          <description>MWMM operand E register 107 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001BAC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3455..3424 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e108': 0xFF083BB0-->
          <name>mtgy_op_e108</name>
          <description>MWMM operand E register 108 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001BB0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3487..3456 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e109': 0xFF083BB4-->
          <name>mtgy_op_e109</name>
          <description>MWMM operand E register 109 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001BB4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3519..3488 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e110': 0xFF083BB8-->
          <name>mtgy_op_e110</name>
          <description>MWMM operand E register 110 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001BB8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3551..3520 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e111': 0xFF083BBC-->
          <name>mtgy_op_e111</name>
          <description>MWMM operand E register 111 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001BBC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3583..3552 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e112': 0xFF083BC0-->
          <name>mtgy_op_e112</name>
          <description>MWMM operand E register 112 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001BC0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3615..3584 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e113': 0xFF083BC4-->
          <name>mtgy_op_e113</name>
          <description>MWMM operand E register 113 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001BC4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3647..3616 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e114': 0xFF083BC8-->
          <name>mtgy_op_e114</name>
          <description>MWMM operand E register 114 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001BC8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3679..3648 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e115': 0xFF083BCC-->
          <name>mtgy_op_e115</name>
          <description>MWMM operand E register 115 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001BCC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3711..3680 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e116': 0xFF083BD0-->
          <name>mtgy_op_e116</name>
          <description>MWMM operand E register 116 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001BD0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3743..3712 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e117': 0xFF083BD4-->
          <name>mtgy_op_e117</name>
          <description>MWMM operand E register 117 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001BD4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3775..3744 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e118': 0xFF083BD8-->
          <name>mtgy_op_e118</name>
          <description>MWMM operand E register 118 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001BD8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3807..3776 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e119': 0xFF083BDC-->
          <name>mtgy_op_e119</name>
          <description>MWMM operand E register 119 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001BDC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3839..3808 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e120': 0xFF083BE0-->
          <name>mtgy_op_e120</name>
          <description>MWMM operand E register 120 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001BE0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3871..3840 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e121': 0xFF083BE4-->
          <name>mtgy_op_e121</name>
          <description>MWMM operand E register 121 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001BE4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3903..3872 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e122': 0xFF083BE8-->
          <name>mtgy_op_e122</name>
          <description>MWMM operand E register 122 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001BE8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3935..3904 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e123': 0xFF083BEC-->
          <name>mtgy_op_e123</name>
          <description>MWMM operand E register 123 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001BEC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3967..3936 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e124': 0xFF083BF0-->
          <name>mtgy_op_e124</name>
          <description>MWMM operand E register 124 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001BF0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3999..3968 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e125': 0xFF083BF4-->
          <name>mtgy_op_e125</name>
          <description>MWMM operand E register 125 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001BF4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 4031..4000 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e126': 0xFF083BF8-->
          <name>mtgy_op_e126</name>
          <description>MWMM operand E register 126 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001BF8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 4063..4032 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_e127': 0xFF083BFC-->
          <name>mtgy_op_e127</name>
          <description>MWMM operand E register 127 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001BFC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 4095..4064 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x0': 0xFF083C00-->
          <name>mtgy_op_x0</name>
          <description>MWMM operand X register 0 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001C00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 31..0 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x1': 0xFF083C04-->
          <name>mtgy_op_x1</name>
          <description>MWMM operand X register 1 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001C04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 63..32 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x2': 0xFF083C08-->
          <name>mtgy_op_x2</name>
          <description>MWMM operand X register 2 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001C08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 95..64 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x3': 0xFF083C0C-->
          <name>mtgy_op_x3</name>
          <description>MWMM operand X register 3 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001C0C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 127..96 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x4': 0xFF083C10-->
          <name>mtgy_op_x4</name>
          <description>MWMM operand X register 4 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001C10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 159..128 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x5': 0xFF083C14-->
          <name>mtgy_op_x5</name>
          <description>MWMM operand X register 5 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001C14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 191..160 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x6': 0xFF083C18-->
          <name>mtgy_op_x6</name>
          <description>MWMM operand X register 6 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001C18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 223..192 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x7': 0xFF083C1C-->
          <name>mtgy_op_x7</name>
          <description>MWMM operand X register 7 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001C1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 255..224 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x8': 0xFF083C20-->
          <name>mtgy_op_x8</name>
          <description>MWMM operand X register 8 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001C20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 287..256 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x9': 0xFF083C24-->
          <name>mtgy_op_x9</name>
          <description>MWMM operand X register 9 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001C24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 319..288 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x10': 0xFF083C28-->
          <name>mtgy_op_x10</name>
          <description>MWMM operand X register 10 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001C28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 351..320 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x11': 0xFF083C2C-->
          <name>mtgy_op_x11</name>
          <description>MWMM operand X register 11 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001C2C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 383..352 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x12': 0xFF083C30-->
          <name>mtgy_op_x12</name>
          <description>MWMM operand X register 12 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001C30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 415..384 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x13': 0xFF083C34-->
          <name>mtgy_op_x13</name>
          <description>MWMM operand X register 13 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001C34</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 447..416 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x14': 0xFF083C38-->
          <name>mtgy_op_x14</name>
          <description>MWMM operand X register 14 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001C38</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 479..448 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x15': 0xFF083C3C-->
          <name>mtgy_op_x15</name>
          <description>MWMM operand X register 15 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001C3C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 511..480 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x16': 0xFF083C40-->
          <name>mtgy_op_x16</name>
          <description>MWMM operand X register 16 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001C40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 543..512 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x17': 0xFF083C44-->
          <name>mtgy_op_x17</name>
          <description>MWMM operand X register 17 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001C44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 575..544 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x18': 0xFF083C48-->
          <name>mtgy_op_x18</name>
          <description>MWMM operand X register 18 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001C48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 607..576 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x19': 0xFF083C4C-->
          <name>mtgy_op_x19</name>
          <description>MWMM operand X register 19 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001C4C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 639..608 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x20': 0xFF083C50-->
          <name>mtgy_op_x20</name>
          <description>MWMM operand X register 20 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001C50</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 671..640 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x21': 0xFF083C54-->
          <name>mtgy_op_x21</name>
          <description>MWMM operand X register 21 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001C54</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 703..672 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x22': 0xFF083C58-->
          <name>mtgy_op_x22</name>
          <description>MWMM operand X register 22 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001C58</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 735..704 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x23': 0xFF083C5C-->
          <name>mtgy_op_x23</name>
          <description>MWMM operand X register 23 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001C5C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 767..736 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x24': 0xFF083C60-->
          <name>mtgy_op_x24</name>
          <description>MWMM operand X register 24 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001C60</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 799..768 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x25': 0xFF083C64-->
          <name>mtgy_op_x25</name>
          <description>MWMM operand X register 25 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001C64</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 831..800 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x26': 0xFF083C68-->
          <name>mtgy_op_x26</name>
          <description>MWMM operand X register 26 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001C68</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 863..832 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x27': 0xFF083C6C-->
          <name>mtgy_op_x27</name>
          <description>MWMM operand X register 27 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001C6C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 895..864 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x28': 0xFF083C70-->
          <name>mtgy_op_x28</name>
          <description>MWMM operand X register 28 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001C70</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 927..896 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x29': 0xFF083C74-->
          <name>mtgy_op_x29</name>
          <description>MWMM operand X register 29 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001C74</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 959..928 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x30': 0xFF083C78-->
          <name>mtgy_op_x30</name>
          <description>MWMM operand X register 30 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001C78</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 991..960 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x31': 0xFF083C7C-->
          <name>mtgy_op_x31</name>
          <description>MWMM operand X register 31 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001C7C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1023..992 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x32': 0xFF083C80-->
          <name>mtgy_op_x32</name>
          <description>MWMM operand X register 32 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001C80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1055..1024 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x33': 0xFF083C84-->
          <name>mtgy_op_x33</name>
          <description>MWMM operand X register 33 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001C84</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1087..1056 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x34': 0xFF083C88-->
          <name>mtgy_op_x34</name>
          <description>MWMM operand X register 34 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001C88</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1119..1088 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x35': 0xFF083C8C-->
          <name>mtgy_op_x35</name>
          <description>MWMM operand X register 35 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001C8C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1151..1120 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x36': 0xFF083C90-->
          <name>mtgy_op_x36</name>
          <description>MWMM operand X register 36 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001C90</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1183..1152 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x37': 0xFF083C94-->
          <name>mtgy_op_x37</name>
          <description>MWMM operand X register 37 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001C94</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1215..1184 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x38': 0xFF083C98-->
          <name>mtgy_op_x38</name>
          <description>MWMM operand X register 38 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001C98</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1247..1216 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x39': 0xFF083C9C-->
          <name>mtgy_op_x39</name>
          <description>MWMM operand X register 39 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001C9C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1279..1248 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x40': 0xFF083CA0-->
          <name>mtgy_op_x40</name>
          <description>MWMM operand X register 40 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001CA0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1311..1280 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x41': 0xFF083CA4-->
          <name>mtgy_op_x41</name>
          <description>MWMM operand X register 41 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001CA4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1343..1312 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x42': 0xFF083CA8-->
          <name>mtgy_op_x42</name>
          <description>MWMM operand X register 42 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001CA8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1375..1344 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x43': 0xFF083CAC-->
          <name>mtgy_op_x43</name>
          <description>MWMM operand X register 43 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001CAC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1407..1376 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x44': 0xFF083CB0-->
          <name>mtgy_op_x44</name>
          <description>MWMM operand X register 44 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001CB0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1439..1408 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x45': 0xFF083CB4-->
          <name>mtgy_op_x45</name>
          <description>MWMM operand X register 45 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001CB4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1471..1440 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x46': 0xFF083CB8-->
          <name>mtgy_op_x46</name>
          <description>MWMM operand X register 46 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001CB8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1503..1472 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x47': 0xFF083CBC-->
          <name>mtgy_op_x47</name>
          <description>MWMM operand X register 47 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001CBC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1535..1504 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x48': 0xFF083CC0-->
          <name>mtgy_op_x48</name>
          <description>MWMM operand X register 48 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001CC0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1567..1536 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x49': 0xFF083CC4-->
          <name>mtgy_op_x49</name>
          <description>MWMM operand X register 49 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001CC4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1599..1568 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x50': 0xFF083CC8-->
          <name>mtgy_op_x50</name>
          <description>MWMM operand X register 50 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001CC8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1631..1600 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x51': 0xFF083CCC-->
          <name>mtgy_op_x51</name>
          <description>MWMM operand X register 51 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001CCC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1663..1632 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x52': 0xFF083CD0-->
          <name>mtgy_op_x52</name>
          <description>MWMM operand X register 52 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001CD0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1695..1664 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x53': 0xFF083CD4-->
          <name>mtgy_op_x53</name>
          <description>MWMM operand X register 53 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001CD4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1727..1696 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x54': 0xFF083CD8-->
          <name>mtgy_op_x54</name>
          <description>MWMM operand X register 54 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001CD8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1759..1728 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x55': 0xFF083CDC-->
          <name>mtgy_op_x55</name>
          <description>MWMM operand X register 55 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001CDC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1791..1760 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x56': 0xFF083CE0-->
          <name>mtgy_op_x56</name>
          <description>MWMM operand X register 56 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001CE0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1823..1792 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x57': 0xFF083CE4-->
          <name>mtgy_op_x57</name>
          <description>MWMM operand X register 57 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001CE4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1855..1824 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x58': 0xFF083CE8-->
          <name>mtgy_op_x58</name>
          <description>MWMM operand X register 58 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001CE8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1887..1856 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x59': 0xFF083CEC-->
          <name>mtgy_op_x59</name>
          <description>MWMM operand X register 59 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001CEC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1919..1888 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x60': 0xFF083CF0-->
          <name>mtgy_op_x60</name>
          <description>MWMM operand X register 60 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001CF0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1951..1920 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x61': 0xFF083CF4-->
          <name>mtgy_op_x61</name>
          <description>MWMM operand X register 61 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001CF4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 1983..1952 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x62': 0xFF083CF8-->
          <name>mtgy_op_x62</name>
          <description>MWMM operand X register 62 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001CF8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2015..1984 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x63': 0xFF083CFC-->
          <name>mtgy_op_x63</name>
          <description>MWMM operand X register 63 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001CFC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2047..2016 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x64': 0xFF083D00-->
          <name>mtgy_op_x64</name>
          <description>MWMM operand X register 64 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001D00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2079..2048 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x65': 0xFF083D04-->
          <name>mtgy_op_x65</name>
          <description>MWMM operand X register 65 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001D04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2111..2080 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x66': 0xFF083D08-->
          <name>mtgy_op_x66</name>
          <description>MWMM operand X register 66 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001D08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2143..2112 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x67': 0xFF083D0C-->
          <name>mtgy_op_x67</name>
          <description>MWMM operand X register 67 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001D0C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2175..2144 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x68': 0xFF083D10-->
          <name>mtgy_op_x68</name>
          <description>MWMM operand X register 68 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001D10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2207..2176 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x69': 0xFF083D14-->
          <name>mtgy_op_x69</name>
          <description>MWMM operand X register 69 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001D14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2239..2208 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x70': 0xFF083D18-->
          <name>mtgy_op_x70</name>
          <description>MWMM operand X register 70 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001D18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2271..2240 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x71': 0xFF083D1C-->
          <name>mtgy_op_x71</name>
          <description>MWMM operand X register 71 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001D1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2303..2272 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x72': 0xFF083D20-->
          <name>mtgy_op_x72</name>
          <description>MWMM operand X register 72 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001D20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2335..2304 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x73': 0xFF083D24-->
          <name>mtgy_op_x73</name>
          <description>MWMM operand X register 73 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001D24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2367..2336 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x74': 0xFF083D28-->
          <name>mtgy_op_x74</name>
          <description>MWMM operand X register 74 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001D28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2399..2368 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x75': 0xFF083D2C-->
          <name>mtgy_op_x75</name>
          <description>MWMM operand X register 75 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001D2C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2431..2400 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x76': 0xFF083D30-->
          <name>mtgy_op_x76</name>
          <description>MWMM operand X register 76 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001D30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2463..2432 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x77': 0xFF083D34-->
          <name>mtgy_op_x77</name>
          <description>MWMM operand X register 77 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001D34</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2495..2464 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x78': 0xFF083D38-->
          <name>mtgy_op_x78</name>
          <description>MWMM operand X register 78 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001D38</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2527..2496 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x79': 0xFF083D3C-->
          <name>mtgy_op_x79</name>
          <description>MWMM operand X register 79 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001D3C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2559..2528 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x80': 0xFF083D40-->
          <name>mtgy_op_x80</name>
          <description>MWMM operand X register 80 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001D40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2591..2560 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x81': 0xFF083D44-->
          <name>mtgy_op_x81</name>
          <description>MWMM operand X register 81 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001D44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2623..2592 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x82': 0xFF083D48-->
          <name>mtgy_op_x82</name>
          <description>MWMM operand X register 82 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001D48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2655..2624 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x83': 0xFF083D4C-->
          <name>mtgy_op_x83</name>
          <description>MWMM operand X register 83 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001D4C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2687..2656 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x84': 0xFF083D50-->
          <name>mtgy_op_x84</name>
          <description>MWMM operand X register 84 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001D50</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2719..2688 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x85': 0xFF083D54-->
          <name>mtgy_op_x85</name>
          <description>MWMM operand X register 85 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001D54</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2751..2720 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x86': 0xFF083D58-->
          <name>mtgy_op_x86</name>
          <description>MWMM operand X register 86 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001D58</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2783..2752 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x87': 0xFF083D5C-->
          <name>mtgy_op_x87</name>
          <description>MWMM operand X register 87 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001D5C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2815..2784 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x88': 0xFF083D60-->
          <name>mtgy_op_x88</name>
          <description>MWMM operand X register 88 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001D60</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2847..2816 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x89': 0xFF083D64-->
          <name>mtgy_op_x89</name>
          <description>MWMM operand X register 89 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001D64</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2879..2848 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x90': 0xFF083D68-->
          <name>mtgy_op_x90</name>
          <description>MWMM operand X register 90 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001D68</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2911..2880 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x91': 0xFF083D6C-->
          <name>mtgy_op_x91</name>
          <description>MWMM operand X register 91 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001D6C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2943..2912 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x92': 0xFF083D70-->
          <name>mtgy_op_x92</name>
          <description>MWMM operand X register 92 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001D70</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 2975..2944 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x93': 0xFF083D74-->
          <name>mtgy_op_x93</name>
          <description>MWMM operand X register 93 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001D74</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3007..2976 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x94': 0xFF083D78-->
          <name>mtgy_op_x94</name>
          <description>MWMM operand X register 94 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001D78</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3039..3008 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x95': 0xFF083D7C-->
          <name>mtgy_op_x95</name>
          <description>MWMM operand X register 95 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001D7C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3071..3040 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x96': 0xFF083D80-->
          <name>mtgy_op_x96</name>
          <description>MWMM operand X register 96 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001D80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3103..3072 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x97': 0xFF083D84-->
          <name>mtgy_op_x97</name>
          <description>MWMM operand X register 97 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001D84</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3135..3104 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x98': 0xFF083D88-->
          <name>mtgy_op_x98</name>
          <description>MWMM operand X register 98 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001D88</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3167..3136 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x99': 0xFF083D8C-->
          <name>mtgy_op_x99</name>
          <description>MWMM operand X register 99 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001D8C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3199..3168 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x100': 0xFF083D90-->
          <name>mtgy_op_x100</name>
          <description>MWMM operand X register 100 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001D90</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3231..3200 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x101': 0xFF083D94-->
          <name>mtgy_op_x101</name>
          <description>MWMM operand X register 101 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001D94</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3263..3232 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x102': 0xFF083D98-->
          <name>mtgy_op_x102</name>
          <description>MWMM operand X register 102 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001D98</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3295..3264 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x103': 0xFF083D9C-->
          <name>mtgy_op_x103</name>
          <description>MWMM operand X register 103 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001D9C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3327..3296 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x104': 0xFF083DA0-->
          <name>mtgy_op_x104</name>
          <description>MWMM operand X register 104 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001DA0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3359..3328 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x105': 0xFF083DA4-->
          <name>mtgy_op_x105</name>
          <description>MWMM operand X register 105 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001DA4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3391..3360 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x106': 0xFF083DA8-->
          <name>mtgy_op_x106</name>
          <description>MWMM operand X register 106 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001DA8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3423..3392 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x107': 0xFF083DAC-->
          <name>mtgy_op_x107</name>
          <description>MWMM operand X register 107 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001DAC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3455..3424 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x108': 0xFF083DB0-->
          <name>mtgy_op_x108</name>
          <description>MWMM operand X register 108 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001DB0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3487..3456 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x109': 0xFF083DB4-->
          <name>mtgy_op_x109</name>
          <description>MWMM operand X register 109 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001DB4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3519..3488 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x110': 0xFF083DB8-->
          <name>mtgy_op_x110</name>
          <description>MWMM operand X register 110 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001DB8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3551..3520 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x111': 0xFF083DBC-->
          <name>mtgy_op_x111</name>
          <description>MWMM operand X register 111 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001DBC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3583..3552 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x112': 0xFF083DC0-->
          <name>mtgy_op_x112</name>
          <description>MWMM operand X register 112 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001DC0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3615..3584 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x113': 0xFF083DC4-->
          <name>mtgy_op_x113</name>
          <description>MWMM operand X register 113 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001DC4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3647..3616 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x114': 0xFF083DC8-->
          <name>mtgy_op_x114</name>
          <description>MWMM operand X register 114 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001DC8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3679..3648 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x115': 0xFF083DCC-->
          <name>mtgy_op_x115</name>
          <description>MWMM operand X register 115 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001DCC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3711..3680 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x116': 0xFF083DD0-->
          <name>mtgy_op_x116</name>
          <description>MWMM operand X register 116 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001DD0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3743..3712 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x117': 0xFF083DD4-->
          <name>mtgy_op_x117</name>
          <description>MWMM operand X register 117 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001DD4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3775..3744 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x118': 0xFF083DD8-->
          <name>mtgy_op_x118</name>
          <description>MWMM operand X register 118 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001DD8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3807..3776 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x119': 0xFF083DDC-->
          <name>mtgy_op_x119</name>
          <description>MWMM operand X register 119 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001DDC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3839..3808 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x120': 0xFF083DE0-->
          <name>mtgy_op_x120</name>
          <description>MWMM operand X register 120 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001DE0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3871..3840 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x121': 0xFF083DE4-->
          <name>mtgy_op_x121</name>
          <description>MWMM operand X register 121 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001DE4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3903..3872 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x122': 0xFF083DE8-->
          <name>mtgy_op_x122</name>
          <description>MWMM operand X register 122 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001DE8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3935..3904 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x123': 0xFF083DEC-->
          <name>mtgy_op_x123</name>
          <description>MWMM operand X register 123 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001DEC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3967..3936 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x124': 0xFF083DF0-->
          <name>mtgy_op_x124</name>
          <description>MWMM operand X register 124 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001DF0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 3999..3968 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x125': 0xFF083DF4-->
          <name>mtgy_op_x125</name>
          <description>MWMM operand X register 125 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001DF4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 4031..4000 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x126': 0xFF083DF8-->
          <name>mtgy_op_x126</name>
          <description>MWMM operand X register 126 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001DF8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 4063..4032 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mtgy_op_x127': 0xFF083DFC-->
          <name>mtgy_op_x127</name>
          <description>MWMM operand X register 127 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00001DFC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data bits 4095..4064 </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>nfifo</name>
      <description>nfifo</description>
      <baseAddress>0xFF400000</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>4096</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>nfifo_arm_app</name>
        <value>14</value>
      </interrupt>
      <registers>
        <register>
          <!--Absolute address of 'nfifo_config': 0xFF400000-->
          <name>nfifo_config</name>
          <description>NFIFO config register 'base_config' is a pointer to start of NFIFO configuration area in memory. The configuration area must be setup by software, before using a FIFO. Each FIFO-configuration entry consists of 3 DW and contains the following: {       | mem-DW0: base(31:2),mas(1:0) mem-DW1: watm(28:16),bottom(12:0) mem-DW2: undr(31),emw(30),empty(29),write(28:16),ovfl(15),fmw(14),full(13),fill(12:0) } This allows FIFOs of up to 8k entries each. The first DWords mem-DW0 and mem-DW1 are only read by NFIFO controller. To reset a FIFO, reinit the configuration entries mem-DW0..2. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFC</resetMask>
          <fields>
            <field>
              <name>base_config</name>
              <bitRange>[31:2]</bitRange>
              <description>Pointer to base_config </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[1:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'nfifo_irq_raw': 0xFF40000C-->
          <name>nfifo_irq_raw</name>
          <description>Raw IRQ: Read access shows status of unmasked IRQs.   IRQs are set automatically and reset by writing to this register: Write access with '1' resets the appropriate IRQ. Write access with '0' does not influence this bit. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00003FFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:14]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>observe9</name>
              <bitRange>[13:13]</bitRange>
              <description>access to FIFO as defined in observe9 </description>
            </field>
            <field>
              <name>observe8</name>
              <bitRange>[12:12]</bitRange>
              <description>access to FIFO as defined in observe8 </description>
            </field>
            <field>
              <name>observe7</name>
              <bitRange>[11:11]</bitRange>
              <description>access to FIFO as defined in observe7 </description>
            </field>
            <field>
              <name>observe6</name>
              <bitRange>[10:10]</bitRange>
              <description>access to FIFO as defined in observe6 </description>
            </field>
            <field>
              <name>observe5</name>
              <bitRange>[9:9]</bitRange>
              <description>access to FIFO as defined in observe5 </description>
            </field>
            <field>
              <name>observe4</name>
              <bitRange>[8:8]</bitRange>
              <description>access to FIFO as defined in observe4 </description>
            </field>
            <field>
              <name>observe3</name>
              <bitRange>[7:7]</bitRange>
              <description>access to FIFO as defined in observe3 </description>
            </field>
            <field>
              <name>observe2</name>
              <bitRange>[6:6]</bitRange>
              <description>access to FIFO as defined in observe2 </description>
            </field>
            <field>
              <name>observe1</name>
              <bitRange>[5:5]</bitRange>
              <description>access to FIFO as defined in observe1 </description>
            </field>
            <field>
              <name>observe0</name>
              <bitRange>[4:4]</bitRange>
              <description>access to FIFO as defined in observe0 </description>
            </field>
            <field>
              <name>fifo_active</name>
              <bitRange>[3:3]</bitRange>
              <description>any access to fifo_nr/fifo_wr is active (to unlock the scheduler after locking_req) </description>
            </field>
            <field>
              <name>write</name>
              <bitRange>[2:2]</bitRange>
              <description>any write access happened to any FIFO </description>
            </field>
            <field>
              <name>read</name>
              <bitRange>[1:1]</bitRange>
              <description>any read access happened to any FIFO </description>
            </field>
            <field>
              <name>ahbl_error</name>
              <bitRange>[0:0]</bitRange>
              <description>AHBL returned HRESP=1 (abort) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'nfifo_irq_arm_app_masked': 0xFF400010-->
          <name>nfifo_irq_arm_app_masked</name>
          <description>Masked IRQ of ARM_APP: Shows status of masked IRQs as connected to application ARM Cortex M4. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000010</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00003FFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:14]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>observe9</name>
              <bitRange>[13:13]</bitRange>
              <description>access to FIFO as defined in observe9 </description>
            </field>
            <field>
              <name>observe8</name>
              <bitRange>[12:12]</bitRange>
              <description>access to FIFO as defined in observe8 </description>
            </field>
            <field>
              <name>observe7</name>
              <bitRange>[11:11]</bitRange>
              <description>access to FIFO as defined in observe7 </description>
            </field>
            <field>
              <name>observe6</name>
              <bitRange>[10:10]</bitRange>
              <description>access to FIFO as defined in observe6 </description>
            </field>
            <field>
              <name>observe5</name>
              <bitRange>[9:9]</bitRange>
              <description>access to FIFO as defined in observe5 </description>
            </field>
            <field>
              <name>observe4</name>
              <bitRange>[8:8]</bitRange>
              <description>access to FIFO as defined in observe4 </description>
            </field>
            <field>
              <name>observe3</name>
              <bitRange>[7:7]</bitRange>
              <description>access to FIFO as defined in observe3 </description>
            </field>
            <field>
              <name>observe2</name>
              <bitRange>[6:6]</bitRange>
              <description>access to FIFO as defined in observe2 </description>
            </field>
            <field>
              <name>observe1</name>
              <bitRange>[5:5]</bitRange>
              <description>access to FIFO as defined in observe1 </description>
            </field>
            <field>
              <name>observe0</name>
              <bitRange>[4:4]</bitRange>
              <description>access to FIFO as defined in observe0 </description>
            </field>
            <field>
              <name>fifo_active</name>
              <bitRange>[3:3]</bitRange>
              <description>any access to fifo_nr/fifo_wr is active (to unlock the scheduler after locking_req) </description>
            </field>
            <field>
              <name>write</name>
              <bitRange>[2:2]</bitRange>
              <description>any write access happened to any FIFO </description>
            </field>
            <field>
              <name>read</name>
              <bitRange>[1:1]</bitRange>
              <description>any read access happened to any FIFO </description>
            </field>
            <field>
              <name>ahbl_error</name>
              <bitRange>[0:0]</bitRange>
              <description>AHBL returned HRESP=1 (abort) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'nfifo_irq_arm_app_msk_set': 0xFF400014-->
          <name>nfifo_irq_arm_app_msk_set</name>
          <description>ARM_APP Cortex M4 IRQ mask set: The IRQ mask enables interrupt requests for corresponding interrupt sources to the ARM_APP processor.   As its bits might be changed by different software tasks,   the IRQ mask register is not writable directly, but by set and reset masks: Write access with '1' sets interrupt mask bit. Write access with '0' does not influence this bit. Read access shows actual interrupt mask. Attention: Before activating interrupt mask, delete old pending interrupts by writing the same value to adr_nfifo_irq_raw. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00003FFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:14]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>observe9</name>
              <bitRange>[13:13]</bitRange>
              <description>access to FIFO as defined in observe9 </description>
            </field>
            <field>
              <name>observe8</name>
              <bitRange>[12:12]</bitRange>
              <description>access to FIFO as defined in observe8 </description>
            </field>
            <field>
              <name>observe7</name>
              <bitRange>[11:11]</bitRange>
              <description>access to FIFO as defined in observe7 </description>
            </field>
            <field>
              <name>observe6</name>
              <bitRange>[10:10]</bitRange>
              <description>access to FIFO as defined in observe6 </description>
            </field>
            <field>
              <name>observe5</name>
              <bitRange>[9:9]</bitRange>
              <description>access to FIFO as defined in observe5 </description>
            </field>
            <field>
              <name>observe4</name>
              <bitRange>[8:8]</bitRange>
              <description>access to FIFO as defined in observe4 </description>
            </field>
            <field>
              <name>observe3</name>
              <bitRange>[7:7]</bitRange>
              <description>access to FIFO as defined in observe3 </description>
            </field>
            <field>
              <name>observe2</name>
              <bitRange>[6:6]</bitRange>
              <description>access to FIFO as defined in observe2 </description>
            </field>
            <field>
              <name>observe1</name>
              <bitRange>[5:5]</bitRange>
              <description>access to FIFO as defined in observe1 </description>
            </field>
            <field>
              <name>observe0</name>
              <bitRange>[4:4]</bitRange>
              <description>access to FIFO as defined in observe0 </description>
            </field>
            <field>
              <name>fifo_active</name>
              <bitRange>[3:3]</bitRange>
              <description>any access to fifo_nr/fifo_wr is active (to unlock the scheduler after locking_req) </description>
            </field>
            <field>
              <name>write</name>
              <bitRange>[2:2]</bitRange>
              <description>any write access happened to any FIFO </description>
            </field>
            <field>
              <name>read</name>
              <bitRange>[1:1]</bitRange>
              <description>any read access happened to any FIFO </description>
            </field>
            <field>
              <name>ahbl_error</name>
              <bitRange>[0:0]</bitRange>
              <description>AHBL returned HRESP=1 (abort) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'nfifo_irq_arm_app_msk_reset': 0xFF400018-->
          <name>nfifo_irq_arm_app_msk_reset</name>
          <description>ARM_APP Cortex M4 IRQ mask reset: This is the corresponding reset mask to disable interrupt requests for corresponding interrupt sources: Write access with '1' resets interrupt mask bit. Write access with '0' does not influence this bit. Read access shows actual interrupt mask. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000018</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00003FFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:14]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>observe9</name>
              <bitRange>[13:13]</bitRange>
              <description>access to FIFO as defined in observe9 </description>
            </field>
            <field>
              <name>observe8</name>
              <bitRange>[12:12]</bitRange>
              <description>access to FIFO as defined in observe8 </description>
            </field>
            <field>
              <name>observe7</name>
              <bitRange>[11:11]</bitRange>
              <description>access to FIFO as defined in observe7 </description>
            </field>
            <field>
              <name>observe6</name>
              <bitRange>[10:10]</bitRange>
              <description>access to FIFO as defined in observe6 </description>
            </field>
            <field>
              <name>observe5</name>
              <bitRange>[9:9]</bitRange>
              <description>access to FIFO as defined in observe5 </description>
            </field>
            <field>
              <name>observe4</name>
              <bitRange>[8:8]</bitRange>
              <description>access to FIFO as defined in observe4 </description>
            </field>
            <field>
              <name>observe3</name>
              <bitRange>[7:7]</bitRange>
              <description>access to FIFO as defined in observe3 </description>
            </field>
            <field>
              <name>observe2</name>
              <bitRange>[6:6]</bitRange>
              <description>access to FIFO as defined in observe2 </description>
            </field>
            <field>
              <name>observe1</name>
              <bitRange>[5:5]</bitRange>
              <description>access to FIFO as defined in observe1 </description>
            </field>
            <field>
              <name>observe0</name>
              <bitRange>[4:4]</bitRange>
              <description>access to FIFO as defined in observe0 </description>
            </field>
            <field>
              <name>fifo_active</name>
              <bitRange>[3:3]</bitRange>
              <description>any access to fifo_nr/fifo_wr is active (to unlock the scheduler after locking_req) </description>
            </field>
            <field>
              <name>write</name>
              <bitRange>[2:2]</bitRange>
              <description>any write access happened to any FIFO </description>
            </field>
            <field>
              <name>read</name>
              <bitRange>[1:1]</bitRange>
              <description>any read access happened to any FIFO </description>
            </field>
            <field>
              <name>ahbl_error</name>
              <bitRange>[0:0]</bitRange>
              <description>AHBL returned HRESP=1 (abort) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'nfifo_irq_xpic_app_masked': 0xFF400028-->
          <name>nfifo_irq_xpic_app_masked</name>
          <description>Masked IRQ of xPIC_APP: Shows status of masked IRQs as connected to xPIC_APP. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000028</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00003FFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:14]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>observe9</name>
              <bitRange>[13:13]</bitRange>
              <description>access to FIFO as defined in observe9 </description>
            </field>
            <field>
              <name>observe8</name>
              <bitRange>[12:12]</bitRange>
              <description>access to FIFO as defined in observe8 </description>
            </field>
            <field>
              <name>observe7</name>
              <bitRange>[11:11]</bitRange>
              <description>access to FIFO as defined in observe7 </description>
            </field>
            <field>
              <name>observe6</name>
              <bitRange>[10:10]</bitRange>
              <description>access to FIFO as defined in observe6 </description>
            </field>
            <field>
              <name>observe5</name>
              <bitRange>[9:9]</bitRange>
              <description>access to FIFO as defined in observe5 </description>
            </field>
            <field>
              <name>observe4</name>
              <bitRange>[8:8]</bitRange>
              <description>access to FIFO as defined in observe4 </description>
            </field>
            <field>
              <name>observe3</name>
              <bitRange>[7:7]</bitRange>
              <description>access to FIFO as defined in observe3 </description>
            </field>
            <field>
              <name>observe2</name>
              <bitRange>[6:6]</bitRange>
              <description>access to FIFO as defined in observe2 </description>
            </field>
            <field>
              <name>observe1</name>
              <bitRange>[5:5]</bitRange>
              <description>access to FIFO as defined in observe1 </description>
            </field>
            <field>
              <name>observe0</name>
              <bitRange>[4:4]</bitRange>
              <description>access to FIFO as defined in observe0 </description>
            </field>
            <field>
              <name>fifo_active</name>
              <bitRange>[3:3]</bitRange>
              <description>any access to fifo_nr/fifo_wr is active (to unlock the scheduler after locking_req) </description>
            </field>
            <field>
              <name>write</name>
              <bitRange>[2:2]</bitRange>
              <description>any write access happened to any FIFO </description>
            </field>
            <field>
              <name>read</name>
              <bitRange>[1:1]</bitRange>
              <description>any read access happened to any FIFO </description>
            </field>
            <field>
              <name>ahbl_error</name>
              <bitRange>[0:0]</bitRange>
              <description>AHBL returned HRESP=1 (abort) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'nfifo_irq_xpic_app_msk_set': 0xFF40002C-->
          <name>nfifo_irq_xpic_app_msk_set</name>
          <description>xPIC_APP IRQ mask set: The xPIC_APP IRQ mask enables interrupt requests for corresponding interrupt sources to the xPIC_APP processor.   As its bits might be changed by different software tasks,   the IRQ mask register is not writable directly, but by set and reset masks: Write access with '1' sets interrupt mask bit. Write access with '0' does not influence this bit. Read access shows actual interrupt mask. Attention: Before activating interrupt mask, delete old pending interrupts by writing the same value to adr_nfifo_irq_raw. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000002C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00003FFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:14]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>observe9</name>
              <bitRange>[13:13]</bitRange>
              <description>access to FIFO as defined in observe9 </description>
            </field>
            <field>
              <name>observe8</name>
              <bitRange>[12:12]</bitRange>
              <description>access to FIFO as defined in observe8 </description>
            </field>
            <field>
              <name>observe7</name>
              <bitRange>[11:11]</bitRange>
              <description>access to FIFO as defined in observe7 </description>
            </field>
            <field>
              <name>observe6</name>
              <bitRange>[10:10]</bitRange>
              <description>access to FIFO as defined in observe6 </description>
            </field>
            <field>
              <name>observe5</name>
              <bitRange>[9:9]</bitRange>
              <description>access to FIFO as defined in observe5 </description>
            </field>
            <field>
              <name>observe4</name>
              <bitRange>[8:8]</bitRange>
              <description>access to FIFO as defined in observe4 </description>
            </field>
            <field>
              <name>observe3</name>
              <bitRange>[7:7]</bitRange>
              <description>access to FIFO as defined in observe3 </description>
            </field>
            <field>
              <name>observe2</name>
              <bitRange>[6:6]</bitRange>
              <description>access to FIFO as defined in observe2 </description>
            </field>
            <field>
              <name>observe1</name>
              <bitRange>[5:5]</bitRange>
              <description>access to FIFO as defined in observe1 </description>
            </field>
            <field>
              <name>observe0</name>
              <bitRange>[4:4]</bitRange>
              <description>access to FIFO as defined in observe0 </description>
            </field>
            <field>
              <name>fifo_active</name>
              <bitRange>[3:3]</bitRange>
              <description>any access to fifo_nr/fifo_wr is active (to unlock the scheduler after locking_req) </description>
            </field>
            <field>
              <name>write</name>
              <bitRange>[2:2]</bitRange>
              <description>any write access happened to any FIFO </description>
            </field>
            <field>
              <name>read</name>
              <bitRange>[1:1]</bitRange>
              <description>any read access happened to any FIFO </description>
            </field>
            <field>
              <name>ahbl_error</name>
              <bitRange>[0:0]</bitRange>
              <description>AHBL returned HRESP=1 (abort) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'nfifo_irq_xpic_app_msk_reset': 0xFF400030-->
          <name>nfifo_irq_xpic_app_msk_reset</name>
          <description>xPIC_APP IRQ mask reset: This is the corresponding reset mask to disable interrupt requests for corresponding interrupt sources: Write access with '1' resets interrupt mask bit. Write access with '0' does not influence this bit. Read access shows actual interrupt mask. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000030</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00003FFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:14]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>observe9</name>
              <bitRange>[13:13]</bitRange>
              <description>access to FIFO as defined in observe9 </description>
            </field>
            <field>
              <name>observe8</name>
              <bitRange>[12:12]</bitRange>
              <description>access to FIFO as defined in observe8 </description>
            </field>
            <field>
              <name>observe7</name>
              <bitRange>[11:11]</bitRange>
              <description>access to FIFO as defined in observe7 </description>
            </field>
            <field>
              <name>observe6</name>
              <bitRange>[10:10]</bitRange>
              <description>access to FIFO as defined in observe6 </description>
            </field>
            <field>
              <name>observe5</name>
              <bitRange>[9:9]</bitRange>
              <description>access to FIFO as defined in observe5 </description>
            </field>
            <field>
              <name>observe4</name>
              <bitRange>[8:8]</bitRange>
              <description>access to FIFO as defined in observe4 </description>
            </field>
            <field>
              <name>observe3</name>
              <bitRange>[7:7]</bitRange>
              <description>access to FIFO as defined in observe3 </description>
            </field>
            <field>
              <name>observe2</name>
              <bitRange>[6:6]</bitRange>
              <description>access to FIFO as defined in observe2 </description>
            </field>
            <field>
              <name>observe1</name>
              <bitRange>[5:5]</bitRange>
              <description>access to FIFO as defined in observe1 </description>
            </field>
            <field>
              <name>observe0</name>
              <bitRange>[4:4]</bitRange>
              <description>access to FIFO as defined in observe0 </description>
            </field>
            <field>
              <name>fifo_active</name>
              <bitRange>[3:3]</bitRange>
              <description>any access to fifo_nr/fifo_wr is active (to unlock the scheduler after locking_req) </description>
            </field>
            <field>
              <name>write</name>
              <bitRange>[2:2]</bitRange>
              <description>any write access happened to any FIFO </description>
            </field>
            <field>
              <name>read</name>
              <bitRange>[1:1]</bitRange>
              <description>any read access happened to any FIFO </description>
            </field>
            <field>
              <name>ahbl_error</name>
              <bitRange>[0:0]</bitRange>
              <description>AHBL returned HRESP=1 (abort) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'nfifo_irq_observe0': 0xFF400058-->
          <name>nfifo_irq_observe0</name>
          <description>FIFO OBSERVE0: This register configures the observation unit that allows to observe one FIFO for special events </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000058</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x007F83FF</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:23]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>full</name>
              <bitRange>[22:22]</bitRange>
              <description>Activate IRQ in case of FIFO gets full </description>
            </field>
            <field>
              <name>fmw</name>
              <bitRange>[21:21]</bitRange>
              <description>Activate IRQ in case of Full-Minus-Watermark is set </description>
            </field>
            <field>
              <name>ovfl</name>
              <bitRange>[20:20]</bitRange>
              <description>Activate IRQ in case of FIFO overflow </description>
            </field>
            <field>
              <name>write</name>
              <bitRange>[19:19]</bitRange>
              <description>Activate IRQ in case of any write access </description>
            </field>
            <field>
              <name>empty</name>
              <bitRange>[18:18]</bitRange>
              <description>Activate IRQ in case of FIFO gets empty </description>
            </field>
            <field>
              <name>emw</name>
              <bitRange>[17:17]</bitRange>
              <description>Activate IRQ in case of Empty-Minus-Watermark is set </description>
            </field>
            <field>
              <name>undr</name>
              <bitRange>[16:16]</bitRange>
              <description>Activate IRQ in case of FIFO underrun </description>
            </field>
            <field>
              <name>read</name>
              <bitRange>[15:15]</bitRange>
              <description>Activate IRQ in case of any read access </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[14:10]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>fifonr</name>
              <bitRange>[9:0]</bitRange>
              <description>Number of FIFO to be observed </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'nfifo_irq_observe1': 0xFF40005C-->
          <name>nfifo_irq_observe1</name>
          <description>FIFO OBSERVE1: This register configures the observation unit that allows to observe one FIFO for special events </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000005C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x007F83FF</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:23]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>full</name>
              <bitRange>[22:22]</bitRange>
              <description>Activate IRQ in case of FIFO gets full </description>
            </field>
            <field>
              <name>fmw</name>
              <bitRange>[21:21]</bitRange>
              <description>Activate IRQ in case of Full-Minus-Watermark is set </description>
            </field>
            <field>
              <name>ovfl</name>
              <bitRange>[20:20]</bitRange>
              <description>Activate IRQ in case of FIFO overflow </description>
            </field>
            <field>
              <name>write</name>
              <bitRange>[19:19]</bitRange>
              <description>Activate IRQ in case of any write access </description>
            </field>
            <field>
              <name>empty</name>
              <bitRange>[18:18]</bitRange>
              <description>Activate IRQ in case of FIFO gets empty </description>
            </field>
            <field>
              <name>emw</name>
              <bitRange>[17:17]</bitRange>
              <description>Activate IRQ in case of Empty-Minus-Watermark is set </description>
            </field>
            <field>
              <name>undr</name>
              <bitRange>[16:16]</bitRange>
              <description>Activate IRQ in case of FIFO underrun </description>
            </field>
            <field>
              <name>read</name>
              <bitRange>[15:15]</bitRange>
              <description>Activate IRQ in case of any read access </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[14:10]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>fifonr</name>
              <bitRange>[9:0]</bitRange>
              <description>Number of FIFO to be observed </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'nfifo_irq_observe2': 0xFF400060-->
          <name>nfifo_irq_observe2</name>
          <description>FIFO OBSERVE2: This register configures the observation unit that allows to observe one FIFO for special events </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000060</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x007F83FF</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:23]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>full</name>
              <bitRange>[22:22]</bitRange>
              <description>Activate IRQ in case of FIFO gets full </description>
            </field>
            <field>
              <name>fmw</name>
              <bitRange>[21:21]</bitRange>
              <description>Activate IRQ in case of Full-Minus-Watermark is set </description>
            </field>
            <field>
              <name>ovfl</name>
              <bitRange>[20:20]</bitRange>
              <description>Activate IRQ in case of FIFO overflow </description>
            </field>
            <field>
              <name>write</name>
              <bitRange>[19:19]</bitRange>
              <description>Activate IRQ in case of any write access </description>
            </field>
            <field>
              <name>empty</name>
              <bitRange>[18:18]</bitRange>
              <description>Activate IRQ in case of FIFO gets empty </description>
            </field>
            <field>
              <name>emw</name>
              <bitRange>[17:17]</bitRange>
              <description>Activate IRQ in case of Empty-Minus-Watermark is set </description>
            </field>
            <field>
              <name>undr</name>
              <bitRange>[16:16]</bitRange>
              <description>Activate IRQ in case of FIFO underrun </description>
            </field>
            <field>
              <name>read</name>
              <bitRange>[15:15]</bitRange>
              <description>Activate IRQ in case of any read access </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[14:10]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>fifonr</name>
              <bitRange>[9:0]</bitRange>
              <description>Number of FIFO to be observed </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'nfifo_irq_observe3': 0xFF400064-->
          <name>nfifo_irq_observe3</name>
          <description>FIFO OBSERVE3: This register configures the observation unit that allows to observe one FIFO for special events </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000064</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x007F83FF</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:23]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>full</name>
              <bitRange>[22:22]</bitRange>
              <description>Activate IRQ in case of FIFO gets full </description>
            </field>
            <field>
              <name>fmw</name>
              <bitRange>[21:21]</bitRange>
              <description>Activate IRQ in case of Full-Minus-Watermark is set </description>
            </field>
            <field>
              <name>ovfl</name>
              <bitRange>[20:20]</bitRange>
              <description>Activate IRQ in case of FIFO overflow </description>
            </field>
            <field>
              <name>write</name>
              <bitRange>[19:19]</bitRange>
              <description>Activate IRQ in case of any write access </description>
            </field>
            <field>
              <name>empty</name>
              <bitRange>[18:18]</bitRange>
              <description>Activate IRQ in case of FIFO gets empty </description>
            </field>
            <field>
              <name>emw</name>
              <bitRange>[17:17]</bitRange>
              <description>Activate IRQ in case of Empty-Minus-Watermark is set </description>
            </field>
            <field>
              <name>undr</name>
              <bitRange>[16:16]</bitRange>
              <description>Activate IRQ in case of FIFO underrun </description>
            </field>
            <field>
              <name>read</name>
              <bitRange>[15:15]</bitRange>
              <description>Activate IRQ in case of any read access </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[14:10]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>fifonr</name>
              <bitRange>[9:0]</bitRange>
              <description>Number of FIFO to be observed </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'nfifo_irq_observe4': 0xFF400068-->
          <name>nfifo_irq_observe4</name>
          <description>FIFO OBSERVE4: This register configures the observation unit that allows to observe one FIFO for special events </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000068</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x007F83FF</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:23]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>full</name>
              <bitRange>[22:22]</bitRange>
              <description>Activate IRQ in case of FIFO gets full </description>
            </field>
            <field>
              <name>fmw</name>
              <bitRange>[21:21]</bitRange>
              <description>Activate IRQ in case of Full-Minus-Watermark is set </description>
            </field>
            <field>
              <name>ovfl</name>
              <bitRange>[20:20]</bitRange>
              <description>Activate IRQ in case of FIFO overflow </description>
            </field>
            <field>
              <name>write</name>
              <bitRange>[19:19]</bitRange>
              <description>Activate IRQ in case of any write access </description>
            </field>
            <field>
              <name>empty</name>
              <bitRange>[18:18]</bitRange>
              <description>Activate IRQ in case of FIFO gets empty </description>
            </field>
            <field>
              <name>emw</name>
              <bitRange>[17:17]</bitRange>
              <description>Activate IRQ in case of Empty-Minus-Watermark is set </description>
            </field>
            <field>
              <name>undr</name>
              <bitRange>[16:16]</bitRange>
              <description>Activate IRQ in case of FIFO underrun </description>
            </field>
            <field>
              <name>read</name>
              <bitRange>[15:15]</bitRange>
              <description>Activate IRQ in case of any read access </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[14:10]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>fifonr</name>
              <bitRange>[9:0]</bitRange>
              <description>Number of FIFO to be observed </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'nfifo_irq_observe5': 0xFF40006C-->
          <name>nfifo_irq_observe5</name>
          <description>FIFO OBSERVE5: This register configures the observation unit that allows to observe one FIFO for special events </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000006C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x007F83FF</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:23]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>full</name>
              <bitRange>[22:22]</bitRange>
              <description>Activate IRQ in case of FIFO gets full </description>
            </field>
            <field>
              <name>fmw</name>
              <bitRange>[21:21]</bitRange>
              <description>Activate IRQ in case of Full-Minus-Watermark is set </description>
            </field>
            <field>
              <name>ovfl</name>
              <bitRange>[20:20]</bitRange>
              <description>Activate IRQ in case of FIFO overflow </description>
            </field>
            <field>
              <name>write</name>
              <bitRange>[19:19]</bitRange>
              <description>Activate IRQ in case of any write access </description>
            </field>
            <field>
              <name>empty</name>
              <bitRange>[18:18]</bitRange>
              <description>Activate IRQ in case of FIFO gets empty </description>
            </field>
            <field>
              <name>emw</name>
              <bitRange>[17:17]</bitRange>
              <description>Activate IRQ in case of Empty-Minus-Watermark is set </description>
            </field>
            <field>
              <name>undr</name>
              <bitRange>[16:16]</bitRange>
              <description>Activate IRQ in case of FIFO underrun </description>
            </field>
            <field>
              <name>read</name>
              <bitRange>[15:15]</bitRange>
              <description>Activate IRQ in case of any read access </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[14:10]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>fifonr</name>
              <bitRange>[9:0]</bitRange>
              <description>Number of FIFO to be observed </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'nfifo_irq_observe6': 0xFF400070-->
          <name>nfifo_irq_observe6</name>
          <description>FIFO OBSERVE6: This register configures the observation unit that allows to observe one FIFO for special events </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000070</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x007F83FF</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:23]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>full</name>
              <bitRange>[22:22]</bitRange>
              <description>Activate IRQ in case of FIFO gets full </description>
            </field>
            <field>
              <name>fmw</name>
              <bitRange>[21:21]</bitRange>
              <description>Activate IRQ in case of Full-Minus-Watermark is set </description>
            </field>
            <field>
              <name>ovfl</name>
              <bitRange>[20:20]</bitRange>
              <description>Activate IRQ in case of FIFO overflow </description>
            </field>
            <field>
              <name>write</name>
              <bitRange>[19:19]</bitRange>
              <description>Activate IRQ in case of any write access </description>
            </field>
            <field>
              <name>empty</name>
              <bitRange>[18:18]</bitRange>
              <description>Activate IRQ in case of FIFO gets empty </description>
            </field>
            <field>
              <name>emw</name>
              <bitRange>[17:17]</bitRange>
              <description>Activate IRQ in case of Empty-Minus-Watermark is set </description>
            </field>
            <field>
              <name>undr</name>
              <bitRange>[16:16]</bitRange>
              <description>Activate IRQ in case of FIFO underrun </description>
            </field>
            <field>
              <name>read</name>
              <bitRange>[15:15]</bitRange>
              <description>Activate IRQ in case of any read access </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[14:10]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>fifonr</name>
              <bitRange>[9:0]</bitRange>
              <description>Number of FIFO to be observed </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'nfifo_irq_observe7': 0xFF400074-->
          <name>nfifo_irq_observe7</name>
          <description>FIFO OBSERVE7: This register configures the observation unit that allows to observe one FIFO for special events </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000074</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x007F83FF</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:23]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>full</name>
              <bitRange>[22:22]</bitRange>
              <description>Activate IRQ in case of FIFO gets full </description>
            </field>
            <field>
              <name>fmw</name>
              <bitRange>[21:21]</bitRange>
              <description>Activate IRQ in case of Full-Minus-Watermark is set </description>
            </field>
            <field>
              <name>ovfl</name>
              <bitRange>[20:20]</bitRange>
              <description>Activate IRQ in case of FIFO overflow </description>
            </field>
            <field>
              <name>write</name>
              <bitRange>[19:19]</bitRange>
              <description>Activate IRQ in case of any write access </description>
            </field>
            <field>
              <name>empty</name>
              <bitRange>[18:18]</bitRange>
              <description>Activate IRQ in case of FIFO gets empty </description>
            </field>
            <field>
              <name>emw</name>
              <bitRange>[17:17]</bitRange>
              <description>Activate IRQ in case of Empty-Minus-Watermark is set </description>
            </field>
            <field>
              <name>undr</name>
              <bitRange>[16:16]</bitRange>
              <description>Activate IRQ in case of FIFO underrun </description>
            </field>
            <field>
              <name>read</name>
              <bitRange>[15:15]</bitRange>
              <description>Activate IRQ in case of any read access </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[14:10]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>fifonr</name>
              <bitRange>[9:0]</bitRange>
              <description>Number of FIFO to be observed </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'nfifo_irq_observe8': 0xFF400078-->
          <name>nfifo_irq_observe8</name>
          <description>FIFO OBSERVE8: This register configures the observation unit that allows to observe one FIFO for special events </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000078</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x007F83FF</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:23]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>full</name>
              <bitRange>[22:22]</bitRange>
              <description>Activate IRQ in case of FIFO gets full </description>
            </field>
            <field>
              <name>fmw</name>
              <bitRange>[21:21]</bitRange>
              <description>Activate IRQ in case of Full-Minus-Watermark is set </description>
            </field>
            <field>
              <name>ovfl</name>
              <bitRange>[20:20]</bitRange>
              <description>Activate IRQ in case of FIFO overflow </description>
            </field>
            <field>
              <name>write</name>
              <bitRange>[19:19]</bitRange>
              <description>Activate IRQ in case of any write access </description>
            </field>
            <field>
              <name>empty</name>
              <bitRange>[18:18]</bitRange>
              <description>Activate IRQ in case of FIFO gets empty </description>
            </field>
            <field>
              <name>emw</name>
              <bitRange>[17:17]</bitRange>
              <description>Activate IRQ in case of Empty-Minus-Watermark is set </description>
            </field>
            <field>
              <name>undr</name>
              <bitRange>[16:16]</bitRange>
              <description>Activate IRQ in case of FIFO underrun </description>
            </field>
            <field>
              <name>read</name>
              <bitRange>[15:15]</bitRange>
              <description>Activate IRQ in case of any read access </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[14:10]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>fifonr</name>
              <bitRange>[9:0]</bitRange>
              <description>Number of FIFO to be observed </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'nfifo_irq_observe9': 0xFF40007C-->
          <name>nfifo_irq_observe9</name>
          <description>FIFO OBSERVE9: This register configures the observation unit that allows to observe one FIFO for special events </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000007C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x007F83FF</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:23]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>full</name>
              <bitRange>[22:22]</bitRange>
              <description>Activate IRQ in case of FIFO gets full </description>
            </field>
            <field>
              <name>fmw</name>
              <bitRange>[21:21]</bitRange>
              <description>Activate IRQ in case of Full-Minus-Watermark is set </description>
            </field>
            <field>
              <name>ovfl</name>
              <bitRange>[20:20]</bitRange>
              <description>Activate IRQ in case of FIFO overflow </description>
            </field>
            <field>
              <name>write</name>
              <bitRange>[19:19]</bitRange>
              <description>Activate IRQ in case of any write access </description>
            </field>
            <field>
              <name>empty</name>
              <bitRange>[18:18]</bitRange>
              <description>Activate IRQ in case of FIFO gets empty </description>
            </field>
            <field>
              <name>emw</name>
              <bitRange>[17:17]</bitRange>
              <description>Activate IRQ in case of Empty-Minus-Watermark is set </description>
            </field>
            <field>
              <name>undr</name>
              <bitRange>[16:16]</bitRange>
              <description>Activate IRQ in case of FIFO underrun </description>
            </field>
            <field>
              <name>read</name>
              <bitRange>[15:15]</bitRange>
              <description>Activate IRQ in case of any read access </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[14:10]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>fifonr</name>
              <bitRange>[9:0]</bitRange>
              <description>Number of FIFO to be observed </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'nfifo_fifo_start': 0xFF400080-->
          <name>nfifo_fifo_start</name>
          <description>Start of NFIFO FIFO access addresses: The following DW-addresses are associated with FIFOs: Read accesses to an address in this area are reading from the appropriate FIFO, write accesses to an address in this area are writing to the appropriate FIFO. The number of FIFOs is limited by this address area to 991. </description>
          <dataType>uint32_t *</dataType>
          <addressOffset>0x00000080</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'nfifo_fifo_end': 0xFF400FFC-->
          <name>nfifo_fifo_end</name>
          <description>End of NFIFO FIFO access addresses </description>
          <dataType>uint32_t *</dataType>
          <addressOffset>0x00000FFC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>pad_ctrl</name>
      <description>pad_ctrl</description>
      <baseAddress>0xFF401000</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>512</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <!--Absolute address of 'pad_ctrl_rdy_n': 0xFF401000-->
          <name>pad_ctrl_rdy_n</name>
          <description>Pad configuration register of port RDY_N (asic_ctrl_access_key protected). Pad type: PRUW0408SCDG_33 This register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: 1.: read out access-key from asic_ctrl_access_key register 2.: write back access-key to asic_ctrl_access_key register 3.: write desired value to this register Programable pad functions are:    ds:   Driving strength: 0: low driving strength (default), 1: high driving strength.    pe:   Pull enable: 0: No resistor is applied, 1: resistor is enabled.          The pull-direction (up or down) is determined by the pad-type.    ie:   Input enable: 0: Digital pad input function disabled, 1: input is enabled. Note:    Not all functions are available for all pads, it depends on the pad type.    Functions not found as programmable bit in the register of a pad are not supported by the pad. Note:    During a power cycle (power up or when a power watch detects an invalid supply), all IOs are    undriven (output enable is off). Additionally the following states are forced to the IOs (POC-states):    pe:   0   Attention: the internal push/pull resistors are not applied during a power cycle.    ds:   1   (no impact as outputs are disabled)    ie:   0   (no impact as core is in reset)    After all power watches have detected a stable power state, the netX enters the reset state. At that moment    the default values of the PAD_CTRL registers will be applied to the IOs. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-up pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_run_n': 0xFF401004-->
          <name>pad_ctrl_run_n</name>
          <description>Pad configuration register of port RUN_N (asic_ctrl_access_key protected). Pad type: PRUW0408SCDG_33 For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-up pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_mled0': 0xFF401008-->
          <name>pad_ctrl_mled0</name>
          <description>Pad configuration register of port MLED0 (asic_ctrl_access_key protected). Pad type: PRDW0408CDG_33(o_sc) For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000011</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-down pad, disabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_mled1': 0xFF40100C-->
          <name>pad_ctrl_mled1</name>
          <description>Pad configuration register of port MLED1 (asic_ctrl_access_key protected). Pad type: PRDW0408CDG_33(o_sc) For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000011</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-down pad, disabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_mled2': 0xFF401010-->
          <name>pad_ctrl_mled2</name>
          <description>Pad configuration register of port MLED2 (asic_ctrl_access_key protected). Pad type: PRDW0408CDG_33(o) For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000011</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-down pad, disabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_mled3': 0xFF401014-->
          <name>pad_ctrl_mled3</name>
          <description>Pad configuration register of port MLED3 (asic_ctrl_access_key protected). Pad type: PRDW0408CDG_33(o) For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000011</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-down pad, disabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_com_io0': 0xFF401018-->
          <name>pad_ctrl_com_io0</name>
          <description>Pad configuration register of port COM_IO0 (asic_ctrl_access_key protected). Pad type: PRDW0408SCDG_ANA_SW_33(adc3) For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000018</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000010</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (shared analog function, disabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-down pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_com_io1': 0xFF40101C-->
          <name>pad_ctrl_com_io1</name>
          <description>Pad configuration register of port COM_IO1 (asic_ctrl_access_key protected). Pad type: PRDW0408SCDG_ANA_SW_33(adc3) For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000001C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000010</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (shared analog function, disabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-down pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_com_io2': 0xFF401020-->
          <name>pad_ctrl_com_io2</name>
          <description>Pad configuration register of port COM_IO2 (asic_ctrl_access_key protected). Pad type: PRDW0408SCDG_ANA_SW_33(adc3) For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000010</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (shared analog function, disabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-down pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_com_io3': 0xFF401024-->
          <name>pad_ctrl_com_io3</name>
          <description>Pad configuration register of port COM_IO3 (asic_ctrl_access_key protected). Pad type: PRDW0408SCDG_ANA_SW_33(adc3) For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000024</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000010</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (shared analog function, disabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-down pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_uart_rxd': 0xFF401028-->
          <name>pad_ctrl_uart_rxd</name>
          <description>Pad configuration register of port UART_RXD (asic_ctrl_access_key protected). Pad type: PDDW0204SCDG_33(i) For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000028</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000050</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-down pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_uart_txd': 0xFF40102C-->
          <name>pad_ctrl_uart_txd</name>
          <description>Pad configuration register of port UART_TXD (asic_ctrl_access_key protected). Pad type: PRDW0408CDG_33(o) For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000002C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000010</resetValue>
          <resetMask>0x00000011</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-down pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_mii0_rxclk': 0xFF401030-->
          <name>pad_ctrl_mii0_rxclk</name>
          <description>Pad configuration register of port MII0_RXCLK (asic_ctrl_access_key protected). Pad type: PRDW0408SCDG_33 For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000030</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-down pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_mii0_rxd0': 0xFF401034-->
          <name>pad_ctrl_mii0_rxd0</name>
          <description>Pad configuration register of port MII0_RXD0 (asic_ctrl_access_key protected). Pad type: PDDW0204SCDG_33(i) For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000034</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000050</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-down pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_mii0_rxd1': 0xFF401038-->
          <name>pad_ctrl_mii0_rxd1</name>
          <description>Pad configuration register of port MII0_RXD1 (asic_ctrl_access_key protected). Pad type: PDDW0408SCDG_33 For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000038</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-down pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_mii0_rxd2': 0xFF40103C-->
          <name>pad_ctrl_mii0_rxd2</name>
          <description>Pad configuration register of port MII0_RXD2 (asic_ctrl_access_key protected). Pad type: PRDW0408SCDG_33 For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000003C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-down pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_mii0_rxd3': 0xFF401040-->
          <name>pad_ctrl_mii0_rxd3</name>
          <description>Pad configuration register of port MII0_RXD3 (asic_ctrl_access_key protected). Pad type: PDDW0204SCDG_33(i) For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000040</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000050</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-down pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_mii0_rxdv': 0xFF401044-->
          <name>pad_ctrl_mii0_rxdv</name>
          <description>Pad configuration register of port MII0_RXDV (asic_ctrl_access_key protected). Pad type: PDDW0204SCDG_33(i) For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000044</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000050</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-down pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_mii0_rxer': 0xFF401048-->
          <name>pad_ctrl_mii0_rxer</name>
          <description>Pad configuration register of port MII0_RXER (asic_ctrl_access_key protected). Pad type: PDDW0204SCDG_33(i) For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000048</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000050</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-down pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_mii0_txclk': 0xFF40104C-->
          <name>pad_ctrl_mii0_txclk</name>
          <description>Pad configuration register of port MII0_TXCLK (asic_ctrl_access_key protected). Pad type: PRDW0408SCDG_33 For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000004C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-down pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_mii0_txd0': 0xFF401050-->
          <name>pad_ctrl_mii0_txd0</name>
          <description>Pad configuration register of port MII0_TXD0 (asic_ctrl_access_key protected). Pad type: PRDW0408SCDG_ANA_SW_33(adc2) For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000050</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000010</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (shared analog function, disabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-down pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_mii0_txd1': 0xFF401054-->
          <name>pad_ctrl_mii0_txd1</name>
          <description>Pad configuration register of port MII0_TXD1 (asic_ctrl_access_key protected). Pad type: PRDW0408SCDG_ANA_SW_33(adc3) For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000054</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000010</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (shared analog function, disabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-down pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_mii0_txd2': 0xFF401058-->
          <name>pad_ctrl_mii0_txd2</name>
          <description>Pad configuration register of port MII0_TXD2 (asic_ctrl_access_key protected). Pad type: PRDW0408SCDG_ANA_SW_33(adc2) For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000058</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000010</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (shared analog function, disabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-down pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_mii0_txd3': 0xFF40105C-->
          <name>pad_ctrl_mii0_txd3</name>
          <description>Pad configuration register of port MII0_TXD3 (asic_ctrl_access_key protected). Pad type: PRDW0408SCDG_ANA_SW_33(adc3) For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000005C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000010</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (shared analog function, disabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-down pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_mii0_txen': 0xFF401060-->
          <name>pad_ctrl_mii0_txen</name>
          <description>Pad configuration register of port MII0_TXEN (asic_ctrl_access_key protected). Pad type: PDDW0408SCDG_33 For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000060</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-down pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_mii0_col': 0xFF401064-->
          <name>pad_ctrl_mii0_col</name>
          <description>Pad configuration register of port MII0_COL (asic_ctrl_access_key protected). Pad type: PDDW0408SCDG_33 For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000064</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-down pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_mii0_crs': 0xFF401068-->
          <name>pad_ctrl_mii0_crs</name>
          <description>Pad configuration register of port MII0_CRS (asic_ctrl_access_key protected). Pad type: PDDW0408SCDG_33 For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000068</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-down pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_phy0_led_link_in': 0xFF40106C-->
          <name>pad_ctrl_phy0_led_link_in</name>
          <description>Pad configuration register of port PHY0_LED_LINK_IN (asic_ctrl_access_key protected). Pad type: PDDW0408SCDG_33 For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000006C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-down pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_mii1_rxclk': 0xFF401070-->
          <name>pad_ctrl_mii1_rxclk</name>
          <description>Pad configuration register of port MII1_RXCLK (asic_ctrl_access_key protected). Pad type: PRDW0408SCDG_33 For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000070</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-down pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_mii1_rxd0': 0xFF401074-->
          <name>pad_ctrl_mii1_rxd0</name>
          <description>Pad configuration register of port MII1_RXD0 (asic_ctrl_access_key protected). Pad type: PDDW0204SCDG_33(i_double_bond) For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000074</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000050</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (disabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-down pad, disabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_mii1_rxd1': 0xFF401078-->
          <name>pad_ctrl_mii1_rxd1</name>
          <description>Pad configuration register of port MII1_RXD1 (asic_ctrl_access_key protected). Pad type: PDDW0408SCDG_33(double_bond) For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000078</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (disabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-down pad, disabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_mii1_rxd2': 0xFF40107C-->
          <name>pad_ctrl_mii1_rxd2</name>
          <description>Pad configuration register of port MII1_RXD2 (asic_ctrl_access_key protected). Pad type: PRDW0408SCDG_33(double_bond) For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000007C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (disabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-down pad, disabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_mii1_rxd3': 0xFF401080-->
          <name>pad_ctrl_mii1_rxd3</name>
          <description>Pad configuration register of port MII1_RXD3 (asic_ctrl_access_key protected). Pad type: PDDW0204SCDG_33(i_double_bond) For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000080</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000050</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (disabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-down pad, disabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_mii1_rxdv': 0xFF401084-->
          <name>pad_ctrl_mii1_rxdv</name>
          <description>Pad configuration register of port MII1_RXDV (asic_ctrl_access_key protected). Pad type: PDDW0204SCDG_33(i) For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000084</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000050</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-down pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_mii1_rxer': 0xFF401088-->
          <name>pad_ctrl_mii1_rxer</name>
          <description>Pad configuration register of port MII1_RXER (asic_ctrl_access_key protected). Pad type: PDDW0408SCDG_33 For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000088</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-down pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_mii1_txclk': 0xFF40108C-->
          <name>pad_ctrl_mii1_txclk</name>
          <description>Pad configuration register of port MII1_TXCLK (asic_ctrl_access_key protected). Pad type: PRDW0408SCDG_ANA_SW_33(adc2) For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000008C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000010</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (shared analog function, disabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-down pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_mii1_txd0': 0xFF401090-->
          <name>pad_ctrl_mii1_txd0</name>
          <description>Pad configuration register of port MII1_TXD0 (asic_ctrl_access_key protected). Pad type: PRDW0408SCDG_33(double_bond) For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000090</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (disabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-down pad, disabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_mii1_txd1': 0xFF401094-->
          <name>pad_ctrl_mii1_txd1</name>
          <description>Pad configuration register of port MII1_TXD1 (asic_ctrl_access_key protected). Pad type: PRDW0408SCDG_33(double_bond) For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000094</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (disabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-down pad, disabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_mii1_txd2': 0xFF401098-->
          <name>pad_ctrl_mii1_txd2</name>
          <description>Pad configuration register of port MII1_TXD2 (asic_ctrl_access_key protected). Pad type: PRDW0408SCDG_33(double_bond) For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000098</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (disabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-down pad, disabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_mii1_txd3': 0xFF40109C-->
          <name>pad_ctrl_mii1_txd3</name>
          <description>Pad configuration register of port MII1_TXD3 (asic_ctrl_access_key protected). Pad type: PRDW0408SCDG_33(double_bond) For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000009C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (disabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-down pad, disabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_mii1_txen': 0xFF4010A0-->
          <name>pad_ctrl_mii1_txen</name>
          <description>Pad configuration register of port MII1_TXEN (asic_ctrl_access_key protected). Pad type: PRDW0408SCDG_ANA_SW_33(adc2) For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000A0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000010</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (shared analog function, disabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-down pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_mii1_col': 0xFF4010A4-->
          <name>pad_ctrl_mii1_col</name>
          <description>Pad configuration register of port MII1_COL (asic_ctrl_access_key protected). Pad type: PDDW0408SCDG_33 For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000A4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-down pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_mii1_crs': 0xFF4010A8-->
          <name>pad_ctrl_mii1_crs</name>
          <description>Pad configuration register of port MII1_CRS (asic_ctrl_access_key protected). Pad type: PDDW0408SCDG_33 For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000A8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-down pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_phy1_led_link_in': 0xFF4010AC-->
          <name>pad_ctrl_phy1_led_link_in</name>
          <description>Pad configuration register of port PHY1_LED_LINK_IN (asic_ctrl_access_key protected). Pad type: PDDW0408SCDG_33 For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000AC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-down pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_mii_mdc': 0xFF4010B0-->
          <name>pad_ctrl_mii_mdc</name>
          <description>Pad configuration register of port MII_MDC (asic_ctrl_access_key protected). Pad type: PRDW0408SCDG_ANA_SW_33(adc2) For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000B0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000010</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (shared analog function, disabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-down pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_mii_mdio': 0xFF4010B4-->
          <name>pad_ctrl_mii_mdio</name>
          <description>Pad configuration register of port MII_MDIO (asic_ctrl_access_key protected). Pad type: PRDW0408SCDG_ANA_SW_33(adc2) For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000B4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000010</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (shared analog function, disabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-down pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_rst_out_n': 0xFF4010B8-->
          <name>pad_ctrl_rst_out_n</name>
          <description>Pad configuration register of port RST_OUT_N (asic_ctrl_access_key protected). Pad type: PRDW0408SCDG_33 For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000B8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-down pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_clk25out': 0xFF4010BC-->
          <name>pad_ctrl_clk25out</name>
          <description>Pad configuration register of port CLK25OUT (asic_ctrl_access_key protected). Pad type: PDDW0408SCDG_33 For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000BC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-down pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_mii0_txen_bga2': 0xFF4010C0-->
          <name>pad_ctrl_mii0_txen_bga2</name>
          <description>Pad configuration register of port MII0_TXEN_BGA2 (asic_ctrl_access_key protected). Pad type: PRDW0408SCDG_33 For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000C0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-down pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_mii0_col_bga2': 0xFF4010C4-->
          <name>pad_ctrl_mii0_col_bga2</name>
          <description>Pad configuration register of port MII0_COL_BGA2 (asic_ctrl_access_key protected). Pad type: PRDW0408SCDG_33 For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000C4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-down pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_mii0_crs_bga2': 0xFF4010C8-->
          <name>pad_ctrl_mii0_crs_bga2</name>
          <description>Pad configuration register of port MII0_CRS_BGA2 (asic_ctrl_access_key protected). Pad type: PDDW0204SCDG_33(i) For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000C8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000050</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-down pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_phy0_led_link_in_bga2': 0xFF4010CC-->
          <name>pad_ctrl_phy0_led_link_in_bga2</name>
          <description>Pad configuration register of port PHY0_LED_LINK_IN_BGA2 (asic_ctrl_access_key protected). Pad type: PDDW0204SCDG_33(i) For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000CC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000050</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-down pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_mii1_rxer_bga2': 0xFF4010D0-->
          <name>pad_ctrl_mii1_rxer_bga2</name>
          <description>Pad configuration register of port MII1_RXER_BGA2 (asic_ctrl_access_key protected). Pad type: PDDW0204SCDG_33(i) For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000D0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000050</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-down pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_mii1_col_bga2': 0xFF4010D4-->
          <name>pad_ctrl_mii1_col_bga2</name>
          <description>Pad configuration register of port MII1_COL_BGA2 (asic_ctrl_access_key protected). Pad type: PRDW0408SCDG_33 For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000D4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-down pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_mii1_crs_bga2': 0xFF4010D8-->
          <name>pad_ctrl_mii1_crs_bga2</name>
          <description>Pad configuration register of port MII1_CRS_BGA2 (asic_ctrl_access_key protected). Pad type: PDDW0204SCDG_33(i) For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000D8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000050</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-down pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_phy1_led_link_in_bga2': 0xFF4010DC-->
          <name>pad_ctrl_phy1_led_link_in_bga2</name>
          <description>Pad configuration register of port PHY1_LED_LINK_IN_BGA2 (asic_ctrl_access_key protected). Pad type: PDDW0204SCDG_33(i) For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000DC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000050</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-down pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_mmio0': 0xFF4010E0-->
          <name>pad_ctrl_mmio0</name>
          <description>Pad configuration register of port MMIO0 (asic_ctrl_access_key protected). Pad type: PRDW0408SCDG_ANA_SW_33(adc2) For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000E0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000010</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (shared analog function, disabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-down pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_mmio1': 0xFF4010E4-->
          <name>pad_ctrl_mmio1</name>
          <description>Pad configuration register of port MMIO1 (asic_ctrl_access_key protected). Pad type: PRDW0408SCDG_ANA_SW_33(adc2) For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000E4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000010</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (shared analog function, disabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-down pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_mmio2': 0xFF4010E8-->
          <name>pad_ctrl_mmio2</name>
          <description>Pad configuration register of port MMIO2 (asic_ctrl_access_key protected). Pad type: PRDW0408SCDG_ANA_SW_33(adc3) For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000E8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000010</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (shared analog function, disabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-down pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_mmio3': 0xFF4010EC-->
          <name>pad_ctrl_mmio3</name>
          <description>Pad configuration register of port MMIO3 (asic_ctrl_access_key protected). Pad type: PRDW0408SCDG_ANA_SW_33(adc3) For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000EC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000010</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (shared analog function, disabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-down pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_mmio4': 0xFF4010F0-->
          <name>pad_ctrl_mmio4</name>
          <description>Pad configuration register of port MMIO4 (asic_ctrl_access_key protected). Pad type: PRDW0408SCDG_ANA_33 For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000F0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000010</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (shared analog function, disabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-down pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_mmio5': 0xFF4010F4-->
          <name>pad_ctrl_mmio5</name>
          <description>Pad configuration register of port MMIO5 (asic_ctrl_access_key protected). Pad type: PRDW0408SCDG_ANA_33 For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000F4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000010</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (shared analog function, disabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-down pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_mmio6': 0xFF4010F8-->
          <name>pad_ctrl_mmio6</name>
          <description>Pad configuration register of port MMIO6 (asic_ctrl_access_key protected). Pad type: PRDW0408SCDG_ANA_33 For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000F8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000010</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (shared analog function, disabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-down pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_mmio7': 0xFF4010FC-->
          <name>pad_ctrl_mmio7</name>
          <description>Pad configuration register of port MMIO7 (asic_ctrl_access_key protected). Pad type: PRDW0408SCDG_ANA_33 For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000FC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000010</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (shared analog function, disabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-down pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_sqi_clk': 0xFF401100-->
          <name>pad_ctrl_sqi_clk</name>
          <description>Pad configuration register of port SQI_CLK (asic_ctrl_access_key protected). Pad type: PDUW0408SCDG_33 For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-up pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_sqi_cs0n': 0xFF401104-->
          <name>pad_ctrl_sqi_cs0n</name>
          <description>Pad configuration register of port SQI_CS0N (asic_ctrl_access_key protected). Pad type: PDUW0408SCDG_33 For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000104</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-up pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_sqi_mosi': 0xFF401108-->
          <name>pad_ctrl_sqi_mosi</name>
          <description>Pad configuration register of port SQI_MOSI (asic_ctrl_access_key protected). Pad type: PDUW0408SCDG_33 For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000108</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-up pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_sqi_miso': 0xFF40110C-->
          <name>pad_ctrl_sqi_miso</name>
          <description>Pad configuration register of port SQI_MISO (asic_ctrl_access_key protected). Pad type: PDUW0408SCDG_33 For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000010C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-up pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_sqi_sio2': 0xFF401110-->
          <name>pad_ctrl_sqi_sio2</name>
          <description>Pad configuration register of port SQI_SIO2 (asic_ctrl_access_key protected). Pad type: PDUW0408SCDG_33 For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000110</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-up pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_sqi_sio3': 0xFF401114-->
          <name>pad_ctrl_sqi_sio3</name>
          <description>Pad configuration register of port SQI_SIO3 (asic_ctrl_access_key protected). Pad type: PDUW0408SCDG_33 For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000114</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-up pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_hif_a0': 0xFF401118-->
          <name>pad_ctrl_hif_a0</name>
          <description>Pad configuration register of port HIF_A0 (asic_ctrl_access_key protected). Pad type: PDUW0408SCDG_33 For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000118</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-up pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_hif_a1': 0xFF40111C-->
          <name>pad_ctrl_hif_a1</name>
          <description>Pad configuration register of port HIF_A1 (asic_ctrl_access_key protected). Pad type: PDUW0408SCDG_33 For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000011C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-up pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_hif_a2': 0xFF401120-->
          <name>pad_ctrl_hif_a2</name>
          <description>Pad configuration register of port HIF_A2 (asic_ctrl_access_key protected). Pad type: PDUW0408SCDG_33 For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000120</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-up pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_hif_a3': 0xFF401124-->
          <name>pad_ctrl_hif_a3</name>
          <description>Pad configuration register of port HIF_A3 (asic_ctrl_access_key protected). Pad type: PDUW0408SCDG_33 For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000124</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-up pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_hif_a4': 0xFF401128-->
          <name>pad_ctrl_hif_a4</name>
          <description>Pad configuration register of port HIF_A4 (asic_ctrl_access_key protected). Pad type: PDUW0408SCDG_33 For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000128</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-up pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_hif_a5': 0xFF40112C-->
          <name>pad_ctrl_hif_a5</name>
          <description>Pad configuration register of port HIF_A5 (asic_ctrl_access_key protected). Pad type: PDUW0408SCDG_33 For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000012C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-up pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_hif_a6': 0xFF401130-->
          <name>pad_ctrl_hif_a6</name>
          <description>Pad configuration register of port HIF_A6 (asic_ctrl_access_key protected). Pad type: PDUW0408SCDG_33 For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000130</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-up pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_hif_a7': 0xFF401134-->
          <name>pad_ctrl_hif_a7</name>
          <description>Pad configuration register of port HIF_A7 (asic_ctrl_access_key protected). Pad type: PDUW0408SCDG_33 For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000134</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-up pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_hif_a8': 0xFF401138-->
          <name>pad_ctrl_hif_a8</name>
          <description>Pad configuration register of port HIF_A8 (asic_ctrl_access_key protected). Pad type: PDUW0408SCDG_33 For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000138</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-up pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_hif_a9': 0xFF40113C-->
          <name>pad_ctrl_hif_a9</name>
          <description>Pad configuration register of port HIF_A9 (asic_ctrl_access_key protected). Pad type: PDUW0408SCDG_33 For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000013C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-up pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_hif_a10': 0xFF401140-->
          <name>pad_ctrl_hif_a10</name>
          <description>Pad configuration register of port HIF_A10 (asic_ctrl_access_key protected). Pad type: PDUW0408SCDG_33 For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000140</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-up pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_hif_a11': 0xFF401144-->
          <name>pad_ctrl_hif_a11</name>
          <description>Pad configuration register of port HIF_A11 (asic_ctrl_access_key protected). Pad type: PDUW0408SCDG_33 For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000144</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-up pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_hif_a12': 0xFF401148-->
          <name>pad_ctrl_hif_a12</name>
          <description>Pad configuration register of port HIF_A12 (asic_ctrl_access_key protected). Pad type: PDUW0408SCDG_33 For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000148</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-up pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_hif_a13': 0xFF40114C-->
          <name>pad_ctrl_hif_a13</name>
          <description>Pad configuration register of port HIF_A13 (asic_ctrl_access_key protected). Pad type: PDUW0408SCDG_33 For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000014C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-up pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_hif_a14': 0xFF401150-->
          <name>pad_ctrl_hif_a14</name>
          <description>Pad configuration register of port HIF_A14 (asic_ctrl_access_key protected). Pad type: PDUW0408SCDG_33 For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000150</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-up pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_hif_a15': 0xFF401154-->
          <name>pad_ctrl_hif_a15</name>
          <description>Pad configuration register of port HIF_A15 (asic_ctrl_access_key protected). Pad type: PDUW0408SCDG_33 For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000154</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-up pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_hif_a16': 0xFF401158-->
          <name>pad_ctrl_hif_a16</name>
          <description>Pad configuration register of port HIF_A16 (asic_ctrl_access_key protected). Pad type: PDUW0408SCDG_33 For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000158</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-up pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_hif_a17': 0xFF40115C-->
          <name>pad_ctrl_hif_a17</name>
          <description>Pad configuration register of port HIF_A17 (asic_ctrl_access_key protected). Pad type: PDUW0408SCDG_33 For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000015C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-up pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_hif_d0': 0xFF401160-->
          <name>pad_ctrl_hif_d0</name>
          <description>Pad configuration register of port HIF_D0 (asic_ctrl_access_key protected). Pad type: PDUW0408SCDG_33 For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000160</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-up pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_hif_d1': 0xFF401164-->
          <name>pad_ctrl_hif_d1</name>
          <description>Pad configuration register of port HIF_D1 (asic_ctrl_access_key protected). Pad type: PDUW0408SCDG_33 For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000164</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-up pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_hif_d2': 0xFF401168-->
          <name>pad_ctrl_hif_d2</name>
          <description>Pad configuration register of port HIF_D2 (asic_ctrl_access_key protected). Pad type: PDUW0408SCDG_33 For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000168</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-up pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_hif_d3': 0xFF40116C-->
          <name>pad_ctrl_hif_d3</name>
          <description>Pad configuration register of port HIF_D3 (asic_ctrl_access_key protected). Pad type: PDUW0408SCDG_33 For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000016C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-up pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_hif_d4': 0xFF401170-->
          <name>pad_ctrl_hif_d4</name>
          <description>Pad configuration register of port HIF_D4 (asic_ctrl_access_key protected). Pad type: PDUW0408SCDG_33 For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000170</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-up pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_hif_d5': 0xFF401174-->
          <name>pad_ctrl_hif_d5</name>
          <description>Pad configuration register of port HIF_D5 (asic_ctrl_access_key protected). Pad type: PDUW0408SCDG_33 For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000174</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-up pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_hif_d6': 0xFF401178-->
          <name>pad_ctrl_hif_d6</name>
          <description>Pad configuration register of port HIF_D6 (asic_ctrl_access_key protected). Pad type: PDUW0408SCDG_33 For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000178</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-up pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_hif_d7': 0xFF40117C-->
          <name>pad_ctrl_hif_d7</name>
          <description>Pad configuration register of port HIF_D7 (asic_ctrl_access_key protected). Pad type: PDUW0408SCDG_33 For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000017C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-up pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_hif_d8': 0xFF401180-->
          <name>pad_ctrl_hif_d8</name>
          <description>Pad configuration register of port HIF_D8 (asic_ctrl_access_key protected). Pad type: PDUW0408SCDG_33 For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000180</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-up pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_hif_d9': 0xFF401184-->
          <name>pad_ctrl_hif_d9</name>
          <description>Pad configuration register of port HIF_D9 (asic_ctrl_access_key protected). Pad type: PRUW0408SCDG_33 For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000184</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-up pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_hif_d10': 0xFF401188-->
          <name>pad_ctrl_hif_d10</name>
          <description>Pad configuration register of port HIF_D10 (asic_ctrl_access_key protected). Pad type: PRUW0408SCDG_33 For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000188</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-up pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_hif_d11': 0xFF40118C-->
          <name>pad_ctrl_hif_d11</name>
          <description>Pad configuration register of port HIF_D11 (asic_ctrl_access_key protected). Pad type: PRUW0408SCDG_33 For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000018C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-up pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_hif_d12': 0xFF401190-->
          <name>pad_ctrl_hif_d12</name>
          <description>Pad configuration register of port HIF_D12 (asic_ctrl_access_key protected). Pad type: PRUW0408SCDG_33 For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000190</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-up pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_hif_d13': 0xFF401194-->
          <name>pad_ctrl_hif_d13</name>
          <description>Pad configuration register of port HIF_D13 (asic_ctrl_access_key protected). Pad type: PRUW0408SCDG_33 For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000194</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-up pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_hif_d14': 0xFF401198-->
          <name>pad_ctrl_hif_d14</name>
          <description>Pad configuration register of port HIF_D14 (asic_ctrl_access_key protected). Pad type: PRUW0408SCDG_33 For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000198</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-up pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_hif_d15': 0xFF40119C-->
          <name>pad_ctrl_hif_d15</name>
          <description>Pad configuration register of port HIF_D15 (asic_ctrl_access_key protected). Pad type: PRUW0408SCDG_33 For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000019C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-up pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_hif_bhen': 0xFF4011A0-->
          <name>pad_ctrl_hif_bhen</name>
          <description>Pad configuration register of port HIF_BHEN (asic_ctrl_access_key protected). Pad type: PDUW0408SCDG_33 For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000001A0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-up pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_hif_csn': 0xFF4011A4-->
          <name>pad_ctrl_hif_csn</name>
          <description>Pad configuration register of port HIF_CSN (asic_ctrl_access_key protected). Pad type: PDUW0408SCDG_33 For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000001A4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-up pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_hif_rdn': 0xFF4011A8-->
          <name>pad_ctrl_hif_rdn</name>
          <description>Pad configuration register of port HIF_RDN (asic_ctrl_access_key protected). Pad type: PDUW0408SCDG_33 For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000001A8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-up pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_hif_wrn': 0xFF4011AC-->
          <name>pad_ctrl_hif_wrn</name>
          <description>Pad configuration register of port HIF_WRN (asic_ctrl_access_key protected). Pad type: PDUW0408SCDG_33 For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000001AC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-up pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_hif_rdy': 0xFF4011B0-->
          <name>pad_ctrl_hif_rdy</name>
          <description>Pad configuration register of port HIF_RDY (asic_ctrl_access_key protected). Pad type: PDUW0408SCDG_33 For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000001B0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-up pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_hif_dirq': 0xFF4011B4-->
          <name>pad_ctrl_hif_dirq</name>
          <description>Pad configuration register of port HIF_DIRQ (asic_ctrl_access_key protected). Pad type: PDUW0408SCDG_33 For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000001B4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-up pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pad_ctrl_hif_sdclk': 0xFF4011B8-->
          <name>pad_ctrl_hif_sdclk</name>
          <description>Pad configuration register of port HIF_SDCLK (asic_ctrl_access_key protected). Pad type: PDUW0408SCDG_33 For details refer to description of register pad_ctrl_rdy_n. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000001B8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x00000051</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ie</name>
              <bitRange>[6:6]</bitRange>
              <description>input enable (enabled by default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pe</name>
              <bitRange>[4:4]</bitRange>
              <description>pull enable (pull-up pad, enabled by default) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ds</name>
              <bitRange>[0:0]</bitRange>
              <description>driving strength (low by default) </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>asic_ctrl</name>
      <description>asic_ctrl</description>
      <baseAddress>0xFF401200</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>256</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>bod</name>
        <value>22</value>
      </interrupt>
      <interrupt>
        <name>clk_sup</name>
        <value>23</value>
      </interrupt>
      <registers>
        <register>
          <!--Absolute address of 'io_config0': 0xFF401200-->
          <name>io_config0</name>
          <description>IO Config0 Register: reserved for COM side </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>reserved value</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'io_config0_mask': 0xFF401204-->
          <name>io_config0_mask</name>
          <description>IO Config0 Mask Register: reserved for COM side </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>reserved value</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'io_config1': 0xFF401208-->
          <name>io_config1</name>
          <description>IO Config1 Register: reserved for COM side </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>reserved value</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'io_config1_mask': 0xFF40120C-->
          <name>io_config1_mask</name>
          <description>IO Config1 Mask Register: reserved for COM side </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>reserved value</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'io_config2': 0xFF401210-->
          <name>io_config2</name>
          <description>IO Config2 Register: Selects of output pin multiplexing. See Excel pinning sheet for details. Changes will only have an effect if the corresponding bits in the io_config2_mask-register are set.  This register is a write mask register, i.e. lower 16 bits are only writeable, if corresponding upper bits are set. This register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: 1.: read out access-key from asic_ctrl_access_key register 2.: write back access-key to asic_ctrl_access_key register 3.: write desired value to this register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>dcdc_enable_n_wm</name>
              <bitRange>[31:31]</bitRange>
              <description>Write mask of dcdc_enable_n </description>
            </field>
            <field>
              <name>clk25out_oe_wm</name>
              <bitRange>[30:30]</bitRange>
              <description>Write mask of clk25out_oe </description>
            </field>
            <field>
              <name>sel_uart_rctsn_wm</name>
              <bitRange>[29:29]</bitRange>
              <description>Write mask of sel_uart_rctsn </description>
            </field>
            <field>
              <name>sel_i2c1_com_wm</name>
              <bitRange>[28:28]</bitRange>
              <description>Write mask of sel_i2c1_com </description>
            </field>
            <field>
              <name>sel_i2c0_com_wm</name>
              <bitRange>[27:27]</bitRange>
              <description>Write mask of sel_i2c0_com </description>
            </field>
            <field>
              <name>sel_fo1_wm</name>
              <bitRange>[26:26]</bitRange>
              <description>Write mask of sel_fo1 </description>
            </field>
            <field>
              <name>sel_fo0_wm</name>
              <bitRange>[25:25]</bitRange>
              <description>Write mask of sel_fo0 </description>
            </field>
            <field>
              <name>sel_ephy_mdio_wm</name>
              <bitRange>[24:24]</bitRange>
              <description>Write mask of sel_ephy_mdio </description>
            </field>
            <field>
              <name>sel_ephy1_wm</name>
              <bitRange>[23:23]</bitRange>
              <description>Write mask of sel_ephy1 </description>
            </field>
            <field>
              <name>sel_ephy0_wm</name>
              <bitRange>[22:22]</bitRange>
              <description>Write mask of sel_ephy0 </description>
            </field>
            <field>
              <name>sel_phy_devel_wm</name>
              <bitRange>[21:21]</bitRange>
              <description>Write mask of sel_phy_devel </description>
            </field>
            <field>
              <name>sel_xc_trigger0_hif_sirq_wm</name>
              <bitRange>[20:20]</bitRange>
              <description>Write mask of sel_xc_trigger0_hif_sirq </description>
            </field>
            <field>
              <name>sel_gpio11_wm</name>
              <bitRange>[19:19]</bitRange>
              <description>Write mask of sel_gpio11 </description>
            </field>
            <field>
              <name>sel_gpio10_wm</name>
              <bitRange>[18:18]</bitRange>
              <description>Write mask of sel_gpio10 </description>
            </field>
            <field>
              <name>sel_gpio9_wm</name>
              <bitRange>[17:17]</bitRange>
              <description>Write mask of sel_gpio9 </description>
            </field>
            <field>
              <name>sel_gpio8_wm</name>
              <bitRange>[16:16]</bitRange>
              <description>Write mask of sel_gpio8 </description>
            </field>
            <field>
              <name>dcdc_enable_n</name>
              <bitRange>[15:15]</bitRange>
              <description>DCDC converter disable 0: enable DCDC converter 1: disable DCDC converter (should be done, if external core supply is attached) </description>
            </field>
            <field>
              <name>clk25out_oe</name>
              <bitRange>[14:14]</bitRange>
              <description>Output enable of CLK25OUT pad. When unset (i.e. '0'), pin will be high-z. </description>
            </field>
            <field>
              <name>sel_uart_rctsn</name>
              <bitRange>[13:13]</bitRange>
              <description>select pads for uart RTS/CTS signals (s. pinning table) </description>
            </field>
            <field>
              <name>sel_i2c1_com</name>
              <bitRange>[12:12]</bitRange>
              <description>select pads for i2c1_com (s. pinning table) </description>
            </field>
            <field>
              <name>sel_i2c0_com</name>
              <bitRange>[11:11]</bitRange>
              <description>select pads for i2c0_com (s. pinning table) </description>
            </field>
            <field>
              <name>sel_fo1</name>
              <bitRange>[10:10]</bitRange>
              <description>select Fiber Optics of PHY1 (s. pinning table) </description>
            </field>
            <field>
              <name>sel_fo0</name>
              <bitRange>[9:9]</bitRange>
              <description>select Fiber Optics of PHY0 (s. pinning table) </description>
            </field>
            <field>
              <name>sel_ephy_mdio</name>
              <bitRange>[8:8]</bitRange>
              <description>connect PHY MDIO to external pads (s. pinning table) </description>
            </field>
            <field>
              <name>sel_ephy1</name>
              <bitRange>[7:7]</bitRange>
              <description>connect PHY1 MII to external MAC (s. pinning table) </description>
            </field>
            <field>
              <name>sel_ephy0</name>
              <bitRange>[6:6]</bitRange>
              <description>connect PHY0 MII to external MAC (s. pinning table) </description>
            </field>
            <field>
              <name>sel_phy_devel</name>
              <bitRange>[5:5]</bitRange>
              <description>select PHY development outputs (s. pinning table) </description>
            </field>
            <field>
              <name>sel_xc_trigger0_hif_sirq</name>
              <bitRange>[4:4]</bitRange>
              <description>select xc_trigger0 on HIF_SIRQ (s. pinning table) </description>
            </field>
            <field>
              <name>sel_gpio11</name>
              <bitRange>[3:3]</bitRange>
              <description>select pad for gpio11 (s. pinning table) </description>
            </field>
            <field>
              <name>sel_gpio10</name>
              <bitRange>[2:2]</bitRange>
              <description>select pad for gpio10 (s. pinning table) </description>
            </field>
            <field>
              <name>sel_gpio9</name>
              <bitRange>[1:1]</bitRange>
              <description>select pad for gpio9  (s. pinning table) </description>
            </field>
            <field>
              <name>sel_gpio8</name>
              <bitRange>[0:0]</bitRange>
              <description>select pad for gpio8  (s. pinning table) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'io_config2_mask': 0xFF401214-->
          <name>io_config2_mask</name>
          <description>IO Config2 Mask Register: This register can be used to lock the special IO configurations for restricted netX devices.   Bits of the io_config2 register can only be modified if the corresponding mask bits in this register are set. This register is lockable by asic_ctrl_com.netx_lock-lock_register. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000FFFF</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>dcdc_enable_n</name>
              <bitRange>[15:15]</bitRange>
              <description>DCDC converter disable </description>
            </field>
            <field>
              <name>clk25out_oe</name>
              <bitRange>[14:14]</bitRange>
              <description>Output enable of CLK25OUT pad. When unset (i.e. '0'), pin will be high-z. </description>
            </field>
            <field>
              <name>sel_uart_rctsn</name>
              <bitRange>[13:13]</bitRange>
              <description>select pads for uart RTS/CTS signals (s. pinning table) </description>
            </field>
            <field>
              <name>sel_i2c1_com</name>
              <bitRange>[12:12]</bitRange>
              <description>select pads for i2c1_com (s. pinning table) </description>
            </field>
            <field>
              <name>sel_i2c0_com</name>
              <bitRange>[11:11]</bitRange>
              <description>select pads for i2c0_com (s. pinning table) </description>
            </field>
            <field>
              <name>sel_fo1</name>
              <bitRange>[10:10]</bitRange>
              <description>select Fiber Optics of PHY1 (s. pinning table) </description>
            </field>
            <field>
              <name>sel_fo0</name>
              <bitRange>[9:9]</bitRange>
              <description>select Fiber Optics of PHY0 (s. pinning table) </description>
            </field>
            <field>
              <name>sel_ephy_mdio</name>
              <bitRange>[8:8]</bitRange>
              <description>connect PHY MDIO to external pads (s. pinning table) </description>
            </field>
            <field>
              <name>sel_ephy1</name>
              <bitRange>[7:7]</bitRange>
              <description>connect PHY1 MII to external MAC (s. pinning table) </description>
            </field>
            <field>
              <name>sel_ephy0</name>
              <bitRange>[6:6]</bitRange>
              <description>connect PHY0 MII to external MAC (s. pinning table) </description>
            </field>
            <field>
              <name>sel_phy_devel</name>
              <bitRange>[5:5]</bitRange>
              <description>select PHY development outputs (s. pinning table) </description>
            </field>
            <field>
              <name>sel_xc_trigger0_hif_sirq</name>
              <bitRange>[4:4]</bitRange>
              <description>select xc_trigger0 on HIF_SIRQ (s. pinning table) </description>
            </field>
            <field>
              <name>sel_gpio11</name>
              <bitRange>[3:3]</bitRange>
              <description>select pad for gpio11 (s. pinning table) </description>
            </field>
            <field>
              <name>sel_gpio10</name>
              <bitRange>[2:2]</bitRange>
              <description>select pad for gpio10 (s. pinning table) </description>
            </field>
            <field>
              <name>sel_gpio9</name>
              <bitRange>[1:1]</bitRange>
              <description>select pad for gpio9  (s. pinning table) </description>
            </field>
            <field>
              <name>sel_gpio8</name>
              <bitRange>[0:0]</bitRange>
              <description>select pad for gpio8  (s. pinning table) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'io_config3': 0xFF401218-->
          <name>io_config3</name>
          <description>IO Config3 Register: Selects of output pin multiplexing. See Excel pinning sheet for details. Changes will only have an effect if the corresponding bits in the io_config3_mask-register are set.  This register is a write mask register, i.e. lower 16 bits are only writeable, if corresponding upper bits are set. This register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: 1.: read out access-key from asic_ctrl_access_key register 2.: write back access-key to asic_ctrl_access_key register 3.: write desired value to this register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000018</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>sel_biss1_mo_wm</name>
              <bitRange>[31:31]</bitRange>
              <description>Write mask of sel_biss1_mo </description>
            </field>
            <field>
              <name>sel_biss1_wm</name>
              <bitRange>[30:30]</bitRange>
              <description>Write mask of sel_biss1 </description>
            </field>
            <field>
              <name>sel_biss0_mo_wm</name>
              <bitRange>[29:29]</bitRange>
              <description>Write mask of sel_biss0_mo </description>
            </field>
            <field>
              <name>sel_biss0_wm</name>
              <bitRange>[28:28]</bitRange>
              <description>Write mask of sel_biss0 </description>
            </field>
            <field>
              <name>sel_endat1_devel_wm</name>
              <bitRange>[27:27]</bitRange>
              <description>Write mask of sel_endat1_devel </description>
            </field>
            <field>
              <name>sel_endat1_wm</name>
              <bitRange>[26:26]</bitRange>
              <description>Write mask of sel_endat1 </description>
            </field>
            <field>
              <name>sel_endat0_devel_wm</name>
              <bitRange>[25:25]</bitRange>
              <description>Write mask of sel_endat0_devel </description>
            </field>
            <field>
              <name>sel_endat0_wm</name>
              <bitRange>[24:24]</bitRange>
              <description>Write mask of sel_endat0 </description>
            </field>
            <field>
              <name>sel_gpio7_wm</name>
              <bitRange>[23:23]</bitRange>
              <description>Write mask of sel_gpio7 </description>
            </field>
            <field>
              <name>sel_gpio6_wm</name>
              <bitRange>[22:22]</bitRange>
              <description>Write mask of sel_gpio6 </description>
            </field>
            <field>
              <name>sel_gpio5_wm</name>
              <bitRange>[21:21]</bitRange>
              <description>Write mask of sel_gpio5 </description>
            </field>
            <field>
              <name>sel_gpio4_wm</name>
              <bitRange>[20:20]</bitRange>
              <description>Write mask of sel_gpio4 </description>
            </field>
            <field>
              <name>sel_gpio3_wm</name>
              <bitRange>[19:19]</bitRange>
              <description>Write mask of sel_gpio3 </description>
            </field>
            <field>
              <name>sel_gpio2_wm</name>
              <bitRange>[18:18]</bitRange>
              <description>Write mask of sel_gpio2 </description>
            </field>
            <field>
              <name>sel_gpio1_wm</name>
              <bitRange>[17:17]</bitRange>
              <description>Write mask of sel_gpio1 </description>
            </field>
            <field>
              <name>sel_gpio0_wm</name>
              <bitRange>[16:16]</bitRange>
              <description>Write mask of sel_gpio0 </description>
            </field>
            <field>
              <name>sel_biss1_mo</name>
              <bitRange>[15:15]</bitRange>
              <description>select pad BISS ch 1 MO (s. pinning table) </description>
            </field>
            <field>
              <name>sel_biss1</name>
              <bitRange>[14:14]</bitRange>
              <description>select pads BISS ch 1 (s. pinning table) </description>
            </field>
            <field>
              <name>sel_biss0_mo</name>
              <bitRange>[13:13]</bitRange>
              <description>select pad BISS ch 0 MO (s. pinning table) </description>
            </field>
            <field>
              <name>sel_biss0</name>
              <bitRange>[12:12]</bitRange>
              <description>select pads BISS ch 0 (s. pinning table) </description>
            </field>
            <field>
              <name>sel_endat1_devel</name>
              <bitRange>[11:11]</bitRange>
              <description>select pads EnDAT ch 1 development function (s. pinning table) Note: EnDAT development function outputs are delayed by one sys-clk. </description>
            </field>
            <field>
              <name>sel_endat1</name>
              <bitRange>[10:10]</bitRange>
              <description>select pads EnDAT ch 1 (s. pinning table) </description>
            </field>
            <field>
              <name>sel_endat0_devel</name>
              <bitRange>[9:9]</bitRange>
              <description>select pads EnDAT ch 0 development function (s. pinning table) Note: EnDAT development function outputs are delayed by one sys-clk. </description>
            </field>
            <field>
              <name>sel_endat0</name>
              <bitRange>[8:8]</bitRange>
              <description>select pads EnDAT ch 0 (s. pinning table) </description>
            </field>
            <field>
              <name>sel_gpio7</name>
              <bitRange>[7:7]</bitRange>
              <description>select pad for gpio7  (s. pinning table) and deactivate this function via MMIOs </description>
            </field>
            <field>
              <name>sel_gpio6</name>
              <bitRange>[6:6]</bitRange>
              <description>select pad for gpio6  (s. pinning table) and deactivate this function via MMIOs </description>
            </field>
            <field>
              <name>sel_gpio5</name>
              <bitRange>[5:5]</bitRange>
              <description>select pad for gpio5  (s. pinning table) and deactivate this function via MMIOs </description>
            </field>
            <field>
              <name>sel_gpio4</name>
              <bitRange>[4:4]</bitRange>
              <description>select pad for gpio4  (s. pinning table) and deactivate this function via MMIOs </description>
            </field>
            <field>
              <name>sel_gpio3</name>
              <bitRange>[3:3]</bitRange>
              <description>select pad for gpio3  (s. pinning table) and deactivate this function via MMIOs </description>
            </field>
            <field>
              <name>sel_gpio2</name>
              <bitRange>[2:2]</bitRange>
              <description>select pad for gpio2  (s. pinning table) and deactivate this function via MMIOs </description>
            </field>
            <field>
              <name>sel_gpio1</name>
              <bitRange>[1:1]</bitRange>
              <description>select pad for gpio1  (s. pinning table) and deactivate this function via MMIOs </description>
            </field>
            <field>
              <name>sel_gpio0</name>
              <bitRange>[0:0]</bitRange>
              <description>select pad for gpio0  (s. pinning table) and deactivate this function via MMIOs </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'io_config3_mask': 0xFF40121C-->
          <name>io_config3_mask</name>
          <description>IO Config3 Mask Register: This register can be used to lock the special IO configurations for restricted netX devices.   Bits of the io_config3 register can only be modified if the corresponding mask bits in this register are set. This register is lockable by asic_ctrl_com.netx_lock-lock_register. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000001C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000FFFF</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sel_biss1_mo</name>
              <bitRange>[15:15]</bitRange>
              <description>select pad BISS ch 1 MO (s. pinning table) </description>
            </field>
            <field>
              <name>sel_biss1</name>
              <bitRange>[14:14]</bitRange>
              <description>select pads BISS ch 1 (s. pinning table) </description>
            </field>
            <field>
              <name>sel_biss0_mo</name>
              <bitRange>[13:13]</bitRange>
              <description>select pad BISS ch 0 MO (s. pinning table) </description>
            </field>
            <field>
              <name>sel_biss0</name>
              <bitRange>[12:12]</bitRange>
              <description>select pads BISS ch 0 (s. pinning table) </description>
            </field>
            <field>
              <name>sel_endat1_devel</name>
              <bitRange>[11:11]</bitRange>
              <description>select pads EnDAT ch 1 development function (s. pinning table) </description>
            </field>
            <field>
              <name>sel_endat1</name>
              <bitRange>[10:10]</bitRange>
              <description>select pads EnDAT ch 1 (s. pinning table) </description>
            </field>
            <field>
              <name>sel_endat0_devel</name>
              <bitRange>[9:9]</bitRange>
              <description>select pads EnDAT ch 0 development function (s. pinning table) </description>
            </field>
            <field>
              <name>sel_endat0</name>
              <bitRange>[8:8]</bitRange>
              <description>select pads EnDAT ch 0 (s. pinning table) </description>
            </field>
            <field>
              <name>sel_gpio7</name>
              <bitRange>[7:7]</bitRange>
              <description>select pad for gpio7  (s. pinning table) and deactivate this function via MMIOs </description>
            </field>
            <field>
              <name>sel_gpio6</name>
              <bitRange>[6:6]</bitRange>
              <description>select pad for gpio6  (s. pinning table) and deactivate this function via MMIOs </description>
            </field>
            <field>
              <name>sel_gpio5</name>
              <bitRange>[5:5]</bitRange>
              <description>select pad for gpio5  (s. pinning table) and deactivate this function via MMIOs </description>
            </field>
            <field>
              <name>sel_gpio4</name>
              <bitRange>[4:4]</bitRange>
              <description>select pad for gpio4  (s. pinning table) and deactivate this function via MMIOs </description>
            </field>
            <field>
              <name>sel_gpio3</name>
              <bitRange>[3:3]</bitRange>
              <description>select pad for gpio3  (s. pinning table) and deactivate this function via MMIOs </description>
            </field>
            <field>
              <name>sel_gpio2</name>
              <bitRange>[2:2]</bitRange>
              <description>select pad for gpio2  (s. pinning table) and deactivate this function via MMIOs </description>
            </field>
            <field>
              <name>sel_gpio1</name>
              <bitRange>[1:1]</bitRange>
              <description>select pad for gpio1  (s. pinning table) and deactivate this function via MMIOs </description>
            </field>
            <field>
              <name>sel_gpio0</name>
              <bitRange>[0:0]</bitRange>
              <description>select pad for gpio0  (s. pinning table) and deactivate this function via MMIOs </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'io_config4': 0xFF401220-->
          <name>io_config4</name>
          <description>IO Config4 Register: Selects of output pin multiplexing. See Excel pinning sheet for details. Changes will only have an effect if the corresponding bits in the io_config4_mask-register are set.  This register is a write mask register, i.e. lower 16 bits are only writeable, if corresponding upper bits are set. This register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: 1.: read out access-key from asic_ctrl_access_key register 2.: write back access-key to asic_ctrl_access_key register 3.: write desired value to this register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0FFF0FFF</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:28]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sel_can1_app_wm</name>
              <bitRange>[27:27]</bitRange>
              <description>Write mask of sel_can1_app </description>
            </field>
            <field>
              <name>sel_can0_app_wm</name>
              <bitRange>[26:26]</bitRange>
              <description>Write mask of sel_can0_app </description>
            </field>
            <field>
              <name>sel_spi2_app_cs2_wm</name>
              <bitRange>[25:25]</bitRange>
              <description>Write mask of sel_spi2_app_cs2 </description>
            </field>
            <field>
              <name>sel_spi2_app_cs1_wm</name>
              <bitRange>[24:24]</bitRange>
              <description>Write mask of sel_spi2_app_cs1 </description>
            </field>
            <field>
              <name>sel_spi2_app_wm</name>
              <bitRange>[23:23]</bitRange>
              <description>Write mask of sel_spi2_app </description>
            </field>
            <field>
              <name>sel_spi0_app_cs1_wm</name>
              <bitRange>[22:22]</bitRange>
              <description>Write mask of sel_spi0_app_cs1 </description>
            </field>
            <field>
              <name>sel_spi0_app_wm</name>
              <bitRange>[21:21]</bitRange>
              <description>Write mask of sel_spi0_app </description>
            </field>
            <field>
              <name>sel_uart_xpic_app_rctsn_wm</name>
              <bitRange>[20:20]</bitRange>
              <description>Write mask of sel_uart_xpic_app_rctsn </description>
            </field>
            <field>
              <name>sel_uart_xpic_app_wm</name>
              <bitRange>[19:19]</bitRange>
              <description>Write mask of sel_uart_xpic_app </description>
            </field>
            <field>
              <name>sel_uart_app_rctsn_wm</name>
              <bitRange>[18:18]</bitRange>
              <description>Write mask of sel_uart_app_rctsn </description>
            </field>
            <field>
              <name>sel_uart_app_wm</name>
              <bitRange>[17:17]</bitRange>
              <description>Write mask of sel_uart_app </description>
            </field>
            <field>
              <name>sel_i2c_app_wm</name>
              <bitRange>[16:16]</bitRange>
              <description>Write mask of sel_i2c_app </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[15:12]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sel_can1_app</name>
              <bitRange>[11:11]</bitRange>
              <description>select pad for can1_app (s. pinning table) and deactivate this function via MMIOs </description>
            </field>
            <field>
              <name>sel_can0_app</name>
              <bitRange>[10:10]</bitRange>
              <description>select pad for can0_app (s. pinning table) and deactivate this function via MMIOs </description>
            </field>
            <field>
              <name>sel_spi2_app_cs2</name>
              <bitRange>[9:9]</bitRange>
              <description>select pad for 3rd chip select of spi2_app (s. pinning table) </description>
            </field>
            <field>
              <name>sel_spi2_app_cs1</name>
              <bitRange>[8:8]</bitRange>
              <description>select pad for 2nd chip select of spi2_app (s. pinning table) </description>
            </field>
            <field>
              <name>sel_spi2_app</name>
              <bitRange>[7:7]</bitRange>
              <description>select pads for spi2_app (s. pinning table) and deactivate this function via MMIOs </description>
            </field>
            <field>
              <name>sel_spi0_app_cs1</name>
              <bitRange>[6:6]</bitRange>
              <description>select pad for 2nd chip select of spi0_app (s. pinning table) </description>
            </field>
            <field>
              <name>sel_spi0_app</name>
              <bitRange>[5:5]</bitRange>
              <description>select pads for spi0_app (s. pinning table) and deactivate this function via MMIOs </description>
            </field>
            <field>
              <name>sel_uart_xpic_app_rctsn</name>
              <bitRange>[4:4]</bitRange>
              <description>select pads for uart_xpic_app RTS/CTS signals (s. pinning table) and deactivate this function via MMIOs </description>
            </field>
            <field>
              <name>sel_uart_xpic_app</name>
              <bitRange>[3:3]</bitRange>
              <description>select pads for uart_xpic_app (s. pinning table) and deactivate this function via MMIOs </description>
            </field>
            <field>
              <name>sel_uart_app_rctsn</name>
              <bitRange>[2:2]</bitRange>
              <description>select pads for uart_app RTS/CTS signals (s. pinning table) and deactivate this function via MMIOs </description>
            </field>
            <field>
              <name>sel_uart_app</name>
              <bitRange>[1:1]</bitRange>
              <description>select pads for uart_app (s. pinning table) and deactivate this function via MMIOs </description>
            </field>
            <field>
              <name>sel_i2c_app</name>
              <bitRange>[0:0]</bitRange>
              <description>select pads for i2c_app (s. pinning table) and deactivate this function via MMIOs </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'io_config4_mask': 0xFF401224-->
          <name>io_config4_mask</name>
          <description>IO Config4 Mask Register: This register can be used to lock the special IO configurations for restricted netX devices.   Bits of the io_config4 register can only be modified if the corresponding mask bits in this register are set. This register is lockable by asic_ctrl_com.netx_lock-lock_register. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000024</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000FFF</resetValue>
          <resetMask>0x00000FFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:12]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sel_can1_app</name>
              <bitRange>[11:11]</bitRange>
              <description>select pad for can1_app (s. pinning table) and deactivate this function via MMIOs </description>
            </field>
            <field>
              <name>sel_can0_app</name>
              <bitRange>[10:10]</bitRange>
              <description>select pad for can0_app (s. pinning table) and deactivate this function via MMIOs </description>
            </field>
            <field>
              <name>sel_spi2_app_cs2</name>
              <bitRange>[9:9]</bitRange>
              <description>select pad for 3rd chip select of spi2_app (s. pinning table) </description>
            </field>
            <field>
              <name>sel_spi2_app_cs1</name>
              <bitRange>[8:8]</bitRange>
              <description>select pad for 2nd chip select of spi2_app (s. pinning table) </description>
            </field>
            <field>
              <name>sel_spi2_app</name>
              <bitRange>[7:7]</bitRange>
              <description>select pads for spi2_app (s. pinning table) and deactivate this function via MMIOs </description>
            </field>
            <field>
              <name>sel_spi0_app_cs1</name>
              <bitRange>[6:6]</bitRange>
              <description>select pad for 2nd chip select of spi0_app (s. pinning table) </description>
            </field>
            <field>
              <name>sel_spi0_app</name>
              <bitRange>[5:5]</bitRange>
              <description>select pads for spi0_app (s. pinning table) and deactivate this function via MMIOs </description>
            </field>
            <field>
              <name>sel_uart_xpic_app_rctsn</name>
              <bitRange>[4:4]</bitRange>
              <description>select pads for uart_xpic_app RTS/CTS signals (s. pinning table) and deactivate this function via MMIOs </description>
            </field>
            <field>
              <name>sel_uart_xpic_app</name>
              <bitRange>[3:3]</bitRange>
              <description>select pads for uart_xpic_app (s. pinning table) and deactivate this function via MMIOs </description>
            </field>
            <field>
              <name>sel_uart_app_rctsn</name>
              <bitRange>[2:2]</bitRange>
              <description>select pads for uart_app RTS/CTS signals (s. pinning table) and deactivate this function via MMIOs </description>
            </field>
            <field>
              <name>sel_uart_app</name>
              <bitRange>[1:1]</bitRange>
              <description>select pads for uart_app (s. pinning table) and deactivate this function via MMIOs </description>
            </field>
            <field>
              <name>sel_i2c_app</name>
              <bitRange>[0:0]</bitRange>
              <description>select pads for i2c_app (s. pinning table) and deactivate this function via MMIOs </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'io_config5': 0xFF401228-->
          <name>io_config5</name>
          <description>IO Config5 Register: Selects of output pin multiplexing. See Excel pinning sheet for details. Changes will only have an effect if the corresponding bits in the io_config5_mask-register are set.  This register is a write mask register, i.e. lower 16 bits are only writeable, if corresponding upper bits are set. This register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: 1.: read out access-key from asic_ctrl_access_key register 2.: write back access-key to asic_ctrl_access_key register 3.: write desired value to this register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000028</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFF7FFF7F</resetMask>
          <fields>
            <field>
              <name>sel_mled11_wm</name>
              <bitRange>[31:31]</bitRange>
              <description>Write mask of sel_mled11 </description>
            </field>
            <field>
              <name>sel_mled10_wm</name>
              <bitRange>[30:30]</bitRange>
              <description>Write mask of sel_mled10 </description>
            </field>
            <field>
              <name>sel_mled9_wm</name>
              <bitRange>[29:29]</bitRange>
              <description>Write mask of sel_mled9 </description>
            </field>
            <field>
              <name>sel_mled8_wm</name>
              <bitRange>[28:28]</bitRange>
              <description>Write mask of sel_mled8 </description>
            </field>
            <field>
              <name>sel_mled7_wm</name>
              <bitRange>[27:27]</bitRange>
              <description>Write mask of sel_mled7 </description>
            </field>
            <field>
              <name>sel_mled6_wm</name>
              <bitRange>[26:26]</bitRange>
              <description>Write mask of sel_mled6 </description>
            </field>
            <field>
              <name>sel_mled5_wm</name>
              <bitRange>[25:25]</bitRange>
              <description>Write mask of sel_mled5 </description>
            </field>
            <field>
              <name>sel_mled4_wm</name>
              <bitRange>[24:24]</bitRange>
              <description>Write mask of sel_mled4 </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[23:23]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sel_mpwm_brake_wm</name>
              <bitRange>[22:22]</bitRange>
              <description>Write mask of sel_mpwm_brake </description>
            </field>
            <field>
              <name>sel_mpwm_wm</name>
              <bitRange>[21:16]</bitRange>
              <description>Write mask of sel_mpwm </description>
            </field>
            <field>
              <name>sel_mled11</name>
              <bitRange>[15:15]</bitRange>
              <description>select pad for mled11 (s. pinning table) </description>
            </field>
            <field>
              <name>sel_mled10</name>
              <bitRange>[14:14]</bitRange>
              <description>select pad for mled10 (s. pinning table) </description>
            </field>
            <field>
              <name>sel_mled9</name>
              <bitRange>[13:13]</bitRange>
              <description>select pad for mled9 (s. pinning table) </description>
            </field>
            <field>
              <name>sel_mled8</name>
              <bitRange>[12:12]</bitRange>
              <description>select pad for mled8 (s. pinning table) </description>
            </field>
            <field>
              <name>sel_mled7</name>
              <bitRange>[11:11]</bitRange>
              <description>select pad for mled7 (s. pinning table) </description>
            </field>
            <field>
              <name>sel_mled6</name>
              <bitRange>[10:10]</bitRange>
              <description>select pad for mled6 (s. pinning table) </description>
            </field>
            <field>
              <name>sel_mled5</name>
              <bitRange>[9:9]</bitRange>
              <description>select pad for mled5 (s. pinning table) </description>
            </field>
            <field>
              <name>sel_mled4</name>
              <bitRange>[8:8]</bitRange>
              <description>select pad for mled4 (s. pinning table) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[7:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sel_mpwm_brake</name>
              <bitRange>[6:6]</bitRange>
              <description>select pad for mpwm_brake (s. pinning table) </description>
            </field>
            <field>
              <name>sel_mpwm</name>
              <bitRange>[5:0]</bitRange>
              <description>select pad for mpwm (s. pinning table) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'io_config5_mask': 0xFF40122C-->
          <name>io_config5_mask</name>
          <description>IO Config5 Mask Register: This register can be used to lock the special IO configurations for restricted netX devices.   Bits of the io_config5 register can only be modified if the corresponding mask bits in this register are set. This register is lockable by asic_ctrl_com.netx_lock-lock_register. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000002C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000FF7F</resetValue>
          <resetMask>0x0000FF7F</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sel_mled11</name>
              <bitRange>[15:15]</bitRange>
              <description>select pad for mled11 (s. pinning table) </description>
            </field>
            <field>
              <name>sel_mled10</name>
              <bitRange>[14:14]</bitRange>
              <description>select pad for mled10 (s. pinning table) </description>
            </field>
            <field>
              <name>sel_mled9</name>
              <bitRange>[13:13]</bitRange>
              <description>select pad for mled9 (s. pinning table) </description>
            </field>
            <field>
              <name>sel_mled8</name>
              <bitRange>[12:12]</bitRange>
              <description>select pad for mled8 (s. pinning table) </description>
            </field>
            <field>
              <name>sel_mled7</name>
              <bitRange>[11:11]</bitRange>
              <description>select pad for mled7 (s. pinning table) </description>
            </field>
            <field>
              <name>sel_mled6</name>
              <bitRange>[10:10]</bitRange>
              <description>select pad for mled6 (s. pinning table) </description>
            </field>
            <field>
              <name>sel_mled5</name>
              <bitRange>[9:9]</bitRange>
              <description>select pad for mled5 (s. pinning table) </description>
            </field>
            <field>
              <name>sel_mled4</name>
              <bitRange>[8:8]</bitRange>
              <description>select pad for mled4 (s. pinning table) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[7:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sel_mpwm_brake</name>
              <bitRange>[6:6]</bitRange>
              <description>select pad for mpwm_brake (s. pinning table) </description>
            </field>
            <field>
              <name>sel_mpwm</name>
              <bitRange>[5:0]</bitRange>
              <description>select pad for mpwm (s. pinning table) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'io_config6': 0xFF401230-->
          <name>io_config6</name>
          <description>IO Config6 Register: Selects of output pin multiplexing. See Excel pinning sheet for details. Changes will only have an effect if the corresponding bits in the io_config6_mask-register are set.  This register is a write mask register, i.e. lower 16 bits are only writeable, if corresponding upper bits are set. This register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: 1.: read out access-key from asic_ctrl_access_key register 2.: write back access-key to asic_ctrl_access_key register 3.: write desired value to this register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000030</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>sel_io_link_wakeup7_wm</name>
              <bitRange>[31:31]</bitRange>
              <description>Write mask of sel_io_link_wakeup7 </description>
            </field>
            <field>
              <name>sel_io_link_wakeup6_wm</name>
              <bitRange>[30:30]</bitRange>
              <description>Write mask of sel_io_link_wakeup6 </description>
            </field>
            <field>
              <name>sel_io_link_wakeup5_wm</name>
              <bitRange>[29:29]</bitRange>
              <description>Write mask of sel_io_link_wakeup5 </description>
            </field>
            <field>
              <name>sel_io_link_wakeup4_wm</name>
              <bitRange>[28:28]</bitRange>
              <description>Write mask of sel_io_link_wakeup4 </description>
            </field>
            <field>
              <name>sel_io_link_wakeup3_wm</name>
              <bitRange>[27:27]</bitRange>
              <description>Write mask of sel_io_link_wakeup3 </description>
            </field>
            <field>
              <name>sel_io_link_wakeup2_wm</name>
              <bitRange>[26:26]</bitRange>
              <description>Write mask of sel_io_link_wakeup2 </description>
            </field>
            <field>
              <name>sel_io_link_wakeup1_wm</name>
              <bitRange>[25:25]</bitRange>
              <description>Write mask of sel_io_link_wakeup1 </description>
            </field>
            <field>
              <name>sel_io_link_wakeup0_wm</name>
              <bitRange>[24:24]</bitRange>
              <description>Write mask of sel_io_link_wakeup0 </description>
            </field>
            <field>
              <name>sel_io_link7_wm</name>
              <bitRange>[23:23]</bitRange>
              <description>Write mask of sel_io_link7 </description>
            </field>
            <field>
              <name>sel_io_link6_wm</name>
              <bitRange>[22:22]</bitRange>
              <description>Write mask of sel_io_link6 </description>
            </field>
            <field>
              <name>sel_io_link5_wm</name>
              <bitRange>[21:21]</bitRange>
              <description>Write mask of sel_io_link5 </description>
            </field>
            <field>
              <name>sel_io_link4_wm</name>
              <bitRange>[20:20]</bitRange>
              <description>Write mask of sel_io_link4 </description>
            </field>
            <field>
              <name>sel_io_link3_wm</name>
              <bitRange>[19:19]</bitRange>
              <description>Write mask of sel_io_link3 </description>
            </field>
            <field>
              <name>sel_io_link2_wm</name>
              <bitRange>[18:18]</bitRange>
              <description>Write mask of sel_io_link2 </description>
            </field>
            <field>
              <name>sel_io_link1_wm</name>
              <bitRange>[17:17]</bitRange>
              <description>Write mask of sel_io_link1 </description>
            </field>
            <field>
              <name>sel_io_link0_wm</name>
              <bitRange>[16:16]</bitRange>
              <description>Write mask of sel_io_link0 </description>
            </field>
            <field>
              <name>sel_io_link_wakeup7</name>
              <bitRange>[15:15]</bitRange>
              <description>select pads for IO-Link7 Wakeup (s. pinning table) </description>
            </field>
            <field>
              <name>sel_io_link_wakeup6</name>
              <bitRange>[14:14]</bitRange>
              <description>select pads for IO-Link6 Wakeup (s. pinning table) </description>
            </field>
            <field>
              <name>sel_io_link_wakeup5</name>
              <bitRange>[13:13]</bitRange>
              <description>select pads for IO-Link5 Wakeup (s. pinning table) </description>
            </field>
            <field>
              <name>sel_io_link_wakeup4</name>
              <bitRange>[12:12]</bitRange>
              <description>select pads for IO-Link4 Wakeup (s. pinning table) </description>
            </field>
            <field>
              <name>sel_io_link_wakeup3</name>
              <bitRange>[11:11]</bitRange>
              <description>select pads for IO-Link3 Wakeup (s. pinning table) </description>
            </field>
            <field>
              <name>sel_io_link_wakeup2</name>
              <bitRange>[10:10]</bitRange>
              <description>select pads for IO-Link2 Wakeup (s. pinning table) </description>
            </field>
            <field>
              <name>sel_io_link_wakeup1</name>
              <bitRange>[9:9]</bitRange>
              <description>select pads for IO-Link1 Wakeup (s. pinning table) </description>
            </field>
            <field>
              <name>sel_io_link_wakeup0</name>
              <bitRange>[8:8]</bitRange>
              <description>select pads for IO-Link0 Wakeup (s. pinning table) </description>
            </field>
            <field>
              <name>sel_io_link7</name>
              <bitRange>[7:7]</bitRange>
              <description>select pads for IO-Link7 (s. pinning table) </description>
            </field>
            <field>
              <name>sel_io_link6</name>
              <bitRange>[6:6]</bitRange>
              <description>select pads for IO-Link6 (s. pinning table) </description>
            </field>
            <field>
              <name>sel_io_link5</name>
              <bitRange>[5:5]</bitRange>
              <description>select pads for IO-Link5 (s. pinning table) </description>
            </field>
            <field>
              <name>sel_io_link4</name>
              <bitRange>[4:4]</bitRange>
              <description>select pads for IO-Link4 (s. pinning table) </description>
            </field>
            <field>
              <name>sel_io_link3</name>
              <bitRange>[3:3]</bitRange>
              <description>select pads for IO-Link3 (s. pinning table) </description>
            </field>
            <field>
              <name>sel_io_link2</name>
              <bitRange>[2:2]</bitRange>
              <description>select pads for IO-Link2 (s. pinning table) </description>
            </field>
            <field>
              <name>sel_io_link1</name>
              <bitRange>[1:1]</bitRange>
              <description>select pads for IO-Link1 (s. pinning table) </description>
            </field>
            <field>
              <name>sel_io_link0</name>
              <bitRange>[0:0]</bitRange>
              <description>select pads for IO-Link0 (s. pinning table) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'io_config6_mask': 0xFF401234-->
          <name>io_config6_mask</name>
          <description>IO Config6 Mask Register: This register can be used to lock the special IO configurations for restricted netX devices.   Bits of the io_config6 register can only be modified if the corresponding mask bits in this register are set. This register is lockable by asic_ctrl_com.netx_lock-lock_register. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000034</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000FFFF</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sel_io_link_wakeup7</name>
              <bitRange>[15:15]</bitRange>
              <description>select pads for IO-Link7 Wakeup (s. pinning table) </description>
            </field>
            <field>
              <name>sel_io_link_wakeup6</name>
              <bitRange>[14:14]</bitRange>
              <description>select pads for IO-Link6 Wakeup (s. pinning table) </description>
            </field>
            <field>
              <name>sel_io_link_wakeup5</name>
              <bitRange>[13:13]</bitRange>
              <description>select pads for IO-Link5 Wakeup (s. pinning table) </description>
            </field>
            <field>
              <name>sel_io_link_wakeup4</name>
              <bitRange>[12:12]</bitRange>
              <description>select pads for IO-Link4 Wakeup (s. pinning table) </description>
            </field>
            <field>
              <name>sel_io_link_wakeup3</name>
              <bitRange>[11:11]</bitRange>
              <description>select pads for IO-Link3 Wakeup (s. pinning table) </description>
            </field>
            <field>
              <name>sel_io_link_wakeup2</name>
              <bitRange>[10:10]</bitRange>
              <description>select pads for IO-Link2 Wakeup (s. pinning table) </description>
            </field>
            <field>
              <name>sel_io_link_wakeup1</name>
              <bitRange>[9:9]</bitRange>
              <description>select pads for IO-Link1 Wakeup (s. pinning table) </description>
            </field>
            <field>
              <name>sel_io_link_wakeup0</name>
              <bitRange>[8:8]</bitRange>
              <description>select pads for IO-Link0 Wakeup (s. pinning table) </description>
            </field>
            <field>
              <name>sel_io_link7</name>
              <bitRange>[7:7]</bitRange>
              <description>select pads for IO-Link7 (s. pinning table) </description>
            </field>
            <field>
              <name>sel_io_link6</name>
              <bitRange>[6:6]</bitRange>
              <description>select pads for IO-Link6 (s. pinning table) </description>
            </field>
            <field>
              <name>sel_io_link5</name>
              <bitRange>[5:5]</bitRange>
              <description>select pads for IO-Link5 (s. pinning table) </description>
            </field>
            <field>
              <name>sel_io_link4</name>
              <bitRange>[4:4]</bitRange>
              <description>select pads for IO-Link4 (s. pinning table) </description>
            </field>
            <field>
              <name>sel_io_link3</name>
              <bitRange>[3:3]</bitRange>
              <description>select pads for IO-Link3 (s. pinning table) </description>
            </field>
            <field>
              <name>sel_io_link2</name>
              <bitRange>[2:2]</bitRange>
              <description>select pads for IO-Link2 (s. pinning table) </description>
            </field>
            <field>
              <name>sel_io_link1</name>
              <bitRange>[1:1]</bitRange>
              <description>select pads for IO-Link1 (s. pinning table) </description>
            </field>
            <field>
              <name>sel_io_link0</name>
              <bitRange>[0:0]</bitRange>
              <description>select pads for IO-Link0 (s. pinning table) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'io_config7': 0xFF401238-->
          <name>io_config7</name>
          <description>IO Config7 Register: Selects of output pin multiplexing. See Excel pinning sheet for details. Changes will only have an effect if the corresponding bits in the io_config7_mask-register are set.  This register is a write mask register, i.e. lower 16 bits are only writeable, if corresponding upper bits are set. This register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: 1.: read out access-key from asic_ctrl_access_key register 2.: write back access-key to asic_ctrl_access_key register 3.: write desired value to this register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000038</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x1FFF1FFF</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:29]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sel_io_link_wakeup1b_wm</name>
              <bitRange>[28:28]</bitRange>
              <description>Write mask of sel_io_link_wakeup1b </description>
            </field>
            <field>
              <name>sel_io_link_wakeup0b_wm</name>
              <bitRange>[27:27]</bitRange>
              <description>Write mask of sel_io_link_wakeup0b </description>
            </field>
            <field>
              <name>sel_io_link1b_wm</name>
              <bitRange>[26:26]</bitRange>
              <description>Write mask of sel_io_link1b </description>
            </field>
            <field>
              <name>sel_io_link0b_wm</name>
              <bitRange>[25:25]</bitRange>
              <description>Write mask of sel_io_link0b </description>
            </field>
            <field>
              <name>sel_sqi_cs2_wm</name>
              <bitRange>[24:24]</bitRange>
              <description>Write mask of sel_sqi_cs2 </description>
            </field>
            <field>
              <name>sel_sqi_cs1_wm</name>
              <bitRange>[23:23]</bitRange>
              <description>Write mask of sel_sqi_cs1 </description>
            </field>
            <field>
              <name>sel_eth_mdio_wm</name>
              <bitRange>[22:21]</bitRange>
              <description>Write mask of sel_eth_mdio </description>
            </field>
            <field>
              <name>sel_eth_cfg_wm</name>
              <bitRange>[20:16]</bitRange>
              <description>Write mask of sel_eth_cfg </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[15:13]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sel_io_link_wakeup1b</name>
              <bitRange>[12:12]</bitRange>
              <description>select pads for IO-Link1 Wakeup at position B (s. pinning table) </description>
            </field>
            <field>
              <name>sel_io_link_wakeup0b</name>
              <bitRange>[11:11]</bitRange>
              <description>select pads for IO-Link0 Wakeup at position B (s. pinning table) </description>
            </field>
            <field>
              <name>sel_io_link1b</name>
              <bitRange>[10:10]</bitRange>
              <description>select pads for IO-Link1 at position B (s. pinning table) </description>
            </field>
            <field>
              <name>sel_io_link0b</name>
              <bitRange>[9:9]</bitRange>
              <description>select pads for IO-Link0 at position B (s. pinning table) </description>
            </field>
            <field>
              <name>sel_sqi_cs2</name>
              <bitRange>[8:8]</bitRange>
              <description>select pad for 3rd chip select of sqi (s. pinning table) </description>
            </field>
            <field>
              <name>sel_sqi_cs1</name>
              <bitRange>[7:7]</bitRange>
              <description>select pad for 2nd chip select of sqi (s. pinning table) </description>
            </field>
            <field>
              <name>sel_eth_mdio</name>
              <bitRange>[6:5]</bitRange>
              <description>select connection for MIIMU MDIO interface used by ETH 00: ETH MIIMU not connected to IOs but the multiplexmatrix can be used for it. 01: connect to external eth_mdio default position (s. pinning table sel_eth_mdio) 10: connect to external eth_mdio position B (s pinning table sel_eth_b_mdio) pins (s pinning table) 11: connect to internal PHY </description>
            </field>
            <field>
              <name>sel_eth_cfg</name>
              <bitRange>[4:0]</bitRange>
              <description>select connection of ETH MII pins: 0: no select 1: select pads for ETH RMII (rxd[1:0],rxdv,rxer,txclk,txd[1:0],txen) (s. pinning table: sel_eth_5,2,1 will be active) 2: select pads for ETH RX only mode (rxclk, rxd[3:0],rxdv,rxer) (s. pinning table: sel_eth_5,3,2,0 will be active) 3: select pads for ETH minimum data transfer in phy mode (rxd,rxdv,txclk,txd,txen) (s. pinning table: sel_eth_4:1 will be active) 4: select also pads for ETH rxclk pin for mac mode (rxclk) (s. pinning table: sel_eth_4:0 will be active) 5: select also pads for ETH RX error signal (rxer) (s. pinning table: sel_eth_5:0 will be active) 6: select also pads for ETH collision and carrier sense (col,crs) (s. pinning table: sel_eth_6:0 will be active) 7: select also pads for ETH TX error signal (txer) (s. pinning table: sel_eth_7:0 will be active) 8: ETH position B: select pads for ETH RMII (rxd[1:0],rxdv,rxer,txclk,txd[1:0],txen) (s. pinning table: sel_eth_5,2,1 will be active) 9: ETH position B: select pads for ETH RX only mode (rxclk, rxd[3:0],rxdv,rxer) (s. pinning table: sel_eth_5,3,2,0 will be active) 10: ETH position B: select pads for ETH minimum data transfer in phy mode (rxd,rxdv,txclk,txd,txen) (s. pinning table: sel_eth_4:1 will be active) 11: ETH position B: select also pads for ETH rxclk pin for mac mode (rxclk) (s. pinning table: sel_eth_4:0 will be active) 12: ETH position B: select also pads for ETH RX error signal (rxer) (s. pinning table: sel_eth_5:0 will be active) 13: ETH position B: select also pads for ETH collision and carrier sense (col,crs) (s. pinning table: sel_eth_6:0 will be active) 14: ETH position B: select also pads for ETH TX error signal (txer) (s. pinning table: sel_eth_7:0 will be active) 15: connect to internal PHY0, if PHY0 not used by XMAC0 (no selects for external MII) 16: connect to internal PHY1, if PHY1 not used by XMAC1 (no selects for external MII) 17: connect to internal LVDS0, if LVDS0 not used by XMAC0 (no selects for external MII) 18: connect to internal LVDS1, if LVDS1 not used by XMAC1 (no selects for external MII) The maximum MII interface consists of 16 signals, but usually not all MII signals are necessary. Values 1..6 define combinations of reduced MII that might be use cases, while 7 is the full MII. To realize this, MII signals are combined to the following groups with appropriate select signals in pinning table: {      | 0      rxclk 1      txclk, txen, txd0, txd1 2      rxdv, rxd0, rxd1 3      rxd2, rxd3 4      txd2, txd3 5      rxer 6      col, crs 7      txer                   } </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'io_config7_mask': 0xFF40123C-->
          <name>io_config7_mask</name>
          <description>IO Config7 Mask Register: This register can be used to lock the special IO configurations for restricted netX devices.   Bits of the io_config7 register can only be modified if the corresponding mask bits in this register are set. This register is lockable by asic_ctrl_com.netx_lock-lock_register. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000003C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00001FFF</resetValue>
          <resetMask>0x00001FFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:13]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sel_io_link_wakeup1b</name>
              <bitRange>[12:12]</bitRange>
              <description>select pads for IO-Link1 Wakeup at position B (s. pinning table) </description>
            </field>
            <field>
              <name>sel_io_link_wakeup0b</name>
              <bitRange>[11:11]</bitRange>
              <description>select pads for IO-Link0 Wakeup at position B (s. pinning table) </description>
            </field>
            <field>
              <name>sel_io_link1b</name>
              <bitRange>[10:10]</bitRange>
              <description>select pads for IO-Link1 at position B (s. pinning table) </description>
            </field>
            <field>
              <name>sel_io_link0b</name>
              <bitRange>[9:9]</bitRange>
              <description>select pads for IO-Link0 at position B (s. pinning table) </description>
            </field>
            <field>
              <name>sel_sqi_cs2</name>
              <bitRange>[8:8]</bitRange>
              <description>select pad for 3rd chip select of sqi (s. pinning table) </description>
            </field>
            <field>
              <name>sel_sqi_cs1</name>
              <bitRange>[7:7]</bitRange>
              <description>select pad for 2nd chip select of sqi (s. pinning table) </description>
            </field>
            <field>
              <name>sel_eth_mdio</name>
              <bitRange>[6:5]</bitRange>
              <description>select connection for MIIMU MDIO interface used by ETH </description>
            </field>
            <field>
              <name>sel_eth_cfg</name>
              <bitRange>[4:0]</bitRange>
              <description>select connection of ETH MII pins: </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'io_config8': 0xFF401240-->
          <name>io_config8</name>
          <description>IO Config8 Register: Selects of output pin multiplexing. See Excel pinning sheet for details. Changes will only have an effect if the corresponding bits in the io_config8_mask-register are set.  This register is a write mask register, i.e. lower 16 bits are only writeable, if corresponding upper bits are set. This register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: 1.: read out access-key from asic_ctrl_access_key register 2.: write back access-key to asic_ctrl_access_key register 3.: write desired value to this register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000040</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000F000F</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:20]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sel_bga2_wm</name>
              <bitRange>[19:19]</bitRange>
              <description>Write mask of sel_bga2 </description>
            </field>
            <field>
              <name>sel_extphy_wm</name>
              <bitRange>[18:18]</bitRange>
              <description>Write mask of sel_extphy </description>
            </field>
            <field>
              <name>sel_arm_trace_cfg_wm</name>
              <bitRange>[17:16]</bitRange>
              <description>Write mask of sel_arm_trace_cfg </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[15:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sel_bga2</name>
              <bitRange>[3:3]</bitRange>
              <description>select *_bga2 pins in pinning table: This is intended for a second bondout version using external Ethernet PHY. If sel_bga2 is active, output enable of pin MII0_TXEN will be inactive, all other *_bga2 pins are inputs. </description>
            </field>
            <field>
              <name>sel_extphy</name>
              <bitRange>[2:2]</bitRange>
              <description>select *_extphy pins in pinning table: This is intended to combine external PHYs with SDRAM. </description>
            </field>
            <field>
              <name>sel_arm_trace_cfg</name>
              <bitRange>[1:0]</bitRange>
              <description>select pins for CoreSight Tracing 00: Disable Trace:           sel_trace = 0, sel_trace_d[3:0] = 0000 01: Trace with 1 data line:  sel_trace = 1, sel_trace_d[3:0] = 0001 10: Trace with 2 data lines: sel_trace = 1, sel_trace_d[3:0] = 0011 11: Trace with 4 data lines: sel_trace = 1, sel_trace_d[3:0] = 1111 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'io_config8_mask': 0xFF401244-->
          <name>io_config8_mask</name>
          <description>IO Config8 Mask Register: This register can be used to lock the special IO configurations for restricted netX devices.   Bits of the io_config8 register can only be modified if the corresponding mask bits in this register are set. This register is lockable by asic_ctrl_com.netx_lock-lock_register. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000044</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000000F</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sel_bga2</name>
              <bitRange>[3:3]</bitRange>
              <description>select *_bga2 pins of 2nd BGA package </description>
            </field>
            <field>
              <name>sel_extphy</name>
              <bitRange>[2:2]</bitRange>
              <description>select different positions in case of external PHY should be connected in parallel with SDRAM. </description>
            </field>
            <field>
              <name>sel_arm_trace_cfg</name>
              <bitRange>[1:0]</bitRange>
              <description>select pins for CoreSight Tracing </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'io_config9': 0xFF401248-->
          <name>io_config9</name>
          <description>IO Config9 Register: Selects of output pin multiplexing. See Excel pinning sheet for details. Changes will only have an effect if the corresponding bits in the io_config9_mask-register are set.  This register is a write mask register, i.e. lower 16 bits are only writeable, if corresponding upper bits are set. This register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: 1.: read out access-key from asic_ctrl_access_key register 2.: write back access-key to asic_ctrl_access_key register 3.: write desired value to this register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000048</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>sel_pio_app_wm</name>
              <bitRange>[31:16]</bitRange>
              <description>Write mask of sel_pio_app </description>
            </field>
            <field>
              <name>sel_pio_app</name>
              <bitRange>[15:0]</bitRange>
              <description>select pads for pio_app[15:0] (s. pinning table) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'io_config9_mask': 0xFF40124C-->
          <name>io_config9_mask</name>
          <description>IO Config9 Mask Register: This register can be used to lock the special IO configurations for restricted netX devices.   Bits of the io_config9 register can only be modified if the corresponding mask bits in this register are set. This register is lockable by asic_ctrl_com.netx_lock-lock_register. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000004C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000FFFF</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sel_pio_app</name>
              <bitRange>[15:0]</bitRange>
              <description>select pads for pio_app[15:0] (s. pinning table) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'io_config10': 0xFF401250-->
          <name>io_config10</name>
          <description>IO Config10 Register: reserved for COM side </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000050</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>reserved value</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'io_config10_mask': 0xFF401254-->
          <name>io_config10_mask</name>
          <description>IO Config10 Mask Register: reserved for COM side </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000054</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>reserved value</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'io_config11': 0xFF401258-->
          <name>io_config11</name>
          <description>IO Config11 Register: reserved for COM side </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000058</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>reserved value</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'io_config11_mask': 0xFF40125C-->
          <name>io_config11_mask</name>
          <description>IO Config11 Mask Register: reserved for COM side </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000005C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>reserved value</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'clock_enable0': 0xFF401268-->
          <name>clock_enable0</name>
          <description>Global Clock Enable Register: Use this registers to disable modules completely for power saving purposes. Changes will only have an effect if the corresponding bits in the clock_enable_mask-register are set. Note: For low power consumption at power on, all switchable clocks are disabled after reset and must be enabled before module usage.  This register is a write mask register, i.e. lower 16 bits are only writeable, if corresponding upper bits are set. This register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: 1.: read out access-key from asic_ctrl_access_key register 2.: write back access-key to asic_ctrl_access_key register 3.: write desired value to this register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000068</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x2FFF2FFF</resetMask>
          <fields>
            <field>
              <name>bf_align3</name>
              <bitRange>[31:30]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>dpm_wm</name>
              <bitRange>[29:29]</bitRange>
              <description>Write mask of dpm </description>
            </field>
            <field>
              <name>bf_align2</name>
              <bitRange>[28:28]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>arm_app_wm</name>
              <bitRange>[27:27]</bitRange>
              <description>Write mask of arm_app </description>
            </field>
            <field>
              <name>dma_com_wm</name>
              <bitRange>[26:26]</bitRange>
              <description>Write mask of dma_com </description>
            </field>
            <field>
              <name>xpic0_wm</name>
              <bitRange>[25:25]</bitRange>
              <description>Write mask of xpic0 </description>
            </field>
            <field>
              <name>xc_misc_wm</name>
              <bitRange>[24:24]</bitRange>
              <description>Write mask of xc_misc </description>
            </field>
            <field>
              <name>fb1_wm</name>
              <bitRange>[23:23]</bitRange>
              <description>Write mask of fb1 </description>
            </field>
            <field>
              <name>fb0_wm</name>
              <bitRange>[22:22]</bitRange>
              <description>Write mask of fb0 </description>
            </field>
            <field>
              <name>xmac1_wm</name>
              <bitRange>[21:21]</bitRange>
              <description>Write mask of xmac1 </description>
            </field>
            <field>
              <name>xmac0_wm</name>
              <bitRange>[20:20]</bitRange>
              <description>Write mask of xmac0 </description>
            </field>
            <field>
              <name>tpec1_wm</name>
              <bitRange>[19:19]</bitRange>
              <description>Write mask of tpec1 </description>
            </field>
            <field>
              <name>tpec0_wm</name>
              <bitRange>[18:18]</bitRange>
              <description>Write mask of tpec0 </description>
            </field>
            <field>
              <name>rpec1_wm</name>
              <bitRange>[17:17]</bitRange>
              <description>Write mask of rpec1 </description>
            </field>
            <field>
              <name>rpec0_wm</name>
              <bitRange>[16:16]</bitRange>
              <description>Write mask of rpec0 </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[15:14]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>dpm</name>
              <bitRange>[13:13]</bitRange>
              <description>enables clock for DPM </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[12:12]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>arm_app</name>
              <bitRange>[11:11]</bitRange>
              <description>enables clock for ARM-APP </description>
            </field>
            <field>
              <name>dma_com</name>
              <bitRange>[10:10]</bitRange>
              <description>enables clock for COM DMA-Ctrl </description>
            </field>
            <field>
              <name>xpic0</name>
              <bitRange>[9:9]</bitRange>
              <description>enables clock for XPIC0 </description>
            </field>
            <field>
              <name>xc_misc</name>
              <bitRange>[8:8]</bitRange>
              <description>enables clock for misc. XC logic (XC-DMAC, XC-SR, XC-BUFMAN </description>
            </field>
            <field>
              <name>fb1</name>
              <bitRange>[7:7]</bitRange>
              <description>enables clock for fieldbus1 1: use internally generated fb1clk to resample xMAC1 outputs 0: use external xm1_eclk to resample xMAC outputs </description>
            </field>
            <field>
              <name>fb0</name>
              <bitRange>[6:6]</bitRange>
              <description>enables clock for fieldbus0 1: use internally generated fb0clk to resample xMAC0 outputs 0: use external xm0_eclk to resample xMAC outputs </description>
            </field>
            <field>
              <name>xmac1</name>
              <bitRange>[5:5]</bitRange>
              <description>enables clock for xMAC1 </description>
            </field>
            <field>
              <name>xmac0</name>
              <bitRange>[4:4]</bitRange>
              <description>enables clock for xMAC0 </description>
            </field>
            <field>
              <name>tpec1</name>
              <bitRange>[3:3]</bitRange>
              <description>enables clock for tPEC1 </description>
            </field>
            <field>
              <name>tpec0</name>
              <bitRange>[2:2]</bitRange>
              <description>enables clock for tPEC0 </description>
            </field>
            <field>
              <name>rpec1</name>
              <bitRange>[1:1]</bitRange>
              <description>enables clock for rPEC1 </description>
            </field>
            <field>
              <name>rpec0</name>
              <bitRange>[0:0]</bitRange>
              <description>enables clock for rPEC0 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'clock_enable0_mask': 0xFF40126C-->
          <name>clock_enable0_mask</name>
          <description>Global Clock Enable Mask Register: This register can be used to lock the clock_enable0 register.   Bits of the clock_enable0 register can only be modified if the corresponding mask bits in this register are set. This register is lockable by asic_ctrl_com.netx_lock-lock_register. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000006C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00002FFF</resetValue>
          <resetMask>0x00002FFF</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:14]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>dpm</name>
              <bitRange>[13:13]</bitRange>
              <description>enables clock for DPM </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[12:12]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>arm_app</name>
              <bitRange>[11:11]</bitRange>
              <description>enables clock for ARM-APP </description>
            </field>
            <field>
              <name>dma_com</name>
              <bitRange>[10:10]</bitRange>
              <description>enables clock for COM DMA-Ctrl </description>
            </field>
            <field>
              <name>xpic0</name>
              <bitRange>[9:9]</bitRange>
              <description>enables clock for XPIC0 </description>
            </field>
            <field>
              <name>xc_misc</name>
              <bitRange>[8:8]</bitRange>
              <description>enables clock for misc. XC logic (XC-DMAC, XC-SR, XC-BUFMAN </description>
            </field>
            <field>
              <name>fb1</name>
              <bitRange>[7:7]</bitRange>
              <description>enables clock for fieldbus1 </description>
            </field>
            <field>
              <name>fb0</name>
              <bitRange>[6:6]</bitRange>
              <description>enables clock for fieldbus0 </description>
            </field>
            <field>
              <name>xmac1</name>
              <bitRange>[5:5]</bitRange>
              <description>enables clock for xMAC1 </description>
            </field>
            <field>
              <name>xmac0</name>
              <bitRange>[4:4]</bitRange>
              <description>enables clock for xMAC0 </description>
            </field>
            <field>
              <name>tpec1</name>
              <bitRange>[3:3]</bitRange>
              <description>enables clock for tPEC1 </description>
            </field>
            <field>
              <name>tpec0</name>
              <bitRange>[2:2]</bitRange>
              <description>enables clock for tPEC0 </description>
            </field>
            <field>
              <name>rpec1</name>
              <bitRange>[1:1]</bitRange>
              <description>enables clock for rPEC1 </description>
            </field>
            <field>
              <name>rpec0</name>
              <bitRange>[0:0]</bitRange>
              <description>enables clock for rPEC0 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'clock_enable1': 0xFF401270-->
          <name>clock_enable1</name>
          <description>Global Clock Enable Register: Use this registers to disable modules completely for power saving purposes. Changes will only have an effect if the corresponding bits in the clock_enable_mask-register are set. Note: For low power consumption at power on, all switchable clocks are disabled after reset and must be enabled before module usage.  This register is a write mask register, i.e. lower 16 bits are only writeable, if corresponding upper bits are set. This register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: 1.: read out access-key from asic_ctrl_access_key register 2.: write back access-key to asic_ctrl_access_key register 3.: write desired value to this register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000070</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000F000F</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:20]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ipc_wm</name>
              <bitRange>[19:19]</bitRange>
              <description>Write mask of ipc </description>
            </field>
            <field>
              <name>crypt_wm</name>
              <bitRange>[18:18]</bitRange>
              <description>Write mask of crypt </description>
            </field>
            <field>
              <name>dma_app_wm</name>
              <bitRange>[17:17]</bitRange>
              <description>Write mask of dma_app </description>
            </field>
            <field>
              <name>xpic1_wm</name>
              <bitRange>[16:16]</bitRange>
              <description>Write mask of xpic1 </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[15:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ipc</name>
              <bitRange>[3:3]</bitRange>
              <description>enables clock for IPC Units (OSAC/NFIFO) </description>
            </field>
            <field>
              <name>crypt</name>
              <bitRange>[2:2]</bitRange>
              <description>enables clock for CRYPT units AES and MTGY Note: The HASH and RANDOM units are always on and accessible. </description>
            </field>
            <field>
              <name>dma_app</name>
              <bitRange>[1:1]</bitRange>
              <description>enables clock for APP DMA-Ctrl </description>
            </field>
            <field>
              <name>xpic1</name>
              <bitRange>[0:0]</bitRange>
              <description>enables clock for XPIC1 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'clock_enable1_mask': 0xFF401274-->
          <name>clock_enable1_mask</name>
          <description>Global Clock Enable Mask Register: This register can be used to lock the clock_enable1 register.   Bits of the clock_enable1 register can only be modified if the corresponding mask bits in this register are set. This register is lockable by asic_ctrl_com.netx_lock-lock_register. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000074</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000000F</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ipc</name>
              <bitRange>[3:3]</bitRange>
              <description>enables clock for IPC Units (OSAC/NFIFO) </description>
            </field>
            <field>
              <name>crypt</name>
              <bitRange>[2:2]</bitRange>
              <description>enables clock for CRYPT Unit </description>
            </field>
            <field>
              <name>dma_app</name>
              <bitRange>[1:1]</bitRange>
              <description>enables clock for APP DMA-Ctrl </description>
            </field>
            <field>
              <name>xpic1</name>
              <bitRange>[0:0]</bitRange>
              <description>enables clock for XPIC1 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'systime_eth_system_ctrl': 0xFF401278-->
          <name>systime_eth_system_ctrl</name>
          <description>Select systime for the ethernet system Changes will only have an effect if the corresponding bits in the systime_eth_system_ctrl_mask-register are set. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000078</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:2]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>eth_system</name>
              <bitRange>[1:0]</bitRange>
              <description>Systime for the ethernet system 00: systime_com 01: systime_com_uc 10: systime_app </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'systime_eth_system_ctrl_mask': 0xFF40127C-->
          <name>systime_eth_system_ctrl_mask</name>
          <description>Select systime for the ethernet system (mask register) This register can be used to lock the systime_eth_system_ctrl register.   Bits of the systime_eth_system_ctrl register can only be modified if the corresponding mask bits in this register are set. This register is lockable by asic_ctrl_com.netx_lock-lock_register. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000007C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000003</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:2]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>eth_system</name>
              <bitRange>[1:0]</bitRange>
              <description>Systime for the ethernet system </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'systime_gpio_com_ctrl_mask': 0xFF401284-->
          <name>systime_gpio_com_ctrl_mask</name>
          <description>Select systime for GPIO_COM (mask register) This register can be used to lock the systime_gpio_com_ctrl register.   Bits of the systime_gpio_com_ctrl register can only be modified if the corresponding mask bits in this register are set. This register is lockable by asic_ctrl_com.netx_lock-lock_register. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000084</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000003</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:2]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>gpio_com</name>
              <bitRange>[1:0]</bitRange>
              <description>Systime for GPIO_COM </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'systime_gpio_app_ctrl': 0xFF401288-->
          <name>systime_gpio_app_ctrl</name>
          <description>Select systime for GPIO_APP Changes will only have an effect if the corresponding bits in the systime_gpio_app_ctrl_mask-register are set. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000088</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:2]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>gpio_app</name>
              <bitRange>[1:0]</bitRange>
              <description>Systime for GPIO_APP 00: systime_com 01: systime_com_uc 10: systime_app </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'systime_gpio_app_ctrl_mask': 0xFF40128C-->
          <name>systime_gpio_app_ctrl_mask</name>
          <description>Select systime for GPIO_APP (mask register) This register can be used to lock the systime_gpio_app_ctrl register.   Bits of the systime_gpio_app_ctrl register can only be modified if the corresponding mask bits in this register are set. This register is lockable by asic_ctrl_com.netx_lock-lock_register. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000008C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000003</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:2]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>gpio_app</name>
              <bitRange>[1:0]</bitRange>
              <description>Systime for GPIO_APP </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'ahbl_master_ready': 0xFF401290-->
          <name>ahbl_master_ready</name>
          <description>All AHBL master ready signals. Before stop, reset or clockdisable of any master, check that this bit of the appropriate master is 1. If it is 0, a current access of this master to the system is not finished. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000090</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000FFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:20]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[19:0]</bitRange>
              <description>netx ahbl_master readys M_DPM0          0 M_DPM1          1 M_XC01_d        2 M_XC01_s        3 M_ADC_MASTER    4 M_IPC_MASTER    5 M_IDPM_MASTER   6 M_DEBUG_MASTER  7 M_XPIC_COM_d    8 M_XPIC_COM_i    9 M_XPIC_APP_d   10 M_XPIC_APP_i   11 M_ARM_COM_d    12 M_ARM_COM_i    13 M_ARM_COM_s    14 M_ARM_APP_d    15 M_ARM_APP_i    16 M_ARM_APP_s    17 M_DMAC_COM     18 M_DMAC_APP     19 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'system_status': 0xFF401294-->
          <name>system_status</name>
          <description>netX System Status Register. This register provides information of special netX system events, e.g: System related interrupt activity, Abort activity. Abort or IRQ status flag can be cleared by writing a '1' to the appropriate bits. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000094</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00001F02</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:13]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>xtal_ok</name>
              <bitRange>[12:12]</bitRange>
              <description>XTAL status signal of disclock. If '1', the PLL can be powered up. -&gt; diverse internal counters count faster (RTC-clock-divider, PLL-stby-controller,...) </description>
            </field>
            <field>
              <name>quick_count</name>
              <bitRange>[11:11]</bitRange>
              <description>Testmode 'quick_count' is activated by BSCAN JTAG TAP controller -&gt; diverse internal counters count faster (RTC-clock-divider, PLL-stby-controller,...) </description>
            </field>
            <field>
              <name>pll_bypass</name>
              <bitRange>[10:10]</bitRange>
              <description>Testmode 'pll_bypass' is activated by TESTDECODER JTAG TAP controller (clk_test is selected in this case) or by the bit pll_bypass of the system_ctrl register in ASIC_CTRL_COM ist set -&gt; 400MHz-PLL is bypassed, PLL output is unused, 400MHz-Clocks (clk400, clk400_2sdram) are directly connected to the RC-OSC clock. </description>
            </field>
            <field>
              <name>pw_bod_ok</name>
              <bitRange>[9:9]</bitRange>
              <description>Power watch brown-out detection status </description>
            </field>
            <field>
              <name>testmode</name>
              <bitRange>[8:8]</bitRange>
              <description>sampled netx TESTMODE input for production test purpose </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[7:2]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>extbus_to_irq_status</name>
              <bitRange>[1:1]</bitRange>
              <description>Current status of HIF-Extension Bus Ready Timeout IRQ. Note: This IRQ is controlled/cleared by ext_rdy_cfg register (area hif_asyncmem_ctrl). </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[0:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'netx_version': 0xFF401298-->
          <name>netx_version</name>
          <description>netX Revision Register: This register contains information about netX hardware and bootloader revision. This register is lockable by asic_ctrl_com.netx_lock-lock_id_regs. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000098</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000000D</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>netx_version</name>
              <bitRange>[31:0]</bitRange>
              <description>netX revision number: Hardware reset values of netX version register is: 0x01: netx100, netx500 0x01: netx50 0x02: netx5_mpw 0x41: netx5 0x50: netx10 0x05: netx51/52 0x06: reserved 0x07: netx6 0x08: netx4000_relaxed 0x09: reserved 0x0a: netx4000 0x0b: reserved 0x0c: netx90_mpw 0x0d: netx90 Further netX revisions should increment (next: 0x0e). This register is changed to Hilscher netX bootloader revision by ROM-code: Hardware reset values should differ from Hilscher values! netX50 revision number starts with 'B' (0x42). 0x41: netx500 0x42: netx50 0x42: netx100 0x41: netx5 0x42: netx10 0x42: netx51/52 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'asic_ctrl_netx_unique_id0': 0xFF40129C-->
          <name>asic_ctrl_netx_unique_id0</name>
          <description>netX unique ID register 0 This register is lockable by asic_ctrl_com.netx_lock-lock_id_regs. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000009C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>id</name>
              <bitRange>[31:0]</bitRange>
              <description>netX unique ID part 0 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'asic_ctrl_netx_unique_id1': 0xFF4012A0-->
          <name>asic_ctrl_netx_unique_id1</name>
          <description>netX unique ID register 1 This register is lockable by asic_ctrl_com.netx_lock-lock_id_regs. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000A0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>id</name>
              <bitRange>[31:0]</bitRange>
              <description>netX unique ID part 1 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'asic_ctrl_netx_unique_id2': 0xFF4012A4-->
          <name>asic_ctrl_netx_unique_id2</name>
          <description>netX unique ID register 2 This register is lockable by asic_ctrl_com.netx_lock-lock_id_regs. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000A4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>id</name>
              <bitRange>[0:0]</bitRange>
              <description>netX unique ID part 2 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'asic_ctrl_clk2rc_length_min': 0xFF4012A8-->
          <name>asic_ctrl_clk2rc_length_min</name>
          <description>RC-OSC clock period min The minimum RC-OSC clock period in cycles of system clock (10ns). </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000A8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x000003FF</resetValue>
          <resetMask>0x000003FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:10]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>len</name>
              <bitRange>[9:0]</bitRange>
              <description>Minimum length of RC-clock period: This register writable, but it can also be changed by hardware. Set to 0x3ff to find a new minimum value. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'asic_ctrl_clk2rc_length_max': 0xFF4012AC-->
          <name>asic_ctrl_clk2rc_length_max</name>
          <description>RC-OSC clock period max The maximum RC-OSC clock period in cycles of system clock (10ns). </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000AC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000003FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:10]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>len</name>
              <bitRange>[9:0]</bitRange>
              <description>max length of RC-clock period This register writable, but it can also be changed by hardware. Set to 0 to find a new maximum value. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'asic_ctrl_irq_raw': 0xFF4012B0-->
          <name>asic_ctrl_irq_raw</name>
          <description>ASIC_CTRL raw IRQ: Read access shows status of unmasked IRQs. IRQs are set automatically and reset by writing to this register: Write access with '1' resets the appropriate IRQ. Write access with '0' does not influence this bit. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000B0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pll_fast</name>
              <bitRange>[3:3]</bitRange>
              <description>raw interrupt state of CLKSUP detected PLL too fast or RC-OSC too slow </description>
            </field>
            <field>
              <name>pll_slow</name>
              <bitRange>[2:2]</bitRange>
              <description>raw interrupt state of CLKSUP detected PLL too slow or RC-OSC too fast </description>
            </field>
            <field>
              <name>pll_noclk</name>
              <bitRange>[1:1]</bitRange>
              <description>raw interrupt state of CLKSUP detected no clock at PLL </description>
            </field>
            <field>
              <name>bod_fail</name>
              <bitRange>[0:0]</bitRange>
              <description>raw interrupt state of voltage at BOD pad dropped below threshold </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'asic_ctrl_irq_masked': 0xFF4012B4-->
          <name>asic_ctrl_irq_masked</name>
          <description>ASIC_CTRL masked IRQ: Shows status of masked IRQs. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000B4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pll_fast</name>
              <bitRange>[3:3]</bitRange>
              <description>masked interrupt state of CLKSUP detected PLL too fast or RC-OSC too slow </description>
            </field>
            <field>
              <name>pll_slow</name>
              <bitRange>[2:2]</bitRange>
              <description>masked interrupt state of CLKSUP detected PLL too slow or RC-OSC too fast </description>
            </field>
            <field>
              <name>pll_noclk</name>
              <bitRange>[1:1]</bitRange>
              <description>masked interrupt state of CLKSUP detected no clock at PLL </description>
            </field>
            <field>
              <name>bod_fail</name>
              <bitRange>[0:0]</bitRange>
              <description>masked interrupt state of voltage at BOD pad dropped below threshold </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'asic_ctrl_irq_mask_set': 0xFF4012B8-->
          <name>asic_ctrl_irq_mask_set</name>
          <description>ASIC_CTRL IRQ mask set: The IRQ mask enables interrupt requests for corresponding interrupt sources. As its bits might be changed by different software tasks, the IRQ maskq register is not writable directly, but by set and reset masks: Write access with '1' sets interrupt mask bit. Write access with '0' does not influence this bit. Read access shows actual interrupt mask. Attention: Before activating interrupt mask, delete old pending interrupts by writing the same value to bod_irq_raw. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000B8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pll_fast</name>
              <bitRange>[3:3]</bitRange>
              <description>set interrupt mask of CLKSUP detected PLL too fast or RC-OSC too slow </description>
            </field>
            <field>
              <name>pll_slow</name>
              <bitRange>[2:2]</bitRange>
              <description>set interrupt mask of CLKSUP detected PLL too slow or RC-OSC too fast </description>
            </field>
            <field>
              <name>pll_noclk</name>
              <bitRange>[1:1]</bitRange>
              <description>set interrupt mask of CLKSUP detected no clock at PLL </description>
            </field>
            <field>
              <name>bod_fail</name>
              <bitRange>[0:0]</bitRange>
              <description>set interrupt mask of voltage at BOD pad dropped below threshold </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'asic_ctrl_irq_mask_reset': 0xFF4012BC-->
          <name>asic_ctrl_irq_mask_reset</name>
          <description>ASIC_CTRL IRQ mask reset: This is the corresponding reset mask to disable interrupt requests for corresponding interrupt sources: Write access with '1' resets interrupt mask bit. Write access with '0' does not influence this bit. Read access shows actual interrupt mask. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000BC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pll_fast</name>
              <bitRange>[3:3]</bitRange>
              <description>reset interrupt mask of CLKSUP detected PLL too fast or RC-OSC too slow </description>
            </field>
            <field>
              <name>pll_slow</name>
              <bitRange>[2:2]</bitRange>
              <description>reset interrupt mask of CLKSUP detected PLL too slow or RC-OSC too fast </description>
            </field>
            <field>
              <name>pll_noclk</name>
              <bitRange>[1:1]</bitRange>
              <description>reset interrupt mask of CLKSUP detected no clock at PLL </description>
            </field>
            <field>
              <name>bod_fail</name>
              <bitRange>[0:0]</bitRange>
              <description>reset interrupt mask of voltage at BOD pad dropped below threshold </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'asic_ctrl_access_key': 0xFF4012C0-->
          <name>asic_ctrl_access_key</name>
          <description>ASIC Control Locking access-key Register: Writing to any register in the asic_ctrl and other protected address areas (e.g. mmio_ctrl) is only possible after setting the correct key here to avoid unintended changes e.g. by crashed software. ---- Changing a control register in the asic_ctrl or in another protected address area is only possible with the following sequence: 1.: Read out the locking access-key from this register. 2.: Write back this locking access-key to this register. 3.: Write desired value to the control register. ---- The locking access-key will become invalid after each access to any register in the asic_ctrl or any other protected address area (e.g. mmio_ctrl). The access-key has to be read out and set again for subsequent accesses.  Note:    Since netX51/52 there are separated instances of access-key-protection logic: netX90 has separate access-keys for the   following CPUs: ARM_COM, ARM_APP, XPIC_COM, XPIC_APP, DEBUG_MASTER. All other masters (currently none) use the shared key.    This allows running access-key read-write sequences of these masters without any synchronisation or locking between them.    To allow access to a protected register for other masters (currently none) one shared instance of the   access-key-protection logic is implemented. This instance is shared by all other masters. When more   than one of these masters should use it, locking must be done in software to avoid interruption of a sequence   of one master by another master. Note: netX90 MPW had only four separate keys: ARM_COM, ARM_APP, DEBUG_MASTER and one shared key (XPIC_COM, XPIC_APP). </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000C0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>access_key</name>
              <bitRange>[15:0]</bitRange>
              <description>Locking access-key for next write access. </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>mmio_ctrl</name>
      <description>mmio_ctrl</description>
      <baseAddress>0xFF401300</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>128</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <!--Absolute address of 'mmio0_cfg': 0xFF401300-->
          <name>mmio0_cfg</name>
          <!--Multiplexmatrix Configuration Register for MMIO0 -->
          <!--- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
          <!--Some bits of this register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: -->
          <!--1.: read out access-key from asic_ctrl_access_key register -->
          <!--2.: write back access-key to asic_ctrl_access_key register -->
          <!--3.: write desired value to this register -->
          <!--- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
          <!--Core-inputs not mapped to any MMIO will be assigned to 0. -->
          <!--If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. -->
          <!--- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
          <!--mmio*_sel - coding: -->
          <!-- -->
          <!--{     |                        |                           | border=1 -->
          <!--Coding netX internal function   signal type                 functional group -->
          <!--       (core connection) -->
          <!--0x00   xc_sample0               input,                      Trigger/Latch Unit -->
          <!--0x01   xc_sample1               input,                      Trigger/Latch Unit -->
          <!--0x02   xc_trigger0              tristatable output,         Trigger/Latch Unit -->
          <!--0x03   xc_trigger1              tristatable output,         Trigger/Latch Unit -->
          <!--0x04   can0_app_rx              input,                      CAN of app side ARM -->
          <!--0x05   can0_app_tx              always driven output,       CAN of app side ARM -->
          <!--0x06   can1_app_rx              input,                      CAN of app side ARM -->
          <!--0x07   can1_app_tx              always driven output,       CAN of app side ARM -->
          <!--0x08   i2c_xpic_app_scl         bidirectional,              I2C of app side xPIC -->
          <!--0x09   i2c_xpic_app_sda         bidirectional,              I2C of app side xPIC -->
          <!--0x0a   i2c_app_scl              bidirectional,              I2C of app side ARM -->
          <!--0x0b   i2c_app_sda              bidirectional,              I2C of app side ARM -->
          <!--0x0c   spi_xpic_app_clk         bidirectional,              SPI of app side xPIC -->
          <!--0x0d   spi_xpic_app_cs0n        bidirectional,              SPI of app side xPIC -->
          <!--0x0e   spi_xpic_app_cs1n        bidirectional,              SPI of app side xPIC -->
          <!--0x0f   spi_xpic_app_cs2n        bidirectional,              SPI of app side xPIC -->
          <!--0x10   spi_xpic_app_miso        bidirectional,              SPI of app side xPIC -->
          <!--0x11   spi_xpic_app_mosi        bidirectional,              SPI of app side xPIC -->
          <!--0x12   spi1_app_clk             bidirectional,              SPI of app side ARM -->
          <!--0x13   spi1_app_cs0n            bidirectional,              SPI of app side ARM -->
          <!--0x14   spi1_app_cs1n            bidirectional,              SPI of app side ARM -->
          <!--0x15   spi1_app_cs2n            bidirectional,              SPI of app side ARM -->
          <!--0x16   spi1_app_miso            bidirectional,              SPI of app side ARM -->
          <!--0x17   spi1_app_mosi            bidirectional,              SPI of app side ARM -->
          <!--0x18   uart_xpic_app_rxd        input,                      UART of app side xPIC -->
          <!--0x19   uart_xpic_app_txd        tristatable output,         UART of app side xPIC -->
          <!--0x1a   uart_xpic_app_rtsn       tristatable output,         UART of app side xPIC -->
          <!--0x1b   uart_xpic_app_ctsn       input,                      UART of app side xPIC -->
          <!--0x1c   uart_app_rxd             input,                      UART of app side ARM -->
          <!--0x1d   uart_app_txd             tristatable output,         UART of app side ARM -->
          <!--0x1e   uart_app_rtsn            tristatable output,         UART of app side ARM -->
          <!--0x1f   uart_app_ctsn            input,                      UART of app side ARM -->
          <!--0x20   gpio0                    bidirectional,              GPIO (Timer/PWM/Blink etc) -->
          <!--0x21   gpio1                    bidirectional,              GPIO (Timer/PWM/Blink etc) -->
          <!--0x22   gpio2                    bidirectional,              GPIO (Timer/PWM/Blink etc) -->
          <!--0x23   gpio3                    bidirectional,              GPIO (Timer/PWM/Blink etc) -->
          <!--0x24   gpio4                    bidirectional,              GPIO (Timer/PWM/Blink etc) -->
          <!--0x25   gpio5                    bidirectional,              GPIO (Timer/PWM/Blink etc) -->
          <!--0x26   gpio6                    bidirectional,              GPIO (Timer/PWM/Blink etc) -->
          <!--0x27   gpio7                    bidirectional,              GPIO (Timer/PWM/Blink etc) -->
          <!--0x28   wdg_act                  always driven output,       System Watchdog -->
          <!--0x29   en_in                    input,                      HIF pio input sampling enable -->
          <!--0x2a   eth_mdc                  always driven output,       MDIO -->
          <!--0x2b   eth_mdio                 bidirectional,              MDIO -->
          <!-- -->
          <!--0x3f   PIO mode                 use MMIO PIO line registers PIO function} -->
          <!-- -->
          <!-- -->
          <description>description too long, please enter short description.</description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000003F</resetValue>
          <resetMask>0x0007063F</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:19]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>status_in_ro</name>
              <bitRange>[18:18]</bitRange>
              <description>current input status of mmio0, could also be read from 'mmio_in_line_status' register </description>
            </field>
            <field>
              <name>pio_out</name>
              <bitRange>[17:17]</bitRange>
              <description>PIO mode output drive level of mmio0, could also be programmd by 'mmio_pio_out_line_cfg' register (not protected) Changing this bit will also change according bit in 'mmio_pio_out_line_cfg register'. </description>
            </field>
            <field>
              <name>pio_oe</name>
              <bitRange>[16:16]</bitRange>
              <description>PIO mode output enable of mmio0, could also be programmd by mmio_pio_oe_line_cfg register (not protected) Changing this bit will also change according bit in 'mmio_pio_oe_line_cfg register'. </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[15:11]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>mmio_in_inv</name>
              <bitRange>[10:10]</bitRange>
              <description>1: invert input signal; 0: keep original signal polarity (access-key-protected) </description>
            </field>
            <field>
              <name>mmio_out_inv</name>
              <bitRange>[9:9]</bitRange>
              <description>1: invert output signal; 0: keep original signal polarity (access-key-protected) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[8:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>mmio_sel</name>
              <bitRange>[5:0]</bitRange>
              <description>mmio0 signal selection (default: PIO mode, access-key-protected). </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mmio1_cfg': 0xFF401304-->
          <name>mmio1_cfg</name>
          <description>Multiplexmatrix Configuration Register for MMIO1 ------------------------------- Some bits of this register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: 1.: read out access-key from asic_ctrl_access_key register 2.: write back access-key to asic_ctrl_access_key register 3.: write desired value to this register ------------------------------- Core-inputs not mapped to any MMIO will be assigned to 0. If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. For signal selection codings (mmio*_sel) look at header of register adr_mmio0. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000003F</resetValue>
          <resetMask>0x0007063F</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:19]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>status_in_ro</name>
              <bitRange>[18:18]</bitRange>
              <description>current input status of mmio1, could also be read from 'mmio_in_line_status' register </description>
            </field>
            <field>
              <name>pio_out</name>
              <bitRange>[17:17]</bitRange>
              <description>PIO mode output drive level of mmio1, could also be programmd by 'mmio_pio_out_line_cfg' register (not protected) Changing this bit will also change according bit in 'mmio_pio_out_line_cfg register'. </description>
            </field>
            <field>
              <name>pio_oe</name>
              <bitRange>[16:16]</bitRange>
              <description>PIO mode output enable of mmio1, could also be programmd by mmio_pio_oe_line_cfg register (not protected) Changing this bit will also change according bit in 'mmio_pio_oe_line_cfg register'. </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[15:11]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>mmio_in_inv</name>
              <bitRange>[10:10]</bitRange>
              <description>1: invert input signal; 0: keep original signal polarity (access-key-protected) </description>
            </field>
            <field>
              <name>mmio_out_inv</name>
              <bitRange>[9:9]</bitRange>
              <description>1: invert output signal; 0: keep original signal polarity (access-key-protected) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[8:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>mmio_sel</name>
              <bitRange>[5:0]</bitRange>
              <description>mmio1 signal selection (default: PIO mode, access-key-protected). </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mmio2_cfg': 0xFF401308-->
          <name>mmio2_cfg</name>
          <description>Multiplexmatrix Configuration Register for MMIO2 ------------------------------- Some bits of this register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: 1.: read out access-key from asic_ctrl_access_key register 2.: write back access-key to asic_ctrl_access_key register 3.: write desired value to this register ------------------------------- Core-inputs not mapped to any MMIO will be assigned to 0. If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. For signal selection codings (mmio*_sel) look at header of register adr_mmio0. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000003F</resetValue>
          <resetMask>0x0007063F</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:19]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>status_in_ro</name>
              <bitRange>[18:18]</bitRange>
              <description>current input status of mmio2, could also be read from 'mmio_in_line_status' register </description>
            </field>
            <field>
              <name>pio_out</name>
              <bitRange>[17:17]</bitRange>
              <description>PIO mode output drive level of mmio2, could also be programmd by 'mmio_pio_out_line_cfg' register (not protected) Changing this bit will also change according bit in 'mmio_pio_out_line_cfg register'. </description>
            </field>
            <field>
              <name>pio_oe</name>
              <bitRange>[16:16]</bitRange>
              <description>PIO mode output enable of mmio2, could also be programmd by mmio_pio_oe_line_cfg register (not protected) Changing this bit will also change according bit in 'mmio_pio_oe_line_cfg register'. </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[15:11]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>mmio_in_inv</name>
              <bitRange>[10:10]</bitRange>
              <description>1: invert input signal; 0: keep original signal polarity (access-key-protected) </description>
            </field>
            <field>
              <name>mmio_out_inv</name>
              <bitRange>[9:9]</bitRange>
              <description>1: invert output signal; 0: keep original signal polarity (access-key-protected) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[8:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>mmio_sel</name>
              <bitRange>[5:0]</bitRange>
              <description>mmio2 signal selection (default: PIO mode, access-key-protected). </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mmio3_cfg': 0xFF40130C-->
          <name>mmio3_cfg</name>
          <description>Multiplexmatrix Configuration Register for MMIO3 ------------------------------- Some bits of this register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: 1.: read out access-key from asic_ctrl_access_key register 2.: write back access-key to asic_ctrl_access_key register 3.: write desired value to this register ------------------------------- Core-inputs not mapped to any MMIO will be assigned to 0. If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. For signal selection codings (mmio*_sel) look at header of register adr_mmio0. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000003F</resetValue>
          <resetMask>0x0007063F</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:19]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>status_in_ro</name>
              <bitRange>[18:18]</bitRange>
              <description>current input status of mmio3, could also be read from 'mmio_in_line_status' register </description>
            </field>
            <field>
              <name>pio_out</name>
              <bitRange>[17:17]</bitRange>
              <description>PIO mode output drive level of mmio3, could also be programmd by 'mmio_pio_out_line_cfg' register (not protected) Changing this bit will also change according bit in 'mmio_pio_out_line_cfg register'. </description>
            </field>
            <field>
              <name>pio_oe</name>
              <bitRange>[16:16]</bitRange>
              <description>PIO mode output enable of mmio3, could also be programmd by mmio_pio_oe_line_cfg register (not protected) Changing this bit will also change according bit in 'mmio_pio_oe_line_cfg register'. </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[15:11]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>mmio_in_inv</name>
              <bitRange>[10:10]</bitRange>
              <description>1: invert input signal; 0: keep original signal polarity (access-key-protected) </description>
            </field>
            <field>
              <name>mmio_out_inv</name>
              <bitRange>[9:9]</bitRange>
              <description>1: invert output signal; 0: keep original signal polarity (access-key-protected) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[8:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>mmio_sel</name>
              <bitRange>[5:0]</bitRange>
              <description>mmio3 signal selection (default: PIO mode, access-key-protected). </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mmio4_cfg': 0xFF401310-->
          <name>mmio4_cfg</name>
          <description>Multiplexmatrix Configuration Register for MMIO4 ------------------------------- Some bits of this register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: 1.: read out access-key from asic_ctrl_access_key register 2.: write back access-key to asic_ctrl_access_key register 3.: write desired value to this register ------------------------------- Core-inputs not mapped to any MMIO will be assigned to 0. If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. For signal selection codings (mmio*_sel) look at header of register adr_mmio0. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000003F</resetValue>
          <resetMask>0x0007063F</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:19]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>status_in_ro</name>
              <bitRange>[18:18]</bitRange>
              <description>current input status of mmio4, could also be read from 'mmio_in_line_status' register </description>
            </field>
            <field>
              <name>pio_out</name>
              <bitRange>[17:17]</bitRange>
              <description>PIO mode output drive level of mmio4, could also be programmd by 'mmio_pio_out_line_cfg' register (not protected) Changing this bit will also change according bit in 'mmio_pio_out_line_cfg register'. </description>
            </field>
            <field>
              <name>pio_oe</name>
              <bitRange>[16:16]</bitRange>
              <description>PIO mode output enable of mmio4, could also be programmd by mmio_pio_oe_line_cfg register (not protected) Changing this bit will also change according bit in 'mmio_pio_oe_line_cfg register'. </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[15:11]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>mmio_in_inv</name>
              <bitRange>[10:10]</bitRange>
              <description>1: invert input signal; 0: keep original signal polarity (access-key-protected) </description>
            </field>
            <field>
              <name>mmio_out_inv</name>
              <bitRange>[9:9]</bitRange>
              <description>1: invert output signal; 0: keep original signal polarity (access-key-protected) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[8:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>mmio_sel</name>
              <bitRange>[5:0]</bitRange>
              <description>mmio4 signal selection (default: PIO mode, access-key-protected). </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mmio5_cfg': 0xFF401314-->
          <name>mmio5_cfg</name>
          <description>Multiplexmatrix Configuration Register for MMIO5 ------------------------------- Some bits of this register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: 1.: read out access-key from asic_ctrl_access_key register 2.: write back access-key to asic_ctrl_access_key register 3.: write desired value to this register ------------------------------- Core-inputs not mapped to any MMIO will be assigned to 0. If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. For signal selection codings (mmio*_sel) look at header of register adr_mmio0. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000003F</resetValue>
          <resetMask>0x0007063F</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:19]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>status_in_ro</name>
              <bitRange>[18:18]</bitRange>
              <description>current input status of mmio5, could also be read from 'mmio_in_line_status' register </description>
            </field>
            <field>
              <name>pio_out</name>
              <bitRange>[17:17]</bitRange>
              <description>PIO mode output drive level of mmio5, could also be programmd by 'mmio_pio_out_line_cfg' register (not protected) Changing this bit will also change according bit in 'mmio_pio_out_line_cfg register'. </description>
            </field>
            <field>
              <name>pio_oe</name>
              <bitRange>[16:16]</bitRange>
              <description>PIO mode output enable of mmio5, could also be programmd by mmio_pio_oe_line_cfg register (not protected) Changing this bit will also change according bit in 'mmio_pio_oe_line_cfg register'. </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[15:11]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>mmio_in_inv</name>
              <bitRange>[10:10]</bitRange>
              <description>1: invert input signal; 0: keep original signal polarity (access-key-protected) </description>
            </field>
            <field>
              <name>mmio_out_inv</name>
              <bitRange>[9:9]</bitRange>
              <description>1: invert output signal; 0: keep original signal polarity (access-key-protected) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[8:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>mmio_sel</name>
              <bitRange>[5:0]</bitRange>
              <description>mmio5 signal selection (default: PIO mode, access-key-protected). </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mmio6_cfg': 0xFF401318-->
          <name>mmio6_cfg</name>
          <description>Multiplexmatrix Configuration Register for MMIO6 ------------------------------- Some bits of this register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: 1.: read out access-key from asic_ctrl_access_key register 2.: write back access-key to asic_ctrl_access_key register 3.: write desired value to this register ------------------------------- Core-inputs not mapped to any MMIO will be assigned to 0. If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. For signal selection codings (mmio*_sel) look at header of register adr_mmio0. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000018</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000003F</resetValue>
          <resetMask>0x0007063F</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:19]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>status_in_ro</name>
              <bitRange>[18:18]</bitRange>
              <description>current input status of mmio6, could also be read from 'mmio_in_line_status' register </description>
            </field>
            <field>
              <name>pio_out</name>
              <bitRange>[17:17]</bitRange>
              <description>PIO mode output drive level of mmio6, could also be programmd by 'mmio_pio_out_line_cfg' register (not protected) Changing this bit will also change according bit in 'mmio_pio_out_line_cfg register'. </description>
            </field>
            <field>
              <name>pio_oe</name>
              <bitRange>[16:16]</bitRange>
              <description>PIO mode output enable of mmio6, could also be programmd by mmio_pio_oe_line_cfg register (not protected) Changing this bit will also change according bit in 'mmio_pio_oe_line_cfg register'. </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[15:11]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>mmio_in_inv</name>
              <bitRange>[10:10]</bitRange>
              <description>1: invert input signal; 0: keep original signal polarity (access-key-protected) </description>
            </field>
            <field>
              <name>mmio_out_inv</name>
              <bitRange>[9:9]</bitRange>
              <description>1: invert output signal; 0: keep original signal polarity (access-key-protected) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[8:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>mmio_sel</name>
              <bitRange>[5:0]</bitRange>
              <description>mmio6 signal selection (default: PIO mode, access-key-protected). </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mmio7_cfg': 0xFF40131C-->
          <name>mmio7_cfg</name>
          <description>Multiplexmatrix Configuration Register for MMIO7 ------------------------------- Some bits of this register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: 1.: read out access-key from asic_ctrl_access_key register 2.: write back access-key to asic_ctrl_access_key register 3.: write desired value to this register ------------------------------- Core-inputs not mapped to any MMIO will be assigned to 0. If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. For signal selection codings (mmio*_sel) look at header of register adr_mmio0. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000001C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000003F</resetValue>
          <resetMask>0x0007063F</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:19]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>status_in_ro</name>
              <bitRange>[18:18]</bitRange>
              <description>current input status of mmio7, could also be read from 'mmio_in_line_status' register </description>
            </field>
            <field>
              <name>pio_out</name>
              <bitRange>[17:17]</bitRange>
              <description>PIO mode output drive level of mmio7, could also be programmd by 'mmio_pio_out_line_cfg' register (not protected) Changing this bit will also change according bit in 'mmio_pio_out_line_cfg register'. </description>
            </field>
            <field>
              <name>pio_oe</name>
              <bitRange>[16:16]</bitRange>
              <description>PIO mode output enable of mmio7, could also be programmd by mmio_pio_oe_line_cfg register (not protected) Changing this bit will also change according bit in 'mmio_pio_oe_line_cfg register'. </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[15:11]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>mmio_in_inv</name>
              <bitRange>[10:10]</bitRange>
              <description>1: invert input signal; 0: keep original signal polarity (access-key-protected) </description>
            </field>
            <field>
              <name>mmio_out_inv</name>
              <bitRange>[9:9]</bitRange>
              <description>1: invert output signal; 0: keep original signal polarity (access-key-protected) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[8:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>mmio_sel</name>
              <bitRange>[5:0]</bitRange>
              <description>mmio7 signal selection (default: PIO mode, access-key-protected). </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mmio8_cfg': 0xFF401320-->
          <name>mmio8_cfg</name>
          <description>Multiplexmatrix Configuration Register for MMIO8 ------------------------------- Some bits of this register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: 1.: read out access-key from asic_ctrl_access_key register 2.: write back access-key to asic_ctrl_access_key register 3.: write desired value to this register ------------------------------- Core-inputs not mapped to any MMIO will be assigned to 0. If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. For signal selection codings (mmio*_sel) look at header of register adr_mmio0. Note:    mmio8 signal is a multiplex option of HIF_D8 and has no PIO function. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000003F</resetValue>
          <resetMask>0x0004063F</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:19]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>status_in_ro</name>
              <bitRange>[18:18]</bitRange>
              <description>current input status of mmio8 port HIF_D8. Could also be read from mmio_in_line_status register </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[17:11]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>mmio_in_inv</name>
              <bitRange>[10:10]</bitRange>
              <description>1: invert input signal; 0: keep original signal polarity (access-key-protected) </description>
            </field>
            <field>
              <name>mmio_out_inv</name>
              <bitRange>[9:9]</bitRange>
              <description>1: invert output signal; 0: keep original signal polarity (access-key-protected) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[8:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>mmio_sel</name>
              <bitRange>[5:0]</bitRange>
              <description>mmio8 signal selection and multiplex function enable (access-key-protected). mmio8 signal is a multiplex option of HIF_D8 and will be selected when this bit-field is programmed to non-PIO MMIO function. PIO mode does not exist for this mmio8 signal. Default value 0x3f deselects mmio8 multiplex option. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mmio9_cfg': 0xFF401324-->
          <name>mmio9_cfg</name>
          <description>Multiplexmatrix Configuration Register for MMIO9 ------------------------------- Some bits of this register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: 1.: read out access-key from asic_ctrl_access_key register 2.: write back access-key to asic_ctrl_access_key register 3.: write desired value to this register ------------------------------- Core-inputs not mapped to any MMIO will be assigned to 0. If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. For signal selection codings (mmio*_sel) look at header of register adr_mmio0. Note:    mmio9 signal is a multiplex option of HIF_D9 and has no PIO function. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000024</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000003F</resetValue>
          <resetMask>0x0004063F</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:19]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>status_in_ro</name>
              <bitRange>[18:18]</bitRange>
              <description>current input status of mmio9 port HIF_D9. Could also be read from mmio_in_line_status register </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[17:11]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>mmio_in_inv</name>
              <bitRange>[10:10]</bitRange>
              <description>1: invert input signal; 0: keep original signal polarity (access-key-protected) </description>
            </field>
            <field>
              <name>mmio_out_inv</name>
              <bitRange>[9:9]</bitRange>
              <description>1: invert output signal; 0: keep original signal polarity (access-key-protected) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[8:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>mmio_sel</name>
              <bitRange>[5:0]</bitRange>
              <description>mmio9 signal selection and multiplex function enable (access-key-protected). mmio9 signal is a multiplex option of HIF_D9 and will be selected when this bit-field is programmed to non-PIO MMIO function. PIO mode does not exist for this mmio9 signal. Default value 0x3f deselects mmio9 multiplex option. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mmio10_cfg': 0xFF401328-->
          <name>mmio10_cfg</name>
          <description>Multiplexmatrix Configuration Register for MMIO10 ------------------------------- Some bits of this register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: 1.: read out access-key from asic_ctrl_access_key register 2.: write back access-key to asic_ctrl_access_key register 3.: write desired value to this register ------------------------------- Core-inputs not mapped to any MMIO will be assigned to 0. If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. For signal selection codings (mmio*_sel) look at header of register adr_mmio0. Note:    mmio10 signal is a multiplex option of HIF_D10 and has no PIO function. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000028</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000003F</resetValue>
          <resetMask>0x0004063F</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:19]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>status_in_ro</name>
              <bitRange>[18:18]</bitRange>
              <description>current input status of mmio10 port HIF_D10. Could also be read from mmio_in_line_status register </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[17:11]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>mmio_in_inv</name>
              <bitRange>[10:10]</bitRange>
              <description>1: invert input signal; 0: keep original signal polarity (access-key-protected) </description>
            </field>
            <field>
              <name>mmio_out_inv</name>
              <bitRange>[9:9]</bitRange>
              <description>1: invert output signal; 0: keep original signal polarity (access-key-protected) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[8:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>mmio_sel</name>
              <bitRange>[5:0]</bitRange>
              <description>mmio10 signal selection and multiplex function enable (access-key-protected). mmio10 signal is a multiplex option of HIF_D10 and will be selected when this bit-field is programmed to non-PIO MMIO function. PIO mode does not exist for this mmio10 signal. Default value 0x3f deselects mmio10 multiplex option. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mmio11_cfg': 0xFF40132C-->
          <name>mmio11_cfg</name>
          <description>Multiplexmatrix Configuration Register for MMIO11 ------------------------------- Some bits of this register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: 1.: read out access-key from asic_ctrl_access_key register 2.: write back access-key to asic_ctrl_access_key register 3.: write desired value to this register ------------------------------- Core-inputs not mapped to any MMIO will be assigned to 0. If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. For signal selection codings (mmio*_sel) look at header of register adr_mmio0. Note:    mmio11 signal is a multiplex option of HIF_D11 and has no PIO function. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000002C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000003F</resetValue>
          <resetMask>0x0004063F</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:19]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>status_in_ro</name>
              <bitRange>[18:18]</bitRange>
              <description>current input status of mmio11 port HIF_D11. Could also be read from mmio_in_line_status register </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[17:11]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>mmio_in_inv</name>
              <bitRange>[10:10]</bitRange>
              <description>1: invert input signal; 0: keep original signal polarity (access-key-protected) </description>
            </field>
            <field>
              <name>mmio_out_inv</name>
              <bitRange>[9:9]</bitRange>
              <description>1: invert output signal; 0: keep original signal polarity (access-key-protected) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[8:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>mmio_sel</name>
              <bitRange>[5:0]</bitRange>
              <description>mmio11 signal selection and multiplex function enable (access-key-protected). mmio11 signal is a multiplex option of HIF_D11 and will be selected when this bit-field is programmed to non-PIO MMIO function. PIO mode does not exist for this mmio11 signal. Default value 0x3f deselects mmio11 multiplex option. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mmio12_cfg': 0xFF401330-->
          <name>mmio12_cfg</name>
          <description>Multiplexmatrix Configuration Register for MMIO12 ------------------------------- Some bits of this register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: 1.: read out access-key from asic_ctrl_access_key register 2.: write back access-key to asic_ctrl_access_key register 3.: write desired value to this register ------------------------------- Core-inputs not mapped to any MMIO will be assigned to 0. If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. For signal selection codings (mmio*_sel) look at header of register adr_mmio0. Note:    mmio12 signal is a multiplex option of HIF_D12 and has no PIO function. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000030</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000003F</resetValue>
          <resetMask>0x0004063F</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:19]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>status_in_ro</name>
              <bitRange>[18:18]</bitRange>
              <description>current input status of mmio12 port HIF_D12. Could also be read from mmio_in_line_status register </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[17:11]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>mmio_in_inv</name>
              <bitRange>[10:10]</bitRange>
              <description>1: invert input signal; 0: keep original signal polarity (access-key-protected) </description>
            </field>
            <field>
              <name>mmio_out_inv</name>
              <bitRange>[9:9]</bitRange>
              <description>1: invert output signal; 0: keep original signal polarity (access-key-protected) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[8:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>mmio_sel</name>
              <bitRange>[5:0]</bitRange>
              <description>mmio12 signal selection and multiplex function enable (access-key-protected). mmio12 signal is a multiplex option of HIF_D12 and will be selected when this bit-field is programmed to non-PIO MMIO function. PIO mode does not exist for this mmio12 signal. Default value 0x3f deselects mmio12 multiplex option. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mmio13_cfg': 0xFF401334-->
          <name>mmio13_cfg</name>
          <description>Multiplexmatrix Configuration Register for MMIO13 ------------------------------- Some bits of this register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: 1.: read out access-key from asic_ctrl_access_key register 2.: write back access-key to asic_ctrl_access_key register 3.: write desired value to this register ------------------------------- Core-inputs not mapped to any MMIO will be assigned to 0. If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. For signal selection codings (mmio*_sel) look at header of register adr_mmio0. Note:    mmio13 signal is a multiplex option of HIF_D13 and has no PIO function. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000034</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000003F</resetValue>
          <resetMask>0x0004063F</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:19]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>status_in_ro</name>
              <bitRange>[18:18]</bitRange>
              <description>current input status of mmio13 port HIF_D13. Could also be read from mmio_in_line_status register </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[17:11]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>mmio_in_inv</name>
              <bitRange>[10:10]</bitRange>
              <description>1: invert input signal; 0: keep original signal polarity (access-key-protected) </description>
            </field>
            <field>
              <name>mmio_out_inv</name>
              <bitRange>[9:9]</bitRange>
              <description>1: invert output signal; 0: keep original signal polarity (access-key-protected) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[8:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>mmio_sel</name>
              <bitRange>[5:0]</bitRange>
              <description>mmio13 signal selection and multiplex function enable (access-key-protected). mmio13 signal is a multiplex option of HIF_D13 and will be selected when this bit-field is programmed to non-PIO MMIO function. PIO mode does not exist for this mmio13 signal. Default value 0x3f deselects mmio13 multiplex option. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mmio14_cfg': 0xFF401338-->
          <name>mmio14_cfg</name>
          <description>Multiplexmatrix Configuration Register for MMIO14 ------------------------------- Some bits of this register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: 1.: read out access-key from asic_ctrl_access_key register 2.: write back access-key to asic_ctrl_access_key register 3.: write desired value to this register ------------------------------- Core-inputs not mapped to any MMIO will be assigned to 0. If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. For signal selection codings (mmio*_sel) look at header of register adr_mmio0. Note:    mmio14 signal is a multiplex option of HIF_D14 and has no PIO function. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000038</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000003F</resetValue>
          <resetMask>0x0004063F</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:19]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>status_in_ro</name>
              <bitRange>[18:18]</bitRange>
              <description>current input status of mmio14 port HIF_D14. Could also be read from mmio_in_line_status register </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[17:11]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>mmio_in_inv</name>
              <bitRange>[10:10]</bitRange>
              <description>1: invert input signal; 0: keep original signal polarity (access-key-protected) </description>
            </field>
            <field>
              <name>mmio_out_inv</name>
              <bitRange>[9:9]</bitRange>
              <description>1: invert output signal; 0: keep original signal polarity (access-key-protected) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[8:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>mmio_sel</name>
              <bitRange>[5:0]</bitRange>
              <description>mmio14 signal selection and multiplex function enable (access-key-protected). mmio14 signal is a multiplex option of HIF_D14 and will be selected when this bit-field is programmed to non-PIO MMIO function. PIO mode does not exist for this mmio14 signal. Default value 0x3f deselects mmio14 multiplex option. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mmio15_cfg': 0xFF40133C-->
          <name>mmio15_cfg</name>
          <description>Multiplexmatrix Configuration Register for MMIO15 ------------------------------- Some bits of this register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: 1.: read out access-key from asic_ctrl_access_key register 2.: write back access-key to asic_ctrl_access_key register 3.: write desired value to this register ------------------------------- Core-inputs not mapped to any MMIO will be assigned to 0. If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. For signal selection codings (mmio*_sel) look at header of register adr_mmio0. Note:    mmio15 signal is a multiplex option of HIF_D15 and has no PIO function. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000003C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000003F</resetValue>
          <resetMask>0x0004063F</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:19]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>status_in_ro</name>
              <bitRange>[18:18]</bitRange>
              <description>current input status of mmio15 port HIF_D15. Could also be read from mmio_in_line_status register </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[17:11]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>mmio_in_inv</name>
              <bitRange>[10:10]</bitRange>
              <description>1: invert input signal; 0: keep original signal polarity (access-key-protected) </description>
            </field>
            <field>
              <name>mmio_out_inv</name>
              <bitRange>[9:9]</bitRange>
              <description>1: invert output signal; 0: keep original signal polarity (access-key-protected) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[8:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>mmio_sel</name>
              <bitRange>[5:0]</bitRange>
              <description>mmio15 signal selection and multiplex function enable (access-key-protected). mmio15 signal is a multiplex option of HIF_D15 and will be selected when this bit-field is programmed to non-PIO MMIO function. PIO mode does not exist for this mmio15 signal. Default value 0x3f deselects mmio15 multiplex option. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mmio16_cfg': 0xFF401340-->
          <name>mmio16_cfg</name>
          <description>Multiplexmatrix Configuration Register for MMIO16 ------------------------------- Some bits of this register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: 1.: read out access-key from asic_ctrl_access_key register 2.: write back access-key to asic_ctrl_access_key register 3.: write desired value to this register ------------------------------- Core-inputs not mapped to any MMIO will be assigned to 0. If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. For signal selection codings (mmio*_sel) look at header of register adr_mmio0. Note:    mmio16 signal is a multiplex option of HIF_RDN and has no PIO function. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000040</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000003F</resetValue>
          <resetMask>0x0004063F</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:19]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>status_in_ro</name>
              <bitRange>[18:18]</bitRange>
              <description>current input status of mmio16 port HIF_RDN. Could also be read from mmio_in_line_status register </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[17:11]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>mmio_in_inv</name>
              <bitRange>[10:10]</bitRange>
              <description>1: invert input signal; 0: keep original signal polarity (access-key-protected) </description>
            </field>
            <field>
              <name>mmio_out_inv</name>
              <bitRange>[9:9]</bitRange>
              <description>1: invert output signal; 0: keep original signal polarity (access-key-protected) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[8:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>mmio_sel</name>
              <bitRange>[5:0]</bitRange>
              <description>mmio16 signal selection and multiplex function enable (access-key-protected). mmio16 signal is a multiplex option of HIF_RDN and will be selected when this bit-field is programmed to non-PIO MMIO function. PIO mode does not exist for this mmio16 signal. Default value 0x3f deselects mmio16 multiplex option. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mmio17_cfg': 0xFF401344-->
          <name>mmio17_cfg</name>
          <description>Multiplexmatrix Configuration Register for MMIO17 ------------------------------- Some bits of this register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: 1.: read out access-key from asic_ctrl_access_key register 2.: write back access-key to asic_ctrl_access_key register 3.: write desired value to this register ------------------------------- Core-inputs not mapped to any MMIO will be assigned to 0. If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. For signal selection codings (mmio*_sel) look at header of register adr_mmio0. Note:    mmio17 signal is a multiplex option of HIF_DIRQ and has no PIO function. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000044</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000003F</resetValue>
          <resetMask>0x0004063F</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:19]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>status_in_ro</name>
              <bitRange>[18:18]</bitRange>
              <description>current input status of mmio17 port HIF_DIRQ. Could also be read from mmio_in_line_status register </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[17:11]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>mmio_in_inv</name>
              <bitRange>[10:10]</bitRange>
              <description>1: invert input signal; 0: keep original signal polarity (access-key-protected) </description>
            </field>
            <field>
              <name>mmio_out_inv</name>
              <bitRange>[9:9]</bitRange>
              <description>1: invert output signal; 0: keep original signal polarity (access-key-protected) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[8:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>mmio_sel</name>
              <bitRange>[5:0]</bitRange>
              <description>mmio17 signal selection and multiplex function enable (access-key-protected). mmio17 signal is a multiplex option of HIF_DIRQ and will be selected when this bit-field is programmed to non-PIO MMIO function. PIO mode does not exist for this mmio17 signal. Default value 0x3f deselects mmio17 multiplex option. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mmio_pio_out_line_cfg0': 0xFF401348-->
          <name>mmio_pio_out_line_cfg0</name>
          <description>MMIO PIO line output level register of MMIO 0 to 17. Changing bits here will change 'pio_out' bit of related mmio*_cfg register. Changes there will change related bit inside this register. Note: This register is not protected by netX access-key algorithm. Note    MMIO8 has no PIO function. The value of bit 8 of (assotiated with MMIO8) will be ignored.    MMIO9 has no PIO function. The value of bit 9 of (assotiated with MMIO9) will be ignored.    MMIO10 has no PIO function. The value of bit 10 of (assotiated with MMIO10) will be ignored.    MMIO11 has no PIO function. The value of bit 11 of (assotiated with MMIO11) will be ignored.    MMIO12 has no PIO function. The value of bit 12 of (assotiated with MMIO12) will be ignored.    MMIO13 has no PIO function. The value of bit 13 of (assotiated with MMIO13) will be ignored.    MMIO14 has no PIO function. The value of bit 14 of (assotiated with MMIO14) will be ignored.    MMIO15 has no PIO function. The value of bit 15 of (assotiated with MMIO15) will be ignored.    MMIO16 has no PIO function. The value of bit 16 of (assotiated with MMIO16) will be ignored.    MMIO17 has no PIO function. The value of bit 17 of (assotiated with MMIO17) will be ignored. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000048</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0003FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:18]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>line</name>
              <bitRange>[17:0]</bitRange>
              <description>MMIO output state if related MMIO is in PIO mode. If related MMIO is not in PIO mode, programmed setting is ignored. Bit 0 controls MMIO0, bit 1 controls MMIO1, ... bit 17 controlls MMIO17. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mmio_pio_out_line_set_cfg0': 0xFF40134C-->
          <name>mmio_pio_out_line_set_cfg0</name>
          <description>MMIO PIO line output level set register of MMIO 0 to 17. This register is for setting single MMIO PIOs to high level with a single access. In contrast to using the 'mmio_pio_out_line_cfg0' register no read-modify-write sequence (which could be interrupted) is required. Writing '1's here will activate the 'pio_out' bit of related 'mmio*_cfg' register and also activate the related bits in the 'mmio_pio_out_line_cfg0' register. For read this register returns the same value as the 'mmio_pio_out_line_cfg0' register. Note: This register is not protected by netX access-key algorithm. Note    MMIO8 has no PIO function. The value of bit 8 of (assotiated with MMIO8) will be ignored.    MMIO9 has no PIO function. The value of bit 9 of (assotiated with MMIO9) will be ignored.    MMIO10 has no PIO function. The value of bit 10 of (assotiated with MMIO10) will be ignored.    MMIO11 has no PIO function. The value of bit 11 of (assotiated with MMIO11) will be ignored.    MMIO12 has no PIO function. The value of bit 12 of (assotiated with MMIO12) will be ignored.    MMIO13 has no PIO function. The value of bit 13 of (assotiated with MMIO13) will be ignored.    MMIO14 has no PIO function. The value of bit 14 of (assotiated with MMIO14) will be ignored.    MMIO15 has no PIO function. The value of bit 15 of (assotiated with MMIO15) will be ignored.    MMIO16 has no PIO function. The value of bit 16 of (assotiated with MMIO16) will be ignored.    MMIO17 has no PIO function. The value of bit 17 of (assotiated with MMIO17) will be ignored. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000004C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0003FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:18]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>line</name>
              <bitRange>[17:0]</bitRange>
              <description>Write '1's to set the related MMIO output to high level (when it is in PIO mode and output is enabled). If related MMIO is not in PIO mode, programmed setting is ignored. Bit 0 controls MMIO0, bit 1 controls MMIO1, ... bit 17 controlls MMIO17. For read the current value of the programmed output states is returned (i.e. the value of mmio_pio_out_line_cfg0). </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mmio_pio_out_line_reset_cfg0': 0xFF401350-->
          <name>mmio_pio_out_line_reset_cfg0</name>
          <description>MMIO PIO line output level reset register of MMIO 0 to 17. This register is for deactivating single MMIO PIOs with a single access. In contrast to using the 'mmio_pio_out_line_cfg0' register no read-modify-write sequence (which could be interrupted) is required. Writing '1's here will clear the 'pio_out' bit of related 'mmio*_cfg' register and also clear the related bits in the 'mmio_pio_out_line_cfg0' register. For read this register returns the same value as the 'mmio_pio_out_line_cfg0' register. Note: This register is not protected by netX access-key algorithm. Note    MMIO8 has no PIO function. The value of bit 8 of (assotiated with MMIO8) will be ignored.    MMIO9 has no PIO function. The value of bit 9 of (assotiated with MMIO9) will be ignored.    MMIO10 has no PIO function. The value of bit 10 of (assotiated with MMIO10) will be ignored.    MMIO11 has no PIO function. The value of bit 11 of (assotiated with MMIO11) will be ignored.    MMIO12 has no PIO function. The value of bit 12 of (assotiated with MMIO12) will be ignored.    MMIO13 has no PIO function. The value of bit 13 of (assotiated with MMIO13) will be ignored.    MMIO14 has no PIO function. The value of bit 14 of (assotiated with MMIO14) will be ignored.    MMIO15 has no PIO function. The value of bit 15 of (assotiated with MMIO15) will be ignored.    MMIO16 has no PIO function. The value of bit 16 of (assotiated with MMIO16) will be ignored.    MMIO17 has no PIO function. The value of bit 17 of (assotiated with MMIO17) will be ignored. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000050</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0003FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:18]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>line</name>
              <bitRange>[17:0]</bitRange>
              <description>Write '1's to set the related MMIO output to low level (when it is in PIO mode and output is enabled). If related MMIO is not in PIO mode, programmed setting is ignored. Bit 0 controls MMIO0, bit 1 controls MMIO1, ... bit 17 controlls MMIO17. For read the current value of the programmed output states is returned (i.e. the value of mmio_pio_out_line_cfg0). </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mmio_pio_oe_line_cfg0': 0xFF401354-->
          <name>mmio_pio_oe_line_cfg0</name>
          <description>MMIO PIO line output enable register of MMIO 0 to 17. Changing bits here will change 'pio_oe' bit of related mmio*_cfg register. Changes there will change related bit inside this register. Note: This register is not protected by netX access-key algorithm. Note    MMIO8 has no PIO function. The value of bit 8 of (assotiated with MMIO8) will be ignored.    MMIO9 has no PIO function. The value of bit 9 of (assotiated with MMIO9) will be ignored.    MMIO10 has no PIO function. The value of bit 10 of (assotiated with MMIO10) will be ignored.    MMIO11 has no PIO function. The value of bit 11 of (assotiated with MMIO11) will be ignored.    MMIO12 has no PIO function. The value of bit 12 of (assotiated with MMIO12) will be ignored.    MMIO13 has no PIO function. The value of bit 13 of (assotiated with MMIO13) will be ignored.    MMIO14 has no PIO function. The value of bit 14 of (assotiated with MMIO14) will be ignored.    MMIO15 has no PIO function. The value of bit 15 of (assotiated with MMIO15) will be ignored.    MMIO16 has no PIO function. The value of bit 16 of (assotiated with MMIO16) will be ignored.    MMIO17 has no PIO function. The value of bit 17 of (assotiated with MMIO17) will be ignored. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000054</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0003FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:18]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>line</name>
              <bitRange>[17:0]</bitRange>
              <description>MMIO output enable if related MMIO is in PIO mode. If related MMIO is not in PIO mode, programmed setting is ignored. Bit 0 controls MMIO0, bit 1 controls MMIO1, ... bit 17 controlls MMIO17. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mmio_pio_oe_line_set_cfg0': 0xFF401358-->
          <name>mmio_pio_oe_line_set_cfg0</name>
          <description>MMIO PIO line output enable set register of MMIO 0 to 17. This register is for activating single MMIO PIOs with a single access. In contrast to using the 'mmio_pio_oe_line_cfg0' register no read-modify-write sequence (which could be interrupted) is required. Writing '1's here will activate the 'pio_oe' bit of related 'mmio*_cfg' register and also activate the related bits in the 'mmio_pio_oe_line_cfg0' register. For read this register returns the same value as the 'mmio_pio_oe_line_cfg0' register. Note: This register is not protected by netX access-key algorithm. Note    MMIO8 has no PIO function. The value of bit 8 of (assotiated with MMIO8) will be ignored.    MMIO9 has no PIO function. The value of bit 9 of (assotiated with MMIO9) will be ignored.    MMIO10 has no PIO function. The value of bit 10 of (assotiated with MMIO10) will be ignored.    MMIO11 has no PIO function. The value of bit 11 of (assotiated with MMIO11) will be ignored.    MMIO12 has no PIO function. The value of bit 12 of (assotiated with MMIO12) will be ignored.    MMIO13 has no PIO function. The value of bit 13 of (assotiated with MMIO13) will be ignored.    MMIO14 has no PIO function. The value of bit 14 of (assotiated with MMIO14) will be ignored.    MMIO15 has no PIO function. The value of bit 15 of (assotiated with MMIO15) will be ignored.    MMIO16 has no PIO function. The value of bit 16 of (assotiated with MMIO16) will be ignored.    MMIO17 has no PIO function. The value of bit 17 of (assotiated with MMIO17) will be ignored. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000058</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0003FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:18]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>line</name>
              <bitRange>[17:0]</bitRange>
              <description>Write '1's to activate the related MMIO output enable (when it is in PIO mode). If related MMIO is not in PIO mode, programmed setting is ignored. Bit 0 controls MMIO0, bit 1 controls MMIO1, ... bit 17 controlls MMIO17. For read the current value of the programmed output enables is returned (i.e. the value of mmio_pio_oe_line_cfg0). </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mmio_pio_oe_line_reset_cfg0': 0xFF40135C-->
          <name>mmio_pio_oe_line_reset_cfg0</name>
          <description>MMIO PIO line output enable reset register of MMIO 0 to 17. This register is for deactivating single MMIO PIOs with a single access. In contrast to using the 'mmio_pio_oe_line_cfg0' register no read-modify-write sequence (which could be interrupted) is required. Writing '1's here will clear the 'pio_oe' bit of related 'mmio*_cfg' register and also clear the related bits in the 'mmio_pio_oe_line_cfg0' register. For read this register returns the same value as the 'mmio_pio_oe_line_cfg0' register. Note: This register is not protected by netX access-key algorithm. Note    MMIO8 has no PIO function. The value of bit 8 of (assotiated with MMIO8) will be ignored.    MMIO9 has no PIO function. The value of bit 9 of (assotiated with MMIO9) will be ignored.    MMIO10 has no PIO function. The value of bit 10 of (assotiated with MMIO10) will be ignored.    MMIO11 has no PIO function. The value of bit 11 of (assotiated with MMIO11) will be ignored.    MMIO12 has no PIO function. The value of bit 12 of (assotiated with MMIO12) will be ignored.    MMIO13 has no PIO function. The value of bit 13 of (assotiated with MMIO13) will be ignored.    MMIO14 has no PIO function. The value of bit 14 of (assotiated with MMIO14) will be ignored.    MMIO15 has no PIO function. The value of bit 15 of (assotiated with MMIO15) will be ignored.    MMIO16 has no PIO function. The value of bit 16 of (assotiated with MMIO16) will be ignored.    MMIO17 has no PIO function. The value of bit 17 of (assotiated with MMIO17) will be ignored. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000005C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0003FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:18]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>line</name>
              <bitRange>[17:0]</bitRange>
              <description>Write '1's to clear the related MMIO output enable (when it is in PIO mode). If related MMIO is not in PIO mode, programmed setting is ignored. Bit 0 controls MMIO0, bit 1 controls MMIO1, ... bit 17 controlls MMIO17. For read the current value of the programmed output enables is returned (i.e. the value of mmio_pio_oe_line_cfg0). </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mmio_in_line_status0': 0xFF401360-->
          <name>mmio_in_line_status0</name>
          <description>MMIO input line register of MMIO 0 to 17. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000060</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0003FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:18]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>line</name>
              <bitRange>[17:0]</bitRange>
              <description>sampled MMIO input state. Does not depend whether MMIO is in PIO mode or not. Bit 0 monitors MMIO0, Bit 1 monitors MMIO1, ... bit 17 monitors MMIO17. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mmio_is_pio_status0': 0xFF401364-->
          <name>mmio_is_pio_status0</name>
          <description>MMIO mode line register of MMIO 0 to 17. Note: PIO Mode can be enabled or disabled in mmio_cfg registers. Note    MMIO8 is not a standard-function MMIO and has no PIO function. When bit 8 is set, MMIO8-function will be active on HIF_D8.    MMIO9 is not a standard-function MMIO and has no PIO function. When bit 9 is set, MMIO9-function will be active on HIF_D9.    MMIO10 is not a standard-function MMIO and has no PIO function. When bit 10 is set, MMIO10-function will be active on HIF_D10.    MMIO11 is not a standard-function MMIO and has no PIO function. When bit 11 is set, MMIO11-function will be active on HIF_D11.    MMIO12 is not a standard-function MMIO and has no PIO function. When bit 12 is set, MMIO12-function will be active on HIF_D12.    MMIO13 is not a standard-function MMIO and has no PIO function. When bit 13 is set, MMIO13-function will be active on HIF_D13.    MMIO14 is not a standard-function MMIO and has no PIO function. When bit 14 is set, MMIO14-function will be active on HIF_D14.    MMIO15 is not a standard-function MMIO and has no PIO function. When bit 15 is set, MMIO15-function will be active on HIF_D15.    MMIO16 is not a standard-function MMIO and has no PIO function. When bit 16 is set, MMIO16-function will be active on HIF_RDN.    MMIO17 is not a standard-function MMIO and has no PIO function. When bit 17 is set, MMIO17-function will be active on HIF_DIRQ. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000064</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0003FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:18]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>line</name>
              <bitRange>[17:0]</bitRange>
              <description>Bit 0 shows status of MMIO0, Bit 1 shows status of  MMIO1, ... bit 17 shows MMIO17. If the MMIO is the standard function of the netX IO (i.e. the netX pin name is MMIOx), the bit of the related MMIO shows whether the MMIO is in PIO mode or not. If the MMIO is a multiplex function of a netX IO (i.e. the netX pin name is another than MMIOx), a PIO function is not available by the MMIO function. In this case the bit of the related MMIO shows whether the MMIO function is selected or not. {                                 |       | The related MMIO is a standard-   Value   Status function MMIO (netX MMIOx pin) yes                   0     The related MMIO is not in PIO mode (is assigned to core functionality). yes                   1     The related MMIO is in PIO mode (is not assigned to core functionality). no                    0     The MMIO-function of the netX IO is selected and assigned to a MMIO core functionality. no                    1     The MMIO-function of the related netX IO is not selected. } Note: When the MMIO function is selected it could be possible that also another IO multiplex function is activated (e.g. by global IO-configuration registers 'io_config'). This function could have higher priority in global IO multiplexing and could deselect the MMIO function. </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>iflash_cfg2</name>
      <description>iflash_cfg2</description>
      <baseAddress>0xFF401400</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>128</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <!--Absolute address of 'buffer_read_ahead_instructions': 0xFF401400-->
          <name>buffer_read_ahead_instructions</name>
          <description>read ahead on instruction channel of flash controller max read ahead = buffer lines - 1 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>read ahead on instruction channel of flash controller </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'buffer_read_ahead_data': 0xFF401404-->
          <name>buffer_read_ahead_data</name>
          <description>read ahead on data channel of flash controller max read ahead = buffer lines - 1 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>read ahead on data channel of flash controller </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'iflash_signals_cfg': 0xFF401408-->
          <name>iflash_signals_cfg</name>
          <description>no Register description</description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000007F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>se</name>
              <bitRange>[6:6]</bitRange>
              <description>flash clock </description>
            </field>
            <field>
              <name>prog</name>
              <bitRange>[5:5]</bitRange>
              <description>defines program cycle </description>
            </field>
            <field>
              <name>nvstr</name>
              <bitRange>[4:4]</bitRange>
              <description>defines non-volatile store cycle </description>
            </field>
            <field>
              <name>mas1</name>
              <bitRange>[3:3]</bitRange>
              <description>defines mass erase cycle </description>
            </field>
            <field>
              <name>erase</name>
              <bitRange>[2:2]</bitRange>
              <description>defines erase cycle </description>
            </field>
            <field>
              <name>ye</name>
              <bitRange>[1:1]</bitRange>
              <description>y address enable </description>
            </field>
            <field>
              <name>xe</name>
              <bitRange>[0:0]</bitRange>
              <description>x address enable </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'iflash_mode_cfg': 0xFF40140C-->
          <name>iflash_mode_cfg</name>
          <description>no Register description</description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000007</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:3]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>iflash_mode</name>
              <bitRange>[2:0]</bitRange>
              <description>3'b000 READ_MODE /  3'b001 PROGRAM_MODE /  3'b010 ERASE_MODE / 3'b011 MASS_ERASE_MODE / 3'b100 MANUAL_MODE </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'iflash_access': 0xFF401410-->
          <name>iflash_access</name>
          <description>read only for the ready bit, write 1 to start access flash action depends on iflash_mode_cfg </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000010</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>run</name>
              <bitRange>[0:0]</bitRange>
              <description>write 1 to start accesss, poll until set to 0 for finsh </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'iflash_yadr': 0xFF401414-->
          <name>iflash_yadr</name>
          <description>Y address of flash controller not all bits are used see: implementation size of flash </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000001F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[4:0]</bitRange>
              <description>Y address of flash controller </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'iflash_xadr': 0xFF401418-->
          <name>iflash_xadr</name>
          <description>X address of flash controller not all bits are used see: implementation size of flash </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000018</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000003FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:10]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[9:0]</bitRange>
              <description>X address of flash controller </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'iflash_din0': 0xFF40141C-->
          <name>iflash_din0</name>
          <description>data[31:0] of din flash controller </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000001C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data[31:0] of din flash controller </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'iflash_din1': 0xFF401420-->
          <name>iflash_din1</name>
          <description>data[63:32] of din flash controller </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data[63:32] of din flash controller </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'iflash_din2': 0xFF401424-->
          <name>iflash_din2</name>
          <description>data[95:64] of din flash controller </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000024</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data[95:64] of din flash controller </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'iflash_din3': 0xFF401428-->
          <name>iflash_din3</name>
          <description>data[127:96] of din flash controller </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000028</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data[127:96] of din flash controller </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'iflash_din4': 0xFF40142C-->
          <name>iflash_din4</name>
          <description>in manual mode for din data[143:128] of din flash controller </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000002C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[15:0]</bitRange>
              <description>data[143:128] of din flash controller </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'iflash_reset': 0xFF401430-->
          <name>iflash_reset</name>
          <description>reset flash controller </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000030</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>reset</name>
              <bitRange>[0:0]</bitRange>
              <description>1= reset; 0= release reset </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'iflash_red_cfg0': 0xFF401434-->
          <name>iflash_red_cfg0</name>
          <description>enable redundancy page XADR[9:3] </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000034</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>adr0</name>
              <bitRange>[7:1]</bitRange>
              <description>XADR to compare </description>
            </field>
            <field>
              <name>n_enb</name>
              <bitRange>[0:0]</bitRange>
              <description>0= enable XADR compare; 1= disable XADR compare </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'iflash_red_cfg1': 0xFF401438-->
          <name>iflash_red_cfg1</name>
          <description>enable redundancy page XADR[9:3] </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000038</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>adr1</name>
              <bitRange>[7:1]</bitRange>
              <description>XADR to compare </description>
            </field>
            <field>
              <name>n_enb</name>
              <bitRange>[0:0]</bitRange>
              <description>0= enable XADR compare; 1= disable XADR compare </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'iflash_ifren_cfg': 0xFF40143C-->
          <name>iflash_ifren_cfg</name>
          <description>no Register description</description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000003C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:2]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ifren1</name>
              <bitRange>[1:1]</bitRange>
              <description>information1 block enable for read only </description>
            </field>
            <field>
              <name>ifren</name>
              <bitRange>[0:0]</bitRange>
              <description>information block enable </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'iflash_din4_ecc': 0xFF401440-->
          <name>iflash_din4_ecc</name>
          <description>in manual mode for ecc calculation of din3..0 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000040</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[15:0]</bitRange>
              <description>ecc of din3..0 flash controller </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'iflash_special_cfg': 0xFF401444-->
          <name>iflash_special_cfg</name>
          <description>no Register description</description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000044</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:2]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>slm</name>
              <bitRange>[1:1]</bitRange>
              <description>sleep mode </description>
            </field>
            <field>
              <name>tmr</name>
              <bitRange>[0:0]</bitRange>
              <description>test mode </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'iflash_protection_info': 0xFF401448-->
          <name>iflash_protection_info</name>
          <description>no Register description</description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000048</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000003F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>write_1</name>
              <bitRange>[5:5]</bitRange>
              <description>protect infopage 1 4k page for write </description>
            </field>
            <field>
              <name>write_0</name>
              <bitRange>[4:4]</bitRange>
              <description>protect infopage 0 4k page for write </description>
            </field>
            <field>
              <name>read_1_up</name>
              <bitRange>[3:3]</bitRange>
              <description>protect infopage 1 upper 2k page for read </description>
            </field>
            <field>
              <name>read_1_dw</name>
              <bitRange>[2:2]</bitRange>
              <description>protect infopage 1 lower 2k page for read </description>
            </field>
            <field>
              <name>read_0_up</name>
              <bitRange>[1:1]</bitRange>
              <description>protect infopage 0 upper 2k page for read </description>
            </field>
            <field>
              <name>read_0_dw</name>
              <bitRange>[0:0]</bitRange>
              <description>protect infopage 0 lower 2k page for read </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>hif_io_ctrl</name>
      <description>hif_io_ctrl</description>
      <baseAddress>0xFF401480</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>64</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>hif_pio_arm</name>
        <value>25</value>
      </interrupt>
      <interrupt>
        <name>hif_rdy_to</name>
        <value>30</value>
      </interrupt>
      <registers>
        <register>
          <!--Absolute address of 'hif_io_cfg': 0xFF401480-->
          <name>hif_io_cfg</name>
          <description>IO Config Register: Selects of HIF pin multiplexing. See Excel pinning sheet for details. This configuration must be set up according to external netX connection before any access to external logic. This register is protected by the netX access key mechanism; changing this register is only possible by the following sequence:  1.: read out access key from ACCESS_KEY register (ASIC_CTRL address area) 2.: write back access key to ACCESS_KEY register (ASIC_CTRL address area) 3.: write desired value to this register (ASIC_CTRL address area)  Attention: Be very careful programming this register. False settings may cause permanent damage on netX or devices connected            to HIF-IOs.  </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x01000060</resetValue>
          <resetMask>0x03000FFF</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:26]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>en_hif_wdg_sys_hif_d19</name>
              <bitRange>[25:25]</bitRange>
              <description>Obsolete for netX90, removed by regdef filter script. Enable 'wdg_active'/'WDGACT'-signal of netX system watchdog on HIF_D19. # default 0 When this bit is set HIF_D19 will be set to output mode and provide watchdog-active signal. However this will have no effect when HIF_D19 is used for another function. For parallel DPM with watchdog HIF_D19 must be set to PIO mode inside DPM module. Note: netX system watch can be programmed inside address area 'WATCHDOG'/'NETX_WDG_AREA'. </description>
            </field>
            <field>
              <name>en_hif_rdy_pio_mi</name>
              <bitRange>[24:24]</bitRange>
              <description>Enable HIF_RDY for PIO usage (or other netX MUX function) when the HIF is in memory-mode. Note: This bit must be disabled if HIF_RDY is used as EXT_BUS RDY (extension bus ready input). Note: This bit is ignored if HIF is DPM. Use DPM RDY configuration if HIF_RDY should be used as PIO together with DPM functionality. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[23:12]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sel_hif_a_width</name>
              <bitRange>[11:8]</bitRange>
              <description>Select HIF MI address width. Selecting smaller address bus width will allow PIO usage on related IOs when not used otherwise (e.g. as SDRAM control signals, see en_hif_sdram_mi). A0 to A11 are always enabled when the HIF MI is enabled by the hif_mi_cfg bits. Following settings are valid for 8 or 16 bit data modes. Please note: - The lower byte of the MI is located on the MII signals (refer to the pinning table). - The upper byte of the MI is located on the lower HIF_D IOs (HIF_D0..7, not on HIF_D8..15). - 32bit data is not supported for netX90 {    |       |       |               |          | Lines   Range           IOs     Function   Comment 0000:    11      2k   HIF_A0..10      A0..A10    ext_a0..ext_a10 0001:    12      4k   HIF_A0..11      A0..A11    + ext_a11 0010:    13      8k   HIF_A0..12      A0..A12    + ext_a12 0011:    14     16k   HIF_A0..13      A0..A13    + ext_a13 0100:    15     32k   HIF_A0..14      A0..A14    + ext_a14 0101:    16     64k   HIF_A0..15      A0..A15    + ext_a15 0110:    17    128k   HIF_A0..16      A0..A16    + ext_a16 0111:    18    256k   HIF_A0..17      A0..A17    + ext_a17}  Following settings are only valid for 8 bit data mode: {    |       |       |               |          | Lines   Range   IOs             Function   Comment 1000     19    512k   HIF_A0..17      A0..A17    ext_a0..ext_a17 HIF_D0          A18        ext_a18 1001     20      1M   HIF_A0..17      A0..A17    ext_a0..ext_a17 HIF_D0,1        A18,A19    ext_a18,ext_a19 1010     21      2M   HIF_A0..17      A0..A17    ext_a0..ext_a17 HIF_D0..2       A18..A20   ext_a18..ext_a20 1011     22      4M   HIF_A0..17      A0..A17    ext_a0..ext_a17 HIF_D0..3       A18..A21   ext_a18..ext_a21 1100     23      8M   HIF_A0..17      A0..A17    ext_a0..ext_a17 HIF_D0..4       A18..A22   ext_a18..ext_a22 1101     24     16M   HIF_A0..17      A0..A17    ext_a0..ext_a17 HIF_D0..5       A18..A23   ext_a18..ext_a23 1110     25     32M   HIF_A0..17      A0..A17    ext_a0..ext_a17 HIF_D0..6       A18..A24   ext_a18..ext_a24 }  </description>
            </field>
            <field>
              <name>en_hif_sdram_mi</name>
              <bitRange>[7:7]</bitRange>
              <description>Enable HIF IOs for SDRAM Memory Interface configuration. HIF-SDRAM Chip-Select is generated on HIF_CSN when this bit is set. ExtBus Chip-Select area 0 is not available then. Ready-Signal for ExtBus is never available when SDRAM is enabled here. If enabled following IOs are used for SDRAM (netX90, partial shared with SRAM/FLASH ctrl signals): {                  |          | netX90 IO         Function   Comment HIF_A0..12        SD_A0..12  Shared SDRAM/FLASH/SRAM address lines, small SDRAM devices do not need all lines (sel_hif_a_width). MII1_RXER         SD_D0      Lower data byte bit 0. Shared SDRAM/FLASH/SRAM data lines. MII1_CRS          SD_D1      Lower data byte bit 1. Shared SDRAM/FLASH/SRAM data lines. MII1_COL          SD_D2      Lower data byte bit 2. Shared SDRAM/FLASH/SRAM data lines. PHY0_LED_LINK_IN  SD_D3      Lower data byte bit 3. Shared SDRAM/FLASH/SRAM data lines. PHY1_LED_LINK_IN  SD_D4      Lower data byte bit 4. Shared SDRAM/FLASH/SRAM data lines. MII0_TXEN         SD_D5      Lower data byte bit 5. Shared SDRAM/FLASH/SRAM data lines. MII0_COL          SD_D6      Lower data byte bit 6. Shared SDRAM/FLASH/SRAM data lines. MII0_CRS          SD_D7      Lower data byte bit 7. Shared SDRAM/FLASH/SRAM data lines. HIF_D0..7         SD_D8..15  Upper data byte, Shared SDRAM/FLASH/SRAM data lines. HIF_A13..14       SD_BA0..1  Only during SDRAM access, usable as FLASH/SRAM A13..14 simultaneously. HIF_A15           SD_RASN    Only during SDRAM access, usable as FLASH/SRAM A15 simultaneously. HIF_A16           SD_CASN    Only during SDRAM access, usable as FLASH/SRAM A16 simultaneously. HIF_A17           SD_DQM0N   Only during SDRAM access, usable as FLASH/SRAM A17 simultaneously. HIF_BHEN          SD_DQM1N   Only during SDRAM access, usable as FLASH/SRAM BHEN simultaneously. HIF_WRN           SD_WEN     Only during SDRAM access, usable as FLASH/SRAM nWR simultaneously. HIF_CSN           SD_CSN     ExtBus CS0 not available HIF_RDY           SD_CKE     ExtBus Ready never available when SDRAM enabled HIF_SDCLK         SD_CLK     HIF SDRAM clock, ExtBus CS2 not available }  Note: HIF_A lines used for SDRAM will always be driven when this bit is set. This does not depend on programmed value of 'sel_hif_a_width' bit field. However 'sel_hif_a_width' must be set wide enough for SDRAM row and column addressing (depending on used SDRAM device). </description>
            </field>
            <field>
              <name>hif_mi_cfg</name>
              <bitRange>[6:5]</bitRange>
              <!--Global HIF IO Memory Interface usage configuration. Extensionbus/HIF-Memory-Interface and must be enabled and data width selected here before-->
              <!--memory devices like SRAM/FLASH/SDRAM can be used on HIF.-->
              <!--Settings:-->
              <!--{   |-->
              <!--00: HIF IOs are used as 8 bit MI.-->
              <!--Minimally used HIF IOs: HIF_A0..10, HIF_RDN, HIF_WRN + 1 Chip-select.-->
              <!--Other HIF IOs can be used for non-MI functions (e.g. MMIO8..15, sDPM0 or MLED4..11).-->
              <!--Up to 3 Chip-Selects are provided (they are PIO by default, view notes):-->
              <!--01: HIF IOs are used as 16 bit MI, HIF_D0..7 are additionally used for the upper data byte.-->
              <!--10: reserved-->
              <!--11: No MI usage. HIF IOs can be used as PIOs or for parallel DPM. }-->
              <!---->
              <!--HIF Extension-bus signal mapping for SRAM/FLASH or SDRAM:-->
              <!--{                    |          |          |           |-->
              <!--IO                 MI8       MI16     SDRAM8     SDRAM16-->
              <!--HIF_A0                 A0     BE0/A0         A0          A0-->
              <!--HIF_A1                 A1         A1         A1          A1-->
              <!--HIF_A2                 A2         A2         A2          A2-->
              <!--HIF_A3                 A3         A3         A3          A3-->
              <!--HIF_A4                 A4         A4         A4          A4-->
              <!--HIF_A5                 A5         A5         A5          A5-->
              <!--HIF_A6                 A6         A6         A6          A6-->
              <!--HIF_A7                 A7         A7         A7          A7-->
              <!--HIF_A8                 A8         A8         A8          A8-->
              <!--HIF_A9                 A9         A9         A9          A9-->
              <!--HIF_A10                A10        A10        A10         A10-->
              <!--HIF_A11           (n2) A11   (n2) A11   (n2) A11    (n2) A11-->
              <!--HIF_A12           (n2) A12   (n2) A12   (n2) A12    (n2) A12-->
              <!--HIF_A13           (n2) A13   (n2) A13        BA0         BA0-->
              <!--HIF_A14           (n2) A14   (n2) A14   (n2) BA1    (n2) BA1-->
              <!--HIF_A15           (n2) A15   (n2) A15        RAS         RAS-->
              <!--HIF_A16           (n2) A16   (n2) A16        CAS         CAS-->
              <!--HIF_A17           (n2) A17   (n2) A17        DQM0        DQM0-->
              <!---->
              <!--MII1_RXER              D0         D0         D0          D0-->
              <!--MII1_CRS               D1         D1         D1          D1-->
              <!--MII1_COL               D2         D2         D2          D2-->
              <!--PHY0_LED_LINK_IN       D3         D3         D3          D3-->
              <!--PHY1_LED_LINK_IN       D4         D4         D4          D4-->
              <!--MII0_TXEN              D5         D5         D5          D5-->
              <!--MII0_COL               D6         D6         D6          D6-->
              <!--MII0_CRS               D7         D7         D7          D7-->
              <!--HIF_D0                (n1)        D8        (n1)         D8-->
              <!--HIF_D1                (n1)        D9        (n1)         D9-->
              <!--HIF_D2                (n1)        D10       (n1)         D10-->
              <!--HIF_D3                (n1)        D11       (n1)         D11-->
              <!--HIF_D4                (n1)        D12       (n1)         D12-->
              <!--HIF_D5                (n1)        D13       (n1)         D13-->
              <!--HIF_D6                (n1)        D14       (n1)         D14-->
              <!--HIF_D7                (n1)        D15       (n1)         D15-->
              <!---->
              <!--HIF_BHEN              (n1)    BHE/BE1       (n1)         DQM1-->
              <!--HIF_CSN                CS0        CS0        CSN         CSN-->
              <!--HIF_RDN                RDN        RDN-->
              <!--HIF_WRN                WRN        WRN        WEN         WEN-->
              <!--HIF_RDY           (n2) RDY   (n2) RDY        CKE         CKE-->
              <!--HIF_DIRQ               CS1        CS1-->
              <!--HIF_SDCLK              CS2        CS2        CLK         CLK-->
              <!--}-->
              <!---->
              <!--Table Notes:-->
              <!--(n1): IOs could be used for other purpose, e.g. for serial DPM0, MMIO (refer to main pinning table).-->
              <!--(n2): Optional, (depends on further configuration, e.g. 'sel_hif_a_width' bit-field).-->
              <!---->
              <!--Note: 8 and 16 bit SRAM and SDRAM devices can be shared.-->
              <!--Note: Configuration of single SRAM/FLASH Chip-Select usage must be done additionally in-->
              <!--HIF related ASYNCMEM_CTRL address area. By default, all Chip-Selects are disabled and-->
              <!--available for PIO usage. If any external memory is used, Chip-Select configuration must be done-->
              <!--before the first access to external memory. Otherwise netX or memory-->
              <!--devices could be damaged. No data width must be configured in the ASYNCMEM_CTRL regsiters, which-->
              <!--exceeds globally enabled data width of this bit-field.-->
              <!--Note: If upper address lines above HIF_A10 are not used as PIOs, this must be configured in-->
              <!--bits 'sel_hif_a_width'.-->
              <!--Note: SDRAM Chip-Select is multiplexed with SRAM/FLASH Chip-Select 0 on HIF_CSN. If 'en_hif_sdram_mi'-->
              <!--is set and SRAM/FLASH Chip-Select 0 enabled in the ASYNCMEM_CTRL address area, SDRAM Chip-Select-->
              <!--gains priority and SRAM/FLASH Chip-Select 0 will not be available.-->
              <!---->
              <description>description too long, please enter short description.</description>
            </field>
            <field>
              <name>en_sdpm1</name>
              <bitRange>[4:4]</bitRange>
              <description>Enables the 2nd serial DPM for netX90. 0: 2nd serial DPM is disabled. 1: 2nd serial DPM is enabled. Note: It is possible to enable the 2nd serial DPM stand-alone or together with the normal DPM in serial mode (i.e. both bits 'sel_hif_dpm' and 'sel_dpm_serial' set). It is not possible to use the 2nd serial DPM together with the first DPM in parallel mode as they use the same IOs (the 2nd DPM does not provide the parallel mode). Note: The mode of the 2nd serial DPM is same as for the first DPM (programmed by the bits 'sel_dpm_serial_spo' and 'sel_dpm_serial_sph') </description>
            </field>
            <field>
              <name>sel_dpm_serial_spo</name>
              <bitRange>[3:3]</bitRange>
              <description>serial DPM mode SPI clock polarity selection (sel_hif_dpm and sel_dpm_serial must be set) 0: Serial clock idle state is low. 1: Serial clock idle state is high. </description>
            </field>
            <field>
              <name>sel_dpm_serial_sph</name>
              <bitRange>[2:2]</bitRange>
              <description>serial DPM mode SPI clock phase selection (sel_hif_dpm and sel_dpm_serial must be set) 0: Serial data sampling on first serial clock edge. 1: Serial data sampling on second serial clock edge. </description>
            </field>
            <field>
              <name>sel_dpm_serial</name>
              <bitRange>[1:1]</bitRange>
              <description>serial (SPI) DPM mode selection (ignored if sel_hif_dpm not set). There are 2 independent serial DPM interfaces for netX90. They can be used together, e.g. one for cyclic and one for acyclic data) or stand-alone. The 1st sDPM (sDPM0) can always be used together with external memory (even 16bit mode). sDPM1 can only be used with an 8 bit MI. The pinning positions of serial DPM interfaces are provided by the main pinning table: The pinning-functions 'dpm0_spi*' represent sDPM0,  pinning-functions 'dpm1_spi*' represent sDPM1. Note: For parallel DPM, the IRQ signals to the host are located on HIF_DIRQ and HIF_SDCLK (DPM0 only). When external SDRAM is used (en_hif_sdram_mi) the IRQ on HIF_SDCLK is not available). For serial DPM the IRQs are located on different IOs (refer to main pinning table). </description>
            </field>
            <field>
              <name>sel_hif_dpm</name>
              <bitRange>[0:0]</bitRange>
              <description>select DPM mode for HIF (serial or parallel) Note: For parallel DPM IO configuration use config registers in address area DPM. Note: Parallel DPM fast/service IRQ functionality (SIRQ/FIQ) on HIF_SDCLK is controlled by en_hif_sdram_mi bit Note: For parallel DPM host IRQs can be generated on HIF_DIRQ and HIF_SDCLK IOs. Note: For parallel DPM HIF PIO function muse be configured inside 'dpm_pio_cfg' registers for all HIF IOs. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hif_pio_cfg': 0xFF401484-->
          <name>hif_pio_cfg</name>
          <description>HIF PIO Mode configuration register. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80000008</resetValue>
          <resetMask>0x8C3F000B</resetMask>
          <fields>
            <field>
              <name>filter_irqs</name>
              <bitRange>[31:31]</bitRange>
              <description>Filtering of HIF PIO inputs for IRQ generation. By default filtering is applied on HIF PIO inputs before IRQ generation. 0 Spikes on PIOs will not be suppressed for HIF PIO IRQ generation. 1 Spikes up to 10ns on HIF PIOs will be suppressed by sample stages for HIF PIO IRQ generation. That causes 10ns additionally IRQ latency. </description>
            </field>
            <field>
              <name>bf_align3</name>
              <bitRange>[30:28]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>irq_hif_dirq_cfg</name>
              <bitRange>[27:26]</bitRange>
              <description>HIF_DIRQ IRQ input configuration {         | Mode   Function 00   low level active IRQ 01   high level active IRQ 10   falling edge active IRQ 11   rising edge active IRQ } For IRQ usage this IO should be in PIO input mode, (programmed in the 'hif_io_cfg' register or PIO-configuration registers of the DPM module). For input its PIO output enable must be programmed to '0'. Spikes on related PIO can be suppressed by 'filter_irqs' bit. Note: HIF PIO IRQs can be assigned and monitored in hif_pio_irq registers further down. Note: The HIF IRQ input bit fields are reordered since netx51/52 </description>
            </field>
            <field>
              <name>bf_align2</name>
              <bitRange>[25:22]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>irq_hif_a17_cfg</name>
              <bitRange>[21:20]</bitRange>
              <description>HIF_A17 IRQ input configuration For coding refer to irq_hif_dirq_cfg bit-field. </description>
            </field>
            <field>
              <name>irq_hif_a16_cfg</name>
              <bitRange>[19:18]</bitRange>
              <description>HIF_A16 IRQ input configuration For coding refer to irq_hif_dirq_cfg bit-field. </description>
            </field>
            <field>
              <name>irq_hif_d12_cfg</name>
              <bitRange>[17:16]</bitRange>
              <description>HIF_D12 (DPM_SPI_DIRQ/SPM_DIRQ) IRQ input configuration For coding refer to irq_hif_dirq_cfg bit-field. </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[15:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>filter_en_in</name>
              <bitRange>[3:3]</bitRange>
              <description>HIF PIO Input sampling enable (EN_IN) filter. 0 Spikes will not be suppressed for EN_IN. 1 Spikes up to 10ns will be suppressed by HIF PIO EN_IN sample stages. Note: Spike suppression can only done for EN_IN input. There is no spike suppression for data inputs of 'hif_pio_in0,1' registers. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[2:2]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>in_ctrl</name>
              <bitRange>[1:0]</bitRange>
              <description>HIF PIO Input sampling mode. HIF input status registers hif_pio_in0,1 can be configured by programming these bits. {         | Mode   Function 00   pio_in registers show HIF IO states sampled at power-on-reset release. 01   HIF IO states are sampled continuously (each netX system clock cycle) 10   HIF IO states are sampling is done each system clock cycle when enable signal EN_IN (MMIO-function) level is low. 11   HIF IO states are sampling is done each system clock cycle when enable signal EN_IN (MMIO-function) level is high. others   reserved } Note: Settings 00 to 11 are netX 50 compatible (netX 50 register DPM_ARM_IO_MODE1.IN_CONTROL). Note: Power-on-reset states will not be lost when 'in_ctrl' is set to a value not 0. Note: Power-on-reset states can be used to read pullup/down configuration of HIF-IOs. However, be careful using reset sampled values of HIF data lines when SDRAM is connected: When Reset is done during SDRAM read access, SDRAM device will keep driving data bus. Pull-up/down values will be overdriven by that. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hif_pio_out0': 0xFF401488-->
          <name>hif_pio_out0</name>
          <description>HIF PIO Output State Configuration Register 0. All unused HIF signals can be used as PIOs. IOs will be driven to the programmed state if appropriate enable bit is set in hif_pio_oe0 register. PIO mode driving of HIF-IOs used in current HIF/EXT_BUS Memory Interface configuration is not possible. ----------------------- Note:    This register can be read or written by 8, 16 or 32 bit access. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>hif_d15</name>
              <bitRange>[15:15]</bitRange>
              <description>PIO output drive level of HIF_D15 signal. </description>
            </field>
            <field>
              <name>hif_d14</name>
              <bitRange>[14:14]</bitRange>
              <description>PIO output drive level of HIF_D14 signal. </description>
            </field>
            <field>
              <name>hif_d13</name>
              <bitRange>[13:13]</bitRange>
              <description>PIO output drive level of HIF_D13 signal. </description>
            </field>
            <field>
              <name>hif_d12</name>
              <bitRange>[12:12]</bitRange>
              <description>PIO output drive level of HIF_D12 signal. </description>
            </field>
            <field>
              <name>hif_d11</name>
              <bitRange>[11:11]</bitRange>
              <description>PIO output drive level of HIF_D11 signal. </description>
            </field>
            <field>
              <name>hif_d10</name>
              <bitRange>[10:10]</bitRange>
              <description>PIO output drive level of HIF_D10 signal. </description>
            </field>
            <field>
              <name>hif_d9</name>
              <bitRange>[9:9]</bitRange>
              <description>PIO output drive level of HIF_D9 signal. </description>
            </field>
            <field>
              <name>hif_d8</name>
              <bitRange>[8:8]</bitRange>
              <description>PIO output drive level of HIF_D8 signal. </description>
            </field>
            <field>
              <name>hif_d7</name>
              <bitRange>[7:7]</bitRange>
              <description>PIO output drive level of HIF_D7 signal. </description>
            </field>
            <field>
              <name>hif_d6</name>
              <bitRange>[6:6]</bitRange>
              <description>PIO output drive level of HIF_D6 signal. </description>
            </field>
            <field>
              <name>hif_d5</name>
              <bitRange>[5:5]</bitRange>
              <description>PIO output drive level of HIF_D5 signal. </description>
            </field>
            <field>
              <name>hif_d4</name>
              <bitRange>[4:4]</bitRange>
              <description>PIO output drive level of HIF_D4 signal. </description>
            </field>
            <field>
              <name>hif_d3</name>
              <bitRange>[3:3]</bitRange>
              <description>PIO output drive level of HIF_D3 signal. </description>
            </field>
            <field>
              <name>hif_d2</name>
              <bitRange>[2:2]</bitRange>
              <description>PIO output drive level of HIF_D2 signal. </description>
            </field>
            <field>
              <name>hif_d1</name>
              <bitRange>[1:1]</bitRange>
              <description>PIO output drive level of HIF_D1 signal. </description>
            </field>
            <field>
              <name>hif_d0</name>
              <bitRange>[0:0]</bitRange>
              <description>PIO output drive level of HIF_D0 signal. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hif_pio_out1': 0xFF40148C-->
          <name>hif_pio_out1</name>
          <description>HIF PIO Output State Configuration Register 1. All unused HIF signals can be used as PIOs. IOs will be driven to the programmed state if appropriate enable bit is set in hif_pio_oe1 register. PIO mode driving of HIF-IOs used in current HIF/EXT_BUS Memory Interface configuration is not possible. ----------------------- Note:    This register can be read or written by 8, 16 or 32 bit access. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFE03FFFF</resetMask>
          <fields>
            <field>
              <name>hif_sdclk</name>
              <bitRange>[31:31]</bitRange>
              <description>PIO output drive level of HIF_SDCLK signal. </description>
            </field>
            <field>
              <name>hif_dirq</name>
              <bitRange>[30:30]</bitRange>
              <description>PIO output drive level of HIF_DIRQ signal. </description>
            </field>
            <field>
              <name>hif_rdy</name>
              <bitRange>[29:29]</bitRange>
              <description>PIO output drive level of HIF_RDY signal. </description>
            </field>
            <field>
              <name>hif_csn</name>
              <bitRange>[28:28]</bitRange>
              <description>PIO output drive level of HIF_CSN signal. </description>
            </field>
            <field>
              <name>hif_wrn</name>
              <bitRange>[27:27]</bitRange>
              <description>PIO output drive level of HIF_WRN signal. </description>
            </field>
            <field>
              <name>hif_rdn</name>
              <bitRange>[26:26]</bitRange>
              <description>PIO output drive level of HIF_RDN signal. </description>
            </field>
            <field>
              <name>hif_bhen</name>
              <bitRange>[25:25]</bitRange>
              <description>PIO output drive level of HIF_BHEN signals. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[24:18]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>hif_a17</name>
              <bitRange>[17:17]</bitRange>
              <description>PIO output drive level of HIF_A17 signal. </description>
            </field>
            <field>
              <name>hif_a16</name>
              <bitRange>[16:16]</bitRange>
              <description>PIO output drive level of HIF_A16 signal. </description>
            </field>
            <field>
              <name>hif_a15</name>
              <bitRange>[15:15]</bitRange>
              <description>PIO output drive level of HIF_A15 signal. </description>
            </field>
            <field>
              <name>hif_a14</name>
              <bitRange>[14:14]</bitRange>
              <description>PIO output drive level of HIF_A14 signal. </description>
            </field>
            <field>
              <name>hif_a13</name>
              <bitRange>[13:13]</bitRange>
              <description>PIO output drive level of HIF_A13 signal. </description>
            </field>
            <field>
              <name>hif_a12</name>
              <bitRange>[12:12]</bitRange>
              <description>PIO output drive level of HIF_A12 signal. </description>
            </field>
            <field>
              <name>hif_a11</name>
              <bitRange>[11:11]</bitRange>
              <description>PIO output drive level of HIF_A11 signal. </description>
            </field>
            <field>
              <name>hif_a10</name>
              <bitRange>[10:10]</bitRange>
              <description>PIO output drive level of HIF_A10 signal. </description>
            </field>
            <field>
              <name>hif_a9</name>
              <bitRange>[9:9]</bitRange>
              <description>PIO output drive level of HIF_A9 signal. </description>
            </field>
            <field>
              <name>hif_a8</name>
              <bitRange>[8:8]</bitRange>
              <description>PIO output drive level of HIF_A8 signal. </description>
            </field>
            <field>
              <name>hif_a7</name>
              <bitRange>[7:7]</bitRange>
              <description>PIO output drive level of HIF_A7 signal. </description>
            </field>
            <field>
              <name>hif_a6</name>
              <bitRange>[6:6]</bitRange>
              <description>PIO output drive level of HIF_A6 signal. </description>
            </field>
            <field>
              <name>hif_a5</name>
              <bitRange>[5:5]</bitRange>
              <description>PIO output drive level of HIF_A5 signal. </description>
            </field>
            <field>
              <name>hif_a4</name>
              <bitRange>[4:4]</bitRange>
              <description>PIO output drive level of HIF_A4 signal. </description>
            </field>
            <field>
              <name>hif_a3</name>
              <bitRange>[3:3]</bitRange>
              <description>PIO output drive level of HIF_A3 signal. </description>
            </field>
            <field>
              <name>hif_a2</name>
              <bitRange>[2:2]</bitRange>
              <description>PIO output drive level of HIF_A2 signal. </description>
            </field>
            <field>
              <name>hif_a1</name>
              <bitRange>[1:1]</bitRange>
              <description>PIO output drive level of HIF_A1 signal. </description>
            </field>
            <field>
              <name>hif_a0</name>
              <bitRange>[0:0]</bitRange>
              <description>PIO output drive level of HIF_A0 signal. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hif_pio_oe0': 0xFF401490-->
          <name>hif_pio_oe0</name>
          <description>HIF PIO Output Enable Configuration Register 0. All unused HIF signals can be used as PIOs. IOs will be driven to the output state programmed in in hif_pio_out0 register. PIO mode driving of HIF-IOs used in current HIF/EXT_BUS Memory Interface configuration is not possible. ----------------------- Note:    This register can be read or written by 8, 16 or 32 bit access. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>hif_d15</name>
              <bitRange>[15:15]</bitRange>
              <description>PIO output enable of HIF_D15 signal. </description>
            </field>
            <field>
              <name>hif_d14</name>
              <bitRange>[14:14]</bitRange>
              <description>PIO output enable of HIF_D14 signal. </description>
            </field>
            <field>
              <name>hif_d13</name>
              <bitRange>[13:13]</bitRange>
              <description>PIO output enable of HIF_D13 signal. </description>
            </field>
            <field>
              <name>hif_d12</name>
              <bitRange>[12:12]</bitRange>
              <description>PIO output enable of HIF_D12 signal. </description>
            </field>
            <field>
              <name>hif_d11</name>
              <bitRange>[11:11]</bitRange>
              <description>PIO output enable of HIF_D11 signal. </description>
            </field>
            <field>
              <name>hif_d10</name>
              <bitRange>[10:10]</bitRange>
              <description>PIO output enable of HIF_D10 signal. </description>
            </field>
            <field>
              <name>hif_d9</name>
              <bitRange>[9:9]</bitRange>
              <description>PIO output enable of HIF_D9 signal. </description>
            </field>
            <field>
              <name>hif_d8</name>
              <bitRange>[8:8]</bitRange>
              <description>PIO output enable of HIF_D8 signal. </description>
            </field>
            <field>
              <name>hif_d7</name>
              <bitRange>[7:7]</bitRange>
              <description>PIO output enable of HIF_D7 signal. </description>
            </field>
            <field>
              <name>hif_d6</name>
              <bitRange>[6:6]</bitRange>
              <description>PIO output enable of HIF_D6 signal. </description>
            </field>
            <field>
              <name>hif_d5</name>
              <bitRange>[5:5]</bitRange>
              <description>PIO output enable of HIF_D5 signal. </description>
            </field>
            <field>
              <name>hif_d4</name>
              <bitRange>[4:4]</bitRange>
              <description>PIO output enable of HIF_D4 signal. </description>
            </field>
            <field>
              <name>hif_d3</name>
              <bitRange>[3:3]</bitRange>
              <description>PIO output enable of HIF_D3 signal. </description>
            </field>
            <field>
              <name>hif_d2</name>
              <bitRange>[2:2]</bitRange>
              <description>PIO output enable of HIF_D2 signal. </description>
            </field>
            <field>
              <name>hif_d1</name>
              <bitRange>[1:1]</bitRange>
              <description>PIO output enable of HIF_D1 signal. </description>
            </field>
            <field>
              <name>hif_d0</name>
              <bitRange>[0:0]</bitRange>
              <description>PIO output enable of HIF_D0 signal. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hif_pio_oe1': 0xFF401494-->
          <name>hif_pio_oe1</name>
          <description>HIF PIO Output Enable Configuration Register 1. All unused HIF signals can be used as PIOs. IOs will be driven to the output state programmed in in hif_pio_out1 register. PIO mode driving of HIF-IOs used in current HIF/EXT_BUS Memory Interface configuration is not possible. ----------------------- Note:    This register can be read or written by 8, 16 or 32 bit access. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFE03FFFF</resetMask>
          <fields>
            <field>
              <name>hif_sdclk</name>
              <bitRange>[31:31]</bitRange>
              <description>PIO output enable of HIF_SDCLK signal. </description>
            </field>
            <field>
              <name>hif_dirq</name>
              <bitRange>[30:30]</bitRange>
              <description>PIO output enable of HIF_DIRQ signal. </description>
            </field>
            <field>
              <name>hif_rdy</name>
              <bitRange>[29:29]</bitRange>
              <description>PIO output enable of HIF_RDY signal. </description>
            </field>
            <field>
              <name>hif_csn</name>
              <bitRange>[28:28]</bitRange>
              <description>PIO output enable of HIF_CSN signal. </description>
            </field>
            <field>
              <name>hif_wrn</name>
              <bitRange>[27:27]</bitRange>
              <description>PIO output enable of HIF_WRN signal. </description>
            </field>
            <field>
              <name>hif_rdn</name>
              <bitRange>[26:26]</bitRange>
              <description>PIO output enable of HIF_RDN signal. </description>
            </field>
            <field>
              <name>hif_bhen</name>
              <bitRange>[25:25]</bitRange>
              <description>PIO output enable of HIF_BHEN signals. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[24:18]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>hif_a17</name>
              <bitRange>[17:17]</bitRange>
              <description>PIO output enable of HIF_A17 signal. </description>
            </field>
            <field>
              <name>hif_a16</name>
              <bitRange>[16:16]</bitRange>
              <description>PIO output enable of HIF_A16 signal. </description>
            </field>
            <field>
              <name>hif_a15</name>
              <bitRange>[15:15]</bitRange>
              <description>PIO output enable of HIF_A15 signal. </description>
            </field>
            <field>
              <name>hif_a14</name>
              <bitRange>[14:14]</bitRange>
              <description>PIO output enable of HIF_A14 signal. </description>
            </field>
            <field>
              <name>hif_a13</name>
              <bitRange>[13:13]</bitRange>
              <description>PIO output enable of HIF_A13 signal. </description>
            </field>
            <field>
              <name>hif_a12</name>
              <bitRange>[12:12]</bitRange>
              <description>PIO output enable of HIF_A12 signal. </description>
            </field>
            <field>
              <name>hif_a11</name>
              <bitRange>[11:11]</bitRange>
              <description>PIO output enable of HIF_A11 signal. </description>
            </field>
            <field>
              <name>hif_a10</name>
              <bitRange>[10:10]</bitRange>
              <description>PIO output enable of HIF_A10 signal. </description>
            </field>
            <field>
              <name>hif_a9</name>
              <bitRange>[9:9]</bitRange>
              <description>PIO output enable of HIF_A9 signal. </description>
            </field>
            <field>
              <name>hif_a8</name>
              <bitRange>[8:8]</bitRange>
              <description>PIO output enable of HIF_A8 signal. </description>
            </field>
            <field>
              <name>hif_a7</name>
              <bitRange>[7:7]</bitRange>
              <description>PIO output enable of HIF_A7 signal. </description>
            </field>
            <field>
              <name>hif_a6</name>
              <bitRange>[6:6]</bitRange>
              <description>PIO output enable of HIF_A6 signal. </description>
            </field>
            <field>
              <name>hif_a5</name>
              <bitRange>[5:5]</bitRange>
              <description>PIO output enable of HIF_A5 signal. </description>
            </field>
            <field>
              <name>hif_a4</name>
              <bitRange>[4:4]</bitRange>
              <description>PIO output enable of HIF_A4 signal. </description>
            </field>
            <field>
              <name>hif_a3</name>
              <bitRange>[3:3]</bitRange>
              <description>PIO output enable of HIF_A3 signal. </description>
            </field>
            <field>
              <name>hif_a2</name>
              <bitRange>[2:2]</bitRange>
              <description>PIO output enable of HIF_A2 signal. </description>
            </field>
            <field>
              <name>hif_a1</name>
              <bitRange>[1:1]</bitRange>
              <description>PIO output enable of HIF_A1 signal. </description>
            </field>
            <field>
              <name>hif_a0</name>
              <bitRange>[0:0]</bitRange>
              <description>PIO output enable of HIF_A0 signal. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hif_pio_in0': 0xFF401498-->
          <name>hif_pio_in0</name>
          <description>HIF PIO Input State Register 0. IO input states can be read here regardless whether IO is used in current HIF/EXT_BUS Memory Interface configuration. HIF IO sampling behaviour can be programmed by 'in_ctrl' bits of 'hif_pio_cfg' register. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000018</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>hif_d15</name>
              <bitRange>[15:15]</bitRange>
              <description>PIO input state of HIF_D15 signal. </description>
            </field>
            <field>
              <name>hif_d14</name>
              <bitRange>[14:14]</bitRange>
              <description>PIO input state of HIF_D14 signal. </description>
            </field>
            <field>
              <name>hif_d13</name>
              <bitRange>[13:13]</bitRange>
              <description>PIO input state of HIF_D13 signal. </description>
            </field>
            <field>
              <name>hif_d12</name>
              <bitRange>[12:12]</bitRange>
              <description>PIO input state of HIF_D12 signal. </description>
            </field>
            <field>
              <name>hif_d11</name>
              <bitRange>[11:11]</bitRange>
              <description>PIO input state of HIF_D11 signal. </description>
            </field>
            <field>
              <name>hif_d10</name>
              <bitRange>[10:10]</bitRange>
              <description>PIO input state of HIF_D10 signal. </description>
            </field>
            <field>
              <name>hif_d9</name>
              <bitRange>[9:9]</bitRange>
              <description>PIO input state of HIF_D9 signal. </description>
            </field>
            <field>
              <name>hif_d8</name>
              <bitRange>[8:8]</bitRange>
              <description>PIO input state of HIF_D8 signal. </description>
            </field>
            <field>
              <name>hif_d7</name>
              <bitRange>[7:7]</bitRange>
              <description>PIO input state of HIF_D7 signal. </description>
            </field>
            <field>
              <name>hif_d6</name>
              <bitRange>[6:6]</bitRange>
              <description>PIO input state of HIF_D6 signal. </description>
            </field>
            <field>
              <name>hif_d5</name>
              <bitRange>[5:5]</bitRange>
              <description>PIO input state of HIF_D5 signal. </description>
            </field>
            <field>
              <name>hif_d4</name>
              <bitRange>[4:4]</bitRange>
              <description>PIO input state of HIF_D4 signal. </description>
            </field>
            <field>
              <name>hif_d3</name>
              <bitRange>[3:3]</bitRange>
              <description>PIO input state of HIF_D3 signal. </description>
            </field>
            <field>
              <name>hif_d2</name>
              <bitRange>[2:2]</bitRange>
              <description>PIO input state of HIF_D2 signal. </description>
            </field>
            <field>
              <name>hif_d1</name>
              <bitRange>[1:1]</bitRange>
              <description>PIO input state of HIF_D1 signal. </description>
            </field>
            <field>
              <name>hif_d0</name>
              <bitRange>[0:0]</bitRange>
              <description>PIO input state of HIF_D0 signal. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hif_pio_in1': 0xFF40149C-->
          <name>hif_pio_in1</name>
          <description>HIF PIO Input State Register 1. IO input states can be read here regardless whether IO is used in current HIF/EXT_BUS Memory Interface configuration. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000001C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFE03FFFF</resetMask>
          <fields>
            <field>
              <name>hif_sdclk</name>
              <bitRange>[31:31]</bitRange>
              <description>PIO input state of HIF_SDCLK signal. </description>
            </field>
            <field>
              <name>hif_dirq</name>
              <bitRange>[30:30]</bitRange>
              <description>PIO input state of HIF_DIRQ signal. </description>
            </field>
            <field>
              <name>hif_rdy</name>
              <bitRange>[29:29]</bitRange>
              <description>PIO input state of HIF_RDY signal. </description>
            </field>
            <field>
              <name>hif_csn</name>
              <bitRange>[28:28]</bitRange>
              <description>PIO input state of HIF_CSN signal. </description>
            </field>
            <field>
              <name>hif_wrn</name>
              <bitRange>[27:27]</bitRange>
              <description>PIO input state of HIF_WRN signal. </description>
            </field>
            <field>
              <name>hif_rdn</name>
              <bitRange>[26:26]</bitRange>
              <description>PIO input state of HIF_RDN signal. </description>
            </field>
            <field>
              <name>hif_bhen</name>
              <bitRange>[25:25]</bitRange>
              <description>PIO input state of HIF_BHEN signal. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[24:18]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>hif_a17</name>
              <bitRange>[17:17]</bitRange>
              <description>PIO input state of HIF_A17 signal </description>
            </field>
            <field>
              <name>hif_a16</name>
              <bitRange>[16:16]</bitRange>
              <description>PIO input state of HIF_A16 signal </description>
            </field>
            <field>
              <name>hif_a15</name>
              <bitRange>[15:15]</bitRange>
              <description>PIO input state of HIF_A15 signal. </description>
            </field>
            <field>
              <name>hif_a14</name>
              <bitRange>[14:14]</bitRange>
              <description>PIO input state of HIF_A14 signal. </description>
            </field>
            <field>
              <name>hif_a13</name>
              <bitRange>[13:13]</bitRange>
              <description>PIO input state of HIF_A13 signal. </description>
            </field>
            <field>
              <name>hif_a12</name>
              <bitRange>[12:12]</bitRange>
              <description>PIO input state of HIF_A12 signal. </description>
            </field>
            <field>
              <name>hif_a11</name>
              <bitRange>[11:11]</bitRange>
              <description>PIO input state of HIF_A11 signal. </description>
            </field>
            <field>
              <name>hif_a10</name>
              <bitRange>[10:10]</bitRange>
              <description>PIO input state of HIF_A10 signal. </description>
            </field>
            <field>
              <name>hif_a9</name>
              <bitRange>[9:9]</bitRange>
              <description>PIO input state of HIF_A9 signal. </description>
            </field>
            <field>
              <name>hif_a8</name>
              <bitRange>[8:8]</bitRange>
              <description>PIO input state of HIF_A8 signal. </description>
            </field>
            <field>
              <name>hif_a7</name>
              <bitRange>[7:7]</bitRange>
              <description>PIO input state of HIF_A7 signal. </description>
            </field>
            <field>
              <name>hif_a6</name>
              <bitRange>[6:6]</bitRange>
              <description>PIO input state of HIF_A6 signal. </description>
            </field>
            <field>
              <name>hif_a5</name>
              <bitRange>[5:5]</bitRange>
              <description>PIO input state of HIF_A5 signal. </description>
            </field>
            <field>
              <name>hif_a4</name>
              <bitRange>[4:4]</bitRange>
              <description>PIO input state of HIF_A4 signal. </description>
            </field>
            <field>
              <name>hif_a3</name>
              <bitRange>[3:3]</bitRange>
              <description>PIO input state of HIF_A3 signal. </description>
            </field>
            <field>
              <name>hif_a2</name>
              <bitRange>[2:2]</bitRange>
              <description>PIO input state of HIF_A2 signal. </description>
            </field>
            <field>
              <name>hif_a1</name>
              <bitRange>[1:1]</bitRange>
              <description>PIO input state of HIF_A1 signal. </description>
            </field>
            <field>
              <name>hif_a0</name>
              <bitRange>[0:0]</bitRange>
              <description>PIO input state of HIF_A0 signal. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hif_pio_irq_raw': 0xFF4014A4-->
          <name>hif_pio_irq_raw</name>
          <description>HIF PIO Raw (before masking) IRQ Status Register. If bit is set, the according interrupt is asserted. Interrupt status can be cleared by writing ones to this register. Each IRQ source can be assigned either to xPIC or to ARM (or to both) by the following registers. IRQ clearing has lower priority than IRQ set when done simultaneously. Note: Spikes up to 10ns will be suppressed by HIF PIO IRQ sample stages. Note: HIF PIO interrupt function can be configured in the hif_pio_cfg register. Note: HIF PIO IRQs are combined with DPM IRQs and Handshake-Cell (HANDSHACKE_CTRL) IRQs. Note: The bits of this register are reordered since netx51/52. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000024</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>irq_hif_dirq</name>
              <bitRange>[3:3]</bitRange>
              <description>HIF_DIRQ IRQ </description>
            </field>
            <field>
              <name>irq_hif_a17</name>
              <bitRange>[2:2]</bitRange>
              <description>HIF_A17 IRQ </description>
            </field>
            <field>
              <name>irq_hif_a16</name>
              <bitRange>[1:1]</bitRange>
              <description>HIF_A16 IRQ </description>
            </field>
            <field>
              <name>irq_hif_d12</name>
              <bitRange>[0:0]</bitRange>
              <description>HIF_D12 (DPM_SPI_DIRQ/SPM_DIRQ) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hif_pio_irq_arm_mask_set': 0xFF4014A8-->
          <name>hif_pio_irq_arm_mask_set</name>
          <description>HIF PIO Interrupt Mask Register for netX internal ARM. Write access with '1' sets interrupt mask bit (enables interrupt request for corresponding interrupt source). Write access with '0' does not influence this bit. Read access shows actual interrupt mask. If bit is set, the according interrupt will activate the IRQ for netX internal ARM. Interrupt status can be cleared by writing ones to the hif_pio_irq_raw register. To release IRQ for netX internal ARM without clearing interrupt in module, reset according mask bit to 0. Note: Spikes up to 10ns will be suppressed by HIF PIO IRQ sample stages. Note: HIF PIO interrupt function can be configured in the hif_pio_cfg register. Note: HIF PIO IRQs are combined with DPM IRQs and Handshake-Cell (HANDSHACKE_CTRL) IRQs. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000028</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>irq_hif_dirq</name>
              <bitRange>[3:3]</bitRange>
              <description>HIF_DIRQ IRQ </description>
            </field>
            <field>
              <name>irq_hif_a17</name>
              <bitRange>[2:2]</bitRange>
              <description>HIF_A17 IRQ </description>
            </field>
            <field>
              <name>irq_hif_a16</name>
              <bitRange>[1:1]</bitRange>
              <description>HIF_A16 IRQ </description>
            </field>
            <field>
              <name>irq_hif_d12</name>
              <bitRange>[0:0]</bitRange>
              <description>HIF_D12 (DPM_SPI_DIRQ/SPM_DIRQ) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hif_pio_irq_arm_mask_reset': 0xFF4014AC-->
          <name>hif_pio_irq_arm_mask_reset</name>
          <description>HIF PIO Interrupt Mask Reset Register for netX internal ARM. Write access with '1' resets interrupt mask bit (disables interrupt request for corresponding interrupt source). Write access with '0' does not influence this bit. Read access shows actual interrupt mask. If bit is set, the according interrupt will activate the IRQ for netX internal ARM if asserted. Interrupt status can be cleared by writing ones to the hif_pio_irq_raw register. To release IRQ for netX internal ARM without clearing interrupt in module, reset according mask bit to 0. Note: Spikes up to 10ns will be suppressed by HIF PIO IRQ sample stages. Note: HIF PIO interrupt function can be configured in the hif_pio_cfg register. Note: HIF PIO IRQs are combined with DPM IRQs and Handshake-Cell (HANDSHACKE_CTRL) IRQs. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000002C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>irq_hif_dirq</name>
              <bitRange>[3:3]</bitRange>
              <description>HIF_DIRQ IRQ </description>
            </field>
            <field>
              <name>irq_hif_a17</name>
              <bitRange>[2:2]</bitRange>
              <description>HIF_A17 IRQ </description>
            </field>
            <field>
              <name>irq_hif_a16</name>
              <bitRange>[1:1]</bitRange>
              <description>HIF_A16 IRQ </description>
            </field>
            <field>
              <name>irq_hif_d12</name>
              <bitRange>[0:0]</bitRange>
              <description>HIF_D12 (DPM_SPI_DIRQ/SPM_DIRQ) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hif_pio_irq_arm_masked': 0xFF4014B0-->
          <name>hif_pio_irq_arm_masked</name>
          <description>HIF PIO Masked Interrupt Status Register for netX internal ARM. If bit is set, if the according mask bit is set in hif_pio_irq_arm_mask-register and the according interrupt is asserted. IRQ for netX internal ARM signal is asserted if at least one bit is set here. Interrupt status can be cleared by writing ones to the hif_pio_irq_raw register. To release IRQ for netX internal ARM signal without clearing interrupt in module, reset according mask bit to 0. Note: Spikes up to 10ns will be suppressed by HIF PIO IRQ sample stages. Note: HIF PIO interrupt function can be configured in the hif_pio_cfg register. Note: HIF PIO IRQs are combined with DPM IRQs and Handshake-Cell (HANDSHACKE_CTRL) IRQs. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000030</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>irq_hif_dirq</name>
              <bitRange>[3:3]</bitRange>
              <description>HIF_DIRQ IRQ </description>
            </field>
            <field>
              <name>irq_hif_a17</name>
              <bitRange>[2:2]</bitRange>
              <description>HIF_A17 IRQ </description>
            </field>
            <field>
              <name>irq_hif_a16</name>
              <bitRange>[1:1]</bitRange>
              <description>HIF_A16 IRQ </description>
            </field>
            <field>
              <name>irq_hif_d12</name>
              <bitRange>[0:0]</bitRange>
              <description>HIF_D12 (DPM_SPI_DIRQ/SPM_DIRQ) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hif_pio_irq_xpic_mask_set': 0xFF4014B4-->
          <name>hif_pio_irq_xpic_mask_set</name>
          <description>HIF PIO Interrupt Mask Register for netX internal xPIC. Write access with '1' sets interrupt mask bit (enables interrupt request for corresponding interrupt source). Write access with '0' does not influence this bit. Read access shows actual interrupt mask. If bit is set, the according interrupt will activate the IRQ for netX internal xPIC. Interrupt status can be cleared by writing ones to the hif_pio_irq_raw register. To release IRQ for netX internal xPIC without clearing interrupt in module, reset according mask bit to 0. Note: Spikes up to 10ns will be suppressed by HIF PIO IRQ sample stages. Note: HIF PIO interrupt function can be configured in the hif_pio_cfg register. Note: HIF PIO IRQs are combined with DPM IRQs and Handshake-Cell (HANDSHACKE_CTRL) IRQs. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000034</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>irq_hif_dirq</name>
              <bitRange>[3:3]</bitRange>
              <description>HIF_DIRQ IRQ </description>
            </field>
            <field>
              <name>irq_hif_a17</name>
              <bitRange>[2:2]</bitRange>
              <description>HIF_A17 IRQ </description>
            </field>
            <field>
              <name>irq_hif_a16</name>
              <bitRange>[1:1]</bitRange>
              <description>HIF_A16 IRQ </description>
            </field>
            <field>
              <name>irq_hif_d12</name>
              <bitRange>[0:0]</bitRange>
              <description>HIF_D12 (DPM_SPI_DIRQ/SPM_DIRQ) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hif_pio_irq_xpic_mask_reset': 0xFF4014B8-->
          <name>hif_pio_irq_xpic_mask_reset</name>
          <description>HIF PIO Interrupt Mask Reset Register for netX internal xPIC. Write access with '1' resets interrupt mask bit (disables interrupt request for corresponding interrupt source). Write access with '0' does not influence this bit. Read access shows actual interrupt mask. If bit is set, the according interrupt will activate the IRQ for netX internal xPIC if asserted. Interrupt status can be cleared by writing ones to the hif_pio_irq_raw register. To release IRQ for netX internal xPIC without clearing interrupt in module, reset according mask bit to 0. Note: Spikes up to 10ns will be suppressed by HIF PIO IRQ sample stages. Note: HIF PIO interrupt function can be configured in the hif_pio_cfg register. Note: HIF PIO IRQs are combined with DPM IRQs and Handshake-Cell (HANDSHACKE_CTRL) IRQs. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000038</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>irq_hif_dirq</name>
              <bitRange>[3:3]</bitRange>
              <description>HIF_DIRQ IRQ </description>
            </field>
            <field>
              <name>irq_hif_a17</name>
              <bitRange>[2:2]</bitRange>
              <description>HIF_A17 IRQ </description>
            </field>
            <field>
              <name>irq_hif_a16</name>
              <bitRange>[1:1]</bitRange>
              <description>HIF_A16 IRQ </description>
            </field>
            <field>
              <name>irq_hif_d12</name>
              <bitRange>[0:0]</bitRange>
              <description>HIF_D12 (DPM_SPI_DIRQ/SPM_DIRQ) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hif_pio_irq_xpic_masked': 0xFF4014BC-->
          <name>hif_pio_irq_xpic_masked</name>
          <description>HIF PIO Masked Interrupt Status Register for netX internal xPIC. If bit is set, if the according mask bit is set in hif_pio_irq_xpic_mask-register and the according interrupt is asserted. IRQ for netX internal xPIC signal is asserted if at least one bit is set here. Interrupt status can be cleared by writing ones to the hif_pio_irq_raw register. To release IRQ for netX internal xPIC signal without clearing interrupt in module, reset according mask bit to 0. Note: Spikes up to 10ns will be suppressed by HIF PIO IRQ sample stages. Note: HIF PIO interrupt function can be configured in the hif_pio_cfg register. Note: HIF PIO IRQs are combined with DPM IRQs and Handshake-Cell (HANDSHACKE_CTRL) IRQs. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000003C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>irq_hif_dirq</name>
              <bitRange>[3:3]</bitRange>
              <description>HIF_DIRQ IRQ </description>
            </field>
            <field>
              <name>irq_hif_a17</name>
              <bitRange>[2:2]</bitRange>
              <description>HIF_A17 IRQ </description>
            </field>
            <field>
              <name>irq_hif_a16</name>
              <bitRange>[1:1]</bitRange>
              <description>HIF_A16 IRQ </description>
            </field>
            <field>
              <name>irq_hif_d12</name>
              <bitRange>[0:0]</bitRange>
              <description>HIF_D12 (DPM_SPI_DIRQ/SPM_DIRQ) </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>hif_asyncmem_ctrl</name>
      <description>hif_asyncmem_ctrl</description>
      <baseAddress>0xFF401500</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>64</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <!--Absolute address of 'extsram0_ctrl': 0xFF401500-->
          <name>extsram0_ctrl</name>
          <description>Control Register for external bus interface and wait-states for chip-select 0 area. External addresses always be byte addresses. For additional byte-enables/DQM signals view netX pinout documentation. For all wait state configuration 1 cycle is 1 netx system clock cycle, i.e. 10ns for netX running on 100MHz at normal operation. Note: Pause and data width configuration is compatible to netx500/100 and netx50. Note: This register can be protected by the register MODULE_FIREWALL_CTRL.firewall_cfg_hifmemctrl. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0303033F</resetValue>
          <resetMask>0xF303033F</resetMask>
          <fields>
            <field>
              <name>ready_en</name>
              <bitRange>[31:31]</bitRange>
              <description>Ready Signal Enable. 0: Access timing is only controlled by Wait-State and Pre/Post-Pause configuration above. 1: Use external ready input to stretch Wait-State phase. Wait-States and Pre/Post-Pauses will be done according to configuration above. However Wait-State phase can be extended by an external device by holding netX ready input inactive. Data access cycle is done after external device sets netX ready input to active state. Note: An external device must assert ready to inactive state while Wait-States phase is running (defined by ws in this register). Ready input sampling and latency takes 20ns. Hence ws must be set to a value greater than 2 for proper functionality using ready. The value must be increased if there is a ready setup time of the ready generating external device. Note: For detailed ready input configuration and handling view ext_rdy_cfg register description. </description>
            </field>
            <field>
              <name>static_cs</name>
              <bitRange>[30:30]</bitRange>
              <description>Static chip-select signal generation. 0: No static chip-select signal generation 1: Static chip-select signal generation enabled (e.g. for i80 displays). All chip-select signals will return to inactive (high) level when no access is performed by default (when this bit is not set). However some devices (e.g. some i80 displays) require subsequent access without chip-select becoming inactive in between. For that purpose 'static_cs' bit can be set. Chip-select will remain active once an access was performed to this chip-select address-area until an access targets another chip-select address-area. Hence, for proper i80 sequence, software must avoid that the current access sequence is interrupted by an access to another chip-select area (including SDRAM access of this memory interface), e.g. cause by interrupt execution, other masters or SDRAM refresh generation. To release chip-select to idle state, - access another chip-select area of this memory interface or - clear the 'static_cs' bit of this chip-select area or - disable this chip-select area (set 'dwidth' to '11'). Note: Clearing the 'static_cs'-bit while an access is running to this chip-select area will have no impact on the current access. However disabling the whole chip-select area while an access is running could lead to an invalid access. Note: This is a new feature since netx51/52. </description>
            </field>
            <field>
              <name>no_p_post_seq_rd</name>
              <bitRange>[29:29]</bitRange>
              <description>No Post-Pause insertion between sequential reads. 0: Post-Pause will be inserted after each read access. 1: Disable Post-Pause between sequential reads. Note: Default setting '0' is for netx100/50 compatibility only. Typically there is no need of Post-Pause insertion between sequential reads. A Post-Pause will always be inserted if the next access addresses another chip-select area, is a write access or is not predictable by the memory controller. </description>
            </field>
            <field>
              <name>no_p_pre_seq_rd</name>
              <bitRange>[28:28]</bitRange>
              <description>No Pre-Pause insertion between sequential reads. 0: Pre-Pause will be inserted after each read access. 1: Disable Pre-Pause between sequential reads. Note: default setting '0' is for netx100/50 compatibility only. Typically there is no need of Pre-Pause insertion between sequential reads. </description>
            </field>
            <field>
              <name>bf_align3</name>
              <bitRange>[27:26]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>dwidth</name>
              <bitRange>[25:24]</bitRange>
              <description>Data bus width of ExtMem0 area. 00 :  8bit memory device connected to this chip-select address area. 01 : 16bit memory device connected to this chip-select address area. 10 : reserved. 11 : memory is disabled, related chip-select signal can be used for other purpose (e.g. as PIO). Note: Chip-selects are disabled by default. However it could be possible that they are enabled during netX boot phase to search for boot device. View bootloader information for this. Note: When chip-select is disabled related netX IO can be used for other functions. View memory interface multiplex options or netX pinning for more information. Note: All access to disabled chip-select area will be ignored. No wait will be generated to requesting master. Read data will be unvalid. External MI signal states will not change. </description>
            </field>
            <field>
              <name>bf_align2</name>
              <bitRange>[23:18]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>p_post</name>
              <bitRange>[17:16]</bitRange>
              <description>Post-Pause (0 - 3 cycles) of ExtMem0 area. Additional wait-states to match memory device Output-Disable or Address-Hold times. If programmed value is not 0, this Post-Pause will be inserted at external access end after Wait-State phase and data access cycle. Address, chip-select and byte-enable signals will remain stable in this phase. but nRD-signal and nWR-signal will become inactive high. After write access netX memory controller will always insert at least 1 Post-Pause cycle to generate positive edge on nWR-signal. </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[15:10]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>p_pre</name>
              <bitRange>[9:8]</bitRange>
              <description>Pre-Pause (0 - 3 cycles) of ExtMem0 area. Additional wait-states to match memory device setup times. If programmed value is not 0, this Pre-Pause will be inserted at external access start before Wait-State phase is started. Address, chip-select and byte-enable signals will be stable in this phase. but nRD-signal and nWR-signal remains inactive high. Note: The Pre-Pause could be extended by 1 cycle under certain conditions by netX memory controller. E.g. this becomes necessary for some access sequences (e.g. write-after-read or chip-select area change) to avoid collisions on external data bus. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[7:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ws</name>
              <bitRange>[5:0]</bitRange>
              <description>Wait-States (0 - 63 cycles) of ExtMem0 area. During read access nRD-signal active low phase is ws+1. During write access nWR-signal active low phase is ws+1.. Address, chip-select and byte-enable signals remain stable in this phase. After ws wait-cycles have passed signals remain stable and final data-access cycle is done. To match memory device data access time tACC: program  WS=ceil(tACC/10ns)-1. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'extsram1_ctrl': 0xFF401504-->
          <name>extsram1_ctrl</name>
          <description>Control Register for external bus interface and wait-states for chip-select 1 area. For detailed register description view extsram0_ctrl register. Note: This register can be protected by the register MODULE_FIREWALL_CTRL.firewall_cfg_hifmemctrl. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0303033F</resetValue>
          <resetMask>0xF303033F</resetMask>
          <fields>
            <field>
              <name>ready_en</name>
              <bitRange>[31:31]</bitRange>
              <description>Ready Signal Enable. </description>
            </field>
            <field>
              <name>static_cs</name>
              <bitRange>[30:30]</bitRange>
              <description>Static chip-select signal generation. </description>
            </field>
            <field>
              <name>no_p_post_seq_rd</name>
              <bitRange>[29:29]</bitRange>
              <description>No Post-Pause insertion between sequential reads. </description>
            </field>
            <field>
              <name>no_p_pre_seq_rd</name>
              <bitRange>[28:28]</bitRange>
              <description>No Pre-Pause insertion between sequential reads. </description>
            </field>
            <field>
              <name>bf_align3</name>
              <bitRange>[27:26]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>dwidth</name>
              <bitRange>[25:24]</bitRange>
              <description>Data bus width of ExtMem1 area. Note: This chip-select is disabled by default and may be shared with other functions. View memory interface multiplex options for more information. </description>
            </field>
            <field>
              <name>bf_align2</name>
              <bitRange>[23:18]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>p_post</name>
              <bitRange>[17:16]</bitRange>
              <description>Post-Pause (0 - 3 cycles) of ExtMem1 area. </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[15:10]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>p_pre</name>
              <bitRange>[9:8]</bitRange>
              <description>Pre-Pause (0 - 3 cycles) of ExtMem1 area. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[7:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ws</name>
              <bitRange>[5:0]</bitRange>
              <description>Wait-States (0 - 63 cycles) of ExtMem1 area. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'extsram2_ctrl': 0xFF401508-->
          <name>extsram2_ctrl</name>
          <description>Control Register for external bus interface and wait-states for chip-select 2 area. For detailed register description view extsram0_ctrl register. Note: This register can be protected by the register MODULE_FIREWALL_CTRL.firewall_cfg_hifmemctrl. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0303033F</resetValue>
          <resetMask>0xF303033F</resetMask>
          <fields>
            <field>
              <name>ready_en</name>
              <bitRange>[31:31]</bitRange>
              <description>Ready Signal Enable. </description>
            </field>
            <field>
              <name>static_cs</name>
              <bitRange>[30:30]</bitRange>
              <description>Static chip-select signal generation. </description>
            </field>
            <field>
              <name>no_p_post_seq_rd</name>
              <bitRange>[29:29]</bitRange>
              <description>No Post-Pause insertion between sequential reads. </description>
            </field>
            <field>
              <name>no_p_pre_seq_rd</name>
              <bitRange>[28:28]</bitRange>
              <description>No Pre-Pause insertion between sequential reads. </description>
            </field>
            <field>
              <name>bf_align3</name>
              <bitRange>[27:26]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>dwidth</name>
              <bitRange>[25:24]</bitRange>
              <description>Data bus width of ExtMem2 area. Note: This chip-select is disabled by default and may be shared with other functions. View memory interface multiplex options for more information. </description>
            </field>
            <field>
              <name>bf_align2</name>
              <bitRange>[23:18]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>p_post</name>
              <bitRange>[17:16]</bitRange>
              <description>Post-Pause (0 - 3 cycles) of ExtMem2 area. </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[15:10]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>p_pre</name>
              <bitRange>[9:8]</bitRange>
              <description>Pre-Pause (0 - 3 cycles) of ExtMem2 area. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[7:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ws</name>
              <bitRange>[5:0]</bitRange>
              <description>Wait-States (0 - 63 cycles) of ExtMem2 area. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'extsram3_ctrl': 0xFF40150C-->
          <name>extsram3_ctrl</name>
          <description>Control Register for external bus interface and wait-states for ExtMem1 chip-select 3 area. For detailed register description view extsram0_ctrl register. Note: This register can be protected by the register MODULE_FIREWALL_CTRL.firewall_cfg_hifmemctrl. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0303033F</resetValue>
          <resetMask>0xF303033F</resetMask>
          <fields>
            <field>
              <name>ready_en</name>
              <bitRange>[31:31]</bitRange>
              <description>Ready Signal Enable. </description>
            </field>
            <field>
              <name>static_cs</name>
              <bitRange>[30:30]</bitRange>
              <description>Static chip-select signal generation. </description>
            </field>
            <field>
              <name>no_p_post_seq_rd</name>
              <bitRange>[29:29]</bitRange>
              <description>No Post-Pause insertion between sequential reads. </description>
            </field>
            <field>
              <name>no_p_pre_seq_rd</name>
              <bitRange>[28:28]</bitRange>
              <description>No Pre-Pause insertion between sequential reads. </description>
            </field>
            <field>
              <name>bf_align3</name>
              <bitRange>[27:26]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>dwidth</name>
              <bitRange>[25:24]</bitRange>
              <description>Data bus width of ExtMem3 area. Note: This chip-select is disabled by default and may be shared with other functions. View memory interface multiplex options for more information. </description>
            </field>
            <field>
              <name>bf_align2</name>
              <bitRange>[23:18]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>p_post</name>
              <bitRange>[17:16]</bitRange>
              <description>Post-Pause (0 - 3 cycles) of ExtMem3 area. </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[15:10]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>p_pre</name>
              <bitRange>[9:8]</bitRange>
              <description>Pre-Pause (0 - 3 cycles) of ExtMem3 area. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[7:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ws</name>
              <bitRange>[5:0]</bitRange>
              <description>Wait-States (0 - 63 cycles) of ExtMem3 area. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'ext_cs0_apm_ctrl': 0xFF401510-->
          <name>ext_cs0_apm_ctrl</name>
          <description>Asynchronous Page Mode (APM) Control Register for ExtMem0 chip-select area. Only ExtMem0 chip-select area supports fast Asynchronous-Page-Mode (APM) Access. Note: This register can be protected by the register MODULE_FIREWALL_CTRL.firewall_cfg_hifmemctrl. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000000F</resetValue>
          <resetMask>0x0000070F</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:11]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>apm_cfg</name>
              <bitRange>[10:8]</bitRange>
              <description>APM configuration. 000 : read bursts are disabled 001 :  1 D-word (4 byte) address boundary for APM 010 :  2 D-word (8 byte) address boundary for APM 011 :  4 D-word (16 byte) address boundary for APM 100 :  8 D-word (32 byte) address boundary for APM 101 : 16 D-word (64 byte) address boundary for APM 110 : 32 D-word (128 byte) address boundary for APM all other settings are reserved. APM burst length programming is related to system address boundaries. For correct programming device data width and page size must be considdered. Examples: 8 bit device providing 4 word page: Page size is 1 D-word. Hence program '000'. 16 bit device providing 8 word page: Page size is 4 D-word. Hence program '011'. 32 bit device providing 32 word page: Page size is 32 D-word. Hence program '110'. Note: When device page size exceeds 32 D-words (128 byte), set 'apm_cfg' bit field to '110'. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[7:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ws_apm</name>
              <bitRange>[3:0]</bitRange>
              <description>APM read burst wait-states (0 - 15 cycles). If APM is enabled by apm_cfg-bits, first read access is done with number of wait-states programmed in extsram0_ctrl register. Following read accesses to ExtMem0 chip-select area are done with wait-states programmed here until APM-accesses are terminated. If netX runs internal read bursts only netX address lines will change. chip-select and nRD signals will remain active low. APM accesses are terminated if chip-select of ExtMem0 address area becomes inactive, if write access is done between read accesses or if read access is leaving APM address boundary. Note: Chip-select remains active low after read even if no further access is currently requested by netX. Chip-select will become inactive, if access to another external chip-select area is requested or if external memory bus is shared with SDRAM and netX SDRAM controller performs access or refresh cycles. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'ext_rdy_cfg': 0xFF401520-->
          <name>ext_rdy_cfg</name>
          <description>External Memory Ready Control Register. Note: Timeout is generated if ready usage is enabled by the extsramX_ctrl registers and is not asserted to active state within 10us. Note: This register can be protected by the register MODULE_FIREWALL_CTRL.firewall_cfg_hifmemctrl. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0x00000931</resetMask>
          <fields>
            <field>
              <name>bf_align3</name>
              <bitRange>[31:12]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>rdy_to_dis</name>
              <bitRange>[11:11]</bitRange>
              <description>Ready Timeout Disable By default ready timeout is enabled. Timeout is generated if ready usage is enabled by the extsramX_ctrl registers and is not asserted to active state within 10us (1024 system clocks). If an external device requires even longer response time, ready timeout can be disabled by setting this bit. However be careful: If ready is not asserted anytime, netX system will stall. Escape from this can only be achieved by Hardware Reset (e.g. by system watchdog timeout). 0: Ready timeout is enabled. 1: Ready timeout is disabled. </description>
            </field>
            <field>
              <name>bf_align2</name>
              <bitRange>[10:9]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>rdy_to_irq_en</name>
              <bitRange>[8:8]</bitRange>
              <description>Ready Timeout IRQ Enable 0: No IRQ generation in case of ready timeout. 1: generate an IRQ in case of ready timeout. Note: Ready Timeout IRQ is part of netX System Status IRQ (view system_status register in area asic_ctrl and VIC registers) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[7:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>rdy_filter</name>
              <bitRange>[5:4]</bitRange>
              <description>Ready Input Filter. Ready input filtering is implemented to avoid false ready active detection especially if ready signal is not always driven and ready active state is realized by pull-up or down resistors. 00: Ready active state is detected after ready signal is sampled once in active state (no filtering). 01: Ready active state is detected after ready signal is consecutively sampled twice in active state. 10: Ready active state is detected after ready signal is consecutively sampled 3 times in active state. 11: Ready active state is detected after ready signal is consecutively sampled 4 times in active state. Note: If ready is sampled in inactive state, active state counting will restart at zero. Note: If ready input filering is enabled, access time will be increased at least by filter time (ready is sampled any 10ns). </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>rdy_act_level</name>
              <bitRange>[0:0]</bitRange>
              <description>Ready Active Level 0: Ready is active low / stall access while ready input is high. 1: Ready is active high / stall access while ready input is low. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'ext_rdy_status': 0xFF401524-->
          <name>ext_rdy_status</name>
          <description>External Memory Ready Status Register. Note: Timeout is generated if ready usage is enabled by the extsramX_ctrl registers and is not asserted to active state within 10us. Note: This register can be protected by the register MODULE_FIREWALL_CTRL.firewall_cfg_hifmemctrl. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000024</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xB7FFFFFF</resetMask>
          <fields>
            <field>
              <name>rdy_to_err</name>
              <bitRange>[31:31]</bitRange>
              <description>Ready Timeout Error. This bit is set if a ready timeout error is detected. The external address and chip-select will be logged then in the lower bits of this register. An IRQ/Abort will be generated if enabled by the ext_rdy_cfg register. Writing a '1' here will reset this bit and the IRQ. Note: If multiple timeouts are detected, the first timeout address and chip-select will be logged. Note: Ready Timeout IRQ is part of netX System Status IRQ (view system_status register in area asic_ctrl and VIC registers) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[30:30]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>rdy_to_err_cs</name>
              <bitRange>[29:28]</bitRange>
              <description>Ready timeout error chip-select logging. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[27:27]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>rdy_to_err_adr</name>
              <bitRange>[26:0]</bitRange>
              <description>Ready timeout error address logging. </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>hif_sdram_ctrl</name>
      <description>hif_sdram_ctrl</description>
      <baseAddress>0xFF401540</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>64</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <!--Absolute address of 'sdram_general_ctrl': 0xFF401540-->
          <name>sdram_general_ctrl</name>
          <description>Control Register for external SDRAM access. For initializing procedure netX SDRAM controller view description of 'ctrl_en' bit inside this register. Note: This register can be protected by the register MODULE_FIREWALL_CTRL.firewall_cfg_hifmemctrl. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x01000001</resetValue>
          <resetMask>0xC30F0733</resetMask>
          <fields>
            <field>
              <name>refresh_status</name>
              <bitRange>[31:31]</bitRange>
              <description>Refresh status flag. Refresh behaviour changed from netx100/500/50: SDRAM controller now has an additional high priority refresh mode (view refresh_mode bit description). There is no need to guarantee sufficient SDRAM refresh generation by checking this bit by software any longer (necessary for netx100/500/50 depending on application). It is only for information purpose for netX10 or later. This bit can be reset by writing '0' to it. Note: This bit is writable but can also be changed by hardware. </description>
            </field>
            <field>
              <name>sdram_ready</name>
              <bitRange>[30:30]</bitRange>
              <description>SDRAM ready. This bit is set to 1 if SDRAM is ready for access. If sdram_general_ctrl.ctrl_en == 0 or sdram_general_ctrl.sdram_pwdn == 0 sdram_ready will be low. It will be set to 1 after SDRAM has been initialized or after power down wake up. Note: This bit is a read only status flag. </description>
            </field>
            <field>
              <name>bf_align4</name>
              <bitRange>[29:26]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>refresh_mode</name>
              <bitRange>[25:24]</bitRange>
              <description>Refresh request generation mode. Refresh behaviour changed from netx100/500/50: SDRAM controller now has an additional high priority refresh mode. Refresh generation has lower priority than accesses on external memory interface normally. That means refreshes do not block data access. To avoid data loss under all conditions without checking critical situations by software a high priority refresh mode is implemented for netX10 and later: If there was too much traffic to SDRAM to run refreshes according to programmed refresh_mode the controller changes to high priority refresh mode automatically. In this mode the controller generates immediately as many refreshes as required to avoid imminent data loss. After that the controller falls back to low priority refresh generation automatically. In normal low priority refresh mode refreshes can be collected. That means single refreshes are not necessarily done in programmed average refresh interval (t_REFI in sdram_timing_ctrl register). However the controller ensures by hardware that t_REFI is kept as mean refresh interval for a certain number of subsequent refreshes. This number of refreshes that will be collected to a long term refresh sequence can be programmed in this bit field. The following refresh request generation mode can be programmed: 00 : fix interval: expect one refresh any programmed refresh period (sdram_timing_ctrl.t_REFI) 01 : collect up to 8 refreshes (default) 10 : collect up to 16 refreshes 11 : collect up to 2047 refreshes Note: Typically SDRAM devices do not require a fix refresh interval. Collecting more refreshes will lead to improved performance (as high priority refresh mode blocking normal access is entered more often when only few refreshes can be collected). Hence, it is recommended setting this bit field to '11' (collecting up to 2047 refreshes). Note: Entering high priority refresh mode typically occurs when SDRAM becomes system performance bottleneck. To detect this, a status bit (refresh_status) will be set when high priority refresh mode was entered. It can be used for debugging or system status information purpose. </description>
            </field>
            <field>
              <name>bf_align3</name>
              <bitRange>[23:20]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ctrl_en</name>
              <bitRange>[19:19]</bitRange>
              <description>Global SDRAM controller enable. Note: The sdram_timing_ctrl and the sdram_mr register can only be changed while this bit is 0. Initializing and enabling SDRAM should be done as follows: {  | A. Special attention must be done before enabling SDRAM after netX reset without power supply was disabled (e.g. pressing some kind of reset button). In this case a reset could be done while a SDRAM read burst was performed. As SDRAM clock will be disabled immediately in case of reset external SDRAM device will keep driving data-lines. To free data lines at least 10 SDRAM clock cycles must be performed. This should be done by enabling (extclk_en-bit set and ctrl_en-bit set) the controller and disabling again (ctrl_en-bit cleared) before really enabling SDRAM and before any other access to external memory devices sharing SDRAM data-lines (e.g. parallel flash devices). B. If SDRAM was already enabled: Disable SDRAM controller by setting the ctrl_en-bit to 0. Ensure that no netX system master is trying to access SDRAM address area. Otherwise related master will be stalled (no ready) until re-enabling SDRAM. 1. Configure the sdram_timing_ctrl register: All timing parameters of the t_* bit fields must be taken from SDRAM device data sheet. All other timing parameters like clock and sample phases are provided by Hilscher. 2. Configure the sdram_mr register: Typically only setting of correct CAS-Latency is required (CL2 or CL3 supported by netX SDRAM controller). CL2 provides better performance an should be preferred. Please read description of the sdram_mr register for further details. 3. Configure the sdram_general_ctrl (this) register and enable the controller by setting the 'ctrl_en' bit. The values for 'banks', 'rows' and 'columns' depend on the used SDRAM device and must be taken from the related data sheet. 4. Wait until 'sdram_ready' status bit is set before accessing SDRAM device. } ------------------------------------ After enable, the controller will run the following SDRAM initialisation procedure (100MHz, 1 cycle = 10ns). {                  |        |                 | command             cycles   time              comment NOP                 20050    200.5us           running sd_clk (if extclk_en), *cs low, cke high) PRECH ALL, NOP      1+15     10ns + 150ns 7x(AUTO REF, NOP)   7x(1+31) 7x(10ns + 310ns) AUTO REF, NOP       1+22     10ns + 220ns LOAD MREG, NOP      1+3      10ns + 30ns       with settings done by the sdram_mr registers ACTIVATE            1        10ns              first access if requested, sdram_ready will be set to 1 here } ------------------------------------ Attention: Accesses requested to SDRAM address area when the controller is not enabled or before SDRAM initialisation procedure was finished (before sdram_ready bit is 1) will be blocked (no ready). This could cause system freezing. Note: The external SDRAM clock will not run if the controller is disabled. </description>
            </field>
            <field>
              <name>extclk_en</name>
              <bitRange>[18:18]</bitRange>
              <description>external SDRAM clock enable 0 : SDRAM clock disabled  (default) 1 : SDRAM clock enabled Note: The external SDRAM clock will not run if the controller is disabled. </description>
            </field>
            <field>
              <name>sdram_pwdn</name>
              <bitRange>[17:17]</bitRange>
              <description>SDRAM power down If this bit is set, the controller will move SDRAM to power down self refresh mode (no data loss) and stop the external SDRAM clock. Return from power-down mode can be done by clearing this bit. </description>
            </field>
            <field>
              <name>dbus16</name>
              <bitRange>[16:16]</bitRange>
              <description>SDRAM data bus width 0 : SDRAM data bus is 8 bit wide  (default) 1 : SDRAM data bus is 16 bit wide </description>
            </field>
            <field>
              <name>bf_align2</name>
              <bitRange>[15:11]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>columns</name>
              <bitRange>[10:8]</bitRange>
              <description>Number of SDRAM device columns and address lines. 000 : 256 columns, address lines A0..A7 (default) 001 : 512 columns, address lines A0..A8 010 : 1k columns, address lines A0..A9 011 : 2k columns, address lines A0..A9,A11 100 : 4k columns, address lines A0..A9,A11,A12 All others: reserved </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[7:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>rows</name>
              <bitRange>[5:4]</bitRange>
              <description>Number of SDRAM device rows and address lines. 00 : 2k rows, address lines A0..A10 (default) 01 : 4k rows, address lines A0..A11 10 : 8k rows, address lines A0..A12 </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:2]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>banks</name>
              <bitRange>[1:0]</bitRange>
              <description>Number of SDRAM device banks and address lines. 00 : 2 banks, address (BA0) 01 : 4 banks, address lines (BA1, BA0)(default) All others: reserved </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'sdram_timing_ctrl': 0xFF401544-->
          <name>sdram_timing_ctrl</name>
          <description>Control Register for external SDRAM access. Changes can only be done, if the SDRAM controller is disabled (sdram_general_ctrl.ctrl_en == 0) to avoid configuration problems. Please view description of 'ctrl_en' bit inside sdram_general_ctrl register for initializing-procedure of netX SDRAM controller. Note: This register can be protected by the register MODULE_FIREWALL_CTRL.firewall_cfg_hifmemctrl. Note: For some registers the reset-value is a reserved value. I.e. these registers must be programmed to another value       than the reset-value at initialization (e.g. t_WR). The values with the remark '(default)' are the values which should       be applicable for all SDRAM devices. However it is strongly recommended to set the values best-fitting the connected device       as the default values typically lead to an immense performance penalty (e.g. t_RAS default is 10). </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0301F7F3</resetValue>
          <resetMask>0x1773F7F3</resetMask>
          <fields>
            <field>
              <name>bf_align5</name>
              <bitRange>[31:29]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>bypass_neg_delay</name>
              <bitRange>[28:28]</bitRange>
              <description>Bypass data sample clock phase shift. 0: use phase shifted (negative delayed) SDRAM loopback clock for data sampling. 1: bypass phase shift logic for SDRAM data sampling. Use SDRAM loopback clock for data sampling. Bypass must be used for system clock frequencies &lt;= 80MHz (rate_mull_add &lt;= 0xC0). If this bit is programmed with '0' by software but system clock frequency is below 80MHz, it will be changed to '1' to enable bypass automatically. When system frequency is changed to a rate more than 80MHz, the bit is released to '0' again. This allows entering netX power save mode entry and leave without reconfiguring this bit by software. However take care that no SDRAM access is running at the moment of system clock frequency change around the 80MHz border. Note: The bit will always remain '1' if it is programmed high. Note: This bit is writable but can also be changed by hardware. </description>
            </field>
            <field>
              <name>bf_align4</name>
              <bitRange>[27:27]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>data_sample_phase</name>
              <bitRange>[26:24]</bitRange>
              <description>Data sample clock phase shift. 0..5: adjustable phase-shift for data sampling SDRAM loopback clock (clk_sdloopback) depending on external capacitive load and SDRAM access time (t_AC). The phase can be shifted in 1.25ns steps. clk_sdloopback will internally rise (sample SDRAM read data) at the data_sample_phase+4th clk400 edge after rise of external MEM_SDCLK (including external capacitive load). For correct settings, the delays depending on external capacitive have to be respected. Data sampling has to be done at least 8ns after internal changes of SDRAM ctrl-signals (MEM_SD*-signals, driven by clk_memsig). </description>
            </field>
            <field>
              <name>bf_align3</name>
              <bitRange>[23:23]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>mem_sdclk_phase</name>
              <bitRange>[22:20]</bitRange>
              <description>MEM_SDCLK phase shift. 0..5: adjustable phase-shift for external SDRAM clock depending on external capacitive load on MEM_SDCLK-signal to match SDRAM signals setup times. The phase can be shifted in 1.25ns steps. MEM_SDCLK will internally rise at the mem_sdclk_phase+1st clk400 edge after internal changes of SDRAM signals (MEM_SD*-signals, MI address and data buses driven by clk_memsig) For correct settings delays depending on external capacitive load have to be respected. Note: The phase shift logic was optimized. Since netX90: - the mem_sdclk_ssneg-bit is obsolete. - phase shift now can be done by (0..5)*1.25ns + 1.25ns, previousely: (0..5)*1.25ns + 2.5ns </description>
            </field>
            <field>
              <name>bf_align2</name>
              <bitRange>[19:18]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>t_REFI</name>
              <bitRange>[17:16]</bitRange>
              <description>Average periodic refresh interval (3.90 us * 2^t_REFI 00 :   3.90 us 01 :   7.80 us (default) 10 :  15.60 us 11 :  31.20 us Note: Typically refresh of SDRAM devices is specified by a certain number of refreshes that must be performed within a certain time. E.g. 8192 refreshes for 64ms. Dividing the time by the number of refreshes leads to the average periodic refresh interval. E.g. 64ms/8192 = 7.8us. Please view also description of 'refresh_mode' of 'sdram_general_ctrl' register for details. </description>
            </field>
            <field>
              <name>t_RFC</name>
              <bitRange>[15:12]</bitRange>
              <description>REFRESH to next command time (clk = tRFC + 4) 0000 :  4 clks 0001 :  5 clks and so on 1111 :  19 clks (default) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[11:11]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>t_RAS</name>
              <bitRange>[10:8]</bitRange>
              <description>ACTIVE to PRECHARGE command time (clk = t_RAS + 3) 000 :  3 clks 001 :  4 clks and so on 111 : 10 clks (default) Note: If Active-to-Active-command-period (t_RC) exceeds t_RAS+t_RP, set t_RAS and t_RP in a way that the following condition is met: t_RAS+t_RP&gt;=t_RC. </description>
            </field>
            <field>
              <name>t_RP</name>
              <bitRange>[7:6]</bitRange>
              <description>Precharge command period time (PRECHARGE to next command) 00 : 1 clk 01 : 2 clks 10 : 3 clks (default) 11 : reserved Note: For Active-to-Active-command-period (t_RC) view note at t_RAS. </description>
            </field>
            <field>
              <name>t_WR</name>
              <bitRange>[5:4]</bitRange>
              <description>Write recovery time (last write data to PRECHARGE) 00 : 1 clk 01 : 2 clks 10 : 3 clks (default) 11 : reserved </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:2]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>t_RCD</name>
              <bitRange>[1:0]</bitRange>
              <description>ACTIVE to READ or WRITE time (RAS to CAS, clk = t_RCD) This value will be also taken as t_RRD (ACTIVE bank A to ACTIVE bank B time) 00 : 1 clk 01 : 2 clks 10 : 3 clks (default) 11 : reserved </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'sdram_mr': 0xFF401548-->
          <name>sdram_mr</name>
          <description>Mode Register for SDRAM device. Changes can only be done, if the SDRAM controller is disabled (sdram_general_ctrl.ctrl_en == 0) to avoid configuration problems. The SDRAM Mode Registers of the used SDRAM device will be set after enabling the SDRAM controller in the 200us SDRAM memory initialisation procedure. It is part of the SDRAM device and programmed by the LOAD MODE REGISTER command. For details of SDRAM Mode Register view datasheet of used SDRAM device. Please view description of 'ctrl_en' bit inside sdram_general_ctrl register for initializing-procedure of netX SDRAM controller. Note: This register can be protected by the register MODULE_FIREWALL_CTRL.firewall_cfg_hifmemctrl. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000033</resetValue>
          <resetMask>0x00003FFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:14]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>MR</name>
              <bitRange>[13:0]</bitRange>
              <description>SDRAM Mode Register. CAS latency bits are typically located in MR[6:4]. Only CL2 and CL3 are supported, not CL1; default is CL3 Burst Length in MR[2:0] is read only here. Burst length depends on data bus width programmed in sdram_general_ctrl.dbus16 register bit The netX10 controller supports only Burst Length 8 (default) for 8bit SDRAM interface and 4 for 16bit SDRAM interface. Note: SDRAM devices where burst length is not located in Mode Register bits MR[2:0] are not supported by netX SDRAM controller. However these devices are not common. Note: This bit is writable but can also be changed by hardware. </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>hifmem_priority_ctrl</name>
      <description>hifmem_priority_ctrl</description>
      <baseAddress>0xFF401580</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>64</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <!--Absolute address of 'extmem_prio_timslot_ctrl': 0xFF401580-->
          <name>extmem_prio_timslot_ctrl</name>
          <description> Memory interface master timeslot priority control register.  Note:  Any master can access in one timeslot ((ts_accessrate_mX*ts_length_mX)/64) + 1 times (i.e. at  maximum (ts_accessrate_mX)/64 bandwidth on external memory bus, ts_accessrate_mX is programmed  by extmem_prio_accesstime_ctrl-register).  Priority control will watch data accesses on external memory data bus (SDRAM and non SDRAM),  including pauses on non SDRAM-accesses, not including control commands to SDRAM.  Any master requesting more accesses will be forced to wait for the remaining timeslot. --------------------------------------------------------  Programmable timeslots are:     ts_length =  0 :             64 systen clock cycles (i.e  0.64us at 100MHz)     ts_length =  1 :            128 systen clock cycles (i.e  1.28us at 100MHz)     ts_length =  2 :            256 systen clock cycles (i.e  2.56us at 100MHz)     ts_length =  3 :            512 systen clock cycles (i.e  5.12us at 100MHz)     ts_length =  4 :           1024 systen clock cycles (i.e 10.24us at 100MHz)     ts_length =  5 :           2048 systen clock cycles (i.e 20.48us at 100MHz)     ts_length =  6 :           4096 systen clock cycles (i.e 40.96us at 100MHz)     ts_length =  7 :           8192 systen clock cycles (i.e 81.92us at 100MHz) --------------------------------------------------------  For netX90 only SDRAM accesses are regarded for timeslot priority, SRAM/FLASH accesses are not.  Note: This register can be protected by the register MODULE_FIREWALL_CTRL.firewall_cfg_hifmemctrl. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00077777</resetValue>
          <resetMask>0x00077777</resetMask>
          <fields>
            <field>
              <name>bf_align4</name>
              <bitRange>[31:19]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ts_length_shared_mi</name>
              <bitRange>[18:16]</bitRange>
              <description>0..7: the timeslot of hifmem-master 4 is on external memory interface 64*2^ts_length_shared_mi systen clock cycles </description>
            </field>
            <field>
              <name>bf_align3</name>
              <bitRange>[15:15]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ts_length_arm_app_i</name>
              <bitRange>[14:12]</bitRange>
              <description>0..7: the timeslot of hifmem-master 3 is on external memory interface 64*2^ts_length_arm_app_i systen clock cycles </description>
            </field>
            <field>
              <name>bf_align2</name>
              <bitRange>[11:11]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ts_length_arm_app_d</name>
              <bitRange>[10:8]</bitRange>
              <description>0..7: the timeslot of hifmem-master 2 is on external memory interface 64*2^ts_length_arm_app_d systen clock cycles </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[7:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ts_length_arm_com_i</name>
              <bitRange>[6:4]</bitRange>
              <description>0..7: the timeslot of hifmem-master 1 is on external memory interface 64*2^ts_length_arm_com_i systen clock cycles </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:3]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ts_length_arm_com_d</name>
              <bitRange>[2:0]</bitRange>
              <description>0..7: the timeslot of hifmem-master 0 is on external memory interface 64*2^ts_length_arm_com_d systen clock cycles </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'extmem_prio_accesstime_ctrl': 0xFF401584-->
          <name>extmem_prio_accesstime_ctrl</name>
          <description> Control Register for master channel accesses per timeslot on external meory interface.  For detailed priority controlling read note at extmem_prio_timslot_ctrl-register description. --------------------------------------------------------  For netX90 only SDRAM accesses are regarded for timeslot priority, SRAM/FLASH accesses are not.  Note: This register can be protected by the register MODULE_FIREWALL_CTRL.firewall_cfg_hifmemctrl. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3FFFFFFF</resetValue>
          <resetMask>0x3FFFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:30]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ts_accessrate_shared_mi</name>
              <bitRange>[29:24]</bitRange>
              <description>0..63: hifmem-master 4 is alowed to request ((ts_accessrate_shared_mi*ts_length_shared_mi)/64) + 1 accesses on external memory </description>
            </field>
            <field>
              <name>ts_accessrate_arm_app_i</name>
              <bitRange>[23:18]</bitRange>
              <description>0..63: hifmem-master 3 is alowed to request ((ts_accessrate_arm_app_i*ts_length_arm_app_i)/64) + 1 accesses on external memory </description>
            </field>
            <field>
              <name>ts_accessrate_arm_app_d</name>
              <bitRange>[17:12]</bitRange>
              <description>0..63: hifmem-master 2 is alowed to request ((ts_accessrate_arm_app_d*ts_length_arm_app_d)/64) + 1 accesses on external memory </description>
            </field>
            <field>
              <name>ts_accessrate_arm_com_i</name>
              <bitRange>[11:6]</bitRange>
              <description>0..63: hifmem-master 1 is alowed to request ((ts_accessrate_arm_com_i*ts_length_arm_com_i)/64) + 1 accesses on external memory </description>
            </field>
            <field>
              <name>ts_accessrate_arm_com_d</name>
              <bitRange>[5:0]</bitRange>
              <description>0..63: hifmem-master 0 is alowed to request ((ts_accessrate_arm_com_d*ts_length_arm_com_d)/64) + 1 accesses on external memory </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>sqi</name>
      <description>sqi</description>
      <baseAddress>0xFF401640</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>64</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>sqi</name>
        <value>24</value>
      </interrupt>
      <registers>
        <register>
          <!--Absolute address of 'sqi_cr0': 0xFF401640-->
          <name>sqi_cr0</name>
          <description>SQI control register 0 This register is compatible with the netX50 and netX10 SPI module, but some additional settings are possible. The SQI module   provides master function only. Slave settings are omitted. The SQI module does not support the compatible mode for netX100. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00080007</resetValue>
          <resetMask>0x08CFFFCF</resetMask>
          <fields>
            <field>
              <name>bf_align3</name>
              <bitRange>[31:28]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>filter_in</name>
              <bitRange>[27:27]</bitRange>
              <description>Input filtering Receive data is sampled every 10 ns (100 MHz system clock). If this bit is set, the stored receive value will be the result of a majority decision of the three sampling points around an sck clock edge (if two or more '1's have been sampled, a '1' will be stored. If this bit is not set, a '0' will be stored). Input filtering should be used for sck_muladd&lt;=0x200 (i.e. below 12.5 MHz). For higher frequencies, stable signal phases are too short for filtering. </description>
            </field>
            <field>
              <name>bf_align2</name>
              <bitRange>[26:24]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sio_cfg</name>
              <bitRange>[23:22]</bitRange>
              <description>SQI IO configuration Default: All additional SQI-IOs (SIO2+3) are in PIO input mode. Coding 00: only SIO2+3 are controllable as PIOs (2-bit SPI or standard Motorola SPI) 01: all SQI IOs are used for transfers (4-bit SPI/SQI) 10: reserved 11: all SQI IOs are controllable as PIOs </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[21:20]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sck_muladd</name>
              <bitRange>[19:8]</bitRange>
              <description>Serial clock rate multiply add value for sck generation sck-frequency: f_sck = (sck_muladd * 100)/4096 [MHz]. Programmed value of sck_muladd must be &lt;= 0x800. Default value 0x800 equals 50 MHz clock rate. Note: If sck_muladd is set to zero, transfer will freeze. Note: SQIROM (XiP) serial clock rate must be programmed in register 'sqi_sqirom_cfg'. </description>
            </field>
            <field>
              <name>sck_phase</name>
              <bitRange>[7:7]</bitRange>
              <description>Serial clock phase 1: Sample data at second clock edge, data is generated half a clock phase before sampling 0: Sample data at first clock edge, data is generated half a clock phase before sampling Note: sck_phase value equals bit 0 of SPI mode value (mode = (sck_pol, sck_phase)). </description>
            </field>
            <field>
              <name>sck_pol</name>
              <bitRange>[6:6]</bitRange>
              <description>Serial clock polarity 0: idle: clock is low, first edge is rising 1: idle: clock is high, first edge is falling Note: sck_pol value equals bit 1 of SPI mode value (mode = (sck_pol, sck_phase)). </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[5:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>datasize</name>
              <bitRange>[3:0]</bitRange>
              <description>Data size select for standard Motorola SPI mode This bit field is unused in 2-bit and 4-bit SPI modes (i.e. data size fixed to 8 bit). The actual transfer size is 'datasize' + 1 bit. {            | 0000...0010: reserved 0011:        4 bit 0100:        5 bit ... 0111:        8 bit ... 1111:        16 bit } </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'sqi_cr1': 0xFF401644-->
          <name>sqi_cr1</name>
          <description>SQI control register 1 This register is compatible with the netX50 and netX10 SPI module, but some additional settings are possible. The SQI module   provides master function only. Slave settings are omitted. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x08080000</resetValue>
          <resetMask>0x1F1F1F02</resetMask>
          <fields>
            <field>
              <name>bf_align4</name>
              <bitRange>[31:29]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>rx_fifo_clr</name>
              <bitRange>[28:28]</bitRange>
              <description>Receive FIFO clear Writing '1' to this bit will clear the receive FIFO. The hardware will automatically reset this bit. This bit is always '0' when read. </description>
            </field>
            <field>
              <name>rx_fifo_wm</name>
              <bitRange>[27:24]</bitRange>
              <description>Receive FIFO watermark for IRQ generation If the receive FIFO watermark IRQ is enabled (bit 'RXIM' is set in register 'sqi_irq_mask'), transfers will stop when the receive FIFO runs full. Transfers will continue after the receive data is read from the receive FIFO to avoid an overflow of the receive FIFO. If the receive FIFO watermark IRQ is disabled (bit 'RXIM' is not set in register 'sqi_irq_mask'), transfers will not stop when the receive FIFO runs full. This may cause an overflow of the receive FIFO. This is compatible with netX50 behavior and allows writing data in full-duplex mode without reading the receive FIFO. </description>
            </field>
            <field>
              <name>bf_align3</name>
              <bitRange>[23:21]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>tx_fifo_clr</name>
              <bitRange>[20:20]</bitRange>
              <description>Transmit FIFO clear Writing '1' to this bit will clear the transmit FIFO. The hardware will automatically reset this bit. This bit is always '0' when read. </description>
            </field>
            <field>
              <name>tx_fifo_wm</name>
              <bitRange>[19:16]</bitRange>
              <description>Transmit FIFO watermark for IRQ generation </description>
            </field>
            <field>
              <name>bf_align2</name>
              <bitRange>[15:13]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>spi_trans_ctrl</name>
              <bitRange>[12:12]</bitRange>
              <description>Transfer control for standard Motorola SPI (default: disabled) This bit is used only for standard Motorola SPI (bits 'mode' of register 'sqi_tcr') in full-duplex and half-duplex mode. If this bit is set, SPI transfers will be controlled by 'start_transfer' and 'transfer_size' of register 'sqi_tcr'. If this bit is not set (default), SPI transfers start immediately after transfer data has been written to TX FIFO (this is compatible with the SPI module). Settings of 'start_transfer' and 'transfer_size' of register 'sqi_tcr' then remain unaffected and will be ignored. If this bit is set and SPI is used in receive mode (full-duplex or half-duplex receive mode set by bit field 'duplex' in register 'sqi_tcr'), transfers will stop when the receive FIFO runs full. Transfers will continue after the receive data is read from the receive FIFO to avoid an overflow of the receive FIFO. </description>
            </field>
            <field>
              <name>fss_static</name>
              <bitRange>[11:11]</bitRange>
              <description>SQI static chip select 0: Chip select will be generated automatically at data frame begin/end according to fss and datasize. 1: Chip select will be set statically according to 'fss' bits (see below). If fss is set to static mode, fss must be toggled manually after each data frame in Motorola SPI mode when sck_phase is 0 for compatibility with the specification! Note: This bit is used only in standard Motorola SPI mode. For SQI modes, chip select is never generated automatically. </description>
            </field>
            <field>
              <name>fss</name>
              <bitRange>[10:8]</bitRange>
              <description>Frame slave select Up to 3 devices can be assigned directly. Up to 8 devices can be assigned if an external de-multiplexer is used. This signal is active low, i.e. the bits will be inverted before they are output to the SQI pins. </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[7:2]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sqi_en</name>
              <bitRange>[1:1]</bitRange>
              <description>SQI enable 0: Interface disabled 1: Interface enabled Note: If you select the SQIROM/XiP function by bit 'enable' of register 'sqi_sqirom_cfg' (see description of register 'sqi_sqirom_cfg'), the standard SQI/SPI function will not be available. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[0:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'sqi_dr': 0xFF401648-->
          <name>sqi_dr</name>
          <description>SQI data register (DR) Read access: Received data word is delivered from receive FIFO. Write access: Data word to be sent is written to send FIFO. Receive and transmit FIFO both have a depth of 16 words (standard SPI mode). The SQI mode combines both FIFOs, i.e. 64 bytes are   available. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>data</name>
              <bitRange>[31:0]</bitRange>
              <description>Transmit data The data must be right-aligned during writing. In Standard SPI mode only bits according to sqi_cr0.datasize are transferred. In SQI mode data must be written in full DWords (i.e. the software has to collect four bytes prior to writing). Unused bytes will not be transferred and may be padded at will (number of transferred bytes depends on sqi_tcr.transfer_size). Receive data will always be right-aligned; unused bits will be '0'. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'sqi_sr': 0xFF40164C-->
          <name>sqi_sr</name>
          <description>Read-only SQI status register Shows the current status of the SQI interface. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xDFDFE01F</resetMask>
          <fields>
            <field>
              <name>rx_fifo_err_undr</name>
              <bitRange>[31:31]</bitRange>
              <description>Receive FIFO underrun error has occurred, unexpected data has been read. To clear this status flag, clear RX FIFO (register 'sqi_cr1'). </description>
            </field>
            <field>
              <name>rx_fifo_err_ovfl</name>
              <bitRange>[30:30]</bitRange>
              <description>Receive FIFO overflow error occurred, data is lost. To clear this status flag, clear RX FIFO (register 'sqi_cr1'). </description>
            </field>
            <field>
              <name>bf_align2</name>
              <bitRange>[29:29]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>rx_fifo_level</name>
              <bitRange>[28:24]</bitRange>
              <description>Receive FIFO level (number of received words to be read from the FIFO). </description>
            </field>
            <field>
              <name>tx_fifo_err_undr</name>
              <bitRange>[23:23]</bitRange>
              <description>Transmit FIFO underrun error has occurred, unexpected data has been sent. To clear this status flag, clear TX FIFO (register 'sqi_cr1'). </description>
            </field>
            <field>
              <name>tx_fifo_err_ovfl</name>
              <bitRange>[22:22]</bitRange>
              <description>Transmit FIFO overflow error occurred, data is lost. To clear this status flag, clear TX FIFO (register 'sqi_cr1'). </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[21:21]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>tx_fifo_level</name>
              <bitRange>[20:16]</bitRange>
              <description>Transmit FIFO level (number of words to be transmitted are left in the FIFO). </description>
            </field>
            <field>
              <name>sqirom_disabled_err</name>
              <bitRange>[15:15]</bitRange>
              <description>Access to the disabled SQIROM area has occurred. To enable the SQIROM function, set bit 'enable' in register 'sqi_sqirom_cfg'. This bit can be used to determine why the IRQ 'sqirom_error' has occurred. Clearing this status flag is possible only by writing a '1' here. </description>
            </field>
            <field>
              <name>sqirom_write_err</name>
              <bitRange>[14:14]</bitRange>
              <description>Write access to the read-only SQIROM area has occurred. This bit can be used to determine why the IRQ 'sqirom_error' has occurred. Clearing this status flag is possible only by writing a '1' here. </description>
            </field>
            <field>
              <name>sqirom_timeout_err</name>
              <bitRange>[13:13]</bitRange>
              <description>Timeout during a read of the SQIROM area has occurred. A timeout results from a fix level of the netX serial clock IO. Check IO multiplexing configuration and make sure that the serial clock output is not externally clamped. This bit can be used to determine why the IRQ 'sqirom_error' has occurred. Clearing this status flag is possible only by writing a '1' here. The SQIROM function must be disabled and enabled again to reset module-internal state machines after this bit has been set (register 'sqirom_cfg', therefore reset and set again the 'enable' bit). </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[12:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>busy</name>
              <bitRange>[4:4]</bitRange>
              <description>Device is busy 1 if data is currently transmitted/received or the transmit FIFO is not empty. </description>
            </field>
            <field>
              <name>rx_fifo_full</name>
              <bitRange>[3:3]</bitRange>
              <description>Receive FIFO is full (1 if full). </description>
            </field>
            <field>
              <name>rx_fifo_not_empty</name>
              <bitRange>[2:2]</bitRange>
              <description>Receive FIFO is not empty (0 if empty). </description>
            </field>
            <field>
              <name>tx_fifo_not_full</name>
              <bitRange>[1:1]</bitRange>
              <description>Transmit FIFO is not full (0 if full). </description>
            </field>
            <field>
              <name>tx_fifo_empty</name>
              <bitRange>[0:0]</bitRange>
              <description>Transmit FIFO is empty (1 if empty). </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'sqi_tcr': 0xFF401650-->
          <name>sqi_tcr</name>
          <description>SQI transfer control This register must not be changed during a transfer (bit 'busy' of register 'sqi_sr' is '1') to avoid corrupted transfers causing   damage to the hardware. Module address offset 0x10 is reserved in the netX10/50 SPI module. Thus, no compatibility problems will result from using this   address for extended transfer control features. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1C000000</resetValue>
          <resetMask>0x3FE7FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:30]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ms_byte_first</name>
              <bitRange>[29:29]</bitRange>
              <description>Most significant byte first 2- and 4-bit mode: Writing '1' to this bit will use most significant byte first in DWords (big endian). Default is little endian In standard Motorola SPI mode this bit is ignored. </description>
            </field>
            <field>
              <name>ms_bit_first</name>
              <bitRange>[28:28]</bitRange>
              <description>Most significant bit first 2- and 4-bit mode: Writing '1' to this bit will transfer most significant bit first (default). In standard Motorola SPI mode this bit is ignored. </description>
            </field>
            <field>
              <name>duplex</name>
              <bitRange>[27:26]</bitRange>
              <description>Transfer type selection Default is '11' for standard SPI compatibility. 00: dummy Generates 'transfer_size' + 1 serial clock periods. No change of RX and TX FIFOs. Data lines (standard Motorola SPI mode: SPI_MOSI) are controlled by 'tx_oe' and 'tx_out'. 01: half-duplex receive Receives 'transfer_size' + 1 words. In 2-bit and 4-bit mode, TX-FIFO will be cleared and is not available during receive. In standard SPI mode, SPI_MOSI is controlled by 'tx_oe' and 'tx_out'. You need not fill the TX-FIFO with dummy TX-data to receive RX-data. TX FIFOs are not changed and always available. 10: half-duplex transmit Transmits 'transfer_size' + 1 words. In 2-bit and 4-bit mode, RX-FIFO will be cleared and is not available during transmit. In standard SPI mode, SPI_MISO input is ignored. RX-FIFO is available and remains unchanged. 11: full-duplex Standard Motorola SPI mode only, reserved in 2-bit and 4-bit modes. The full-duplex standard Motorola SPI mode always transmits and receives data. Transmit data is taken from TX-FIFO, receive data is stored in RX-FIFO. Note: If '11' is set in 2-bit or 4-bit mode, this is treated as 'receive' (like '01' setting). Note: In case of a FIFO error (overflow, underrun) before changing to '01' or '10', the FIFO error status bits in register 'sqi_sr' will not be cleared by half-duplex modes FIFO clearing. </description>
            </field>
            <field>
              <name>mode</name>
              <bitRange>[25:24]</bitRange>
              <description>SPI/SQI mode selection 00: Standard Motorola SPI mode. 01: 2-bit SPI mode 10: 4-bit SPI mode 11: reserved </description>
            </field>
            <field>
              <name>start_transfer</name>
              <bitRange>[23:23]</bitRange>
              <description>Transfer start signal Writing a '1' starts the transfer of transfer_size bytes or dummy cycles. The hardware will automatically reset this bit. This bit is always '0' when read. This bit is writable only after a transfer sequence is finished or if it has been terminated by a FIFO clear. Note: A transfer sequence is finished completely when 'busy' of register 'sqi_sr' is not set. Note: In standard Motorola SPI mode, this function can be controlled by bit 'spi_trans_ctrl' of register 'sqi_cr1' (for SPI module compatibility). </description>
            </field>
            <field>
              <name>tx_oe</name>
              <bitRange>[22:22]</bitRange>
              <description>Output driver enable in dummy or standard SPI receive-only mode Writing a '1' enables the output drivers of the data pins in the dummy mode. </description>
            </field>
            <field>
              <name>tx_out</name>
              <bitRange>[21:21]</bitRange>
              <description>Output level in dummy or standard SPI receive-only mode This bit selects the output level when the output driver is enabled in the dummy mode. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[20:19]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>transfer_size</name>
              <bitRange>[18:0]</bitRange>
              <description>Number of bytes within the current SQI transaction Program (number of bytes - 1) or (number of dummy clock cycles - 1). Example: {        | 0x00000: one byte/dummy cycle ... 0x7ffff: 512k bytes/dummy cycles } This bit field counts down during transfers with each transferred word/byte or dummy cycle. This bit field is writable only after a transfer sequence is finished or if it has been terminated by a FIFO clear. Hence, this bit is writable, but it can also be changed by hardware. A running transfer sequence can be terminated by clearing the FIFO (register 'sqi_cr1'). This may become necessary for terminating a read sequence. Example: A half-duplex write transfer of 128 kbytes has been programmed, but there is not enough write data. To terminate this write sequence, clear the TX FIFO. If an external transfer is running while the FIFO is being cleared, this transfer will be continued and finished with the last bit to be transferred. Note: A transfer sequence is finished completely when 'busy' of register 'sqi_sr' is not set. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'sqi_irq_mask': 0xFF401654-->
          <name>sqi_irq_mask</name>
          <description>SQI interrupt mask register: IRQ mask is an AND-mask: Only raw interrupts with mask bit set can generate a module IRQ to CPU.   For detailed IRQ behavior and function, see register 'sqi_irq_raw'. The functionality of this register is similar to that of the corresponding SPI register spi_imsc.   In contrast to this register, setting bits in spi_imsc also clears the corresponding raw interrupts. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000001FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:9]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sqirom_error</name>
              <bitRange>[8:8]</bitRange>
              <description>SQIROM error interrupt mask </description>
            </field>
            <field>
              <name>trans_end</name>
              <bitRange>[7:7]</bitRange>
              <description>Transfer end interrupt mask </description>
            </field>
            <field>
              <name>txeim</name>
              <bitRange>[6:6]</bitRange>
              <description>Transmit FIFO empty interrupt mask (for compatibility with netx100/500) </description>
            </field>
            <field>
              <name>rxfim</name>
              <bitRange>[5:5]</bitRange>
              <description>Receive FIFO full interrupt mask (for compatibility with netx100/500) </description>
            </field>
            <field>
              <name>rxneim</name>
              <bitRange>[4:4]</bitRange>
              <description>Receive FIFO not empty interrupt mask (for compatibility with netx100/500) </description>
            </field>
            <field>
              <name>TXIM</name>
              <bitRange>[3:3]</bitRange>
              <description>Transmit FIFO interrupt mask </description>
            </field>
            <field>
              <name>RXIM</name>
              <bitRange>[2:2]</bitRange>
              <description>Receive FIFO interrupt mask </description>
            </field>
            <field>
              <name>RTIM</name>
              <bitRange>[1:1]</bitRange>
              <description>Receive timeout interrupt mask </description>
            </field>
            <field>
              <name>RORIM</name>
              <bitRange>[0:0]</bitRange>
              <description>Receive FIFO overrun interrupt mask </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'sqi_irq_raw': 0xFF401658-->
          <name>sqi_irq_raw</name>
          <description>SQI interrupt state before masking register (raw interrupt). Writing a '1' to a bit clears this interrupt. IRQ flags can also be cleared by using 'sqi_irq_clear' for SPI module compatibility. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000018</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000008</resetValue>
          <resetMask>0x000001FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:9]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sqirom_error</name>
              <bitRange>[8:8]</bitRange>
              <description>Unmasked SQIROM error interrupt state 1: SQIROM access error detected. This IRQ will be set if an error occurs during an SQIROM access. For detailed information on the error, see SQIROM error bits in register 'sqi_sr'. For error handling, clear this IRQ bit and the bits of register 'sqi_sr'. 0: no SQIROM error detected. </description>
            </field>
            <field>
              <name>trans_end</name>
              <bitRange>[7:7]</bitRange>
              <description>Unmasked transfer end interrupt state (related to bit 'busy' of register 'sqi_sr') 1: transfer finished. Bit 'busy' of register 'sqi_sr' has become inactive. 0: transfer not finished. Bit 'busy' of register 'sqi_sr' is active. </description>
            </field>
            <field>
              <name>txeris</name>
              <bitRange>[6:6]</bitRange>
              <description>Unmasked transmit FIFO empty interrupt state (for compatibility with netx100/500) 1: transmit FIFO is empty 0: transmit FIFO is not empty </description>
            </field>
            <field>
              <name>rxfris</name>
              <bitRange>[5:5]</bitRange>
              <description>Unmasked receive FIFO full interrupt state (for compatibility with netx100/500) 1: receive FIFO is full 0: receive FIFO is not full </description>
            </field>
            <field>
              <name>rxneris</name>
              <bitRange>[4:4]</bitRange>
              <description>Unmasked receive FIFO not empty interrupt state (for compatibility with netx100/500) 1: receive FIFO is not empty 0: receive FIFO is empty </description>
            </field>
            <field>
              <name>TXRIS</name>
              <bitRange>[3:3]</bitRange>
              <description>Unmasked transmit FIFO interrupt state 1: transmit FIFO level is below sqi_cr1.tx_fifo_wm 0: transmit FIFO is equal or higher than sqi_cr1.tx_fifo_wm </description>
            </field>
            <field>
              <name>RXRIS</name>
              <bitRange>[2:2]</bitRange>
              <description>Unmasked receive FIFO interrupt state 1: receive FIFO is higher than sqi_cr1.rx_fifo_wm 0: receive FIFO is equal or below sqi_cr1.rx_fifo_wm Note: Before programming this IRQ, see description of bits 'spi_trans_ctrl' and 'rx_fifo_wm' of register 'sqi_cr1' for receive FIFO behavior. </description>
            </field>
            <field>
              <name>RTRIS</name>
              <bitRange>[1:1]</bitRange>
              <description>Unmasked receive timeout interrupt state Timeout period is 32 serial clock periods (depending on adr_sqi_cr0.sck_muladd). 1: receive FIFO is not empty and has not been read out during the timeout period 0: receive FIFO is empty or read during the last timeout period </description>
            </field>
            <field>
              <name>RORRIS</name>
              <bitRange>[0:0]</bitRange>
              <description>Unmasked receive FIFO overrun interrupt state 1: receive FIFO overrun error occurred 0: no receive FIFO overrun error occurred </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'sqi_irq_masked': 0xFF40165C-->
          <name>sqi_irq_masked</name>
          <description>SQI masked interrupt status register For detailed IRQ behavior and function, see register 'sqi_irq_raw'. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000001C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000001FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:9]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sqirom_error</name>
              <bitRange>[8:8]</bitRange>
              <description>Masked SQIROM error interrupt state </description>
            </field>
            <field>
              <name>trans_end</name>
              <bitRange>[7:7]</bitRange>
              <description>Masked transfer end interrupt state </description>
            </field>
            <field>
              <name>txemis</name>
              <bitRange>[6:6]</bitRange>
              <description>Masked transmit FIFO empty interrupt state (for compatibility with netx100/500) </description>
            </field>
            <field>
              <name>rxfmis</name>
              <bitRange>[5:5]</bitRange>
              <description>Masked receive FIFO full interrupt state (for compatibility with netx100/500) </description>
            </field>
            <field>
              <name>rxnemis</name>
              <bitRange>[4:4]</bitRange>
              <description>Masked receive FIFO not empty interrupt state (for compatibility with netx100/500) </description>
            </field>
            <field>
              <name>TXMIS</name>
              <bitRange>[3:3]</bitRange>
              <description>Masked transmit FIFO interrupt state </description>
            </field>
            <field>
              <name>RXMIS</name>
              <bitRange>[2:2]</bitRange>
              <description>Masked receive FIFO interrupt state </description>
            </field>
            <field>
              <name>RTMIS</name>
              <bitRange>[1:1]</bitRange>
              <description>Masked receive timeout interrupt state </description>
            </field>
            <field>
              <name>RORMIS</name>
              <bitRange>[0:0]</bitRange>
              <description>Masked receive FIFO overrun interrupt state </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'sqi_irq_clear': 0xFF401660-->
          <name>sqi_irq_clear</name>
          <description>SQI interrupt clear register (for compatibility with netX10/50 SPI module). This register is always '0' on read. IRQ flags can also be cleared by writing register 'sqi_irq_raw'. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000001FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:9]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sqirom_error</name>
              <bitRange>[8:8]</bitRange>
              <description>Clear SQIROM error interrupt </description>
            </field>
            <field>
              <name>trans_end</name>
              <bitRange>[7:7]</bitRange>
              <description>Clear transfer end interrupt </description>
            </field>
            <field>
              <name>txeic</name>
              <bitRange>[6:6]</bitRange>
              <description>Clear transmit FIFO empty interrupt (for compatibility with netx100/500) </description>
            </field>
            <field>
              <name>rxfic</name>
              <bitRange>[5:5]</bitRange>
              <description>Clear receive FIFO full interrupt (for compatibility with netx100/500) </description>
            </field>
            <field>
              <name>rxneic</name>
              <bitRange>[4:4]</bitRange>
              <description>Clear receive FIFO not empty interrupt (for compatibility with netx100/500) </description>
            </field>
            <field>
              <name>TXIC</name>
              <bitRange>[3:3]</bitRange>
              <description>Clear transmit FIFO interrupt </description>
            </field>
            <field>
              <name>RXIC</name>
              <bitRange>[2:2]</bitRange>
              <description>Clear receive FIFO interrupt </description>
            </field>
            <field>
              <name>RTIC</name>
              <bitRange>[1:1]</bitRange>
              <description>Clear receive timeout interrupt </description>
            </field>
            <field>
              <name>RORIC</name>
              <bitRange>[0:0]</bitRange>
              <description>Clear receive FIFO overrun interrupt </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'sqi_dmacr': 0xFF401664-->
          <name>sqi_dmacr</name>
          <description>SQI DMA control register This module generates normal transfer requests only (i.e. no last requests will be issued). In consequence,   you can use DMAC-controlled transfers only (no peripheral-controlled mode). </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000024</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:2]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>tx_dma_en</name>
              <bitRange>[1:1]</bitRange>
              <description>Enable DMA for SQI-transmit data A request will be generated if TX-FIFO is not full and sqi_cr1.sqi_en (module enable) is set. If at least 4 words are writable to the TX-FIFO, there will be a burst request to the DMAC. Set dmac_chctrl.DBSize = 1 (i.e. burst size: 4) in the DMAC module. If this bit is reset or the module is disabled, DMA request will also be reset. </description>
            </field>
            <field>
              <name>rx_dma_en</name>
              <bitRange>[0:0]</bitRange>
              <description>Enable DMA for SQI-receive data A request will be generated if RX-FIFO is not empty and sqi_cr1.sqi_en (module enable) is set. If the RX-FIFO contains at least 4 words, there will be a burst request to the DMAC. Set dmac_chctrl.SBSize = 1 (i.e. burst size: 4) in the DMAC module. If this bit is reset or the module is disabled, DMA request will also be reset. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'sqi_pio_out': 0xFF401668-->
          <name>sqi_pio_out</name>
          <description>SQI PIO output level control register Bits 'sio_cfg' of register 'sqi_cr0' control the IO PIO mode. Bit 'sqi_en' of register 'sqi_cr0' has to be set to drive the SQI IOs in the PIO mode. PIO input signal states are never filtered (bit 'filter_in' of register 'sqi_cr0'). </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000028</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000000E</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sio3</name>
              <bitRange>[7:7]</bitRange>
              <description>SIO3 output state </description>
            </field>
            <field>
              <name>sio2</name>
              <bitRange>[6:6]</bitRange>
              <description>SIO2 output state </description>
            </field>
            <field>
              <name>miso</name>
              <bitRange>[5:5]</bitRange>
              <description>MISO/SIO1 output state </description>
            </field>
            <field>
              <name>mosi</name>
              <bitRange>[4:4]</bitRange>
              <description>MOSI/SIO0 output state </description>
            </field>
            <field>
              <name>csn</name>
              <bitRange>[3:1]</bitRange>
              <description>Chip select/FSS output state {CS2, CS1, CS0} </description>
            </field>
            <field>
              <name>sclk</name>
              <bitRange>[0:0]</bitRange>
              <description>Serial SPI clock output state </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'sqi_pio_oe': 0xFF401670-->
          <name>sqi_pio_oe</name>
          <description>SQI PIO output enable control register Bits 'sio_cfg' of register 'sqi_cr0' control the IO PIO mode. Bit 'sqi_en' of register 'sqi_cr0' has to be set to drive the SQI IOs in the PIO mode. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000030</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sio3</name>
              <bitRange>[7:7]</bitRange>
              <description>SIO3 output enable </description>
            </field>
            <field>
              <name>sio2</name>
              <bitRange>[6:6]</bitRange>
              <description>SIO2 output enable </description>
            </field>
            <field>
              <name>miso</name>
              <bitRange>[5:5]</bitRange>
              <description>MISO/SIO1 output enable </description>
            </field>
            <field>
              <name>mosi</name>
              <bitRange>[4:4]</bitRange>
              <description>MOSI/SIO0 output enable </description>
            </field>
            <field>
              <name>csn</name>
              <bitRange>[3:1]</bitRange>
              <description>Chip select/FSS output enable {CS2, CS1, CS0} </description>
            </field>
            <field>
              <name>sclk</name>
              <bitRange>[0:0]</bitRange>
              <description>Serial SPI clock output enable </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'sqi_pio_in': 0xFF401674-->
          <name>sqi_pio_in</name>
          <description>SQI PIO input status register Bits 'sio_cfg' of register 'sqi_cr0' control the IO PIO mode. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000034</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sio3</name>
              <bitRange>[7:7]</bitRange>
              <description>SIO3 input state </description>
            </field>
            <field>
              <name>sio2</name>
              <bitRange>[6:6]</bitRange>
              <description>SIO2 input state </description>
            </field>
            <field>
              <name>miso</name>
              <bitRange>[5:5]</bitRange>
              <description>MISO/SIO1 input state </description>
            </field>
            <field>
              <name>mosi</name>
              <bitRange>[4:4]</bitRange>
              <description>MOSI/SIO0 input state </description>
            </field>
            <field>
              <name>csn</name>
              <bitRange>[3:1]</bitRange>
              <description>Chip select/FSS input state {CS2, CS1, CS0} </description>
            </field>
            <field>
              <name>sclk</name>
              <bitRange>[0:0]</bitRange>
              <description>Serial SPI clock input state </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'sqi_sqirom_cfg': 0xFF401678-->
          <name>sqi_sqirom_cfg</name>
          <description>SQIROM mode configuration This mode supports the 'eXecute in Place' (XiP) feature of SQI flash chips. This register serves to configure the position of command   byte and address nibbles as well as the number of address nibbles and dummy cycles. To support a wide range of frequencies for the   serial clock output, you can also change the clock divider. Notes: 1. Before enabling this mode, make sure that the SQI flash chip is in 4-bit command mode, otherwise the module is not able to fetch data   from the flash. 2. When enabled, the SQI module is completely blocked, i.e. other SQI or SPI transactions are not possible. 3. The chip select signal of the flash must be connected to sqi_cs0. 4. SQIROM transfers can be generated in SPI mode 0 or 3, which can be selected in register 'sqi_cr0'. DO NOT select mode 1 and 2   for SQIROM usage. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000038</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x02020004</resetValue>
          <resetMask>0xFF3FFF7F</resetMask>
          <fields>
            <field>
              <name>clk_div_val</name>
              <bitRange>[31:24]</bitRange>
              <description>clk400 will be divided by (clk_div_val+3) for sqirom_clk generation. Default setting '2' is 80 MHz. Maximum serial clock rate (programming '0') is 133 MHz. Serial clock period (t_sck) will be (clk_div_val+3) * 2.5 ns. Clock high and low phase will be generated symmetrically. </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[23:22]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>t_csh</name>
              <bitRange>[21:20]</bitRange>
              <description>Min. SQI chip select high (idle) time: (t_csh+1) * t_sck (according to clk_div_val). Programmable values are 0 to 3. Change this parameter if the SQI device used requires min. chip select high times exceeding 1 serial clock period. The data sheet of the SQI device used provides the required timing. Note: Serial clock will not toggle if the device is not selected. Hence, only chip select active timing has to be considered. </description>
            </field>
            <field>
              <name>dummy_cycles</name>
              <bitRange>[19:16]</bitRange>
              <description>Selects the number of dummy cycles before data will be sampled from the SQI chip. {     | 0000: 0 cycles 0001: 1 cycle 0010: 2 cycles (default) ... 1111: 15 cycles } </description>
            </field>
            <field>
              <name>cmd_byte</name>
              <bitRange>[15:8]</bitRange>
              <description>This byte is transferred to the SQI chip as the command sequence. Bit 'addr_before_cmd' controls the address command order. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[7:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>addr_bits</name>
              <bitRange>[6:4]</bitRange>
              <description>The number of address bits of the access address considered to generate the address for the SQI chip. This setting depends on the size of the SQI chip. {     | 000:  20 bits (1-MByte/8-MBit device) (default) 001:  21 bits (2-MByte/16-MBit device) 010:  22 bits (4-MByte/32-MBit device) 011:  23 bits (8-MByte/64-MBit device) 100:  24 bits (16-MByte/128-MBit device) 101:  25 bits (32-MByte/256-MBit device) 110:  26 bits (64-MByte/512-MBit device) 111:  reserved } </description>
            </field>
            <field>
              <name>addr_nibbles</name>
              <bitRange>[3:2]</bitRange>
              <description>The number of nibbles to be transferred as the address to the SQI chip. This setting depends on the command format of the SQI chip. Bit 'addr_before_cmd' controls the address command order. The most significant address bits will be transmitted in the first address nibble. The least significant address bits will be transmitted in the last address nibble. 00: 5 nibbles 01: 6 nibbles (default) 10: 7 nibbles 11: 8 nibbles </description>
            </field>
            <field>
              <name>addr_before_cmd</name>
              <bitRange>[1:1]</bitRange>
              <description>Address before command When set to '1', the address nibbles will be transferred before the command byte. Otherwise, the command will be transferred first (default). </description>
            </field>
            <field>
              <name>enable</name>
              <bitRange>[0:0]</bitRange>
              <description>Enables the SQIROM mode of the SQI module. The SQI chip needs to be initialized to accept 4-bit read-command before you activate the SQIROM mode. This bit is also used to switch between the SQIROM/XiP and the standard SQI/SPI function. If this bit is set, the standard SQI/SPI function is not available. The SQIROM/XiP function does not depend on the programmed value of bit 'sqi_en' of register 'sqi_cr1'. If the multiplex matrix provides the SQI function, it is available only in standard SQI/SPI, but not for SQIROM/XiP usage. The SQIROM/XiP function is provided only on dedicated SQI IOs, but not as a multiplex matrix function even if standard SQI/SPI is provided there. </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>uart</name>
      <description>uart</description>
      <baseAddress>0xFF401680</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>64</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>uart</name>
        <value>8</value>
      </interrupt>
      <registers>
        <register>
          <!--Absolute address of 'uartdr': 0xFF401680-->
          <name>uartdr</name>
          <description>data read or written from the interface </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000007FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:11]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>BE</name>
              <bitRange>[10:10]</bitRange>
              <description>Break Error, read only, mirrored from uartrsr, to handle in DMA-read-out data </description>
            </field>
            <field>
              <name>PE</name>
              <bitRange>[9:9]</bitRange>
              <description>Parity Error, read only, mirrored from uartrsr, to handle in DMA-read-out data </description>
            </field>
            <field>
              <name>FE</name>
              <bitRange>[8:8]</bitRange>
              <description>Framing Error, read only, mirrored from uartrsr, to handle in DMA-read-out data </description>
            </field>
            <field>
              <name>DATA</name>
              <bitRange>[7:0]</bitRange>
              <description>data read or written from the interface </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'uartrsr': 0xFF401684-->
          <name>uartrsr</name>
          <description>receive status register (read) / Error Clear Register (write) </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>OE</name>
              <bitRange>[3:3]</bitRange>
              <description>Overrun Error </description>
            </field>
            <field>
              <name>BE</name>
              <bitRange>[2:2]</bitRange>
              <description>Break Error </description>
            </field>
            <field>
              <name>PE</name>
              <bitRange>[1:1]</bitRange>
              <description>Parity Error </description>
            </field>
            <field>
              <name>FE</name>
              <bitRange>[0:0]</bitRange>
              <description>Framing Error </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'uartlcr_h': 0xFF401688-->
          <name>uartlcr_h</name>
          <description>Line control Register, high byte </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000007F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>WLEN</name>
              <bitRange>[6:5]</bitRange>
              <description>Word Length '00' 5 bits '01' 6 bits '10' 7 bits '11' 8 bits </description>
            </field>
            <field>
              <name>FEN</name>
              <bitRange>[4:4]</bitRange>
              <description>FIFO Enable </description>
            </field>
            <field>
              <name>STP2</name>
              <bitRange>[3:3]</bitRange>
              <description>2 Stop Bits Select </description>
            </field>
            <field>
              <name>EPS</name>
              <bitRange>[2:2]</bitRange>
              <description>Even Parity Select </description>
            </field>
            <field>
              <name>PEN</name>
              <bitRange>[1:1]</bitRange>
              <description>Parity Enalble </description>
            </field>
            <field>
              <name>BRK</name>
              <bitRange>[0:0]</bitRange>
              <description>Send Break </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'uartlcr_m': 0xFF40168C-->
          <name>uartlcr_m</name>
          <description>Line control Register, middle byte </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>BAUDDIVMS</name>
              <bitRange>[7:0]</bitRange>
              <description>bauddiv : Baud Divisor Most Significant Byte use higher byte of bauddiv = (system clk / (16 * baud rate)) - 1 if not alternative settings by register uartcr_2 are done </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'uartlcr_l': 0xFF401690-->
          <name>uartlcr_l</name>
          <description>Line control Register, low byte </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>BAUDDIVLS</name>
              <bitRange>[7:0]</bitRange>
              <description>Baud Divisor Least Significant Byte use lower byte of bauddiv = (system clk / (16 * baud rate)) - 1 if not alternative settings by register uartcr_2 are done </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'uartcr': 0xFF401694-->
          <name>uartcr</name>
          <description>uart control Register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000001FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:9]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>TX_RX_LOOP</name>
              <bitRange>[8:8]</bitRange>
              <description>internal loop (TX -&gt; RX) (test purpose only) </description>
            </field>
            <field>
              <name>LBE</name>
              <bitRange>[7:7]</bitRange>
              <description>Loop Back Enable for IrDA mode </description>
            </field>
            <field>
              <name>RTIE</name>
              <bitRange>[6:6]</bitRange>
              <description>Receive Timeout Interrupt Enable </description>
            </field>
            <field>
              <name>TIE</name>
              <bitRange>[5:5]</bitRange>
              <description>Transmit Interrupt Enable </description>
            </field>
            <field>
              <name>RIE</name>
              <bitRange>[4:4]</bitRange>
              <description>Receive Interrupt Enable </description>
            </field>
            <field>
              <name>MSIE</name>
              <bitRange>[3:3]</bitRange>
              <description>Modem Status Interrupt Enable </description>
            </field>
            <field>
              <name>SIRLP</name>
              <bitRange>[2:2]</bitRange>
              <description>IrDA SIR Low Power Mode </description>
            </field>
            <field>
              <name>SIREN</name>
              <bitRange>[1:1]</bitRange>
              <description>SIR Enable </description>
            </field>
            <field>
              <name>uartEN</name>
              <bitRange>[0:0]</bitRange>
              <description>uart Enable </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'uartfr': 0xFF401698-->
          <name>uartfr</name>
          <description>uart Flag Register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000018</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>TXFE</name>
              <bitRange>[7:7]</bitRange>
              <description>Transmit FIFO Empty </description>
            </field>
            <field>
              <name>RXFF</name>
              <bitRange>[6:6]</bitRange>
              <description>Receive FIFO Full </description>
            </field>
            <field>
              <name>TXFF</name>
              <bitRange>[5:5]</bitRange>
              <description>Transmit FIFO Full </description>
            </field>
            <field>
              <name>RXFE</name>
              <bitRange>[4:4]</bitRange>
              <description>Receive FIFO Empty </description>
            </field>
            <field>
              <name>BUSY</name>
              <bitRange>[3:3]</bitRange>
              <description>uart BUSY </description>
            </field>
            <field>
              <name>DCD</name>
              <bitRange>[2:2]</bitRange>
              <description>Data Carrier Detect </description>
            </field>
            <field>
              <name>DSR</name>
              <bitRange>[1:1]</bitRange>
              <description>Data Set Ready </description>
            </field>
            <field>
              <name>CTS</name>
              <bitRange>[0:0]</bitRange>
              <description>Clear To Send </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'uartiir': 0xFF40169C-->
          <name>uartiir</name>
          <description>Interrupt Identification (read) / interrupt clear (write) </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000001C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>RTIS</name>
              <bitRange>[3:3]</bitRange>
              <description>Receive Timeout Interrupt Status </description>
            </field>
            <field>
              <name>TIS</name>
              <bitRange>[2:2]</bitRange>
              <description>Transmit Interrupt Status </description>
            </field>
            <field>
              <name>RIS</name>
              <bitRange>[1:1]</bitRange>
              <description>Receive Interrupt Status </description>
            </field>
            <field>
              <name>MIS</name>
              <bitRange>[0:0]</bitRange>
              <description>Modem Interrupt Status </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'uartilpr': 0xFF4016A0-->
          <name>uartilpr</name>
          <description>IrDA Low Power Counter Register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ILPDVSR</name>
              <bitRange>[7:0]</bitRange>
              <description>IrDA Low Power Divisor </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'uartrts': 0xFF4016A4-->
          <name>uartrts</name>
          <description>RTS Control Register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000024</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>STICK</name>
              <bitRange>[7:7]</bitRange>
              <description>stick parity </description>
            </field>
            <field>
              <name>CTS_pol</name>
              <bitRange>[6:6]</bitRange>
              <description>nUARTCTS polarity: 1=active high </description>
            </field>
            <field>
              <name>CTS_ctr</name>
              <bitRange>[5:5]</bitRange>
              <description>nUARTCTS control </description>
            </field>
            <field>
              <name>RTS_pol</name>
              <bitRange>[4:4]</bitRange>
              <description>RTS polarity: 1=active high </description>
            </field>
            <field>
              <name>MOD2</name>
              <bitRange>[3:3]</bitRange>
              <description>mode1/mode2 </description>
            </field>
            <field>
              <name>COUNT</name>
              <bitRange>[2:2]</bitRange>
              <description>count base: 1=system clocks, 0=time in bauds </description>
            </field>
            <field>
              <name>RTS</name>
              <bitRange>[1:1]</bitRange>
              <description>if AUTO=0: controlled by this bit </description>
            </field>
            <field>
              <name>AUTO</name>
              <bitRange>[0:0]</bitRange>
              <description>automatic or controlled by the next bit (RTS) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'uartforerun': 0xFF4016A8-->
          <name>uartforerun</name>
          <description>RTS forerun cycles </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000028</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>FORERUN</name>
              <bitRange>[7:0]</bitRange>
              <description>number of forerun cycles in system clocks or bauds </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'uarttrail': 0xFF4016AC-->
          <name>uarttrail</name>
          <description>RTS trail cycles </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000002C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>TRAIL</name>
              <bitRange>[7:0]</bitRange>
              <description>number of trail cycles in system clocks or bauds </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'uartdrvout': 0xFF4016B0-->
          <name>uartdrvout</name>
          <description>Drive Output </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000030</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:2]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>DRVRTS</name>
              <bitRange>[1:1]</bitRange>
              <description>enable driver for RTS </description>
            </field>
            <field>
              <name>DRVTX</name>
              <bitRange>[0:0]</bitRange>
              <description>enable driver for TX </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'uartcr_2': 0xFF4016B4-->
          <name>uartcr_2</name>
          <description>Control Register 2 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000034</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:2]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>oversampling_8x</name>
              <bitRange>[1:1]</bitRange>
              <description>Oversampling mode: 0: Use default 16x oversampling. 1: Use reduced accuracy 8x oversampling. This can be used to increase the max. baudrate. When selected, the configured baudrate will be doubled. Note that the bit reception is more error-prone in noisy environments. </description>
            </field>
            <field>
              <name>Baud_Rate_Mode</name>
              <bitRange>[0:0]</bitRange>
              <description>If this bit is set the baud rate is generated more exactly by the following formula: value = ( (Baud Rate * 16) / System Frequency ) * 2^16  . You have to write this 16-bit value in register uartlcr_l and uartlcr_m. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'uartrxiflsel': 0xFF4016B8-->
          <name>uartrxiflsel</name>
          <description>RX FIFO trigger level and RX-DMA enable </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000038</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000008</resetValue>
          <resetMask>0x0000003F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>RXDMA</name>
              <bitRange>[5:5]</bitRange>
              <description>Enable DMA-requests for RX-fifo-data. A request will be generated if RX-FIFO is not empty and uartcr.uartEN (module enable) is set. Burst request to DMA-Ctrl will be done if the RX-FIFO contains at least 4 words (set DMA-burst-size to 4) If this bit is reset or the module is disabled, DMA-request will also be reset. single transfer request: RX-FIFO contains 1 byte or more, burst request: 4 bytes or more note: set adr_dmac_chctrl.SBSize = 1 (i.e. burst size: 4) in the DMA module </description>
            </field>
            <field>
              <name>RXIFLSEL</name>
              <bitRange>[4:0]</bitRange>
              <description>Choose a number between 1 and 16. It defines the IRQ trigger level of the receive fifo. The IRQ (UARTRXINTR) will be set if the number of received bytes in the receive fifo are greater than or equal RXIFLSEL. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'uarttxiflsel': 0xFF4016BC-->
          <name>uarttxiflsel</name>
          <description>TX FIFO trigger level and TX-DMA enable </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000003C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000008</resetValue>
          <resetMask>0x0000003F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>TXDMA</name>
              <bitRange>[5:5]</bitRange>
              <description>Enable DMA-requests for TX-fifo-data. A request will be generated if TX-FIFO is not full and uartcr.uartEN (module enable) is set. Burst request to DMA-Ctrl will be done if at least 4 words are writable to the TX-FIFO (set DMA-burst-size to 4) If this bit is reset or the module is disabled, DMA-request will also be reset. note: set adr_dmac_chctrl.DBSize = 1 (i.e. burst size: 4) in the DMA module </description>
            </field>
            <field>
              <name>TXIFLSEL</name>
              <bitRange>[4:0]</bitRange>
              <description>Choose a number between 1 and 16. It defines the IRQ trigger level of the transmit fifo. The IRQ (UARTTXINTR) will be set if the number of transmitted bytes in the transmit fifo are less than TXIFLSEL. </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>ahb_abort</name>
      <description>abort</description>
      <baseAddress>0xFF4016C0</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>16</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <!--Absolute address of 'abort_base': 0xFF4016C0-->
          <name>abort_base</name>
          <description>Start-address of abort generating address area. Area size: 16Bytes Abort (AHB: HRESP=ERROR) will be generated by access to this area. Write access will be ignored. Read access returns 0xdeadbeef. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'abort_end': 0xFF4016CC-->
          <name>abort_end</name>
          <description>End-address of abort generating address area. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>sample_at_porn_stat</name>
      <description>sample_at_porn_stat</description>
      <baseAddress>0xFF4016D0</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>16</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <!--Absolute address of 'sample_at_porn_stat_in0': 0xFF4016D0-->
          <name>sample_at_porn_stat_in0</name>
          <description>Status of inputs sampled at power-on-reset (PORn) register 0. This register shows the status of the inputs sampled at power-on-reset. It will not change on normal system reset. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>hif_a15</name>
              <bitRange>[31:31]</bitRange>
              <description>Input status of pin 'hif_a15' sampled at power-on-reset </description>
            </field>
            <field>
              <name>hif_a14</name>
              <bitRange>[30:30]</bitRange>
              <description>Input status of pin 'hif_a14' sampled at power-on-reset </description>
            </field>
            <field>
              <name>hif_a13</name>
              <bitRange>[29:29]</bitRange>
              <description>Input status of pin 'hif_a13' sampled at power-on-reset </description>
            </field>
            <field>
              <name>hif_a12</name>
              <bitRange>[28:28]</bitRange>
              <description>Input status of pin 'hif_a12' sampled at power-on-reset </description>
            </field>
            <field>
              <name>hif_a11</name>
              <bitRange>[27:27]</bitRange>
              <description>Input status of pin 'hif_a11' sampled at power-on-reset </description>
            </field>
            <field>
              <name>hif_a10</name>
              <bitRange>[26:26]</bitRange>
              <description>Input status of pin 'hif_a10' sampled at power-on-reset </description>
            </field>
            <field>
              <name>hif_a9</name>
              <bitRange>[25:25]</bitRange>
              <description>Input status of pin 'hif_a9' sampled at power-on-reset </description>
            </field>
            <field>
              <name>hif_a8</name>
              <bitRange>[24:24]</bitRange>
              <description>Input status of pin 'hif_a8' sampled at power-on-reset </description>
            </field>
            <field>
              <name>hif_a7</name>
              <bitRange>[23:23]</bitRange>
              <description>Input status of pin 'hif_a7' sampled at power-on-reset </description>
            </field>
            <field>
              <name>hif_a6</name>
              <bitRange>[22:22]</bitRange>
              <description>Input status of pin 'hif_a6' sampled at power-on-reset </description>
            </field>
            <field>
              <name>hif_a5</name>
              <bitRange>[21:21]</bitRange>
              <description>Input status of pin 'hif_a5' sampled at power-on-reset </description>
            </field>
            <field>
              <name>hif_a4</name>
              <bitRange>[20:20]</bitRange>
              <description>Input status of pin 'hif_a4' sampled at power-on-reset </description>
            </field>
            <field>
              <name>hif_a3</name>
              <bitRange>[19:19]</bitRange>
              <description>Input status of pin 'hif_a3' sampled at power-on-reset </description>
            </field>
            <field>
              <name>hif_a2</name>
              <bitRange>[18:18]</bitRange>
              <description>Input status of pin 'hif_a2' sampled at power-on-reset </description>
            </field>
            <field>
              <name>hif_a1</name>
              <bitRange>[17:17]</bitRange>
              <description>Input status of pin 'hif_a1' sampled at power-on-reset </description>
            </field>
            <field>
              <name>hif_a0</name>
              <bitRange>[16:16]</bitRange>
              <description>Input status of pin 'hif_a0' sampled at power-on-reset </description>
            </field>
            <field>
              <name>hif_d15</name>
              <bitRange>[15:15]</bitRange>
              <description>Input status of pin 'hif_d15' sampled at power-on-reset </description>
            </field>
            <field>
              <name>hif_d14</name>
              <bitRange>[14:14]</bitRange>
              <description>Input status of pin 'hif_d14' sampled at power-on-reset </description>
            </field>
            <field>
              <name>hif_d13</name>
              <bitRange>[13:13]</bitRange>
              <description>Input status of pin 'hif_d13' sampled at power-on-reset </description>
            </field>
            <field>
              <name>hif_d12</name>
              <bitRange>[12:12]</bitRange>
              <description>Input status of pin 'hif_d12' sampled at power-on-reset </description>
            </field>
            <field>
              <name>hif_d11</name>
              <bitRange>[11:11]</bitRange>
              <description>Input status of pin 'hif_d11' sampled at power-on-reset </description>
            </field>
            <field>
              <name>hif_d10</name>
              <bitRange>[10:10]</bitRange>
              <description>Input status of pin 'hif_d10' sampled at power-on-reset </description>
            </field>
            <field>
              <name>hif_d9</name>
              <bitRange>[9:9]</bitRange>
              <description>Input status of pin 'hif_d9' sampled at power-on-reset </description>
            </field>
            <field>
              <name>hif_d8</name>
              <bitRange>[8:8]</bitRange>
              <description>Input status of pin 'hif_d8' sampled at power-on-reset </description>
            </field>
            <field>
              <name>hif_d7</name>
              <bitRange>[7:7]</bitRange>
              <description>Input status of pin 'hif_d7' sampled at power-on-reset </description>
            </field>
            <field>
              <name>hif_d6</name>
              <bitRange>[6:6]</bitRange>
              <description>Input status of pin 'hif_d6' sampled at power-on-reset </description>
            </field>
            <field>
              <name>hif_d5</name>
              <bitRange>[5:5]</bitRange>
              <description>Input status of pin 'hif_d5' sampled at power-on-reset </description>
            </field>
            <field>
              <name>hif_d4</name>
              <bitRange>[4:4]</bitRange>
              <description>Input status of pin 'hif_d4' sampled at power-on-reset </description>
            </field>
            <field>
              <name>hif_d3</name>
              <bitRange>[3:3]</bitRange>
              <description>Input status of pin 'hif_d3' sampled at power-on-reset </description>
            </field>
            <field>
              <name>hif_d2</name>
              <bitRange>[2:2]</bitRange>
              <description>Input status of pin 'hif_d2' sampled at power-on-reset </description>
            </field>
            <field>
              <name>hif_d1</name>
              <bitRange>[1:1]</bitRange>
              <description>Input status of pin 'hif_d1' sampled at power-on-reset </description>
            </field>
            <field>
              <name>hif_d0</name>
              <bitRange>[0:0]</bitRange>
              <description>Input status of pin 'hif_d0' sampled at power-on-reset </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'sample_at_porn_stat_in1': 0xFF4016D4-->
          <name>sample_at_porn_stat_in1</name>
          <description>Status of inputs sampled at power-on-reset (PORn) register 1. This register shows the status of the inputs sampled at power-on-reset. It will not change on normal system reset. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0001FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:17]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sqi_sio3</name>
              <bitRange>[16:16]</bitRange>
              <description>Input status of pin 'sqi_sio3' sampled at power-on-reset </description>
            </field>
            <field>
              <name>sqi_sio2</name>
              <bitRange>[15:15]</bitRange>
              <description>Input status of pin 'sqi_sio2' sampled at power-on-reset </description>
            </field>
            <field>
              <name>sqi_miso</name>
              <bitRange>[14:14]</bitRange>
              <description>Input status of pin 'sqi_miso' sampled at power-on-reset </description>
            </field>
            <field>
              <name>sqi_mosi</name>
              <bitRange>[13:13]</bitRange>
              <description>Input status of pin 'sqi_mosi' sampled at power-on-reset </description>
            </field>
            <field>
              <name>sqi_cs0n</name>
              <bitRange>[12:12]</bitRange>
              <description>Input status of pin 'sqi_cs0n' sampled at power-on-reset </description>
            </field>
            <field>
              <name>sqi_clk</name>
              <bitRange>[11:11]</bitRange>
              <description>Input status of pin 'sqi_clk' sampled at power-on-reset </description>
            </field>
            <field>
              <name>run_n</name>
              <bitRange>[10:10]</bitRange>
              <description>Input status of pin 'run_n' sampled at power-on-reset </description>
            </field>
            <field>
              <name>rdy_n</name>
              <bitRange>[9:9]</bitRange>
              <description>Input status of pin 'rdy_n' sampled at power-on-reset </description>
            </field>
            <field>
              <name>hif_sdclk</name>
              <bitRange>[8:8]</bitRange>
              <description>Input status of pin 'hif_sdclk' sampled at power-on-reset </description>
            </field>
            <field>
              <name>hif_dirq</name>
              <bitRange>[7:7]</bitRange>
              <description>Input status of pin 'hif_dirq' sampled at power-on-reset </description>
            </field>
            <field>
              <name>hif_rdy</name>
              <bitRange>[6:6]</bitRange>
              <description>Input status of pin 'hif_rdy' sampled at power-on-reset </description>
            </field>
            <field>
              <name>hif_csn</name>
              <bitRange>[5:5]</bitRange>
              <description>Input status of pin 'hif_csn' sampled at power-on-reset </description>
            </field>
            <field>
              <name>hif_wrn</name>
              <bitRange>[4:4]</bitRange>
              <description>Input status of pin 'hif_wrn' sampled at power-on-reset </description>
            </field>
            <field>
              <name>hif_rdn</name>
              <bitRange>[3:3]</bitRange>
              <description>Input status of pin 'hif_rdn' sampled at power-on-reset </description>
            </field>
            <field>
              <name>hif_bhen</name>
              <bitRange>[2:2]</bitRange>
              <description>Input status of pin 'hif_bhen' sampled at power-on-reset </description>
            </field>
            <field>
              <name>hif_a17</name>
              <bitRange>[1:1]</bitRange>
              <description>Input status of pin 'hif_a17' sampled at power-on-reset </description>
            </field>
            <field>
              <name>hif_a16</name>
              <bitRange>[0:0]</bitRange>
              <description>Input status of pin 'hif_a16' sampled at power-on-reset </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>slave_firewall_ctrl</name>
      <description>slave_firewall_ctrl</description>
      <baseAddress>0xFF401700</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>64</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <!--Absolute address of 'firewall_cfg_crypt_system': 0xFF401700-->
          <name>firewall_cfg_crypt_system</name>
          <description>Firewall configuration register for the crypt_system NETX AHB channel.  Basic function: A denied access will generate an ERROR-response (abort). Masters which cannot handle aborts directly can generate an IRQ to their controlling master when they receive an abort (e.g. the DPM-master can generate an IRQ to its host or the DMA-controllers can generate an IRQ to the ARM-CPU). The firewall will no generate any IRQ by itself. A denied write access will be junked. A denied read access will return unpredictable data.  Note:   COM-side masters are: DPM0, DPM1, XC01, XPIC_COM, ARM_COM, DMAC_COM.   APP-side masters are: IDPM_MASTER, XPIC_APP, ARM_APP, DMAC_APP.   Other masters which cannot be filtered but globally disabled are: ADC_MASTER, IPC_MASTER, DEBUG_MASTER. Note:   The configuration bits of this register can be locked to protect it from reconfiguration by ASIC_CTRL_COM.netx_lock.lock_firewall.   The functionality of the status bits are not influenced by ASIC_CTRL_COM.netx_lock.lock_firewall.  </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000033</resetValue>
          <resetMask>0x80000333</resetMask>
          <fields>
            <field>
              <name>abort_dis</name>
              <bitRange>[31:31]</bitRange>
              <description>disable abort-generation for denied accesses 1: no ERROR response for denied accesses (not recommended). 0: ERROR response for denied accesses (default) </description>
            </field>
            <field>
              <name>bf_align2</name>
              <bitRange>[30:10]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>stat_app</name>
              <bitRange>[9:9]</bitRange>
              <description>status for APP side masters, write '1' to clear. </description>
            </field>
            <field>
              <name>stat_com</name>
              <bitRange>[8:8]</bitRange>
              <description>Firewall status for COM side masters, write '1' to clear. 1: an access of the COM side was denied 0: no denied accesses Note: Clearing the stat-bit by software has lower priority than setting by hardware. I.e. clearing a status bit while an access of the related is denied, will fail. Ensure that no access will be denied before clearing by stopping accessing master (e.g. DMAC which could perform long jobs with long bursts). </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[7:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>rp_app</name>
              <bitRange>[5:5]</bitRange>
              <description>read permission for APP side masters </description>
            </field>
            <field>
              <name>rp_com</name>
              <bitRange>[4:4]</bitRange>
              <description>read permission for COM side masters 1: permit read access 0: deny read access </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:2]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>wp_app</name>
              <bitRange>[1:1]</bitRange>
              <description>write permission for APP side masters </description>
            </field>
            <field>
              <name>wp_com</name>
              <bitRange>[0:0]</bitRange>
              <description>write permission for COM side masters 1: permit write access 0: deny write access </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'firewall_cfg_debug_slave': 0xFF401704-->
          <name>firewall_cfg_debug_slave</name>
          <description>Firewall configuration register for the debug_slave NETX AHB channel.  See description of register firewall_cfg_crypt_system for details.  Note:   The configuration bits of this register can be locked to protect it from reconfiguration by ASIC_CTRL_COM.netx_lock.lock_firewall.   The functionality of the status bits are not influenced by ASIC_CTRL_COM.netx_lock.lock_firewall.  </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000033</resetValue>
          <resetMask>0x80000333</resetMask>
          <fields>
            <field>
              <name>abort_dis</name>
              <bitRange>[31:31]</bitRange>
              <description>disable abort-generation for denied accesses </description>
            </field>
            <field>
              <name>bf_align2</name>
              <bitRange>[30:10]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>stat_app</name>
              <bitRange>[9:9]</bitRange>
              <description>status for APP side masters, write '1' to clear. </description>
            </field>
            <field>
              <name>stat_com</name>
              <bitRange>[8:8]</bitRange>
              <description>Firewall status for COM side masters, write '1' to clear. </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[7:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>rp_app</name>
              <bitRange>[5:5]</bitRange>
              <description>read permission for APP side masters </description>
            </field>
            <field>
              <name>rp_com</name>
              <bitRange>[4:4]</bitRange>
              <description>read permission for COM side masters </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:2]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>wp_app</name>
              <bitRange>[1:1]</bitRange>
              <description>write permission for APP side masters </description>
            </field>
            <field>
              <name>wp_com</name>
              <bitRange>[0:0]</bitRange>
              <description>write permission for COM side masters </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'firewall_cfg_eth_system': 0xFF401708-->
          <name>firewall_cfg_eth_system</name>
          <description>Firewall configuration register for the eth_system NETX AHB channel.  See description of register firewall_cfg_crypt_system for details.  Note:   The configuration bits of this register can be locked to protect it from reconfiguration by ASIC_CTRL_COM.netx_lock.lock_firewall.   The functionality of the status bits are not influenced by ASIC_CTRL_COM.netx_lock.lock_firewall.  </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000033</resetValue>
          <resetMask>0x80000333</resetMask>
          <fields>
            <field>
              <name>abort_dis</name>
              <bitRange>[31:31]</bitRange>
              <description>disable abort-generation for denied accesses </description>
            </field>
            <field>
              <name>bf_align2</name>
              <bitRange>[30:10]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>stat_app</name>
              <bitRange>[9:9]</bitRange>
              <description>status for APP side masters, write '1' to clear. </description>
            </field>
            <field>
              <name>stat_com</name>
              <bitRange>[8:8]</bitRange>
              <description>Firewall status for COM side masters, write '1' to clear. </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[7:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>rp_app</name>
              <bitRange>[5:5]</bitRange>
              <description>read permission for APP side masters </description>
            </field>
            <field>
              <name>rp_com</name>
              <bitRange>[4:4]</bitRange>
              <description>read permission for COM side masters </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:2]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>wp_app</name>
              <bitRange>[1:1]</bitRange>
              <description>write permission for APP side masters </description>
            </field>
            <field>
              <name>wp_com</name>
              <bitRange>[0:0]</bitRange>
              <description>write permission for COM side masters </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'firewall_cfg_sqirom': 0xFF40170C-->
          <name>firewall_cfg_sqirom</name>
          <description>Firewall configuration register for the sqirom NETX AHB channel.  See description of register firewall_cfg_crypt_system for details.  Note:   The configuration bits of this register can be locked to protect it from reconfiguration by ASIC_CTRL_COM.netx_lock.lock_firewall.   The functionality of the status bits are not influenced by ASIC_CTRL_COM.netx_lock.lock_firewall.  </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000033</resetValue>
          <resetMask>0x80000333</resetMask>
          <fields>
            <field>
              <name>abort_dis</name>
              <bitRange>[31:31]</bitRange>
              <description>disable abort-generation for denied accesses </description>
            </field>
            <field>
              <name>bf_align2</name>
              <bitRange>[30:10]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>stat_app</name>
              <bitRange>[9:9]</bitRange>
              <description>status for APP side masters, write '1' to clear. </description>
            </field>
            <field>
              <name>stat_com</name>
              <bitRange>[8:8]</bitRange>
              <description>Firewall status for COM side masters, write '1' to clear. </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[7:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>rp_app</name>
              <bitRange>[5:5]</bitRange>
              <description>read permission for APP side masters </description>
            </field>
            <field>
              <name>rp_com</name>
              <bitRange>[4:4]</bitRange>
              <description>read permission for COM side masters </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:2]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>wp_app</name>
              <bitRange>[1:1]</bitRange>
              <description>write permission for APP side masters </description>
            </field>
            <field>
              <name>wp_com</name>
              <bitRange>[0:0]</bitRange>
              <description>write permission for COM side masters </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'firewall_cfg_hifmem_amem': 0xFF401710-->
          <name>firewall_cfg_hifmem_amem</name>
          <description>Firewall configuration register for the hifmem_amem NETX AHB channel.  See description of register firewall_cfg_crypt_system for details.  Note:   The configuration bits of this register can be locked to protect it from reconfiguration by ASIC_CTRL_COM.netx_lock.lock_firewall.   The functionality of the status bits are not influenced by ASIC_CTRL_COM.netx_lock.lock_firewall.  </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000033</resetValue>
          <resetMask>0x80000333</resetMask>
          <fields>
            <field>
              <name>abort_dis</name>
              <bitRange>[31:31]</bitRange>
              <description>disable abort-generation for denied accesses </description>
            </field>
            <field>
              <name>bf_align2</name>
              <bitRange>[30:10]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>stat_app</name>
              <bitRange>[9:9]</bitRange>
              <description>status for APP side masters, write '1' to clear. </description>
            </field>
            <field>
              <name>stat_com</name>
              <bitRange>[8:8]</bitRange>
              <description>Firewall status for COM side masters, write '1' to clear. </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[7:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>rp_app</name>
              <bitRange>[5:5]</bitRange>
              <description>read permission for APP side masters </description>
            </field>
            <field>
              <name>rp_com</name>
              <bitRange>[4:4]</bitRange>
              <description>read permission for COM side masters </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:2]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>wp_app</name>
              <bitRange>[1:1]</bitRange>
              <description>write permission for APP side masters </description>
            </field>
            <field>
              <name>wp_com</name>
              <bitRange>[0:0]</bitRange>
              <description>write permission for COM side masters </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'firewall_cfg_hifmem_sdram': 0xFF401714-->
          <name>firewall_cfg_hifmem_sdram</name>
          <description>Firewall configuration register for the hifmem_sdram NETX AHB channel.  See description of register firewall_cfg_crypt_system for details.  Note:   The configuration bits of this register can be locked to protect it from reconfiguration by ASIC_CTRL_COM.netx_lock.lock_firewall.   The functionality of the status bits are not influenced by ASIC_CTRL_COM.netx_lock.lock_firewall.  </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000033</resetValue>
          <resetMask>0x80000333</resetMask>
          <fields>
            <field>
              <name>abort_dis</name>
              <bitRange>[31:31]</bitRange>
              <description>disable abort-generation for denied accesses </description>
            </field>
            <field>
              <name>bf_align2</name>
              <bitRange>[30:10]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>stat_app</name>
              <bitRange>[9:9]</bitRange>
              <description>status for APP side masters, write '1' to clear. </description>
            </field>
            <field>
              <name>stat_com</name>
              <bitRange>[8:8]</bitRange>
              <description>Firewall status for COM side masters, write '1' to clear. </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[7:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>rp_app</name>
              <bitRange>[5:5]</bitRange>
              <description>read permission for APP side masters </description>
            </field>
            <field>
              <name>rp_com</name>
              <bitRange>[4:4]</bitRange>
              <description>read permission for COM side masters </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:2]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>wp_app</name>
              <bitRange>[1:1]</bitRange>
              <description>write permission for APP side masters </description>
            </field>
            <field>
              <name>wp_com</name>
              <bitRange>[0:0]</bitRange>
              <description>write permission for COM side masters </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>module_firewall_ctrl</name>
      <description>module_firewall_ctrl</description>
      <baseAddress>0xFF401740</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>64</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <!--Absolute address of 'firewall_cfg_intlogic_shd_pad_ctrl': 0xFF401740-->
          <name>firewall_cfg_intlogic_shd_pad_ctrl</name>
          <description>Firewall configuration register for the intlogic_shd_pad_ctrl module.  Basic function: A denied access will generate an ERROR-response (abort). Masters which cannot handle aborts directly can generate an IRQ to their controlling master when they receive an abort (e.g. the DPM-master can generate an IRQ to its host or the DMA-controllers can generate an IRQ to the ARM-CPU). The firewall will no generate any IRQ by itself. A denied write access will be junked. A denied read access will return unpredictable data.  Note:   COM-side masters are: DPM0, DPM1, XC01, XPIC_COM, ARM_COM, DMAC_COM.   APP-side masters are: IDPM_MASTER, XPIC_APP, ARM_APP, DMAC_APP.   Other masters which cannot be filtered but globally disabled are: ADC_MASTER, IPC_MASTER, DEBUG_MASTER. Note:   The configuration bits of this register can be locked to protect it from reconfiguration by ASIC_CTRL_COM.netx_lock.lock_firewall.   The functionality of the status bits are not influenced by ASIC_CTRL_COM.netx_lock.lock_firewall.  </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000033</resetValue>
          <resetMask>0x80000333</resetMask>
          <fields>
            <field>
              <name>abort_dis</name>
              <bitRange>[31:31]</bitRange>
              <description>disable abort-generation for denied accesses 1: no ERROR response for denied accesses (not recommended). 0: ERROR response for denied accesses (default) </description>
            </field>
            <field>
              <name>bf_align2</name>
              <bitRange>[30:10]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>stat_app</name>
              <bitRange>[9:9]</bitRange>
              <description>status for APP side masters, write '1' to clear. </description>
            </field>
            <field>
              <name>stat_com</name>
              <bitRange>[8:8]</bitRange>
              <description>Firewall status for COM side masters, write '1' to clear. 1: an access of the COM side was denied 0: no denied accesses Note: Clearing the stat-bit by software has lower priority than setting by hardware. I.e. clearing a status bit while an access of the related is denied, will fail. Ensure that no access will be denied before clearing by stopping accessing master (e.g. DMAC which could perform long jobs with long bursts). </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[7:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>rp_app</name>
              <bitRange>[5:5]</bitRange>
              <description>read permission for APP side masters </description>
            </field>
            <field>
              <name>rp_com</name>
              <bitRange>[4:4]</bitRange>
              <description>read permission for COM side masters 1: permit read access 0: deny read access </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:2]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>wp_app</name>
              <bitRange>[1:1]</bitRange>
              <description>write permission for APP side masters </description>
            </field>
            <field>
              <name>wp_com</name>
              <bitRange>[0:0]</bitRange>
              <description>write permission for COM side masters 1: permit write access 0: deny write access </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'firewall_cfg_intlogic_shd_sqi': 0xFF401744-->
          <name>firewall_cfg_intlogic_shd_sqi</name>
          <description>Firewall configuration register for the intlogic_shd_sqi module.  See description of register firewall_cfg_intlogic_shd_pad_ctrl for details.  Note:   The configuration bits of this register can be locked to protect it from reconfiguration by ASIC_CTRL_COM.netx_lock.lock_firewall.   The functionality of the status bits are not influenced by ASIC_CTRL_COM.netx_lock.lock_firewall.  </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000033</resetValue>
          <resetMask>0x80000333</resetMask>
          <fields>
            <field>
              <name>abort_dis</name>
              <bitRange>[31:31]</bitRange>
              <description>disable abort-generation for denied accesses </description>
            </field>
            <field>
              <name>bf_align2</name>
              <bitRange>[30:10]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>stat_app</name>
              <bitRange>[9:9]</bitRange>
              <description>status for APP side masters, write '1' to clear. </description>
            </field>
            <field>
              <name>stat_com</name>
              <bitRange>[8:8]</bitRange>
              <description>Firewall status for COM side masters, write '1' to clear. </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[7:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>rp_app</name>
              <bitRange>[5:5]</bitRange>
              <description>read permission for APP side masters </description>
            </field>
            <field>
              <name>rp_com</name>
              <bitRange>[4:4]</bitRange>
              <description>read permission for COM side masters </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:2]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>wp_app</name>
              <bitRange>[1:1]</bitRange>
              <description>write permission for APP side masters </description>
            </field>
            <field>
              <name>wp_com</name>
              <bitRange>[0:0]</bitRange>
              <description>write permission for COM side masters </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'firewall_cfg_intlogic_shd_uart': 0xFF401748-->
          <name>firewall_cfg_intlogic_shd_uart</name>
          <description>Firewall configuration register for the intlogic_shd_uart module.  See description of register firewall_cfg_intlogic_shd_pad_ctrl for details.  Note:   The configuration bits of this register can be locked to protect it from reconfiguration by ASIC_CTRL_COM.netx_lock.lock_firewall.   The functionality of the status bits are not influenced by ASIC_CTRL_COM.netx_lock.lock_firewall.  </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000033</resetValue>
          <resetMask>0x80000333</resetMask>
          <fields>
            <field>
              <name>abort_dis</name>
              <bitRange>[31:31]</bitRange>
              <description>disable abort-generation for denied accesses </description>
            </field>
            <field>
              <name>bf_align2</name>
              <bitRange>[30:10]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>stat_app</name>
              <bitRange>[9:9]</bitRange>
              <description>status for APP side masters, write '1' to clear. </description>
            </field>
            <field>
              <name>stat_com</name>
              <bitRange>[8:8]</bitRange>
              <description>Firewall status for COM side masters, write '1' to clear. </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[7:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>rp_app</name>
              <bitRange>[5:5]</bitRange>
              <description>read permission for APP side masters </description>
            </field>
            <field>
              <name>rp_com</name>
              <bitRange>[4:4]</bitRange>
              <description>read permission for COM side masters </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:2]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>wp_app</name>
              <bitRange>[1:1]</bitRange>
              <description>write permission for APP side masters </description>
            </field>
            <field>
              <name>wp_com</name>
              <bitRange>[0:0]</bitRange>
              <description>write permission for COM side masters </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'firewall_cfg_intlogic_shd_ecc_ctrl': 0xFF40174C-->
          <name>firewall_cfg_intlogic_shd_ecc_ctrl</name>
          <description>Firewall configuration register for the intlogic_shd_ecc_ctrl module.  See description of register firewall_cfg_intlogic_shd_pad_ctrl for details.  Note:   The configuration bits of this register can be locked to protect it from reconfiguration by ASIC_CTRL_COM.netx_lock.lock_firewall.   The functionality of the status bits are not influenced by ASIC_CTRL_COM.netx_lock.lock_firewall.  </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000033</resetValue>
          <resetMask>0x80000333</resetMask>
          <fields>
            <field>
              <name>abort_dis</name>
              <bitRange>[31:31]</bitRange>
              <description>disable abort-generation for denied accesses </description>
            </field>
            <field>
              <name>bf_align2</name>
              <bitRange>[30:10]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>stat_app</name>
              <bitRange>[9:9]</bitRange>
              <description>status for APP side masters, write '1' to clear. </description>
            </field>
            <field>
              <name>stat_com</name>
              <bitRange>[8:8]</bitRange>
              <description>Firewall status for COM side masters, write '1' to clear. </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[7:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>rp_app</name>
              <bitRange>[5:5]</bitRange>
              <description>read permission for APP side masters </description>
            </field>
            <field>
              <name>rp_com</name>
              <bitRange>[4:4]</bitRange>
              <description>read permission for COM side masters </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:2]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>wp_app</name>
              <bitRange>[1:1]</bitRange>
              <description>write permission for APP side masters </description>
            </field>
            <field>
              <name>wp_com</name>
              <bitRange>[0:0]</bitRange>
              <description>write permission for COM side masters </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'firewall_cfg_intlogic_shd_madc': 0xFF401750-->
          <name>firewall_cfg_intlogic_shd_madc</name>
          <description>Firewall configuration register for the intlogic_shd_madc module.  See description of register firewall_cfg_intlogic_shd_pad_ctrl for details.  Note:   The configuration bits of this register can be locked to protect it from reconfiguration by ASIC_CTRL_COM.netx_lock.lock_firewall.   The functionality of the status bits are not influenced by ASIC_CTRL_COM.netx_lock.lock_firewall.  </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000033</resetValue>
          <resetMask>0x80000333</resetMask>
          <fields>
            <field>
              <name>abort_dis</name>
              <bitRange>[31:31]</bitRange>
              <description>disable abort-generation for denied accesses </description>
            </field>
            <field>
              <name>bf_align2</name>
              <bitRange>[30:10]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>stat_app</name>
              <bitRange>[9:9]</bitRange>
              <description>status for APP side masters, write '1' to clear. </description>
            </field>
            <field>
              <name>stat_com</name>
              <bitRange>[8:8]</bitRange>
              <description>Firewall status for COM side masters, write '1' to clear. </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[7:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>rp_app</name>
              <bitRange>[5:5]</bitRange>
              <description>read permission for APP side masters </description>
            </field>
            <field>
              <name>rp_com</name>
              <bitRange>[4:4]</bitRange>
              <description>read permission for COM side masters </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:2]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>wp_app</name>
              <bitRange>[1:1]</bitRange>
              <description>write permission for APP side masters </description>
            </field>
            <field>
              <name>wp_com</name>
              <bitRange>[0:0]</bitRange>
              <description>write permission for COM side masters </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'firewall_cfg_intlogic_shd_madc_seq0': 0xFF401754-->
          <name>firewall_cfg_intlogic_shd_madc_seq0</name>
          <description>Firewall configuration register for the intlogic_shd_madc_seq0 module.  See description of register firewall_cfg_intlogic_shd_pad_ctrl for details.  Note:   The configuration bits of this register can be locked to protect it from reconfiguration by ASIC_CTRL_COM.netx_lock.lock_firewall.   The functionality of the status bits are not influenced by ASIC_CTRL_COM.netx_lock.lock_firewall.  </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000033</resetValue>
          <resetMask>0x80000333</resetMask>
          <fields>
            <field>
              <name>abort_dis</name>
              <bitRange>[31:31]</bitRange>
              <description>disable abort-generation for denied accesses </description>
            </field>
            <field>
              <name>bf_align2</name>
              <bitRange>[30:10]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>stat_app</name>
              <bitRange>[9:9]</bitRange>
              <description>status for APP side masters, write '1' to clear. </description>
            </field>
            <field>
              <name>stat_com</name>
              <bitRange>[8:8]</bitRange>
              <description>Firewall status for COM side masters, write '1' to clear. </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[7:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>rp_app</name>
              <bitRange>[5:5]</bitRange>
              <description>read permission for APP side masters </description>
            </field>
            <field>
              <name>rp_com</name>
              <bitRange>[4:4]</bitRange>
              <description>read permission for COM side masters </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:2]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>wp_app</name>
              <bitRange>[1:1]</bitRange>
              <description>write permission for APP side masters </description>
            </field>
            <field>
              <name>wp_com</name>
              <bitRange>[0:0]</bitRange>
              <description>write permission for COM side masters </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'firewall_cfg_intlogic_shd_madc_seq1': 0xFF401758-->
          <name>firewall_cfg_intlogic_shd_madc_seq1</name>
          <description>Firewall configuration register for the intlogic_shd_madc_seq1 module.  See description of register firewall_cfg_intlogic_shd_pad_ctrl for details.  Note:   The configuration bits of this register can be locked to protect it from reconfiguration by ASIC_CTRL_COM.netx_lock.lock_firewall.   The functionality of the status bits are not influenced by ASIC_CTRL_COM.netx_lock.lock_firewall.  </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000018</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000033</resetValue>
          <resetMask>0x80000333</resetMask>
          <fields>
            <field>
              <name>abort_dis</name>
              <bitRange>[31:31]</bitRange>
              <description>disable abort-generation for denied accesses </description>
            </field>
            <field>
              <name>bf_align2</name>
              <bitRange>[30:10]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>stat_app</name>
              <bitRange>[9:9]</bitRange>
              <description>status for APP side masters, write '1' to clear. </description>
            </field>
            <field>
              <name>stat_com</name>
              <bitRange>[8:8]</bitRange>
              <description>Firewall status for COM side masters, write '1' to clear. </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[7:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>rp_app</name>
              <bitRange>[5:5]</bitRange>
              <description>read permission for APP side masters </description>
            </field>
            <field>
              <name>rp_com</name>
              <bitRange>[4:4]</bitRange>
              <description>read permission for COM side masters </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:2]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>wp_app</name>
              <bitRange>[1:1]</bitRange>
              <description>write permission for APP side masters </description>
            </field>
            <field>
              <name>wp_com</name>
              <bitRange>[0:0]</bitRange>
              <description>write permission for COM side masters </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'firewall_cfg_intlogic_shd_madc_seq2': 0xFF40175C-->
          <name>firewall_cfg_intlogic_shd_madc_seq2</name>
          <description>Firewall configuration register for the intlogic_shd_madc_seq2 module.  See description of register firewall_cfg_intlogic_shd_pad_ctrl for details.  Note:   The configuration bits of this register can be locked to protect it from reconfiguration by ASIC_CTRL_COM.netx_lock.lock_firewall.   The functionality of the status bits are not influenced by ASIC_CTRL_COM.netx_lock.lock_firewall.  </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000001C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000033</resetValue>
          <resetMask>0x80000333</resetMask>
          <fields>
            <field>
              <name>abort_dis</name>
              <bitRange>[31:31]</bitRange>
              <description>disable abort-generation for denied accesses </description>
            </field>
            <field>
              <name>bf_align2</name>
              <bitRange>[30:10]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>stat_app</name>
              <bitRange>[9:9]</bitRange>
              <description>status for APP side masters, write '1' to clear. </description>
            </field>
            <field>
              <name>stat_com</name>
              <bitRange>[8:8]</bitRange>
              <description>Firewall status for COM side masters, write '1' to clear. </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[7:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>rp_app</name>
              <bitRange>[5:5]</bitRange>
              <description>read permission for APP side masters </description>
            </field>
            <field>
              <name>rp_com</name>
              <bitRange>[4:4]</bitRange>
              <description>read permission for COM side masters </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:2]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>wp_app</name>
              <bitRange>[1:1]</bitRange>
              <description>write permission for APP side masters </description>
            </field>
            <field>
              <name>wp_com</name>
              <bitRange>[0:0]</bitRange>
              <description>write permission for COM side masters </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'firewall_cfg_intlogic_shd_madc_seq3': 0xFF401760-->
          <name>firewall_cfg_intlogic_shd_madc_seq3</name>
          <description>Firewall configuration register for the intlogic_shd_madc_seq3 module.  See description of register firewall_cfg_intlogic_shd_pad_ctrl for details.  Note:   The configuration bits of this register can be locked to protect it from reconfiguration by ASIC_CTRL_COM.netx_lock.lock_firewall.   The functionality of the status bits are not influenced by ASIC_CTRL_COM.netx_lock.lock_firewall.  </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000033</resetValue>
          <resetMask>0x80000333</resetMask>
          <fields>
            <field>
              <name>abort_dis</name>
              <bitRange>[31:31]</bitRange>
              <description>disable abort-generation for denied accesses </description>
            </field>
            <field>
              <name>bf_align2</name>
              <bitRange>[30:10]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>stat_app</name>
              <bitRange>[9:9]</bitRange>
              <description>status for APP side masters, write '1' to clear. </description>
            </field>
            <field>
              <name>stat_com</name>
              <bitRange>[8:8]</bitRange>
              <description>Firewall status for COM side masters, write '1' to clear. </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[7:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>rp_app</name>
              <bitRange>[5:5]</bitRange>
              <description>read permission for APP side masters </description>
            </field>
            <field>
              <name>rp_com</name>
              <bitRange>[4:4]</bitRange>
              <description>read permission for COM side masters </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:2]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>wp_app</name>
              <bitRange>[1:1]</bitRange>
              <description>write permission for APP side masters </description>
            </field>
            <field>
              <name>wp_com</name>
              <bitRange>[0:0]</bitRange>
              <description>write permission for COM side masters </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'firewall_cfg_hifmemctrl': 0xFF40177C-->
          <name>firewall_cfg_hifmemctrl</name>
          <description>Firewall configuration register for the configuration registers of the HIF MI.  See description of register firewall_cfg_intlogic_shd_pad_ctrl for details. Note that read access cannot be blocked for the configuration registers of the HIF MI. The failed-access-status is not logged individually for each MI configuration register.  Note:   The configuration bits of this register can be locked to protect it from reconfiguration by ASIC_CTRL_COM.netx_lock.lock_firewall.   The functionality of the status bits are not influenced by ASIC_CTRL_COM.netx_lock.lock_firewall.  </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000003C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x03333333</resetValue>
          <resetMask>0xB3333333</resetMask>
          <fields>
            <field>
              <name>abort_dis</name>
              <bitRange>[31:31]</bitRange>
              <description>Disable abort-generation for denied accesses for all registers controlled by this register. </description>
            </field>
            <field>
              <name>bf_align7</name>
              <bitRange>[30:30]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>stat_app</name>
              <bitRange>[29:29]</bitRange>
              <description>Status for APP side masters for all registers above, write '1' to clear. </description>
            </field>
            <field>
              <name>stat_com</name>
              <bitRange>[28:28]</bitRange>
              <description>Firewall status for COM side masters for all registers above, write '1' to clear. </description>
            </field>
            <field>
              <name>bf_align6</name>
              <bitRange>[27:26]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sdram_ctrl_wp_app</name>
              <bitRange>[25:25]</bitRange>
              <description>Write permission for APP side masters for the following register(s): all registers of hif_sdram_ctrl and hifmem_priority_ctrl </description>
            </field>
            <field>
              <name>sdram_ctrl_wp_com</name>
              <bitRange>[24:24]</bitRange>
              <description>Write permission for COM side masters for the following register(s): all registers of hif_sdram_ctrl and hifmem_priority_ctrl </description>
            </field>
            <field>
              <name>bf_align5</name>
              <bitRange>[23:22]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>extsram3_ctrl_wp_app</name>
              <bitRange>[21:21]</bitRange>
              <description>Write permission for APP side masters for the following register(s): hif_asyncmem_ctrl.extsram3_ctrl </description>
            </field>
            <field>
              <name>extsram3_ctrl_wp_com</name>
              <bitRange>[20:20]</bitRange>
              <description>Write permission for COM side masters for the following register(s): hif_asyncmem_ctrl.extsram3_ctrl </description>
            </field>
            <field>
              <name>bf_align4</name>
              <bitRange>[19:18]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>extsram2_ctrl_wp_app</name>
              <bitRange>[17:17]</bitRange>
              <description>Write permission for APP side masters for the following register(s): hif_asyncmem_ctrl.extsram2_ctrl </description>
            </field>
            <field>
              <name>extsram2_ctrl_wp_com</name>
              <bitRange>[16:16]</bitRange>
              <description>Write permission for COM side masters for the following register(s): hif_asyncmem_ctrl.extsram2_ctrl </description>
            </field>
            <field>
              <name>bf_align3</name>
              <bitRange>[15:14]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>extsram1_ctrl_wp_app</name>
              <bitRange>[13:13]</bitRange>
              <description>Write permission for APP side masters for the following register(s): hif_asyncmem_ctrl.extsram1_ctrl </description>
            </field>
            <field>
              <name>extsram1_ctrl_wp_com</name>
              <bitRange>[12:12]</bitRange>
              <description>Write permission for COM side masters for the following register(s): hif_asyncmem_ctrl.extsram1_ctrl </description>
            </field>
            <field>
              <name>bf_align2</name>
              <bitRange>[11:10]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>extsram0_ctrl_wp_app</name>
              <bitRange>[9:9]</bitRange>
              <description>Write permission for APP side masters for the following register(s): hif_asyncmem_ctrl.extsram0_ctrl and hif_asyncmem_ctrl.ext_cs0_apm_ctr </description>
            </field>
            <field>
              <name>extsram0_ctrl_wp_com</name>
              <bitRange>[8:8]</bitRange>
              <description>Write permission for COM side masters for the following register(s): hif_asyncmem_ctrl.extsram0_ctrl and hif_asyncmem_ctrl.ext_cs0_apm_ctr </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[7:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ext_rdy_status_wp_app</name>
              <bitRange>[5:5]</bitRange>
              <description>Write permission for APP side masters for the following register(s): hif_asyncmem_ctrl.ext_rdy_status </description>
            </field>
            <field>
              <name>ext_rdy_status_wp_com</name>
              <bitRange>[4:4]</bitRange>
              <description>Write permission for COM side masters for the following register(s): hif_asyncmem_ctrl.ext_rdy_status </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:2]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ext_rdy_cfg_wp_app</name>
              <bitRange>[1:1]</bitRange>
              <description>Write permission for APP side masters for the following register(s): hif_asyncmem_ctrl.ext_rdy_cfg </description>
            </field>
            <field>
              <name>ext_rdy_cfg_wp_com</name>
              <bitRange>[0:0]</bitRange>
              <description>Write permission for COM side masters for the following register(s): hif_asyncmem_ctrl.ext_rdy_cfg </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>ecc_ctrl</name>
      <description>ecc_ctrl</description>
      <baseAddress>0xFF401780</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>32</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <!--Absolute address of 'ecc_ctrl_iflash2_ctrl': 0xFF401780-->
          <name>ecc_ctrl_iflash2_ctrl</name>
          <description>IFLASH2 syndrome manipulation register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000001FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:9]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>syndrome_inv</name>
              <bitRange>[8:1]</bitRange>
              <description>Inverts syndrome bits for ECC testing </description>
            </field>
            <field>
              <name>enable</name>
              <bitRange>[0:0]</bitRange>
              <description>enable ECC </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'ecc_ctrl_iflash2_addr_sbe': 0xFF401784-->
          <name>ecc_ctrl_iflash2_addr_sbe</name>
          <description>RAM Address of ECC single bit error (SBE): This register logs the RAM address where first ECC SBE occured. This first SBE address will be stored (even in case of further SBEs) until the appropriate bit in status_sbe register was cleared. Note1: Not all RAM ECCs support error address logging, e.g. dual-port RAMs Note2: This is the real RAM address, i.e. a 32-bit address except at xMAC 64-bit RAMs or RAMs that are not directly accessible by CPU. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00007FFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:15]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>address</name>
              <bitRange>[14:0]</bitRange>
              <description>Address of last ECC single bit error </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'ecc_ctrl_iflash2_addr_dbe': 0xFF401788-->
          <name>ecc_ctrl_iflash2_addr_dbe</name>
          <description>RAM Address of ECC single bit error (DBE): This register logs the RAM address where first ECC DBE occured. This first DBE address will be stored (even in case of further DBEs) until the appropriate bit in status_sbe register was cleared. Note1: Not all RAM ECCs support error address logging, e.g. dual-port RAMs Note2: This is the real RAM address, i.e. a 32-bit address except at xMAC 64-bit RAMs or RAMs that are not directly accessible by CPU. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00007FFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:15]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>address</name>
              <bitRange>[14:0]</bitRange>
              <description>Address of last ECC double bit error </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'ecc_ctrl_status_sbe': 0xFF40178C-->
          <name>ecc_ctrl_status_sbe</name>
          <description>ECC status SBE: This register collects single bit error (SBE) status information. In case of ECC SBE, a bit in this register will be set. Bits can be reset by writing '1' to the apprpriate bit position (write to clear). If a SBE or DBE bit is set, IRQ signal will be asserted. Note: No mask register is required, as error correction can be enabled for each RAM separately. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>iflash2</name>
              <bitRange>[0:0]</bitRange>
              <description>IFLASH2 Single Bit Error occured </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'ecc_ctrl_status_dbe': 0xFF401790-->
          <name>ecc_ctrl_status_dbe</name>
          <description>ECC status DBE: This register collects double bit error (DBE) status information. In case of ECC DBE, a bit of the appropriate RAM in this register will be set. Bits can be reset by writing '1' to the apprpriate bit position (write to clear). If a SBE or DBE bit is set, IRQ signal will be asserted. Note: No mask register is required, as error correction can be enabled for each RAM separately. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>iflash2</name>
              <bitRange>[0:0]</bitRange>
              <description>IFLASH2 Double Bit Error occured </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>madc</name>
      <description>madc</description>
      <baseAddress>0xFF4017E0</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>32</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <!--Absolute address of 'madc_cfg': 0xFF4017E0-->
          <name>madc_cfg</name>
          <description>Config bits for the MADC common module. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000002</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>adcclk_period</name>
              <bitRange>[7:0]</bitRange>
              <description>Max value of global ADC synchronization counter: ADCs running at same adcclk might interfere. Therefore the ADCs should be able to run in different clk-phases. Adcclk generation will be done within the ADC sequencers. This value is used to configure a global counter for clock phase reference. It's value should be the same or an natural numbered multiple of the value configured in ADC sequencers. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_adc01_static_cfg': 0xFF4017E4-->
          <name>madc_adc01_static_cfg</name>
          <description>Static configuration signals (D2A) to the MAZ IP containing the analog modules ADC0 to ADC3. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000007</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:3]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>vref_buffer_enable</name>
              <bitRange>[2:2]</bitRange>
              <description>Output Enable for internal Vref buffer Three modes are supported for generation of ADC Reference voltage (vref): {  | 1. Use VDD3 (3,3V supply of analog core) as reference: This mode might be inaccurate due to jitter on VDD3. To enable this mode set static_cfg-vref=1 inside the related MADC_SEQ module. The vref_buffer_enable need not be set, if all ADCs use VDD3. 2. Use internal 2.6V reference: This mode requires an external capacitor at pin ADC_VREF, which will be driven to 2.6V from internal vref_buffer. To enable this mode set this bit to 1 and static_cfg-vref=0 inside the related MADC_SEQ module. 3. Use external reference: Use any external reference voltage (&lt;3.3V) at pin ADC_VREF. To enable this mode set this bit to 0 and static_cfg-vref=0 inside the related MADC_SEQ module.} </description>
            </field>
            <field>
              <name>adc01_reset_n</name>
              <bitRange>[1:1]</bitRange>
              <description>Low active reset of ADC0 and ADC1 and their state machines: 1: Soft-Reset is inactive. 0: Soft-Reset is active. A reset can be applied at any time during a currently running conversion cycle. There are no constraints on reset length. </description>
            </field>
            <field>
              <name>adc01_enable</name>
              <bitRange>[0:0]</bitRange>
              <description>Power-down mode of ADC0 and ADC1: 1: Enable ADC (Power up) 0: Disable ADC (Power-down) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_adc23_static_cfg': 0xFF4017E8-->
          <name>madc_adc23_static_cfg</name>
          <description>Static configuration signals (D2A) to the MAZ IP containing the analog modules ADC0 to ADC3. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:2]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>adc23_reset_n</name>
              <bitRange>[1:1]</bitRange>
              <description>Low active reset of ADC2 and ADC3 and their state machines: 1: Soft-Reset is inactive. 0: Soft-Reset is active. A reset can be applied at any time during a currently running conversion cycle. There are no constraints on reset length. </description>
            </field>
            <field>
              <name>adc23_enable</name>
              <bitRange>[0:0]</bitRange>
              <description>Power-down mode of ADC2 and ADC3: 1: Enable ADC (Power up) 0: Disable ADC (Power-down) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_start': 0xFF4017EC-->
          <name>madc_start</name>
          <description>ADC start register: This register allows to start all ADCs in parallel.   All further configuration is done within the ADC sequencers.   Also ADCs can be started from their sequencers address range. This register is writable but can also be changed by hardware (reset). </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>start_adc3</name>
              <bitRange>[3:3]</bitRange>
              <description>Start ADC3: </description>
            </field>
            <field>
              <name>start_adc2</name>
              <bitRange>[2:2]</bitRange>
              <description>Start ADC2: </description>
            </field>
            <field>
              <name>start_adc1</name>
              <bitRange>[1:1]</bitRange>
              <description>Start ADC1: </description>
            </field>
            <field>
              <name>start_adc0</name>
              <bitRange>[0:0]</bitRange>
              <description>Start ADC0: Setting this bit to 1 starts ADC control state machine for ADC0. It will reset automatically after sampling phase. If it is reset, it can be set for next conversion. If start_adc0 and start_adc1 are set, the next conversion will be started after both ADCs are finished. Otherwise the next conversion will start directly after current conversion of ADC0 is finished. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_deadtime01_delay': 0xFF4017F0-->
          <name>madc_deadtime01_delay</name>
          <description>Dead time delay: Delay in steps of system clock (10ns) between Dead Time EVenT from PWM module and trigger. In case of 2nd DTEVT within delay time, the second DTEVT will be lost. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x000A000A</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>dt1</name>
              <bitRange>[31:16]</bitRange>
              <description>delay for DTEVT[1] </description>
            </field>
            <field>
              <name>dt0</name>
              <bitRange>[15:0]</bitRange>
              <description>delay for DTEVT[0] </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_deadtime23_delay': 0xFF4017F4-->
          <name>madc_deadtime23_delay</name>
          <description>Dead time delay: Delay in steps of system clock (10ns) between Dead Time Event from PWM module and trigger. In case of 2nd Dead Time Event within delay time, the second DTEVT will be lost. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x000A000A</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>dt3</name>
              <bitRange>[31:16]</bitRange>
              <description>delay for DTEVT[3] </description>
            </field>
            <field>
              <name>dt2</name>
              <bitRange>[15:0]</bitRange>
              <description>delay for DTEVT[2] </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_deadtime45_delay': 0xFF4017F8-->
          <name>madc_deadtime45_delay</name>
          <description>Dead time delay: Delay in steps of system clock (10ns) between Dead Time Event from PWM module and trigger. In case of 2nd Dead Time Event within delay time, the second DTEVT will be lost. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000018</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x000A000A</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>dt5</name>
              <bitRange>[31:16]</bitRange>
              <description>delay for DTEVT[5] </description>
            </field>
            <field>
              <name>dt4</name>
              <bitRange>[15:0]</bitRange>
              <description>delay for DTEVT[4] </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>madc_seq0</name>
      <description>madc_seq0</description>
      <baseAddress>0xFF401800</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>256</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>madc_seq0</name>
        <value>45</value>
      </interrupt>
      <registers>
        <register>
          <!--Absolute address of 'madc_seq_cfg': 0xFF401800-->
          <name>madc_seq_cfg</name>
          <description>ADC static configuration </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000FF02</resetValue>
          <resetMask>0x000FFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:20]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>dma_disable</name>
              <bitRange>[19:19]</bitRange>
              <description>Disable DMA 1: DMA is disabled, results are not written to memory, only the current result will be visible in madc_seq_result_current. 0: DMA is enabled, results are written to memory as defined in madc_seq_ms_adr and madc_seq_m*-adr_offset. </description>
            </field>
            <field>
              <name>dma_32bit_adr</name>
              <bitRange>[18:18]</bitRange>
              <description>The DMA engine only uses 32bit addresses and DWord access. This mode wastes memory but speeds up the DMA access by not running read-modify-write cycles. </description>
            </field>
            <field>
              <name>vref_vdd3</name>
              <bitRange>[17:17]</bitRange>
              <description>Reference Select of ADC: 0: use reference from pin VREF_ADC (internally driven C or external reference, s. madc_adc01_static_cfg-vref_buffer_enable) 1: use reference from pin VDD3 (Analog core supply) </description>
            </field>
            <field>
              <name>adcclk_sync</name>
              <bitRange>[16:16]</bitRange>
              <description>0: The rising edges of adcclk are generated independently of the other ADCs. 1: Use adc_clock_phase for defined clock phases in relation to other ADC sequencers </description>
            </field>
            <field>
              <name>adcclk_phase</name>
              <bitRange>[15:8]</bitRange>
              <description>Generation of the rising edge of the adcclk is delayed until the global clk_phase counter matches this value. NOTE: The rising edge of the adcclk ending the first sample period of a triggered measurement is NEVER delayed. </description>
            </field>
            <field>
              <name>adcclk_period</name>
              <bitRange>[7:0]</bitRange>
              <description>Duration of an adcclk period in system clock cycles-1 For odd values the high phase of adcclk is one system clock cycle longer than the low phase. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_tracking_time_mux0': 0xFF401804-->
          <name>madc_seq_tracking_time_mux0</name>
          <description>ADC sample extension for input channel 0 Length of 2nd adcclk in steps of 10ns system clock(~ delay of 3rd adcclk edge). The capacitor inside ADC needs time to be charged depending   on the driving strength of the external signal.   For 12 bit precision, this time should be 9*(Rint+Rext)*C,   with Rint=1kOhm and C=7.5pF. The total formula for this value is: tt_add = ceil((6,75 x Rext/kOhm) + 6,75) - adcclk_period/10ns - 2 Set tt_add=4 if calculated value is smaller 4. The total ADC cycle time results in: tcycle = 14 * adcclk_period + clock_sync_delay (max 1 adcclk_period) + tt_add * 10ns. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000004</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>tt_add</name>
              <bitRange>[7:0]</bitRange>
              <description>Tracking time addon </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_tracking_time_mux1': 0xFF401808-->
          <name>madc_seq_tracking_time_mux1</name>
          <description>ADC sample extension for input channel 1 s. madc_seq_tracking_time_mux0 for details. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000004</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>tt_add</name>
              <bitRange>[7:0]</bitRange>
              <description>Tracking time addon </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_tracking_time_mux2': 0xFF40180C-->
          <name>madc_seq_tracking_time_mux2</name>
          <description>ADC sample extension for input channel 2 s. madc_seq_tracking_time_mux0 for details. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000004</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>tt_add</name>
              <bitRange>[7:0]</bitRange>
              <description>Tracking time addon </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_tracking_time_mux3': 0xFF401810-->
          <name>madc_seq_tracking_time_mux3</name>
          <description>ADC sample extension for input channel 3 s. madc_seq_tracking_time_mux0 for details. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000004</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>tt_add</name>
              <bitRange>[7:0]</bitRange>
              <description>Tracking time addon </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_tracking_time_mux4': 0xFF401814-->
          <name>madc_seq_tracking_time_mux4</name>
          <description>ADC sample extension for input channel 4 s. madc_seq_tracking_time_mux0 for details. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000004</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>tt_add</name>
              <bitRange>[7:0]</bitRange>
              <description>Tracking time addon </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_tracking_time_mux5': 0xFF401818-->
          <name>madc_seq_tracking_time_mux5</name>
          <description>ADC sample extension for input channel 5 s. madc_seq_tracking_time_mux0 for details. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000018</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000004</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>tt_add</name>
              <bitRange>[7:0]</bitRange>
              <description>Tracking time addon </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_tracking_time_mux6': 0xFF40181C-->
          <name>madc_seq_tracking_time_mux6</name>
          <description>ADC sample extension for input channel 6 s. madc_seq_tracking_time_mux0 for details. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000001C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000004</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>tt_add</name>
              <bitRange>[7:0]</bitRange>
              <description>Tracking time addon </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_tracking_time_mux7': 0xFF401820-->
          <name>madc_seq_tracking_time_mux7</name>
          <description>ADC sample extension for input channel 7 s. madc_seq_tracking_time_mux0 for details. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000004</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>tt_add</name>
              <bitRange>[7:0]</bitRange>
              <description>Tracking time addon </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_ms_en': 0xFF401824-->
          <name>madc_seq_ms_en</name>
          <description>Enable measurement configurations: Terminology: A measurement sequence consists of upto 8 measurements. A measurement consists of up to 8 samples. A sample needs at least 14 adcclk cycles (+ tracking time addon). This register enables the measurements belonging to a measurement sequence (up to 8). With the start of a measurement sequence (s. madc_seq_cmd) all sequence configuration registers   (ms_en, ms_adr, m0..m7) are copied to shadow registers that can no longer be changed until   the measurement sequence is finished. All further write accesses to these registers will be valid for the subsequent measurement sequence. The software must ensure, that a set of configuration data for one sequence is completely written   before starting the next sequence. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000024</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>m7</name>
              <bitRange>[7:7]</bitRange>
              <description>1: Enable measurement defined by madc_seq_m7 for the current measurement sequence </description>
            </field>
            <field>
              <name>m6</name>
              <bitRange>[6:6]</bitRange>
              <description>1: Enable measurement defined by madc_seq_m6 for the current measurement sequence </description>
            </field>
            <field>
              <name>m5</name>
              <bitRange>[5:5]</bitRange>
              <description>1: Enable measurement defined by madc_seq_m5 for the current measurement sequence </description>
            </field>
            <field>
              <name>m4</name>
              <bitRange>[4:4]</bitRange>
              <description>1: Enable measurement defined by madc_seq_m4 for the current measurement sequence </description>
            </field>
            <field>
              <name>m3</name>
              <bitRange>[3:3]</bitRange>
              <description>1: Enable measurement defined by madc_seq_m3 for the current measurement sequence </description>
            </field>
            <field>
              <name>m2</name>
              <bitRange>[2:2]</bitRange>
              <description>1: Enable measurement defined by madc_seq_m2 for the current measurement sequence </description>
            </field>
            <field>
              <name>m1</name>
              <bitRange>[1:1]</bitRange>
              <description>1: Enable measurement defined by madc_seq_m1 for the current measurement sequence </description>
            </field>
            <field>
              <name>m0</name>
              <bitRange>[0:0]</bitRange>
              <description>1: Enable measurement defined by madc_seq_m0 for the current measurement sequence </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_ms_baseadr': 0xFF401828-->
          <name>madc_seq_ms_baseadr</name>
          <description>Base address for writing the measurement results. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000028</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFE</resetMask>
          <fields>
            <field>
              <name>adr</name>
              <bitRange>[31:1]</bitRange>
              <description>word (16 bit) aligned address, LSB is ignored In case of madc_seq_cfg-dma_32bit_adr=1, bit 1 will be ignored. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[0:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_m0': 0xFF40182C-->
          <name>madc_seq_m0</name>
          <description>Measurement 0 configuration: A measurement performs (oversample+1) ADC conversions, summing up the results. Every ADC conversion starts with two adcclk periods followed by a sampling phase extension with a minimal duration selected by sext_sel. The sampling phase of the first ADC conversion of the measurement ends when the trigger condition is fulfilled. All subsequent conversions of the measurement do not wait for any trigger condition. The sum consisting of (oversample+1) ADC conversions is written as a 16 bit word to the memory location (byte address) ms_adr + 2*adr_offset. During the measurement the input multiplexer setting (channel selection) is changed to the value mux. Depending on the timing selected by mux_time_sel the channel setting becomes effective for this or the next measurement. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000002C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0001FFFF</resetValue>
          <resetMask>0x0FFFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:28]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>adr_offset</name>
              <bitRange>[27:23]</bitRange>
              <description>Address offset specified in 16 bit words where the sum will be stored In case of madc_seq_cfg-dma_32bit_adr=1, this value will be interpreted as 32-bit address. </description>
            </field>
            <field>
              <name>mux</name>
              <bitRange>[22:20]</bitRange>
              <description>Input channel multiplexer setting The input multiplexer will always be set 1 system clock (10ns) before SOF. It will be reset after sampling to ensure a not-connected phase at the one-hot-coded multiplexer switches. </description>
            </field>
            <field>
              <name>oversample</name>
              <bitRange>[19:17]</bitRange>
              <description>Number of samples minus one to sum for this measurement i.e. 0:sum 1 samples, 1:sum 2 samples, ... </description>
            </field>
            <field>
              <name>trigger</name>
              <bitRange>[16:0]</bitRange>
              <description>Trigger condition for measurement 0x0...0x0FFFF:     condition (ECNT == trigger) 0x10000...0x10005: delayed DTEVT[0..5]==1 0x10006:           GPIO_APP_COUNTER0 = 0 0x10007:           GPIO_APP_COUNTER1 = 0 0x10008:           GPIO_APP_COUNTER2 = 0 0x10009:           posedge of xc_trigger[0] 0x1000a:           posedge of xc_trigger[1] 0x1000b:           negedge of xc_trigger[0] 0x1000c:           negedge of xc_trigger[1] 0x1000d:           posedge of xc_sample[0] 0x1000e:           posedge of xc_sample[1] 0x1000f:           negedge of xc_sample[0] 0x10010:           negedge of xc_sample[1] 0x1FFFF:           no trigger, measurement executes immediately after end of sampling phase Note: Ensure that the time between SOC and trigger event does not exceed ADC_MAXTRACK (10ms). </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_m1': 0xFF401830-->
          <name>madc_seq_m1</name>
          <description>Measurement 1 configuration: s. madc_seq_m0 for details </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000030</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0001FFFF</resetValue>
          <resetMask>0x0FFFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:28]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>adr_offset</name>
              <bitRange>[27:23]</bitRange>
              <description>Address offset specified in 16 bit words where the sum will be stored </description>
            </field>
            <field>
              <name>mux</name>
              <bitRange>[22:20]</bitRange>
              <description>Input channel multiplexer setting </description>
            </field>
            <field>
              <name>oversample</name>
              <bitRange>[19:17]</bitRange>
              <description>Number of samples minus one to sum for this measurement </description>
            </field>
            <field>
              <name>trigger</name>
              <bitRange>[16:0]</bitRange>
              <description>Trigger condition for measurement </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_m2': 0xFF401834-->
          <name>madc_seq_m2</name>
          <description>Measurement 2 configuration: s. madc_seq_m0 for details </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000034</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0001FFFF</resetValue>
          <resetMask>0x0FFFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:28]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>adr_offset</name>
              <bitRange>[27:23]</bitRange>
              <description>Address offset specified in 16 bit words where the sum will be stored </description>
            </field>
            <field>
              <name>mux</name>
              <bitRange>[22:20]</bitRange>
              <description>Input channel multiplexer setting </description>
            </field>
            <field>
              <name>oversample</name>
              <bitRange>[19:17]</bitRange>
              <description>Number of samples minus one to sum for this measurement </description>
            </field>
            <field>
              <name>trigger</name>
              <bitRange>[16:0]</bitRange>
              <description>Trigger condition for measurement </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_m3': 0xFF401838-->
          <name>madc_seq_m3</name>
          <description>Measurement 3 configuration: s. madc_seq_m0 for details </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000038</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0001FFFF</resetValue>
          <resetMask>0x0FFFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:28]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>adr_offset</name>
              <bitRange>[27:23]</bitRange>
              <description>Address offset specified in 16 bit words where the sum will be stored </description>
            </field>
            <field>
              <name>mux</name>
              <bitRange>[22:20]</bitRange>
              <description>Input channel multiplexer setting </description>
            </field>
            <field>
              <name>oversample</name>
              <bitRange>[19:17]</bitRange>
              <description>Number of samples minus one to sum for this measurement </description>
            </field>
            <field>
              <name>trigger</name>
              <bitRange>[16:0]</bitRange>
              <description>Trigger condition for measurement </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_m4': 0xFF40183C-->
          <name>madc_seq_m4</name>
          <description>Measurement 4 configuration: s. madc_seq_m0 for details </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000003C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0001FFFF</resetValue>
          <resetMask>0x0FFFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:28]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>adr_offset</name>
              <bitRange>[27:23]</bitRange>
              <description>Address offset specified in 16 bit words where the sum will be stored </description>
            </field>
            <field>
              <name>mux</name>
              <bitRange>[22:20]</bitRange>
              <description>Input channel multiplexer setting </description>
            </field>
            <field>
              <name>oversample</name>
              <bitRange>[19:17]</bitRange>
              <description>Number of samples minus one to sum for this measurement </description>
            </field>
            <field>
              <name>trigger</name>
              <bitRange>[16:0]</bitRange>
              <description>Trigger condition for measurement </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_m5': 0xFF401840-->
          <name>madc_seq_m5</name>
          <description>Measurement 5 configuration: s. madc_seq_m0 for details </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000040</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0001FFFF</resetValue>
          <resetMask>0x0FFFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:28]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>adr_offset</name>
              <bitRange>[27:23]</bitRange>
              <description>Address offset specified in 16 bit words where the sum will be stored </description>
            </field>
            <field>
              <name>mux</name>
              <bitRange>[22:20]</bitRange>
              <description>Input channel multiplexer setting </description>
            </field>
            <field>
              <name>oversample</name>
              <bitRange>[19:17]</bitRange>
              <description>Number of samples minus one to sum for this measurement </description>
            </field>
            <field>
              <name>trigger</name>
              <bitRange>[16:0]</bitRange>
              <description>Trigger condition for measurement </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_m6': 0xFF401844-->
          <name>madc_seq_m6</name>
          <description>Measurement 6 configuration: s. madc_seq_m0 for details </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000044</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0001FFFF</resetValue>
          <resetMask>0x0FFFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:28]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>adr_offset</name>
              <bitRange>[27:23]</bitRange>
              <description>Address offset specified in 16 bit words where the sum will be stored </description>
            </field>
            <field>
              <name>mux</name>
              <bitRange>[22:20]</bitRange>
              <description>Input channel multiplexer setting </description>
            </field>
            <field>
              <name>oversample</name>
              <bitRange>[19:17]</bitRange>
              <description>Number of samples minus one to sum for this measurement </description>
            </field>
            <field>
              <name>trigger</name>
              <bitRange>[16:0]</bitRange>
              <description>Trigger condition for measurement </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_m7': 0xFF401848-->
          <name>madc_seq_m7</name>
          <description>Measurement 7 configuration: s. madc_seq_m0 for details </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000048</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0001FFFF</resetValue>
          <resetMask>0x0FFFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:28]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>adr_offset</name>
              <bitRange>[27:23]</bitRange>
              <description>Address offset specified in 16 bit words where the sum will be stored </description>
            </field>
            <field>
              <name>mux</name>
              <bitRange>[22:20]</bitRange>
              <description>Input channel multiplexer setting </description>
            </field>
            <field>
              <name>oversample</name>
              <bitRange>[19:17]</bitRange>
              <description>Number of samples minus one to sum for this measurement </description>
            </field>
            <field>
              <name>trigger</name>
              <bitRange>[16:0]</bitRange>
              <description>Trigger condition for measurement </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_cmd': 0xFF40184C-->
          <name>madc_seq_cmd</name>
          <description>Command Register: Run or abort processing the measurement sequence. This register is writable but can also be changed by hardware (reset). </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000004C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>debug</name>
              <bitRange>[3:3]</bitRange>
              <description>Debug mode: 0: ADC is controlled by measurement sequencer 1: ADC is directly controlled by madc_seq_debug register. </description>
            </field>
            <field>
              <name>reset</name>
              <bitRange>[2:2]</bitRange>
              <description>Reset this ADC-sequencer: In comparision to madc_adc01_static_cfg-adc01_reset_n, which resets a pair of ADC channels (e.g. ADC0 and ADC1), this bit only resets this single ADC-sequencer. The analog part of ADC will not be reset, but all registers of the controller (including result registers, which will not be reset in case of run=stop). </description>
            </field>
            <field>
              <name>continuous</name>
              <bitRange>[1:1]</bitRange>
              <description>Continuous mode: 0: run starts single conversion. All measurements enabled in madc_m_en are executed once. 1: start continuous conversion. All measurments enabled are executed repeatedly until stopped by resetting the run bit. </description>
            </field>
            <field>
              <name>run</name>
              <bitRange>[0:0]</bitRange>
              <description>Run bit: This bit can be set here or at madc_start to start all ADCs simultaneously. This bit can be reset here or automatically by hardware, when measurement sequence is finished. 1 : start measurement sequence. 0 : stop measurement sequence. Any conversion in progress is aborted and ADC returns to idle state with adcclk=0 and adc_soc=0. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_status': 0xFF401850-->
          <name>madc_seq_status</name>
          <description>Status of the current measurement sequence in progress </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000050</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000001FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:9]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>adc_half_clock_cycle</name>
              <bitRange>[8:4]</bitRange>
              <description>0..30: current adcclk half clock cycle, 0 when adc is idle </description>
            </field>
            <field>
              <name>m_nr</name>
              <bitRange>[3:0]</bitRange>
              <description>Number of measurement configuration: 0..7: currently active measurement configuration, 8 when the ADC is idle </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_result_current': 0xFF401854-->
          <name>madc_seq_result_current</name>
          <description>Result register of current measurement </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000054</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x80077FFF</resetMask>
          <fields>
            <field>
              <name>valid</name>
              <bitRange>[31:31]</bitRange>
              <description>result in register is finally calculated (val shows intermediate values in case of oversample&gt;0) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[30:19]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>mnr</name>
              <bitRange>[18:16]</bitRange>
              <description>number of measurement configuration </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[15:15]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[14:0]</bitRange>
              <description>result of measurement </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_result_last': 0xFF401858-->
          <name>madc_seq_result_last</name>
          <description>Result register of last measurement </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000058</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x80077FFF</resetMask>
          <fields>
            <field>
              <name>valid</name>
              <bitRange>[31:31]</bitRange>
              <description>result in register is finally calculated (val shows intermediate values in case of oversample&gt;0) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[30:19]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>mnr</name>
              <bitRange>[18:16]</bitRange>
              <description>number of measurement configuration </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[15:15]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[14:0]</bitRange>
              <description>result of measurement </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_debug': 0xFF40185C-->
          <name>madc_seq_debug</name>
          <description>Debug Mode register: If cmd-debug is enabled, this register directly controls inputs of both ADCs. Output data of both ADCs will still be at data0 and data1. In debug mode, a software reset (cfg-reset_n) will not influence these values (only directly signal ADC_NRES). </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000005C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000003FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:10]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>adc_set_mux7</name>
              <bitRange>[9:9]</bitRange>
              <description>ADC0_SET_MUX7 signal </description>
            </field>
            <field>
              <name>adc_set_mux6</name>
              <bitRange>[8:8]</bitRange>
              <description>ADC0_SET_MUX6 signal </description>
            </field>
            <field>
              <name>adc_set_mux5</name>
              <bitRange>[7:7]</bitRange>
              <description>ADC0_SET_MUX5 signal </description>
            </field>
            <field>
              <name>adc_set_mux4</name>
              <bitRange>[6:6]</bitRange>
              <description>ADC0_SET_MUX4 signal </description>
            </field>
            <field>
              <name>adc_set_mux3</name>
              <bitRange>[5:5]</bitRange>
              <description>ADC0_SET_MUX3 signal </description>
            </field>
            <field>
              <name>adc_set_mux2</name>
              <bitRange>[4:4]</bitRange>
              <description>ADC0_SET_MUX2 signal </description>
            </field>
            <field>
              <name>adc_set_mux1</name>
              <bitRange>[3:3]</bitRange>
              <description>ADC0_SET_MUX1 signal </description>
            </field>
            <field>
              <name>adc_set_mux0</name>
              <bitRange>[2:2]</bitRange>
              <description>ADC0_SET_MUX0 signal </description>
            </field>
            <field>
              <name>adc_soc</name>
              <bitRange>[1:1]</bitRange>
              <description>ADC0_SOC signal </description>
            </field>
            <field>
              <name>adc_clk</name>
              <bitRange>[0:0]</bitRange>
              <description>ADC0 is sampling data. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_irq_raw': 0xFF401870-->
          <name>madc_seq_irq_raw</name>
          <description>Raw IRQ: Read access shows status of unmasked IRQs. IRQs are set automatically and reset by writing to this register: Write access with '1' resets the appropriate IRQ (if event irq, reset status irqs at their source). Write access with '0' does not influence this bit. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000070</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000007FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:11]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>dma_hresp</name>
              <bitRange>[10:10]</bitRange>
              <description>AHBL hresp signal received </description>
            </field>
            <field>
              <name>dma_overrun</name>
              <bitRange>[9:9]</bitRange>
              <description>AHBL write buffer overrun result not written due to AHBL busy </description>
            </field>
            <field>
              <name>seq_cmpl</name>
              <bitRange>[8:8]</bitRange>
              <description>measurement sequence completed </description>
            </field>
            <field>
              <name>m7_cmpl</name>
              <bitRange>[7:7]</bitRange>
              <description>event: measurement 7 completed </description>
            </field>
            <field>
              <name>m6_cmpl</name>
              <bitRange>[6:6]</bitRange>
              <description>event: measurement 6 completed </description>
            </field>
            <field>
              <name>m5_cmpl</name>
              <bitRange>[5:5]</bitRange>
              <description>event: measurement 5 completed </description>
            </field>
            <field>
              <name>m4_cmpl</name>
              <bitRange>[4:4]</bitRange>
              <description>event: measurement 4 completed </description>
            </field>
            <field>
              <name>m3_cmpl</name>
              <bitRange>[3:3]</bitRange>
              <description>event: measurement 3 completed </description>
            </field>
            <field>
              <name>m2_cmpl</name>
              <bitRange>[2:2]</bitRange>
              <description>event: measurement 2 completed </description>
            </field>
            <field>
              <name>m1_cmpl</name>
              <bitRange>[1:1]</bitRange>
              <description>event: measurement 1 completed </description>
            </field>
            <field>
              <name>m0_cmpl</name>
              <bitRange>[0:0]</bitRange>
              <description>event: measurement 0 completed </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_irq_masked': 0xFF401874-->
          <name>madc_seq_irq_masked</name>
          <description>Masked IRQ: Shows status of masked IRQs (as connected to ARM/xPIC). </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000074</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000007FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:11]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>dma_hresp</name>
              <bitRange>[10:10]</bitRange>
              <description>AHBL hresp signal received </description>
            </field>
            <field>
              <name>dma_overrun</name>
              <bitRange>[9:9]</bitRange>
              <description>AHBL write buffer overrun result not written due to AHBL busy </description>
            </field>
            <field>
              <name>seq_cmpl</name>
              <bitRange>[8:8]</bitRange>
              <description>measurement sequence completed </description>
            </field>
            <field>
              <name>m7_cmpl</name>
              <bitRange>[7:7]</bitRange>
              <description>event: measurement 7 completed </description>
            </field>
            <field>
              <name>m6_cmpl</name>
              <bitRange>[6:6]</bitRange>
              <description>event: measurement 6 completed </description>
            </field>
            <field>
              <name>m5_cmpl</name>
              <bitRange>[5:5]</bitRange>
              <description>event: measurement 5 completed </description>
            </field>
            <field>
              <name>m4_cmpl</name>
              <bitRange>[4:4]</bitRange>
              <description>event: measurement 4 completed </description>
            </field>
            <field>
              <name>m3_cmpl</name>
              <bitRange>[3:3]</bitRange>
              <description>event: measurement 3 completed </description>
            </field>
            <field>
              <name>m2_cmpl</name>
              <bitRange>[2:2]</bitRange>
              <description>event: measurement 2 completed </description>
            </field>
            <field>
              <name>m1_cmpl</name>
              <bitRange>[1:1]</bitRange>
              <description>event: measurement 1 completed </description>
            </field>
            <field>
              <name>m0_cmpl</name>
              <bitRange>[0:0]</bitRange>
              <description>event: measurement 0 completed </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_irq_mask_set': 0xFF401878-->
          <name>madc_seq_irq_mask_set</name>
          <description>IRQ enable mask: The IRQ mask enables interrupt requests for corresponding interrupt sources.   As its bits might be changed by different software tasks,   the IRQ mask register is not writable directly, but by set and reset masks: Write access with '1' sets interrupt mask bit. Write access with '0' does not influence this bit. Read access shows actual interrupt mask. Attention: Before activating interrupt mask, delete old pending interrupts by writing the same value to adr_mpwm_irq_raw. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000078</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000007FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:11]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>dma_hresp</name>
              <bitRange>[10:10]</bitRange>
              <description>AHBL hresp signal received </description>
            </field>
            <field>
              <name>dma_overrun</name>
              <bitRange>[9:9]</bitRange>
              <description>AHBL write buffer overrun result not written due to AHBL busy </description>
            </field>
            <field>
              <name>seq_cmpl</name>
              <bitRange>[8:8]</bitRange>
              <description>measurement sequence completed </description>
            </field>
            <field>
              <name>m7_cmpl</name>
              <bitRange>[7:7]</bitRange>
              <description>event: measurement 7 completed </description>
            </field>
            <field>
              <name>m6_cmpl</name>
              <bitRange>[6:6]</bitRange>
              <description>event: measurement 6 completed </description>
            </field>
            <field>
              <name>m5_cmpl</name>
              <bitRange>[5:5]</bitRange>
              <description>event: measurement 5 completed </description>
            </field>
            <field>
              <name>m4_cmpl</name>
              <bitRange>[4:4]</bitRange>
              <description>event: measurement 4 completed </description>
            </field>
            <field>
              <name>m3_cmpl</name>
              <bitRange>[3:3]</bitRange>
              <description>event: measurement 3 completed </description>
            </field>
            <field>
              <name>m2_cmpl</name>
              <bitRange>[2:2]</bitRange>
              <description>event: measurement 2 completed </description>
            </field>
            <field>
              <name>m1_cmpl</name>
              <bitRange>[1:1]</bitRange>
              <description>event: measurement 1 completed </description>
            </field>
            <field>
              <name>m0_cmpl</name>
              <bitRange>[0:0]</bitRange>
              <description>event: measurement 0 completed </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_irq_mask_reset': 0xFF40187C-->
          <name>madc_seq_irq_mask_reset</name>
          <description>IRQ disable mask: This is the corresponding reset mask to disable interrupt requests for corresponding interrupt sources: Write access with '1' resets interrupt mask bit. Write access with '0' does not influence this bit. Read access shows bit number of the lowest active bit in IRQ_MASKED or MAX+1 when no bit is set. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000007C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000007FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:11]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>dma_hresp</name>
              <bitRange>[10:10]</bitRange>
              <description>AHBL hresp signal received </description>
            </field>
            <field>
              <name>dma_overrun</name>
              <bitRange>[9:9]</bitRange>
              <description>AHBL write buffer overrun result not written due to AHBL busy </description>
            </field>
            <field>
              <name>seq_cmpl</name>
              <bitRange>[8:8]</bitRange>
              <description>measurement sequence completed </description>
            </field>
            <field>
              <name>m7_cmpl</name>
              <bitRange>[7:7]</bitRange>
              <description>event: measurement 7 completed </description>
            </field>
            <field>
              <name>m6_cmpl</name>
              <bitRange>[6:6]</bitRange>
              <description>event: measurement 6 completed </description>
            </field>
            <field>
              <name>m5_cmpl</name>
              <bitRange>[5:5]</bitRange>
              <description>event: measurement 5 completed </description>
            </field>
            <field>
              <name>m4_cmpl</name>
              <bitRange>[4:4]</bitRange>
              <description>event: measurement 4 completed </description>
            </field>
            <field>
              <name>m3_cmpl</name>
              <bitRange>[3:3]</bitRange>
              <description>event: measurement 3 completed </description>
            </field>
            <field>
              <name>m2_cmpl</name>
              <bitRange>[2:2]</bitRange>
              <description>event: measurement 2 completed </description>
            </field>
            <field>
              <name>m1_cmpl</name>
              <bitRange>[1:1]</bitRange>
              <description>event: measurement 1 completed </description>
            </field>
            <field>
              <name>m0_cmpl</name>
              <bitRange>[0:0]</bitRange>
              <description>event: measurement 0 completed </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>madc_seq1</name>
      <description>madc_seq1</description>
      <baseAddress>0xFF401900</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>256</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>madc_seq1</name>
        <value>46</value>
      </interrupt>
      <registers>
        <register>
          <!--Absolute address of 'madc_seq_cfg': 0xFF401900-->
          <name>madc_seq_cfg</name>
          <description>ADC static configuration </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000FF02</resetValue>
          <resetMask>0x000FFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:20]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>dma_disable</name>
              <bitRange>[19:19]</bitRange>
              <description>Disable DMA 1: DMA is disabled, results are not written to memory, only the current result will be visible in madc_seq_result_current. 0: DMA is enabled, results are written to memory as defined in madc_seq_ms_adr and madc_seq_m*-adr_offset. </description>
            </field>
            <field>
              <name>dma_32bit_adr</name>
              <bitRange>[18:18]</bitRange>
              <description>The DMA engine only uses 32bit addresses and DWord access. This mode wastes memory but speeds up the DMA access by not running read-modify-write cycles. </description>
            </field>
            <field>
              <name>vref_vdd3</name>
              <bitRange>[17:17]</bitRange>
              <description>Reference Select of ADC: 0: use reference from pin VREF_ADC (internally driven C or external reference, s. madc_adc01_static_cfg-vref_buffer_enable) 1: use reference from pin VDD3 (Analog core supply) </description>
            </field>
            <field>
              <name>adcclk_sync</name>
              <bitRange>[16:16]</bitRange>
              <description>0: The rising edges of adcclk are generated independently of the other ADCs. 1: Use adc_clock_phase for defined clock phases in relation to other ADC sequencers </description>
            </field>
            <field>
              <name>adcclk_phase</name>
              <bitRange>[15:8]</bitRange>
              <description>Generation of the rising edge of the adcclk is delayed until the global clk_phase counter matches this value. NOTE: The rising edge of the adcclk ending the first sample period of a triggered measurement is NEVER delayed. </description>
            </field>
            <field>
              <name>adcclk_period</name>
              <bitRange>[7:0]</bitRange>
              <description>Duration of an adcclk period in system clock cycles-1 For odd values the high phase of adcclk is one system clock cycle longer than the low phase. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_tracking_time_mux0': 0xFF401904-->
          <name>madc_seq_tracking_time_mux0</name>
          <description>ADC sample extension for input channel 0 Length of 2nd adcclk in steps of 10ns system clock(~ delay of 3rd adcclk edge). The capacitor inside ADC needs time to be charged depending   on the driving strength of the external signal.   For 12 bit precision, this time should be 9*(Rint+Rext)*C,   with Rint=1kOhm and C=7.5pF. The total formula for this value is: tt_add = ceil((6,75 x Rext/kOhm) + 6,75) - adcclk_period/10ns - 2 Set tt_add=4 if calculated value is smaller 4. The total ADC cycle time results in: tcycle = 14 * adcclk_period + clock_sync_delay (max 1 adcclk_period) + tt_add * 10ns. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000004</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>tt_add</name>
              <bitRange>[7:0]</bitRange>
              <description>Tracking time addon </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_tracking_time_mux1': 0xFF401908-->
          <name>madc_seq_tracking_time_mux1</name>
          <description>ADC sample extension for input channel 1 s. madc_seq_tracking_time_mux0 for details. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000004</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>tt_add</name>
              <bitRange>[7:0]</bitRange>
              <description>Tracking time addon </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_tracking_time_mux2': 0xFF40190C-->
          <name>madc_seq_tracking_time_mux2</name>
          <description>ADC sample extension for input channel 2 s. madc_seq_tracking_time_mux0 for details. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000004</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>tt_add</name>
              <bitRange>[7:0]</bitRange>
              <description>Tracking time addon </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_tracking_time_mux3': 0xFF401910-->
          <name>madc_seq_tracking_time_mux3</name>
          <description>ADC sample extension for input channel 3 s. madc_seq_tracking_time_mux0 for details. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000004</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>tt_add</name>
              <bitRange>[7:0]</bitRange>
              <description>Tracking time addon </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_tracking_time_mux4': 0xFF401914-->
          <name>madc_seq_tracking_time_mux4</name>
          <description>ADC sample extension for input channel 4 s. madc_seq_tracking_time_mux0 for details. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000004</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>tt_add</name>
              <bitRange>[7:0]</bitRange>
              <description>Tracking time addon </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_tracking_time_mux5': 0xFF401918-->
          <name>madc_seq_tracking_time_mux5</name>
          <description>ADC sample extension for input channel 5 s. madc_seq_tracking_time_mux0 for details. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000018</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000004</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>tt_add</name>
              <bitRange>[7:0]</bitRange>
              <description>Tracking time addon </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_tracking_time_mux6': 0xFF40191C-->
          <name>madc_seq_tracking_time_mux6</name>
          <description>ADC sample extension for input channel 6 s. madc_seq_tracking_time_mux0 for details. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000001C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000004</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>tt_add</name>
              <bitRange>[7:0]</bitRange>
              <description>Tracking time addon </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_tracking_time_mux7': 0xFF401920-->
          <name>madc_seq_tracking_time_mux7</name>
          <description>ADC sample extension for input channel 7 s. madc_seq_tracking_time_mux0 for details. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000004</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>tt_add</name>
              <bitRange>[7:0]</bitRange>
              <description>Tracking time addon </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_ms_en': 0xFF401924-->
          <name>madc_seq_ms_en</name>
          <description>Enable measurement configurations: Terminology: A measurement sequence consists of upto 8 measurements. A measurement consists of up to 8 samples. A sample needs at least 14 adcclk cycles (+ tracking time addon). This register enables the measurements belonging to a measurement sequence (up to 8). With the start of a measurement sequence (s. madc_seq_cmd) all sequence configuration registers   (ms_en, ms_adr, m0..m7) are copied to shadow registers that can no longer be changed until   the measurement sequence is finished. All further write accesses to these registers will be valid for the subsequent measurement sequence. The software must ensure, that a set of configuration data for one sequence is completely written   before starting the next sequence. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000024</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>m7</name>
              <bitRange>[7:7]</bitRange>
              <description>1: Enable measurement defined by madc_seq_m7 for the current measurement sequence </description>
            </field>
            <field>
              <name>m6</name>
              <bitRange>[6:6]</bitRange>
              <description>1: Enable measurement defined by madc_seq_m6 for the current measurement sequence </description>
            </field>
            <field>
              <name>m5</name>
              <bitRange>[5:5]</bitRange>
              <description>1: Enable measurement defined by madc_seq_m5 for the current measurement sequence </description>
            </field>
            <field>
              <name>m4</name>
              <bitRange>[4:4]</bitRange>
              <description>1: Enable measurement defined by madc_seq_m4 for the current measurement sequence </description>
            </field>
            <field>
              <name>m3</name>
              <bitRange>[3:3]</bitRange>
              <description>1: Enable measurement defined by madc_seq_m3 for the current measurement sequence </description>
            </field>
            <field>
              <name>m2</name>
              <bitRange>[2:2]</bitRange>
              <description>1: Enable measurement defined by madc_seq_m2 for the current measurement sequence </description>
            </field>
            <field>
              <name>m1</name>
              <bitRange>[1:1]</bitRange>
              <description>1: Enable measurement defined by madc_seq_m1 for the current measurement sequence </description>
            </field>
            <field>
              <name>m0</name>
              <bitRange>[0:0]</bitRange>
              <description>1: Enable measurement defined by madc_seq_m0 for the current measurement sequence </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_ms_baseadr': 0xFF401928-->
          <name>madc_seq_ms_baseadr</name>
          <description>Base address for writing the measurement results. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000028</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFE</resetMask>
          <fields>
            <field>
              <name>adr</name>
              <bitRange>[31:1]</bitRange>
              <description>word (16 bit) aligned address, LSB is ignored In case of madc_seq_cfg-dma_32bit_adr=1, bit 1 will be ignored. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[0:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_m0': 0xFF40192C-->
          <name>madc_seq_m0</name>
          <description>Measurement 0 configuration: A measurement performs (oversample+1) ADC conversions, summing up the results. Every ADC conversion starts with two adcclk periods followed by a sampling phase extension with a minimal duration selected by sext_sel. The sampling phase of the first ADC conversion of the measurement ends when the trigger condition is fulfilled. All subsequent conversions of the measurement do not wait for any trigger condition. The sum consisting of (oversample+1) ADC conversions is written as a 16 bit word to the memory location (byte address) ms_adr + 2*adr_offset. During the measurement the input multiplexer setting (channel selection) is changed to the value mux. Depending on the timing selected by mux_time_sel the channel setting becomes effective for this or the next measurement. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000002C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0001FFFF</resetValue>
          <resetMask>0x0FFFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:28]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>adr_offset</name>
              <bitRange>[27:23]</bitRange>
              <description>Address offset specified in 16 bit words where the sum will be stored In case of madc_seq_cfg-dma_32bit_adr=1, this value will be interpreted as 32-bit address. </description>
            </field>
            <field>
              <name>mux</name>
              <bitRange>[22:20]</bitRange>
              <description>Input channel multiplexer setting The input multiplexer will always be set 1 system clock (10ns) before SOF. It will be reset after sampling to ensure a not-connected phase at the one-hot-coded multiplexer switches. </description>
            </field>
            <field>
              <name>oversample</name>
              <bitRange>[19:17]</bitRange>
              <description>Number of samples minus one to sum for this measurement i.e. 0:sum 1 samples, 1:sum 2 samples, ... </description>
            </field>
            <field>
              <name>trigger</name>
              <bitRange>[16:0]</bitRange>
              <description>Trigger condition for measurement 0x0...0x0FFFF:     condition (ECNT == trigger) 0x10000...0x10005: delayed DTEVT[0..5]==1 0x10006:           GPIO_APP_COUNTER0 = 0 0x10007:           GPIO_APP_COUNTER1 = 0 0x10008:           GPIO_APP_COUNTER2 = 0 0x10009:           posedge of xc_trigger[0] 0x1000a:           posedge of xc_trigger[1] 0x1000b:           negedge of xc_trigger[0] 0x1000c:           negedge of xc_trigger[1] 0x1000d:           posedge of xc_sample[0] 0x1000e:           posedge of xc_sample[1] 0x1000f:           negedge of xc_sample[0] 0x10010:           negedge of xc_sample[1] 0x1FFFF:           no trigger, measurement executes immediately after end of sampling phase Note: Ensure that the time between SOC and trigger event does not exceed ADC_MAXTRACK (10ms). </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_m1': 0xFF401930-->
          <name>madc_seq_m1</name>
          <description>Measurement 1 configuration: s. madc_seq_m0 for details </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000030</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0001FFFF</resetValue>
          <resetMask>0x0FFFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:28]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>adr_offset</name>
              <bitRange>[27:23]</bitRange>
              <description>Address offset specified in 16 bit words where the sum will be stored </description>
            </field>
            <field>
              <name>mux</name>
              <bitRange>[22:20]</bitRange>
              <description>Input channel multiplexer setting </description>
            </field>
            <field>
              <name>oversample</name>
              <bitRange>[19:17]</bitRange>
              <description>Number of samples minus one to sum for this measurement </description>
            </field>
            <field>
              <name>trigger</name>
              <bitRange>[16:0]</bitRange>
              <description>Trigger condition for measurement </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_m2': 0xFF401934-->
          <name>madc_seq_m2</name>
          <description>Measurement 2 configuration: s. madc_seq_m0 for details </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000034</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0001FFFF</resetValue>
          <resetMask>0x0FFFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:28]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>adr_offset</name>
              <bitRange>[27:23]</bitRange>
              <description>Address offset specified in 16 bit words where the sum will be stored </description>
            </field>
            <field>
              <name>mux</name>
              <bitRange>[22:20]</bitRange>
              <description>Input channel multiplexer setting </description>
            </field>
            <field>
              <name>oversample</name>
              <bitRange>[19:17]</bitRange>
              <description>Number of samples minus one to sum for this measurement </description>
            </field>
            <field>
              <name>trigger</name>
              <bitRange>[16:0]</bitRange>
              <description>Trigger condition for measurement </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_m3': 0xFF401938-->
          <name>madc_seq_m3</name>
          <description>Measurement 3 configuration: s. madc_seq_m0 for details </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000038</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0001FFFF</resetValue>
          <resetMask>0x0FFFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:28]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>adr_offset</name>
              <bitRange>[27:23]</bitRange>
              <description>Address offset specified in 16 bit words where the sum will be stored </description>
            </field>
            <field>
              <name>mux</name>
              <bitRange>[22:20]</bitRange>
              <description>Input channel multiplexer setting </description>
            </field>
            <field>
              <name>oversample</name>
              <bitRange>[19:17]</bitRange>
              <description>Number of samples minus one to sum for this measurement </description>
            </field>
            <field>
              <name>trigger</name>
              <bitRange>[16:0]</bitRange>
              <description>Trigger condition for measurement </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_m4': 0xFF40193C-->
          <name>madc_seq_m4</name>
          <description>Measurement 4 configuration: s. madc_seq_m0 for details </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000003C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0001FFFF</resetValue>
          <resetMask>0x0FFFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:28]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>adr_offset</name>
              <bitRange>[27:23]</bitRange>
              <description>Address offset specified in 16 bit words where the sum will be stored </description>
            </field>
            <field>
              <name>mux</name>
              <bitRange>[22:20]</bitRange>
              <description>Input channel multiplexer setting </description>
            </field>
            <field>
              <name>oversample</name>
              <bitRange>[19:17]</bitRange>
              <description>Number of samples minus one to sum for this measurement </description>
            </field>
            <field>
              <name>trigger</name>
              <bitRange>[16:0]</bitRange>
              <description>Trigger condition for measurement </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_m5': 0xFF401940-->
          <name>madc_seq_m5</name>
          <description>Measurement 5 configuration: s. madc_seq_m0 for details </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000040</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0001FFFF</resetValue>
          <resetMask>0x0FFFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:28]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>adr_offset</name>
              <bitRange>[27:23]</bitRange>
              <description>Address offset specified in 16 bit words where the sum will be stored </description>
            </field>
            <field>
              <name>mux</name>
              <bitRange>[22:20]</bitRange>
              <description>Input channel multiplexer setting </description>
            </field>
            <field>
              <name>oversample</name>
              <bitRange>[19:17]</bitRange>
              <description>Number of samples minus one to sum for this measurement </description>
            </field>
            <field>
              <name>trigger</name>
              <bitRange>[16:0]</bitRange>
              <description>Trigger condition for measurement </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_m6': 0xFF401944-->
          <name>madc_seq_m6</name>
          <description>Measurement 6 configuration: s. madc_seq_m0 for details </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000044</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0001FFFF</resetValue>
          <resetMask>0x0FFFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:28]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>adr_offset</name>
              <bitRange>[27:23]</bitRange>
              <description>Address offset specified in 16 bit words where the sum will be stored </description>
            </field>
            <field>
              <name>mux</name>
              <bitRange>[22:20]</bitRange>
              <description>Input channel multiplexer setting </description>
            </field>
            <field>
              <name>oversample</name>
              <bitRange>[19:17]</bitRange>
              <description>Number of samples minus one to sum for this measurement </description>
            </field>
            <field>
              <name>trigger</name>
              <bitRange>[16:0]</bitRange>
              <description>Trigger condition for measurement </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_m7': 0xFF401948-->
          <name>madc_seq_m7</name>
          <description>Measurement 7 configuration: s. madc_seq_m0 for details </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000048</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0001FFFF</resetValue>
          <resetMask>0x0FFFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:28]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>adr_offset</name>
              <bitRange>[27:23]</bitRange>
              <description>Address offset specified in 16 bit words where the sum will be stored </description>
            </field>
            <field>
              <name>mux</name>
              <bitRange>[22:20]</bitRange>
              <description>Input channel multiplexer setting </description>
            </field>
            <field>
              <name>oversample</name>
              <bitRange>[19:17]</bitRange>
              <description>Number of samples minus one to sum for this measurement </description>
            </field>
            <field>
              <name>trigger</name>
              <bitRange>[16:0]</bitRange>
              <description>Trigger condition for measurement </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_cmd': 0xFF40194C-->
          <name>madc_seq_cmd</name>
          <description>Command Register: Run or abort processing the measurement sequence. This register is writable but can also be changed by hardware (reset). </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000004C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>debug</name>
              <bitRange>[3:3]</bitRange>
              <description>Debug mode: 0: ADC is controlled by measurement sequencer 1: ADC is directly controlled by madc_seq_debug register. </description>
            </field>
            <field>
              <name>reset</name>
              <bitRange>[2:2]</bitRange>
              <description>Reset this ADC-sequencer: In comparision to madc_adc01_static_cfg-adc01_reset_n, which resets a pair of ADC channels (e.g. ADC0 and ADC1), this bit only resets this single ADC-sequencer. The analog part of ADC will not be reset, but all registers of the controller (including result registers, which will not be reset in case of run=stop). </description>
            </field>
            <field>
              <name>continuous</name>
              <bitRange>[1:1]</bitRange>
              <description>Continuous mode: 0: run starts single conversion. All measurements enabled in madc_m_en are executed once. 1: start continuous conversion. All measurments enabled are executed repeatedly until stopped by resetting the run bit. </description>
            </field>
            <field>
              <name>run</name>
              <bitRange>[0:0]</bitRange>
              <description>Run bit: This bit can be set here or at madc_start to start all ADCs simultaneously. This bit can be reset here or automatically by hardware, when measurement sequence is finished. 1 : start measurement sequence. 0 : stop measurement sequence. Any conversion in progress is aborted and ADC returns to idle state with adcclk=0 and adc_soc=0. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_status': 0xFF401950-->
          <name>madc_seq_status</name>
          <description>Status of the current measurement sequence in progress </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000050</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000001FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:9]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>adc_half_clock_cycle</name>
              <bitRange>[8:4]</bitRange>
              <description>0..30: current adcclk half clock cycle, 0 when adc is idle </description>
            </field>
            <field>
              <name>m_nr</name>
              <bitRange>[3:0]</bitRange>
              <description>Number of measurement configuration: 0..7: currently active measurement configuration, 8 when the ADC is idle </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_result_current': 0xFF401954-->
          <name>madc_seq_result_current</name>
          <description>Result register of current measurement </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000054</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x80077FFF</resetMask>
          <fields>
            <field>
              <name>valid</name>
              <bitRange>[31:31]</bitRange>
              <description>result in register is finally calculated (val shows intermediate values in case of oversample&gt;0) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[30:19]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>mnr</name>
              <bitRange>[18:16]</bitRange>
              <description>number of measurement configuration </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[15:15]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[14:0]</bitRange>
              <description>result of measurement </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_result_last': 0xFF401958-->
          <name>madc_seq_result_last</name>
          <description>Result register of last measurement </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000058</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x80077FFF</resetMask>
          <fields>
            <field>
              <name>valid</name>
              <bitRange>[31:31]</bitRange>
              <description>result in register is finally calculated (val shows intermediate values in case of oversample&gt;0) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[30:19]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>mnr</name>
              <bitRange>[18:16]</bitRange>
              <description>number of measurement configuration </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[15:15]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[14:0]</bitRange>
              <description>result of measurement </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_debug': 0xFF40195C-->
          <name>madc_seq_debug</name>
          <description>Debug Mode register: If cmd-debug is enabled, this register directly controls inputs of both ADCs. Output data of both ADCs will still be at data0 and data1. In debug mode, a software reset (cfg-reset_n) will not influence these values (only directly signal ADC_NRES). </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000005C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000003FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:10]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>adc_set_mux7</name>
              <bitRange>[9:9]</bitRange>
              <description>ADC0_SET_MUX7 signal </description>
            </field>
            <field>
              <name>adc_set_mux6</name>
              <bitRange>[8:8]</bitRange>
              <description>ADC0_SET_MUX6 signal </description>
            </field>
            <field>
              <name>adc_set_mux5</name>
              <bitRange>[7:7]</bitRange>
              <description>ADC0_SET_MUX5 signal </description>
            </field>
            <field>
              <name>adc_set_mux4</name>
              <bitRange>[6:6]</bitRange>
              <description>ADC0_SET_MUX4 signal </description>
            </field>
            <field>
              <name>adc_set_mux3</name>
              <bitRange>[5:5]</bitRange>
              <description>ADC0_SET_MUX3 signal </description>
            </field>
            <field>
              <name>adc_set_mux2</name>
              <bitRange>[4:4]</bitRange>
              <description>ADC0_SET_MUX2 signal </description>
            </field>
            <field>
              <name>adc_set_mux1</name>
              <bitRange>[3:3]</bitRange>
              <description>ADC0_SET_MUX1 signal </description>
            </field>
            <field>
              <name>adc_set_mux0</name>
              <bitRange>[2:2]</bitRange>
              <description>ADC0_SET_MUX0 signal </description>
            </field>
            <field>
              <name>adc_soc</name>
              <bitRange>[1:1]</bitRange>
              <description>ADC0_SOC signal </description>
            </field>
            <field>
              <name>adc_clk</name>
              <bitRange>[0:0]</bitRange>
              <description>ADC0 is sampling data. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_irq_raw': 0xFF401970-->
          <name>madc_seq_irq_raw</name>
          <description>Raw IRQ: Read access shows status of unmasked IRQs. IRQs are set automatically and reset by writing to this register: Write access with '1' resets the appropriate IRQ (if event irq, reset status irqs at their source). Write access with '0' does not influence this bit. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000070</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000007FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:11]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>dma_hresp</name>
              <bitRange>[10:10]</bitRange>
              <description>AHBL hresp signal received </description>
            </field>
            <field>
              <name>dma_overrun</name>
              <bitRange>[9:9]</bitRange>
              <description>AHBL write buffer overrun result not written due to AHBL busy </description>
            </field>
            <field>
              <name>seq_cmpl</name>
              <bitRange>[8:8]</bitRange>
              <description>measurement sequence completed </description>
            </field>
            <field>
              <name>m7_cmpl</name>
              <bitRange>[7:7]</bitRange>
              <description>event: measurement 7 completed </description>
            </field>
            <field>
              <name>m6_cmpl</name>
              <bitRange>[6:6]</bitRange>
              <description>event: measurement 6 completed </description>
            </field>
            <field>
              <name>m5_cmpl</name>
              <bitRange>[5:5]</bitRange>
              <description>event: measurement 5 completed </description>
            </field>
            <field>
              <name>m4_cmpl</name>
              <bitRange>[4:4]</bitRange>
              <description>event: measurement 4 completed </description>
            </field>
            <field>
              <name>m3_cmpl</name>
              <bitRange>[3:3]</bitRange>
              <description>event: measurement 3 completed </description>
            </field>
            <field>
              <name>m2_cmpl</name>
              <bitRange>[2:2]</bitRange>
              <description>event: measurement 2 completed </description>
            </field>
            <field>
              <name>m1_cmpl</name>
              <bitRange>[1:1]</bitRange>
              <description>event: measurement 1 completed </description>
            </field>
            <field>
              <name>m0_cmpl</name>
              <bitRange>[0:0]</bitRange>
              <description>event: measurement 0 completed </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_irq_masked': 0xFF401974-->
          <name>madc_seq_irq_masked</name>
          <description>Masked IRQ: Shows status of masked IRQs (as connected to ARM/xPIC). </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000074</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000007FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:11]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>dma_hresp</name>
              <bitRange>[10:10]</bitRange>
              <description>AHBL hresp signal received </description>
            </field>
            <field>
              <name>dma_overrun</name>
              <bitRange>[9:9]</bitRange>
              <description>AHBL write buffer overrun result not written due to AHBL busy </description>
            </field>
            <field>
              <name>seq_cmpl</name>
              <bitRange>[8:8]</bitRange>
              <description>measurement sequence completed </description>
            </field>
            <field>
              <name>m7_cmpl</name>
              <bitRange>[7:7]</bitRange>
              <description>event: measurement 7 completed </description>
            </field>
            <field>
              <name>m6_cmpl</name>
              <bitRange>[6:6]</bitRange>
              <description>event: measurement 6 completed </description>
            </field>
            <field>
              <name>m5_cmpl</name>
              <bitRange>[5:5]</bitRange>
              <description>event: measurement 5 completed </description>
            </field>
            <field>
              <name>m4_cmpl</name>
              <bitRange>[4:4]</bitRange>
              <description>event: measurement 4 completed </description>
            </field>
            <field>
              <name>m3_cmpl</name>
              <bitRange>[3:3]</bitRange>
              <description>event: measurement 3 completed </description>
            </field>
            <field>
              <name>m2_cmpl</name>
              <bitRange>[2:2]</bitRange>
              <description>event: measurement 2 completed </description>
            </field>
            <field>
              <name>m1_cmpl</name>
              <bitRange>[1:1]</bitRange>
              <description>event: measurement 1 completed </description>
            </field>
            <field>
              <name>m0_cmpl</name>
              <bitRange>[0:0]</bitRange>
              <description>event: measurement 0 completed </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_irq_mask_set': 0xFF401978-->
          <name>madc_seq_irq_mask_set</name>
          <description>IRQ enable mask: The IRQ mask enables interrupt requests for corresponding interrupt sources.   As its bits might be changed by different software tasks,   the IRQ mask register is not writable directly, but by set and reset masks: Write access with '1' sets interrupt mask bit. Write access with '0' does not influence this bit. Read access shows actual interrupt mask. Attention: Before activating interrupt mask, delete old pending interrupts by writing the same value to adr_mpwm_irq_raw. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000078</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000007FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:11]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>dma_hresp</name>
              <bitRange>[10:10]</bitRange>
              <description>AHBL hresp signal received </description>
            </field>
            <field>
              <name>dma_overrun</name>
              <bitRange>[9:9]</bitRange>
              <description>AHBL write buffer overrun result not written due to AHBL busy </description>
            </field>
            <field>
              <name>seq_cmpl</name>
              <bitRange>[8:8]</bitRange>
              <description>measurement sequence completed </description>
            </field>
            <field>
              <name>m7_cmpl</name>
              <bitRange>[7:7]</bitRange>
              <description>event: measurement 7 completed </description>
            </field>
            <field>
              <name>m6_cmpl</name>
              <bitRange>[6:6]</bitRange>
              <description>event: measurement 6 completed </description>
            </field>
            <field>
              <name>m5_cmpl</name>
              <bitRange>[5:5]</bitRange>
              <description>event: measurement 5 completed </description>
            </field>
            <field>
              <name>m4_cmpl</name>
              <bitRange>[4:4]</bitRange>
              <description>event: measurement 4 completed </description>
            </field>
            <field>
              <name>m3_cmpl</name>
              <bitRange>[3:3]</bitRange>
              <description>event: measurement 3 completed </description>
            </field>
            <field>
              <name>m2_cmpl</name>
              <bitRange>[2:2]</bitRange>
              <description>event: measurement 2 completed </description>
            </field>
            <field>
              <name>m1_cmpl</name>
              <bitRange>[1:1]</bitRange>
              <description>event: measurement 1 completed </description>
            </field>
            <field>
              <name>m0_cmpl</name>
              <bitRange>[0:0]</bitRange>
              <description>event: measurement 0 completed </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_irq_mask_reset': 0xFF40197C-->
          <name>madc_seq_irq_mask_reset</name>
          <description>IRQ disable mask: This is the corresponding reset mask to disable interrupt requests for corresponding interrupt sources: Write access with '1' resets interrupt mask bit. Write access with '0' does not influence this bit. Read access shows bit number of the lowest active bit in IRQ_MASKED or MAX+1 when no bit is set. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000007C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000007FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:11]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>dma_hresp</name>
              <bitRange>[10:10]</bitRange>
              <description>AHBL hresp signal received </description>
            </field>
            <field>
              <name>dma_overrun</name>
              <bitRange>[9:9]</bitRange>
              <description>AHBL write buffer overrun result not written due to AHBL busy </description>
            </field>
            <field>
              <name>seq_cmpl</name>
              <bitRange>[8:8]</bitRange>
              <description>measurement sequence completed </description>
            </field>
            <field>
              <name>m7_cmpl</name>
              <bitRange>[7:7]</bitRange>
              <description>event: measurement 7 completed </description>
            </field>
            <field>
              <name>m6_cmpl</name>
              <bitRange>[6:6]</bitRange>
              <description>event: measurement 6 completed </description>
            </field>
            <field>
              <name>m5_cmpl</name>
              <bitRange>[5:5]</bitRange>
              <description>event: measurement 5 completed </description>
            </field>
            <field>
              <name>m4_cmpl</name>
              <bitRange>[4:4]</bitRange>
              <description>event: measurement 4 completed </description>
            </field>
            <field>
              <name>m3_cmpl</name>
              <bitRange>[3:3]</bitRange>
              <description>event: measurement 3 completed </description>
            </field>
            <field>
              <name>m2_cmpl</name>
              <bitRange>[2:2]</bitRange>
              <description>event: measurement 2 completed </description>
            </field>
            <field>
              <name>m1_cmpl</name>
              <bitRange>[1:1]</bitRange>
              <description>event: measurement 1 completed </description>
            </field>
            <field>
              <name>m0_cmpl</name>
              <bitRange>[0:0]</bitRange>
              <description>event: measurement 0 completed </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>madc_seq2</name>
      <description>madc_seq2</description>
      <baseAddress>0xFF401A00</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>256</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>madc_seq2</name>
        <value>47</value>
      </interrupt>
      <registers>
        <register>
          <!--Absolute address of 'madc_seq_cfg': 0xFF401A00-->
          <name>madc_seq_cfg</name>
          <description>ADC static configuration </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000FF02</resetValue>
          <resetMask>0x000FFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:20]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>dma_disable</name>
              <bitRange>[19:19]</bitRange>
              <description>Disable DMA 1: DMA is disabled, results are not written to memory, only the current result will be visible in madc_seq_result_current. 0: DMA is enabled, results are written to memory as defined in madc_seq_ms_adr and madc_seq_m*-adr_offset. </description>
            </field>
            <field>
              <name>dma_32bit_adr</name>
              <bitRange>[18:18]</bitRange>
              <description>The DMA engine only uses 32bit addresses and DWord access. This mode wastes memory but speeds up the DMA access by not running read-modify-write cycles. </description>
            </field>
            <field>
              <name>vref_vdd3</name>
              <bitRange>[17:17]</bitRange>
              <description>Reference Select of ADC: 0: use reference from pin VREF_ADC (internally driven C or external reference, s. madc_adc01_static_cfg-vref_buffer_enable) 1: use reference from pin VDD3 (Analog core supply) </description>
            </field>
            <field>
              <name>adcclk_sync</name>
              <bitRange>[16:16]</bitRange>
              <description>0: The rising edges of adcclk are generated independently of the other ADCs. 1: Use adc_clock_phase for defined clock phases in relation to other ADC sequencers </description>
            </field>
            <field>
              <name>adcclk_phase</name>
              <bitRange>[15:8]</bitRange>
              <description>Generation of the rising edge of the adcclk is delayed until the global clk_phase counter matches this value. NOTE: The rising edge of the adcclk ending the first sample period of a triggered measurement is NEVER delayed. </description>
            </field>
            <field>
              <name>adcclk_period</name>
              <bitRange>[7:0]</bitRange>
              <description>Duration of an adcclk period in system clock cycles-1 For odd values the high phase of adcclk is one system clock cycle longer than the low phase. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_tracking_time_mux0': 0xFF401A04-->
          <name>madc_seq_tracking_time_mux0</name>
          <description>ADC sample extension for input channel 0 Length of 2nd adcclk in steps of 10ns system clock(~ delay of 3rd adcclk edge). The capacitor inside ADC needs time to be charged depending   on the driving strength of the external signal.   For 12 bit precision, this time should be 9*(Rint+Rext)*C,   with Rint=1kOhm and C=7.5pF. The total formula for this value is: tt_add = ceil((6,75 x Rext/kOhm) + 6,75) - adcclk_period/10ns - 2 Set tt_add=4 if calculated value is smaller 4. The total ADC cycle time results in: tcycle = 14 * adcclk_period + clock_sync_delay (max 1 adcclk_period) + tt_add * 10ns. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000004</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>tt_add</name>
              <bitRange>[7:0]</bitRange>
              <description>Tracking time addon </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_tracking_time_mux1': 0xFF401A08-->
          <name>madc_seq_tracking_time_mux1</name>
          <description>ADC sample extension for input channel 1 s. madc_seq_tracking_time_mux0 for details. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000004</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>tt_add</name>
              <bitRange>[7:0]</bitRange>
              <description>Tracking time addon </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_tracking_time_mux2': 0xFF401A0C-->
          <name>madc_seq_tracking_time_mux2</name>
          <description>ADC sample extension for input channel 2 s. madc_seq_tracking_time_mux0 for details. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000004</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>tt_add</name>
              <bitRange>[7:0]</bitRange>
              <description>Tracking time addon </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_tracking_time_mux3': 0xFF401A10-->
          <name>madc_seq_tracking_time_mux3</name>
          <description>ADC sample extension for input channel 3 s. madc_seq_tracking_time_mux0 for details. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000004</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>tt_add</name>
              <bitRange>[7:0]</bitRange>
              <description>Tracking time addon </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_tracking_time_mux4': 0xFF401A14-->
          <name>madc_seq_tracking_time_mux4</name>
          <description>ADC sample extension for input channel 4 s. madc_seq_tracking_time_mux0 for details. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000004</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>tt_add</name>
              <bitRange>[7:0]</bitRange>
              <description>Tracking time addon </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_tracking_time_mux5': 0xFF401A18-->
          <name>madc_seq_tracking_time_mux5</name>
          <description>ADC sample extension for input channel 5 s. madc_seq_tracking_time_mux0 for details. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000018</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000004</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>tt_add</name>
              <bitRange>[7:0]</bitRange>
              <description>Tracking time addon </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_tracking_time_mux6': 0xFF401A1C-->
          <name>madc_seq_tracking_time_mux6</name>
          <description>ADC sample extension for input channel 6 s. madc_seq_tracking_time_mux0 for details. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000001C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000004</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>tt_add</name>
              <bitRange>[7:0]</bitRange>
              <description>Tracking time addon </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_tracking_time_mux7': 0xFF401A20-->
          <name>madc_seq_tracking_time_mux7</name>
          <description>ADC sample extension for input channel 7 s. madc_seq_tracking_time_mux0 for details. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000004</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>tt_add</name>
              <bitRange>[7:0]</bitRange>
              <description>Tracking time addon </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_ms_en': 0xFF401A24-->
          <name>madc_seq_ms_en</name>
          <description>Enable measurement configurations: Terminology: A measurement sequence consists of upto 8 measurements. A measurement consists of up to 8 samples. A sample needs at least 14 adcclk cycles (+ tracking time addon). This register enables the measurements belonging to a measurement sequence (up to 8). With the start of a measurement sequence (s. madc_seq_cmd) all sequence configuration registers   (ms_en, ms_adr, m0..m7) are copied to shadow registers that can no longer be changed until   the measurement sequence is finished. All further write accesses to these registers will be valid for the subsequent measurement sequence. The software must ensure, that a set of configuration data for one sequence is completely written   before starting the next sequence. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000024</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>m7</name>
              <bitRange>[7:7]</bitRange>
              <description>1: Enable measurement defined by madc_seq_m7 for the current measurement sequence </description>
            </field>
            <field>
              <name>m6</name>
              <bitRange>[6:6]</bitRange>
              <description>1: Enable measurement defined by madc_seq_m6 for the current measurement sequence </description>
            </field>
            <field>
              <name>m5</name>
              <bitRange>[5:5]</bitRange>
              <description>1: Enable measurement defined by madc_seq_m5 for the current measurement sequence </description>
            </field>
            <field>
              <name>m4</name>
              <bitRange>[4:4]</bitRange>
              <description>1: Enable measurement defined by madc_seq_m4 for the current measurement sequence </description>
            </field>
            <field>
              <name>m3</name>
              <bitRange>[3:3]</bitRange>
              <description>1: Enable measurement defined by madc_seq_m3 for the current measurement sequence </description>
            </field>
            <field>
              <name>m2</name>
              <bitRange>[2:2]</bitRange>
              <description>1: Enable measurement defined by madc_seq_m2 for the current measurement sequence </description>
            </field>
            <field>
              <name>m1</name>
              <bitRange>[1:1]</bitRange>
              <description>1: Enable measurement defined by madc_seq_m1 for the current measurement sequence </description>
            </field>
            <field>
              <name>m0</name>
              <bitRange>[0:0]</bitRange>
              <description>1: Enable measurement defined by madc_seq_m0 for the current measurement sequence </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_ms_baseadr': 0xFF401A28-->
          <name>madc_seq_ms_baseadr</name>
          <description>Base address for writing the measurement results. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000028</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFE</resetMask>
          <fields>
            <field>
              <name>adr</name>
              <bitRange>[31:1]</bitRange>
              <description>word (16 bit) aligned address, LSB is ignored In case of madc_seq_cfg-dma_32bit_adr=1, bit 1 will be ignored. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[0:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_m0': 0xFF401A2C-->
          <name>madc_seq_m0</name>
          <description>Measurement 0 configuration: A measurement performs (oversample+1) ADC conversions, summing up the results. Every ADC conversion starts with two adcclk periods followed by a sampling phase extension with a minimal duration selected by sext_sel. The sampling phase of the first ADC conversion of the measurement ends when the trigger condition is fulfilled. All subsequent conversions of the measurement do not wait for any trigger condition. The sum consisting of (oversample+1) ADC conversions is written as a 16 bit word to the memory location (byte address) ms_adr + 2*adr_offset. During the measurement the input multiplexer setting (channel selection) is changed to the value mux. Depending on the timing selected by mux_time_sel the channel setting becomes effective for this or the next measurement. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000002C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0001FFFF</resetValue>
          <resetMask>0x0FFFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:28]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>adr_offset</name>
              <bitRange>[27:23]</bitRange>
              <description>Address offset specified in 16 bit words where the sum will be stored In case of madc_seq_cfg-dma_32bit_adr=1, this value will be interpreted as 32-bit address. </description>
            </field>
            <field>
              <name>mux</name>
              <bitRange>[22:20]</bitRange>
              <description>Input channel multiplexer setting The input multiplexer will always be set 1 system clock (10ns) before SOF. It will be reset after sampling to ensure a not-connected phase at the one-hot-coded multiplexer switches. </description>
            </field>
            <field>
              <name>oversample</name>
              <bitRange>[19:17]</bitRange>
              <description>Number of samples minus one to sum for this measurement i.e. 0:sum 1 samples, 1:sum 2 samples, ... </description>
            </field>
            <field>
              <name>trigger</name>
              <bitRange>[16:0]</bitRange>
              <description>Trigger condition for measurement 0x0...0x0FFFF:     condition (ECNT == trigger) 0x10000...0x10005: delayed DTEVT[0..5]==1 0x10006:           GPIO_APP_COUNTER0 = 0 0x10007:           GPIO_APP_COUNTER1 = 0 0x10008:           GPIO_APP_COUNTER2 = 0 0x10009:           posedge of xc_trigger[0] 0x1000a:           posedge of xc_trigger[1] 0x1000b:           negedge of xc_trigger[0] 0x1000c:           negedge of xc_trigger[1] 0x1000d:           posedge of xc_sample[0] 0x1000e:           posedge of xc_sample[1] 0x1000f:           negedge of xc_sample[0] 0x10010:           negedge of xc_sample[1] 0x1FFFF:           no trigger, measurement executes immediately after end of sampling phase Note: Ensure that the time between SOC and trigger event does not exceed ADC_MAXTRACK (10ms). </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_m1': 0xFF401A30-->
          <name>madc_seq_m1</name>
          <description>Measurement 1 configuration: s. madc_seq_m0 for details </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000030</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0001FFFF</resetValue>
          <resetMask>0x0FFFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:28]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>adr_offset</name>
              <bitRange>[27:23]</bitRange>
              <description>Address offset specified in 16 bit words where the sum will be stored </description>
            </field>
            <field>
              <name>mux</name>
              <bitRange>[22:20]</bitRange>
              <description>Input channel multiplexer setting </description>
            </field>
            <field>
              <name>oversample</name>
              <bitRange>[19:17]</bitRange>
              <description>Number of samples minus one to sum for this measurement </description>
            </field>
            <field>
              <name>trigger</name>
              <bitRange>[16:0]</bitRange>
              <description>Trigger condition for measurement </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_m2': 0xFF401A34-->
          <name>madc_seq_m2</name>
          <description>Measurement 2 configuration: s. madc_seq_m0 for details </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000034</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0001FFFF</resetValue>
          <resetMask>0x0FFFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:28]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>adr_offset</name>
              <bitRange>[27:23]</bitRange>
              <description>Address offset specified in 16 bit words where the sum will be stored </description>
            </field>
            <field>
              <name>mux</name>
              <bitRange>[22:20]</bitRange>
              <description>Input channel multiplexer setting </description>
            </field>
            <field>
              <name>oversample</name>
              <bitRange>[19:17]</bitRange>
              <description>Number of samples minus one to sum for this measurement </description>
            </field>
            <field>
              <name>trigger</name>
              <bitRange>[16:0]</bitRange>
              <description>Trigger condition for measurement </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_m3': 0xFF401A38-->
          <name>madc_seq_m3</name>
          <description>Measurement 3 configuration: s. madc_seq_m0 for details </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000038</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0001FFFF</resetValue>
          <resetMask>0x0FFFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:28]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>adr_offset</name>
              <bitRange>[27:23]</bitRange>
              <description>Address offset specified in 16 bit words where the sum will be stored </description>
            </field>
            <field>
              <name>mux</name>
              <bitRange>[22:20]</bitRange>
              <description>Input channel multiplexer setting </description>
            </field>
            <field>
              <name>oversample</name>
              <bitRange>[19:17]</bitRange>
              <description>Number of samples minus one to sum for this measurement </description>
            </field>
            <field>
              <name>trigger</name>
              <bitRange>[16:0]</bitRange>
              <description>Trigger condition for measurement </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_m4': 0xFF401A3C-->
          <name>madc_seq_m4</name>
          <description>Measurement 4 configuration: s. madc_seq_m0 for details </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000003C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0001FFFF</resetValue>
          <resetMask>0x0FFFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:28]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>adr_offset</name>
              <bitRange>[27:23]</bitRange>
              <description>Address offset specified in 16 bit words where the sum will be stored </description>
            </field>
            <field>
              <name>mux</name>
              <bitRange>[22:20]</bitRange>
              <description>Input channel multiplexer setting </description>
            </field>
            <field>
              <name>oversample</name>
              <bitRange>[19:17]</bitRange>
              <description>Number of samples minus one to sum for this measurement </description>
            </field>
            <field>
              <name>trigger</name>
              <bitRange>[16:0]</bitRange>
              <description>Trigger condition for measurement </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_m5': 0xFF401A40-->
          <name>madc_seq_m5</name>
          <description>Measurement 5 configuration: s. madc_seq_m0 for details </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000040</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0001FFFF</resetValue>
          <resetMask>0x0FFFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:28]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>adr_offset</name>
              <bitRange>[27:23]</bitRange>
              <description>Address offset specified in 16 bit words where the sum will be stored </description>
            </field>
            <field>
              <name>mux</name>
              <bitRange>[22:20]</bitRange>
              <description>Input channel multiplexer setting </description>
            </field>
            <field>
              <name>oversample</name>
              <bitRange>[19:17]</bitRange>
              <description>Number of samples minus one to sum for this measurement </description>
            </field>
            <field>
              <name>trigger</name>
              <bitRange>[16:0]</bitRange>
              <description>Trigger condition for measurement </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_m6': 0xFF401A44-->
          <name>madc_seq_m6</name>
          <description>Measurement 6 configuration: s. madc_seq_m0 for details </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000044</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0001FFFF</resetValue>
          <resetMask>0x0FFFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:28]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>adr_offset</name>
              <bitRange>[27:23]</bitRange>
              <description>Address offset specified in 16 bit words where the sum will be stored </description>
            </field>
            <field>
              <name>mux</name>
              <bitRange>[22:20]</bitRange>
              <description>Input channel multiplexer setting </description>
            </field>
            <field>
              <name>oversample</name>
              <bitRange>[19:17]</bitRange>
              <description>Number of samples minus one to sum for this measurement </description>
            </field>
            <field>
              <name>trigger</name>
              <bitRange>[16:0]</bitRange>
              <description>Trigger condition for measurement </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_m7': 0xFF401A48-->
          <name>madc_seq_m7</name>
          <description>Measurement 7 configuration: s. madc_seq_m0 for details </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000048</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0001FFFF</resetValue>
          <resetMask>0x0FFFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:28]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>adr_offset</name>
              <bitRange>[27:23]</bitRange>
              <description>Address offset specified in 16 bit words where the sum will be stored </description>
            </field>
            <field>
              <name>mux</name>
              <bitRange>[22:20]</bitRange>
              <description>Input channel multiplexer setting </description>
            </field>
            <field>
              <name>oversample</name>
              <bitRange>[19:17]</bitRange>
              <description>Number of samples minus one to sum for this measurement </description>
            </field>
            <field>
              <name>trigger</name>
              <bitRange>[16:0]</bitRange>
              <description>Trigger condition for measurement </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_cmd': 0xFF401A4C-->
          <name>madc_seq_cmd</name>
          <description>Command Register: Run or abort processing the measurement sequence. This register is writable but can also be changed by hardware (reset). </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000004C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>debug</name>
              <bitRange>[3:3]</bitRange>
              <description>Debug mode: 0: ADC is controlled by measurement sequencer 1: ADC is directly controlled by madc_seq_debug register. </description>
            </field>
            <field>
              <name>reset</name>
              <bitRange>[2:2]</bitRange>
              <description>Reset this ADC-sequencer: In comparision to madc_adc01_static_cfg-adc01_reset_n, which resets a pair of ADC channels (e.g. ADC0 and ADC1), this bit only resets this single ADC-sequencer. The analog part of ADC will not be reset, but all registers of the controller (including result registers, which will not be reset in case of run=stop). </description>
            </field>
            <field>
              <name>continuous</name>
              <bitRange>[1:1]</bitRange>
              <description>Continuous mode: 0: run starts single conversion. All measurements enabled in madc_m_en are executed once. 1: start continuous conversion. All measurments enabled are executed repeatedly until stopped by resetting the run bit. </description>
            </field>
            <field>
              <name>run</name>
              <bitRange>[0:0]</bitRange>
              <description>Run bit: This bit can be set here or at madc_start to start all ADCs simultaneously. This bit can be reset here or automatically by hardware, when measurement sequence is finished. 1 : start measurement sequence. 0 : stop measurement sequence. Any conversion in progress is aborted and ADC returns to idle state with adcclk=0 and adc_soc=0. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_status': 0xFF401A50-->
          <name>madc_seq_status</name>
          <description>Status of the current measurement sequence in progress </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000050</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000001FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:9]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>adc_half_clock_cycle</name>
              <bitRange>[8:4]</bitRange>
              <description>0..30: current adcclk half clock cycle, 0 when adc is idle </description>
            </field>
            <field>
              <name>m_nr</name>
              <bitRange>[3:0]</bitRange>
              <description>Number of measurement configuration: 0..7: currently active measurement configuration, 8 when the ADC is idle </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_result_current': 0xFF401A54-->
          <name>madc_seq_result_current</name>
          <description>Result register of current measurement </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000054</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x80077FFF</resetMask>
          <fields>
            <field>
              <name>valid</name>
              <bitRange>[31:31]</bitRange>
              <description>result in register is finally calculated (val shows intermediate values in case of oversample&gt;0) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[30:19]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>mnr</name>
              <bitRange>[18:16]</bitRange>
              <description>number of measurement configuration </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[15:15]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[14:0]</bitRange>
              <description>result of measurement </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_result_last': 0xFF401A58-->
          <name>madc_seq_result_last</name>
          <description>Result register of last measurement </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000058</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x80077FFF</resetMask>
          <fields>
            <field>
              <name>valid</name>
              <bitRange>[31:31]</bitRange>
              <description>result in register is finally calculated (val shows intermediate values in case of oversample&gt;0) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[30:19]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>mnr</name>
              <bitRange>[18:16]</bitRange>
              <description>number of measurement configuration </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[15:15]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[14:0]</bitRange>
              <description>result of measurement </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_debug': 0xFF401A5C-->
          <name>madc_seq_debug</name>
          <description>Debug Mode register: If cmd-debug is enabled, this register directly controls inputs of both ADCs. Output data of both ADCs will still be at data0 and data1. In debug mode, a software reset (cfg-reset_n) will not influence these values (only directly signal ADC_NRES). </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000005C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000003FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:10]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>adc_set_mux7</name>
              <bitRange>[9:9]</bitRange>
              <description>ADC0_SET_MUX7 signal </description>
            </field>
            <field>
              <name>adc_set_mux6</name>
              <bitRange>[8:8]</bitRange>
              <description>ADC0_SET_MUX6 signal </description>
            </field>
            <field>
              <name>adc_set_mux5</name>
              <bitRange>[7:7]</bitRange>
              <description>ADC0_SET_MUX5 signal </description>
            </field>
            <field>
              <name>adc_set_mux4</name>
              <bitRange>[6:6]</bitRange>
              <description>ADC0_SET_MUX4 signal </description>
            </field>
            <field>
              <name>adc_set_mux3</name>
              <bitRange>[5:5]</bitRange>
              <description>ADC0_SET_MUX3 signal </description>
            </field>
            <field>
              <name>adc_set_mux2</name>
              <bitRange>[4:4]</bitRange>
              <description>ADC0_SET_MUX2 signal </description>
            </field>
            <field>
              <name>adc_set_mux1</name>
              <bitRange>[3:3]</bitRange>
              <description>ADC0_SET_MUX1 signal </description>
            </field>
            <field>
              <name>adc_set_mux0</name>
              <bitRange>[2:2]</bitRange>
              <description>ADC0_SET_MUX0 signal </description>
            </field>
            <field>
              <name>adc_soc</name>
              <bitRange>[1:1]</bitRange>
              <description>ADC0_SOC signal </description>
            </field>
            <field>
              <name>adc_clk</name>
              <bitRange>[0:0]</bitRange>
              <description>ADC0 is sampling data. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_irq_raw': 0xFF401A70-->
          <name>madc_seq_irq_raw</name>
          <description>Raw IRQ: Read access shows status of unmasked IRQs. IRQs are set automatically and reset by writing to this register: Write access with '1' resets the appropriate IRQ (if event irq, reset status irqs at their source). Write access with '0' does not influence this bit. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000070</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000007FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:11]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>dma_hresp</name>
              <bitRange>[10:10]</bitRange>
              <description>AHBL hresp signal received </description>
            </field>
            <field>
              <name>dma_overrun</name>
              <bitRange>[9:9]</bitRange>
              <description>AHBL write buffer overrun result not written due to AHBL busy </description>
            </field>
            <field>
              <name>seq_cmpl</name>
              <bitRange>[8:8]</bitRange>
              <description>measurement sequence completed </description>
            </field>
            <field>
              <name>m7_cmpl</name>
              <bitRange>[7:7]</bitRange>
              <description>event: measurement 7 completed </description>
            </field>
            <field>
              <name>m6_cmpl</name>
              <bitRange>[6:6]</bitRange>
              <description>event: measurement 6 completed </description>
            </field>
            <field>
              <name>m5_cmpl</name>
              <bitRange>[5:5]</bitRange>
              <description>event: measurement 5 completed </description>
            </field>
            <field>
              <name>m4_cmpl</name>
              <bitRange>[4:4]</bitRange>
              <description>event: measurement 4 completed </description>
            </field>
            <field>
              <name>m3_cmpl</name>
              <bitRange>[3:3]</bitRange>
              <description>event: measurement 3 completed </description>
            </field>
            <field>
              <name>m2_cmpl</name>
              <bitRange>[2:2]</bitRange>
              <description>event: measurement 2 completed </description>
            </field>
            <field>
              <name>m1_cmpl</name>
              <bitRange>[1:1]</bitRange>
              <description>event: measurement 1 completed </description>
            </field>
            <field>
              <name>m0_cmpl</name>
              <bitRange>[0:0]</bitRange>
              <description>event: measurement 0 completed </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_irq_masked': 0xFF401A74-->
          <name>madc_seq_irq_masked</name>
          <description>Masked IRQ: Shows status of masked IRQs (as connected to ARM/xPIC). </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000074</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000007FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:11]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>dma_hresp</name>
              <bitRange>[10:10]</bitRange>
              <description>AHBL hresp signal received </description>
            </field>
            <field>
              <name>dma_overrun</name>
              <bitRange>[9:9]</bitRange>
              <description>AHBL write buffer overrun result not written due to AHBL busy </description>
            </field>
            <field>
              <name>seq_cmpl</name>
              <bitRange>[8:8]</bitRange>
              <description>measurement sequence completed </description>
            </field>
            <field>
              <name>m7_cmpl</name>
              <bitRange>[7:7]</bitRange>
              <description>event: measurement 7 completed </description>
            </field>
            <field>
              <name>m6_cmpl</name>
              <bitRange>[6:6]</bitRange>
              <description>event: measurement 6 completed </description>
            </field>
            <field>
              <name>m5_cmpl</name>
              <bitRange>[5:5]</bitRange>
              <description>event: measurement 5 completed </description>
            </field>
            <field>
              <name>m4_cmpl</name>
              <bitRange>[4:4]</bitRange>
              <description>event: measurement 4 completed </description>
            </field>
            <field>
              <name>m3_cmpl</name>
              <bitRange>[3:3]</bitRange>
              <description>event: measurement 3 completed </description>
            </field>
            <field>
              <name>m2_cmpl</name>
              <bitRange>[2:2]</bitRange>
              <description>event: measurement 2 completed </description>
            </field>
            <field>
              <name>m1_cmpl</name>
              <bitRange>[1:1]</bitRange>
              <description>event: measurement 1 completed </description>
            </field>
            <field>
              <name>m0_cmpl</name>
              <bitRange>[0:0]</bitRange>
              <description>event: measurement 0 completed </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_irq_mask_set': 0xFF401A78-->
          <name>madc_seq_irq_mask_set</name>
          <description>IRQ enable mask: The IRQ mask enables interrupt requests for corresponding interrupt sources.   As its bits might be changed by different software tasks,   the IRQ mask register is not writable directly, but by set and reset masks: Write access with '1' sets interrupt mask bit. Write access with '0' does not influence this bit. Read access shows actual interrupt mask. Attention: Before activating interrupt mask, delete old pending interrupts by writing the same value to adr_mpwm_irq_raw. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000078</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000007FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:11]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>dma_hresp</name>
              <bitRange>[10:10]</bitRange>
              <description>AHBL hresp signal received </description>
            </field>
            <field>
              <name>dma_overrun</name>
              <bitRange>[9:9]</bitRange>
              <description>AHBL write buffer overrun result not written due to AHBL busy </description>
            </field>
            <field>
              <name>seq_cmpl</name>
              <bitRange>[8:8]</bitRange>
              <description>measurement sequence completed </description>
            </field>
            <field>
              <name>m7_cmpl</name>
              <bitRange>[7:7]</bitRange>
              <description>event: measurement 7 completed </description>
            </field>
            <field>
              <name>m6_cmpl</name>
              <bitRange>[6:6]</bitRange>
              <description>event: measurement 6 completed </description>
            </field>
            <field>
              <name>m5_cmpl</name>
              <bitRange>[5:5]</bitRange>
              <description>event: measurement 5 completed </description>
            </field>
            <field>
              <name>m4_cmpl</name>
              <bitRange>[4:4]</bitRange>
              <description>event: measurement 4 completed </description>
            </field>
            <field>
              <name>m3_cmpl</name>
              <bitRange>[3:3]</bitRange>
              <description>event: measurement 3 completed </description>
            </field>
            <field>
              <name>m2_cmpl</name>
              <bitRange>[2:2]</bitRange>
              <description>event: measurement 2 completed </description>
            </field>
            <field>
              <name>m1_cmpl</name>
              <bitRange>[1:1]</bitRange>
              <description>event: measurement 1 completed </description>
            </field>
            <field>
              <name>m0_cmpl</name>
              <bitRange>[0:0]</bitRange>
              <description>event: measurement 0 completed </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_irq_mask_reset': 0xFF401A7C-->
          <name>madc_seq_irq_mask_reset</name>
          <description>IRQ disable mask: This is the corresponding reset mask to disable interrupt requests for corresponding interrupt sources: Write access with '1' resets interrupt mask bit. Write access with '0' does not influence this bit. Read access shows bit number of the lowest active bit in IRQ_MASKED or MAX+1 when no bit is set. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000007C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000007FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:11]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>dma_hresp</name>
              <bitRange>[10:10]</bitRange>
              <description>AHBL hresp signal received </description>
            </field>
            <field>
              <name>dma_overrun</name>
              <bitRange>[9:9]</bitRange>
              <description>AHBL write buffer overrun result not written due to AHBL busy </description>
            </field>
            <field>
              <name>seq_cmpl</name>
              <bitRange>[8:8]</bitRange>
              <description>measurement sequence completed </description>
            </field>
            <field>
              <name>m7_cmpl</name>
              <bitRange>[7:7]</bitRange>
              <description>event: measurement 7 completed </description>
            </field>
            <field>
              <name>m6_cmpl</name>
              <bitRange>[6:6]</bitRange>
              <description>event: measurement 6 completed </description>
            </field>
            <field>
              <name>m5_cmpl</name>
              <bitRange>[5:5]</bitRange>
              <description>event: measurement 5 completed </description>
            </field>
            <field>
              <name>m4_cmpl</name>
              <bitRange>[4:4]</bitRange>
              <description>event: measurement 4 completed </description>
            </field>
            <field>
              <name>m3_cmpl</name>
              <bitRange>[3:3]</bitRange>
              <description>event: measurement 3 completed </description>
            </field>
            <field>
              <name>m2_cmpl</name>
              <bitRange>[2:2]</bitRange>
              <description>event: measurement 2 completed </description>
            </field>
            <field>
              <name>m1_cmpl</name>
              <bitRange>[1:1]</bitRange>
              <description>event: measurement 1 completed </description>
            </field>
            <field>
              <name>m0_cmpl</name>
              <bitRange>[0:0]</bitRange>
              <description>event: measurement 0 completed </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>madc_seq3</name>
      <description>madc_seq3</description>
      <baseAddress>0xFF401B00</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>256</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>madc_seq3</name>
        <value>48</value>
      </interrupt>
      <registers>
        <register>
          <!--Absolute address of 'madc_seq_cfg': 0xFF401B00-->
          <name>madc_seq_cfg</name>
          <description>ADC static configuration </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000FF02</resetValue>
          <resetMask>0x000FFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:20]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>dma_disable</name>
              <bitRange>[19:19]</bitRange>
              <description>Disable DMA 1: DMA is disabled, results are not written to memory, only the current result will be visible in madc_seq_result_current. 0: DMA is enabled, results are written to memory as defined in madc_seq_ms_adr and madc_seq_m*-adr_offset. </description>
            </field>
            <field>
              <name>dma_32bit_adr</name>
              <bitRange>[18:18]</bitRange>
              <description>The DMA engine only uses 32bit addresses and DWord access. This mode wastes memory but speeds up the DMA access by not running read-modify-write cycles. </description>
            </field>
            <field>
              <name>vref_vdd3</name>
              <bitRange>[17:17]</bitRange>
              <description>Reference Select of ADC: 0: use reference from pin VREF_ADC (internally driven C or external reference, s. madc_adc01_static_cfg-vref_buffer_enable) 1: use reference from pin VDD3 (Analog core supply) </description>
            </field>
            <field>
              <name>adcclk_sync</name>
              <bitRange>[16:16]</bitRange>
              <description>0: The rising edges of adcclk are generated independently of the other ADCs. 1: Use adc_clock_phase for defined clock phases in relation to other ADC sequencers </description>
            </field>
            <field>
              <name>adcclk_phase</name>
              <bitRange>[15:8]</bitRange>
              <description>Generation of the rising edge of the adcclk is delayed until the global clk_phase counter matches this value. NOTE: The rising edge of the adcclk ending the first sample period of a triggered measurement is NEVER delayed. </description>
            </field>
            <field>
              <name>adcclk_period</name>
              <bitRange>[7:0]</bitRange>
              <description>Duration of an adcclk period in system clock cycles-1 For odd values the high phase of adcclk is one system clock cycle longer than the low phase. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_tracking_time_mux0': 0xFF401B04-->
          <name>madc_seq_tracking_time_mux0</name>
          <description>ADC sample extension for input channel 0 Length of 2nd adcclk in steps of 10ns system clock(~ delay of 3rd adcclk edge). The capacitor inside ADC needs time to be charged depending   on the driving strength of the external signal.   For 12 bit precision, this time should be 9*(Rint+Rext)*C,   with Rint=1kOhm and C=7.5pF. The total formula for this value is: tt_add = ceil((6,75 x Rext/kOhm) + 6,75) - adcclk_period/10ns - 2 Set tt_add=4 if calculated value is smaller 4. The total ADC cycle time results in: tcycle = 14 * adcclk_period + clock_sync_delay (max 1 adcclk_period) + tt_add * 10ns. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000004</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>tt_add</name>
              <bitRange>[7:0]</bitRange>
              <description>Tracking time addon </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_tracking_time_mux1': 0xFF401B08-->
          <name>madc_seq_tracking_time_mux1</name>
          <description>ADC sample extension for input channel 1 s. madc_seq_tracking_time_mux0 for details. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000004</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>tt_add</name>
              <bitRange>[7:0]</bitRange>
              <description>Tracking time addon </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_tracking_time_mux2': 0xFF401B0C-->
          <name>madc_seq_tracking_time_mux2</name>
          <description>ADC sample extension for input channel 2 s. madc_seq_tracking_time_mux0 for details. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000004</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>tt_add</name>
              <bitRange>[7:0]</bitRange>
              <description>Tracking time addon </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_tracking_time_mux3': 0xFF401B10-->
          <name>madc_seq_tracking_time_mux3</name>
          <description>ADC sample extension for input channel 3 s. madc_seq_tracking_time_mux0 for details. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000004</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>tt_add</name>
              <bitRange>[7:0]</bitRange>
              <description>Tracking time addon </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_tracking_time_mux4': 0xFF401B14-->
          <name>madc_seq_tracking_time_mux4</name>
          <description>ADC sample extension for input channel 4 s. madc_seq_tracking_time_mux0 for details. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000004</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>tt_add</name>
              <bitRange>[7:0]</bitRange>
              <description>Tracking time addon </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_tracking_time_mux5': 0xFF401B18-->
          <name>madc_seq_tracking_time_mux5</name>
          <description>ADC sample extension for input channel 5 s. madc_seq_tracking_time_mux0 for details. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000018</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000004</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>tt_add</name>
              <bitRange>[7:0]</bitRange>
              <description>Tracking time addon </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_tracking_time_mux6': 0xFF401B1C-->
          <name>madc_seq_tracking_time_mux6</name>
          <description>ADC sample extension for input channel 6 s. madc_seq_tracking_time_mux0 for details. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000001C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000004</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>tt_add</name>
              <bitRange>[7:0]</bitRange>
              <description>Tracking time addon </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_tracking_time_mux7': 0xFF401B20-->
          <name>madc_seq_tracking_time_mux7</name>
          <description>ADC sample extension for input channel 7 s. madc_seq_tracking_time_mux0 for details. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000004</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>tt_add</name>
              <bitRange>[7:0]</bitRange>
              <description>Tracking time addon </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_ms_en': 0xFF401B24-->
          <name>madc_seq_ms_en</name>
          <description>Enable measurement configurations: Terminology: A measurement sequence consists of upto 8 measurements. A measurement consists of up to 8 samples. A sample needs at least 14 adcclk cycles (+ tracking time addon). This register enables the measurements belonging to a measurement sequence (up to 8). With the start of a measurement sequence (s. madc_seq_cmd) all sequence configuration registers   (ms_en, ms_adr, m0..m7) are copied to shadow registers that can no longer be changed until   the measurement sequence is finished. All further write accesses to these registers will be valid for the subsequent measurement sequence. The software must ensure, that a set of configuration data for one sequence is completely written   before starting the next sequence. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000024</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>m7</name>
              <bitRange>[7:7]</bitRange>
              <description>1: Enable measurement defined by madc_seq_m7 for the current measurement sequence </description>
            </field>
            <field>
              <name>m6</name>
              <bitRange>[6:6]</bitRange>
              <description>1: Enable measurement defined by madc_seq_m6 for the current measurement sequence </description>
            </field>
            <field>
              <name>m5</name>
              <bitRange>[5:5]</bitRange>
              <description>1: Enable measurement defined by madc_seq_m5 for the current measurement sequence </description>
            </field>
            <field>
              <name>m4</name>
              <bitRange>[4:4]</bitRange>
              <description>1: Enable measurement defined by madc_seq_m4 for the current measurement sequence </description>
            </field>
            <field>
              <name>m3</name>
              <bitRange>[3:3]</bitRange>
              <description>1: Enable measurement defined by madc_seq_m3 for the current measurement sequence </description>
            </field>
            <field>
              <name>m2</name>
              <bitRange>[2:2]</bitRange>
              <description>1: Enable measurement defined by madc_seq_m2 for the current measurement sequence </description>
            </field>
            <field>
              <name>m1</name>
              <bitRange>[1:1]</bitRange>
              <description>1: Enable measurement defined by madc_seq_m1 for the current measurement sequence </description>
            </field>
            <field>
              <name>m0</name>
              <bitRange>[0:0]</bitRange>
              <description>1: Enable measurement defined by madc_seq_m0 for the current measurement sequence </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_ms_baseadr': 0xFF401B28-->
          <name>madc_seq_ms_baseadr</name>
          <description>Base address for writing the measurement results. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000028</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFE</resetMask>
          <fields>
            <field>
              <name>adr</name>
              <bitRange>[31:1]</bitRange>
              <description>word (16 bit) aligned address, LSB is ignored In case of madc_seq_cfg-dma_32bit_adr=1, bit 1 will be ignored. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[0:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_m0': 0xFF401B2C-->
          <name>madc_seq_m0</name>
          <description>Measurement 0 configuration: A measurement performs (oversample+1) ADC conversions, summing up the results. Every ADC conversion starts with two adcclk periods followed by a sampling phase extension with a minimal duration selected by sext_sel. The sampling phase of the first ADC conversion of the measurement ends when the trigger condition is fulfilled. All subsequent conversions of the measurement do not wait for any trigger condition. The sum consisting of (oversample+1) ADC conversions is written as a 16 bit word to the memory location (byte address) ms_adr + 2*adr_offset. During the measurement the input multiplexer setting (channel selection) is changed to the value mux. Depending on the timing selected by mux_time_sel the channel setting becomes effective for this or the next measurement. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000002C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0001FFFF</resetValue>
          <resetMask>0x0FFFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:28]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>adr_offset</name>
              <bitRange>[27:23]</bitRange>
              <description>Address offset specified in 16 bit words where the sum will be stored In case of madc_seq_cfg-dma_32bit_adr=1, this value will be interpreted as 32-bit address. </description>
            </field>
            <field>
              <name>mux</name>
              <bitRange>[22:20]</bitRange>
              <description>Input channel multiplexer setting The input multiplexer will always be set 1 system clock (10ns) before SOF. It will be reset after sampling to ensure a not-connected phase at the one-hot-coded multiplexer switches. </description>
            </field>
            <field>
              <name>oversample</name>
              <bitRange>[19:17]</bitRange>
              <description>Number of samples minus one to sum for this measurement i.e. 0:sum 1 samples, 1:sum 2 samples, ... </description>
            </field>
            <field>
              <name>trigger</name>
              <bitRange>[16:0]</bitRange>
              <description>Trigger condition for measurement 0x0...0x0FFFF:     condition (ECNT == trigger) 0x10000...0x10005: delayed DTEVT[0..5]==1 0x10006:           GPIO_APP_COUNTER0 = 0 0x10007:           GPIO_APP_COUNTER1 = 0 0x10008:           GPIO_APP_COUNTER2 = 0 0x10009:           posedge of xc_trigger[0] 0x1000a:           posedge of xc_trigger[1] 0x1000b:           negedge of xc_trigger[0] 0x1000c:           negedge of xc_trigger[1] 0x1000d:           posedge of xc_sample[0] 0x1000e:           posedge of xc_sample[1] 0x1000f:           negedge of xc_sample[0] 0x10010:           negedge of xc_sample[1] 0x1FFFF:           no trigger, measurement executes immediately after end of sampling phase Note: Ensure that the time between SOC and trigger event does not exceed ADC_MAXTRACK (10ms). </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_m1': 0xFF401B30-->
          <name>madc_seq_m1</name>
          <description>Measurement 1 configuration: s. madc_seq_m0 for details </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000030</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0001FFFF</resetValue>
          <resetMask>0x0FFFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:28]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>adr_offset</name>
              <bitRange>[27:23]</bitRange>
              <description>Address offset specified in 16 bit words where the sum will be stored </description>
            </field>
            <field>
              <name>mux</name>
              <bitRange>[22:20]</bitRange>
              <description>Input channel multiplexer setting </description>
            </field>
            <field>
              <name>oversample</name>
              <bitRange>[19:17]</bitRange>
              <description>Number of samples minus one to sum for this measurement </description>
            </field>
            <field>
              <name>trigger</name>
              <bitRange>[16:0]</bitRange>
              <description>Trigger condition for measurement </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_m2': 0xFF401B34-->
          <name>madc_seq_m2</name>
          <description>Measurement 2 configuration: s. madc_seq_m0 for details </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000034</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0001FFFF</resetValue>
          <resetMask>0x0FFFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:28]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>adr_offset</name>
              <bitRange>[27:23]</bitRange>
              <description>Address offset specified in 16 bit words where the sum will be stored </description>
            </field>
            <field>
              <name>mux</name>
              <bitRange>[22:20]</bitRange>
              <description>Input channel multiplexer setting </description>
            </field>
            <field>
              <name>oversample</name>
              <bitRange>[19:17]</bitRange>
              <description>Number of samples minus one to sum for this measurement </description>
            </field>
            <field>
              <name>trigger</name>
              <bitRange>[16:0]</bitRange>
              <description>Trigger condition for measurement </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_m3': 0xFF401B38-->
          <name>madc_seq_m3</name>
          <description>Measurement 3 configuration: s. madc_seq_m0 for details </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000038</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0001FFFF</resetValue>
          <resetMask>0x0FFFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:28]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>adr_offset</name>
              <bitRange>[27:23]</bitRange>
              <description>Address offset specified in 16 bit words where the sum will be stored </description>
            </field>
            <field>
              <name>mux</name>
              <bitRange>[22:20]</bitRange>
              <description>Input channel multiplexer setting </description>
            </field>
            <field>
              <name>oversample</name>
              <bitRange>[19:17]</bitRange>
              <description>Number of samples minus one to sum for this measurement </description>
            </field>
            <field>
              <name>trigger</name>
              <bitRange>[16:0]</bitRange>
              <description>Trigger condition for measurement </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_m4': 0xFF401B3C-->
          <name>madc_seq_m4</name>
          <description>Measurement 4 configuration: s. madc_seq_m0 for details </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000003C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0001FFFF</resetValue>
          <resetMask>0x0FFFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:28]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>adr_offset</name>
              <bitRange>[27:23]</bitRange>
              <description>Address offset specified in 16 bit words where the sum will be stored </description>
            </field>
            <field>
              <name>mux</name>
              <bitRange>[22:20]</bitRange>
              <description>Input channel multiplexer setting </description>
            </field>
            <field>
              <name>oversample</name>
              <bitRange>[19:17]</bitRange>
              <description>Number of samples minus one to sum for this measurement </description>
            </field>
            <field>
              <name>trigger</name>
              <bitRange>[16:0]</bitRange>
              <description>Trigger condition for measurement </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_m5': 0xFF401B40-->
          <name>madc_seq_m5</name>
          <description>Measurement 5 configuration: s. madc_seq_m0 for details </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000040</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0001FFFF</resetValue>
          <resetMask>0x0FFFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:28]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>adr_offset</name>
              <bitRange>[27:23]</bitRange>
              <description>Address offset specified in 16 bit words where the sum will be stored </description>
            </field>
            <field>
              <name>mux</name>
              <bitRange>[22:20]</bitRange>
              <description>Input channel multiplexer setting </description>
            </field>
            <field>
              <name>oversample</name>
              <bitRange>[19:17]</bitRange>
              <description>Number of samples minus one to sum for this measurement </description>
            </field>
            <field>
              <name>trigger</name>
              <bitRange>[16:0]</bitRange>
              <description>Trigger condition for measurement </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_m6': 0xFF401B44-->
          <name>madc_seq_m6</name>
          <description>Measurement 6 configuration: s. madc_seq_m0 for details </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000044</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0001FFFF</resetValue>
          <resetMask>0x0FFFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:28]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>adr_offset</name>
              <bitRange>[27:23]</bitRange>
              <description>Address offset specified in 16 bit words where the sum will be stored </description>
            </field>
            <field>
              <name>mux</name>
              <bitRange>[22:20]</bitRange>
              <description>Input channel multiplexer setting </description>
            </field>
            <field>
              <name>oversample</name>
              <bitRange>[19:17]</bitRange>
              <description>Number of samples minus one to sum for this measurement </description>
            </field>
            <field>
              <name>trigger</name>
              <bitRange>[16:0]</bitRange>
              <description>Trigger condition for measurement </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_m7': 0xFF401B48-->
          <name>madc_seq_m7</name>
          <description>Measurement 7 configuration: s. madc_seq_m0 for details </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000048</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0001FFFF</resetValue>
          <resetMask>0x0FFFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:28]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>adr_offset</name>
              <bitRange>[27:23]</bitRange>
              <description>Address offset specified in 16 bit words where the sum will be stored </description>
            </field>
            <field>
              <name>mux</name>
              <bitRange>[22:20]</bitRange>
              <description>Input channel multiplexer setting </description>
            </field>
            <field>
              <name>oversample</name>
              <bitRange>[19:17]</bitRange>
              <description>Number of samples minus one to sum for this measurement </description>
            </field>
            <field>
              <name>trigger</name>
              <bitRange>[16:0]</bitRange>
              <description>Trigger condition for measurement </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_cmd': 0xFF401B4C-->
          <name>madc_seq_cmd</name>
          <description>Command Register: Run or abort processing the measurement sequence. This register is writable but can also be changed by hardware (reset). </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000004C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>debug</name>
              <bitRange>[3:3]</bitRange>
              <description>Debug mode: 0: ADC is controlled by measurement sequencer 1: ADC is directly controlled by madc_seq_debug register. </description>
            </field>
            <field>
              <name>reset</name>
              <bitRange>[2:2]</bitRange>
              <description>Reset this ADC-sequencer: In comparision to madc_adc01_static_cfg-adc01_reset_n, which resets a pair of ADC channels (e.g. ADC0 and ADC1), this bit only resets this single ADC-sequencer. The analog part of ADC will not be reset, but all registers of the controller (including result registers, which will not be reset in case of run=stop). </description>
            </field>
            <field>
              <name>continuous</name>
              <bitRange>[1:1]</bitRange>
              <description>Continuous mode: 0: run starts single conversion. All measurements enabled in madc_m_en are executed once. 1: start continuous conversion. All measurments enabled are executed repeatedly until stopped by resetting the run bit. </description>
            </field>
            <field>
              <name>run</name>
              <bitRange>[0:0]</bitRange>
              <description>Run bit: This bit can be set here or at madc_start to start all ADCs simultaneously. This bit can be reset here or automatically by hardware, when measurement sequence is finished. 1 : start measurement sequence. 0 : stop measurement sequence. Any conversion in progress is aborted and ADC returns to idle state with adcclk=0 and adc_soc=0. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_status': 0xFF401B50-->
          <name>madc_seq_status</name>
          <description>Status of the current measurement sequence in progress </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000050</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000001FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:9]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>adc_half_clock_cycle</name>
              <bitRange>[8:4]</bitRange>
              <description>0..30: current adcclk half clock cycle, 0 when adc is idle </description>
            </field>
            <field>
              <name>m_nr</name>
              <bitRange>[3:0]</bitRange>
              <description>Number of measurement configuration: 0..7: currently active measurement configuration, 8 when the ADC is idle </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_result_current': 0xFF401B54-->
          <name>madc_seq_result_current</name>
          <description>Result register of current measurement </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000054</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x80077FFF</resetMask>
          <fields>
            <field>
              <name>valid</name>
              <bitRange>[31:31]</bitRange>
              <description>result in register is finally calculated (val shows intermediate values in case of oversample&gt;0) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[30:19]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>mnr</name>
              <bitRange>[18:16]</bitRange>
              <description>number of measurement configuration </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[15:15]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[14:0]</bitRange>
              <description>result of measurement </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_result_last': 0xFF401B58-->
          <name>madc_seq_result_last</name>
          <description>Result register of last measurement </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000058</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x80077FFF</resetMask>
          <fields>
            <field>
              <name>valid</name>
              <bitRange>[31:31]</bitRange>
              <description>result in register is finally calculated (val shows intermediate values in case of oversample&gt;0) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[30:19]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>mnr</name>
              <bitRange>[18:16]</bitRange>
              <description>number of measurement configuration </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[15:15]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[14:0]</bitRange>
              <description>result of measurement </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_debug': 0xFF401B5C-->
          <name>madc_seq_debug</name>
          <description>Debug Mode register: If cmd-debug is enabled, this register directly controls inputs of both ADCs. Output data of both ADCs will still be at data0 and data1. In debug mode, a software reset (cfg-reset_n) will not influence these values (only directly signal ADC_NRES). </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000005C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000003FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:10]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>adc_set_mux7</name>
              <bitRange>[9:9]</bitRange>
              <description>ADC0_SET_MUX7 signal </description>
            </field>
            <field>
              <name>adc_set_mux6</name>
              <bitRange>[8:8]</bitRange>
              <description>ADC0_SET_MUX6 signal </description>
            </field>
            <field>
              <name>adc_set_mux5</name>
              <bitRange>[7:7]</bitRange>
              <description>ADC0_SET_MUX5 signal </description>
            </field>
            <field>
              <name>adc_set_mux4</name>
              <bitRange>[6:6]</bitRange>
              <description>ADC0_SET_MUX4 signal </description>
            </field>
            <field>
              <name>adc_set_mux3</name>
              <bitRange>[5:5]</bitRange>
              <description>ADC0_SET_MUX3 signal </description>
            </field>
            <field>
              <name>adc_set_mux2</name>
              <bitRange>[4:4]</bitRange>
              <description>ADC0_SET_MUX2 signal </description>
            </field>
            <field>
              <name>adc_set_mux1</name>
              <bitRange>[3:3]</bitRange>
              <description>ADC0_SET_MUX1 signal </description>
            </field>
            <field>
              <name>adc_set_mux0</name>
              <bitRange>[2:2]</bitRange>
              <description>ADC0_SET_MUX0 signal </description>
            </field>
            <field>
              <name>adc_soc</name>
              <bitRange>[1:1]</bitRange>
              <description>ADC0_SOC signal </description>
            </field>
            <field>
              <name>adc_clk</name>
              <bitRange>[0:0]</bitRange>
              <description>ADC0 is sampling data. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_irq_raw': 0xFF401B70-->
          <name>madc_seq_irq_raw</name>
          <description>Raw IRQ: Read access shows status of unmasked IRQs. IRQs are set automatically and reset by writing to this register: Write access with '1' resets the appropriate IRQ (if event irq, reset status irqs at their source). Write access with '0' does not influence this bit. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000070</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000007FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:11]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>dma_hresp</name>
              <bitRange>[10:10]</bitRange>
              <description>AHBL hresp signal received </description>
            </field>
            <field>
              <name>dma_overrun</name>
              <bitRange>[9:9]</bitRange>
              <description>AHBL write buffer overrun result not written due to AHBL busy </description>
            </field>
            <field>
              <name>seq_cmpl</name>
              <bitRange>[8:8]</bitRange>
              <description>measurement sequence completed </description>
            </field>
            <field>
              <name>m7_cmpl</name>
              <bitRange>[7:7]</bitRange>
              <description>event: measurement 7 completed </description>
            </field>
            <field>
              <name>m6_cmpl</name>
              <bitRange>[6:6]</bitRange>
              <description>event: measurement 6 completed </description>
            </field>
            <field>
              <name>m5_cmpl</name>
              <bitRange>[5:5]</bitRange>
              <description>event: measurement 5 completed </description>
            </field>
            <field>
              <name>m4_cmpl</name>
              <bitRange>[4:4]</bitRange>
              <description>event: measurement 4 completed </description>
            </field>
            <field>
              <name>m3_cmpl</name>
              <bitRange>[3:3]</bitRange>
              <description>event: measurement 3 completed </description>
            </field>
            <field>
              <name>m2_cmpl</name>
              <bitRange>[2:2]</bitRange>
              <description>event: measurement 2 completed </description>
            </field>
            <field>
              <name>m1_cmpl</name>
              <bitRange>[1:1]</bitRange>
              <description>event: measurement 1 completed </description>
            </field>
            <field>
              <name>m0_cmpl</name>
              <bitRange>[0:0]</bitRange>
              <description>event: measurement 0 completed </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_irq_masked': 0xFF401B74-->
          <name>madc_seq_irq_masked</name>
          <description>Masked IRQ: Shows status of masked IRQs (as connected to ARM/xPIC). </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000074</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000007FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:11]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>dma_hresp</name>
              <bitRange>[10:10]</bitRange>
              <description>AHBL hresp signal received </description>
            </field>
            <field>
              <name>dma_overrun</name>
              <bitRange>[9:9]</bitRange>
              <description>AHBL write buffer overrun result not written due to AHBL busy </description>
            </field>
            <field>
              <name>seq_cmpl</name>
              <bitRange>[8:8]</bitRange>
              <description>measurement sequence completed </description>
            </field>
            <field>
              <name>m7_cmpl</name>
              <bitRange>[7:7]</bitRange>
              <description>event: measurement 7 completed </description>
            </field>
            <field>
              <name>m6_cmpl</name>
              <bitRange>[6:6]</bitRange>
              <description>event: measurement 6 completed </description>
            </field>
            <field>
              <name>m5_cmpl</name>
              <bitRange>[5:5]</bitRange>
              <description>event: measurement 5 completed </description>
            </field>
            <field>
              <name>m4_cmpl</name>
              <bitRange>[4:4]</bitRange>
              <description>event: measurement 4 completed </description>
            </field>
            <field>
              <name>m3_cmpl</name>
              <bitRange>[3:3]</bitRange>
              <description>event: measurement 3 completed </description>
            </field>
            <field>
              <name>m2_cmpl</name>
              <bitRange>[2:2]</bitRange>
              <description>event: measurement 2 completed </description>
            </field>
            <field>
              <name>m1_cmpl</name>
              <bitRange>[1:1]</bitRange>
              <description>event: measurement 1 completed </description>
            </field>
            <field>
              <name>m0_cmpl</name>
              <bitRange>[0:0]</bitRange>
              <description>event: measurement 0 completed </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_irq_mask_set': 0xFF401B78-->
          <name>madc_seq_irq_mask_set</name>
          <description>IRQ enable mask: The IRQ mask enables interrupt requests for corresponding interrupt sources.   As its bits might be changed by different software tasks,   the IRQ mask register is not writable directly, but by set and reset masks: Write access with '1' sets interrupt mask bit. Write access with '0' does not influence this bit. Read access shows actual interrupt mask. Attention: Before activating interrupt mask, delete old pending interrupts by writing the same value to adr_mpwm_irq_raw. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000078</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000007FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:11]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>dma_hresp</name>
              <bitRange>[10:10]</bitRange>
              <description>AHBL hresp signal received </description>
            </field>
            <field>
              <name>dma_overrun</name>
              <bitRange>[9:9]</bitRange>
              <description>AHBL write buffer overrun result not written due to AHBL busy </description>
            </field>
            <field>
              <name>seq_cmpl</name>
              <bitRange>[8:8]</bitRange>
              <description>measurement sequence completed </description>
            </field>
            <field>
              <name>m7_cmpl</name>
              <bitRange>[7:7]</bitRange>
              <description>event: measurement 7 completed </description>
            </field>
            <field>
              <name>m6_cmpl</name>
              <bitRange>[6:6]</bitRange>
              <description>event: measurement 6 completed </description>
            </field>
            <field>
              <name>m5_cmpl</name>
              <bitRange>[5:5]</bitRange>
              <description>event: measurement 5 completed </description>
            </field>
            <field>
              <name>m4_cmpl</name>
              <bitRange>[4:4]</bitRange>
              <description>event: measurement 4 completed </description>
            </field>
            <field>
              <name>m3_cmpl</name>
              <bitRange>[3:3]</bitRange>
              <description>event: measurement 3 completed </description>
            </field>
            <field>
              <name>m2_cmpl</name>
              <bitRange>[2:2]</bitRange>
              <description>event: measurement 2 completed </description>
            </field>
            <field>
              <name>m1_cmpl</name>
              <bitRange>[1:1]</bitRange>
              <description>event: measurement 1 completed </description>
            </field>
            <field>
              <name>m0_cmpl</name>
              <bitRange>[0:0]</bitRange>
              <description>event: measurement 0 completed </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'madc_seq_irq_mask_reset': 0xFF401B7C-->
          <name>madc_seq_irq_mask_reset</name>
          <description>IRQ disable mask: This is the corresponding reset mask to disable interrupt requests for corresponding interrupt sources: Write access with '1' resets interrupt mask bit. Write access with '0' does not influence this bit. Read access shows bit number of the lowest active bit in IRQ_MASKED or MAX+1 when no bit is set. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000007C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000007FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:11]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>dma_hresp</name>
              <bitRange>[10:10]</bitRange>
              <description>AHBL hresp signal received </description>
            </field>
            <field>
              <name>dma_overrun</name>
              <bitRange>[9:9]</bitRange>
              <description>AHBL write buffer overrun result not written due to AHBL busy </description>
            </field>
            <field>
              <name>seq_cmpl</name>
              <bitRange>[8:8]</bitRange>
              <description>measurement sequence completed </description>
            </field>
            <field>
              <name>m7_cmpl</name>
              <bitRange>[7:7]</bitRange>
              <description>event: measurement 7 completed </description>
            </field>
            <field>
              <name>m6_cmpl</name>
              <bitRange>[6:6]</bitRange>
              <description>event: measurement 6 completed </description>
            </field>
            <field>
              <name>m5_cmpl</name>
              <bitRange>[5:5]</bitRange>
              <description>event: measurement 5 completed </description>
            </field>
            <field>
              <name>m4_cmpl</name>
              <bitRange>[4:4]</bitRange>
              <description>event: measurement 4 completed </description>
            </field>
            <field>
              <name>m3_cmpl</name>
              <bitRange>[3:3]</bitRange>
              <description>event: measurement 3 completed </description>
            </field>
            <field>
              <name>m2_cmpl</name>
              <bitRange>[2:2]</bitRange>
              <description>event: measurement 2 completed </description>
            </field>
            <field>
              <name>m1_cmpl</name>
              <bitRange>[1:1]</bitRange>
              <description>event: measurement 1 completed </description>
            </field>
            <field>
              <name>m0_cmpl</name>
              <bitRange>[0:0]</bitRange>
              <description>event: measurement 0 completed </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>eth</name>
      <description>eth</description>
      <baseAddress>0xFF480000</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>64</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>eth</name>
        <value>26</value>
      </interrupt>
      <registers>
        <register>
          <!--Absolute address of 'eth_config': 0xFF480000-->
          <name>eth_config</name>
          <description>ETH config register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000004</resetValue>
          <resetMask>0x38003FFF</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:30]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>phy_mode</name>
              <bitRange>[29:29]</bitRange>
              <description>PHY mode: 0: behave like an ethernet MAC, sync to external rxclk/txclk 1: behave like an ethernet PHY, generate txclk (=rxclk), signals change their function: {            | rxclk:    not used rxd[3:0]: data input, to be connected to txd[3:0] of MAC device rxdv:     Data valid input, to be connected to txen of MAC device rxer:     Error input, to be connected to txer of MAC device txclk:    Clock output, to be connected to rxclk and txclk of MAC device txd[3:0]: Data output, to be connected to rxd[3:0] of MAC device txen:     Data valid output, to be connected to rxdv of MAC device txer:     Error output. to be connected to rxer of MAC device col:      not used crs:      not used} </description>
            </field>
            <field>
              <name>hd_suppress_loopback</name>
              <bitRange>[28:28]</bitRange>
              <description>Suppress loopback in half_duplex mode: 1: don't start RX-process, if txen is active. 0: RX and TX work indepentently. </description>
            </field>
            <field>
              <name>frequency</name>
              <bitRange>[27:27]</bitRange>
              <description>MII clock frequency: 1: 50MHz (use in PHY mode only) 0: 25MHz </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[26:14]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>rx_enable</name>
              <bitRange>[13:13]</bitRange>
              <description>Enable of receive state machine: When disabled, receive state machine is reset. After enabling, receive state machine waits for rxdv going down. If rxdv is already down, proper IFG is expected. </description>
            </field>
            <field>
              <name>rx_systime_sfd</name>
              <bitRange>[12:12]</bitRange>
              <description>Sample systime at SFD of received frame: 1: Sample systime_ns to eth_rx_systime_ns at SFD (+constant offset) 0: Sample systime_ns to eth_rx_systime_ns when rxdv gets active (+constant offset) </description>
            </field>
            <field>
              <name>rx_dma_mode</name>
              <bitRange>[11:11]</bitRange>
              <description>Receive DMA mode: Each received frame needs 2 DMA-transfers, one for package data and one for rx_len/status. In rx_dma_mode irq_raw-rx_frame_finished is reset automatically. </description>
            </field>
            <field>
              <name>rx_no_preamble</name>
              <bitRange>[10:10]</bitRange>
              <description>receive starts, when rxdv gets active </description>
            </field>
            <field>
              <name>rx_exact_preamble</name>
              <bitRange>[9:9]</bitRange>
              <description>Accept only packages with exact preamble, rx_preamble_error IRQ will be generated independant on this setting. </description>
            </field>
            <field>
              <name>rx_allow_jumbo_packets</name>
              <bitRange>[8:8]</bitRange>
              <description>Receive frames &gt; 1522 bytes. If jumbo_packets are not allowed, the receive frame buffer must be 1524 bytes. Warning: Frames with len &gt; 2047 will be received, but rx_frame_len has only 11 bit. </description>
            </field>
            <field>
              <name>rx_delay_inputs</name>
              <bitRange>[7:7]</bitRange>
              <description>Delay mii inputs (rx_d, rx_dv, rx_err, crs, col) by 1 clockcycle before sampling them. This leads to inputs fitting to sampled rxclk. Enable this in MAC mode, disable in PHY mode. </description>
            </field>
            <field>
              <name>rx_sample_phase</name>
              <bitRange>[6:4]</bitRange>
              <description>clk-phase in which rxd is sampled: PHY mode (phy_mode=1): {    | 0,4: sample at posedge tx_clk 1,5: sample at posedge tx_clk + 1cc 2,6: sample at posedge tx_clk + 2cc 3,7: sample at posedge tx_clk + 3cc} MAC mode (phy_mode=0): {  | 0: sample at posedge rx_clk + 1cc 1: sample at posedge rx_clk + 2cc 2: sample at posedge rx_clk + 3cc 3: sample at posedge rx_clk + 4cc 4: sample at negedge rx_clk + 3cc 5: sample at negedge rx_clk + 4cc 6: sample at negedge rx_clk + 1cc 7: sample at negedge rx_clk + 2cc} </description>
            </field>
            <field>
              <name>rx_watermark_irq</name>
              <bitRange>[3:0]</bitRange>
              <description>Watermark for RX-FIFO, that generates interrupt This number of DWords is available inside RX-FIFO </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'eth_tx_config': 0xFF480004-->
          <name>eth_tx_config</name>
          <description>ETH config register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x02188084</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>half_duplex</name>
              <bitRange>[31:31]</bitRange>
              <description>Half Duplex Mode: 1: In half duplex mode transmission of a frame starts after the following sequence: - tx_watermark_start was reached - mii_crs became low and stayed low for tx_crs_low_cycles - (tx_min_ifg_cycles - tx_crs_low_cycles) are passed 0: In full duplex mode transmission of a frame starts after the following sequence: - tx_min_ifg_cycles are passed after the last transmitted frame - tx_watermark_start was reached </description>
            </field>
            <field>
              <name>tx_dma_mode</name>
              <bitRange>[30:30]</bitRange>
              <description>In tx_dma_mode tx_len comes from DMAC automatically. An extra tx_lsreq will be generated to request tx_len, before frame data is requested (and after previous frame is finished). In tx_dma_mode irq_raw-tx_frame_finished is reset automatically. </description>
            </field>
            <field>
              <name>tx_systime_sfd</name>
              <bitRange>[29:29]</bitRange>
              <description>Sample systime at SFD: 1: Sample systime_ns to eth_tx_systime_ns at SFD (-constant offset) 0: Sample systime_ns to eth_tx_systime_ns when txen gets active (-constant offset) </description>
            </field>
            <field>
              <name>tx_abort_frame</name>
              <bitRange>[28:26]</bitRange>
              <description>Different abort mechanisms: 000: no abort: Transmit frame from TX-FIFO until tx_len and append correct FCS. 001: standard abort: Abort transmission, send wrong FCS, activate mii_txer. SW should keep bit active until irq-tx_frame_finished, then reset TX-FIFO. 010: abort with dribble nibble: Like standard abort, but append dribble nibble after wrong FCS (needed by some PHYs to detect error condition) SW should keep bit active until irq-tx_frame_finished, then reset TX-FIFO. 011: no FCS mode: Transmit frame from TX-FIFO until tx_len but do not append FCS. Never activate mii_txer (except in case of tx_fifo_undr). 100: Fast Track Switching controlled abort: Wait for next byte-border, then attach special FCS as wrong FCS. Special FCS is 'a0a0a0a0', or 'a0a0a0a1' in case that real FCS would end with 'a0'. Do not activate mii_txer. SW should keep bit active until irq-tx_frame_finished, then reset TX-FIFO. 101: reserved 110: reserved 111: reserved </description>
            </field>
            <field>
              <name>tx_crs_low_cycles</name>
              <bitRange>[25:21]</bitRange>
              <description>txclk-cycles with mii_crs low, before free carrier is detected (only used in half_duplex mode): Value range: [0,tx_min_ifg_cycles]. For details s. half_duplex mode. </description>
            </field>
            <field>
              <name>tx_min_ifg_cycles</name>
              <bitRange>[20:16]</bitRange>
              <description>minimum IFG in txclk-cycles In half_duplex mode reduce value by 2 to compensate cycles for sampling of mii_crs. </description>
            </field>
            <field>
              <name>tx_preamble_len</name>
              <bitRange>[15:11]</bitRange>
              <description>Length of TX-preamble in nibbles (incl. SFD) </description>
            </field>
            <field>
              <name>tx_output_phase</name>
              <bitRange>[10:8]</bitRange>
              <description>clk-phase in which txd, txen, txer is changed at output PHY mode (phy_mode=1): {    | 0,4: change output at negedge tx_clk 1,5: change output at negedge tx_clk + 1cc 2,6: change output at negedge tx_clk + 2cc 3,7: change output at negedge tx_clk + 3cc} MAC mode (phy_mode=0): {  | 0: change output at posedge tx_clk + 2cc 1: change output at posedge tx_clk + 3cc 2: change output at posedge tx_clk + 4cc 3: change output at posedge tx_clk + 5cc 4: change output at negedge tx_clk + 4cc 5: change output at negedge tx_clk + 5cc 6: change output at negedge tx_clk + 2cc 7: change output at negedge tx_clk + 3cc} </description>
            </field>
            <field>
              <name>tx_watermark_start</name>
              <bitRange>[7:4]</bitRange>
              <description>Watermark for TX-FIFO, that starts transmission. This number of DWords is inside TX-FIFO </description>
            </field>
            <field>
              <name>tx_watermark_irq</name>
              <bitRange>[3:0]</bitRange>
              <description>Watermark for TX-FIFO, that generates IRQ. This number of DWords is free inside TX-FIFO </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'eth_status': 0xFF480008-->
          <name>eth_status</name>
          <description>ETH status register: </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000F9F</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:12]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>tx_fill</name>
              <bitRange>[11:7]</bitRange>
              <description>Fill-level of TX-FIFO </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[6:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>rx_fill</name>
              <bitRange>[4:0]</bitRange>
              <description>Fill-level of RX-FIFO </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'eth_tx_data': 0xFF48000C-->
          <name>eth_tx_data</name>
          <description>Data to TX-FIFO: returns 0xdeadbeef on read </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data to TX-FIFO </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'eth_rx_data': 0xFF480010-->
          <name>eth_rx_data</name>
          <description>Data from RX-FIFO: </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000010</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>data from RX-FIFO </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'eth_tx_len': 0xFF480014-->
          <name>eth_tx_len</name>
          <description>Length of data inside transmitted frame (between SFD and FCS) Note: Set this value after previous frame is completely transmitted (irq-tx_frame_finished). </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x000005EA</resetValue>
          <resetMask>0x000007FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:11]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[10:0]</bitRange>
              <description>To be transmitted data length (excluding SFD and excluding FCS) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'eth_rx_len_stat': 0xFF480018-->
          <name>eth_rx_len_stat</name>
          <description>Length and status information of lastly received frame </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000018</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xF80007FF</resetMask>
          <fields>
            <field>
              <name>rx_mii_rxerr</name>
              <bitRange>[31:31]</bitRange>
              <description>external rxerr signal was active in last frame </description>
            </field>
            <field>
              <name>rx_crc_error</name>
              <bitRange>[30:30]</bitRange>
              <description>wrong RX FCS detected </description>
            </field>
            <field>
              <name>rx_dribble_nibble</name>
              <bitRange>[29:29]</bitRange>
              <description>frame finished at non-even nibble count, last nibble was dropped </description>
            </field>
            <field>
              <name>rx_jumbo_packet</name>
              <bitRange>[28:28]</bitRange>
              <description>rx_frame_len &gt; 1522 detected: In case of eth_config-allow_jumbo_packets=1, this frame was received, but rx_len will overflow at 2048. In case of eth_config-allow_jumbo_packets=0, frame is stopped after 1522, but other status information (rxerr, crc, dribble_nibble) will be checked anyway. </description>
            </field>
            <field>
              <name>rx_short_ifg</name>
              <bitRange>[27:27]</bitRange>
              <description>IFG shorter 960ns detected (preceeding this frame). </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[26:11]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>rx_len</name>
              <bitRange>[10:0]</bitRange>
              <description>Received data (excluding SFD and including FCS) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'eth_rx_systime_ns': 0xFF480020-->
          <name>eth_rx_systime_ns</name>
          <description>Systime_ns sampled at start of received frame. Exact position of start of frame is defined in eth_config-systime_sfd. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000020</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Sampled systime_ns </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'eth_tx_systime_ns': 0xFF480024-->
          <name>eth_tx_systime_ns</name>
          <description>Systime_ns sampled at start of transmitted frame. Exact position of start of frame is defined in eth_tx_config-systime_sfd. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000024</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Sampled systime_ns </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'eth_irq_raw': 0xFF480028-->
          <name>eth_irq_raw</name>
          <description>Raw IRQ: Read access shows status of unmasked IRQs.   IRQs are set automatically and reset by writing to this register: Write access with '1' resets the appropriate IRQ. Write access with '0' does not influence this bit. Write access with '1' to rx_/tx_fifo_undr/_ovfl resets RX-FIFO/TX-FIFO. Bits rx_data and tx_fifo are cleared by reading from/filling the appropriate FIFO. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000028</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00001FFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:13]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>tx_late_col</name>
              <bitRange>[12:12]</bitRange>
              <description>late colision detected in half_duplex mode, started sending jam </description>
            </field>
            <field>
              <name>tx_col</name>
              <bitRange>[11:11]</bitRange>
              <description>collision detected in half_duplex mode, started sending jam </description>
            </field>
            <field>
              <name>rx_preamble_error</name>
              <bitRange>[10:10]</bitRange>
              <description>data &lt;&gt; 0x5 during preamble or wrong length of preamble </description>
            </field>
            <field>
              <name>rx_short_dv</name>
              <bitRange>[9:9]</bitRange>
              <description>mii_rxdv becomes low before SFD </description>
            </field>
            <field>
              <name>rx_cpu_too_slow</name>
              <bitRange>[8:8]</bitRange>
              <description>next frame started before irq_raw_rx_frame_finished was cleared </description>
            </field>
            <field>
              <name>rx_fifo_ovfl</name>
              <bitRange>[7:7]</bitRange>
              <description>RX-FIFO overflow </description>
            </field>
            <field>
              <name>rx_fifo_undr</name>
              <bitRange>[6:6]</bitRange>
              <description>RX-FIFO underrun (debug only, can never happen in ASIC) </description>
            </field>
            <field>
              <name>tx_fifo_ovfl</name>
              <bitRange>[5:5]</bitRange>
              <description>TX-FIFO overflow (debug only, can never happen in ASIC) </description>
            </field>
            <field>
              <name>tx_fifo_undr</name>
              <bitRange>[4:4]</bitRange>
              <description>TX-FIFO underrun </description>
            </field>
            <field>
              <name>rx_frame_finished</name>
              <bitRange>[3:3]</bitRange>
              <description>RX frame finished: Clearing this bit tells the module, that the CPU has read rx_len_stat and the next frame can be received. In rx_dma_mode this bit is handled automatically, demask it to the CPU. </description>
            </field>
            <field>
              <name>rx_data</name>
              <bitRange>[2:2]</bitRange>
              <description>RX Data is available </description>
            </field>
            <field>
              <name>tx_frame_finished</name>
              <bitRange>[1:1]</bitRange>
              <description>TX frame finished: In tx_dma_mode this bit is handled automatically, demask it to the CPU. </description>
            </field>
            <field>
              <name>tx_fifo</name>
              <bitRange>[0:0]</bitRange>
              <description>TX-FIFO has free entries </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'eth_irq_masked': 0xFF48002C-->
          <name>eth_irq_masked</name>
          <description>Masked IRQ: Shows status of masked IRQs as connected to ARM/xPIC. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000002C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00001FFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:13]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>tx_late_col</name>
              <bitRange>[12:12]</bitRange>
              <description>late colision detected in half_duplex mode, started sending jam </description>
            </field>
            <field>
              <name>tx_col</name>
              <bitRange>[11:11]</bitRange>
              <description>collision detected in half_duplex mode, started sending jam </description>
            </field>
            <field>
              <name>rx_preamble_error</name>
              <bitRange>[10:10]</bitRange>
              <description>data &lt;&gt; 0x5 during preamble or wrong length of preamble </description>
            </field>
            <field>
              <name>rx_short_dv</name>
              <bitRange>[9:9]</bitRange>
              <description>mii_rxdv becomes low before SFD </description>
            </field>
            <field>
              <name>rx_cpu_too_slow</name>
              <bitRange>[8:8]</bitRange>
              <description>next frame started before irq_raw_rx_frame_finished was cleared </description>
            </field>
            <field>
              <name>rx_fifo_ovfl</name>
              <bitRange>[7:7]</bitRange>
              <description>RX-FIFO overflow </description>
            </field>
            <field>
              <name>rx_fifo_undr</name>
              <bitRange>[6:6]</bitRange>
              <description>RX-FIFO underrun (debug only, can never happen in ASIC) </description>
            </field>
            <field>
              <name>tx_fifo_ovfl</name>
              <bitRange>[5:5]</bitRange>
              <description>TX-FIFO overflow (debug only, can never happen in ASIC) </description>
            </field>
            <field>
              <name>tx_fifo_undr</name>
              <bitRange>[4:4]</bitRange>
              <description>TX-FIFO underrun </description>
            </field>
            <field>
              <name>rx_frame_finished</name>
              <bitRange>[3:3]</bitRange>
              <description>RX frame finished </description>
            </field>
            <field>
              <name>rx_data</name>
              <bitRange>[2:2]</bitRange>
              <description>RX Data is available </description>
            </field>
            <field>
              <name>tx_frame_finished</name>
              <bitRange>[1:1]</bitRange>
              <description>TX frame finished </description>
            </field>
            <field>
              <name>tx_fifo</name>
              <bitRange>[0:0]</bitRange>
              <description>TX-FIFO has free entries </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'eth_irq_msk_set': 0xFF480030-->
          <name>eth_irq_msk_set</name>
          <description>IRQ mask set: The IRQ mask enables interrupt requests for corresponding interrupt sources.   As its bits might be changed by different software tasks,   the IRQ mask register is not writable directly, but by set and reset masks: Write access with '1' sets interrupt mask bit. Write access with '0' does not influence this bit. Read access shows actual interrupt mask. Attention: Before activating interrupt mask, delete old pending interrupts by writing the same value to adr_eth_irq_raw. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000030</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00001FFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:13]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>tx_late_col</name>
              <bitRange>[12:12]</bitRange>
              <description>late colision detected in half_duplex mode, started sending jam </description>
            </field>
            <field>
              <name>tx_col</name>
              <bitRange>[11:11]</bitRange>
              <description>collision detected in half_duplex mode, started sending jam </description>
            </field>
            <field>
              <name>rx_preamble_error</name>
              <bitRange>[10:10]</bitRange>
              <description>data &lt;&gt; 0x5 during preamble or wrong length of preamble </description>
            </field>
            <field>
              <name>rx_short_dv</name>
              <bitRange>[9:9]</bitRange>
              <description>mii_rxdv becomes low before SFD </description>
            </field>
            <field>
              <name>rx_cpu_too_slow</name>
              <bitRange>[8:8]</bitRange>
              <description>next frame started before irq_raw_rx_frame_finished was cleared </description>
            </field>
            <field>
              <name>rx_fifo_ovfl</name>
              <bitRange>[7:7]</bitRange>
              <description>RX-FIFO overflow </description>
            </field>
            <field>
              <name>rx_fifo_undr</name>
              <bitRange>[6:6]</bitRange>
              <description>RX-FIFO underrun (debug only, can never happen in ASIC) </description>
            </field>
            <field>
              <name>tx_fifo_ovfl</name>
              <bitRange>[5:5]</bitRange>
              <description>TX-FIFO overflow (debug only, can never happen in ASIC) </description>
            </field>
            <field>
              <name>tx_fifo_undr</name>
              <bitRange>[4:4]</bitRange>
              <description>TX-FIFO underrun </description>
            </field>
            <field>
              <name>rx_frame_finished</name>
              <bitRange>[3:3]</bitRange>
              <description>RX frame finished </description>
            </field>
            <field>
              <name>rx_data</name>
              <bitRange>[2:2]</bitRange>
              <description>RX Data is available </description>
            </field>
            <field>
              <name>tx_frame_finished</name>
              <bitRange>[1:1]</bitRange>
              <description>TX frame finished </description>
            </field>
            <field>
              <name>tx_fifo</name>
              <bitRange>[0:0]</bitRange>
              <description>TX-FIFO has free entries </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'eth_irq_msk_reset': 0xFF480034-->
          <name>eth_irq_msk_reset</name>
          <description>IRQ mask reset: This is the corresponding reset mask to disable interrupt requests for corresponding interrupt sources: Write access with '1' resets interrupt mask bit. Write access with '0' does not influence this bit. Read access shows actual interrupt mask. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000034</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00001FFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:13]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>tx_late_col</name>
              <bitRange>[12:12]</bitRange>
              <description>late colision detected in half_duplex mode, started sending jam </description>
            </field>
            <field>
              <name>tx_col</name>
              <bitRange>[11:11]</bitRange>
              <description>collision detected in half_duplex mode, started sending jam </description>
            </field>
            <field>
              <name>rx_preamble_error</name>
              <bitRange>[10:10]</bitRange>
              <description>data &lt;&gt; 0x5 during preamble or wrong length of preamble </description>
            </field>
            <field>
              <name>rx_short_dv</name>
              <bitRange>[9:9]</bitRange>
              <description>mii_rxdv becomes low before SFD </description>
            </field>
            <field>
              <name>rx_cpu_too_slow</name>
              <bitRange>[8:8]</bitRange>
              <description>next frame started before irq_raw_rx_frame_finished was cleared </description>
            </field>
            <field>
              <name>rx_fifo_ovfl</name>
              <bitRange>[7:7]</bitRange>
              <description>RX-FIFO overflow </description>
            </field>
            <field>
              <name>rx_fifo_undr</name>
              <bitRange>[6:6]</bitRange>
              <description>RX-FIFO underrun (debug only, can never happen in ASIC) </description>
            </field>
            <field>
              <name>tx_fifo_ovfl</name>
              <bitRange>[5:5]</bitRange>
              <description>TX-FIFO overflow (debug only, can never happen in ASIC) </description>
            </field>
            <field>
              <name>tx_fifo_undr</name>
              <bitRange>[4:4]</bitRange>
              <description>TX-FIFO underrun </description>
            </field>
            <field>
              <name>rx_frame_finished</name>
              <bitRange>[3:3]</bitRange>
              <description>RX frame finished </description>
            </field>
            <field>
              <name>rx_data</name>
              <bitRange>[2:2]</bitRange>
              <description>RX Data is available </description>
            </field>
            <field>
              <name>tx_frame_finished</name>
              <bitRange>[1:1]</bitRange>
              <description>TX frame finished </description>
            </field>
            <field>
              <name>tx_fifo</name>
              <bitRange>[0:0]</bitRange>
              <description>TX-FIFO has free entries </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'eth_miimu': 0xFF480038-->
          <name>eth_miimu</name>
          <description>MDIO FSM interface controlling for netX external PHY. Note:    Loopback for purpose is provided by miimu_sw register and also performed    in non-software-mode when enabled. Note:    Prior phy_nres-bit was removed. PHY reset must be done by register ASIC_CTRL.phy_control. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000038</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFEF</resetMask>
          <fields>
            <field>
              <name>data</name>
              <bitRange>[31:16]</bitRange>
              <description>Data to or from PHY register </description>
            </field>
            <field>
              <name>phyaddr</name>
              <bitRange>[15:11]</bitRange>
              <description>PHY address </description>
            </field>
            <field>
              <name>regaddr</name>
              <bitRange>[10:6]</bitRange>
              <description>Register address </description>
            </field>
            <field>
              <name>rta</name>
              <bitRange>[5:5]</bitRange>
              <description>Read Turn Around field: 0: one bit 1: two bits </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[4:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>mdc_period</name>
              <bitRange>[3:3]</bitRange>
              <description>MDC period: 1: 800ns 0: 400ns </description>
            </field>
            <field>
              <name>opmode</name>
              <bitRange>[2:2]</bitRange>
              <description>Operation mode: 1: write 0: read </description>
            </field>
            <field>
              <name>preamble</name>
              <bitRange>[1:1]</bitRange>
              <description>Send preamble </description>
            </field>
            <field>
              <name>snrdy</name>
              <bitRange>[0:0]</bitRange>
              <description>Start not ready </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'eth_miimu_sw': 0xFF48003C-->
          <name>eth_miimu_sw</name>
          <description>MDIO software interface controlling for netX internal PHY. Note:    Function is similar to old MIIMU unit register 'miimu_sw', however data output    enable was removed as it is not necessary for MDIO interface to internal PHY (due    to non-bidirectional data signal). </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000003C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000001F1</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:9]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>loopback</name>
              <bitRange>[8:8]</bitRange>
              <description>MDIO-data-out to data-in loopback for test purpose. 0: no loopback, MDIO-data-in comes from internal PHY. 1: loopback, MDIO-data-in comes from current MDIO-data-out. Note: Loopback can also be used in non-software-mode. </description>
            </field>
            <field>
              <name>mdi_ro</name>
              <bitRange>[7:7]</bitRange>
              <description>current MDI value </description>
            </field>
            <field>
              <name>mdoe</name>
              <bitRange>[6:6]</bitRange>
              <description>MDOE value for software mode </description>
            </field>
            <field>
              <name>mdo</name>
              <bitRange>[5:5]</bitRange>
              <description>MDO value for software mode </description>
            </field>
            <field>
              <name>mdc</name>
              <bitRange>[4:4]</bitRange>
              <description>MDC value for software mode </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>enable</name>
              <bitRange>[0:0]</bitRange>
              <description>Enables software mode: MDC, MDO and MDOE are set by software. </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <dim>4</dim>
      <dimIncrement>0x20</dimIncrement>
      <name>dmac_app_ch[%s]</name>
      <description>dmac_app_ch0</description>
      <baseAddress>0xFF800100</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>32</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <!--Absolute address of 'dmac_chsrc_ad': 0xFF800100-->
          <name>dmac_chsrc_ad</name>
          <description>channel source address registers </description>
          <dataType>uint32_t *</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMACCHSRCADDR</name>
              <bitRange>[31:0]</bitRange>
              <description>DMA source address </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'dmac_chdest_ad': 0xFF800104-->
          <name>dmac_chdest_ad</name>
          <description>channel destination address registers </description>
          <dataType>uint32_t *</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMACCHDESTADDR</name>
              <bitRange>[31:0]</bitRange>
              <description>DMA destination address </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'dmac_chlink': 0xFF800108-->
          <name>dmac_chlink</name>
          <description>channel linked list item register </description>
          <dataType>uint32_t *</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFC</resetMask>
          <fields>
            <field>
              <name>LLIADDR</name>
              <bitRange>[31:2]</bitRange>
              <description>Linked list item. Bits [31:2] of the address for the next LLI. Address bits [1:0] are 0. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[1:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'dmac_chctrl': 0xFF80010C-->
          <name>dmac_chctrl</name>
          <description>channel control registers </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFDFFFFFF</resetMask>
          <fields>
            <field>
              <name>I</name>
              <bitRange>[31:31]</bitRange>
              <description>Terminal count interrupt enable bit. It controls whether the current LLI is expected to trigger the terminal count interrupt. </description>
            </field>
            <field>
              <name>Prot</name>
              <bitRange>[30:28]</bitRange>
              <description>Protection. </description>
            </field>
            <field>
              <name>DI</name>
              <bitRange>[27:27]</bitRange>
              <description>Destination increment. When set the destination address is incremented after each transfer. </description>
            </field>
            <field>
              <name>SI</name>
              <bitRange>[26:26]</bitRange>
              <description>Source increment. When set the source address is incremented after each transfer. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[25:25]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ARM_EQ</name>
              <bitRange>[24:24]</bitRange>
              <description>Set equal behaviour to arm implementation This bit should always be set to 1 (default of 0 is from historical reasons). This bit changes 2 behavioural details: 1. ARM_EQ=1: ignore single requests in DMA-controlled Memory-to-Peripheral accesses. ARM_EQ=0: handle single requests like burst requests (in this case DBSize should be 1 access). Note: In DMA-controlled Memory-to-Peripheral mode only burst request signals are allowed. The behaviour of single requests (from peripheral to DMAC) is not defined. Modules generating single requests anyways might use ARM_EQ=0 in combination with DBSize=000. 2. ARM_EQ=1: Always read 0 from TransferSize in this register. ARM_EQ=0: Read some internal value for debug purposes </description>
            </field>
            <field>
              <name>DWidth</name>
              <bitRange>[23:21]</bitRange>
              <description>Destination transfer width: The source and destination widths can be different from each other. The hardware automatically packs and unpacks the data as required. _________________________ bit_value      data_width ------------------------- 000             8 bit 001            16 bit 010            32 bit ========================= </description>
            </field>
            <field>
              <name>SWidth</name>
              <bitRange>[20:18]</bitRange>
              <description>Source transfer width: The source and destination widths can be different from each other. The hardware automatically packs and unpacks the data as required. _________________________ bit_value      data_width ------------------------- 000             8 bit 001            16 bit 010            32 bit ========================= </description>
            </field>
            <field>
              <name>DBSize</name>
              <bitRange>[17:15]</bitRange>
              <description>Destination burst size: Indicates the number of transfers which make up a destination burst transfer request. This value must be set to the burst size of the destination peripheral, or if the destination is memory, to the memory boundary size. The burst size is the amount of data that is transferred when the DMACxBREQ signal goes active in the destination peripheral. The burst size is not related to the AHB HBURST signal. Note: If flow controller is DMAC and destination is a peripheral, only bursts are transferred to the peripheral (DMACxSREQ is ignored if set by peripheral). The source burst size has no such limitation. ________________________________ bit_value    burst_transfer_size -------------------------------- 000         1 001         4 010         8 011         16 100         32 101         64 110         128 111         256 ================================ </description>
            </field>
            <field>
              <name>SBSize</name>
              <bitRange>[14:12]</bitRange>
              <description>Source burst size: Indicates the number of transfers which make up a source burst. This value must be set to the burst size of the source peripheral, or if the source is memory, to the memory boundary size. The burst size is the amount of data that is transferred when the DMACxBREQ signal goes active in the source peripheral. The burst size is not related to the AHB HBURST signal. ________________________________ bit_value    burst_transfer_size -------------------------------- 000         1 001         4 010         8 011         16 100         32 101         64 110         128 111         256 ================================ </description>
            </field>
            <field>
              <name>TransferSize</name>
              <bitRange>[11:0]</bitRange>
              <description>Transfer size: For writes, this field indicates the number of (Source width) transfers to perform when the DMAC is the flow controller. For reads, the transfer size indicates the number of transfers completed on the destination bus. Reading the register when the channel is active does not give useful information, as by the time that the software has processed the value read, the channel might have progressed. It is intended to be used only when a channel is enabled and then disabled. If the DMAC controller is not the flow controller the transfer size should be set to 0. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'dmac_chcfg': 0xFF800110-->
          <name>dmac_chcfg</name>
          <description>channel configuration registers </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0007FBDF</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:19]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>H</name>
              <bitRange>[18:18]</bitRange>
              <description>Halt: 0 = allow DMA requests 1 = ignore further source DMA requests. The contents of the channels FIFO are drained. This value can be used with the Active and Channel Enable bits to cleanly disable a DMA channel. </description>
            </field>
            <field>
              <name>A</name>
              <bitRange>[17:17]</bitRange>
              <description>Active: 0 = there is no data in the FIFO of the channel 1 = the FIFO of the channel has data. (ro) This value can be used with the Halt and Channel Enable bits to cleanly disable a DMA channel. </description>
            </field>
            <field>
              <name>L</name>
              <bitRange>[16:16]</bitRange>
              <description>Lock. When set this bit enables locked transfers. </description>
            </field>
            <field>
              <name>ITC</name>
              <bitRange>[15:15]</bitRange>
              <description>Terminal count interrupt mask. When cleared this bit masks out the terminal count interrupt of the relevant channel. </description>
            </field>
            <field>
              <name>IE</name>
              <bitRange>[14:14]</bitRange>
              <description>Interrupt error mask. When cleared this bit masks out the error interrupt of the relevant channel. </description>
            </field>
            <field>
              <name>FlowCntrl</name>
              <bitRange>[13:11]</bitRange>
              <description>Flow control and transfer type. This value is used to indicate the flow controller and transfer type. The flow controller can be the DMAC, the source peripheral, or the destination peripheral. The transfer type can be either memory-to-memory, memory-to-peripheral, peripheral-to-memory, or peripheral-to-peripheral. _______________________________________________________________________ bit_value     transfer_type                                  controller ----------------------------------------------------------------------- 000           Memory-to-memory                               DMAC 001           Memory-to-peripheral                           DMAC 010           Peripheral-to-memorys                          DMAC 011           Source peripheral-to-destination peripheral    DMAC (not supported in netX system) 100           Source peripheral-to-destination peripheral    Destination peripheral (not supported in netX system) 101           Memory-to-peripheral                           Peripheral 110           Peripheral-to-memory                           Peripheral 111           Source peripheral-to-destination peripheral    Source peripheral (not supported in netX system) ======================================================================== Note: Peripheral-to-peripheral transfers are configurable, but not supported in the netX system. Don't use these three modes. </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[10:10]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>DestPeripheral</name>
              <bitRange>[9:6]</bitRange>
              <description>Destination peripheral. This value selects the DMA destination request peripheral. This field is ignored if the destination of the transfer is to memory. For mapping of peripheral to value see 'SrcPeripheral' bit-field in this register. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>SrcPeripheral</name>
              <bitRange>[4:1]</bitRange>
              <description>Source peripheral. This value selects the DMA source request peripheral. This field is ignored if the source of the transfer is from memory. Note: The mapping of peripherals to App-side DMAC inputs is done within the DMAC_MUX_APP module. See 'dmac_mux_peripheral_input_sel*' registers for default mapping / current mapping. {      |                  | value   Com-side           App-side 0        uart_rx           dmac_mux_peripheral_input_sel0 1        uart_tx           dmac_mux_peripheral_input_sel1 2        i2c0_com_master   dmac_mux_peripheral_input_sel2 3        i2c0_com_slave    dmac_mux_peripheral_input_sel3 4        i2c1_com_master   dmac_mux_peripheral_input_sel4 5        i2c1_com_slave    dmac_mux_peripheral_input_sel5 6        sqi_rx            dmac_mux_peripheral_input_sel6 7        sqi_tx            dmac_mux_peripheral_input_sel7 8        eth_rx            reserved 9        eth_tx            reserved 10       hash              reserved 11       aes_in            reserved 12       aes_out           reserved 13       reserved          reserved 14       reserved          reserved 15       reserved          reserved } </description>
            </field>
            <field>
              <name>E</name>
              <bitRange>[0:0]</bitRange>
              <description>Channel enable. Reading this bit indicates whether a channel is currently enabled or disabled: 0 = channel disabled 1 = channel enabled. The Channel Enable bit status can also be found by reading the DMACEnbldChns register. A channel is enabled by setting this bit. Before enabling a single channel the DMA controller must be enabled globally by setting the DMACENABLE bit in the dmac_config register. Enabling a channel while the controller is disabled leads to undefined behaviour. A channel can be disabled by clearing the Enable bit. This causes the current AHB transfer (if one is in progress) to complete and the channel is then disabled. Any data in the channels FIFO is lost. Restarting the channel by simply setting the Channel Enable bit has unpredictable effects and the channel must be fully re-initialized. The channel is also disabled, and Channel Enable bit cleared, when the last LLI is reached or if a channel error is encountered. If a channel has to be disabled without losing data in a channels FIFO the Halt bit must be set so that further DMA requests are ignored. The Active bit must then be polled until it reaches 0, indicating that there is no data left in the channels FIFO. Finally the Channel Enable bit can be cleared. </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>dmac_app_reg</name>
      <description>dmac_app_reg</description>
      <baseAddress>0xFF800800</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>2048</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>dmac_app</name>
        <value>6</value>
      </interrupt>
      <registers>
        <register>
          <!--Absolute address of 'dmac_int_status': 0xFF800800-->
          <name>dmac_int_status</name>
          <description>interrupt status register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>DMACINT_ch3</name>
              <bitRange>[3:3]</bitRange>
              <description>Status of DMA channel 3 - interrupt after masking. 1'b1 indicates an active interrupt request. </description>
            </field>
            <field>
              <name>DMACINT_ch2</name>
              <bitRange>[2:2]</bitRange>
              <description>Status of DMA channel 2 - interrupt after masking. 1'b1 indicates an active interrupt request. </description>
            </field>
            <field>
              <name>DMACINT_ch1</name>
              <bitRange>[1:1]</bitRange>
              <description>Status of DMA channel 1 - interrupt after masking. 1'b1 indicates an active interrupt request. </description>
            </field>
            <field>
              <name>DMACINT_ch0</name>
              <bitRange>[0:0]</bitRange>
              <description>Status of DMA channel 0 - interrupt after masking. 1'b1 indicates an active interrupt request. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'dmac_inttc_status': 0xFF800804-->
          <name>dmac_inttc_status</name>
          <description>interrupt terminal count status register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>DMACINTTC_ch3</name>
              <bitRange>[3:3]</bitRange>
              <description>Status of DMA channel 3 - terminal count interrupt after masking. 1'b1 indicates an active interrupt request. </description>
            </field>
            <field>
              <name>DMACINTTC_ch2</name>
              <bitRange>[2:2]</bitRange>
              <description>Status of DMA channel 2 - terminal count interrupt after masking. 1'b1 indicates an active interrupt request. </description>
            </field>
            <field>
              <name>DMACINTTC_ch1</name>
              <bitRange>[1:1]</bitRange>
              <description>Status of DMA channel 1 - terminal count interrupt after masking. 1'b1 indicates an active interrupt request. </description>
            </field>
            <field>
              <name>DMACINTTC_ch0</name>
              <bitRange>[0:0]</bitRange>
              <description>Status of DMA channel 0 - terminal count interrupt after masking. 1'b1 indicates an active interrupt request. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'dmac_inttc_clear': 0xFF800808-->
          <name>dmac_inttc_clear</name>
          <description>interrupt terminal count clear register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>DMACINTTCCLR_ch3</name>
              <bitRange>[3:3]</bitRange>
              <description>Writing a 1'b1 Bit clears the terminal count interrupt of the specific channel 3 ,1'b0 have no effect. </description>
            </field>
            <field>
              <name>DMACINTTCCLR_ch2</name>
              <bitRange>[2:2]</bitRange>
              <description>Writing a 1'b1 Bit clears the terminal count interrupt of the specific channel 2 ,1'b0 have no effect. </description>
            </field>
            <field>
              <name>DMACINTTCCLR_ch1</name>
              <bitRange>[1:1]</bitRange>
              <description>Writing a 1'b1 Bit clears the terminal count interrupt of the specific channel 1 ,1'b0 have no effect. </description>
            </field>
            <field>
              <name>DMACINTTCCLR_ch0</name>
              <bitRange>[0:0]</bitRange>
              <description>Writing a 1'b1 Bit clears the terminal count interrupt of the specific channel 0 ,1'b0 have no effect. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'dmac_interr_status': 0xFF80080C-->
          <name>dmac_interr_status</name>
          <description>interrupt error status register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>DMACINTERR_ch3</name>
              <bitRange>[3:3]</bitRange>
              <description>Status of DMA channel 3 - error interrupt after masking. 1'b1 indicates an active interrupt request. </description>
            </field>
            <field>
              <name>DMACINTERR_ch2</name>
              <bitRange>[2:2]</bitRange>
              <description>Status of DMA channel 2 - error interrupt after masking. 1'b1 indicates an active interrupt request. </description>
            </field>
            <field>
              <name>DMACINTERR_ch1</name>
              <bitRange>[1:1]</bitRange>
              <description>Status of DMA channel 1 - error interrupt after masking. 1'b1 indicates an active interrupt request. </description>
            </field>
            <field>
              <name>DMACINTERR_ch0</name>
              <bitRange>[0:0]</bitRange>
              <description>Status of DMA channel 0 - error interrupt after masking. 1'b1 indicates an active interrupt request. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'dmac_interr_clear': 0xFF800810-->
          <name>dmac_interr_clear</name>
          <description>interrupt error clear register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000010</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>DMACINTERRCLR_ch3</name>
              <bitRange>[3:3]</bitRange>
              <description>Writing a 1'b1 Bit clears the error interrupt of the specific channel 3 ,1'b0 have no effect. </description>
            </field>
            <field>
              <name>DMACINTERRCLR_ch2</name>
              <bitRange>[2:2]</bitRange>
              <description>Writing a 1'b1 Bit clears the error interrupt of the specific channel 2 ,1'b0 have no effect. </description>
            </field>
            <field>
              <name>DMACINTERRCLR_ch1</name>
              <bitRange>[1:1]</bitRange>
              <description>Writing a 1'b1 Bit clears the error interrupt of the specific channel 1 ,1'b0 have no effect. </description>
            </field>
            <field>
              <name>DMACINTERRCLR_ch0</name>
              <bitRange>[0:0]</bitRange>
              <description>Writing a 1'b1 Bit clears the error interrupt of the specific channel 0 ,1'b0 have no effect. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'dmac_rawinttc_status': 0xFF800814-->
          <name>dmac_rawinttc_status</name>
          <description>raw interrupt terminal count status register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000014</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>DMACRAWINTTC_ch3</name>
              <bitRange>[3:3]</bitRange>
              <description>Status of DMA channel 3 - terminal count interrupt prior to masking. 1'b1 indicates an active interrupt request. </description>
            </field>
            <field>
              <name>DMACRAWINTTC_ch2</name>
              <bitRange>[2:2]</bitRange>
              <description>Status of DMA channel 2 - terminal count interrupt prior to masking. 1'b1 indicates an active interrupt request. </description>
            </field>
            <field>
              <name>DMACRAWINTTC_ch1</name>
              <bitRange>[1:1]</bitRange>
              <description>Status of DMA channel 1 - terminal count interrupt prior to masking. 1'b1 indicates an active interrupt request. </description>
            </field>
            <field>
              <name>DMACRAWINTTC_ch0</name>
              <bitRange>[0:0]</bitRange>
              <description>Status of DMA channel 0 - terminal count interrupt prior to masking. 1'b1 indicates an active interrupt request. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'dmac_rawinterr_status': 0xFF800818-->
          <name>dmac_rawinterr_status</name>
          <description>raw interrupt error status register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000018</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>DMACRAWINTERR_ch3</name>
              <bitRange>[3:3]</bitRange>
              <description>Status of DMA channel 3 - error interrupt prior to masking. 1'b1 indicates an active interrupt request. </description>
            </field>
            <field>
              <name>DMACRAWINTERR_ch2</name>
              <bitRange>[2:2]</bitRange>
              <description>Status of DMA channel 2 - error interrupt prior to masking. 1'b1 indicates an active interrupt request. </description>
            </field>
            <field>
              <name>DMACRAWINTERR_ch1</name>
              <bitRange>[1:1]</bitRange>
              <description>Status of DMA channel 1 - error interrupt prior to masking. 1'b1 indicates an active interrupt request. </description>
            </field>
            <field>
              <name>DMACRAWINTERR_ch0</name>
              <bitRange>[0:0]</bitRange>
              <description>Status of DMA channel 0 - error interrupt prior to masking. 1'b1 indicates an active interrupt request. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'dmac_enabled_channel': 0xFF80081C-->
          <name>dmac_enabled_channel</name>
          <description>channel enable register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000001C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>DMACENABLEDCHNS_ch3</name>
              <bitRange>[3:3]</bitRange>
              <description>Status DMA channel 3 enable </description>
            </field>
            <field>
              <name>DMACENABLEDCHNS_ch2</name>
              <bitRange>[2:2]</bitRange>
              <description>Status DMA channel 2 enable </description>
            </field>
            <field>
              <name>DMACENABLEDCHNS_ch1</name>
              <bitRange>[1:1]</bitRange>
              <description>Status DMA channel 1 enable </description>
            </field>
            <field>
              <name>DMACENABLEDCHNS_ch0</name>
              <bitRange>[0:0]</bitRange>
              <description>Status DMA channel 0 enable </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'dmac_softb_req': 0xFF800820-->
          <name>dmac_softb_req</name>
          <description>software burst request register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>DMACSoftBReq</name>
              <bitRange>[15:0]</bitRange>
              <description>Software burst request. A DMA request can be generated for each source by writing a 1'b1 to the corresponding register bit. Reading the register indicates which sources are requesting DMA burst transfers. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'dmac_softs_req': 0xFF800824-->
          <name>dmac_softs_req</name>
          <description>software single request register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000024</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>DMACSoftSReq</name>
              <bitRange>[15:0]</bitRange>
              <description>Software single request. A DMA request can be generated for each source by writing a 1'b1 to the corresponding register bit. Reading the register indicates which sources are requesting DMA single transfers. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'dmac_softlb_req': 0xFF800828-->
          <name>dmac_softlb_req</name>
          <description>software last burst request register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000028</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>DMACSoftLBReq</name>
              <bitRange>[15:0]</bitRange>
              <description>Software last burst request. A DMA request can be generated for each source by writing a 1'b1 to the corresponding register bit. Reading the register indicates which sources are requesting DMA last burst transfers. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'dmac_softls_req': 0xFF80082C-->
          <name>dmac_softls_req</name>
          <description>software last single request register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000002C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>DMACSoftLSReq</name>
              <bitRange>[15:0]</bitRange>
              <description>Software last single request. A DMA request can be generated for each source by writing a 1'b1 to the corresponding register bit. Reading the register indicates which sources are requesting DMA last single transfers. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'dmac_config': 0xFF800830-->
          <name>dmac_config</name>
          <description>configuration register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000030</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>DMACENABLE</name>
              <bitRange>[0:0]</bitRange>
              <description>DMAC enable: 0 = disabled 1 = enabled. This bit is reset to 0. Disabling the DMAC reduces power consumption. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'dmac_sync': 0xFF800834-->
          <name>dmac_sync</name>
          <description>sync register DMA synchronization logic for DMA request signals enabled or disabled A 1'b0 bit indicates that the synchronization logic for the DMACBREQ[15:0], DMACSREQ[15:0], DMACLBREQ[15:0], and DMACLSREQ[15:0] request signals is enabled. A HIGH bit indicates that the synchronization logic is disabled. Note: Within the netX system all peripherals and the DMAC are running in the same clock-domain. Therefore, it is recommended to disable the synchronisation for all channels (i.e. write 0xffff). This results in a performance gain. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000034</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>DIS_SYNC</name>
              <bitRange>[15:0]</bitRange>
              <description>Disable sync register peripheral requests. </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>dmac_mux_app</name>
      <description>dmac_mux_app</description>
      <baseAddress>0xFF801000</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>64</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <!--Absolute address of 'dmac_mux_peripheral_input_sel0': 0xFF801000-->
          <name>dmac_mux_peripheral_input_sel0</name>
          <description>Peripheral input select for DMAC input channel 0 This register configures which peripheral should be connected to DMAC's input channel 0. Note: This should not be changed while any of the DMA channels are performing DMA transfers. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000002</resetValue>
          <resetMask>0x0000003F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>index</name>
              <bitRange>[5:0]</bitRange>
              <description>Index of the peripheral to be connected to DMAC's input channel 0. Default connected peripheral: uart_app_rx {        | Number   Peripheral 0       uart_rx 1       uart_tx 2       uart_app_rx (default on DMAC input channel 0) 3       uart_app_tx (default on DMAC input channel 1) 4       i2c_app_master (default on DMAC input channel 2) 5       i2c_app_slave (default on DMAC input channel 3) 6       spi0_app_rx (default on DMAC input channel 4) 7       spi0_app_tx (default on DMAC input channel 5) 8       spi1_app_rx 9       spi1_app_tx 10       spi2_app_rx 11       spi2_app_tx 12       sqi0_app_rx 13       sqi0_app_tx 14       sqi1_app_rx 15       sqi1_app_tx 16       uart_xpic_app_rx 17       uart_xpic_app_tx 18       i2c_xpic_app_master 19       i2c_xpic_app_slave 20       spi_xpic_app_rx 21       spi_xpic_app_tx 22       sqi_rx 23       sqi_tx 24       eth_rx 25       eth_tx 26       hash 27       aes_in 28       aes_out 29       no connection 30 - 31  reserved } </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'dmac_mux_peripheral_input_sel1': 0xFF801004-->
          <name>dmac_mux_peripheral_input_sel1</name>
          <description>Peripheral input select for DMAC input channel 1 This register configures which peripheral should be connected to DMAC's input channel 1. Note: This should not be changed while any of the DMA channels are performing DMA transfers. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000003</resetValue>
          <resetMask>0x0000003F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>index</name>
              <bitRange>[5:0]</bitRange>
              <description>Index of the peripheral to be connected to DMAC's input channel 1. Default connected peripheral: uart_app_tx For a list of available peripheral indices, see dmac_mux_peripheral_input_sel0. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'dmac_mux_peripheral_input_sel2': 0xFF801008-->
          <name>dmac_mux_peripheral_input_sel2</name>
          <description>Peripheral input select for DMAC input channel 2 This register configures which peripheral should be connected to DMAC's input channel 2. Note: This should not be changed while any of the DMA channels are performing DMA transfers. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000004</resetValue>
          <resetMask>0x0000003F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>index</name>
              <bitRange>[5:0]</bitRange>
              <description>Index of the peripheral to be connected to DMAC's input channel 2. Default connected peripheral: i2c_app_master For a list of available peripheral indices, see dmac_mux_peripheral_input_sel0. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'dmac_mux_peripheral_input_sel3': 0xFF80100C-->
          <name>dmac_mux_peripheral_input_sel3</name>
          <description>Peripheral input select for DMAC input channel 3 This register configures which peripheral should be connected to DMAC's input channel 3. Note: This should not be changed while any of the DMA channels are performing DMA transfers. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000005</resetValue>
          <resetMask>0x0000003F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>index</name>
              <bitRange>[5:0]</bitRange>
              <description>Index of the peripheral to be connected to DMAC's input channel 3. Default connected peripheral: i2c_app_slave For a list of available peripheral indices, see dmac_mux_peripheral_input_sel0. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'dmac_mux_peripheral_input_sel4': 0xFF801010-->
          <name>dmac_mux_peripheral_input_sel4</name>
          <description>Peripheral input select for DMAC input channel 4 This register configures which peripheral should be connected to DMAC's input channel 4. Note: This should not be changed while any of the DMA channels are performing DMA transfers. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000006</resetValue>
          <resetMask>0x0000003F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>index</name>
              <bitRange>[5:0]</bitRange>
              <description>Index of the peripheral to be connected to DMAC's input channel 4. Default connected peripheral: spi0_app_rx For a list of available peripheral indices, see dmac_mux_peripheral_input_sel0. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'dmac_mux_peripheral_input_sel5': 0xFF801014-->
          <name>dmac_mux_peripheral_input_sel5</name>
          <description>Peripheral input select for DMAC input channel 5 This register configures which peripheral should be connected to DMAC's input channel 5. Note: This should not be changed while any of the DMA channels are performing DMA transfers. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000007</resetValue>
          <resetMask>0x0000003F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>index</name>
              <bitRange>[5:0]</bitRange>
              <description>Index of the peripheral to be connected to DMAC's input channel 5. Default connected peripheral: spi0_app_tx For a list of available peripheral indices, see dmac_mux_peripheral_input_sel0. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'dmac_mux_peripheral_input_sel6': 0xFF801018-->
          <name>dmac_mux_peripheral_input_sel6</name>
          <description>Peripheral input select for DMAC input channel 6 This register configures which peripheral should be connected to DMAC's input channel 6. Note: This should not be changed while any of the DMA channels are performing DMA transfers. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000018</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000003F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>index</name>
              <bitRange>[5:0]</bitRange>
              <description>Index of the peripheral to be connected to DMAC's input channel 6. Default connected peripheral: uart_rx For a list of available peripheral indices, see dmac_mux_peripheral_input_sel0. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'dmac_mux_peripheral_input_sel7': 0xFF80101C-->
          <name>dmac_mux_peripheral_input_sel7</name>
          <description>Peripheral input select for DMAC input channel 7 This register configures which peripheral should be connected to DMAC's input channel 7. Note: This should not be changed while any of the DMA channels are performing DMA transfers. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000001C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000003F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>index</name>
              <bitRange>[5:0]</bitRange>
              <description>Index of the peripheral to be connected to DMAC's input channel 7. Default connected peripheral: uart_rx For a list of available peripheral indices, see dmac_mux_peripheral_input_sel0. </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>uart_app</name>
      <description>uart_app</description>
      <baseAddress>0xFF801040</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>64</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>uart_app</name>
        <value>20</value>
      </interrupt>
      <registers>
        <register>
          <!--Absolute address of 'uartdr': 0xFF801040-->
          <name>uartdr</name>
          <description>data read or written from the interface </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000007FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:11]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>BE</name>
              <bitRange>[10:10]</bitRange>
              <description>Break Error, read only, mirrored from uartrsr, to handle in DMA-read-out data </description>
            </field>
            <field>
              <name>PE</name>
              <bitRange>[9:9]</bitRange>
              <description>Parity Error, read only, mirrored from uartrsr, to handle in DMA-read-out data </description>
            </field>
            <field>
              <name>FE</name>
              <bitRange>[8:8]</bitRange>
              <description>Framing Error, read only, mirrored from uartrsr, to handle in DMA-read-out data </description>
            </field>
            <field>
              <name>DATA</name>
              <bitRange>[7:0]</bitRange>
              <description>data read or written from the interface </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'uartrsr': 0xFF801044-->
          <name>uartrsr</name>
          <description>receive status register (read) / Error Clear Register (write) </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>OE</name>
              <bitRange>[3:3]</bitRange>
              <description>Overrun Error </description>
            </field>
            <field>
              <name>BE</name>
              <bitRange>[2:2]</bitRange>
              <description>Break Error </description>
            </field>
            <field>
              <name>PE</name>
              <bitRange>[1:1]</bitRange>
              <description>Parity Error </description>
            </field>
            <field>
              <name>FE</name>
              <bitRange>[0:0]</bitRange>
              <description>Framing Error </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'uartlcr_h': 0xFF801048-->
          <name>uartlcr_h</name>
          <description>Line control Register, high byte </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000007F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>WLEN</name>
              <bitRange>[6:5]</bitRange>
              <description>Word Length '00' 5 bits '01' 6 bits '10' 7 bits '11' 8 bits </description>
            </field>
            <field>
              <name>FEN</name>
              <bitRange>[4:4]</bitRange>
              <description>FIFO Enable </description>
            </field>
            <field>
              <name>STP2</name>
              <bitRange>[3:3]</bitRange>
              <description>2 Stop Bits Select </description>
            </field>
            <field>
              <name>EPS</name>
              <bitRange>[2:2]</bitRange>
              <description>Even Parity Select </description>
            </field>
            <field>
              <name>PEN</name>
              <bitRange>[1:1]</bitRange>
              <description>Parity Enalble </description>
            </field>
            <field>
              <name>BRK</name>
              <bitRange>[0:0]</bitRange>
              <description>Send Break </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'uartlcr_m': 0xFF80104C-->
          <name>uartlcr_m</name>
          <description>Line control Register, middle byte </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>BAUDDIVMS</name>
              <bitRange>[7:0]</bitRange>
              <description>bauddiv : Baud Divisor Most Significant Byte use higher byte of bauddiv = (system clk / (16 * baud rate)) - 1 if not alternative settings by register uartcr_2 are done </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'uartlcr_l': 0xFF801050-->
          <name>uartlcr_l</name>
          <description>Line control Register, low byte </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>BAUDDIVLS</name>
              <bitRange>[7:0]</bitRange>
              <description>Baud Divisor Least Significant Byte use lower byte of bauddiv = (system clk / (16 * baud rate)) - 1 if not alternative settings by register uartcr_2 are done </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'uartcr': 0xFF801054-->
          <name>uartcr</name>
          <description>uart control Register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000001FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:9]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>TX_RX_LOOP</name>
              <bitRange>[8:8]</bitRange>
              <description>internal loop (TX -&gt; RX) (test purpose only) </description>
            </field>
            <field>
              <name>LBE</name>
              <bitRange>[7:7]</bitRange>
              <description>Loop Back Enable for IrDA mode </description>
            </field>
            <field>
              <name>RTIE</name>
              <bitRange>[6:6]</bitRange>
              <description>Receive Timeout Interrupt Enable </description>
            </field>
            <field>
              <name>TIE</name>
              <bitRange>[5:5]</bitRange>
              <description>Transmit Interrupt Enable </description>
            </field>
            <field>
              <name>RIE</name>
              <bitRange>[4:4]</bitRange>
              <description>Receive Interrupt Enable </description>
            </field>
            <field>
              <name>MSIE</name>
              <bitRange>[3:3]</bitRange>
              <description>Modem Status Interrupt Enable </description>
            </field>
            <field>
              <name>SIRLP</name>
              <bitRange>[2:2]</bitRange>
              <description>IrDA SIR Low Power Mode </description>
            </field>
            <field>
              <name>SIREN</name>
              <bitRange>[1:1]</bitRange>
              <description>SIR Enable </description>
            </field>
            <field>
              <name>uartEN</name>
              <bitRange>[0:0]</bitRange>
              <description>uart Enable </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'uartfr': 0xFF801058-->
          <name>uartfr</name>
          <description>uart Flag Register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000018</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>TXFE</name>
              <bitRange>[7:7]</bitRange>
              <description>Transmit FIFO Empty </description>
            </field>
            <field>
              <name>RXFF</name>
              <bitRange>[6:6]</bitRange>
              <description>Receive FIFO Full </description>
            </field>
            <field>
              <name>TXFF</name>
              <bitRange>[5:5]</bitRange>
              <description>Transmit FIFO Full </description>
            </field>
            <field>
              <name>RXFE</name>
              <bitRange>[4:4]</bitRange>
              <description>Receive FIFO Empty </description>
            </field>
            <field>
              <name>BUSY</name>
              <bitRange>[3:3]</bitRange>
              <description>uart BUSY </description>
            </field>
            <field>
              <name>DCD</name>
              <bitRange>[2:2]</bitRange>
              <description>Data Carrier Detect </description>
            </field>
            <field>
              <name>DSR</name>
              <bitRange>[1:1]</bitRange>
              <description>Data Set Ready </description>
            </field>
            <field>
              <name>CTS</name>
              <bitRange>[0:0]</bitRange>
              <description>Clear To Send </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'uartiir': 0xFF80105C-->
          <name>uartiir</name>
          <description>Interrupt Identification (read) / interrupt clear (write) </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000001C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>RTIS</name>
              <bitRange>[3:3]</bitRange>
              <description>Receive Timeout Interrupt Status </description>
            </field>
            <field>
              <name>TIS</name>
              <bitRange>[2:2]</bitRange>
              <description>Transmit Interrupt Status </description>
            </field>
            <field>
              <name>RIS</name>
              <bitRange>[1:1]</bitRange>
              <description>Receive Interrupt Status </description>
            </field>
            <field>
              <name>MIS</name>
              <bitRange>[0:0]</bitRange>
              <description>Modem Interrupt Status </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'uartilpr': 0xFF801060-->
          <name>uartilpr</name>
          <description>IrDA Low Power Counter Register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ILPDVSR</name>
              <bitRange>[7:0]</bitRange>
              <description>IrDA Low Power Divisor </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'uartrts': 0xFF801064-->
          <name>uartrts</name>
          <description>RTS Control Register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000024</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>STICK</name>
              <bitRange>[7:7]</bitRange>
              <description>stick parity </description>
            </field>
            <field>
              <name>CTS_pol</name>
              <bitRange>[6:6]</bitRange>
              <description>nUARTCTS polarity: 1=active high </description>
            </field>
            <field>
              <name>CTS_ctr</name>
              <bitRange>[5:5]</bitRange>
              <description>nUARTCTS control </description>
            </field>
            <field>
              <name>RTS_pol</name>
              <bitRange>[4:4]</bitRange>
              <description>RTS polarity: 1=active high </description>
            </field>
            <field>
              <name>MOD2</name>
              <bitRange>[3:3]</bitRange>
              <description>mode1/mode2 </description>
            </field>
            <field>
              <name>COUNT</name>
              <bitRange>[2:2]</bitRange>
              <description>count base: 1=system clocks, 0=time in bauds </description>
            </field>
            <field>
              <name>RTS</name>
              <bitRange>[1:1]</bitRange>
              <description>if AUTO=0: controlled by this bit </description>
            </field>
            <field>
              <name>AUTO</name>
              <bitRange>[0:0]</bitRange>
              <description>automatic or controlled by the next bit (RTS) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'uartforerun': 0xFF801068-->
          <name>uartforerun</name>
          <description>RTS forerun cycles </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000028</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>FORERUN</name>
              <bitRange>[7:0]</bitRange>
              <description>number of forerun cycles in system clocks or bauds </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'uarttrail': 0xFF80106C-->
          <name>uarttrail</name>
          <description>RTS trail cycles </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000002C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>TRAIL</name>
              <bitRange>[7:0]</bitRange>
              <description>number of trail cycles in system clocks or bauds </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'uartdrvout': 0xFF801070-->
          <name>uartdrvout</name>
          <description>Drive Output </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000030</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:2]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>DRVRTS</name>
              <bitRange>[1:1]</bitRange>
              <description>enable driver for RTS </description>
            </field>
            <field>
              <name>DRVTX</name>
              <bitRange>[0:0]</bitRange>
              <description>enable driver for TX </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'uartcr_2': 0xFF801074-->
          <name>uartcr_2</name>
          <description>Control Register 2 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000034</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:2]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>oversampling_8x</name>
              <bitRange>[1:1]</bitRange>
              <description>Oversampling mode: 0: Use default 16x oversampling. 1: Use reduced accuracy 8x oversampling. This can be used to increase the max. baudrate. When selected, the configured baudrate will be doubled. Note that the bit reception is more error-prone in noisy environments. </description>
            </field>
            <field>
              <name>Baud_Rate_Mode</name>
              <bitRange>[0:0]</bitRange>
              <description>If this bit is set the baud rate is generated more exactly by the following formula: value = ( (Baud Rate * 16) / System Frequency ) * 2^16  . You have to write this 16-bit value in register uartlcr_l and uartlcr_m. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'uartrxiflsel': 0xFF801078-->
          <name>uartrxiflsel</name>
          <description>RX FIFO trigger level and RX-DMA enable </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000038</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000008</resetValue>
          <resetMask>0x0000003F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>RXDMA</name>
              <bitRange>[5:5]</bitRange>
              <description>Enable DMA-requests for RX-fifo-data. A request will be generated if RX-FIFO is not empty and uartcr.uartEN (module enable) is set. Burst request to DMA-Ctrl will be done if the RX-FIFO contains at least 4 words (set DMA-burst-size to 4) If this bit is reset or the module is disabled, DMA-request will also be reset. single transfer request: RX-FIFO contains 1 byte or more, burst request: 4 bytes or more note: set adr_dmac_chctrl.SBSize = 1 (i.e. burst size: 4) in the DMA module </description>
            </field>
            <field>
              <name>RXIFLSEL</name>
              <bitRange>[4:0]</bitRange>
              <description>Choose a number between 1 and 16. It defines the IRQ trigger level of the receive fifo. The IRQ (UARTRXINTR) will be set if the number of received bytes in the receive fifo are greater than or equal RXIFLSEL. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'uarttxiflsel': 0xFF80107C-->
          <name>uarttxiflsel</name>
          <description>TX FIFO trigger level and TX-DMA enable </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000003C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000008</resetValue>
          <resetMask>0x0000003F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>TXDMA</name>
              <bitRange>[5:5]</bitRange>
              <description>Enable DMA-requests for TX-fifo-data. A request will be generated if TX-FIFO is not full and uartcr.uartEN (module enable) is set. Burst request to DMA-Ctrl will be done if at least 4 words are writable to the TX-FIFO (set DMA-burst-size to 4) If this bit is reset or the module is disabled, DMA-request will also be reset. note: set adr_dmac_chctrl.DBSize = 1 (i.e. burst size: 4) in the DMA module </description>
            </field>
            <field>
              <name>TXIFLSEL</name>
              <bitRange>[4:0]</bitRange>
              <description>Choose a number between 1 and 16. It defines the IRQ trigger level of the transmit fifo. The IRQ (UARTTXINTR) will be set if the number of transmitted bytes in the transmit fifo are less than TXIFLSEL. </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>i2c_app</name>
      <description>i2c_app</description>
      <baseAddress>0xFF801080</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>64</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>i2c_app</name>
        <value>9</value>
      </interrupt>
      <registers>
        <register>
          <!--Absolute address of 'i2c_mcr': 0xFF801080-->
          <name>i2c_mcr</name>
          <description>I2C master control register: </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000707FF</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:19]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>en_timeout</name>
              <bitRange>[18:18]</bitRange>
              <description>Enable I2C command timeout detection. Enabling the timeout detection is recommended to prevent the module from stalling if another device holds the I2C signals permanently low. For details, see the description of bit i2s_sr.timeout. </description>
            </field>
            <field>
              <name>rst_i2c</name>
              <bitRange>[17:17]</bitRange>
              <description>Reset the I2C bus-state-detection logic. To avoid conflicts with other masters, some I2C bus states, which are important when there are multiple masters on the I2C bus, are always monitored, even if the I2C module is disabled. For details, see bits i2c_sr.started and i2c.bus_master. However, it may happen that bus states are detected which lock up the I2C module. E.g. hazards during power-up or IO configuration or sequences, which are not I2C compliant, can cause a lock-up. This bit can be used to escape from such a situation. Write a '1' here to reset the I2C bus-state-detection logic of register i2c_sr. Note: This bit is new since netX51/52. It is always '0' when read. </description>
            </field>
            <field>
              <name>pio_mode</name>
              <bitRange>[16:16]</bitRange>
              <description>If this bit is set, SCL and SDA can be controlled directly by register i2c_pio (e.g. to access devices being incompatible with I2C). In PIO mode, the I2C controller state machine is disabled: FIFOs are not used, no IRQs will be set, and no DMA controlling is possible. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[15:11]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sadr</name>
              <bitRange>[10:4]</bitRange>
              <description>7-bit slave address sent after (r)START: For 10-bit addressing, the first byte (10-bit start '11110', address bits[9:8] must be programmed here. The second start byte (lower slave address bits) must be on top of the master FIFO (i2c_mdr). This register must be rewritten (even if the value does not change) to address another slave in the 10-bit mode (run 2-byte start sequence). The register must not be rewritten before a repeated START on the same 10-bit addressed slave (run 1-byte start sequence e.g. write to read change). </description>
            </field>
            <field>
              <name>mode</name>
              <bitRange>[3:1]</bitRange>
              <description>I2C-speed-mode: If this device is used as a slave only, the mode should be set to the data rate generated by the fastest master on the I2C-bus for appropriate input filtering and spike suppression. 000: Fast/Standard mode, 50 kbit/s 001: Fast/Standard mode, 100 kbit/s 010: Fast/Standard mode, 200 kbit/s 011: Fast/Standard mode, 400 kbit/s 100: High-speed mode, 800 kbit/s 101: High-speed mode, 1.2 Mbit/s 110: High-speed mode, 1.7 Mbit/s 111: High-speed mode, 3.4 Mbit/s) </description>
            </field>
            <field>
              <name>en_i2c</name>
              <bitRange>[0:0]</bitRange>
              <description>Global I2C controller enable 1: Enable I2C controller 0: Disable I2C controller Disabling the I2C module during a transfer will immediately disconnect the I2C module from the bus without generating a STOP. The internal I2C state machine will be set back to initial/idle state. The I2C bus-state-detection for the bits i2c_sr.bus_master and i2c_sr.started are performed even if the module is disabled. For details, see these bits. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'i2c_scr': 0xFF801084-->
          <name>i2c_scr</name>
          <description>I2C slave control register: </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x001707FF</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:21]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>autoreset_ac_start</name>
              <bitRange>[20:20]</bitRange>
              <description>Auto reset ac_start (ac_start must be set again after any (r)START): 0: ac_start will not be reset automatically (netX 50-compatible, but not recommended) 1: Reset ac_start after this slave acknowledged a start sequence (recommended) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[19:19]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ac_gcall</name>
              <bitRange>[18:18]</bitRange>
              <description>General call acknowledge: 0: Do not generate an acknowledge after a general call 1: Generate an acknowledge after a general call </description>
            </field>
            <field>
              <name>ac_start</name>
              <bitRange>[17:17]</bitRange>
              <description>Enable start sequence acknowledge: If the received address matches the sid-bits, the start-byte (2 bytes if sid10 is set) will be acknowledged. If the master requests a read transfer, a slave FIFO read access will be carried out immediately after the acknowledge, i.e. valid data must be present in the slave FIFO before enabling the acknowledge. If autoreset_ac_start is enabled, the controller will automatically reset this bit. If it is not enabled, the software should reset this bit after the start sequence has been acknowledged to avoid acknowledge and FIFO errors after the next (r)START. 0: Do not generate an acknowledge after the start sequence 1: Generate an acknowledge after the start sequence This bit is writable, but can also be changed by hardware. </description>
            </field>
            <field>
              <name>ac_srx</name>
              <bitRange>[16:16]</bitRange>
              <description>Enable slave-receive-data acknowledge: 0: Do not acknowledge receive bytes 1: Acknowledge receive bytes If the slave FIFO is full, receive data will not be acknowledged. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[15:11]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sid10</name>
              <bitRange>[10:10]</bitRange>
              <description>10-bit slave device ID/address: 0: Wait for 7-bit slave address after (r)START 1: Wait for 10-bit slave address after (r)START </description>
            </field>
            <field>
              <name>sid</name>
              <bitRange>[9:0]</bitRange>
              <description>Slave device ID/address: External masters can address this device (this I2C module in slave mode) by the ID/address programmed here. If sid10 is not set, bits 9 to 7 will be ignored. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'i2c_cmd': 0xFF801088-->
          <name>i2c_cmd</name>
          <description>I2C master command register: </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000000E</resetValue>
          <resetMask>0x0FF3FF0F</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:28]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>acpollmax</name>
              <bitRange>[27:20]</bitRange>
              <description>Number of tries (acpollmax+1, i.e. 1 to 256) for start sequence acknowledge polling: For 7-bit addressing, acknowledge polling START and the first byte containing the slave address (i2c_mcr.sadr) will be repeated up to acpollmax+1 times until a slave generates an acknowledge. If no acknowledge is received within acpollmax+1 tries, IRQ cmd_err will be generated. For 10-bit-addressing, the 2-byte start sequence is performed. The second address byte (lower address bits) must be on top of the master FIFO (i2c_mdr). For subsequent transfers, the value programmed in tsize has to ignore this byte. The programmed value of acpollmax will count down during acknowledge polling after each start sequence. This bit is writable, but can also be changed by hardware. </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[19:18]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>tsize</name>
              <bitRange>[17:8]</bitRange>
              <description>Transfer tsize+1 bytes (1...1024): If no acknowledge is generated by the slave (receiver), write transfers will be terminated and IRQ cmd_err will be generated. For 10-bit-addressing, the second start-byte (lower address bits) must be on top of the master FIFO. For subsequent transfers, the value programmed here has to ignore this byte. This value will count down during transfers after each byte. This bit is writable, but can also be changed by hardware. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[7:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>cmd</name>
              <bitRange>[3:1]</bitRange>
              <description>I2C sequence command: All commands will generate IRQ cmd_ok or IRQ cmd_err. A successful command termination will always generate IRQ cmd_ok. In case of an unsuccessful command termination, IRQ cmd_err will be set. {    |         | 000  START     Generate (r)START-condition 001  S_AC      Acknowledge-polling: generate up to acpollmax+1 START-sequences (until acknowledged by slave) 010  S_AC_T    Run S_AC, then transfer tsize+1 bytes from/to master FIFO. Not to be continued 011  S_AC_TC   Run S_AC, then transfer tsize+1 bytes from/to master FIFO. To be continued 100  CT        Continued transfer not to be continued 101  CTC       Continued transfer to be continued 110  STOP      Generate STOP-condition 111  IDLE      Nothing to do, last command finished, break current command } Sequences including read transfers that are not to be continued (S_AC_T, CT with 'nwr' bit set) will not generate an acknowledge after the last received byte (read transfer ends). Read transfers that are to be continued (S_AC_TC, CTC) will generate an acknowledge after the last received byte and must be followed by CT or CTC. Before continued transfers (CT, CTC), a command including START (START, S_AC, S_AC_T, S_AC_TC) must be executed to generate a valid I2C sequence. STOP must always be executed by software to free the bus after transfer end. STOP is not included in any command sequence and never executed automatically by this module. Some commands are handled as sequences (i.e. after setting S_AC_T, first S_AC then CT will be seen when read). You need not poll for IDLE here before setting up a new command, but you have to wait for cmd_ok or cmd_err status flags of register i2c_irqsr to be set. This bit is writable, but can also be changed by hardware. </description>
            </field>
            <field>
              <name>nwr</name>
              <bitRange>[0:0]</bitRange>
              <description>Transfer direction (not-write/read): 0: cmd will be executed as write 1: cmd will be executed as read Master FIFO-requests (IRQ and DMA) are generated depending on this direction flag. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'i2c_mdr': 0xFF80108C-->
          <name>i2c_mdr</name>
          <description>I2C master data register (master FIFO): There is only one FIFO for both receive and transmit master data with a depth of 16 bytes. For master write access, data sent by the master is delivered from the FIFO. For master read access, data received by the master is stored in the FIFO. In case of imminent data transfer failure (read transfer and FIFO is full or write transfer and FIFO is empty), the transfer will be interrupted. To continue the transfer, the FIFO must be handled first (filled for write transfer, read out for read transfer). Note: The FIFO behavior has been changed: For netX 51/52/56 and older versions, the current command was aborted and the cmd_err was raised. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>mdata</name>
              <bitRange>[7:0]</bitRange>
              <description>I2C master transmit or receive data: Write data will be removed from the FIFO after the receiving slave has generated the corresponding acknowledge. Write data that has not been acknowledged will not be removed from the FIFO. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'i2c_sdr': 0xFF801090-->
          <name>i2c_sdr</name>
          <description>I2C slave data register (slave FIFO): There is only one FIFO for both receive and transmit slave data with a depth of 16 bytes. For master read access, data sent by the slave is delivered from the FIFO. For master write access, data received by the slave is stored in the FIFO. A transfer is initiated after the detection of I2C-start-sequence to the device address (i2c_scr.sid, sreq IRQ) which is acknowledged by this device (i2c_scr.ac_start). For read transfers, sent data is read from the FIFO immediately after the detection of the acknowledge on the I2C-bus. SDA will be driven with the next data MSB immediately after the acknowledge SCL high phase. In case of a master read transfer and slave FIFO underrun, corrupted data will be sent to the master and the IRQ fifo_err will be set. In case of a master write transfer and slave FIFO is full, no acknowledge will be generated for the last received byte. No FIFO overflow will occur, but the last transferred byte (not acknowledged) will be lost and has to be sent again by the master. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sdata</name>
              <bitRange>[7:0]</bitRange>
              <description>I2C slave transmit or receive data: The software must handle i2c_scr.ac_start correctly to avoid FIFO errors after (r)START. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'i2c_mfifo_cr': 0xFF801094-->
          <name>i2c_mfifo_cr</name>
          <description>I2C master FIFO control register: </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000010F</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:9]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>mfifo_clr</name>
              <bitRange>[8:8]</bitRange>
              <description>Clear master data FIFO, write only bit. This bit is writable, but can also be changed by hardware. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[7:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>mfifo_wm</name>
              <bitRange>[3:0]</bitRange>
              <description>Master FIFO watermark for the generation of IRQ mfifo_req: If the master is the transmitter (enabled and i2c_cmd.nwr is 0), IRQ mfifo_req is generated if mfifo_level&lt;mfifo_wm. If the master is the receiver (enabled and i2c_cmd.nwr is 1), IRQ mfifo_req is generated if mfifo_level&gt;mfifo_wm. Note: Set the watermark to 0 at transfer end to avoid further IRQ generation. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'i2c_sfifo_cr': 0xFF801098-->
          <name>i2c_sfifo_cr</name>
          <description>I2C slave FIFO control register: </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000018</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000010F</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:9]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sfifo_clr</name>
              <bitRange>[8:8]</bitRange>
              <description>Clear slave data FIFO, write only bit. This bit is writable, but can also be changed by hardware. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[7:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sfifo_wm</name>
              <bitRange>[3:0]</bitRange>
              <description>Slave FIFO watermark for the generation of IRQ sfifo_req: If the slave is the transmitter (start sequence with set read bit was acknowledged by this slave), IRQ sfifo_req is generated if sfifo_level&lt;sfifo_wm. If the slave is not the transmitter (is receiver or not selected), IRQ sfifo_req is generated if sfifo_level&gt;sfifo_wm. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'i2c_sr': 0xFF80109C-->
          <name>i2c_sr</name>
          <description>I2C status register: </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000001C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xC0110040</resetValue>
          <resetMask>0xDFFF7FDF</resetMask>
          <fields>
            <field>
              <name>sda_state</name>
              <bitRange>[31:31]</bitRange>
              <description>SDA signal state sampled and filtered from bus (e.g. to detect bus blockings) This is a read-only status bit. </description>
            </field>
            <field>
              <name>scl_state</name>
              <bitRange>[30:30]</bitRange>
              <description>SCL signal state sampled and filtered from bus (e.g. to detect bus blockings) This is a read-only status bit. </description>
            </field>
            <field>
              <name>bf_align2</name>
              <bitRange>[29:29]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>timeout</name>
              <bitRange>[28:28]</bitRange>
              <description>I2C command timeout detection (for I2C master). I2C slaves can stretch low SCL phases by holding the SCL line low. The master must detect this and wait until the SCL line is released before the current transfer can continue. In error cases, the I2C bus can be blocked permanently by a low signal state of SCL. The reason for the blocking can be e.g. a crashed I2C slave or a false I/O configuration. To escape from such a situation, a timeout watchdog is implemented: A timeout will be detected if the SCL line is held low for more than 256 SCL periods. In this case, the recent command will be terminated and IRQ cmd_err will be set. The timeout detection must be enabled by bit i2c_mcr.en_timeout. It is disabled by default for backward compatibility. However, enabling is strongly recommended. If timeout is detected, the status bit must be cleared before a new command can be applied. This status bit can be cleared by writing a '1' to it or when bit i2c_mcr.rst_i2c performs a reset of the bus-state-detection logic. </description>
            </field>
            <field>
              <name>sid10_aced</name>
              <bitRange>[27:27]</bitRange>
              <description>10-bit slave address acknowledge state. {  | 0: There was no 10-bit slave address or it was not acknowledged. 1: A 10-bit slave address was broadcasted and a slave acknowledged this broadcast. I.e. for the master side: A 10-bit slave was addressed and the slave acknowledged. I.e. for the slave side: A master broadcasted a start with the address programmed in register i2c_scr.sid and the i2c module acknowledged this broadcast as bit i2c_scr.ac_start is set.} This read-only status bit is cleared automatically when the module detects a STOP or when register i2c_mcr is written (e.g. to perform a module reset by bit i2c_mcr.rst_i2c or to address another slave by changing the bits i2c_mcr.sadr). Remember that during rSTART, the master will generate only the first START-byte. </description>
            </field>
            <field>
              <name>gcall_aced</name>
              <bitRange>[26:26]</bitRange>
              <description>General call acknowledge state. 0: No general call start-byte, or general call start-byte was not acknowledged. 1: The slave side of the i2c module received and acknowledged a general call. Bit i2c_scr.ac_gcall controls the acknowledging of a general call. This read-only status bit will be cleared automatically if the last start-byte is not a general call or if it is a general call but bit i2c_scr.ac_gcall is not set. This bit is forced to '0' when the bit i2c_mcr.rst_i2c performs a reset of the bus-state-detection logic. Note: The bit has no function for the master side of the i2c module </description>
            </field>
            <field>
              <name>nwr_aced</name>
              <bitRange>[25:25]</bitRange>
              <description>Transfer direction (nwr-bit) of the last acknowledged start-byte (or 2-byte start sequence for 10-bit addressing). 0: The last acknowledged start-byte defined a write transfer. 1: The last acknowledged start-byte defined a read transfer. Slave FIFO requests generating IRQ and DMA requests depend on this direction flag. This read-only status bit is forced to '0' when bit i2c_mcr.rst_i2c performs a reset of the bus-state-detection logic. </description>
            </field>
            <field>
              <name>last_ac</name>
              <bitRange>[24:24]</bitRange>
              <description>Last acknowledge detected on bus. 0: SDA was high at the last acknowledge, i.e. no acknowledge. 1: SDA was low at the last acknowledge, i.e. acknowledge. This read-only status bit is forced to '0' when bit i2c_mcr.rst_i2c performs a reset of the bus-state-detection logic. </description>
            </field>
            <field>
              <name>slave_access</name>
              <bitRange>[23:23]</bitRange>
              <description>Slave access state. 0: No slave access to this device. 1: A master addressed this slave device. This read-only status bit is set if a start-byte (2 bytes for 10-bit address) containing the address programmed in register i2c_scr.sid has been received. This bit is always reset to 0 during START or STOP. This bit is forced to '0' when bit i2c_mcr.rst_i2c performs a reset of the bus-state-detection logic. Note: This bit does not depend on whether the start-byte has been acknowledged or not. </description>
            </field>
            <field>
              <name>started</name>
              <bitRange>[22:22]</bitRange>
              <description>START condition detection: 0: The bus is idle (STOP was detected, not started). 1: (r)START was detected on the bus. The bus is occupied. This detection will also take place while the module is disabled. This is important if there are multiple I2C masters on the bus: If another master occupies the bus while the I2C module is disabled, the I2C module must not start a transfer, before the other master has released the bus. Use bit i2c_mcr.rst_i2c to force this read-only status bit to '0', e.g. in order to escape from an accidentally detected START or a START that is not followed by a STOP. </description>
            </field>
            <field>
              <name>nwr</name>
              <bitRange>[21:21]</bitRange>
              <description>Transfer direction detected after last (r)START. 0: The last start-byte defined a write transfer. 1: The last start-byte defined a read transfer. This read-only status bit is always reset to 0 during (r)START. This bit is forced to '0' when bit i2c_mcr.rst_i2c performs a reset of the bus-state-detection logic. Note: This bit does not depend on whether the start-byte has been acknowledged or not. </description>
            </field>
            <field>
              <name>bus_master</name>
              <bitRange>[20:20]</bitRange>
              <description>Bus arbitration state. 0: Master lost I2C bus arbitration, bus is busy by another master. 1: Master gains I2C bus arbitration or bus is idle. This read-only status bit is set when the monitored bus state does not match the bus state expected by the I2C module. The bit is reset, when a STOP is detected. This detection will also take place while the module is disabled. This is important if there are multiple I2C masters on the bus: If another master occupies the bus while the I2C module is disabled, the I2C module must not start a transfer, before the other master has released the bus. Use bit i2c_mcr.rst_i2c to force this bit to '0', e.g. in order to escape from an arbitration loss not followed by a STOP. </description>
            </field>
            <field>
              <name>sfifo_err_undr</name>
              <bitRange>[19:19]</bitRange>
              <description>Slave FIFO underrun error occurred. Data is lost and the slave FIFO must be cleared by bit i2c_sfifo_cr.sfifo_clr. Clearing the slave FIFO will also clear this read-only status bit. </description>
            </field>
            <field>
              <name>sfifo_err_ovfl</name>
              <bitRange>[18:18]</bitRange>
              <description>Slave FIFO overflow error occurred. Data is lost and the slave FIFO must be cleared by bit i2c_sfifo_cr.sfifo_clr. Clearing the slave FIFO will also clear this read-only status bit. </description>
            </field>
            <field>
              <name>sfifo_full</name>
              <bitRange>[17:17]</bitRange>
              <description>Slave FIFO is full (1 if full) This is a read-only status bit. </description>
            </field>
            <field>
              <name>sfifo_empty</name>
              <bitRange>[16:16]</bitRange>
              <description>Slave FIFO is empty (1 if empty) This is a read-only status bit. </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[15:15]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sfifo_level</name>
              <bitRange>[14:10]</bitRange>
              <description>Slave FIFO level (0..16) This is a read-only status bit field. </description>
            </field>
            <field>
              <name>mfifo_err_undr</name>
              <bitRange>[9:9]</bitRange>
              <description>Master FIFO underrun error occurred. Data is lost and the master FIFO must be cleared by bit i2c_mfifo_cr.mfifo_clr. Clearing the master FIFO will also clear this read-only status bit. </description>
            </field>
            <field>
              <name>mfifo_err_ovfl</name>
              <bitRange>[8:8]</bitRange>
              <description>Master FIFO overflow error occurred. Data is lost and the master FIFO must be cleared by bit i2c_mfifo_cr.mfifo_clr. Clearing the master FIFO will also clear this read-only status bit. </description>
            </field>
            <field>
              <name>mfifo_full</name>
              <bitRange>[7:7]</bitRange>
              <description>Master FIFO is full (1 if full) This is a read-only status bit. </description>
            </field>
            <field>
              <name>mfifo_empty</name>
              <bitRange>[6:6]</bitRange>
              <description>Master FIFO is empty (1 if empty) This is a read-only status bit. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>mfifo_level</name>
              <bitRange>[4:0]</bitRange>
              <description>Master FIFO level (0..16) This is a read-only status bit field. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'i2c_irqmsk': 0xFF8010A0-->
          <name>i2c_irqmsk</name>
          <description>I2C interrupt mask set or clear register: These bits have AND-mask character. The corresponding IRQ will generate the module IRQ only if the mask bit is set. Changing a mask bit from '0' to '1' will clear the corresponding raw IRQ state. For a detailed IRQ description, see i2c_irqraw. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000007F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sreq</name>
              <bitRange>[6:6]</bitRange>
              <description>Slave request interrupt mask </description>
            </field>
            <field>
              <name>sfifo_req</name>
              <bitRange>[5:5]</bitRange>
              <description>Slave FIFO action request interrupt mask </description>
            </field>
            <field>
              <name>mfifo_req</name>
              <bitRange>[4:4]</bitRange>
              <description>Master FIFO action request interrupt mask </description>
            </field>
            <field>
              <name>bus_busy</name>
              <bitRange>[3:3]</bitRange>
              <description>External I2C-bus is busy interrupt mask </description>
            </field>
            <field>
              <name>fifo_err</name>
              <bitRange>[2:2]</bitRange>
              <description>FIFO error interrupt mask </description>
            </field>
            <field>
              <name>cmd_err</name>
              <bitRange>[1:1]</bitRange>
              <description>Command error interrupt mask </description>
            </field>
            <field>
              <name>cmd_ok</name>
              <bitRange>[0:0]</bitRange>
              <description>Command OK interrupt mask </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'i2c_irqsr': 0xFF8010A4-->
          <name>i2c_irqsr</name>
          <description>I2C interrupt state register (raw interrupt before masking): Writing '1' will clear the corresponding IRQ. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000024</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000007F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sreq</name>
              <bitRange>[6:6]</bitRange>
              <description>Unmasked slave request interrupt state: Purpose: Set up slave FIFO 1: External master was running START-sequence and requested this slave 0: Slave is not requested </description>
            </field>
            <field>
              <name>sfifo_req</name>
              <bitRange>[5:5]</bitRange>
              <description>Unmasked slave FIFO action request interrupt state: Purpose: Slave FIFO should be updated 1: Slave FIFO request: i2c_sr.sfifo_level is above or below i2c_sfifo_cr.sfifo_wm (see description i2c_sfifo_cr) 0: Slave FIFO state not critical </description>
            </field>
            <field>
              <name>mfifo_req</name>
              <bitRange>[4:4]</bitRange>
              <description>Unmasked master FIFO action request interrupt state: Purpose: Master FIFO should be updated 1: Master FIFO request: i2c_sr.mfifo_level is above or below i2c_mfifo_cr.mfifo_wm (see description i2c_mfifo_cr) 0: Master FIFO state not critical </description>
            </field>
            <field>
              <name>bus_busy</name>
              <bitRange>[3:3]</bitRange>
              <description>Unmasked external I2C-bus is busy interrupt state: Purpose: Detect I2C-bus arbitration loss 1: Master did not gain the requested bus access because another master accessed the bus 0: Bus is idle or no transfer is requested by this master </description>
            </field>
            <field>
              <name>fifo_err</name>
              <bitRange>[2:2]</bitRange>
              <description>Unmasked FIFO error interrupt state: Purpose: Detect FIFO errors/transfer failures 1: FIFO error occurred, check register i2c_sr 0: FIFOs ok </description>
            </field>
            <field>
              <name>cmd_err</name>
              <bitRange>[1:1]</bitRange>
              <description>Unmasked command error interrupt state: Purpose: Check last command termination 1: Last command finished erroneously 0: Command not finished, no command or command finished successfully </description>
            </field>
            <field>
              <name>cmd_ok</name>
              <bitRange>[0:0]</bitRange>
              <description>Unmasked command OK interrupt state: Purpose: Check last command termination 1: Last command finished successfully 0: Command not finished, no command or command finished erroneously </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'i2c_irqmsked': 0xFF8010A8-->
          <name>i2c_irqmsked</name>
          <description>I2C masked interrupt state register: If one of these bits is set, the I2C IRQ will be set to the interrupt controller. For a detailed IRQ description, see i2c_irqraw. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000028</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000007F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sreq</name>
              <bitRange>[6:6]</bitRange>
              <description>Masked slave request interrupt state </description>
            </field>
            <field>
              <name>sfifo_req</name>
              <bitRange>[5:5]</bitRange>
              <description>Masked slave FIFO action request interrupt state </description>
            </field>
            <field>
              <name>mfifo_req</name>
              <bitRange>[4:4]</bitRange>
              <description>Masked master FIFO action request interrupt state </description>
            </field>
            <field>
              <name>bus_busy</name>
              <bitRange>[3:3]</bitRange>
              <description>Masked external I2C-bus is busy interrupt state </description>
            </field>
            <field>
              <name>fifo_err</name>
              <bitRange>[2:2]</bitRange>
              <description>Masked FIFO error interrupt state </description>
            </field>
            <field>
              <name>cmd_err</name>
              <bitRange>[1:1]</bitRange>
              <description>Masked command error interrupt state </description>
            </field>
            <field>
              <name>cmd_ok</name>
              <bitRange>[0:0]</bitRange>
              <description>Masked command OK interrupt state </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'i2c_dmacr': 0xFF8010AC-->
          <name>i2c_dmacr</name>
          <description>I2C DMA control register: Required settings for the DMA controller: - DMA transfer size to/from I2C module: Byte - DMA burst length to/from I2C module: 4 DMA burst requests will be generated if the corresponding FIFO contains more than 4 bytes (receive case) or if more than 4 bytes are writable to the corresponding FIFO (transmit case). DMA single transfer requests will be generated if the corresponding FIFO contains more than 1 byte (receive case) or if more than 1 byte is writable to the corresponding FIFO (transmit case). No further DMA requests will be generated if all transmit data is written to the master FIFO and the i2c module is the DMA flow controller (for master data only). Once all data is written to the master FIFO, the last burst/single request will be generated for the DMA controller. If the DMA controller sets DMACTC (terminal count) to indicate the end of transfer, the corresponding bit will be cleared. If one of the bits of this register is set to 0 by software and a DMA transfer has been requested before, the DMA controller will perform one last transfer to reset DMA request signals. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000002C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sdmab_en</name>
              <bitRange>[3:3]</bitRange>
              <description>Enable DMA burst requests for I2C slave data. The DMA controller must be the flow controller. This bit is writable, but can also be changed by hardware. </description>
            </field>
            <field>
              <name>sdmas_en</name>
              <bitRange>[2:2]</bitRange>
              <description>Enable DMA single requests for I2C slave data. The DMA controller must be the flow controller. This bit is writable, but can also be changed by hardware. </description>
            </field>
            <field>
              <name>mdmab_en</name>
              <bitRange>[1:1]</bitRange>
              <description>Enable DMA burst requests for I2C master data. The I2C module is the flow controller (i.e. peripheral-controlled flow control). Both, single and burst requests must be enabled. This bit is writable, but can also be changed by hardware. </description>
            </field>
            <field>
              <name>mdmas_en</name>
              <bitRange>[0:0]</bitRange>
              <description>Enable DMA single requests for I2C master data. The I2C module is the flow controller (i.e. peripheral-controlled flow control). Both, single and burst requests must be enabled. This bit is writable, but can also be changed by hardware. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'i2c_pio': 0xFF8010B0-->
          <name>i2c_pio</name>
          <description>PIO mode register: This register can directly control the I2C signals SCL and SDA if pio_mode is enabled in register i2c_mcr. In PIO mode, the I2C controller state machine is disabled, thus, no FIFO action takes place, no IRQs will be set, and no DMA-controlling is possible. Note: To avoid external driving conflicts, the I2C signals SCL and SDA are never driven active-high according to the I2C bus specification. The high level of these signals is realized by a pull-up (of the pad or externally)   and by setting the appropriate output enable to 0 (scl_oe, sda_oe) instead of driving the level active-high. Driving the signals directly by enabling the outputs (programming the bits sda_oe or scl_oe to '1') can lead to driving conflicts and could cause damage. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000030</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000044</resetValue>
          <resetMask>0x00000077</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sda_in_ro</name>
              <bitRange>[6:6]</bitRange>
              <description>SDA input state (read-only) </description>
            </field>
            <field>
              <name>sda_oe</name>
              <bitRange>[5:5]</bitRange>
              <description>SDA output enable 0: Do not drive SDA, switch pad to high-z. 1: Drive SDA, switch pad to programmed sda_out-state </description>
            </field>
            <field>
              <name>sda_out</name>
              <bitRange>[4:4]</bitRange>
              <description>Driving level of SDA (1: high, 0: low) if output is enabled (sda_oe is set) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:3]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>scl_in_ro</name>
              <bitRange>[2:2]</bitRange>
              <description>SCL input state (read-only) </description>
            </field>
            <field>
              <name>scl_oe</name>
              <bitRange>[1:1]</bitRange>
              <description>SCL output enable 0: Do not drive SCL, switch pad to high-z. 1: Drive SCL, switch pad to programmed scl_out-state </description>
            </field>
            <field>
              <name>scl_out</name>
              <bitRange>[0:0]</bitRange>
              <description>Driving level of SCL (1: high, 0: low) if output is enabled (scl_oe is set) </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>spi0_app</name>
      <description>spi0_app</description>
      <baseAddress>0xFF8010C0</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>64</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>spi0_app</name>
        <value>16</value>
      </interrupt>
      <registers>
        <register>
          <!--Absolute address of 'spi_cr0': 0xFF8010C0-->
          <name>spi_cr0</name>
          <description>SPI control register 0 Registers 0x30..0x3C can be used instead of registers 0x00...0x24 to keep netx50 software compliant to netx100/500. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80080007</resetValue>
          <resetMask>0x9B0FFFCF</resetMask>
          <fields>
            <field>
              <name>netx100_comp</name>
              <bitRange>[31:31]</bitRange>
              <description>Use netx100/500-compatible SPI mode: 0: start transfer after writing data 1: start transfer after setting CR_write or CR_read </description>
            </field>
            <field>
              <name>bf_align3</name>
              <bitRange>[30:29]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>slave_sig_early</name>
              <bitRange>[28:28]</bitRange>
              <description>Generate MISO in slave mode 1 SCK clock edge earlier than defined in the SPI specification. This is to compensate pad or sampling delays on fast data rates. However, hold timing problems could come up as MISO is generated very fast after the sampling SPI clock edge. If filter_in is enabled, it takes at least 3 system clocks to generate MISO after SCK. If filter_in is disabled, it takes at least 2 system clocks to generate MISO after SCK. </description>
            </field>
            <field>
              <name>filter_in</name>
              <bitRange>[27:27]</bitRange>
              <description>Receive data is sampled every 10ns (100MHz system clock). If this bit is set, the stored receive value will be the result of a majority decision of the three sampling points around a SPI-clock edge (if two or more '1s! were sampled a '1' will be stored, else a '0' will be stored. In slave mode chip-select and SCK edges will also be detected by oversampling if this bit is set: An edge will be detected if the majority-result of 3 subsequent sampled values toggles. Input filtering should be used for sck_muladd&lt;=0x200 (i.e. below 12.5MHz). Stable signal phases are too short with higher frequencies and input filtering cannot be used. </description>
            </field>
            <field>
              <name>bf_align2</name>
              <bitRange>[26:26]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>format</name>
              <bitRange>[25:24]</bitRange>
              <description>Frame format: 00:     Motorola SPI frame format 01..11: reserved </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[23:20]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sck_muladd</name>
              <bitRange>[19:8]</bitRange>
              <description>Serial clock rate multiply add value for master SCK generation. The SPI clock frequency is: f_spi_sck = (sck_muladd * 100)/4096 [MHz]. Default value 0x800 equals 50MHz SPI clock rate. All serial clock rates are derived from 100MHz netX system clock. Hence, all serial clock phases are multiples of 10ns. This leads to non-constant serial clock phases when a clock rate is programmed which cannot be generated by 100MHz/(2*n) without remainder. E.g. programming 0x4CC here will lead to a mean clock-rate of 30MHz. However, single clock high and low phases of 10ns and clock periods of 30ns will occur. This must be considered for serial device selection. E.g. using a 30MHz device which requires 33ns minimum clock period and a duty cycle of 50% will fail. Note: If sck_muladd is set to zero, SPI transfer will freeze. The SPI clock must not exceed (system frequency/4) in slave mode, if correct data sampling should always be guaranteed. Note: The value programmed here has no impact in slave mode. </description>
            </field>
            <field>
              <name>SPH</name>
              <bitRange>[7:7]</bitRange>
              <description>Serial clock phase (netx500: CR_ncpha): 1: sample data at second clock edge, data is generated half a clock phase before sampling 0: sample data at first clock edge, data is generated half a clock phase before sampling </description>
            </field>
            <field>
              <name>SPO</name>
              <bitRange>[6:6]</bitRange>
              <description>Serial clock polarity (netx500: CR_cpol): 0: idle: clock is low, first edge is rising 1: idle: clock is high, first edge is falling </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[5:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>datasize</name>
              <bitRange>[3:0]</bitRange>
              <description>DSS: data size select (transfer size = datasize + 1 bits): {            | 0000...0010: reserved 0011:        4 bit 0100:        5 bit ... 0111:        8 bit ... 1111:        16 bit } Note: 16 bit TX-data-loss bug of netX50/netX5 is fixed since netX10. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'spi_cr1': 0xFF8010C4-->
          <name>spi_cr1</name>
          <description>SPI control register 1 Registers 0x30..0x3C can be used instead of registers 0x00...0x24 to keep netx50 software compliant to netx100/500. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x08080000</resetValue>
          <resetMask>0x1F1F0F0F</resetMask>
          <fields>
            <field>
              <name>bf_align3</name>
              <bitRange>[31:29]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>rx_fifo_clr</name>
              <bitRange>[28:28]</bitRange>
              <description>Writing '1' to this bit will clear the receive FIFOs. </description>
            </field>
            <field>
              <name>rx_fifo_wm</name>
              <bitRange>[27:24]</bitRange>
              <description>Receive FIFO watermark for IRQ generation </description>
            </field>
            <field>
              <name>bf_align2</name>
              <bitRange>[23:21]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>tx_fifo_clr</name>
              <bitRange>[20:20]</bitRange>
              <description>Writing '1' to this bit will clear the transmit FIFOs. Note: There must be at least 1 system clock idle after clear before writing new data to the FIFO. This is guaranteed by the netX internal bus structure and needs not being considered by software. </description>
            </field>
            <field>
              <name>tx_fifo_wm</name>
              <bitRange>[19:16]</bitRange>
              <description>Transmit FIFO watermark for IRQ generation </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[15:12]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>fss_static</name>
              <bitRange>[11:11]</bitRange>
              <description>SPI static chip-select: {  | 0: SPI chip-select will be toggled automatically before and after each transferred word according to fss and datasize. 1: SPI chip-select will be set statically according to the fss bits. } </description>
            </field>
            <field>
              <name>fss</name>
              <bitRange>[10:8]</bitRange>
              <description>Frame or slave select. There are up to 3 external SPI chip-select signals. In master mode, the fss bits define the states of the chip-select signals. The inversion for low-active chip-selects (e.g. for Motorola SPI frame format) is done automatically depending on the value programmed to the 'format' bits. Example: To use the netX IO CS1 as chip-select, program '010' here, regardless whether the external chip-select is low or high active. In slave mode, the fss bits are a mask to select which netX input should be used as chip-select. Example: To use the netX IO CS0 as chip-select, program '001' here. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[7:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>SOD</name>
              <bitRange>[3:3]</bitRange>
              <description>Slave mode output disable (to connect multiple slaves to one master): 0: MISO can be driven in slave mode 1: MISO is not driven in slave mode </description>
            </field>
            <field>
              <name>MS</name>
              <bitRange>[2:2]</bitRange>
              <description>Mode select: 0: Module is configured as master 1: Module is configured as slave </description>
            </field>
            <field>
              <name>SSE</name>
              <bitRange>[1:1]</bitRange>
              <description>SPI enable: 0: Module disabled 1: Module enabled </description>
            </field>
            <field>
              <name>LBM</name>
              <bitRange>[0:0]</bitRange>
              <description>Loop back mode: 0: Internal loop back disabled 1: Internal loop back enabled, spi_cr0.filter_in must be set for loopback function </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'spi_dr': 0xFF8010C8-->
          <name>spi_dr</name>
          <description>SPI data register Registers 0x30..0x3C can be used instead of registers 0x00...0x24 to keep netx50 software compliant to netx100/500. The SPI module has 2 FIFOs: One for transmit data and one for receive data. Read access: Received data byte is delivered from receive FIFO. Write access: Transmit data byte is written to send FIFO. Both FIFOs (receive and transmit) have a depth of 16. SPI master mode: MISO input data will be stored in the receive FIFO; transmit FIFO generates MOSI output data. SPI slave mode: MOSI input data will be stored in the receive FIFO; transmit FIFO generates MISO output data. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0001FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:17]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>data</name>
              <bitRange>[16:0]</bitRange>
              <description>Transmit data: Only lowest bits according to spi_cr0.datasize will be sent. Receive data will be delivered on the lowest bits, unused bits (above spi_cr0.datasize) will be '0'. In slave mode transmit data is requested from the FIFO when the last bit of the currently transferred word is set to the MISO signal. If no next transmit data can be read from the FIFO until the current word's last bit was transferred, a FIFO underrun will occur in case chip-select does not go inactive at the next detected SCK edge. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'spi_sr': 0xFF8010CC-->
          <name>spi_sr</name>
          <description>SPI status register Registers 0x30..0x3C can be used instead of registers 0x00...0x24 to keep netx50 software compliant to netx100/500. Note: Both FIFOs (receive and transmit) have a depth of 16. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xDFDF001F</resetMask>
          <fields>
            <field>
              <name>rx_fifo_err_undr</name>
              <bitRange>[31:31]</bitRange>
              <description>Receive FIFO underrun error occurred, data is lost </description>
            </field>
            <field>
              <name>rx_fifo_err_ovfl</name>
              <bitRange>[30:30]</bitRange>
              <description>Receive FIFO overflow error occurred, data is lost </description>
            </field>
            <field>
              <name>bf_align2</name>
              <bitRange>[29:29]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>rx_fifo_level</name>
              <bitRange>[28:24]</bitRange>
              <description>Receive FIFO level (number of received words to read out are left in FIFO) </description>
            </field>
            <field>
              <name>tx_fifo_err_undr</name>
              <bitRange>[23:23]</bitRange>
              <description>Transmit FIFO underrun error occurred, data is lost </description>
            </field>
            <field>
              <name>tx_fifo_err_ovfl</name>
              <bitRange>[22:22]</bitRange>
              <description>Transmit FIFO overflow error occurred, data is lost </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[21:21]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>tx_fifo_level</name>
              <bitRange>[20:16]</bitRange>
              <description>Transmit FIFO level (number of words to transmit are left in FIFO) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[15:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>BSY</name>
              <bitRange>[4:4]</bitRange>
              <description>Device busy (1 if data is currently transmitted/received or the transmit FIFO is not empty) </description>
            </field>
            <field>
              <name>RFF</name>
              <bitRange>[3:3]</bitRange>
              <description>Receive FIFO is full (1 if full) </description>
            </field>
            <field>
              <name>RNE</name>
              <bitRange>[2:2]</bitRange>
              <description>Receive FIFO is not empty (0 if empty) </description>
            </field>
            <field>
              <name>TNF</name>
              <bitRange>[1:1]</bitRange>
              <description>Transmit FIFO is not full (0 if full) </description>
            </field>
            <field>
              <name>TFE</name>
              <bitRange>[0:0]</bitRange>
              <description>Transmit FIFO is empty (1 if empty) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'spi_imsc': 0xFF8010D4-->
          <name>spi_imsc</name>
          <description>SPI Interrupt Mask Set and Clear register: Registers 0x30..0x3C can be used instead of registers 0x00...0x24 to keep netx50 software compliant to netx100/500. IRQ mask is an AND-mask: only raw interrupts with mask bit set can generate a module IRQ. When writing this register, the corresponding interrupt is cleared similar to writing the register spi_icr.  Note: The functionality of this register is similar to the corresponding SQI register sqi_irq_mask.       However, in contrast to this register, setting bits in sqi_irq_mask does not clear the corresponding interrupts.  Note: Both FIFOs (receive and transmit) have a depth of 16. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000007F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>txeim</name>
              <bitRange>[6:6]</bitRange>
              <description>Transmit FIFO empty interrupt mask (for netx100/500 compliance) </description>
            </field>
            <field>
              <name>rxfim</name>
              <bitRange>[5:5]</bitRange>
              <description>Receive FIFO full interrupt mask (for netx100/500 compliance) </description>
            </field>
            <field>
              <name>rxneim</name>
              <bitRange>[4:4]</bitRange>
              <description>Receive FIFO not empty interrupt mask (for netx100/500 compliance) </description>
            </field>
            <field>
              <name>TXIM</name>
              <bitRange>[3:3]</bitRange>
              <description>Transmit FIFO interrupt mask </description>
            </field>
            <field>
              <name>RXIM</name>
              <bitRange>[2:2]</bitRange>
              <description>Receive FIFO interrupt mask </description>
            </field>
            <field>
              <name>RTIM</name>
              <bitRange>[1:1]</bitRange>
              <description>Receive timeout interrupt mask </description>
            </field>
            <field>
              <name>RORIM</name>
              <bitRange>[0:0]</bitRange>
              <description>Receive FIFO overrun interrupt mask </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'spi_ris': 0xFF8010D8-->
          <name>spi_ris</name>
          <description>SPI interrupt state before masking register (raw interrupt) Registers 0x30..0x3C can be used instead of registers 0x00...0x24 to keep netx50 software compliant to netx100/500. Note: Both FIFOs (receive and transmit) have a depth of 16. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000018</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000007F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>txeris</name>
              <bitRange>[6:6]</bitRange>
              <description>Unmasked transmit FIFO empty interrupt state (for netx100/500 compliance) 1: transmit FIFO is empty 0: transmit FIFO is not empty </description>
            </field>
            <field>
              <name>rxfris</name>
              <bitRange>[5:5]</bitRange>
              <description>Unmasked receive FIFO full interrupt state (for netx100/500 compliance) 1: receive FIFO is full 0: receive FIFO is not full </description>
            </field>
            <field>
              <name>rxneris</name>
              <bitRange>[4:4]</bitRange>
              <description>Unmasked receive FIFO not empty interrupt state (for netx100/500 compliance) 1: receive FIFO is not empty 0: receive FIFO is empty </description>
            </field>
            <field>
              <name>TXRIS</name>
              <bitRange>[3:3]</bitRange>
              <description>Unmasked transmit FIFO interrupt state 1: transmit FIFO level is below spi_cr1.tx_fifo_wm 0: transmit FIFO equals or is higher than spi_cr1.tx_fifo_wm </description>
            </field>
            <field>
              <name>RXRIS</name>
              <bitRange>[2:2]</bitRange>
              <description>Unmasked receive FIFO interrupt state 1: receive FIFO is higher than spi_cr1.rx_fifo_wm 0: receive FIFO is equals or is below spi_cr1.rx_fifo_wm </description>
            </field>
            <field>
              <name>RTRIS</name>
              <bitRange>[1:1]</bitRange>
              <description>Unmasked receive timeout interrupt state Timeout period are 32 SPI clock periods depending on adr_spi_cr0.sck_muladd 1: receive FIFO is not empty and not read out in the passed timeout period 0: receive FIFO is empty or read during the last timeout period </description>
            </field>
            <field>
              <name>RORRIS</name>
              <bitRange>[0:0]</bitRange>
              <description>Unmasked receive FIFO overrun interrupt state 1: receive FIFO overrun error occurred 0: no receive FIFO overrun error occurred </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'spi_mis': 0xFF8010DC-->
          <name>spi_mis</name>
          <description>SPI interrupt status register Registers 0x30..0x3C can be used instead of registers 0x00...0x24 to keep netx50 software compliant to netx100/500. Note: Both FIFOs (receive and transmit) have a depth of 16. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000001C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000007F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>txemis</name>
              <bitRange>[6:6]</bitRange>
              <description>Masked transmit FIFO empty interrupt state (for netx100/500 compliance) </description>
            </field>
            <field>
              <name>rxfmis</name>
              <bitRange>[5:5]</bitRange>
              <description>Masked receive FIFO full interrupt state (for netx100/500 compliance) </description>
            </field>
            <field>
              <name>rxnemis</name>
              <bitRange>[4:4]</bitRange>
              <description>Masked receive FIFO not empty interrupt state (for netx100/500 compliance) </description>
            </field>
            <field>
              <name>TXMIS</name>
              <bitRange>[3:3]</bitRange>
              <description>Masked transmit FIFO interrupt state </description>
            </field>
            <field>
              <name>RXMIS</name>
              <bitRange>[2:2]</bitRange>
              <description>Masked receive FIFO interrupt state </description>
            </field>
            <field>
              <name>RTMIS</name>
              <bitRange>[1:1]</bitRange>
              <description>Masked receive timeout interrupt state </description>
            </field>
            <field>
              <name>RORMIS</name>
              <bitRange>[0:0]</bitRange>
              <description>Masked receive FIFO overrun interrupt state </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'spi_icr': 0xFF8010E0-->
          <name>spi_icr</name>
          <description>SPI interrupt clear register Registers 0x30..0x3C can be used instead of registers 0x00...0x24 to keep netx50 software compliant to netx100/500. An interrupt is cleared by writing '1' to the according bit. Note: Both FIFOs (receive and transmit) have a depth of 16. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000007F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>txeic</name>
              <bitRange>[6:6]</bitRange>
              <description>Clear transmit FIFO empty interrupt (for netx100/500 compliance) </description>
            </field>
            <field>
              <name>rxfic</name>
              <bitRange>[5:5]</bitRange>
              <description>Clear receive FIFO full interrupt (for netx100/500 compliance) </description>
            </field>
            <field>
              <name>rxneic</name>
              <bitRange>[4:4]</bitRange>
              <description>Clear receive FIFO not empty interrupt (for netx100/500 compliance) </description>
            </field>
            <field>
              <name>TXIC</name>
              <bitRange>[3:3]</bitRange>
              <description>PL022 extension: clear transmit FIFO interrupt </description>
            </field>
            <field>
              <name>RXIC</name>
              <bitRange>[2:2]</bitRange>
              <description>PL022 extension: clear receive FIFO interrupt </description>
            </field>
            <field>
              <name>RTIC</name>
              <bitRange>[1:1]</bitRange>
              <description>Clear receive FIFO overrun interrupt </description>
            </field>
            <field>
              <name>RORIC</name>
              <bitRange>[0:0]</bitRange>
              <description>Clear receive FIFO overrun interrupt Writing '1' here will clear the receive FIFO </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'spi_dmacr': 0xFF8010E8-->
          <name>spi_dmacr</name>
          <description>SPI DMA control register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000028</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:2]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>TXDMAE</name>
              <bitRange>[1:1]</bitRange>
              <description>Enable DMA for SPI transmit data. A single request will be generated if the transmit FIFO is not full and spi_cr1.SSE (module enable) is set. Burst requests to the DMA controller will be generated if at least 4 words are writable to the transmit FIFO (set DMA burst size to 4). If this bit is reset or the module is disabled, the DMA request signals will also be reset. Note: set dmac_chctrl.SBSize = 1 (i.e. burst size: 4) in the DMA controller. </description>
            </field>
            <field>
              <name>RXDMAE</name>
              <bitRange>[0:0]</bitRange>
              <description>Enable DMA for SPI receive data. A single request will be generated if the receive FIFO is not empty and spi_cr1.SSE (module enable) is set. Burst request to the DMA controller will be generated if the receive FIFO contains at least 4 words (set DMA burst size to 4). If this bit is reset or the module is disabled, the DMA request signals will also be reset. Note: set dmac_chctrl.SBSize = 1 (i.e. burst size: 4) in the DMA controller. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'spi_data_register': 0xFF8010F0-->
          <name>spi_data_register</name>
          <description>netx100/500 compliant SPI data register (DR) Registers 0x30..0x3C can be used instead of registers 0x00...0x24 to keep netx50 software compliant to netx100/500. 2 data bytes with valid bits. During a write access data_byte_1 and dr_valid1 must not be used. dr_valid0 must be set. In netx50 and later versions both FIFOs (receive and transmit) have a depth of 16, fill values are fixed to 4. To keep software compatible, not more than 8 bytes should be in netx100/500 FIFOs. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000030</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0003FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:18]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>dr_valid1</name>
              <bitRange>[17:17]</bitRange>
              <description>Obsolete, always 0 </description>
            </field>
            <field>
              <name>dr_valid0</name>
              <bitRange>[16:16]</bitRange>
              <description>Valid bit for data_byte_0 This bit shows if data_byte_0 is valid and must be set during a FIFO write access. </description>
            </field>
            <field>
              <name>data_byte_1</name>
              <bitRange>[15:8]</bitRange>
              <description>Obsolete, don't use </description>
            </field>
            <field>
              <name>data_byte_0</name>
              <bitRange>[7:0]</bitRange>
              <description>Data byte 0 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'spi_status_register': 0xFF8010F4-->
          <name>spi_status_register</name>
          <description>netx100/500 compliant SPI status register (SR): Shows the actual status of the SPI interface. Bits 24..18 show occurred interrupts; writing ones into these bits clears the interrupts. Writing into other bits has no effect. In netx50 and later versions both FIFOs (receive and transmit) have a depth of 16, fill values are fixed to 4. To keep software compatible, not more than 8 bytes should be in netx100/500 FIFOs. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000034</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x03FFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:26]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>SR_selected</name>
              <bitRange>[25:25]</bitRange>
              <description>External master has access to SPI interface </description>
            </field>
            <field>
              <name>SR_out_full</name>
              <bitRange>[24:24]</bitRange>
              <description>Output FIFO is full. This is only with netx100/500 an IRQ. </description>
            </field>
            <field>
              <name>SR_out_empty</name>
              <bitRange>[23:23]</bitRange>
              <description>Output FIFO is empty in slave mode (equals spi_ris.txeris in netx50 and later versions) </description>
            </field>
            <field>
              <name>SR_out_fw</name>
              <bitRange>[22:22]</bitRange>
              <description>netX is writing data too fast into output FIFO. Available as an IRQ only on netx100/500 (equals spi_sr.tx_fifo_err_ovfl in netx50 and later versions). </description>
            </field>
            <field>
              <name>SR_out_fuel</name>
              <bitRange>[21:21]</bitRange>
              <description>Adjustable fill value of output FIFO reached (equals spi_ris.TXRIS in netx50 and later versions) </description>
            </field>
            <field>
              <name>SR_in_full</name>
              <bitRange>[20:20]</bitRange>
              <description>Input FIFO is full (equals spi_ris.rxfris in netx50 and later versions) </description>
            </field>
            <field>
              <name>SR_in_recdata</name>
              <bitRange>[19:19]</bitRange>
              <description>Valid data bytes in input FIFO (equals spi_ris.rxneris in netx50 and later versions) </description>
            </field>
            <field>
              <name>SR_in_fuel</name>
              <bitRange>[18:18]</bitRange>
              <description>Adjustable fill value of input FIFO reached (equals spi_ris.RXRIS in netx50 and later versions) </description>
            </field>
            <field>
              <name>SR_out_fuel_val</name>
              <bitRange>[17:9]</bitRange>
              <description>Output FIFO fill value (number of bytes) </description>
            </field>
            <field>
              <name>SR_in_fuel_val</name>
              <bitRange>[8:0]</bitRange>
              <description>Input FIFO fill value (number of bytes) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'spi_control_register': 0xFF8010F8-->
          <name>spi_control_register</name>
          <description>netx100/500 compliant SPI control register (CR) </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000038</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFF00FDF</resetMask>
          <fields>
            <field>
              <name>CR_en</name>
              <bitRange>[31:31]</bitRange>
              <description>1: enable 0: disable SPI interface </description>
            </field>
            <field>
              <name>CR_ms</name>
              <bitRange>[30:30]</bitRange>
              <description>1: master mode 0:slave mode </description>
            </field>
            <field>
              <name>CR_cpol</name>
              <bitRange>[29:29]</bitRange>
              <description>1: falling edge of SCK is primary 0: rising edge of SCK is primary </description>
            </field>
            <field>
              <name>CR_ncpha</name>
              <bitRange>[28:28]</bitRange>
              <description>SPI clock phase mode (Note: meaning of this bit is inverted to functionality of bit spi_cr0.SPH): {  | 0: change data on secondary SCK edge data is active on primary SCK edge 1: change data on primary SCK edge data is active on secondary SCK edge } </description>
            </field>
            <field>
              <name>CR_burst</name>
              <bitRange>[27:25]</bitRange>
              <description>netx100/netx500 only, obsolete in later versions: burst length = 2^CR_burst </description>
            </field>
            <field>
              <name>CR_burstdelay</name>
              <bitRange>[24:22]</bitRange>
              <description>netx100/netx500 only, obsolete in later versions: delay between transmission of 2 data bytes (0 to 7 SCK cycles) </description>
            </field>
            <field>
              <name>CR_clr_outfifo</name>
              <bitRange>[21:21]</bitRange>
              <description>Clear output FIFO </description>
            </field>
            <field>
              <name>CR_clr_infifo</name>
              <bitRange>[20:20]</bitRange>
              <description>Clear input FIFO </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[19:12]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>CS_mode</name>
              <bitRange>[11:11]</bitRange>
              <description>1: chip select is generated automatically by the internal state machine 0: chip select is directly controlled by software (see bits CR_ss). </description>
            </field>
            <field>
              <name>CR_ss</name>
              <bitRange>[10:8]</bitRange>
              <description>External slave select </description>
            </field>
            <field>
              <name>CR_write</name>
              <bitRange>[7:7]</bitRange>
              <description>netx100/netx500 only, in later versions always '1':  1: enable SPI interface write data </description>
            </field>
            <field>
              <name>CR_read</name>
              <bitRange>[6:6]</bitRange>
              <description>netx100/netx500 only, in later versions always '1':  1: enable SPI interface read data </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>CR_speed</name>
              <bitRange>[4:1]</bitRange>
              <description>Clock divider for SPI clock (2 - 2^16) If SPI clock rate is changed using spi_cr0.sck_muladd, this value will not be updated and may be incorrect There are 16 different SPI clocks frequencies to choose: 0000: 0.025 MHz (Note: Not compatible to netx100/500. '0000' freezes SCK in netx100/500.) 0001: 0.05 MHz 0010: 0.1 MHz 0011: 0.2 MHz 0100: 0.5 MHz 0101: 1 MHz 0110: 1.25 MHz 0111: 2 MHz 1000: 2.5 MHz 1001: 3.3333 MHz 1010: 5 MHz 1011: 10 MHz 1100: 12.5 MHz 1101: 16.6666 MHz 1110: 25 MHz 1111: 50 MHz </description>
            </field>
            <field>
              <name>CR_softreset</name>
              <bitRange>[0:0]</bitRange>
              <description>write only: no function in netx100/netx500; later versions: clears IRQs and FIFOs </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'spi_interrupt_control_register': 0xFF8010FC-->
          <name>spi_interrupt_control_register</name>
          <description>netx100/500 compliant SPI interrupt control register (IR) In netx50 and later versions both FIFOs (receive and transmit) have a depth of 16, fill values are fixed to 4. To keep software compatible, not more than 8 bytes should be in netx100/500 FIFOs. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000003C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x01FFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:25]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>IR_out_full_en</name>
              <bitRange>[24:24]</bitRange>
              <description>IRQ enable for irq_spi(6), netx100/netx500 only, always '0' in later versions </description>
            </field>
            <field>
              <name>IR_out_empty_en</name>
              <bitRange>[23:23]</bitRange>
              <description>IRQ enable for irq_spi(5)  (equals spi_imsc.rxeim in netx50 and later versions) </description>
            </field>
            <field>
              <name>IR_out_fw_en</name>
              <bitRange>[22:22]</bitRange>
              <description>IRQ enable for irq_spi(4), netx100/netx500 only, always '0' in later versions </description>
            </field>
            <field>
              <name>IR_out_fuel_en</name>
              <bitRange>[21:21]</bitRange>
              <description>IRQ enable for irq_spi(3)  (equals spi_imsc.TXIM in netx50 and later versions) </description>
            </field>
            <field>
              <name>IR_in_full_en</name>
              <bitRange>[20:20]</bitRange>
              <description>IRQ enable for irq_spi(2)  (equals spi_imsc.txfim in netx50 and later versions) </description>
            </field>
            <field>
              <name>IR_in_recdata_en</name>
              <bitRange>[19:19]</bitRange>
              <description>IRQ enable for irq_spi(1)  (equals spi_imsc.txneim in netx50 and later versions) </description>
            </field>
            <field>
              <name>IR_in_fuel_en</name>
              <bitRange>[18:18]</bitRange>
              <description>IRQ enable for irq_spi(0)  (equals spi_imsc.RXIM in netx50 and later versions) </description>
            </field>
            <field>
              <name>IR_out_fuel</name>
              <bitRange>[17:9]</bitRange>
              <description>Adjustable watermark level of output FIFO </description>
            </field>
            <field>
              <name>IR_in_fuel</name>
              <bitRange>[8:0]</bitRange>
              <description>Adjustable watermark level of input FIFO </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>spi1_app</name>
      <description>spi1_app</description>
      <baseAddress>0xFF801100</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>64</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>spi1_app</name>
        <value>17</value>
      </interrupt>
      <registers>
        <register>
          <!--Absolute address of 'spi_cr0': 0xFF801100-->
          <name>spi_cr0</name>
          <description>SPI control register 0 Registers 0x30..0x3C can be used instead of registers 0x00...0x24 to keep netx50 software compliant to netx100/500. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80080007</resetValue>
          <resetMask>0x9B0FFFCF</resetMask>
          <fields>
            <field>
              <name>netx100_comp</name>
              <bitRange>[31:31]</bitRange>
              <description>Use netx100/500-compatible SPI mode: 0: start transfer after writing data 1: start transfer after setting CR_write or CR_read </description>
            </field>
            <field>
              <name>bf_align3</name>
              <bitRange>[30:29]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>slave_sig_early</name>
              <bitRange>[28:28]</bitRange>
              <description>Generate MISO in slave mode 1 SCK clock edge earlier than defined in the SPI specification. This is to compensate pad or sampling delays on fast data rates. However, hold timing problems could come up as MISO is generated very fast after the sampling SPI clock edge. If filter_in is enabled, it takes at least 3 system clocks to generate MISO after SCK. If filter_in is disabled, it takes at least 2 system clocks to generate MISO after SCK. </description>
            </field>
            <field>
              <name>filter_in</name>
              <bitRange>[27:27]</bitRange>
              <description>Receive data is sampled every 10ns (100MHz system clock). If this bit is set, the stored receive value will be the result of a majority decision of the three sampling points around a SPI-clock edge (if two or more '1s! were sampled a '1' will be stored, else a '0' will be stored. In slave mode chip-select and SCK edges will also be detected by oversampling if this bit is set: An edge will be detected if the majority-result of 3 subsequent sampled values toggles. Input filtering should be used for sck_muladd&lt;=0x200 (i.e. below 12.5MHz). Stable signal phases are too short with higher frequencies and input filtering cannot be used. </description>
            </field>
            <field>
              <name>bf_align2</name>
              <bitRange>[26:26]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>format</name>
              <bitRange>[25:24]</bitRange>
              <description>Frame format: 00:     Motorola SPI frame format 01..11: reserved </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[23:20]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sck_muladd</name>
              <bitRange>[19:8]</bitRange>
              <description>Serial clock rate multiply add value for master SCK generation. The SPI clock frequency is: f_spi_sck = (sck_muladd * 100)/4096 [MHz]. Default value 0x800 equals 50MHz SPI clock rate. All serial clock rates are derived from 100MHz netX system clock. Hence, all serial clock phases are multiples of 10ns. This leads to non-constant serial clock phases when a clock rate is programmed which cannot be generated by 100MHz/(2*n) without remainder. E.g. programming 0x4CC here will lead to a mean clock-rate of 30MHz. However, single clock high and low phases of 10ns and clock periods of 30ns will occur. This must be considered for serial device selection. E.g. using a 30MHz device which requires 33ns minimum clock period and a duty cycle of 50% will fail. Note: If sck_muladd is set to zero, SPI transfer will freeze. The SPI clock must not exceed (system frequency/4) in slave mode, if correct data sampling should always be guaranteed. Note: The value programmed here has no impact in slave mode. </description>
            </field>
            <field>
              <name>SPH</name>
              <bitRange>[7:7]</bitRange>
              <description>Serial clock phase (netx500: CR_ncpha): 1: sample data at second clock edge, data is generated half a clock phase before sampling 0: sample data at first clock edge, data is generated half a clock phase before sampling </description>
            </field>
            <field>
              <name>SPO</name>
              <bitRange>[6:6]</bitRange>
              <description>Serial clock polarity (netx500: CR_cpol): 0: idle: clock is low, first edge is rising 1: idle: clock is high, first edge is falling </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[5:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>datasize</name>
              <bitRange>[3:0]</bitRange>
              <description>DSS: data size select (transfer size = datasize + 1 bits): {            | 0000...0010: reserved 0011:        4 bit 0100:        5 bit ... 0111:        8 bit ... 1111:        16 bit } Note: 16 bit TX-data-loss bug of netX50/netX5 is fixed since netX10. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'spi_cr1': 0xFF801104-->
          <name>spi_cr1</name>
          <description>SPI control register 1 Registers 0x30..0x3C can be used instead of registers 0x00...0x24 to keep netx50 software compliant to netx100/500. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x08080000</resetValue>
          <resetMask>0x1F1F0F0F</resetMask>
          <fields>
            <field>
              <name>bf_align3</name>
              <bitRange>[31:29]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>rx_fifo_clr</name>
              <bitRange>[28:28]</bitRange>
              <description>Writing '1' to this bit will clear the receive FIFOs. </description>
            </field>
            <field>
              <name>rx_fifo_wm</name>
              <bitRange>[27:24]</bitRange>
              <description>Receive FIFO watermark for IRQ generation </description>
            </field>
            <field>
              <name>bf_align2</name>
              <bitRange>[23:21]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>tx_fifo_clr</name>
              <bitRange>[20:20]</bitRange>
              <description>Writing '1' to this bit will clear the transmit FIFOs. Note: There must be at least 1 system clock idle after clear before writing new data to the FIFO. This is guaranteed by the netX internal bus structure and needs not being considered by software. </description>
            </field>
            <field>
              <name>tx_fifo_wm</name>
              <bitRange>[19:16]</bitRange>
              <description>Transmit FIFO watermark for IRQ generation </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[15:12]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>fss_static</name>
              <bitRange>[11:11]</bitRange>
              <description>SPI static chip-select: {  | 0: SPI chip-select will be toggled automatically before and after each transferred word according to fss and datasize. 1: SPI chip-select will be set statically according to the fss bits. } </description>
            </field>
            <field>
              <name>fss</name>
              <bitRange>[10:8]</bitRange>
              <description>Frame or slave select. There are up to 3 external SPI chip-select signals. In master mode, the fss bits define the states of the chip-select signals. The inversion for low-active chip-selects (e.g. for Motorola SPI frame format) is done automatically depending on the value programmed to the 'format' bits. Example: To use the netX IO CS1 as chip-select, program '010' here, regardless whether the external chip-select is low or high active. In slave mode, the fss bits are a mask to select which netX input should be used as chip-select. Example: To use the netX IO CS0 as chip-select, program '001' here. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[7:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>SOD</name>
              <bitRange>[3:3]</bitRange>
              <description>Slave mode output disable (to connect multiple slaves to one master): 0: MISO can be driven in slave mode 1: MISO is not driven in slave mode </description>
            </field>
            <field>
              <name>MS</name>
              <bitRange>[2:2]</bitRange>
              <description>Mode select: 0: Module is configured as master 1: Module is configured as slave </description>
            </field>
            <field>
              <name>SSE</name>
              <bitRange>[1:1]</bitRange>
              <description>SPI enable: 0: Module disabled 1: Module enabled </description>
            </field>
            <field>
              <name>LBM</name>
              <bitRange>[0:0]</bitRange>
              <description>Loop back mode: 0: Internal loop back disabled 1: Internal loop back enabled, spi_cr0.filter_in must be set for loopback function </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'spi_dr': 0xFF801108-->
          <name>spi_dr</name>
          <description>SPI data register Registers 0x30..0x3C can be used instead of registers 0x00...0x24 to keep netx50 software compliant to netx100/500. The SPI module has 2 FIFOs: One for transmit data and one for receive data. Read access: Received data byte is delivered from receive FIFO. Write access: Transmit data byte is written to send FIFO. Both FIFOs (receive and transmit) have a depth of 16. SPI master mode: MISO input data will be stored in the receive FIFO; transmit FIFO generates MOSI output data. SPI slave mode: MOSI input data will be stored in the receive FIFO; transmit FIFO generates MISO output data. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0001FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:17]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>data</name>
              <bitRange>[16:0]</bitRange>
              <description>Transmit data: Only lowest bits according to spi_cr0.datasize will be sent. Receive data will be delivered on the lowest bits, unused bits (above spi_cr0.datasize) will be '0'. In slave mode transmit data is requested from the FIFO when the last bit of the currently transferred word is set to the MISO signal. If no next transmit data can be read from the FIFO until the current word's last bit was transferred, a FIFO underrun will occur in case chip-select does not go inactive at the next detected SCK edge. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'spi_sr': 0xFF80110C-->
          <name>spi_sr</name>
          <description>SPI status register Registers 0x30..0x3C can be used instead of registers 0x00...0x24 to keep netx50 software compliant to netx100/500. Note: Both FIFOs (receive and transmit) have a depth of 16. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xDFDF001F</resetMask>
          <fields>
            <field>
              <name>rx_fifo_err_undr</name>
              <bitRange>[31:31]</bitRange>
              <description>Receive FIFO underrun error occurred, data is lost </description>
            </field>
            <field>
              <name>rx_fifo_err_ovfl</name>
              <bitRange>[30:30]</bitRange>
              <description>Receive FIFO overflow error occurred, data is lost </description>
            </field>
            <field>
              <name>bf_align2</name>
              <bitRange>[29:29]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>rx_fifo_level</name>
              <bitRange>[28:24]</bitRange>
              <description>Receive FIFO level (number of received words to read out are left in FIFO) </description>
            </field>
            <field>
              <name>tx_fifo_err_undr</name>
              <bitRange>[23:23]</bitRange>
              <description>Transmit FIFO underrun error occurred, data is lost </description>
            </field>
            <field>
              <name>tx_fifo_err_ovfl</name>
              <bitRange>[22:22]</bitRange>
              <description>Transmit FIFO overflow error occurred, data is lost </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[21:21]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>tx_fifo_level</name>
              <bitRange>[20:16]</bitRange>
              <description>Transmit FIFO level (number of words to transmit are left in FIFO) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[15:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>BSY</name>
              <bitRange>[4:4]</bitRange>
              <description>Device busy (1 if data is currently transmitted/received or the transmit FIFO is not empty) </description>
            </field>
            <field>
              <name>RFF</name>
              <bitRange>[3:3]</bitRange>
              <description>Receive FIFO is full (1 if full) </description>
            </field>
            <field>
              <name>RNE</name>
              <bitRange>[2:2]</bitRange>
              <description>Receive FIFO is not empty (0 if empty) </description>
            </field>
            <field>
              <name>TNF</name>
              <bitRange>[1:1]</bitRange>
              <description>Transmit FIFO is not full (0 if full) </description>
            </field>
            <field>
              <name>TFE</name>
              <bitRange>[0:0]</bitRange>
              <description>Transmit FIFO is empty (1 if empty) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'spi_imsc': 0xFF801114-->
          <name>spi_imsc</name>
          <description>SPI Interrupt Mask Set and Clear register: Registers 0x30..0x3C can be used instead of registers 0x00...0x24 to keep netx50 software compliant to netx100/500. IRQ mask is an AND-mask: only raw interrupts with mask bit set can generate a module IRQ. When writing this register, the corresponding interrupt is cleared similar to writing the register spi_icr.  Note: The functionality of this register is similar to the corresponding SQI register sqi_irq_mask.       However, in contrast to this register, setting bits in sqi_irq_mask does not clear the corresponding interrupts.  Note: Both FIFOs (receive and transmit) have a depth of 16. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000007F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>txeim</name>
              <bitRange>[6:6]</bitRange>
              <description>Transmit FIFO empty interrupt mask (for netx100/500 compliance) </description>
            </field>
            <field>
              <name>rxfim</name>
              <bitRange>[5:5]</bitRange>
              <description>Receive FIFO full interrupt mask (for netx100/500 compliance) </description>
            </field>
            <field>
              <name>rxneim</name>
              <bitRange>[4:4]</bitRange>
              <description>Receive FIFO not empty interrupt mask (for netx100/500 compliance) </description>
            </field>
            <field>
              <name>TXIM</name>
              <bitRange>[3:3]</bitRange>
              <description>Transmit FIFO interrupt mask </description>
            </field>
            <field>
              <name>RXIM</name>
              <bitRange>[2:2]</bitRange>
              <description>Receive FIFO interrupt mask </description>
            </field>
            <field>
              <name>RTIM</name>
              <bitRange>[1:1]</bitRange>
              <description>Receive timeout interrupt mask </description>
            </field>
            <field>
              <name>RORIM</name>
              <bitRange>[0:0]</bitRange>
              <description>Receive FIFO overrun interrupt mask </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'spi_ris': 0xFF801118-->
          <name>spi_ris</name>
          <description>SPI interrupt state before masking register (raw interrupt) Registers 0x30..0x3C can be used instead of registers 0x00...0x24 to keep netx50 software compliant to netx100/500. Note: Both FIFOs (receive and transmit) have a depth of 16. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000018</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000007F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>txeris</name>
              <bitRange>[6:6]</bitRange>
              <description>Unmasked transmit FIFO empty interrupt state (for netx100/500 compliance) 1: transmit FIFO is empty 0: transmit FIFO is not empty </description>
            </field>
            <field>
              <name>rxfris</name>
              <bitRange>[5:5]</bitRange>
              <description>Unmasked receive FIFO full interrupt state (for netx100/500 compliance) 1: receive FIFO is full 0: receive FIFO is not full </description>
            </field>
            <field>
              <name>rxneris</name>
              <bitRange>[4:4]</bitRange>
              <description>Unmasked receive FIFO not empty interrupt state (for netx100/500 compliance) 1: receive FIFO is not empty 0: receive FIFO is empty </description>
            </field>
            <field>
              <name>TXRIS</name>
              <bitRange>[3:3]</bitRange>
              <description>Unmasked transmit FIFO interrupt state 1: transmit FIFO level is below spi_cr1.tx_fifo_wm 0: transmit FIFO equals or is higher than spi_cr1.tx_fifo_wm </description>
            </field>
            <field>
              <name>RXRIS</name>
              <bitRange>[2:2]</bitRange>
              <description>Unmasked receive FIFO interrupt state 1: receive FIFO is higher than spi_cr1.rx_fifo_wm 0: receive FIFO is equals or is below spi_cr1.rx_fifo_wm </description>
            </field>
            <field>
              <name>RTRIS</name>
              <bitRange>[1:1]</bitRange>
              <description>Unmasked receive timeout interrupt state Timeout period are 32 SPI clock periods depending on adr_spi_cr0.sck_muladd 1: receive FIFO is not empty and not read out in the passed timeout period 0: receive FIFO is empty or read during the last timeout period </description>
            </field>
            <field>
              <name>RORRIS</name>
              <bitRange>[0:0]</bitRange>
              <description>Unmasked receive FIFO overrun interrupt state 1: receive FIFO overrun error occurred 0: no receive FIFO overrun error occurred </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'spi_mis': 0xFF80111C-->
          <name>spi_mis</name>
          <description>SPI interrupt status register Registers 0x30..0x3C can be used instead of registers 0x00...0x24 to keep netx50 software compliant to netx100/500. Note: Both FIFOs (receive and transmit) have a depth of 16. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000001C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000007F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>txemis</name>
              <bitRange>[6:6]</bitRange>
              <description>Masked transmit FIFO empty interrupt state (for netx100/500 compliance) </description>
            </field>
            <field>
              <name>rxfmis</name>
              <bitRange>[5:5]</bitRange>
              <description>Masked receive FIFO full interrupt state (for netx100/500 compliance) </description>
            </field>
            <field>
              <name>rxnemis</name>
              <bitRange>[4:4]</bitRange>
              <description>Masked receive FIFO not empty interrupt state (for netx100/500 compliance) </description>
            </field>
            <field>
              <name>TXMIS</name>
              <bitRange>[3:3]</bitRange>
              <description>Masked transmit FIFO interrupt state </description>
            </field>
            <field>
              <name>RXMIS</name>
              <bitRange>[2:2]</bitRange>
              <description>Masked receive FIFO interrupt state </description>
            </field>
            <field>
              <name>RTMIS</name>
              <bitRange>[1:1]</bitRange>
              <description>Masked receive timeout interrupt state </description>
            </field>
            <field>
              <name>RORMIS</name>
              <bitRange>[0:0]</bitRange>
              <description>Masked receive FIFO overrun interrupt state </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'spi_icr': 0xFF801120-->
          <name>spi_icr</name>
          <description>SPI interrupt clear register Registers 0x30..0x3C can be used instead of registers 0x00...0x24 to keep netx50 software compliant to netx100/500. An interrupt is cleared by writing '1' to the according bit. Note: Both FIFOs (receive and transmit) have a depth of 16. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000007F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>txeic</name>
              <bitRange>[6:6]</bitRange>
              <description>Clear transmit FIFO empty interrupt (for netx100/500 compliance) </description>
            </field>
            <field>
              <name>rxfic</name>
              <bitRange>[5:5]</bitRange>
              <description>Clear receive FIFO full interrupt (for netx100/500 compliance) </description>
            </field>
            <field>
              <name>rxneic</name>
              <bitRange>[4:4]</bitRange>
              <description>Clear receive FIFO not empty interrupt (for netx100/500 compliance) </description>
            </field>
            <field>
              <name>TXIC</name>
              <bitRange>[3:3]</bitRange>
              <description>PL022 extension: clear transmit FIFO interrupt </description>
            </field>
            <field>
              <name>RXIC</name>
              <bitRange>[2:2]</bitRange>
              <description>PL022 extension: clear receive FIFO interrupt </description>
            </field>
            <field>
              <name>RTIC</name>
              <bitRange>[1:1]</bitRange>
              <description>Clear receive FIFO overrun interrupt </description>
            </field>
            <field>
              <name>RORIC</name>
              <bitRange>[0:0]</bitRange>
              <description>Clear receive FIFO overrun interrupt Writing '1' here will clear the receive FIFO </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'spi_dmacr': 0xFF801128-->
          <name>spi_dmacr</name>
          <description>SPI DMA control register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000028</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:2]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>TXDMAE</name>
              <bitRange>[1:1]</bitRange>
              <description>Enable DMA for SPI transmit data. A single request will be generated if the transmit FIFO is not full and spi_cr1.SSE (module enable) is set. Burst requests to the DMA controller will be generated if at least 4 words are writable to the transmit FIFO (set DMA burst size to 4). If this bit is reset or the module is disabled, the DMA request signals will also be reset. Note: set dmac_chctrl.SBSize = 1 (i.e. burst size: 4) in the DMA controller. </description>
            </field>
            <field>
              <name>RXDMAE</name>
              <bitRange>[0:0]</bitRange>
              <description>Enable DMA for SPI receive data. A single request will be generated if the receive FIFO is not empty and spi_cr1.SSE (module enable) is set. Burst request to the DMA controller will be generated if the receive FIFO contains at least 4 words (set DMA burst size to 4). If this bit is reset or the module is disabled, the DMA request signals will also be reset. Note: set dmac_chctrl.SBSize = 1 (i.e. burst size: 4) in the DMA controller. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'spi_data_register': 0xFF801130-->
          <name>spi_data_register</name>
          <description>netx100/500 compliant SPI data register (DR) Registers 0x30..0x3C can be used instead of registers 0x00...0x24 to keep netx50 software compliant to netx100/500. 2 data bytes with valid bits. During a write access data_byte_1 and dr_valid1 must not be used. dr_valid0 must be set. In netx50 and later versions both FIFOs (receive and transmit) have a depth of 16, fill values are fixed to 4. To keep software compatible, not more than 8 bytes should be in netx100/500 FIFOs. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000030</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0003FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:18]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>dr_valid1</name>
              <bitRange>[17:17]</bitRange>
              <description>Obsolete, always 0 </description>
            </field>
            <field>
              <name>dr_valid0</name>
              <bitRange>[16:16]</bitRange>
              <description>Valid bit for data_byte_0 This bit shows if data_byte_0 is valid and must be set during a FIFO write access. </description>
            </field>
            <field>
              <name>data_byte_1</name>
              <bitRange>[15:8]</bitRange>
              <description>Obsolete, don't use </description>
            </field>
            <field>
              <name>data_byte_0</name>
              <bitRange>[7:0]</bitRange>
              <description>Data byte 0 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'spi_status_register': 0xFF801134-->
          <name>spi_status_register</name>
          <description>netx100/500 compliant SPI status register (SR): Shows the actual status of the SPI interface. Bits 24..18 show occurred interrupts; writing ones into these bits clears the interrupts. Writing into other bits has no effect. In netx50 and later versions both FIFOs (receive and transmit) have a depth of 16, fill values are fixed to 4. To keep software compatible, not more than 8 bytes should be in netx100/500 FIFOs. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000034</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x03FFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:26]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>SR_selected</name>
              <bitRange>[25:25]</bitRange>
              <description>External master has access to SPI interface </description>
            </field>
            <field>
              <name>SR_out_full</name>
              <bitRange>[24:24]</bitRange>
              <description>Output FIFO is full. This is only with netx100/500 an IRQ. </description>
            </field>
            <field>
              <name>SR_out_empty</name>
              <bitRange>[23:23]</bitRange>
              <description>Output FIFO is empty in slave mode (equals spi_ris.txeris in netx50 and later versions) </description>
            </field>
            <field>
              <name>SR_out_fw</name>
              <bitRange>[22:22]</bitRange>
              <description>netX is writing data too fast into output FIFO. Available as an IRQ only on netx100/500 (equals spi_sr.tx_fifo_err_ovfl in netx50 and later versions). </description>
            </field>
            <field>
              <name>SR_out_fuel</name>
              <bitRange>[21:21]</bitRange>
              <description>Adjustable fill value of output FIFO reached (equals spi_ris.TXRIS in netx50 and later versions) </description>
            </field>
            <field>
              <name>SR_in_full</name>
              <bitRange>[20:20]</bitRange>
              <description>Input FIFO is full (equals spi_ris.rxfris in netx50 and later versions) </description>
            </field>
            <field>
              <name>SR_in_recdata</name>
              <bitRange>[19:19]</bitRange>
              <description>Valid data bytes in input FIFO (equals spi_ris.rxneris in netx50 and later versions) </description>
            </field>
            <field>
              <name>SR_in_fuel</name>
              <bitRange>[18:18]</bitRange>
              <description>Adjustable fill value of input FIFO reached (equals spi_ris.RXRIS in netx50 and later versions) </description>
            </field>
            <field>
              <name>SR_out_fuel_val</name>
              <bitRange>[17:9]</bitRange>
              <description>Output FIFO fill value (number of bytes) </description>
            </field>
            <field>
              <name>SR_in_fuel_val</name>
              <bitRange>[8:0]</bitRange>
              <description>Input FIFO fill value (number of bytes) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'spi_control_register': 0xFF801138-->
          <name>spi_control_register</name>
          <description>netx100/500 compliant SPI control register (CR) </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000038</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFF00FDF</resetMask>
          <fields>
            <field>
              <name>CR_en</name>
              <bitRange>[31:31]</bitRange>
              <description>1: enable 0: disable SPI interface </description>
            </field>
            <field>
              <name>CR_ms</name>
              <bitRange>[30:30]</bitRange>
              <description>1: master mode 0:slave mode </description>
            </field>
            <field>
              <name>CR_cpol</name>
              <bitRange>[29:29]</bitRange>
              <description>1: falling edge of SCK is primary 0: rising edge of SCK is primary </description>
            </field>
            <field>
              <name>CR_ncpha</name>
              <bitRange>[28:28]</bitRange>
              <description>SPI clock phase mode (Note: meaning of this bit is inverted to functionality of bit spi_cr0.SPH): {  | 0: change data on secondary SCK edge data is active on primary SCK edge 1: change data on primary SCK edge data is active on secondary SCK edge } </description>
            </field>
            <field>
              <name>CR_burst</name>
              <bitRange>[27:25]</bitRange>
              <description>netx100/netx500 only, obsolete in later versions: burst length = 2^CR_burst </description>
            </field>
            <field>
              <name>CR_burstdelay</name>
              <bitRange>[24:22]</bitRange>
              <description>netx100/netx500 only, obsolete in later versions: delay between transmission of 2 data bytes (0 to 7 SCK cycles) </description>
            </field>
            <field>
              <name>CR_clr_outfifo</name>
              <bitRange>[21:21]</bitRange>
              <description>Clear output FIFO </description>
            </field>
            <field>
              <name>CR_clr_infifo</name>
              <bitRange>[20:20]</bitRange>
              <description>Clear input FIFO </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[19:12]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>CS_mode</name>
              <bitRange>[11:11]</bitRange>
              <description>1: chip select is generated automatically by the internal state machine 0: chip select is directly controlled by software (see bits CR_ss). </description>
            </field>
            <field>
              <name>CR_ss</name>
              <bitRange>[10:8]</bitRange>
              <description>External slave select </description>
            </field>
            <field>
              <name>CR_write</name>
              <bitRange>[7:7]</bitRange>
              <description>netx100/netx500 only, in later versions always '1':  1: enable SPI interface write data </description>
            </field>
            <field>
              <name>CR_read</name>
              <bitRange>[6:6]</bitRange>
              <description>netx100/netx500 only, in later versions always '1':  1: enable SPI interface read data </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>CR_speed</name>
              <bitRange>[4:1]</bitRange>
              <description>Clock divider for SPI clock (2 - 2^16) If SPI clock rate is changed using spi_cr0.sck_muladd, this value will not be updated and may be incorrect There are 16 different SPI clocks frequencies to choose: 0000: 0.025 MHz (Note: Not compatible to netx100/500. '0000' freezes SCK in netx100/500.) 0001: 0.05 MHz 0010: 0.1 MHz 0011: 0.2 MHz 0100: 0.5 MHz 0101: 1 MHz 0110: 1.25 MHz 0111: 2 MHz 1000: 2.5 MHz 1001: 3.3333 MHz 1010: 5 MHz 1011: 10 MHz 1100: 12.5 MHz 1101: 16.6666 MHz 1110: 25 MHz 1111: 50 MHz </description>
            </field>
            <field>
              <name>CR_softreset</name>
              <bitRange>[0:0]</bitRange>
              <description>write only: no function in netx100/netx500; later versions: clears IRQs and FIFOs </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'spi_interrupt_control_register': 0xFF80113C-->
          <name>spi_interrupt_control_register</name>
          <description>netx100/500 compliant SPI interrupt control register (IR) In netx50 and later versions both FIFOs (receive and transmit) have a depth of 16, fill values are fixed to 4. To keep software compatible, not more than 8 bytes should be in netx100/500 FIFOs. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000003C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x01FFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:25]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>IR_out_full_en</name>
              <bitRange>[24:24]</bitRange>
              <description>IRQ enable for irq_spi(6), netx100/netx500 only, always '0' in later versions </description>
            </field>
            <field>
              <name>IR_out_empty_en</name>
              <bitRange>[23:23]</bitRange>
              <description>IRQ enable for irq_spi(5)  (equals spi_imsc.rxeim in netx50 and later versions) </description>
            </field>
            <field>
              <name>IR_out_fw_en</name>
              <bitRange>[22:22]</bitRange>
              <description>IRQ enable for irq_spi(4), netx100/netx500 only, always '0' in later versions </description>
            </field>
            <field>
              <name>IR_out_fuel_en</name>
              <bitRange>[21:21]</bitRange>
              <description>IRQ enable for irq_spi(3)  (equals spi_imsc.TXIM in netx50 and later versions) </description>
            </field>
            <field>
              <name>IR_in_full_en</name>
              <bitRange>[20:20]</bitRange>
              <description>IRQ enable for irq_spi(2)  (equals spi_imsc.txfim in netx50 and later versions) </description>
            </field>
            <field>
              <name>IR_in_recdata_en</name>
              <bitRange>[19:19]</bitRange>
              <description>IRQ enable for irq_spi(1)  (equals spi_imsc.txneim in netx50 and later versions) </description>
            </field>
            <field>
              <name>IR_in_fuel_en</name>
              <bitRange>[18:18]</bitRange>
              <description>IRQ enable for irq_spi(0)  (equals spi_imsc.RXIM in netx50 and later versions) </description>
            </field>
            <field>
              <name>IR_out_fuel</name>
              <bitRange>[17:9]</bitRange>
              <description>Adjustable watermark level of output FIFO </description>
            </field>
            <field>
              <name>IR_in_fuel</name>
              <bitRange>[8:0]</bitRange>
              <description>Adjustable watermark level of input FIFO </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>spi2_app</name>
      <description>spi2_app</description>
      <baseAddress>0xFF801140</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>64</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>spi2_app</name>
        <value>18</value>
      </interrupt>
      <registers>
        <register>
          <!--Absolute address of 'spi_cr0': 0xFF801140-->
          <name>spi_cr0</name>
          <description>SPI control register 0 Registers 0x30..0x3C can be used instead of registers 0x00...0x24 to keep netx50 software compliant to netx100/500. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80080007</resetValue>
          <resetMask>0x9B0FFFCF</resetMask>
          <fields>
            <field>
              <name>netx100_comp</name>
              <bitRange>[31:31]</bitRange>
              <description>Use netx100/500-compatible SPI mode: 0: start transfer after writing data 1: start transfer after setting CR_write or CR_read </description>
            </field>
            <field>
              <name>bf_align3</name>
              <bitRange>[30:29]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>slave_sig_early</name>
              <bitRange>[28:28]</bitRange>
              <description>Generate MISO in slave mode 1 SCK clock edge earlier than defined in the SPI specification. This is to compensate pad or sampling delays on fast data rates. However, hold timing problems could come up as MISO is generated very fast after the sampling SPI clock edge. If filter_in is enabled, it takes at least 3 system clocks to generate MISO after SCK. If filter_in is disabled, it takes at least 2 system clocks to generate MISO after SCK. </description>
            </field>
            <field>
              <name>filter_in</name>
              <bitRange>[27:27]</bitRange>
              <description>Receive data is sampled every 10ns (100MHz system clock). If this bit is set, the stored receive value will be the result of a majority decision of the three sampling points around a SPI-clock edge (if two or more '1s! were sampled a '1' will be stored, else a '0' will be stored. In slave mode chip-select and SCK edges will also be detected by oversampling if this bit is set: An edge will be detected if the majority-result of 3 subsequent sampled values toggles. Input filtering should be used for sck_muladd&lt;=0x200 (i.e. below 12.5MHz). Stable signal phases are too short with higher frequencies and input filtering cannot be used. </description>
            </field>
            <field>
              <name>bf_align2</name>
              <bitRange>[26:26]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>format</name>
              <bitRange>[25:24]</bitRange>
              <description>Frame format: 00:     Motorola SPI frame format 01..11: reserved </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[23:20]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sck_muladd</name>
              <bitRange>[19:8]</bitRange>
              <description>Serial clock rate multiply add value for master SCK generation. The SPI clock frequency is: f_spi_sck = (sck_muladd * 100)/4096 [MHz]. Default value 0x800 equals 50MHz SPI clock rate. All serial clock rates are derived from 100MHz netX system clock. Hence, all serial clock phases are multiples of 10ns. This leads to non-constant serial clock phases when a clock rate is programmed which cannot be generated by 100MHz/(2*n) without remainder. E.g. programming 0x4CC here will lead to a mean clock-rate of 30MHz. However, single clock high and low phases of 10ns and clock periods of 30ns will occur. This must be considered for serial device selection. E.g. using a 30MHz device which requires 33ns minimum clock period and a duty cycle of 50% will fail. Note: If sck_muladd is set to zero, SPI transfer will freeze. The SPI clock must not exceed (system frequency/4) in slave mode, if correct data sampling should always be guaranteed. Note: The value programmed here has no impact in slave mode. </description>
            </field>
            <field>
              <name>SPH</name>
              <bitRange>[7:7]</bitRange>
              <description>Serial clock phase (netx500: CR_ncpha): 1: sample data at second clock edge, data is generated half a clock phase before sampling 0: sample data at first clock edge, data is generated half a clock phase before sampling </description>
            </field>
            <field>
              <name>SPO</name>
              <bitRange>[6:6]</bitRange>
              <description>Serial clock polarity (netx500: CR_cpol): 0: idle: clock is low, first edge is rising 1: idle: clock is high, first edge is falling </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[5:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>datasize</name>
              <bitRange>[3:0]</bitRange>
              <description>DSS: data size select (transfer size = datasize + 1 bits): {            | 0000...0010: reserved 0011:        4 bit 0100:        5 bit ... 0111:        8 bit ... 1111:        16 bit } Note: 16 bit TX-data-loss bug of netX50/netX5 is fixed since netX10. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'spi_cr1': 0xFF801144-->
          <name>spi_cr1</name>
          <description>SPI control register 1 Registers 0x30..0x3C can be used instead of registers 0x00...0x24 to keep netx50 software compliant to netx100/500. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x08080000</resetValue>
          <resetMask>0x1F1F0F0F</resetMask>
          <fields>
            <field>
              <name>bf_align3</name>
              <bitRange>[31:29]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>rx_fifo_clr</name>
              <bitRange>[28:28]</bitRange>
              <description>Writing '1' to this bit will clear the receive FIFOs. </description>
            </field>
            <field>
              <name>rx_fifo_wm</name>
              <bitRange>[27:24]</bitRange>
              <description>Receive FIFO watermark for IRQ generation </description>
            </field>
            <field>
              <name>bf_align2</name>
              <bitRange>[23:21]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>tx_fifo_clr</name>
              <bitRange>[20:20]</bitRange>
              <description>Writing '1' to this bit will clear the transmit FIFOs. Note: There must be at least 1 system clock idle after clear before writing new data to the FIFO. This is guaranteed by the netX internal bus structure and needs not being considered by software. </description>
            </field>
            <field>
              <name>tx_fifo_wm</name>
              <bitRange>[19:16]</bitRange>
              <description>Transmit FIFO watermark for IRQ generation </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[15:12]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>fss_static</name>
              <bitRange>[11:11]</bitRange>
              <description>SPI static chip-select: {  | 0: SPI chip-select will be toggled automatically before and after each transferred word according to fss and datasize. 1: SPI chip-select will be set statically according to the fss bits. } </description>
            </field>
            <field>
              <name>fss</name>
              <bitRange>[10:8]</bitRange>
              <description>Frame or slave select. There are up to 3 external SPI chip-select signals. In master mode, the fss bits define the states of the chip-select signals. The inversion for low-active chip-selects (e.g. for Motorola SPI frame format) is done automatically depending on the value programmed to the 'format' bits. Example: To use the netX IO CS1 as chip-select, program '010' here, regardless whether the external chip-select is low or high active. In slave mode, the fss bits are a mask to select which netX input should be used as chip-select. Example: To use the netX IO CS0 as chip-select, program '001' here. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[7:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>SOD</name>
              <bitRange>[3:3]</bitRange>
              <description>Slave mode output disable (to connect multiple slaves to one master): 0: MISO can be driven in slave mode 1: MISO is not driven in slave mode </description>
            </field>
            <field>
              <name>MS</name>
              <bitRange>[2:2]</bitRange>
              <description>Mode select: 0: Module is configured as master 1: Module is configured as slave </description>
            </field>
            <field>
              <name>SSE</name>
              <bitRange>[1:1]</bitRange>
              <description>SPI enable: 0: Module disabled 1: Module enabled </description>
            </field>
            <field>
              <name>LBM</name>
              <bitRange>[0:0]</bitRange>
              <description>Loop back mode: 0: Internal loop back disabled 1: Internal loop back enabled, spi_cr0.filter_in must be set for loopback function </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'spi_dr': 0xFF801148-->
          <name>spi_dr</name>
          <description>SPI data register Registers 0x30..0x3C can be used instead of registers 0x00...0x24 to keep netx50 software compliant to netx100/500. The SPI module has 2 FIFOs: One for transmit data and one for receive data. Read access: Received data byte is delivered from receive FIFO. Write access: Transmit data byte is written to send FIFO. Both FIFOs (receive and transmit) have a depth of 16. SPI master mode: MISO input data will be stored in the receive FIFO; transmit FIFO generates MOSI output data. SPI slave mode: MOSI input data will be stored in the receive FIFO; transmit FIFO generates MISO output data. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0001FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:17]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>data</name>
              <bitRange>[16:0]</bitRange>
              <description>Transmit data: Only lowest bits according to spi_cr0.datasize will be sent. Receive data will be delivered on the lowest bits, unused bits (above spi_cr0.datasize) will be '0'. In slave mode transmit data is requested from the FIFO when the last bit of the currently transferred word is set to the MISO signal. If no next transmit data can be read from the FIFO until the current word's last bit was transferred, a FIFO underrun will occur in case chip-select does not go inactive at the next detected SCK edge. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'spi_sr': 0xFF80114C-->
          <name>spi_sr</name>
          <description>SPI status register Registers 0x30..0x3C can be used instead of registers 0x00...0x24 to keep netx50 software compliant to netx100/500. Note: Both FIFOs (receive and transmit) have a depth of 16. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xDFDF001F</resetMask>
          <fields>
            <field>
              <name>rx_fifo_err_undr</name>
              <bitRange>[31:31]</bitRange>
              <description>Receive FIFO underrun error occurred, data is lost </description>
            </field>
            <field>
              <name>rx_fifo_err_ovfl</name>
              <bitRange>[30:30]</bitRange>
              <description>Receive FIFO overflow error occurred, data is lost </description>
            </field>
            <field>
              <name>bf_align2</name>
              <bitRange>[29:29]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>rx_fifo_level</name>
              <bitRange>[28:24]</bitRange>
              <description>Receive FIFO level (number of received words to read out are left in FIFO) </description>
            </field>
            <field>
              <name>tx_fifo_err_undr</name>
              <bitRange>[23:23]</bitRange>
              <description>Transmit FIFO underrun error occurred, data is lost </description>
            </field>
            <field>
              <name>tx_fifo_err_ovfl</name>
              <bitRange>[22:22]</bitRange>
              <description>Transmit FIFO overflow error occurred, data is lost </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[21:21]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>tx_fifo_level</name>
              <bitRange>[20:16]</bitRange>
              <description>Transmit FIFO level (number of words to transmit are left in FIFO) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[15:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>BSY</name>
              <bitRange>[4:4]</bitRange>
              <description>Device busy (1 if data is currently transmitted/received or the transmit FIFO is not empty) </description>
            </field>
            <field>
              <name>RFF</name>
              <bitRange>[3:3]</bitRange>
              <description>Receive FIFO is full (1 if full) </description>
            </field>
            <field>
              <name>RNE</name>
              <bitRange>[2:2]</bitRange>
              <description>Receive FIFO is not empty (0 if empty) </description>
            </field>
            <field>
              <name>TNF</name>
              <bitRange>[1:1]</bitRange>
              <description>Transmit FIFO is not full (0 if full) </description>
            </field>
            <field>
              <name>TFE</name>
              <bitRange>[0:0]</bitRange>
              <description>Transmit FIFO is empty (1 if empty) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'spi_imsc': 0xFF801154-->
          <name>spi_imsc</name>
          <description>SPI Interrupt Mask Set and Clear register: Registers 0x30..0x3C can be used instead of registers 0x00...0x24 to keep netx50 software compliant to netx100/500. IRQ mask is an AND-mask: only raw interrupts with mask bit set can generate a module IRQ. When writing this register, the corresponding interrupt is cleared similar to writing the register spi_icr.  Note: The functionality of this register is similar to the corresponding SQI register sqi_irq_mask.       However, in contrast to this register, setting bits in sqi_irq_mask does not clear the corresponding interrupts.  Note: Both FIFOs (receive and transmit) have a depth of 16. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000007F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>txeim</name>
              <bitRange>[6:6]</bitRange>
              <description>Transmit FIFO empty interrupt mask (for netx100/500 compliance) </description>
            </field>
            <field>
              <name>rxfim</name>
              <bitRange>[5:5]</bitRange>
              <description>Receive FIFO full interrupt mask (for netx100/500 compliance) </description>
            </field>
            <field>
              <name>rxneim</name>
              <bitRange>[4:4]</bitRange>
              <description>Receive FIFO not empty interrupt mask (for netx100/500 compliance) </description>
            </field>
            <field>
              <name>TXIM</name>
              <bitRange>[3:3]</bitRange>
              <description>Transmit FIFO interrupt mask </description>
            </field>
            <field>
              <name>RXIM</name>
              <bitRange>[2:2]</bitRange>
              <description>Receive FIFO interrupt mask </description>
            </field>
            <field>
              <name>RTIM</name>
              <bitRange>[1:1]</bitRange>
              <description>Receive timeout interrupt mask </description>
            </field>
            <field>
              <name>RORIM</name>
              <bitRange>[0:0]</bitRange>
              <description>Receive FIFO overrun interrupt mask </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'spi_ris': 0xFF801158-->
          <name>spi_ris</name>
          <description>SPI interrupt state before masking register (raw interrupt) Registers 0x30..0x3C can be used instead of registers 0x00...0x24 to keep netx50 software compliant to netx100/500. Note: Both FIFOs (receive and transmit) have a depth of 16. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000018</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000007F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>txeris</name>
              <bitRange>[6:6]</bitRange>
              <description>Unmasked transmit FIFO empty interrupt state (for netx100/500 compliance) 1: transmit FIFO is empty 0: transmit FIFO is not empty </description>
            </field>
            <field>
              <name>rxfris</name>
              <bitRange>[5:5]</bitRange>
              <description>Unmasked receive FIFO full interrupt state (for netx100/500 compliance) 1: receive FIFO is full 0: receive FIFO is not full </description>
            </field>
            <field>
              <name>rxneris</name>
              <bitRange>[4:4]</bitRange>
              <description>Unmasked receive FIFO not empty interrupt state (for netx100/500 compliance) 1: receive FIFO is not empty 0: receive FIFO is empty </description>
            </field>
            <field>
              <name>TXRIS</name>
              <bitRange>[3:3]</bitRange>
              <description>Unmasked transmit FIFO interrupt state 1: transmit FIFO level is below spi_cr1.tx_fifo_wm 0: transmit FIFO equals or is higher than spi_cr1.tx_fifo_wm </description>
            </field>
            <field>
              <name>RXRIS</name>
              <bitRange>[2:2]</bitRange>
              <description>Unmasked receive FIFO interrupt state 1: receive FIFO is higher than spi_cr1.rx_fifo_wm 0: receive FIFO is equals or is below spi_cr1.rx_fifo_wm </description>
            </field>
            <field>
              <name>RTRIS</name>
              <bitRange>[1:1]</bitRange>
              <description>Unmasked receive timeout interrupt state Timeout period are 32 SPI clock periods depending on adr_spi_cr0.sck_muladd 1: receive FIFO is not empty and not read out in the passed timeout period 0: receive FIFO is empty or read during the last timeout period </description>
            </field>
            <field>
              <name>RORRIS</name>
              <bitRange>[0:0]</bitRange>
              <description>Unmasked receive FIFO overrun interrupt state 1: receive FIFO overrun error occurred 0: no receive FIFO overrun error occurred </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'spi_mis': 0xFF80115C-->
          <name>spi_mis</name>
          <description>SPI interrupt status register Registers 0x30..0x3C can be used instead of registers 0x00...0x24 to keep netx50 software compliant to netx100/500. Note: Both FIFOs (receive and transmit) have a depth of 16. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000001C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000007F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>txemis</name>
              <bitRange>[6:6]</bitRange>
              <description>Masked transmit FIFO empty interrupt state (for netx100/500 compliance) </description>
            </field>
            <field>
              <name>rxfmis</name>
              <bitRange>[5:5]</bitRange>
              <description>Masked receive FIFO full interrupt state (for netx100/500 compliance) </description>
            </field>
            <field>
              <name>rxnemis</name>
              <bitRange>[4:4]</bitRange>
              <description>Masked receive FIFO not empty interrupt state (for netx100/500 compliance) </description>
            </field>
            <field>
              <name>TXMIS</name>
              <bitRange>[3:3]</bitRange>
              <description>Masked transmit FIFO interrupt state </description>
            </field>
            <field>
              <name>RXMIS</name>
              <bitRange>[2:2]</bitRange>
              <description>Masked receive FIFO interrupt state </description>
            </field>
            <field>
              <name>RTMIS</name>
              <bitRange>[1:1]</bitRange>
              <description>Masked receive timeout interrupt state </description>
            </field>
            <field>
              <name>RORMIS</name>
              <bitRange>[0:0]</bitRange>
              <description>Masked receive FIFO overrun interrupt state </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'spi_icr': 0xFF801160-->
          <name>spi_icr</name>
          <description>SPI interrupt clear register Registers 0x30..0x3C can be used instead of registers 0x00...0x24 to keep netx50 software compliant to netx100/500. An interrupt is cleared by writing '1' to the according bit. Note: Both FIFOs (receive and transmit) have a depth of 16. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000007F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>txeic</name>
              <bitRange>[6:6]</bitRange>
              <description>Clear transmit FIFO empty interrupt (for netx100/500 compliance) </description>
            </field>
            <field>
              <name>rxfic</name>
              <bitRange>[5:5]</bitRange>
              <description>Clear receive FIFO full interrupt (for netx100/500 compliance) </description>
            </field>
            <field>
              <name>rxneic</name>
              <bitRange>[4:4]</bitRange>
              <description>Clear receive FIFO not empty interrupt (for netx100/500 compliance) </description>
            </field>
            <field>
              <name>TXIC</name>
              <bitRange>[3:3]</bitRange>
              <description>PL022 extension: clear transmit FIFO interrupt </description>
            </field>
            <field>
              <name>RXIC</name>
              <bitRange>[2:2]</bitRange>
              <description>PL022 extension: clear receive FIFO interrupt </description>
            </field>
            <field>
              <name>RTIC</name>
              <bitRange>[1:1]</bitRange>
              <description>Clear receive FIFO overrun interrupt </description>
            </field>
            <field>
              <name>RORIC</name>
              <bitRange>[0:0]</bitRange>
              <description>Clear receive FIFO overrun interrupt Writing '1' here will clear the receive FIFO </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'spi_dmacr': 0xFF801168-->
          <name>spi_dmacr</name>
          <description>SPI DMA control register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000028</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:2]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>TXDMAE</name>
              <bitRange>[1:1]</bitRange>
              <description>Enable DMA for SPI transmit data. A single request will be generated if the transmit FIFO is not full and spi_cr1.SSE (module enable) is set. Burst requests to the DMA controller will be generated if at least 4 words are writable to the transmit FIFO (set DMA burst size to 4). If this bit is reset or the module is disabled, the DMA request signals will also be reset. Note: set dmac_chctrl.SBSize = 1 (i.e. burst size: 4) in the DMA controller. </description>
            </field>
            <field>
              <name>RXDMAE</name>
              <bitRange>[0:0]</bitRange>
              <description>Enable DMA for SPI receive data. A single request will be generated if the receive FIFO is not empty and spi_cr1.SSE (module enable) is set. Burst request to the DMA controller will be generated if the receive FIFO contains at least 4 words (set DMA burst size to 4). If this bit is reset or the module is disabled, the DMA request signals will also be reset. Note: set dmac_chctrl.SBSize = 1 (i.e. burst size: 4) in the DMA controller. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'spi_data_register': 0xFF801170-->
          <name>spi_data_register</name>
          <description>netx100/500 compliant SPI data register (DR) Registers 0x30..0x3C can be used instead of registers 0x00...0x24 to keep netx50 software compliant to netx100/500. 2 data bytes with valid bits. During a write access data_byte_1 and dr_valid1 must not be used. dr_valid0 must be set. In netx50 and later versions both FIFOs (receive and transmit) have a depth of 16, fill values are fixed to 4. To keep software compatible, not more than 8 bytes should be in netx100/500 FIFOs. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000030</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0003FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:18]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>dr_valid1</name>
              <bitRange>[17:17]</bitRange>
              <description>Obsolete, always 0 </description>
            </field>
            <field>
              <name>dr_valid0</name>
              <bitRange>[16:16]</bitRange>
              <description>Valid bit for data_byte_0 This bit shows if data_byte_0 is valid and must be set during a FIFO write access. </description>
            </field>
            <field>
              <name>data_byte_1</name>
              <bitRange>[15:8]</bitRange>
              <description>Obsolete, don't use </description>
            </field>
            <field>
              <name>data_byte_0</name>
              <bitRange>[7:0]</bitRange>
              <description>Data byte 0 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'spi_status_register': 0xFF801174-->
          <name>spi_status_register</name>
          <description>netx100/500 compliant SPI status register (SR): Shows the actual status of the SPI interface. Bits 24..18 show occurred interrupts; writing ones into these bits clears the interrupts. Writing into other bits has no effect. In netx50 and later versions both FIFOs (receive and transmit) have a depth of 16, fill values are fixed to 4. To keep software compatible, not more than 8 bytes should be in netx100/500 FIFOs. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000034</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x03FFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:26]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>SR_selected</name>
              <bitRange>[25:25]</bitRange>
              <description>External master has access to SPI interface </description>
            </field>
            <field>
              <name>SR_out_full</name>
              <bitRange>[24:24]</bitRange>
              <description>Output FIFO is full. This is only with netx100/500 an IRQ. </description>
            </field>
            <field>
              <name>SR_out_empty</name>
              <bitRange>[23:23]</bitRange>
              <description>Output FIFO is empty in slave mode (equals spi_ris.txeris in netx50 and later versions) </description>
            </field>
            <field>
              <name>SR_out_fw</name>
              <bitRange>[22:22]</bitRange>
              <description>netX is writing data too fast into output FIFO. Available as an IRQ only on netx100/500 (equals spi_sr.tx_fifo_err_ovfl in netx50 and later versions). </description>
            </field>
            <field>
              <name>SR_out_fuel</name>
              <bitRange>[21:21]</bitRange>
              <description>Adjustable fill value of output FIFO reached (equals spi_ris.TXRIS in netx50 and later versions) </description>
            </field>
            <field>
              <name>SR_in_full</name>
              <bitRange>[20:20]</bitRange>
              <description>Input FIFO is full (equals spi_ris.rxfris in netx50 and later versions) </description>
            </field>
            <field>
              <name>SR_in_recdata</name>
              <bitRange>[19:19]</bitRange>
              <description>Valid data bytes in input FIFO (equals spi_ris.rxneris in netx50 and later versions) </description>
            </field>
            <field>
              <name>SR_in_fuel</name>
              <bitRange>[18:18]</bitRange>
              <description>Adjustable fill value of input FIFO reached (equals spi_ris.RXRIS in netx50 and later versions) </description>
            </field>
            <field>
              <name>SR_out_fuel_val</name>
              <bitRange>[17:9]</bitRange>
              <description>Output FIFO fill value (number of bytes) </description>
            </field>
            <field>
              <name>SR_in_fuel_val</name>
              <bitRange>[8:0]</bitRange>
              <description>Input FIFO fill value (number of bytes) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'spi_control_register': 0xFF801178-->
          <name>spi_control_register</name>
          <description>netx100/500 compliant SPI control register (CR) </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000038</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFF00FDF</resetMask>
          <fields>
            <field>
              <name>CR_en</name>
              <bitRange>[31:31]</bitRange>
              <description>1: enable 0: disable SPI interface </description>
            </field>
            <field>
              <name>CR_ms</name>
              <bitRange>[30:30]</bitRange>
              <description>1: master mode 0:slave mode </description>
            </field>
            <field>
              <name>CR_cpol</name>
              <bitRange>[29:29]</bitRange>
              <description>1: falling edge of SCK is primary 0: rising edge of SCK is primary </description>
            </field>
            <field>
              <name>CR_ncpha</name>
              <bitRange>[28:28]</bitRange>
              <description>SPI clock phase mode (Note: meaning of this bit is inverted to functionality of bit spi_cr0.SPH): {  | 0: change data on secondary SCK edge data is active on primary SCK edge 1: change data on primary SCK edge data is active on secondary SCK edge } </description>
            </field>
            <field>
              <name>CR_burst</name>
              <bitRange>[27:25]</bitRange>
              <description>netx100/netx500 only, obsolete in later versions: burst length = 2^CR_burst </description>
            </field>
            <field>
              <name>CR_burstdelay</name>
              <bitRange>[24:22]</bitRange>
              <description>netx100/netx500 only, obsolete in later versions: delay between transmission of 2 data bytes (0 to 7 SCK cycles) </description>
            </field>
            <field>
              <name>CR_clr_outfifo</name>
              <bitRange>[21:21]</bitRange>
              <description>Clear output FIFO </description>
            </field>
            <field>
              <name>CR_clr_infifo</name>
              <bitRange>[20:20]</bitRange>
              <description>Clear input FIFO </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[19:12]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>CS_mode</name>
              <bitRange>[11:11]</bitRange>
              <description>1: chip select is generated automatically by the internal state machine 0: chip select is directly controlled by software (see bits CR_ss). </description>
            </field>
            <field>
              <name>CR_ss</name>
              <bitRange>[10:8]</bitRange>
              <description>External slave select </description>
            </field>
            <field>
              <name>CR_write</name>
              <bitRange>[7:7]</bitRange>
              <description>netx100/netx500 only, in later versions always '1':  1: enable SPI interface write data </description>
            </field>
            <field>
              <name>CR_read</name>
              <bitRange>[6:6]</bitRange>
              <description>netx100/netx500 only, in later versions always '1':  1: enable SPI interface read data </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>CR_speed</name>
              <bitRange>[4:1]</bitRange>
              <description>Clock divider for SPI clock (2 - 2^16) If SPI clock rate is changed using spi_cr0.sck_muladd, this value will not be updated and may be incorrect There are 16 different SPI clocks frequencies to choose: 0000: 0.025 MHz (Note: Not compatible to netx100/500. '0000' freezes SCK in netx100/500.) 0001: 0.05 MHz 0010: 0.1 MHz 0011: 0.2 MHz 0100: 0.5 MHz 0101: 1 MHz 0110: 1.25 MHz 0111: 2 MHz 1000: 2.5 MHz 1001: 3.3333 MHz 1010: 5 MHz 1011: 10 MHz 1100: 12.5 MHz 1101: 16.6666 MHz 1110: 25 MHz 1111: 50 MHz </description>
            </field>
            <field>
              <name>CR_softreset</name>
              <bitRange>[0:0]</bitRange>
              <description>write only: no function in netx100/netx500; later versions: clears IRQs and FIFOs </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'spi_interrupt_control_register': 0xFF80117C-->
          <name>spi_interrupt_control_register</name>
          <description>netx100/500 compliant SPI interrupt control register (IR) In netx50 and later versions both FIFOs (receive and transmit) have a depth of 16, fill values are fixed to 4. To keep software compatible, not more than 8 bytes should be in netx100/500 FIFOs. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000003C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x01FFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:25]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>IR_out_full_en</name>
              <bitRange>[24:24]</bitRange>
              <description>IRQ enable for irq_spi(6), netx100/netx500 only, always '0' in later versions </description>
            </field>
            <field>
              <name>IR_out_empty_en</name>
              <bitRange>[23:23]</bitRange>
              <description>IRQ enable for irq_spi(5)  (equals spi_imsc.rxeim in netx50 and later versions) </description>
            </field>
            <field>
              <name>IR_out_fw_en</name>
              <bitRange>[22:22]</bitRange>
              <description>IRQ enable for irq_spi(4), netx100/netx500 only, always '0' in later versions </description>
            </field>
            <field>
              <name>IR_out_fuel_en</name>
              <bitRange>[21:21]</bitRange>
              <description>IRQ enable for irq_spi(3)  (equals spi_imsc.TXIM in netx50 and later versions) </description>
            </field>
            <field>
              <name>IR_in_full_en</name>
              <bitRange>[20:20]</bitRange>
              <description>IRQ enable for irq_spi(2)  (equals spi_imsc.txfim in netx50 and later versions) </description>
            </field>
            <field>
              <name>IR_in_recdata_en</name>
              <bitRange>[19:19]</bitRange>
              <description>IRQ enable for irq_spi(1)  (equals spi_imsc.txneim in netx50 and later versions) </description>
            </field>
            <field>
              <name>IR_in_fuel_en</name>
              <bitRange>[18:18]</bitRange>
              <description>IRQ enable for irq_spi(0)  (equals spi_imsc.RXIM in netx50 and later versions) </description>
            </field>
            <field>
              <name>IR_out_fuel</name>
              <bitRange>[17:9]</bitRange>
              <description>Adjustable watermark level of output FIFO </description>
            </field>
            <field>
              <name>IR_in_fuel</name>
              <bitRange>[8:0]</bitRange>
              <description>Adjustable watermark level of input FIFO </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>sqi0_app</name>
      <description>sqi0_app</description>
      <baseAddress>0xFF801180</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>64</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>sqi0_app</name>
        <value>73</value>
      </interrupt>
      <registers>
        <register>
          <!--Absolute address of 'sqi_cr0': 0xFF801180-->
          <name>sqi_cr0</name>
          <description>SQI control register 0 This register is compatible with the netX50 and netX10 SPI module, but some additional settings are possible. The SQI module   provides master function only. Slave settings are omitted. The SQI module does not support the compatible mode for netX100. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00080007</resetValue>
          <resetMask>0x08CFFFCF</resetMask>
          <fields>
            <field>
              <name>bf_align3</name>
              <bitRange>[31:28]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>filter_in</name>
              <bitRange>[27:27]</bitRange>
              <description>Input filtering Receive data is sampled every 10 ns (100 MHz system clock). If this bit is set, the stored receive value will be the result of a majority decision of the three sampling points around an sck clock edge (if two or more '1's have been sampled, a '1' will be stored. If this bit is not set, a '0' will be stored). Input filtering should be used for sck_muladd&lt;=0x200 (i.e. below 12.5 MHz). For higher frequencies, stable signal phases are too short for filtering. </description>
            </field>
            <field>
              <name>bf_align2</name>
              <bitRange>[26:24]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sio_cfg</name>
              <bitRange>[23:22]</bitRange>
              <description>SQI IO configuration Default: All additional SQI-IOs (SIO2+3) are in PIO input mode. Coding 00: only SIO2+3 are controllable as PIOs (2-bit SPI or standard Motorola SPI) 01: all SQI IOs are used for transfers (4-bit SPI/SQI) 10: reserved 11: all SQI IOs are controllable as PIOs </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[21:20]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sck_muladd</name>
              <bitRange>[19:8]</bitRange>
              <description>Serial clock rate multiply add value for sck generation sck-frequency: f_sck = (sck_muladd * 100)/4096 [MHz]. Programmed value of sck_muladd must be &lt;= 0x800. Default value 0x800 equals 50 MHz clock rate. Note: If sck_muladd is set to zero, transfer will freeze. Note: SQIROM (XiP) serial clock rate must be programmed in register 'sqi_sqirom_cfg'. </description>
            </field>
            <field>
              <name>sck_phase</name>
              <bitRange>[7:7]</bitRange>
              <description>Serial clock phase 1: Sample data at second clock edge, data is generated half a clock phase before sampling 0: Sample data at first clock edge, data is generated half a clock phase before sampling Note: sck_phase value equals bit 0 of SPI mode value (mode = (sck_pol, sck_phase)). </description>
            </field>
            <field>
              <name>sck_pol</name>
              <bitRange>[6:6]</bitRange>
              <description>Serial clock polarity 0: idle: clock is low, first edge is rising 1: idle: clock is high, first edge is falling Note: sck_pol value equals bit 1 of SPI mode value (mode = (sck_pol, sck_phase)). </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[5:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>datasize</name>
              <bitRange>[3:0]</bitRange>
              <description>Data size select for standard Motorola SPI mode This bit field is unused in 2-bit and 4-bit SPI modes (i.e. data size fixed to 8 bit). The actual transfer size is 'datasize' + 1 bit. {            | 0000...0010: reserved 0011:        4 bit 0100:        5 bit ... 0111:        8 bit ... 1111:        16 bit } </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'sqi_cr1': 0xFF801184-->
          <name>sqi_cr1</name>
          <description>SQI control register 1 This register is compatible with the netX50 and netX10 SPI module, but some additional settings are possible. The SQI module   provides master function only. Slave settings are omitted. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x08080000</resetValue>
          <resetMask>0x1F1F1F02</resetMask>
          <fields>
            <field>
              <name>bf_align4</name>
              <bitRange>[31:29]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>rx_fifo_clr</name>
              <bitRange>[28:28]</bitRange>
              <description>Receive FIFO clear Writing '1' to this bit will clear the receive FIFO. The hardware will automatically reset this bit. This bit is always '0' when read. </description>
            </field>
            <field>
              <name>rx_fifo_wm</name>
              <bitRange>[27:24]</bitRange>
              <description>Receive FIFO watermark for IRQ generation If the receive FIFO watermark IRQ is enabled (bit 'RXIM' is set in register 'sqi_irq_mask'), transfers will stop when the receive FIFO runs full. Transfers will continue after the receive data is read from the receive FIFO to avoid an overflow of the receive FIFO. If the receive FIFO watermark IRQ is disabled (bit 'RXIM' is not set in register 'sqi_irq_mask'), transfers will not stop when the receive FIFO runs full. This may cause an overflow of the receive FIFO. This is compatible with netX50 behavior and allows writing data in full-duplex mode without reading the receive FIFO. </description>
            </field>
            <field>
              <name>bf_align3</name>
              <bitRange>[23:21]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>tx_fifo_clr</name>
              <bitRange>[20:20]</bitRange>
              <description>Transmit FIFO clear Writing '1' to this bit will clear the transmit FIFO. The hardware will automatically reset this bit. This bit is always '0' when read. </description>
            </field>
            <field>
              <name>tx_fifo_wm</name>
              <bitRange>[19:16]</bitRange>
              <description>Transmit FIFO watermark for IRQ generation </description>
            </field>
            <field>
              <name>bf_align2</name>
              <bitRange>[15:13]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>spi_trans_ctrl</name>
              <bitRange>[12:12]</bitRange>
              <description>Transfer control for standard Motorola SPI (default: disabled) This bit is used only for standard Motorola SPI (bits 'mode' of register 'sqi_tcr') in full-duplex and half-duplex mode. If this bit is set, SPI transfers will be controlled by 'start_transfer' and 'transfer_size' of register 'sqi_tcr'. If this bit is not set (default), SPI transfers start immediately after transfer data has been written to TX FIFO (this is compatible with the SPI module). Settings of 'start_transfer' and 'transfer_size' of register 'sqi_tcr' then remain unaffected and will be ignored. If this bit is set and SPI is used in receive mode (full-duplex or half-duplex receive mode set by bit field 'duplex' in register 'sqi_tcr'), transfers will stop when the receive FIFO runs full. Transfers will continue after the receive data is read from the receive FIFO to avoid an overflow of the receive FIFO. </description>
            </field>
            <field>
              <name>fss_static</name>
              <bitRange>[11:11]</bitRange>
              <description>SQI static chip select 0: Chip select will be generated automatically at data frame begin/end according to fss and datasize. 1: Chip select will be set statically according to 'fss' bits (see below). If fss is set to static mode, fss must be toggled manually after each data frame in Motorola SPI mode when sck_phase is 0 for compatibility with the specification! Note: This bit is used only in standard Motorola SPI mode. For SQI modes, chip select is never generated automatically. </description>
            </field>
            <field>
              <name>fss</name>
              <bitRange>[10:8]</bitRange>
              <description>Frame slave select Up to 3 devices can be assigned directly. Up to 8 devices can be assigned if an external de-multiplexer is used. This signal is active low, i.e. the bits will be inverted before they are output to the SQI pins. </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[7:2]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sqi_en</name>
              <bitRange>[1:1]</bitRange>
              <description>SQI enable 0: Interface disabled 1: Interface enabled Note: If you select the SQIROM/XiP function by bit 'enable' of register 'sqi_sqirom_cfg' (see description of register 'sqi_sqirom_cfg'), the standard SQI/SPI function will not be available. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[0:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'sqi_dr': 0xFF801188-->
          <name>sqi_dr</name>
          <description>SQI data register (DR) Read access: Received data word is delivered from receive FIFO. Write access: Data word to be sent is written to send FIFO. Receive and transmit FIFO both have a depth of 16 words (standard SPI mode). The SQI mode combines both FIFOs, i.e. 64 bytes are   available. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>data</name>
              <bitRange>[31:0]</bitRange>
              <description>Transmit data The data must be right-aligned during writing. In Standard SPI mode only bits according to sqi_cr0.datasize are transferred. In SQI mode data must be written in full DWords (i.e. the software has to collect four bytes prior to writing). Unused bytes will not be transferred and may be padded at will (number of transferred bytes depends on sqi_tcr.transfer_size). Receive data will always be right-aligned; unused bits will be '0'. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'sqi_sr': 0xFF80118C-->
          <name>sqi_sr</name>
          <description>Read-only SQI status register Shows the current status of the SQI interface. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xDFDFE01F</resetMask>
          <fields>
            <field>
              <name>rx_fifo_err_undr</name>
              <bitRange>[31:31]</bitRange>
              <description>Receive FIFO underrun error has occurred, unexpected data has been read. To clear this status flag, clear RX FIFO (register 'sqi_cr1'). </description>
            </field>
            <field>
              <name>rx_fifo_err_ovfl</name>
              <bitRange>[30:30]</bitRange>
              <description>Receive FIFO overflow error occurred, data is lost. To clear this status flag, clear RX FIFO (register 'sqi_cr1'). </description>
            </field>
            <field>
              <name>bf_align2</name>
              <bitRange>[29:29]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>rx_fifo_level</name>
              <bitRange>[28:24]</bitRange>
              <description>Receive FIFO level (number of received words to be read from the FIFO). </description>
            </field>
            <field>
              <name>tx_fifo_err_undr</name>
              <bitRange>[23:23]</bitRange>
              <description>Transmit FIFO underrun error has occurred, unexpected data has been sent. To clear this status flag, clear TX FIFO (register 'sqi_cr1'). </description>
            </field>
            <field>
              <name>tx_fifo_err_ovfl</name>
              <bitRange>[22:22]</bitRange>
              <description>Transmit FIFO overflow error occurred, data is lost. To clear this status flag, clear TX FIFO (register 'sqi_cr1'). </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[21:21]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>tx_fifo_level</name>
              <bitRange>[20:16]</bitRange>
              <description>Transmit FIFO level (number of words to be transmitted are left in the FIFO). </description>
            </field>
            <field>
              <name>sqirom_disabled_err</name>
              <bitRange>[15:15]</bitRange>
              <description>Access to the disabled SQIROM area has occurred. To enable the SQIROM function, set bit 'enable' in register 'sqi_sqirom_cfg'. This bit can be used to determine why the IRQ 'sqirom_error' has occurred. Clearing this status flag is possible only by writing a '1' here. </description>
            </field>
            <field>
              <name>sqirom_write_err</name>
              <bitRange>[14:14]</bitRange>
              <description>Write access to the read-only SQIROM area has occurred. This bit can be used to determine why the IRQ 'sqirom_error' has occurred. Clearing this status flag is possible only by writing a '1' here. </description>
            </field>
            <field>
              <name>sqirom_timeout_err</name>
              <bitRange>[13:13]</bitRange>
              <description>Timeout during a read of the SQIROM area has occurred. A timeout results from a fix level of the netX serial clock IO. Check IO multiplexing configuration and make sure that the serial clock output is not externally clamped. This bit can be used to determine why the IRQ 'sqirom_error' has occurred. Clearing this status flag is possible only by writing a '1' here. The SQIROM function must be disabled and enabled again to reset module-internal state machines after this bit has been set (register 'sqirom_cfg', therefore reset and set again the 'enable' bit). </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[12:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>busy</name>
              <bitRange>[4:4]</bitRange>
              <description>Device is busy 1 if data is currently transmitted/received or the transmit FIFO is not empty. </description>
            </field>
            <field>
              <name>rx_fifo_full</name>
              <bitRange>[3:3]</bitRange>
              <description>Receive FIFO is full (1 if full). </description>
            </field>
            <field>
              <name>rx_fifo_not_empty</name>
              <bitRange>[2:2]</bitRange>
              <description>Receive FIFO is not empty (0 if empty). </description>
            </field>
            <field>
              <name>tx_fifo_not_full</name>
              <bitRange>[1:1]</bitRange>
              <description>Transmit FIFO is not full (0 if full). </description>
            </field>
            <field>
              <name>tx_fifo_empty</name>
              <bitRange>[0:0]</bitRange>
              <description>Transmit FIFO is empty (1 if empty). </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'sqi_tcr': 0xFF801190-->
          <name>sqi_tcr</name>
          <description>SQI transfer control This register must not be changed during a transfer (bit 'busy' of register 'sqi_sr' is '1') to avoid corrupted transfers causing   damage to the hardware. Module address offset 0x10 is reserved in the netX10/50 SPI module. Thus, no compatibility problems will result from using this   address for extended transfer control features. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1C000000</resetValue>
          <resetMask>0x3FE7FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:30]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ms_byte_first</name>
              <bitRange>[29:29]</bitRange>
              <description>Most significant byte first 2- and 4-bit mode: Writing '1' to this bit will use most significant byte first in DWords (big endian). Default is little endian In standard Motorola SPI mode this bit is ignored. </description>
            </field>
            <field>
              <name>ms_bit_first</name>
              <bitRange>[28:28]</bitRange>
              <description>Most significant bit first 2- and 4-bit mode: Writing '1' to this bit will transfer most significant bit first (default). In standard Motorola SPI mode this bit is ignored. </description>
            </field>
            <field>
              <name>duplex</name>
              <bitRange>[27:26]</bitRange>
              <description>Transfer type selection Default is '11' for standard SPI compatibility. 00: dummy Generates 'transfer_size' + 1 serial clock periods. No change of RX and TX FIFOs. Data lines (standard Motorola SPI mode: SPI_MOSI) are controlled by 'tx_oe' and 'tx_out'. 01: half-duplex receive Receives 'transfer_size' + 1 words. In 2-bit and 4-bit mode, TX-FIFO will be cleared and is not available during receive. In standard SPI mode, SPI_MOSI is controlled by 'tx_oe' and 'tx_out'. You need not fill the TX-FIFO with dummy TX-data to receive RX-data. TX FIFOs are not changed and always available. 10: half-duplex transmit Transmits 'transfer_size' + 1 words. In 2-bit and 4-bit mode, RX-FIFO will be cleared and is not available during transmit. In standard SPI mode, SPI_MISO input is ignored. RX-FIFO is available and remains unchanged. 11: full-duplex Standard Motorola SPI mode only, reserved in 2-bit and 4-bit modes. The full-duplex standard Motorola SPI mode always transmits and receives data. Transmit data is taken from TX-FIFO, receive data is stored in RX-FIFO. Note: If '11' is set in 2-bit or 4-bit mode, this is treated as 'receive' (like '01' setting). Note: In case of a FIFO error (overflow, underrun) before changing to '01' or '10', the FIFO error status bits in register 'sqi_sr' will not be cleared by half-duplex modes FIFO clearing. </description>
            </field>
            <field>
              <name>mode</name>
              <bitRange>[25:24]</bitRange>
              <description>SPI/SQI mode selection 00: Standard Motorola SPI mode. 01: 2-bit SPI mode 10: 4-bit SPI mode 11: reserved </description>
            </field>
            <field>
              <name>start_transfer</name>
              <bitRange>[23:23]</bitRange>
              <description>Transfer start signal Writing a '1' starts the transfer of transfer_size bytes or dummy cycles. The hardware will automatically reset this bit. This bit is always '0' when read. This bit is writable only after a transfer sequence is finished or if it has been terminated by a FIFO clear. Note: A transfer sequence is finished completely when 'busy' of register 'sqi_sr' is not set. Note: In standard Motorola SPI mode, this function can be controlled by bit 'spi_trans_ctrl' of register 'sqi_cr1' (for SPI module compatibility). </description>
            </field>
            <field>
              <name>tx_oe</name>
              <bitRange>[22:22]</bitRange>
              <description>Output driver enable in dummy or standard SPI receive-only mode Writing a '1' enables the output drivers of the data pins in the dummy mode. </description>
            </field>
            <field>
              <name>tx_out</name>
              <bitRange>[21:21]</bitRange>
              <description>Output level in dummy or standard SPI receive-only mode This bit selects the output level when the output driver is enabled in the dummy mode. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[20:19]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>transfer_size</name>
              <bitRange>[18:0]</bitRange>
              <description>Number of bytes within the current SQI transaction Program (number of bytes - 1) or (number of dummy clock cycles - 1). Example: {        | 0x00000: one byte/dummy cycle ... 0x7ffff: 512k bytes/dummy cycles } This bit field counts down during transfers with each transferred word/byte or dummy cycle. This bit field is writable only after a transfer sequence is finished or if it has been terminated by a FIFO clear. Hence, this bit is writable, but it can also be changed by hardware. A running transfer sequence can be terminated by clearing the FIFO (register 'sqi_cr1'). This may become necessary for terminating a read sequence. Example: A half-duplex write transfer of 128 kbytes has been programmed, but there is not enough write data. To terminate this write sequence, clear the TX FIFO. If an external transfer is running while the FIFO is being cleared, this transfer will be continued and finished with the last bit to be transferred. Note: A transfer sequence is finished completely when 'busy' of register 'sqi_sr' is not set. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'sqi_irq_mask': 0xFF801194-->
          <name>sqi_irq_mask</name>
          <description>SQI interrupt mask register: IRQ mask is an AND-mask: Only raw interrupts with mask bit set can generate a module IRQ to CPU.   For detailed IRQ behavior and function, see register 'sqi_irq_raw'. The functionality of this register is similar to that of the corresponding SPI register spi_imsc.   In contrast to this register, setting bits in spi_imsc also clears the corresponding raw interrupts. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000001FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:9]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sqirom_error</name>
              <bitRange>[8:8]</bitRange>
              <description>SQIROM error interrupt mask </description>
            </field>
            <field>
              <name>trans_end</name>
              <bitRange>[7:7]</bitRange>
              <description>Transfer end interrupt mask </description>
            </field>
            <field>
              <name>txeim</name>
              <bitRange>[6:6]</bitRange>
              <description>Transmit FIFO empty interrupt mask (for compatibility with netx100/500) </description>
            </field>
            <field>
              <name>rxfim</name>
              <bitRange>[5:5]</bitRange>
              <description>Receive FIFO full interrupt mask (for compatibility with netx100/500) </description>
            </field>
            <field>
              <name>rxneim</name>
              <bitRange>[4:4]</bitRange>
              <description>Receive FIFO not empty interrupt mask (for compatibility with netx100/500) </description>
            </field>
            <field>
              <name>TXIM</name>
              <bitRange>[3:3]</bitRange>
              <description>Transmit FIFO interrupt mask </description>
            </field>
            <field>
              <name>RXIM</name>
              <bitRange>[2:2]</bitRange>
              <description>Receive FIFO interrupt mask </description>
            </field>
            <field>
              <name>RTIM</name>
              <bitRange>[1:1]</bitRange>
              <description>Receive timeout interrupt mask </description>
            </field>
            <field>
              <name>RORIM</name>
              <bitRange>[0:0]</bitRange>
              <description>Receive FIFO overrun interrupt mask </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'sqi_irq_raw': 0xFF801198-->
          <name>sqi_irq_raw</name>
          <description>SQI interrupt state before masking register (raw interrupt). Writing a '1' to a bit clears this interrupt. IRQ flags can also be cleared by using 'sqi_irq_clear' for SPI module compatibility. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000018</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000008</resetValue>
          <resetMask>0x000001FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:9]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sqirom_error</name>
              <bitRange>[8:8]</bitRange>
              <description>Unmasked SQIROM error interrupt state 1: SQIROM access error detected. This IRQ will be set if an error occurs during an SQIROM access. For detailed information on the error, see SQIROM error bits in register 'sqi_sr'. For error handling, clear this IRQ bit and the bits of register 'sqi_sr'. 0: no SQIROM error detected. </description>
            </field>
            <field>
              <name>trans_end</name>
              <bitRange>[7:7]</bitRange>
              <description>Unmasked transfer end interrupt state (related to bit 'busy' of register 'sqi_sr') 1: transfer finished. Bit 'busy' of register 'sqi_sr' has become inactive. 0: transfer not finished. Bit 'busy' of register 'sqi_sr' is active. </description>
            </field>
            <field>
              <name>txeris</name>
              <bitRange>[6:6]</bitRange>
              <description>Unmasked transmit FIFO empty interrupt state (for compatibility with netx100/500) 1: transmit FIFO is empty 0: transmit FIFO is not empty </description>
            </field>
            <field>
              <name>rxfris</name>
              <bitRange>[5:5]</bitRange>
              <description>Unmasked receive FIFO full interrupt state (for compatibility with netx100/500) 1: receive FIFO is full 0: receive FIFO is not full </description>
            </field>
            <field>
              <name>rxneris</name>
              <bitRange>[4:4]</bitRange>
              <description>Unmasked receive FIFO not empty interrupt state (for compatibility with netx100/500) 1: receive FIFO is not empty 0: receive FIFO is empty </description>
            </field>
            <field>
              <name>TXRIS</name>
              <bitRange>[3:3]</bitRange>
              <description>Unmasked transmit FIFO interrupt state 1: transmit FIFO level is below sqi_cr1.tx_fifo_wm 0: transmit FIFO is equal or higher than sqi_cr1.tx_fifo_wm </description>
            </field>
            <field>
              <name>RXRIS</name>
              <bitRange>[2:2]</bitRange>
              <description>Unmasked receive FIFO interrupt state 1: receive FIFO is higher than sqi_cr1.rx_fifo_wm 0: receive FIFO is equal or below sqi_cr1.rx_fifo_wm Note: Before programming this IRQ, see description of bits 'spi_trans_ctrl' and 'rx_fifo_wm' of register 'sqi_cr1' for receive FIFO behavior. </description>
            </field>
            <field>
              <name>RTRIS</name>
              <bitRange>[1:1]</bitRange>
              <description>Unmasked receive timeout interrupt state Timeout period is 32 serial clock periods (depending on adr_sqi_cr0.sck_muladd). 1: receive FIFO is not empty and has not been read out during the timeout period 0: receive FIFO is empty or read during the last timeout period </description>
            </field>
            <field>
              <name>RORRIS</name>
              <bitRange>[0:0]</bitRange>
              <description>Unmasked receive FIFO overrun interrupt state 1: receive FIFO overrun error occurred 0: no receive FIFO overrun error occurred </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'sqi_irq_masked': 0xFF80119C-->
          <name>sqi_irq_masked</name>
          <description>SQI masked interrupt status register For detailed IRQ behavior and function, see register 'sqi_irq_raw'. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000001C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000001FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:9]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sqirom_error</name>
              <bitRange>[8:8]</bitRange>
              <description>Masked SQIROM error interrupt state </description>
            </field>
            <field>
              <name>trans_end</name>
              <bitRange>[7:7]</bitRange>
              <description>Masked transfer end interrupt state </description>
            </field>
            <field>
              <name>txemis</name>
              <bitRange>[6:6]</bitRange>
              <description>Masked transmit FIFO empty interrupt state (for compatibility with netx100/500) </description>
            </field>
            <field>
              <name>rxfmis</name>
              <bitRange>[5:5]</bitRange>
              <description>Masked receive FIFO full interrupt state (for compatibility with netx100/500) </description>
            </field>
            <field>
              <name>rxnemis</name>
              <bitRange>[4:4]</bitRange>
              <description>Masked receive FIFO not empty interrupt state (for compatibility with netx100/500) </description>
            </field>
            <field>
              <name>TXMIS</name>
              <bitRange>[3:3]</bitRange>
              <description>Masked transmit FIFO interrupt state </description>
            </field>
            <field>
              <name>RXMIS</name>
              <bitRange>[2:2]</bitRange>
              <description>Masked receive FIFO interrupt state </description>
            </field>
            <field>
              <name>RTMIS</name>
              <bitRange>[1:1]</bitRange>
              <description>Masked receive timeout interrupt state </description>
            </field>
            <field>
              <name>RORMIS</name>
              <bitRange>[0:0]</bitRange>
              <description>Masked receive FIFO overrun interrupt state </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'sqi_irq_clear': 0xFF8011A0-->
          <name>sqi_irq_clear</name>
          <description>SQI interrupt clear register (for compatibility with netX10/50 SPI module). This register is always '0' on read. IRQ flags can also be cleared by writing register 'sqi_irq_raw'. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000001FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:9]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sqirom_error</name>
              <bitRange>[8:8]</bitRange>
              <description>Clear SQIROM error interrupt </description>
            </field>
            <field>
              <name>trans_end</name>
              <bitRange>[7:7]</bitRange>
              <description>Clear transfer end interrupt </description>
            </field>
            <field>
              <name>txeic</name>
              <bitRange>[6:6]</bitRange>
              <description>Clear transmit FIFO empty interrupt (for compatibility with netx100/500) </description>
            </field>
            <field>
              <name>rxfic</name>
              <bitRange>[5:5]</bitRange>
              <description>Clear receive FIFO full interrupt (for compatibility with netx100/500) </description>
            </field>
            <field>
              <name>rxneic</name>
              <bitRange>[4:4]</bitRange>
              <description>Clear receive FIFO not empty interrupt (for compatibility with netx100/500) </description>
            </field>
            <field>
              <name>TXIC</name>
              <bitRange>[3:3]</bitRange>
              <description>Clear transmit FIFO interrupt </description>
            </field>
            <field>
              <name>RXIC</name>
              <bitRange>[2:2]</bitRange>
              <description>Clear receive FIFO interrupt </description>
            </field>
            <field>
              <name>RTIC</name>
              <bitRange>[1:1]</bitRange>
              <description>Clear receive timeout interrupt </description>
            </field>
            <field>
              <name>RORIC</name>
              <bitRange>[0:0]</bitRange>
              <description>Clear receive FIFO overrun interrupt </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'sqi_dmacr': 0xFF8011A4-->
          <name>sqi_dmacr</name>
          <description>SQI DMA control register This module generates normal transfer requests only (i.e. no last requests will be issued). In consequence,   you can use DMAC-controlled transfers only (no peripheral-controlled mode). </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000024</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:2]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>tx_dma_en</name>
              <bitRange>[1:1]</bitRange>
              <description>Enable DMA for SQI-transmit data A request will be generated if TX-FIFO is not full and sqi_cr1.sqi_en (module enable) is set. If at least 4 words are writable to the TX-FIFO, there will be a burst request to the DMAC. Set dmac_chctrl.DBSize = 1 (i.e. burst size: 4) in the DMAC module. If this bit is reset or the module is disabled, DMA request will also be reset. </description>
            </field>
            <field>
              <name>rx_dma_en</name>
              <bitRange>[0:0]</bitRange>
              <description>Enable DMA for SQI-receive data A request will be generated if RX-FIFO is not empty and sqi_cr1.sqi_en (module enable) is set. If the RX-FIFO contains at least 4 words, there will be a burst request to the DMAC. Set dmac_chctrl.SBSize = 1 (i.e. burst size: 4) in the DMAC module. If this bit is reset or the module is disabled, DMA request will also be reset. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'sqi_pio_out': 0xFF8011A8-->
          <name>sqi_pio_out</name>
          <description>SQI PIO output level control register Bits 'sio_cfg' of register 'sqi_cr0' control the IO PIO mode. Bit 'sqi_en' of register 'sqi_cr0' has to be set to drive the SQI IOs in the PIO mode. PIO input signal states are never filtered (bit 'filter_in' of register 'sqi_cr0'). </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000028</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000000E</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sio3</name>
              <bitRange>[7:7]</bitRange>
              <description>SIO3 output state </description>
            </field>
            <field>
              <name>sio2</name>
              <bitRange>[6:6]</bitRange>
              <description>SIO2 output state </description>
            </field>
            <field>
              <name>miso</name>
              <bitRange>[5:5]</bitRange>
              <description>MISO/SIO1 output state </description>
            </field>
            <field>
              <name>mosi</name>
              <bitRange>[4:4]</bitRange>
              <description>MOSI/SIO0 output state </description>
            </field>
            <field>
              <name>csn</name>
              <bitRange>[3:1]</bitRange>
              <description>Chip select/FSS output state {CS2, CS1, CS0} </description>
            </field>
            <field>
              <name>sclk</name>
              <bitRange>[0:0]</bitRange>
              <description>Serial SPI clock output state </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'sqi_pio_oe': 0xFF8011B0-->
          <name>sqi_pio_oe</name>
          <description>SQI PIO output enable control register Bits 'sio_cfg' of register 'sqi_cr0' control the IO PIO mode. Bit 'sqi_en' of register 'sqi_cr0' has to be set to drive the SQI IOs in the PIO mode. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000030</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sio3</name>
              <bitRange>[7:7]</bitRange>
              <description>SIO3 output enable </description>
            </field>
            <field>
              <name>sio2</name>
              <bitRange>[6:6]</bitRange>
              <description>SIO2 output enable </description>
            </field>
            <field>
              <name>miso</name>
              <bitRange>[5:5]</bitRange>
              <description>MISO/SIO1 output enable </description>
            </field>
            <field>
              <name>mosi</name>
              <bitRange>[4:4]</bitRange>
              <description>MOSI/SIO0 output enable </description>
            </field>
            <field>
              <name>csn</name>
              <bitRange>[3:1]</bitRange>
              <description>Chip select/FSS output enable {CS2, CS1, CS0} </description>
            </field>
            <field>
              <name>sclk</name>
              <bitRange>[0:0]</bitRange>
              <description>Serial SPI clock output enable </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'sqi_pio_in': 0xFF8011B4-->
          <name>sqi_pio_in</name>
          <description>SQI PIO input status register Bits 'sio_cfg' of register 'sqi_cr0' control the IO PIO mode. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000034</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sio3</name>
              <bitRange>[7:7]</bitRange>
              <description>SIO3 input state </description>
            </field>
            <field>
              <name>sio2</name>
              <bitRange>[6:6]</bitRange>
              <description>SIO2 input state </description>
            </field>
            <field>
              <name>miso</name>
              <bitRange>[5:5]</bitRange>
              <description>MISO/SIO1 input state </description>
            </field>
            <field>
              <name>mosi</name>
              <bitRange>[4:4]</bitRange>
              <description>MOSI/SIO0 input state </description>
            </field>
            <field>
              <name>csn</name>
              <bitRange>[3:1]</bitRange>
              <description>Chip select/FSS input state {CS2, CS1, CS0} </description>
            </field>
            <field>
              <name>sclk</name>
              <bitRange>[0:0]</bitRange>
              <description>Serial SPI clock input state </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'sqi_sqirom_cfg': 0xFF8011B8-->
          <name>sqi_sqirom_cfg</name>
          <description>SQIROM mode configuration This mode supports the 'eXecute in Place' (XiP) feature of SQI flash chips. This register serves to configure the position of command   byte and address nibbles as well as the number of address nibbles and dummy cycles. To support a wide range of frequencies for the   serial clock output, you can also change the clock divider. Notes: 1. Before enabling this mode, make sure that the SQI flash chip is in 4-bit command mode, otherwise the module is not able to fetch data   from the flash. 2. When enabled, the SQI module is completely blocked, i.e. other SQI or SPI transactions are not possible. 3. The chip select signal of the flash must be connected to sqi_cs0. 4. SQIROM transfers can be generated in SPI mode 0 or 3, which can be selected in register 'sqi_cr0'. DO NOT select mode 1 and 2   for SQIROM usage. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000038</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x02020004</resetValue>
          <resetMask>0xFF3FFF7F</resetMask>
          <fields>
            <field>
              <name>clk_div_val</name>
              <bitRange>[31:24]</bitRange>
              <description>clk400 will be divided by (clk_div_val+3) for sqirom_clk generation. Default setting '2' is 80 MHz. Maximum serial clock rate (programming '0') is 133 MHz. Serial clock period (t_sck) will be (clk_div_val+3) * 2.5 ns. Clock high and low phase will be generated symmetrically. </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[23:22]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>t_csh</name>
              <bitRange>[21:20]</bitRange>
              <description>Min. SQI chip select high (idle) time: (t_csh+1) * t_sck (according to clk_div_val). Programmable values are 0 to 3. Change this parameter if the SQI device used requires min. chip select high times exceeding 1 serial clock period. The data sheet of the SQI device used provides the required timing. Note: Serial clock will not toggle if the device is not selected. Hence, only chip select active timing has to be considered. </description>
            </field>
            <field>
              <name>dummy_cycles</name>
              <bitRange>[19:16]</bitRange>
              <description>Selects the number of dummy cycles before data will be sampled from the SQI chip. {     | 0000: 0 cycles 0001: 1 cycle 0010: 2 cycles (default) ... 1111: 15 cycles } </description>
            </field>
            <field>
              <name>cmd_byte</name>
              <bitRange>[15:8]</bitRange>
              <description>This byte is transferred to the SQI chip as the command sequence. Bit 'addr_before_cmd' controls the address command order. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[7:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>addr_bits</name>
              <bitRange>[6:4]</bitRange>
              <description>The number of address bits of the access address considered to generate the address for the SQI chip. This setting depends on the size of the SQI chip. {     | 000:  20 bits (1-MByte/8-MBit device) (default) 001:  21 bits (2-MByte/16-MBit device) 010:  22 bits (4-MByte/32-MBit device) 011:  23 bits (8-MByte/64-MBit device) 100:  24 bits (16-MByte/128-MBit device) 101:  25 bits (32-MByte/256-MBit device) 110:  26 bits (64-MByte/512-MBit device) 111:  reserved } </description>
            </field>
            <field>
              <name>addr_nibbles</name>
              <bitRange>[3:2]</bitRange>
              <description>The number of nibbles to be transferred as the address to the SQI chip. This setting depends on the command format of the SQI chip. Bit 'addr_before_cmd' controls the address command order. The most significant address bits will be transmitted in the first address nibble. The least significant address bits will be transmitted in the last address nibble. 00: 5 nibbles 01: 6 nibbles (default) 10: 7 nibbles 11: 8 nibbles </description>
            </field>
            <field>
              <name>addr_before_cmd</name>
              <bitRange>[1:1]</bitRange>
              <description>Address before command When set to '1', the address nibbles will be transferred before the command byte. Otherwise, the command will be transferred first (default). </description>
            </field>
            <field>
              <name>enable</name>
              <bitRange>[0:0]</bitRange>
              <description>Enables the SQIROM mode of the SQI module. The SQI chip needs to be initialized to accept 4-bit read-command before you activate the SQIROM mode. This bit is also used to switch between the SQIROM/XiP and the standard SQI/SPI function. If this bit is set, the standard SQI/SPI function is not available. The SQIROM/XiP function does not depend on the programmed value of bit 'sqi_en' of register 'sqi_cr1'. If the multiplex matrix provides the SQI function, it is available only in standard SQI/SPI, but not for SQIROM/XiP usage. The SQIROM/XiP function is provided only on dedicated SQI IOs, but not as a multiplex matrix function even if standard SQI/SPI is provided there. </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>sqi1_app</name>
      <description>sqi1_app</description>
      <baseAddress>0xFF8011C0</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>64</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>sqi1_app</name>
        <value>74</value>
      </interrupt>
      <registers>
        <register>
          <!--Absolute address of 'sqi_cr0': 0xFF8011C0-->
          <name>sqi_cr0</name>
          <description>SQI control register 0 This register is compatible with the netX50 and netX10 SPI module, but some additional settings are possible. The SQI module   provides master function only. Slave settings are omitted. The SQI module does not support the compatible mode for netX100. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00080007</resetValue>
          <resetMask>0x08CFFFCF</resetMask>
          <fields>
            <field>
              <name>bf_align3</name>
              <bitRange>[31:28]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>filter_in</name>
              <bitRange>[27:27]</bitRange>
              <description>Input filtering Receive data is sampled every 10 ns (100 MHz system clock). If this bit is set, the stored receive value will be the result of a majority decision of the three sampling points around an sck clock edge (if two or more '1's have been sampled, a '1' will be stored. If this bit is not set, a '0' will be stored). Input filtering should be used for sck_muladd&lt;=0x200 (i.e. below 12.5 MHz). For higher frequencies, stable signal phases are too short for filtering. </description>
            </field>
            <field>
              <name>bf_align2</name>
              <bitRange>[26:24]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sio_cfg</name>
              <bitRange>[23:22]</bitRange>
              <description>SQI IO configuration Default: All additional SQI-IOs (SIO2+3) are in PIO input mode. Coding 00: only SIO2+3 are controllable as PIOs (2-bit SPI or standard Motorola SPI) 01: all SQI IOs are used for transfers (4-bit SPI/SQI) 10: reserved 11: all SQI IOs are controllable as PIOs </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[21:20]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sck_muladd</name>
              <bitRange>[19:8]</bitRange>
              <description>Serial clock rate multiply add value for sck generation sck-frequency: f_sck = (sck_muladd * 100)/4096 [MHz]. Programmed value of sck_muladd must be &lt;= 0x800. Default value 0x800 equals 50 MHz clock rate. Note: If sck_muladd is set to zero, transfer will freeze. Note: SQIROM (XiP) serial clock rate must be programmed in register 'sqi_sqirom_cfg'. </description>
            </field>
            <field>
              <name>sck_phase</name>
              <bitRange>[7:7]</bitRange>
              <description>Serial clock phase 1: Sample data at second clock edge, data is generated half a clock phase before sampling 0: Sample data at first clock edge, data is generated half a clock phase before sampling Note: sck_phase value equals bit 0 of SPI mode value (mode = (sck_pol, sck_phase)). </description>
            </field>
            <field>
              <name>sck_pol</name>
              <bitRange>[6:6]</bitRange>
              <description>Serial clock polarity 0: idle: clock is low, first edge is rising 1: idle: clock is high, first edge is falling Note: sck_pol value equals bit 1 of SPI mode value (mode = (sck_pol, sck_phase)). </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[5:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>datasize</name>
              <bitRange>[3:0]</bitRange>
              <description>Data size select for standard Motorola SPI mode This bit field is unused in 2-bit and 4-bit SPI modes (i.e. data size fixed to 8 bit). The actual transfer size is 'datasize' + 1 bit. {            | 0000...0010: reserved 0011:        4 bit 0100:        5 bit ... 0111:        8 bit ... 1111:        16 bit } </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'sqi_cr1': 0xFF8011C4-->
          <name>sqi_cr1</name>
          <description>SQI control register 1 This register is compatible with the netX50 and netX10 SPI module, but some additional settings are possible. The SQI module   provides master function only. Slave settings are omitted. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x08080000</resetValue>
          <resetMask>0x1F1F1F02</resetMask>
          <fields>
            <field>
              <name>bf_align4</name>
              <bitRange>[31:29]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>rx_fifo_clr</name>
              <bitRange>[28:28]</bitRange>
              <description>Receive FIFO clear Writing '1' to this bit will clear the receive FIFO. The hardware will automatically reset this bit. This bit is always '0' when read. </description>
            </field>
            <field>
              <name>rx_fifo_wm</name>
              <bitRange>[27:24]</bitRange>
              <description>Receive FIFO watermark for IRQ generation If the receive FIFO watermark IRQ is enabled (bit 'RXIM' is set in register 'sqi_irq_mask'), transfers will stop when the receive FIFO runs full. Transfers will continue after the receive data is read from the receive FIFO to avoid an overflow of the receive FIFO. If the receive FIFO watermark IRQ is disabled (bit 'RXIM' is not set in register 'sqi_irq_mask'), transfers will not stop when the receive FIFO runs full. This may cause an overflow of the receive FIFO. This is compatible with netX50 behavior and allows writing data in full-duplex mode without reading the receive FIFO. </description>
            </field>
            <field>
              <name>bf_align3</name>
              <bitRange>[23:21]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>tx_fifo_clr</name>
              <bitRange>[20:20]</bitRange>
              <description>Transmit FIFO clear Writing '1' to this bit will clear the transmit FIFO. The hardware will automatically reset this bit. This bit is always '0' when read. </description>
            </field>
            <field>
              <name>tx_fifo_wm</name>
              <bitRange>[19:16]</bitRange>
              <description>Transmit FIFO watermark for IRQ generation </description>
            </field>
            <field>
              <name>bf_align2</name>
              <bitRange>[15:13]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>spi_trans_ctrl</name>
              <bitRange>[12:12]</bitRange>
              <description>Transfer control for standard Motorola SPI (default: disabled) This bit is used only for standard Motorola SPI (bits 'mode' of register 'sqi_tcr') in full-duplex and half-duplex mode. If this bit is set, SPI transfers will be controlled by 'start_transfer' and 'transfer_size' of register 'sqi_tcr'. If this bit is not set (default), SPI transfers start immediately after transfer data has been written to TX FIFO (this is compatible with the SPI module). Settings of 'start_transfer' and 'transfer_size' of register 'sqi_tcr' then remain unaffected and will be ignored. If this bit is set and SPI is used in receive mode (full-duplex or half-duplex receive mode set by bit field 'duplex' in register 'sqi_tcr'), transfers will stop when the receive FIFO runs full. Transfers will continue after the receive data is read from the receive FIFO to avoid an overflow of the receive FIFO. </description>
            </field>
            <field>
              <name>fss_static</name>
              <bitRange>[11:11]</bitRange>
              <description>SQI static chip select 0: Chip select will be generated automatically at data frame begin/end according to fss and datasize. 1: Chip select will be set statically according to 'fss' bits (see below). If fss is set to static mode, fss must be toggled manually after each data frame in Motorola SPI mode when sck_phase is 0 for compatibility with the specification! Note: This bit is used only in standard Motorola SPI mode. For SQI modes, chip select is never generated automatically. </description>
            </field>
            <field>
              <name>fss</name>
              <bitRange>[10:8]</bitRange>
              <description>Frame slave select Up to 3 devices can be assigned directly. Up to 8 devices can be assigned if an external de-multiplexer is used. This signal is active low, i.e. the bits will be inverted before they are output to the SQI pins. </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[7:2]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sqi_en</name>
              <bitRange>[1:1]</bitRange>
              <description>SQI enable 0: Interface disabled 1: Interface enabled Note: If you select the SQIROM/XiP function by bit 'enable' of register 'sqi_sqirom_cfg' (see description of register 'sqi_sqirom_cfg'), the standard SQI/SPI function will not be available. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[0:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'sqi_dr': 0xFF8011C8-->
          <name>sqi_dr</name>
          <description>SQI data register (DR) Read access: Received data word is delivered from receive FIFO. Write access: Data word to be sent is written to send FIFO. Receive and transmit FIFO both have a depth of 16 words (standard SPI mode). The SQI mode combines both FIFOs, i.e. 64 bytes are   available. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>data</name>
              <bitRange>[31:0]</bitRange>
              <description>Transmit data The data must be right-aligned during writing. In Standard SPI mode only bits according to sqi_cr0.datasize are transferred. In SQI mode data must be written in full DWords (i.e. the software has to collect four bytes prior to writing). Unused bytes will not be transferred and may be padded at will (number of transferred bytes depends on sqi_tcr.transfer_size). Receive data will always be right-aligned; unused bits will be '0'. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'sqi_sr': 0xFF8011CC-->
          <name>sqi_sr</name>
          <description>Read-only SQI status register Shows the current status of the SQI interface. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xDFDFE01F</resetMask>
          <fields>
            <field>
              <name>rx_fifo_err_undr</name>
              <bitRange>[31:31]</bitRange>
              <description>Receive FIFO underrun error has occurred, unexpected data has been read. To clear this status flag, clear RX FIFO (register 'sqi_cr1'). </description>
            </field>
            <field>
              <name>rx_fifo_err_ovfl</name>
              <bitRange>[30:30]</bitRange>
              <description>Receive FIFO overflow error occurred, data is lost. To clear this status flag, clear RX FIFO (register 'sqi_cr1'). </description>
            </field>
            <field>
              <name>bf_align2</name>
              <bitRange>[29:29]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>rx_fifo_level</name>
              <bitRange>[28:24]</bitRange>
              <description>Receive FIFO level (number of received words to be read from the FIFO). </description>
            </field>
            <field>
              <name>tx_fifo_err_undr</name>
              <bitRange>[23:23]</bitRange>
              <description>Transmit FIFO underrun error has occurred, unexpected data has been sent. To clear this status flag, clear TX FIFO (register 'sqi_cr1'). </description>
            </field>
            <field>
              <name>tx_fifo_err_ovfl</name>
              <bitRange>[22:22]</bitRange>
              <description>Transmit FIFO overflow error occurred, data is lost. To clear this status flag, clear TX FIFO (register 'sqi_cr1'). </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[21:21]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>tx_fifo_level</name>
              <bitRange>[20:16]</bitRange>
              <description>Transmit FIFO level (number of words to be transmitted are left in the FIFO). </description>
            </field>
            <field>
              <name>sqirom_disabled_err</name>
              <bitRange>[15:15]</bitRange>
              <description>Access to the disabled SQIROM area has occurred. To enable the SQIROM function, set bit 'enable' in register 'sqi_sqirom_cfg'. This bit can be used to determine why the IRQ 'sqirom_error' has occurred. Clearing this status flag is possible only by writing a '1' here. </description>
            </field>
            <field>
              <name>sqirom_write_err</name>
              <bitRange>[14:14]</bitRange>
              <description>Write access to the read-only SQIROM area has occurred. This bit can be used to determine why the IRQ 'sqirom_error' has occurred. Clearing this status flag is possible only by writing a '1' here. </description>
            </field>
            <field>
              <name>sqirom_timeout_err</name>
              <bitRange>[13:13]</bitRange>
              <description>Timeout during a read of the SQIROM area has occurred. A timeout results from a fix level of the netX serial clock IO. Check IO multiplexing configuration and make sure that the serial clock output is not externally clamped. This bit can be used to determine why the IRQ 'sqirom_error' has occurred. Clearing this status flag is possible only by writing a '1' here. The SQIROM function must be disabled and enabled again to reset module-internal state machines after this bit has been set (register 'sqirom_cfg', therefore reset and set again the 'enable' bit). </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[12:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>busy</name>
              <bitRange>[4:4]</bitRange>
              <description>Device is busy 1 if data is currently transmitted/received or the transmit FIFO is not empty. </description>
            </field>
            <field>
              <name>rx_fifo_full</name>
              <bitRange>[3:3]</bitRange>
              <description>Receive FIFO is full (1 if full). </description>
            </field>
            <field>
              <name>rx_fifo_not_empty</name>
              <bitRange>[2:2]</bitRange>
              <description>Receive FIFO is not empty (0 if empty). </description>
            </field>
            <field>
              <name>tx_fifo_not_full</name>
              <bitRange>[1:1]</bitRange>
              <description>Transmit FIFO is not full (0 if full). </description>
            </field>
            <field>
              <name>tx_fifo_empty</name>
              <bitRange>[0:0]</bitRange>
              <description>Transmit FIFO is empty (1 if empty). </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'sqi_tcr': 0xFF8011D0-->
          <name>sqi_tcr</name>
          <description>SQI transfer control This register must not be changed during a transfer (bit 'busy' of register 'sqi_sr' is '1') to avoid corrupted transfers causing   damage to the hardware. Module address offset 0x10 is reserved in the netX10/50 SPI module. Thus, no compatibility problems will result from using this   address for extended transfer control features. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1C000000</resetValue>
          <resetMask>0x3FE7FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:30]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ms_byte_first</name>
              <bitRange>[29:29]</bitRange>
              <description>Most significant byte first 2- and 4-bit mode: Writing '1' to this bit will use most significant byte first in DWords (big endian). Default is little endian In standard Motorola SPI mode this bit is ignored. </description>
            </field>
            <field>
              <name>ms_bit_first</name>
              <bitRange>[28:28]</bitRange>
              <description>Most significant bit first 2- and 4-bit mode: Writing '1' to this bit will transfer most significant bit first (default). In standard Motorola SPI mode this bit is ignored. </description>
            </field>
            <field>
              <name>duplex</name>
              <bitRange>[27:26]</bitRange>
              <description>Transfer type selection Default is '11' for standard SPI compatibility. 00: dummy Generates 'transfer_size' + 1 serial clock periods. No change of RX and TX FIFOs. Data lines (standard Motorola SPI mode: SPI_MOSI) are controlled by 'tx_oe' and 'tx_out'. 01: half-duplex receive Receives 'transfer_size' + 1 words. In 2-bit and 4-bit mode, TX-FIFO will be cleared and is not available during receive. In standard SPI mode, SPI_MOSI is controlled by 'tx_oe' and 'tx_out'. You need not fill the TX-FIFO with dummy TX-data to receive RX-data. TX FIFOs are not changed and always available. 10: half-duplex transmit Transmits 'transfer_size' + 1 words. In 2-bit and 4-bit mode, RX-FIFO will be cleared and is not available during transmit. In standard SPI mode, SPI_MISO input is ignored. RX-FIFO is available and remains unchanged. 11: full-duplex Standard Motorola SPI mode only, reserved in 2-bit and 4-bit modes. The full-duplex standard Motorola SPI mode always transmits and receives data. Transmit data is taken from TX-FIFO, receive data is stored in RX-FIFO. Note: If '11' is set in 2-bit or 4-bit mode, this is treated as 'receive' (like '01' setting). Note: In case of a FIFO error (overflow, underrun) before changing to '01' or '10', the FIFO error status bits in register 'sqi_sr' will not be cleared by half-duplex modes FIFO clearing. </description>
            </field>
            <field>
              <name>mode</name>
              <bitRange>[25:24]</bitRange>
              <description>SPI/SQI mode selection 00: Standard Motorola SPI mode. 01: 2-bit SPI mode 10: 4-bit SPI mode 11: reserved </description>
            </field>
            <field>
              <name>start_transfer</name>
              <bitRange>[23:23]</bitRange>
              <description>Transfer start signal Writing a '1' starts the transfer of transfer_size bytes or dummy cycles. The hardware will automatically reset this bit. This bit is always '0' when read. This bit is writable only after a transfer sequence is finished or if it has been terminated by a FIFO clear. Note: A transfer sequence is finished completely when 'busy' of register 'sqi_sr' is not set. Note: In standard Motorola SPI mode, this function can be controlled by bit 'spi_trans_ctrl' of register 'sqi_cr1' (for SPI module compatibility). </description>
            </field>
            <field>
              <name>tx_oe</name>
              <bitRange>[22:22]</bitRange>
              <description>Output driver enable in dummy or standard SPI receive-only mode Writing a '1' enables the output drivers of the data pins in the dummy mode. </description>
            </field>
            <field>
              <name>tx_out</name>
              <bitRange>[21:21]</bitRange>
              <description>Output level in dummy or standard SPI receive-only mode This bit selects the output level when the output driver is enabled in the dummy mode. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[20:19]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>transfer_size</name>
              <bitRange>[18:0]</bitRange>
              <description>Number of bytes within the current SQI transaction Program (number of bytes - 1) or (number of dummy clock cycles - 1). Example: {        | 0x00000: one byte/dummy cycle ... 0x7ffff: 512k bytes/dummy cycles } This bit field counts down during transfers with each transferred word/byte or dummy cycle. This bit field is writable only after a transfer sequence is finished or if it has been terminated by a FIFO clear. Hence, this bit is writable, but it can also be changed by hardware. A running transfer sequence can be terminated by clearing the FIFO (register 'sqi_cr1'). This may become necessary for terminating a read sequence. Example: A half-duplex write transfer of 128 kbytes has been programmed, but there is not enough write data. To terminate this write sequence, clear the TX FIFO. If an external transfer is running while the FIFO is being cleared, this transfer will be continued and finished with the last bit to be transferred. Note: A transfer sequence is finished completely when 'busy' of register 'sqi_sr' is not set. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'sqi_irq_mask': 0xFF8011D4-->
          <name>sqi_irq_mask</name>
          <description>SQI interrupt mask register: IRQ mask is an AND-mask: Only raw interrupts with mask bit set can generate a module IRQ to CPU.   For detailed IRQ behavior and function, see register 'sqi_irq_raw'. The functionality of this register is similar to that of the corresponding SPI register spi_imsc.   In contrast to this register, setting bits in spi_imsc also clears the corresponding raw interrupts. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000001FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:9]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sqirom_error</name>
              <bitRange>[8:8]</bitRange>
              <description>SQIROM error interrupt mask </description>
            </field>
            <field>
              <name>trans_end</name>
              <bitRange>[7:7]</bitRange>
              <description>Transfer end interrupt mask </description>
            </field>
            <field>
              <name>txeim</name>
              <bitRange>[6:6]</bitRange>
              <description>Transmit FIFO empty interrupt mask (for compatibility with netx100/500) </description>
            </field>
            <field>
              <name>rxfim</name>
              <bitRange>[5:5]</bitRange>
              <description>Receive FIFO full interrupt mask (for compatibility with netx100/500) </description>
            </field>
            <field>
              <name>rxneim</name>
              <bitRange>[4:4]</bitRange>
              <description>Receive FIFO not empty interrupt mask (for compatibility with netx100/500) </description>
            </field>
            <field>
              <name>TXIM</name>
              <bitRange>[3:3]</bitRange>
              <description>Transmit FIFO interrupt mask </description>
            </field>
            <field>
              <name>RXIM</name>
              <bitRange>[2:2]</bitRange>
              <description>Receive FIFO interrupt mask </description>
            </field>
            <field>
              <name>RTIM</name>
              <bitRange>[1:1]</bitRange>
              <description>Receive timeout interrupt mask </description>
            </field>
            <field>
              <name>RORIM</name>
              <bitRange>[0:0]</bitRange>
              <description>Receive FIFO overrun interrupt mask </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'sqi_irq_raw': 0xFF8011D8-->
          <name>sqi_irq_raw</name>
          <description>SQI interrupt state before masking register (raw interrupt). Writing a '1' to a bit clears this interrupt. IRQ flags can also be cleared by using 'sqi_irq_clear' for SPI module compatibility. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000018</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000008</resetValue>
          <resetMask>0x000001FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:9]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sqirom_error</name>
              <bitRange>[8:8]</bitRange>
              <description>Unmasked SQIROM error interrupt state 1: SQIROM access error detected. This IRQ will be set if an error occurs during an SQIROM access. For detailed information on the error, see SQIROM error bits in register 'sqi_sr'. For error handling, clear this IRQ bit and the bits of register 'sqi_sr'. 0: no SQIROM error detected. </description>
            </field>
            <field>
              <name>trans_end</name>
              <bitRange>[7:7]</bitRange>
              <description>Unmasked transfer end interrupt state (related to bit 'busy' of register 'sqi_sr') 1: transfer finished. Bit 'busy' of register 'sqi_sr' has become inactive. 0: transfer not finished. Bit 'busy' of register 'sqi_sr' is active. </description>
            </field>
            <field>
              <name>txeris</name>
              <bitRange>[6:6]</bitRange>
              <description>Unmasked transmit FIFO empty interrupt state (for compatibility with netx100/500) 1: transmit FIFO is empty 0: transmit FIFO is not empty </description>
            </field>
            <field>
              <name>rxfris</name>
              <bitRange>[5:5]</bitRange>
              <description>Unmasked receive FIFO full interrupt state (for compatibility with netx100/500) 1: receive FIFO is full 0: receive FIFO is not full </description>
            </field>
            <field>
              <name>rxneris</name>
              <bitRange>[4:4]</bitRange>
              <description>Unmasked receive FIFO not empty interrupt state (for compatibility with netx100/500) 1: receive FIFO is not empty 0: receive FIFO is empty </description>
            </field>
            <field>
              <name>TXRIS</name>
              <bitRange>[3:3]</bitRange>
              <description>Unmasked transmit FIFO interrupt state 1: transmit FIFO level is below sqi_cr1.tx_fifo_wm 0: transmit FIFO is equal or higher than sqi_cr1.tx_fifo_wm </description>
            </field>
            <field>
              <name>RXRIS</name>
              <bitRange>[2:2]</bitRange>
              <description>Unmasked receive FIFO interrupt state 1: receive FIFO is higher than sqi_cr1.rx_fifo_wm 0: receive FIFO is equal or below sqi_cr1.rx_fifo_wm Note: Before programming this IRQ, see description of bits 'spi_trans_ctrl' and 'rx_fifo_wm' of register 'sqi_cr1' for receive FIFO behavior. </description>
            </field>
            <field>
              <name>RTRIS</name>
              <bitRange>[1:1]</bitRange>
              <description>Unmasked receive timeout interrupt state Timeout period is 32 serial clock periods (depending on adr_sqi_cr0.sck_muladd). 1: receive FIFO is not empty and has not been read out during the timeout period 0: receive FIFO is empty or read during the last timeout period </description>
            </field>
            <field>
              <name>RORRIS</name>
              <bitRange>[0:0]</bitRange>
              <description>Unmasked receive FIFO overrun interrupt state 1: receive FIFO overrun error occurred 0: no receive FIFO overrun error occurred </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'sqi_irq_masked': 0xFF8011DC-->
          <name>sqi_irq_masked</name>
          <description>SQI masked interrupt status register For detailed IRQ behavior and function, see register 'sqi_irq_raw'. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000001C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000001FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:9]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sqirom_error</name>
              <bitRange>[8:8]</bitRange>
              <description>Masked SQIROM error interrupt state </description>
            </field>
            <field>
              <name>trans_end</name>
              <bitRange>[7:7]</bitRange>
              <description>Masked transfer end interrupt state </description>
            </field>
            <field>
              <name>txemis</name>
              <bitRange>[6:6]</bitRange>
              <description>Masked transmit FIFO empty interrupt state (for compatibility with netx100/500) </description>
            </field>
            <field>
              <name>rxfmis</name>
              <bitRange>[5:5]</bitRange>
              <description>Masked receive FIFO full interrupt state (for compatibility with netx100/500) </description>
            </field>
            <field>
              <name>rxnemis</name>
              <bitRange>[4:4]</bitRange>
              <description>Masked receive FIFO not empty interrupt state (for compatibility with netx100/500) </description>
            </field>
            <field>
              <name>TXMIS</name>
              <bitRange>[3:3]</bitRange>
              <description>Masked transmit FIFO interrupt state </description>
            </field>
            <field>
              <name>RXMIS</name>
              <bitRange>[2:2]</bitRange>
              <description>Masked receive FIFO interrupt state </description>
            </field>
            <field>
              <name>RTMIS</name>
              <bitRange>[1:1]</bitRange>
              <description>Masked receive timeout interrupt state </description>
            </field>
            <field>
              <name>RORMIS</name>
              <bitRange>[0:0]</bitRange>
              <description>Masked receive FIFO overrun interrupt state </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'sqi_irq_clear': 0xFF8011E0-->
          <name>sqi_irq_clear</name>
          <description>SQI interrupt clear register (for compatibility with netX10/50 SPI module). This register is always '0' on read. IRQ flags can also be cleared by writing register 'sqi_irq_raw'. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000001FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:9]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sqirom_error</name>
              <bitRange>[8:8]</bitRange>
              <description>Clear SQIROM error interrupt </description>
            </field>
            <field>
              <name>trans_end</name>
              <bitRange>[7:7]</bitRange>
              <description>Clear transfer end interrupt </description>
            </field>
            <field>
              <name>txeic</name>
              <bitRange>[6:6]</bitRange>
              <description>Clear transmit FIFO empty interrupt (for compatibility with netx100/500) </description>
            </field>
            <field>
              <name>rxfic</name>
              <bitRange>[5:5]</bitRange>
              <description>Clear receive FIFO full interrupt (for compatibility with netx100/500) </description>
            </field>
            <field>
              <name>rxneic</name>
              <bitRange>[4:4]</bitRange>
              <description>Clear receive FIFO not empty interrupt (for compatibility with netx100/500) </description>
            </field>
            <field>
              <name>TXIC</name>
              <bitRange>[3:3]</bitRange>
              <description>Clear transmit FIFO interrupt </description>
            </field>
            <field>
              <name>RXIC</name>
              <bitRange>[2:2]</bitRange>
              <description>Clear receive FIFO interrupt </description>
            </field>
            <field>
              <name>RTIC</name>
              <bitRange>[1:1]</bitRange>
              <description>Clear receive timeout interrupt </description>
            </field>
            <field>
              <name>RORIC</name>
              <bitRange>[0:0]</bitRange>
              <description>Clear receive FIFO overrun interrupt </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'sqi_dmacr': 0xFF8011E4-->
          <name>sqi_dmacr</name>
          <description>SQI DMA control register This module generates normal transfer requests only (i.e. no last requests will be issued). In consequence,   you can use DMAC-controlled transfers only (no peripheral-controlled mode). </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000024</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:2]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>tx_dma_en</name>
              <bitRange>[1:1]</bitRange>
              <description>Enable DMA for SQI-transmit data A request will be generated if TX-FIFO is not full and sqi_cr1.sqi_en (module enable) is set. If at least 4 words are writable to the TX-FIFO, there will be a burst request to the DMAC. Set dmac_chctrl.DBSize = 1 (i.e. burst size: 4) in the DMAC module. If this bit is reset or the module is disabled, DMA request will also be reset. </description>
            </field>
            <field>
              <name>rx_dma_en</name>
              <bitRange>[0:0]</bitRange>
              <description>Enable DMA for SQI-receive data A request will be generated if RX-FIFO is not empty and sqi_cr1.sqi_en (module enable) is set. If the RX-FIFO contains at least 4 words, there will be a burst request to the DMAC. Set dmac_chctrl.SBSize = 1 (i.e. burst size: 4) in the DMAC module. If this bit is reset or the module is disabled, DMA request will also be reset. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'sqi_pio_out': 0xFF8011E8-->
          <name>sqi_pio_out</name>
          <description>SQI PIO output level control register Bits 'sio_cfg' of register 'sqi_cr0' control the IO PIO mode. Bit 'sqi_en' of register 'sqi_cr0' has to be set to drive the SQI IOs in the PIO mode. PIO input signal states are never filtered (bit 'filter_in' of register 'sqi_cr0'). </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000028</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000000E</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sio3</name>
              <bitRange>[7:7]</bitRange>
              <description>SIO3 output state </description>
            </field>
            <field>
              <name>sio2</name>
              <bitRange>[6:6]</bitRange>
              <description>SIO2 output state </description>
            </field>
            <field>
              <name>miso</name>
              <bitRange>[5:5]</bitRange>
              <description>MISO/SIO1 output state </description>
            </field>
            <field>
              <name>mosi</name>
              <bitRange>[4:4]</bitRange>
              <description>MOSI/SIO0 output state </description>
            </field>
            <field>
              <name>csn</name>
              <bitRange>[3:1]</bitRange>
              <description>Chip select/FSS output state {CS2, CS1, CS0} </description>
            </field>
            <field>
              <name>sclk</name>
              <bitRange>[0:0]</bitRange>
              <description>Serial SPI clock output state </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'sqi_pio_oe': 0xFF8011F0-->
          <name>sqi_pio_oe</name>
          <description>SQI PIO output enable control register Bits 'sio_cfg' of register 'sqi_cr0' control the IO PIO mode. Bit 'sqi_en' of register 'sqi_cr0' has to be set to drive the SQI IOs in the PIO mode. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000030</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sio3</name>
              <bitRange>[7:7]</bitRange>
              <description>SIO3 output enable </description>
            </field>
            <field>
              <name>sio2</name>
              <bitRange>[6:6]</bitRange>
              <description>SIO2 output enable </description>
            </field>
            <field>
              <name>miso</name>
              <bitRange>[5:5]</bitRange>
              <description>MISO/SIO1 output enable </description>
            </field>
            <field>
              <name>mosi</name>
              <bitRange>[4:4]</bitRange>
              <description>MOSI/SIO0 output enable </description>
            </field>
            <field>
              <name>csn</name>
              <bitRange>[3:1]</bitRange>
              <description>Chip select/FSS output enable {CS2, CS1, CS0} </description>
            </field>
            <field>
              <name>sclk</name>
              <bitRange>[0:0]</bitRange>
              <description>Serial SPI clock output enable </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'sqi_pio_in': 0xFF8011F4-->
          <name>sqi_pio_in</name>
          <description>SQI PIO input status register Bits 'sio_cfg' of register 'sqi_cr0' control the IO PIO mode. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000034</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sio3</name>
              <bitRange>[7:7]</bitRange>
              <description>SIO3 input state </description>
            </field>
            <field>
              <name>sio2</name>
              <bitRange>[6:6]</bitRange>
              <description>SIO2 input state </description>
            </field>
            <field>
              <name>miso</name>
              <bitRange>[5:5]</bitRange>
              <description>MISO/SIO1 input state </description>
            </field>
            <field>
              <name>mosi</name>
              <bitRange>[4:4]</bitRange>
              <description>MOSI/SIO0 input state </description>
            </field>
            <field>
              <name>csn</name>
              <bitRange>[3:1]</bitRange>
              <description>Chip select/FSS input state {CS2, CS1, CS0} </description>
            </field>
            <field>
              <name>sclk</name>
              <bitRange>[0:0]</bitRange>
              <description>Serial SPI clock input state </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'sqi_sqirom_cfg': 0xFF8011F8-->
          <name>sqi_sqirom_cfg</name>
          <description>SQIROM mode configuration This mode supports the 'eXecute in Place' (XiP) feature of SQI flash chips. This register serves to configure the position of command   byte and address nibbles as well as the number of address nibbles and dummy cycles. To support a wide range of frequencies for the   serial clock output, you can also change the clock divider. Notes: 1. Before enabling this mode, make sure that the SQI flash chip is in 4-bit command mode, otherwise the module is not able to fetch data   from the flash. 2. When enabled, the SQI module is completely blocked, i.e. other SQI or SPI transactions are not possible. 3. The chip select signal of the flash must be connected to sqi_cs0. 4. SQIROM transfers can be generated in SPI mode 0 or 3, which can be selected in register 'sqi_cr0'. DO NOT select mode 1 and 2   for SQIROM usage. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000038</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x02020004</resetValue>
          <resetMask>0xFF3FFF7F</resetMask>
          <fields>
            <field>
              <name>clk_div_val</name>
              <bitRange>[31:24]</bitRange>
              <description>clk400 will be divided by (clk_div_val+3) for sqirom_clk generation. Default setting '2' is 80 MHz. Maximum serial clock rate (programming '0') is 133 MHz. Serial clock period (t_sck) will be (clk_div_val+3) * 2.5 ns. Clock high and low phase will be generated symmetrically. </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[23:22]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>t_csh</name>
              <bitRange>[21:20]</bitRange>
              <description>Min. SQI chip select high (idle) time: (t_csh+1) * t_sck (according to clk_div_val). Programmable values are 0 to 3. Change this parameter if the SQI device used requires min. chip select high times exceeding 1 serial clock period. The data sheet of the SQI device used provides the required timing. Note: Serial clock will not toggle if the device is not selected. Hence, only chip select active timing has to be considered. </description>
            </field>
            <field>
              <name>dummy_cycles</name>
              <bitRange>[19:16]</bitRange>
              <description>Selects the number of dummy cycles before data will be sampled from the SQI chip. {     | 0000: 0 cycles 0001: 1 cycle 0010: 2 cycles (default) ... 1111: 15 cycles } </description>
            </field>
            <field>
              <name>cmd_byte</name>
              <bitRange>[15:8]</bitRange>
              <description>This byte is transferred to the SQI chip as the command sequence. Bit 'addr_before_cmd' controls the address command order. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[7:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>addr_bits</name>
              <bitRange>[6:4]</bitRange>
              <description>The number of address bits of the access address considered to generate the address for the SQI chip. This setting depends on the size of the SQI chip. {     | 000:  20 bits (1-MByte/8-MBit device) (default) 001:  21 bits (2-MByte/16-MBit device) 010:  22 bits (4-MByte/32-MBit device) 011:  23 bits (8-MByte/64-MBit device) 100:  24 bits (16-MByte/128-MBit device) 101:  25 bits (32-MByte/256-MBit device) 110:  26 bits (64-MByte/512-MBit device) 111:  reserved } </description>
            </field>
            <field>
              <name>addr_nibbles</name>
              <bitRange>[3:2]</bitRange>
              <description>The number of nibbles to be transferred as the address to the SQI chip. This setting depends on the command format of the SQI chip. Bit 'addr_before_cmd' controls the address command order. The most significant address bits will be transmitted in the first address nibble. The least significant address bits will be transmitted in the last address nibble. 00: 5 nibbles 01: 6 nibbles (default) 10: 7 nibbles 11: 8 nibbles </description>
            </field>
            <field>
              <name>addr_before_cmd</name>
              <bitRange>[1:1]</bitRange>
              <description>Address before command When set to '1', the address nibbles will be transferred before the command byte. Otherwise, the command will be transferred first (default). </description>
            </field>
            <field>
              <name>enable</name>
              <bitRange>[0:0]</bitRange>
              <description>Enables the SQIROM mode of the SQI module. The SQI chip needs to be initialized to accept 4-bit read-command before you activate the SQIROM mode. This bit is also used to switch between the SQIROM/XiP and the standard SQI/SPI function. If this bit is set, the standard SQI/SPI function is not available. The SQIROM/XiP function does not depend on the programmed value of bit 'sqi_en' of register 'sqi_cr1'. If the multiplex matrix provides the SQI function, it is available only in standard SQI/SPI, but not for SQIROM/XiP usage. The SQIROM/XiP function is provided only on dedicated SQI IOs, but not as a multiplex matrix function even if standard SQI/SPI is provided there. </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>can_ctrl0_app</name>
      <description>can_ctrl0_app</description>
      <baseAddress>0xFF801200</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>128</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>can_ctrl0_app</name>
        <value>71</value>
      </interrupt>
      <registers>
        <register>
          <!--Absolute address of 'canctrl_mode': 0xFF801200-->
          <name>canctrl_mode</name>
          <description>CAN mode register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>acceptance_mode</name>
              <bitRange>[3:3]</bitRange>
              <description>Acceptance Filter Mode 1 single; the single acceptance filter option is enabled (one filter with the length of 32 bit is active) 0 dual; the dual acceptance filter option is enabled (two filters, each with the length of 16 bit are active) </description>
            </field>
            <field>
              <name>selftest</name>
              <bitRange>[2:2]</bitRange>
              <description>Self Test Mode 1 self test; in this mode a full node test is possible without any other active node on the bus using the self reception request command; the CAN controller will perform a successful transmission, even if there is no acknowledge received 0 normal; an acknowledge is required for successful transmission </description>
            </field>
            <field>
              <name>listen_mode</name>
              <bitRange>[1:1]</bitRange>
              <description>Listen Only Mode 1 listen only; in this mode the CAN controller would give no acknowledge to the CAN-bus, even if a message is received successfully; the error counters are stopped at the current value 0 normal </description>
            </field>
            <field>
              <name>reset_mode</name>
              <bitRange>[0:0]</bitRange>
              <description>Reset Mode 1 reset; detection of a set reset mode bit results in aborting the current transmission/reception of a message and entering the reset mode 0 normal; on the `1-to-0' transition of the reset mode bit, the CAN controller returns to the operating mode </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'canctrl_command': 0xFF801204-->
          <name>canctrl_command</name>
          <description>CAN command register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000001F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>self_rx_request</name>
              <bitRange>[4:4]</bitRange>
              <description>Self Reception Request, self-clearing 1 present; a message shall be transmitted and received simultaneously Setting tx_request and self_rx_request simultaneously will ignore the set self_rx_request bit. </description>
            </field>
            <field>
              <name>clr_overrun</name>
              <bitRange>[3:3]</bitRange>
              <description>Clear Data Overrun, self-clearing 1 clear; the data overrun status bit is cleared, shall be used together with release_rx_buf to release invalid buffer </description>
            </field>
            <field>
              <name>release_rx_buf</name>
              <bitRange>[2:2]</bitRange>
              <description>Release Receive Buffer, self-clearing 1 released; the receive buffer, representing the message memory space in the RXFIFO is released </description>
            </field>
            <field>
              <name>abort_tx</name>
              <bitRange>[1:1]</bitRange>
              <description>Abort Transmission, self-clearing 1 present; if not already in progress, a pending transmission request is cancelled Setting the command bits tx_request and abort_tx simultaneously results in sending the transmit message once. No re-transmission will be performed in the event of an error or arbitration lost (single-shot transmission). </description>
            </field>
            <field>
              <name>tx_request</name>
              <bitRange>[0:0]</bitRange>
              <description>Transmission Request, self-clearing 1 present; a message shall be transmitted </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'canctrl_status': 0xFF801208-->
          <name>canctrl_status</name>
          <description>CAN status register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000001FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:9]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>tx_aborted</name>
              <bitRange>[8:8]</bitRange>
              <description>Transmission aborted 1 Previously requested transmission is aborted </description>
            </field>
            <field>
              <name>bus_status</name>
              <bitRange>[7:7]</bitRange>
              <description>Bus Status 1 bus-off; the CAN controller is not involved in bus activities 0 bus-on; the CAN controller is involved in bus activities </description>
            </field>
            <field>
              <name>error_status</name>
              <bitRange>[6:6]</bitRange>
              <description>Error Status 1 error; at least one of the error counters has reached or exceeded the CPU warning limit defined by the Error Warning Limit Register (EWLR) 0 ok; both error counters are below the warning limit </description>
            </field>
            <field>
              <name>tx_status</name>
              <bitRange>[5:5]</bitRange>
              <description>Transmit Status 1 transmit; the CAN controller is transmitting a message 0 idle </description>
            </field>
            <field>
              <name>rx_status</name>
              <bitRange>[4:4]</bitRange>
              <description>Receive Status 1 receive; the CAN controller is receiving a message 0 idle </description>
            </field>
            <field>
              <name>tx_complete</name>
              <bitRange>[3:3]</bitRange>
              <description>Transmission Complete 1 complete; last requested transmission has been successfully completed 0 incomplete; previously requested transmission is not yet completed </description>
            </field>
            <field>
              <name>tx_buf_status</name>
              <bitRange>[2:2]</bitRange>
              <description>Transmit Buffer Status 1 released; the CPU may write a message into the transmit buffer 0 locked; the CPU cannot access the transmit buffer ; a message is either waiting for transmission or is in the process of being transmitted </description>
            </field>
            <field>
              <name>overrun</name>
              <bitRange>[1:1]</bitRange>
              <description>Data Overrun Status 1 overrun; a message was lost because there was not enough space for that message in the RXFIFO 0 absent; no data overrun has occurred since the last clear data overrun command was given </description>
            </field>
            <field>
              <name>rx_buf_status</name>
              <bitRange>[0:0]</bitRange>
              <description>Receive Buffer Status 1 full; one or more complete messages are available in the RXFIFO 0 empty; no message is available </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'canctrl_irq': 0xFF80120C-->
          <name>canctrl_irq</name>
          <description>CAN interrupt register reading the register will clear all bits except rx_irq </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000EF</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>bus_error_irq</name>
              <bitRange>[7:7]</bitRange>
              <description>Bus Error Interrupt 1 set; this bit is set when the CAN controller detects an error on the CAN-bus and the bus_error_irq_en bit is set within the interrupt enable register, will only get active again if canctrl_err_code_capture register is read 0 reset </description>
            </field>
            <field>
              <name>arb_lost_irq</name>
              <bitRange>[6:6]</bitRange>
              <description>Arbitration Lost Interrupt 1 set; this bit is set when the CAN controller lost the arbitration and becomes a receiver and the arb_lost_irq_en bit is set within the interrupt enable register, will only get active again if canctrl_arb_lost_capture register is read 0 reset </description>
            </field>
            <field>
              <name>err_passive_irq</name>
              <bitRange>[5:5]</bitRange>
              <description>Error Passive Interrupt 1 set; this bit is set whenever the CAN controller has reached the error passive status (at least one error counter exceeds the protocol-defined level of 127) or if the CAN controller is in the error passive status and enters the error active status again and the err_passive_irq_en bit is set within the interrupt enable register 0 reset </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[4:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>overrun_irq</name>
              <bitRange>[3:3]</bitRange>
              <description>Data Overrun Interrup 1 set; this bit is set on a `0-to-1' transition of the data overrun status bit and the overrun_irq_en bit is set within the interrupt enable register 0 reset </description>
            </field>
            <field>
              <name>warning_irq</name>
              <bitRange>[2:2]</bitRange>
              <description>Error Warning Interrupt 1 set; this bit is set on every change (set and clear) of either the error status or bus status bits and the warning_irq_en bit is set within the interrupt enable register 0 reset </description>
            </field>
            <field>
              <name>tx_irq</name>
              <bitRange>[1:1]</bitRange>
              <description>Transmit Interrupt 1 set; this bit is set whenever the transmit buffer status changes from `0-to-1' (released) and the tx_irq_en bit is set within the interrupt enable register 0 reset </description>
            </field>
            <field>
              <name>rx_irq</name>
              <bitRange>[0:0]</bitRange>
              <description>Receive Interrupt 1 set; this bit is set while the receive FIFO is not empty and the rx_irq_en bit is set within the interrupt enable register 0 reset; no more message is available within the RXFIFO </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'canctrl_irq_en': 0xFF801210-->
          <name>canctrl_irq_en</name>
          <description>CAN interrupt enable register in not extended mode: acceptance_code_0 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000EF</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>bus_error_irq_en</name>
              <bitRange>[7:7]</bitRange>
              <description>Bus Error Interrupt Enable 1 enabled; if an bus error has been detected, the CAN controller requests the respective interrupt 0 disabled </description>
            </field>
            <field>
              <name>arb_lost_irq_en</name>
              <bitRange>[6:6]</bitRange>
              <description>Arbitration Lost Interrupt Enable 1 enabled; if the CAN controller has lost arbitration, the respective interrupt is requested 0 disabled </description>
            </field>
            <field>
              <name>err_passive_irq_en</name>
              <bitRange>[5:5]</bitRange>
              <description>Error Passive Interrupt Enable 1 enabled; if the error status of the CAN controller changes from error active to error passive or vice versa, the respective interrupt is requested 0 disabled </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[4:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>overrun_irq_en</name>
              <bitRange>[3:3]</bitRange>
              <description>Data Overrun Interrupt Enable 1 enabled; if the data overrun status bit is set (see status register; Table 14), the CAN controller requests the respective interrupt 0 disabled </description>
            </field>
            <field>
              <name>warning_irq_en</name>
              <bitRange>[2:2]</bitRange>
              <description>Error Warning Interrupt Enable 1 enabled; if the error or bus status change (see status register), the CAN controller requests the respective interrupt 0 disabled </description>
            </field>
            <field>
              <name>tx_irq_en</name>
              <bitRange>[1:1]</bitRange>
              <description>Transmit Interrupt Enable 1 enabled; when a message has been successfully transmitted or the transmit buffer is accessible again (e.g. after an abort transmission command), the CAN controller requests the respective interrupt 0 disabled </description>
            </field>
            <field>
              <name>rx_irq_en</name>
              <bitRange>[0:0]</bitRange>
              <description>Receive Interrupt Enable 1 enabled; when the receive buffer status is `full' the CAN controller requests the respective interrupt 0 disabled </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'canctrl_not_extended_acceptance_mask0': 0xFF801214-->
          <name>canctrl_not_extended_acceptance_mask0</name>
          <description>CAN not extended acceptance mask register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'canctrl_bus_timing0': 0xFF801218-->
          <name>canctrl_bus_timing0</name>
          <description>CAN bus timing register 0, only writable in reset mode in not extended mode: acceptance_mask_0 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000018</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000007FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:11]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sync_jump_width</name>
              <bitRange>[10:9]</bitRange>
              <description>Synchronization Jump Width To compensate for phase shifts between clock oscillators of different bus controllers, any bus controller must re-synchronize on any relevant signal edge of the current transmission. The synchronization jump width defines the maximum number of clock cycles a bit period may be shortened or lengthened by one re-synchronization: tSJW = tscl * (sync_jump_width + 1) </description>
            </field>
            <field>
              <name>prescaler</name>
              <bitRange>[8:0]</bitRange>
              <description>Baud Rate Prescaler The period of the CAN system clock tscl is programmable and determines the individual bit timing. The CAN system clock is calculated using the following equation: tscl = tCLK * prescaler with tCLK = 10 ns </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'canctrl_bus_timing1': 0xFF80121C-->
          <name>canctrl_bus_timing1</name>
          <description>CAN bus timing register 1, only writable in reset mode </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000001C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00001FBF</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:13]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>tseg2</name>
              <bitRange>[12:8]</bitRange>
              <description>Time Segment 2 (TSEG2) TSEG2 determine the number of clock cycles per bit period and the location of the sample point, where: tTSEG2 = tscl * (tseg2 + 1) </description>
            </field>
            <field>
              <name>oversampling</name>
              <bitRange>[7:7]</bitRange>
              <description>Sampling 1 triple; the bus is sampled three times; recommended for low/medium speed buses (class A and B) where filtering spikes on the bus line is beneficial 0 single; the bus is sampled once; recommended for high speed buses (SAE class C) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[6:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>tseg1</name>
              <bitRange>[5:0]</bitRange>
              <description>Time Segment 1 (TSEG1) TSEG1 determine the number of clock cycles per bit period and the location of the sample point, where: tSYNCSEG = 1 * tscl tTSEG1 = tscl * (tseg1 + 1) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'canctrl_not_extended_data0': 0xFF801228-->
          <name>canctrl_not_extended_data0</name>
          <description>CAN not extended data register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000028</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'canctrl_arb_lost_capture': 0xFF80122C-->
          <name>canctrl_arb_lost_capture</name>
          <description>CAN arbitration lost capture register This register contains information about the bit position of losing arbitration. reading the register will clear all bits in not extended mode: data1 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000002C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000001F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>position</name>
              <bitRange>[4:0]</bitRange>
              <description>Positon where arbitration was lost {              | Decimal value    Position 00         arbitration lost in bit 1 of identifier 01         arbitration lost in bit 2 of identifier 02         arbitration lost in bit 3 of identifier 03         arbitration lost in bit 4 of identifier 04         arbitration lost in bit 5 of identifier 05         arbitration lost in bit 6 of identifier 06         arbitration lost in bit 7 of identifier 07         arbitration lost in bit 8 of identifier 08         arbitration lost in bit 9 of identifier 09         arbitration lost in bit 10 of identifier 10         arbitration lost in bit 11 of identifier 11         arbitration lost in bit SRTR; (bit RTR for standard frame messages) 12         arbitration lost in bit IDE 13         arbitration lost in bit 12 of identifier; extended frame messages only 14         arbitration lost in bit 13 of identifier; extended frame messages only 15         arbitration lost in bit 14 of identifier; extended frame messages only 16         arbitration lost in bit 15 of identifier; extended frame messages only 17         arbitration lost in bit 16 of identifier; extended frame messages only 18         arbitration lost in bit 17 of identifier; extended frame messages only 19         arbitration lost in bit 18 of identifier; extended frame messages only 20         arbitration lost in bit 19 of identifier; extended frame messages only 21         arbitration lost in bit 20 of identifier; extended frame messages only 22         arbitration lost in bit 21 of identifier; extended frame messages only 23         arbitration lost in bit 22 of identifier; extended frame messages only 24         arbitration lost in bit 23 of identifier; extended frame messages only 25         arbitration lost in bit 24 of identifier; extended frame messages only 26         arbitration lost in bit 25 of identifier; extended frame messages only 27         arbitration lost in bit 26 of identifier; extended frame messages only 28         arbitration lost in bit 27 of identifier; extended frame messages only 29         arbitration lost in bit 28 of identifier; extended frame messages only 30         arbitration lost in bit 29 of identifier; extended frame messages only 31         arbitration lost in bit RTR; extended frame messages only  } </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'canctrl_err_code_capture': 0xFF801230-->
          <name>canctrl_err_code_capture</name>
          <description>CAN error code capture register This register contains information about the type and location of errors on the bus. reading the register will clear all bits in not extended mode: data2 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000030</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>err_code</name>
              <bitRange>[7:6]</bitRange>
              <description>Error code {                  | Binary value      Code 00            bit error 01            form error 10            stuff error 11            other type of error } </description>
            </field>
            <field>
              <name>direction</name>
              <bitRange>[5:5]</bitRange>
              <description>Direction 1 RX; error occurred during reception 0 TX; error occurred during transmission </description>
            </field>
            <field>
              <name>segment</name>
              <bitRange>[4:0]</bitRange>
              <description>Frame segment where error was detected {                  | Binary value       Segment 00011           start of frame 00010           ID.28 to ID.21 00110           ID.20 to ID.18 00100           bit SRTR 00101           bit IDE 00111           ID.17 to ID.13 01111           ID.12 to ID.5 01110           ID.4 to ID.0 01100           bit RTR 01101           reser ved bit 1 01001           reser ved bit 0 01011           data length code 01010           data field 01000           CRC sequence 11000           CRC delimiter 11001           acknowledge slot 11011           acknowledge delimiter 11010           end of frame 10010           intermission 10001           active error flag 10110           passive error flag 10011           tolerate dominant bits 10111           error delimiter 11100           overload flag } </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'canctrl_err_warning_limit': 0xFF801234-->
          <name>canctrl_err_warning_limit</name>
          <description>CAN error warning limit register, only writable in reset mode in not extended mode: data3 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000034</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000060</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>limit</name>
              <bitRange>[7:0]</bitRange>
              <description>error warning limit </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'canctrl_rx_error_cnt': 0xFF801238-->
          <name>canctrl_rx_error_cnt</name>
          <description>CAN RX error counter register, only writable in reset mode The RX error counter register reflects the current value of the receive error counter. If a bus-off event occurs, the RX error counter is initialized to logic 0. The time bus-off is valid, writing to this register has no effect. Note, that a CPU-forced content change of the RX error counter is only possible, if the reset mode was entered previously. An error status change (see status register), an error warning or an error passive interrupt forced by the new register content will not occur, until the reset mode is cancelled again. in not extended mode: data4 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000038</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>rx_err</name>
              <bitRange>[7:0]</bitRange>
              <description>rx error counter </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'canctrl_tx_error_cnt': 0xFF80123C-->
          <name>canctrl_tx_error_cnt</name>
          <description>CAN TX error counter register, only writable in reset mode The TX error counter register reflects the current value of the transmit error counter. If a bus-off event occurs, the TX error counter is initialized to 127 to count the minimum protocol-defined time (128 occurrences of the bus-free signal). Reading the TX error counter during this time gives information about the status of the bus-off recovery. If bus-off is active, a write access to TXERR in the range from 0 to 254 clears the bus-off flag and the controller will wait for one occurrence of 11 consecutive recessive bits (bus-free) after the reset mode has been cleared. Writing 255 to TXERR allows to initiate a CPU-driven bus-off event. It should be noted that a CPU-forced content change of the TX error counter is only possible, if the reset mode was entered previously. An error or bus status change (see status register), an error warning or an error passive interrupt forced by the new register content will not occur until the reset mode is cancelled again. After leaving the reset mode, the new TX counter content is interpreted and the bus-off event is performed in the same way, as if it was forced by a bus error event. That means, that the reset mode is entered again, the TX error counter is initialized to 127, the RX counter is cleared and all concerned status and interrupt register bits are set. Clearing of reset mode now will perform the protocol-defined bus-off recovery sequence (waiting for 128 occurrences of the bus-free signal). If the reset mode is entered again before the end of bus-off recovery (TXERR &gt; 0), bus-off keeps active and TXERR is frozen. in not extended mode: data5 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000003C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>tx_err</name>
              <bitRange>[7:0]</bitRange>
              <description>tx error counter </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'canctrl_data0': 0xFF801240-->
          <name>canctrl_data0</name>
          <description>CAN data register 0 This register has multiple functions depending on reset mode and read or write access. {               |     |  Reset mode:      R/W: Read or write acceptance code 0  Operating mode:   R:  Standard frame: Read RX frame information                        Extended frame: Read RX frame information                    W:  Standard frame: Write TX frame information                        Extended frame: Write TX frame information } in not extended mode: data6 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000040</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>data</name>
              <bitRange>[7:0]</bitRange>
              <description>register content (rx data, tx data or acceptance code) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'canctrl_data1': 0xFF801244-->
          <name>canctrl_data1</name>
          <description>CAN data register 1 This register has multiple functions depending on reset mode and read or write access. {               |     |  Reset mode:      R/W: Read or write acceptance code 1  Operating mode:   R:  Standard frame: Read RX identifier 1                        Extended frame: Read RX identifier 1                    W:  Standard frame: Write TX identifier 1                        Extended frame: Write TX identifier 1 } in not extended mode: data7 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000044</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>data</name>
              <bitRange>[7:0]</bitRange>
              <description>register content (rx data, tx data or acceptance code) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'canctrl_data2': 0xFF801248-->
          <name>canctrl_data2</name>
          <description>CAN data register 2 This register has multiple functions depending on reset mode and read or write access. {               |     |  Reset mode:      R/W: Read or write acceptance code 2  Operating mode:   R:  Standard frame: Read RX identifier 2                        Extended frame: Read RX identifier 2                    W:  Standard frame: Write TX identifier 2                        Extended frame: Write TX identifier 2 } in not extended mode: data8 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000048</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>data</name>
              <bitRange>[7:0]</bitRange>
              <description>register content (rx data, tx data or acceptance code) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'canctrl_data3': 0xFF80124C-->
          <name>canctrl_data3</name>
          <description>CAN data register 3 This register has multiple functions depending on reset mode and read or write access. {               |     |  Reset mode:      R/W: Read or write acceptance code 3  Operating mode:   R:  Standard frame: Read RX data 1                        Extended frame: Read RX identifier 3                    W:  Standard frame: Write TX data 1                        Extended frame: Write TX identifier 3 } in not extended mode: data9 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000004C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>data</name>
              <bitRange>[7:0]</bitRange>
              <description>register content (rx data, tx data or acceptance code) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'canctrl_data4': 0xFF801250-->
          <name>canctrl_data4</name>
          <description>CAN data register 4 This register has multiple functions depending on reset mode and read or write access. {               |     |  Reset mode:      R/W: Read or write acceptance mask 0  Operating mode:   R:  Standard frame: Read RX data 2                        Extended frame: Read RX identifier 4                    W:  Standard frame: Write TX data 2                        Extended frame: Write TX identifier 4 } </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000050</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>data</name>
              <bitRange>[7:0]</bitRange>
              <description>register content (rx data, tx data or acceptance mask) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'canctrl_data5': 0xFF801254-->
          <name>canctrl_data5</name>
          <description>CAN data register 5 This register has multiple functions depending on reset mode and read or write access. {               |     |  Reset mode:      R/W: Read or write acceptance mask 1  Operating mode:   R:  Standard frame: Read RX data 3                        Extended frame: Read RX data 1                    W:  Standard frame: Write TX data 3                        Extended frame: Write TX data 1 } </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000054</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>data</name>
              <bitRange>[7:0]</bitRange>
              <description>register content (rx data, tx data or acceptance mask) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'canctrl_data6': 0xFF801258-->
          <name>canctrl_data6</name>
          <description>CAN data register 6 This register has multiple functions depending on reset mode and read or write access. {               |     |  Reset mode:      R/W: Read or write acceptance mask 2  Operating mode:   R:  Standard frame: Read RX data 4                        Extended frame: Read RX data 2                    W:  Standard frame: Write TX data 4                        Extended frame: Write TX data 2 } </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000058</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>data</name>
              <bitRange>[7:0]</bitRange>
              <description>register content (rx data, tx data or acceptance mask) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'canctrl_data7': 0xFF80125C-->
          <name>canctrl_data7</name>
          <description>CAN data register 7 This register has multiple functions depending on reset mode and read or write access. {               |     |  Reset mode:      R/W: Read or write acceptance mask 3  Operating mode:   R:  Standard frame: Read RX data 5                        Extended frame: Read RX data 3                    W:  Standard frame: Write TX data 5                        Extended frame: Write TX data 3 } </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000005C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>data</name>
              <bitRange>[7:0]</bitRange>
              <description>register content (rx data, tx data or acceptance mask) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'canctrl_data8': 0xFF801260-->
          <name>canctrl_data8</name>
          <description>CAN data register 8 This register has multiple functions depending on reset mode and read or write access. {               |     |  Reset mode:      R/W: reserved  Operating mode:   R:  Standard frame: Read RX data 6                        Extended frame: Read RX data 4                    W:  Standard frame: Write TX data 6                        Extended frame: Write TX data 4 } </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000060</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>data</name>
              <bitRange>[7:0]</bitRange>
              <description>register content (rx data or tx data) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'canctrl_data9': 0xFF801264-->
          <name>canctrl_data9</name>
          <description>CAN data register 9 This register has multiple functions depending on reset mode and read or write access. {               |     |  Reset mode:      R/W: reserved  Operating mode:   R:  Standard frame: Read RX data 7                        Extended frame: Read RX data 5                    W:  Standard frame: Write TX data 7                        Extended frame: Write TX data 5 } </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000064</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>data</name>
              <bitRange>[7:0]</bitRange>
              <description>register content (rx data or tx data) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'canctrl_data10': 0xFF801268-->
          <name>canctrl_data10</name>
          <description>CAN data register 10 This register has multiple functions depending on reset mode and read or write access. {               |     |  Reset mode:      R/W: reserved  Operating mode:   R:  Standard frame: Read RX data 8                        Extended frame: Read RX data 6                    W:  Standard frame: Write TX data 8                        Extended frame: Write TX data 6 } </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000068</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>data</name>
              <bitRange>[7:0]</bitRange>
              <description>register content (rx data or tx data) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'canctrl_data11': 0xFF80126C-->
          <name>canctrl_data11</name>
          <description>CAN data register 11 This register has multiple functions depending on reset mode and read or write access. {               |     |  Reset mode:      R/W: reserved  Operating mode:   R:  Standard frame: reserved                        Extended frame: Read RX data 7                    W:  Standard frame: reserved                        Extended frame: Write TX data 7 } </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000006C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>data</name>
              <bitRange>[7:0]</bitRange>
              <description>register content (rx data or tx data) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'canctrl_data12': 0xFF801270-->
          <name>canctrl_data12</name>
          <description>CAN data register 12 This register has multiple functions depending on reset mode and read or write access. {               |     |  Reset mode:      R/W: reserved  Operating mode:   R:  Standard frame: reserved                        Extended frame: Read RX data 8                    W:  Standard frame: reserved                        Extended frame: Write TX data 8 } </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000070</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>data</name>
              <bitRange>[7:0]</bitRange>
              <description>register content (rx data or tx data) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'canctrl_rx_message_cnt': 0xFF801274-->
          <name>canctrl_rx_message_cnt</name>
          <description>CAN RX message counter register Reflects the number of messages available within the RXFIFO. The value is incremented with each receive event and decremented by the release receive buffer command. After any reset event, this register is cleared. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000074</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000007F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>rx_msg_cnt</name>
              <bitRange>[6:0]</bitRange>
              <description>rx message counter </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'canctrl_mode_control': 0xFF80127C-->
          <name>canctrl_mode_control</name>
          <description>CAN mode control register, only writable in reset mode </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000007C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000080</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>mode</name>
              <bitRange>[7:7]</bitRange>
              <description>0: BasicCAN mode, 1: PeliCAN mode recommended value is 1 (PeliCAN mode), The here given register map of all registers of the CAN controller is valid for PeliCAN only. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[6:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>can_ctrl1_app</name>
      <description>can_ctrl1_app</description>
      <baseAddress>0xFF801280</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>128</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>can_ctrl1_app</name>
        <value>72</value>
      </interrupt>
      <registers>
        <register>
          <!--Absolute address of 'canctrl_mode': 0xFF801280-->
          <name>canctrl_mode</name>
          <description>CAN mode register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>acceptance_mode</name>
              <bitRange>[3:3]</bitRange>
              <description>Acceptance Filter Mode 1 single; the single acceptance filter option is enabled (one filter with the length of 32 bit is active) 0 dual; the dual acceptance filter option is enabled (two filters, each with the length of 16 bit are active) </description>
            </field>
            <field>
              <name>selftest</name>
              <bitRange>[2:2]</bitRange>
              <description>Self Test Mode 1 self test; in this mode a full node test is possible without any other active node on the bus using the self reception request command; the CAN controller will perform a successful transmission, even if there is no acknowledge received 0 normal; an acknowledge is required for successful transmission </description>
            </field>
            <field>
              <name>listen_mode</name>
              <bitRange>[1:1]</bitRange>
              <description>Listen Only Mode 1 listen only; in this mode the CAN controller would give no acknowledge to the CAN-bus, even if a message is received successfully; the error counters are stopped at the current value 0 normal </description>
            </field>
            <field>
              <name>reset_mode</name>
              <bitRange>[0:0]</bitRange>
              <description>Reset Mode 1 reset; detection of a set reset mode bit results in aborting the current transmission/reception of a message and entering the reset mode 0 normal; on the `1-to-0' transition of the reset mode bit, the CAN controller returns to the operating mode </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'canctrl_command': 0xFF801284-->
          <name>canctrl_command</name>
          <description>CAN command register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000001F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>self_rx_request</name>
              <bitRange>[4:4]</bitRange>
              <description>Self Reception Request, self-clearing 1 present; a message shall be transmitted and received simultaneously Setting tx_request and self_rx_request simultaneously will ignore the set self_rx_request bit. </description>
            </field>
            <field>
              <name>clr_overrun</name>
              <bitRange>[3:3]</bitRange>
              <description>Clear Data Overrun, self-clearing 1 clear; the data overrun status bit is cleared, shall be used together with release_rx_buf to release invalid buffer </description>
            </field>
            <field>
              <name>release_rx_buf</name>
              <bitRange>[2:2]</bitRange>
              <description>Release Receive Buffer, self-clearing 1 released; the receive buffer, representing the message memory space in the RXFIFO is released </description>
            </field>
            <field>
              <name>abort_tx</name>
              <bitRange>[1:1]</bitRange>
              <description>Abort Transmission, self-clearing 1 present; if not already in progress, a pending transmission request is cancelled Setting the command bits tx_request and abort_tx simultaneously results in sending the transmit message once. No re-transmission will be performed in the event of an error or arbitration lost (single-shot transmission). </description>
            </field>
            <field>
              <name>tx_request</name>
              <bitRange>[0:0]</bitRange>
              <description>Transmission Request, self-clearing 1 present; a message shall be transmitted </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'canctrl_status': 0xFF801288-->
          <name>canctrl_status</name>
          <description>CAN status register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000001FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:9]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>tx_aborted</name>
              <bitRange>[8:8]</bitRange>
              <description>Transmission aborted 1 Previously requested transmission is aborted </description>
            </field>
            <field>
              <name>bus_status</name>
              <bitRange>[7:7]</bitRange>
              <description>Bus Status 1 bus-off; the CAN controller is not involved in bus activities 0 bus-on; the CAN controller is involved in bus activities </description>
            </field>
            <field>
              <name>error_status</name>
              <bitRange>[6:6]</bitRange>
              <description>Error Status 1 error; at least one of the error counters has reached or exceeded the CPU warning limit defined by the Error Warning Limit Register (EWLR) 0 ok; both error counters are below the warning limit </description>
            </field>
            <field>
              <name>tx_status</name>
              <bitRange>[5:5]</bitRange>
              <description>Transmit Status 1 transmit; the CAN controller is transmitting a message 0 idle </description>
            </field>
            <field>
              <name>rx_status</name>
              <bitRange>[4:4]</bitRange>
              <description>Receive Status 1 receive; the CAN controller is receiving a message 0 idle </description>
            </field>
            <field>
              <name>tx_complete</name>
              <bitRange>[3:3]</bitRange>
              <description>Transmission Complete 1 complete; last requested transmission has been successfully completed 0 incomplete; previously requested transmission is not yet completed </description>
            </field>
            <field>
              <name>tx_buf_status</name>
              <bitRange>[2:2]</bitRange>
              <description>Transmit Buffer Status 1 released; the CPU may write a message into the transmit buffer 0 locked; the CPU cannot access the transmit buffer ; a message is either waiting for transmission or is in the process of being transmitted </description>
            </field>
            <field>
              <name>overrun</name>
              <bitRange>[1:1]</bitRange>
              <description>Data Overrun Status 1 overrun; a message was lost because there was not enough space for that message in the RXFIFO 0 absent; no data overrun has occurred since the last clear data overrun command was given </description>
            </field>
            <field>
              <name>rx_buf_status</name>
              <bitRange>[0:0]</bitRange>
              <description>Receive Buffer Status 1 full; one or more complete messages are available in the RXFIFO 0 empty; no message is available </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'canctrl_irq': 0xFF80128C-->
          <name>canctrl_irq</name>
          <description>CAN interrupt register reading the register will clear all bits except rx_irq </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000EF</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>bus_error_irq</name>
              <bitRange>[7:7]</bitRange>
              <description>Bus Error Interrupt 1 set; this bit is set when the CAN controller detects an error on the CAN-bus and the bus_error_irq_en bit is set within the interrupt enable register, will only get active again if canctrl_err_code_capture register is read 0 reset </description>
            </field>
            <field>
              <name>arb_lost_irq</name>
              <bitRange>[6:6]</bitRange>
              <description>Arbitration Lost Interrupt 1 set; this bit is set when the CAN controller lost the arbitration and becomes a receiver and the arb_lost_irq_en bit is set within the interrupt enable register, will only get active again if canctrl_arb_lost_capture register is read 0 reset </description>
            </field>
            <field>
              <name>err_passive_irq</name>
              <bitRange>[5:5]</bitRange>
              <description>Error Passive Interrupt 1 set; this bit is set whenever the CAN controller has reached the error passive status (at least one error counter exceeds the protocol-defined level of 127) or if the CAN controller is in the error passive status and enters the error active status again and the err_passive_irq_en bit is set within the interrupt enable register 0 reset </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[4:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>overrun_irq</name>
              <bitRange>[3:3]</bitRange>
              <description>Data Overrun Interrup 1 set; this bit is set on a `0-to-1' transition of the data overrun status bit and the overrun_irq_en bit is set within the interrupt enable register 0 reset </description>
            </field>
            <field>
              <name>warning_irq</name>
              <bitRange>[2:2]</bitRange>
              <description>Error Warning Interrupt 1 set; this bit is set on every change (set and clear) of either the error status or bus status bits and the warning_irq_en bit is set within the interrupt enable register 0 reset </description>
            </field>
            <field>
              <name>tx_irq</name>
              <bitRange>[1:1]</bitRange>
              <description>Transmit Interrupt 1 set; this bit is set whenever the transmit buffer status changes from `0-to-1' (released) and the tx_irq_en bit is set within the interrupt enable register 0 reset </description>
            </field>
            <field>
              <name>rx_irq</name>
              <bitRange>[0:0]</bitRange>
              <description>Receive Interrupt 1 set; this bit is set while the receive FIFO is not empty and the rx_irq_en bit is set within the interrupt enable register 0 reset; no more message is available within the RXFIFO </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'canctrl_irq_en': 0xFF801290-->
          <name>canctrl_irq_en</name>
          <description>CAN interrupt enable register in not extended mode: acceptance_code_0 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000EF</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>bus_error_irq_en</name>
              <bitRange>[7:7]</bitRange>
              <description>Bus Error Interrupt Enable 1 enabled; if an bus error has been detected, the CAN controller requests the respective interrupt 0 disabled </description>
            </field>
            <field>
              <name>arb_lost_irq_en</name>
              <bitRange>[6:6]</bitRange>
              <description>Arbitration Lost Interrupt Enable 1 enabled; if the CAN controller has lost arbitration, the respective interrupt is requested 0 disabled </description>
            </field>
            <field>
              <name>err_passive_irq_en</name>
              <bitRange>[5:5]</bitRange>
              <description>Error Passive Interrupt Enable 1 enabled; if the error status of the CAN controller changes from error active to error passive or vice versa, the respective interrupt is requested 0 disabled </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[4:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>overrun_irq_en</name>
              <bitRange>[3:3]</bitRange>
              <description>Data Overrun Interrupt Enable 1 enabled; if the data overrun status bit is set (see status register; Table 14), the CAN controller requests the respective interrupt 0 disabled </description>
            </field>
            <field>
              <name>warning_irq_en</name>
              <bitRange>[2:2]</bitRange>
              <description>Error Warning Interrupt Enable 1 enabled; if the error or bus status change (see status register), the CAN controller requests the respective interrupt 0 disabled </description>
            </field>
            <field>
              <name>tx_irq_en</name>
              <bitRange>[1:1]</bitRange>
              <description>Transmit Interrupt Enable 1 enabled; when a message has been successfully transmitted or the transmit buffer is accessible again (e.g. after an abort transmission command), the CAN controller requests the respective interrupt 0 disabled </description>
            </field>
            <field>
              <name>rx_irq_en</name>
              <bitRange>[0:0]</bitRange>
              <description>Receive Interrupt Enable 1 enabled; when the receive buffer status is `full' the CAN controller requests the respective interrupt 0 disabled </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'canctrl_not_extended_acceptance_mask0': 0xFF801294-->
          <name>canctrl_not_extended_acceptance_mask0</name>
          <description>CAN not extended acceptance mask register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'canctrl_bus_timing0': 0xFF801298-->
          <name>canctrl_bus_timing0</name>
          <description>CAN bus timing register 0, only writable in reset mode in not extended mode: acceptance_mask_0 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000018</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000007FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:11]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sync_jump_width</name>
              <bitRange>[10:9]</bitRange>
              <description>Synchronization Jump Width To compensate for phase shifts between clock oscillators of different bus controllers, any bus controller must re-synchronize on any relevant signal edge of the current transmission. The synchronization jump width defines the maximum number of clock cycles a bit period may be shortened or lengthened by one re-synchronization: tSJW = tscl * (sync_jump_width + 1) </description>
            </field>
            <field>
              <name>prescaler</name>
              <bitRange>[8:0]</bitRange>
              <description>Baud Rate Prescaler The period of the CAN system clock tscl is programmable and determines the individual bit timing. The CAN system clock is calculated using the following equation: tscl = tCLK * prescaler with tCLK = 10 ns </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'canctrl_bus_timing1': 0xFF80129C-->
          <name>canctrl_bus_timing1</name>
          <description>CAN bus timing register 1, only writable in reset mode </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000001C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00001FBF</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:13]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>tseg2</name>
              <bitRange>[12:8]</bitRange>
              <description>Time Segment 2 (TSEG2) TSEG2 determine the number of clock cycles per bit period and the location of the sample point, where: tTSEG2 = tscl * (tseg2 + 1) </description>
            </field>
            <field>
              <name>oversampling</name>
              <bitRange>[7:7]</bitRange>
              <description>Sampling 1 triple; the bus is sampled three times; recommended for low/medium speed buses (class A and B) where filtering spikes on the bus line is beneficial 0 single; the bus is sampled once; recommended for high speed buses (SAE class C) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[6:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>tseg1</name>
              <bitRange>[5:0]</bitRange>
              <description>Time Segment 1 (TSEG1) TSEG1 determine the number of clock cycles per bit period and the location of the sample point, where: tSYNCSEG = 1 * tscl tTSEG1 = tscl * (tseg1 + 1) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'canctrl_not_extended_data0': 0xFF8012A8-->
          <name>canctrl_not_extended_data0</name>
          <description>CAN not extended data register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000028</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'canctrl_arb_lost_capture': 0xFF8012AC-->
          <name>canctrl_arb_lost_capture</name>
          <description>CAN arbitration lost capture register This register contains information about the bit position of losing arbitration. reading the register will clear all bits in not extended mode: data1 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000002C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000001F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>position</name>
              <bitRange>[4:0]</bitRange>
              <description>Positon where arbitration was lost {              | Decimal value    Position 00         arbitration lost in bit 1 of identifier 01         arbitration lost in bit 2 of identifier 02         arbitration lost in bit 3 of identifier 03         arbitration lost in bit 4 of identifier 04         arbitration lost in bit 5 of identifier 05         arbitration lost in bit 6 of identifier 06         arbitration lost in bit 7 of identifier 07         arbitration lost in bit 8 of identifier 08         arbitration lost in bit 9 of identifier 09         arbitration lost in bit 10 of identifier 10         arbitration lost in bit 11 of identifier 11         arbitration lost in bit SRTR; (bit RTR for standard frame messages) 12         arbitration lost in bit IDE 13         arbitration lost in bit 12 of identifier; extended frame messages only 14         arbitration lost in bit 13 of identifier; extended frame messages only 15         arbitration lost in bit 14 of identifier; extended frame messages only 16         arbitration lost in bit 15 of identifier; extended frame messages only 17         arbitration lost in bit 16 of identifier; extended frame messages only 18         arbitration lost in bit 17 of identifier; extended frame messages only 19         arbitration lost in bit 18 of identifier; extended frame messages only 20         arbitration lost in bit 19 of identifier; extended frame messages only 21         arbitration lost in bit 20 of identifier; extended frame messages only 22         arbitration lost in bit 21 of identifier; extended frame messages only 23         arbitration lost in bit 22 of identifier; extended frame messages only 24         arbitration lost in bit 23 of identifier; extended frame messages only 25         arbitration lost in bit 24 of identifier; extended frame messages only 26         arbitration lost in bit 25 of identifier; extended frame messages only 27         arbitration lost in bit 26 of identifier; extended frame messages only 28         arbitration lost in bit 27 of identifier; extended frame messages only 29         arbitration lost in bit 28 of identifier; extended frame messages only 30         arbitration lost in bit 29 of identifier; extended frame messages only 31         arbitration lost in bit RTR; extended frame messages only  } </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'canctrl_err_code_capture': 0xFF8012B0-->
          <name>canctrl_err_code_capture</name>
          <description>CAN error code capture register This register contains information about the type and location of errors on the bus. reading the register will clear all bits in not extended mode: data2 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000030</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>err_code</name>
              <bitRange>[7:6]</bitRange>
              <description>Error code {                  | Binary value      Code 00            bit error 01            form error 10            stuff error 11            other type of error } </description>
            </field>
            <field>
              <name>direction</name>
              <bitRange>[5:5]</bitRange>
              <description>Direction 1 RX; error occurred during reception 0 TX; error occurred during transmission </description>
            </field>
            <field>
              <name>segment</name>
              <bitRange>[4:0]</bitRange>
              <description>Frame segment where error was detected {                  | Binary value       Segment 00011           start of frame 00010           ID.28 to ID.21 00110           ID.20 to ID.18 00100           bit SRTR 00101           bit IDE 00111           ID.17 to ID.13 01111           ID.12 to ID.5 01110           ID.4 to ID.0 01100           bit RTR 01101           reser ved bit 1 01001           reser ved bit 0 01011           data length code 01010           data field 01000           CRC sequence 11000           CRC delimiter 11001           acknowledge slot 11011           acknowledge delimiter 11010           end of frame 10010           intermission 10001           active error flag 10110           passive error flag 10011           tolerate dominant bits 10111           error delimiter 11100           overload flag } </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'canctrl_err_warning_limit': 0xFF8012B4-->
          <name>canctrl_err_warning_limit</name>
          <description>CAN error warning limit register, only writable in reset mode in not extended mode: data3 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000034</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000060</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>limit</name>
              <bitRange>[7:0]</bitRange>
              <description>error warning limit </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'canctrl_rx_error_cnt': 0xFF8012B8-->
          <name>canctrl_rx_error_cnt</name>
          <description>CAN RX error counter register, only writable in reset mode The RX error counter register reflects the current value of the receive error counter. If a bus-off event occurs, the RX error counter is initialized to logic 0. The time bus-off is valid, writing to this register has no effect. Note, that a CPU-forced content change of the RX error counter is only possible, if the reset mode was entered previously. An error status change (see status register), an error warning or an error passive interrupt forced by the new register content will not occur, until the reset mode is cancelled again. in not extended mode: data4 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000038</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>rx_err</name>
              <bitRange>[7:0]</bitRange>
              <description>rx error counter </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'canctrl_tx_error_cnt': 0xFF8012BC-->
          <name>canctrl_tx_error_cnt</name>
          <description>CAN TX error counter register, only writable in reset mode The TX error counter register reflects the current value of the transmit error counter. If a bus-off event occurs, the TX error counter is initialized to 127 to count the minimum protocol-defined time (128 occurrences of the bus-free signal). Reading the TX error counter during this time gives information about the status of the bus-off recovery. If bus-off is active, a write access to TXERR in the range from 0 to 254 clears the bus-off flag and the controller will wait for one occurrence of 11 consecutive recessive bits (bus-free) after the reset mode has been cleared. Writing 255 to TXERR allows to initiate a CPU-driven bus-off event. It should be noted that a CPU-forced content change of the TX error counter is only possible, if the reset mode was entered previously. An error or bus status change (see status register), an error warning or an error passive interrupt forced by the new register content will not occur until the reset mode is cancelled again. After leaving the reset mode, the new TX counter content is interpreted and the bus-off event is performed in the same way, as if it was forced by a bus error event. That means, that the reset mode is entered again, the TX error counter is initialized to 127, the RX counter is cleared and all concerned status and interrupt register bits are set. Clearing of reset mode now will perform the protocol-defined bus-off recovery sequence (waiting for 128 occurrences of the bus-free signal). If the reset mode is entered again before the end of bus-off recovery (TXERR &gt; 0), bus-off keeps active and TXERR is frozen. in not extended mode: data5 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000003C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>tx_err</name>
              <bitRange>[7:0]</bitRange>
              <description>tx error counter </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'canctrl_data0': 0xFF8012C0-->
          <name>canctrl_data0</name>
          <description>CAN data register 0 This register has multiple functions depending on reset mode and read or write access. {               |     |  Reset mode:      R/W: Read or write acceptance code 0  Operating mode:   R:  Standard frame: Read RX frame information                        Extended frame: Read RX frame information                    W:  Standard frame: Write TX frame information                        Extended frame: Write TX frame information } in not extended mode: data6 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000040</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>data</name>
              <bitRange>[7:0]</bitRange>
              <description>register content (rx data, tx data or acceptance code) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'canctrl_data1': 0xFF8012C4-->
          <name>canctrl_data1</name>
          <description>CAN data register 1 This register has multiple functions depending on reset mode and read or write access. {               |     |  Reset mode:      R/W: Read or write acceptance code 1  Operating mode:   R:  Standard frame: Read RX identifier 1                        Extended frame: Read RX identifier 1                    W:  Standard frame: Write TX identifier 1                        Extended frame: Write TX identifier 1 } in not extended mode: data7 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000044</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>data</name>
              <bitRange>[7:0]</bitRange>
              <description>register content (rx data, tx data or acceptance code) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'canctrl_data2': 0xFF8012C8-->
          <name>canctrl_data2</name>
          <description>CAN data register 2 This register has multiple functions depending on reset mode and read or write access. {               |     |  Reset mode:      R/W: Read or write acceptance code 2  Operating mode:   R:  Standard frame: Read RX identifier 2                        Extended frame: Read RX identifier 2                    W:  Standard frame: Write TX identifier 2                        Extended frame: Write TX identifier 2 } in not extended mode: data8 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000048</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>data</name>
              <bitRange>[7:0]</bitRange>
              <description>register content (rx data, tx data or acceptance code) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'canctrl_data3': 0xFF8012CC-->
          <name>canctrl_data3</name>
          <description>CAN data register 3 This register has multiple functions depending on reset mode and read or write access. {               |     |  Reset mode:      R/W: Read or write acceptance code 3  Operating mode:   R:  Standard frame: Read RX data 1                        Extended frame: Read RX identifier 3                    W:  Standard frame: Write TX data 1                        Extended frame: Write TX identifier 3 } in not extended mode: data9 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000004C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>data</name>
              <bitRange>[7:0]</bitRange>
              <description>register content (rx data, tx data or acceptance code) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'canctrl_data4': 0xFF8012D0-->
          <name>canctrl_data4</name>
          <description>CAN data register 4 This register has multiple functions depending on reset mode and read or write access. {               |     |  Reset mode:      R/W: Read or write acceptance mask 0  Operating mode:   R:  Standard frame: Read RX data 2                        Extended frame: Read RX identifier 4                    W:  Standard frame: Write TX data 2                        Extended frame: Write TX identifier 4 } </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000050</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>data</name>
              <bitRange>[7:0]</bitRange>
              <description>register content (rx data, tx data or acceptance mask) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'canctrl_data5': 0xFF8012D4-->
          <name>canctrl_data5</name>
          <description>CAN data register 5 This register has multiple functions depending on reset mode and read or write access. {               |     |  Reset mode:      R/W: Read or write acceptance mask 1  Operating mode:   R:  Standard frame: Read RX data 3                        Extended frame: Read RX data 1                    W:  Standard frame: Write TX data 3                        Extended frame: Write TX data 1 } </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000054</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>data</name>
              <bitRange>[7:0]</bitRange>
              <description>register content (rx data, tx data or acceptance mask) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'canctrl_data6': 0xFF8012D8-->
          <name>canctrl_data6</name>
          <description>CAN data register 6 This register has multiple functions depending on reset mode and read or write access. {               |     |  Reset mode:      R/W: Read or write acceptance mask 2  Operating mode:   R:  Standard frame: Read RX data 4                        Extended frame: Read RX data 2                    W:  Standard frame: Write TX data 4                        Extended frame: Write TX data 2 } </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000058</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>data</name>
              <bitRange>[7:0]</bitRange>
              <description>register content (rx data, tx data or acceptance mask) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'canctrl_data7': 0xFF8012DC-->
          <name>canctrl_data7</name>
          <description>CAN data register 7 This register has multiple functions depending on reset mode and read or write access. {               |     |  Reset mode:      R/W: Read or write acceptance mask 3  Operating mode:   R:  Standard frame: Read RX data 5                        Extended frame: Read RX data 3                    W:  Standard frame: Write TX data 5                        Extended frame: Write TX data 3 } </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000005C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>data</name>
              <bitRange>[7:0]</bitRange>
              <description>register content (rx data, tx data or acceptance mask) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'canctrl_data8': 0xFF8012E0-->
          <name>canctrl_data8</name>
          <description>CAN data register 8 This register has multiple functions depending on reset mode and read or write access. {               |     |  Reset mode:      R/W: reserved  Operating mode:   R:  Standard frame: Read RX data 6                        Extended frame: Read RX data 4                    W:  Standard frame: Write TX data 6                        Extended frame: Write TX data 4 } </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000060</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>data</name>
              <bitRange>[7:0]</bitRange>
              <description>register content (rx data or tx data) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'canctrl_data9': 0xFF8012E4-->
          <name>canctrl_data9</name>
          <description>CAN data register 9 This register has multiple functions depending on reset mode and read or write access. {               |     |  Reset mode:      R/W: reserved  Operating mode:   R:  Standard frame: Read RX data 7                        Extended frame: Read RX data 5                    W:  Standard frame: Write TX data 7                        Extended frame: Write TX data 5 } </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000064</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>data</name>
              <bitRange>[7:0]</bitRange>
              <description>register content (rx data or tx data) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'canctrl_data10': 0xFF8012E8-->
          <name>canctrl_data10</name>
          <description>CAN data register 10 This register has multiple functions depending on reset mode and read or write access. {               |     |  Reset mode:      R/W: reserved  Operating mode:   R:  Standard frame: Read RX data 8                        Extended frame: Read RX data 6                    W:  Standard frame: Write TX data 8                        Extended frame: Write TX data 6 } </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000068</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>data</name>
              <bitRange>[7:0]</bitRange>
              <description>register content (rx data or tx data) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'canctrl_data11': 0xFF8012EC-->
          <name>canctrl_data11</name>
          <description>CAN data register 11 This register has multiple functions depending on reset mode and read or write access. {               |     |  Reset mode:      R/W: reserved  Operating mode:   R:  Standard frame: reserved                        Extended frame: Read RX data 7                    W:  Standard frame: reserved                        Extended frame: Write TX data 7 } </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000006C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>data</name>
              <bitRange>[7:0]</bitRange>
              <description>register content (rx data or tx data) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'canctrl_data12': 0xFF8012F0-->
          <name>canctrl_data12</name>
          <description>CAN data register 12 This register has multiple functions depending on reset mode and read or write access. {               |     |  Reset mode:      R/W: reserved  Operating mode:   R:  Standard frame: reserved                        Extended frame: Read RX data 8                    W:  Standard frame: reserved                        Extended frame: Write TX data 8 } </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000070</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>data</name>
              <bitRange>[7:0]</bitRange>
              <description>register content (rx data or tx data) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'canctrl_rx_message_cnt': 0xFF8012F4-->
          <name>canctrl_rx_message_cnt</name>
          <description>CAN RX message counter register Reflects the number of messages available within the RXFIFO. The value is incremented with each receive event and decremented by the release receive buffer command. After any reset event, this register is cleared. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000074</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000007F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>rx_msg_cnt</name>
              <bitRange>[6:0]</bitRange>
              <description>rx message counter </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'canctrl_mode_control': 0xFF8012FC-->
          <name>canctrl_mode_control</name>
          <description>CAN mode control register, only writable in reset mode </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000007C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000080</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>mode</name>
              <bitRange>[7:7]</bitRange>
              <description>0: BasicCAN mode, 1: PeliCAN mode recommended value is 1 (PeliCAN mode), The here given register map of all registers of the CAN controller is valid for PeliCAN only. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[6:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>mled_ctrl_app</name>
      <description>mled_ctrl_app</description>
      <baseAddress>0xFF801300</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>256</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <!--Absolute address of 'mled_ctrl_app_cfg': 0xFF801300-->
          <name>mled_ctrl_app_cfg</name>
          <description>Global configuration register. This register controls global configuration options for all Multi-LED outputs. Description of Multi-LED control module operation: a) Time-multiplexed PWM mode: Each output drives two LEDs: Low-side and high-side LED. Three states of the output pin are possible:   High (i.e. the low-side LED is on), low (i.e. the high-side LED is on), or high-z (i.e. both LEDs are off). The PWM period, determined by bit field prescale_counter_max, is the same for all outputs. The prescale   counter will be increased by the netX system clock (i.e. 100 MHz). A second counter (the PWM counter) will be increased when the prescale counter reaches its configured max. value. The PWM counter is a   fixed-width counter and always counts from 0 to 511. If the PWM counter is in the range of 0 - 255, the high-side LED will be driven depending on the configured   switch-on time (registers on_time[x], with x being an even number). The output pin will be driven low when the high-side   phase starts. If the PWM counter reaches on_time[x] - 1, the output pin will switch to high-z state. If the PWM counter is in the range of 256 - 511, the low-side LED will be driven depending on the configured   switch-on time (registers on_time[y], with y being an odd number). The output pin will be driven high when the low-side   phase starts. If the PWM counter reaches 256 + on_time[y] - 1, the output pin will switch to high-z state. The state of an LED depends on the input value selected by the input multiplexer. For a list of   selectable signals, see register mled_ctrl_output_sel[0]. When the selected input signal is off, the   output signal will be high-z during the entire corresponding PWM phase.  b) Pass-through mode: This mode disables the time-multiplexed PWM entirely and a configured signal will be output directly or   inverted (delayed by one netX system cycle). This mode will be used when all bits of bit field sel of the   output phase 0 configuration register (high-side LED) are set to '1'. The input signal (and inversion)   is selected by the corresponding phase 1 configuration register (low-side LED). The output can be configured   to high-z state if the corresponding phase 1 on_time register is set to '0', therefore it must be set != '0' for   regular pass-through operation (i.e. the output will be driven high or low depending on the input signal).  c) Multi-LED internal blink generator: The blink signal synchronizes the blinking of several LEDs. Bit field blink_counter_max determines the blink   frequency which is the same for all outputs configured to blink mode. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00018FFE</resetValue>
          <resetMask>0x000FFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:20]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>blink_counter_max</name>
              <bitRange>[19:11]</bitRange>
              <description>Maximum value the blink counter will count to. The blink counter determines the blink frequency: f_blink = 50 Hz / (blink_counter_max + 1) blink_counter_max = (50 Hz / f_blink) - 1. The range of the blink frequency is therefore within ~0.1 Hz and 50 Hz. </description>
            </field>
            <field>
              <name>prescale_counter_max</name>
              <bitRange>[10:1]</bitRange>
              <description>Maximum value the prescale counter will count to. The prescale counter determines the PWM frequency of all outputs: f_pwm = f_clk / (512 * (prescale_counter_max + 1)) prescale_counter_max = (f_clk / (512 * f_pwm)) - 1 with f_clk = 100 MHz (netX system frequency). The range of the PWM frequency is therefore within ~191 Hz and ~195 kHz. </description>
            </field>
            <field>
              <name>enable</name>
              <bitRange>[0:0]</bitRange>
              <description>Writing a '1' to this bit will enable the MLED_CTRL_APP module. When disabled, all counters will be stopped to save power and outputs will be switched to high-z state. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mled_ctrl_app_output_sel[%s]': 0xFF801304-->
          <dim>16</dim>
          <dimIncrement>4</dimIncrement>
          <name>mled_ctrl_app_output_sel[%s]</name>
          <description>Output 0 phase 0 (high-side LED) configuration. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000007</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:3]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sel</name>
              <bitRange>[2:1]</bitRange>
              <description>Selection of the signal connected to this output. {        | Value    Input 0        always off 1        line register 2        MLED_CTRL blink 3        pass-through (for phase 0 registers) / reserved (for phase 1 registers) } </description>
            </field>
            <field>
              <name>inv</name>
              <bitRange>[0:0]</bitRange>
              <description>Invert input signal. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mled_ctrl_app_output_on_time[%s]': 0xFF801344-->
          <dim>16</dim>
          <dimIncrement>4</dimIncrement>
          <name>mled_ctrl_app_output_on_time[%s]</name>
          <description>Output 0 phase 0 (high-side LED) switch-on time. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000044</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x000000FF</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[7:0]</bitRange>
              <description>Switch-on time of this LED. This value determines the period during which the output is active. The value helps achieve a consistent brightness of different LED types. Dimming individual LEDs is also possible. Possible values are 0 (off) to 255 (on for the full phase minus one PWM tick). </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mled_ctrl_app_line0': 0xFF801384-->
          <name>mled_ctrl_app_line0</name>
          <description>Line register. The line register allows changing all LEDs (configured to line mode) at once to a new value. Note: The change will take effect at the start of the next PWM period (when the output operates in   time-multiplexed PWM mode). In pass-through mode, the change will take effect immediately. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000084</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[15:0]</bitRange>
              <description>MLED output values 15..0 when line mode is selected in the corresponding 'sel' register. </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>gpio_app</name>
      <description>gpio_app</description>
      <baseAddress>0xFF801400</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>256</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>gpio_app0</name>
        <value>54</value>
      </interrupt>
      <interrupt>
        <name>gpio_app1</name>
        <value>55</value>
      </interrupt>
      <interrupt>
        <name>gpio_app2</name>
        <value>56</value>
      </interrupt>
      <interrupt>
        <name>gpio_app3</name>
        <value>57</value>
      </interrupt>
      <interrupt>
        <name>gpio_app4</name>
        <value>58</value>
      </interrupt>
      <interrupt>
        <name>gpio_app5</name>
        <value>59</value>
      </interrupt>
      <interrupt>
        <name>gpio_app6</name>
        <value>60</value>
      </interrupt>
      <interrupt>
        <name>gpio_app7</name>
        <value>61</value>
      </interrupt>
      <interrupt>
        <name>gpio_app_timer0</name>
        <value>62</value>
      </interrupt>
      <interrupt>
        <name>gpio_app_timer1</name>
        <value>63</value>
      </interrupt>
      <interrupt>
        <name>gpio_app_timer2</name>
        <value>64</value>
      </interrupt>
      <registers>
        <register>
          <!--Absolute address of 'gpio_app_cfg[%s]': 0xFF801400-->
          <dim>8</dim>
          <dimIncrement>4</dimIncrement>
          <name>gpio_app_cfg[%s]</name>
          <description>GPIO_APP pin 0 config register: This register is accessible via address areas inlogic_app and xpic_app_system. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00001FFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:13]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>blink_once</name>
              <bitRange>[12:12]</bitRange>
              <description>Run blink sequence only once (blink mode only) </description>
            </field>
            <field>
              <name>blink_len</name>
              <bitRange>[11:7]</bitRange>
              <description>Length of blink sequence minus 1 (blink mode only) 00000: use bit 0 of gpio_app_tc 00001: use bits 0..1 of gpio_app_tc 00010: use bits 0..2 of gpio_app_tc ... 11111: use bits 0..31 of gpio_app_tc </description>
            </field>
            <field>
              <name>count_ref</name>
              <bitRange>[6:5]</bitRange>
              <description>counter reference 00: counter 0 01: counter 1 10: counter 2 11: sys_time (global system time) </description>
            </field>
            <field>
              <name>inv</name>
              <bitRange>[4:4]</bitRange>
              <description>1: invert input/output value 0: do not invert input/output </description>
            </field>
            <field>
              <name>mode</name>
              <bitRange>[3:0]</bitRange>
              <description>defines the gp input or output mode - depends on io_cfg Input modes: 0000: read mode 0001: capture continued at rising edge (allows gpio_app_irq on each capture) 0010: capture once at rising edge (reset gpio_app_irq to capture again) 0011: capture once at high level (reset gpio_app_irq to capture again) Output modes: 0100: set to 0 0101: set to 1 0110: set to gpio_app_line[0] 0111: pwm mode, direct threshold update (might cause hazards on output) 1000: blink mode Multi pin modes: 1111: pwm2-mode with threshold update at counter=0 from gpio_app_tc[n+1] register (hazard-free) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'gpio_app_tc[%s]': 0xFF801420-->
          <dim>8</dim>
          <dimIncrement>4</dimIncrement>
          <name>gpio_app_tc[%s]</name>
          <description>GPIO_APP pin 0 threshold or capture register: This register is accessible via address areas inlogic_app and xpic_app_system. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Threshold/Capture register: PWM mode (threshold): { | The counter threshold value equals the number of inactive clock cycles per period (cycles with pwm=0). Therefore it is interpreted differently in symmetrical and asymmetrical counter mode: Asymmetrical mode (sawtooth): pwm = (counter &gt;= gpio_app_tc) Symmetrical mode (triangle) : Counter is compared with gpio_app_tc[31:1], gpio_app_tc[0] extends the inactive phase by 1 clock cycle only while counting up. This allows running a 10 ns resolution even in symmetrical mode.} Capture mode (capture register) { | In the capture mode, this register holds the captured counter value.} Blink mode (blink sequence) { | In the blink mode, this register holds the blinking sequence starting from bit 0.} </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'gpio_app_counter_ctrl[%s]': 0xFF801440-->
          <dim>3</dim>
          <dimIncrement>4</dimIncrement>
          <name>gpio_app_counter_ctrl[%s]</name>
          <description>GPIO_APP counter0 control register: This register is accessible via address areas inlogic_app and xpic_app_system. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000040</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000003FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:10]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>gpio_ref</name>
              <bitRange>[9:7]</bitRange>
              <description>gpio reference (0 - 7) </description>
            </field>
            <field>
              <name>event_act</name>
              <bitRange>[6:5]</bitRange>
              <description>Define action of selected external event (dependent on sel_event, gpio_ref) 00: count every clock cycle, ignore external events 01: count only external events (edge or level according to bit sel_event) 10: enable watchdog mode of counter (external event will be reset without IRQ, overflow generates IRQ). 11: enable automatic run mode (external event sets run bit, used for DC-DC PWM in combination with bit once=1) </description>
            </field>
            <field>
              <name>once</name>
              <bitRange>[4:4]</bitRange>
              <description>1: count once (reset run bit after 1 period) 0: count continuously </description>
            </field>
            <field>
              <name>sel_event</name>
              <bitRange>[3:3]</bitRange>
              <description>select external event 0: high level, invert gpio in register gpio_app_cfg to select low level 1: pos. edge, invert gpio in register gpio_app_cfg to select neg. edge </description>
            </field>
            <field>
              <name>irq_en</name>
              <bitRange>[2:2]</bitRange>
              <description>1: enable interrupt request on sel_event 0: disable interrupt request </description>
            </field>
            <field>
              <name>sym_nasym</name>
              <bitRange>[1:1]</bitRange>
              <description>1: symmetric mode (triangle) 0: asymmetric mode (sawtooth) </description>
            </field>
            <field>
              <name>run</name>
              <bitRange>[0:0]</bitRange>
              <description>1: start counter, counter is running 0: stop counter </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'gpio_app_counter_max[%s]': 0xFF80144C-->
          <dim>3</dim>
          <dimIncrement>4</dimIncrement>
          <name>gpio_app_counter_max[%s]</name>
          <description>GPIO_APP counter0 max value: This register is accessible via address areas inlogic_app and xpic_app_system. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000004C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Asymmetric mode: Counting period in cc + 1 Symmetric mode: Counting period in cc </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'gpio_app_counter_cnt[%s]': 0xFF801458-->
          <dim>3</dim>
          <dimIncrement>4</dimIncrement>
          <name>gpio_app_counter_cnt[%s]</name>
          <description>GPIO_APP counter0 current value: This register is accessible via address areas inlogic_app and xpic_app_system. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000058</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>current counter value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'gpio_app_line': 0xFF801464-->
          <name>gpio_app_line</name>
          <description>GPIO_APP line register This register is accessible via address areas inlogic_app and xpic_app_system. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000064</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[7:0]</bitRange>
              <description>gpio_app output values </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'gpio_app_in': 0xFF801468-->
          <name>gpio_app_in</name>
          <description>GPIO_APP latched inputs register: This register is accessible via address areas inlogic_app and xpic_app_system. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000068</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[7:0]</bitRange>
              <description>gpio_app input values </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'gpio_app_irq_raw': 0xFF80146C-->
          <name>gpio_app_irq_raw</name>
          <description>GPIO_APP raw IRQ register: Read access shows the status of unmasked IRQs.   IRQs are set automatically and reset by writing to this register: Write access with '1' resets the corresponding IRQ. Write access with '0' does not influence this bit. This register is accessible via address areas inlogic_app and xpic_app_system. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000006C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>gpio_app7</name>
              <bitRange>[7:7]</bitRange>
              <description>Interrupt bit for GPIO_APP7 </description>
            </field>
            <field>
              <name>gpio_app6</name>
              <bitRange>[6:6]</bitRange>
              <description>Interrupt bit for GPIO_APP6 </description>
            </field>
            <field>
              <name>gpio_app5</name>
              <bitRange>[5:5]</bitRange>
              <description>Interrupt bit for GPIO_APP5 </description>
            </field>
            <field>
              <name>gpio_app4</name>
              <bitRange>[4:4]</bitRange>
              <description>Interrupt bit for GPIO_APP4 </description>
            </field>
            <field>
              <name>gpio_app3</name>
              <bitRange>[3:3]</bitRange>
              <description>Interrupt bit for GPIO_APP3 </description>
            </field>
            <field>
              <name>gpio_app2</name>
              <bitRange>[2:2]</bitRange>
              <description>Interrupt bit for GPIO_APP2 </description>
            </field>
            <field>
              <name>gpio_app1</name>
              <bitRange>[1:1]</bitRange>
              <description>Interrupt bit for GPIO_APP1 </description>
            </field>
            <field>
              <name>gpio_app0</name>
              <bitRange>[0:0]</bitRange>
              <description>Interrupt bit for GPIO_APP0 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'gpio_app_irq_masked': 0xFF801470-->
          <name>gpio_app_irq_masked</name>
          <description>GPIO_APP masked IRQ register: This register exists 2x for the different system busses (address areas) it is connected to.   This allows 2 CPUs to work in parallel on this module: ARM_APP, xPIC_APP. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000070</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>gpio_app7</name>
              <bitRange>[7:7]</bitRange>
              <description>Interrupt bit for GPIO_APP7 </description>
            </field>
            <field>
              <name>gpio_app6</name>
              <bitRange>[6:6]</bitRange>
              <description>Interrupt bit for GPIO_APP6 </description>
            </field>
            <field>
              <name>gpio_app5</name>
              <bitRange>[5:5]</bitRange>
              <description>Interrupt bit for GPIO_APP5 </description>
            </field>
            <field>
              <name>gpio_app4</name>
              <bitRange>[4:4]</bitRange>
              <description>Interrupt bit for GPIO_APP4 </description>
            </field>
            <field>
              <name>gpio_app3</name>
              <bitRange>[3:3]</bitRange>
              <description>Interrupt bit for GPIO_APP3 </description>
            </field>
            <field>
              <name>gpio_app2</name>
              <bitRange>[2:2]</bitRange>
              <description>Interrupt bit for GPIO_APP2 </description>
            </field>
            <field>
              <name>gpio_app1</name>
              <bitRange>[1:1]</bitRange>
              <description>Interrupt bit for GPIO_APP1 </description>
            </field>
            <field>
              <name>gpio_app0</name>
              <bitRange>[0:0]</bitRange>
              <description>Interrupt bit for GPIO_APP0 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'gpio_app_irq_mask_set': 0xFF801474-->
          <name>gpio_app_irq_mask_set</name>
          <description>GPIO_APP interrupt mask set: The interrupt mask register exists 2x for the different system busses (address areas) it is connected to.   This allows 2 CPUs to work in parallel on this module: ARM_APP, xPIC_APP. The inlogic_app IRQ mask enables interrupt requests for ARM_APP.   The xpic_app_system IRQ mask enables interrupt requests for xPIC_APP.   Since different software tasks might change its bits,   the IRQ mask register is not writable directly, but by set and reset masks: Write access with '1' sets the interrupt mask bit (enables the interrupt request for the corresponding interrupt source). Write access with '0' does not influence this bit. Read access shows the current interrupt mask. Note: Before activating the interrupt mask, delete old pending interrupts by writing the same value to gpio_app_irq_raw. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000074</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>gpio_app7</name>
              <bitRange>[7:7]</bitRange>
              <description>Interrupt bit for GPIO_APP7 </description>
            </field>
            <field>
              <name>gpio_app6</name>
              <bitRange>[6:6]</bitRange>
              <description>Interrupt bit for GPIO_APP6 </description>
            </field>
            <field>
              <name>gpio_app5</name>
              <bitRange>[5:5]</bitRange>
              <description>Interrupt bit for GPIO_APP5 </description>
            </field>
            <field>
              <name>gpio_app4</name>
              <bitRange>[4:4]</bitRange>
              <description>Interrupt bit for GPIO_APP4 </description>
            </field>
            <field>
              <name>gpio_app3</name>
              <bitRange>[3:3]</bitRange>
              <description>Interrupt bit for GPIO_APP3 </description>
            </field>
            <field>
              <name>gpio_app2</name>
              <bitRange>[2:2]</bitRange>
              <description>Interrupt bit for GPIO_APP2 </description>
            </field>
            <field>
              <name>gpio_app1</name>
              <bitRange>[1:1]</bitRange>
              <description>Interrupt bit for GPIO_APP1 </description>
            </field>
            <field>
              <name>gpio_app0</name>
              <bitRange>[0:0]</bitRange>
              <description>Interrupt bit for GPIO_APP0 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'gpio_app_irq_mask_rst': 0xFF801478-->
          <name>gpio_app_irq_mask_rst</name>
          <description>GPIO_APP interrupt mask reset: This reset mask serves to disable the interrupt requests for the corresponding interrupt sources.   Like irq_msk_set, this address exists for the following address areas: inlogic_app, xpic_app_system. Write access with '1' resets the interrupt mask bit (disables the interrupt request for the corresponding interrupt source). Write access with '0' does not influence this bit. Read access shows the current interrupt mask. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000078</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>gpio_app7</name>
              <bitRange>[7:7]</bitRange>
              <description>Interrupt bit for GPIO_APP7 </description>
            </field>
            <field>
              <name>gpio_app6</name>
              <bitRange>[6:6]</bitRange>
              <description>Interrupt bit for GPIO_APP6 </description>
            </field>
            <field>
              <name>gpio_app5</name>
              <bitRange>[5:5]</bitRange>
              <description>Interrupt bit for GPIO_APP5 </description>
            </field>
            <field>
              <name>gpio_app4</name>
              <bitRange>[4:4]</bitRange>
              <description>Interrupt bit for GPIO_APP4 </description>
            </field>
            <field>
              <name>gpio_app3</name>
              <bitRange>[3:3]</bitRange>
              <description>Interrupt bit for GPIO_APP3 </description>
            </field>
            <field>
              <name>gpio_app2</name>
              <bitRange>[2:2]</bitRange>
              <description>Interrupt bit for GPIO_APP2 </description>
            </field>
            <field>
              <name>gpio_app1</name>
              <bitRange>[1:1]</bitRange>
              <description>Interrupt bit for GPIO_APP1 </description>
            </field>
            <field>
              <name>gpio_app0</name>
              <bitRange>[0:0]</bitRange>
              <description>Interrupt bit for GPIO_APP0 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'gpio_app_cnt_irq_raw': 0xFF80147C-->
          <name>gpio_app_cnt_irq_raw</name>
          <description>Counter raw IRQ register: Read access shows the status of unmasked IRQs.   IRQs are set automatically and reset by writing to this register: Write access with '1' resets the corresponding IRQ. Write access with '0' does not influence this bit. This register is accessible via address areas inlogic_app and xpic_app_system. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000007C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000007</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:3]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>cnt2</name>
              <bitRange>[2:2]</bitRange>
              <description>Interrupt bit for counter2 </description>
            </field>
            <field>
              <name>cnt1</name>
              <bitRange>[1:1]</bitRange>
              <description>Interrupt bit for counter1 </description>
            </field>
            <field>
              <name>cnt0</name>
              <bitRange>[0:0]</bitRange>
              <description>Interrupt bit for counter0 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'gpio_app_cnt_irq_masked': 0xFF801480-->
          <name>gpio_app_cnt_irq_masked</name>
          <description>Counter masked IRQ register: Read access shows the status of masked IRQs (cnt_irq_raw AND cnt_irq_mask). This register exists 2x for the different system busses (address areas) it is connected to.   This allows 2 CPUs to work in parallel on this module: ARM_APP, xPIC_APP. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000080</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000007</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:3]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>cnt2</name>
              <bitRange>[2:2]</bitRange>
              <description>Interrupt bit for counter2 </description>
            </field>
            <field>
              <name>cnt1</name>
              <bitRange>[1:1]</bitRange>
              <description>Interrupt bit for counter1 </description>
            </field>
            <field>
              <name>cnt0</name>
              <bitRange>[0:0]</bitRange>
              <description>Interrupt bit for counter0 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'gpio_app_cnt_irq_mask_set': 0xFF801484-->
          <name>gpio_app_cnt_irq_mask_set</name>
          <description>Counter interrupt mask set: The interrupt mask register exists 2x for the different system busses (address areas) it is connected to.   This allows 2 CPUs to work in parallel on this module: ARM_APP, xPIC_APP. The inlogic_app IRQ mask enables interrupt requests for ARM_APP.   The xpic_app_system IRQ mask enables interrupt requests for xPIC_APP.   Since different software tasks might change its bits,   the IRQ mask register is not writable directly, but by set and reset masks: Write access with '1' sets the interrupt mask bit (enables the interrupt request for the corresponding interrupt source). Write access with '0' does not influence this bit. Read access shows the current interrupt mask. Note: Before activating the interrupt mask, delete old pending interrupts by writing the same value to cnt_irq_raw. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000084</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000007</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:3]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>cnt2</name>
              <bitRange>[2:2]</bitRange>
              <description>Interrupt bit for counter2 </description>
            </field>
            <field>
              <name>cnt1</name>
              <bitRange>[1:1]</bitRange>
              <description>Interrupt bit for counter1 </description>
            </field>
            <field>
              <name>cnt0</name>
              <bitRange>[0:0]</bitRange>
              <description>Interrupt bit for counter0 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'gpio_app_cnt_irq_mask_rst': 0xFF801488-->
          <name>gpio_app_cnt_irq_mask_rst</name>
          <description>Counter interrupt mask reset: This reset mask serves to disable the interrupt requests for the corresponding interrupt sources.   Like cnt_irq_msk_set, this address exists for the following address areas: inlogic_app, xpic_app_system. Write access with '1' resets the interrupt mask bit (disables the interrupt request for the corresponding interrupt source). Write access with '0' does not influence this bit. Read access shows the current interrupt mask. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000088</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000007</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:3]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>cnt2</name>
              <bitRange>[2:2]</bitRange>
              <description>Interrupt bit for counter2 </description>
            </field>
            <field>
              <name>cnt1</name>
              <bitRange>[1:1]</bitRange>
              <description>Interrupt bit for counter1 </description>
            </field>
            <field>
              <name>cnt0</name>
              <bitRange>[0:0]</bitRange>
              <description>Interrupt bit for counter0 </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>pio_app</name>
      <description>pio_app</description>
      <baseAddress>0xFF801500</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>256</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>pio0_app</name>
        <value>65</value>
      </interrupt>
      <interrupt>
        <name>pio1_app</name>
        <value>66</value>
      </interrupt>
      <interrupt>
        <name>pio2_app</name>
        <value>67</value>
      </interrupt>
      <interrupt>
        <name>pio3_app</name>
        <value>68</value>
      </interrupt>
      <registers>
        <register>
          <!--Absolute address of 'pio_in': 0xFF801500-->
          <name>pio_in</name>
          <description>PIO input line status register. Each PIO input status can also be read from dedicated PIOx input state register. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x1FFFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:29]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[28:0]</bitRange>
              <description>PIO input states (LSB: PIO0). </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pio_out': 0xFF801504-->
          <name>pio_out</name>
          <description>PIO output drive level line register. Each PIOs output drive level can also be programmed by dedicated PIOx output drive level register. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x1FFFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:29]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[28:0]</bitRange>
              <description>PIO output drive levels (LSB: PIO0). </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pio_oe': 0xFF801508-->
          <name>pio_oe</name>
          <description>PIO output enable line register. Each PIOs output enable can also be programmed by dedicated PIOx output enable register. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x1FFFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:29]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[28:0]</bitRange>
              <description>PIO output enables (LSB: PIO0). </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pio_io_link_in': 0xFF80150C-->
          <name>pio_io_link_in</name>
          <description>IO-Link input values. This register collects the inputs of 8 IO-Link ports for use in IO-Link IO-mode.   In this mode the output and output-enable values are set by PIO pins independant on   xPIC or IO-Link module. The relation of IO-Link-pin and PIO-pin can be seen in the global netX90 pinning sheet:   io_link7_out-&gt;pio27, io_link7_oe-&gt;pio28   io_link6_out-&gt;pio24, io_link6_oe-&gt;pio25   io_link5_out-&gt;pio22, io_link5_oe-&gt;pio23   io_link4_out-&gt;pio19, io_link4_oe-&gt;pio21   io_link3_out-&gt;pio14, io_link3_oe-&gt;pio15   io_link2_out-&gt;pio11, io_link2_oe-&gt;pio13   io_link1_out/oe: configurable via multiplexmatrix on pio7:0   io_link0_out/oe: configurable via multiplexmatrix on pio7:0 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[7:0]</bitRange>
              <description>IO-Link input </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pio_in_inv': 0xFF801510-->
          <name>pio_in_inv</name>
          <description>Invert input of PIO. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x1FFFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:29]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[28:0]</bitRange>
              <description>Invert PIO </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pio_edge_event': 0xFF801514-->
          <name>pio_edge_event</name>
          <description>generate IRQ at edge of PIO, otherwise level. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x1FFFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:29]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[28:0]</bitRange>
              <description>Edge detect 0: generate IRQ if (inverted) PIO is high level 1: generate IRQ at rising edge of (inverted) PIO </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pio_irq_raw': 0xFF801518-->
          <name>pio_irq_raw</name>
          <description>Raw IRQ: Read access shows status of unmasked IRQs.   IRQs are set automatically and reset by writing to this register: Write access with '1' resets the appropriate IRQ (if event irq, reset status irqs at their source). Write access with '0' does not influence this bit. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000018</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x1FFFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:29]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pio</name>
              <bitRange>[28:0]</bitRange>
              <description>event or active level at PIO input </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pio_irq0_masked': 0xFF80151C-->
          <name>pio_irq0_masked</name>
          <description>Masked IRQ: Shows status of masked IRQs (as connected to ARM/xPIC). </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000001C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x1FFFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:29]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pio</name>
              <bitRange>[28:0]</bitRange>
              <description>event or active level at PIO input </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pio_irq0_msk_set': 0xFF801520-->
          <name>pio_irq0_msk_set</name>
          <description>IRQ enable mask: The IRQ mask enables interrupt requests for corresponding interrupt sources.   As its bits might be changed by different software tasks,   the IRQ mask register is not writable directly, but by set and reset masks: Write access with '1' sets interrupt mask bit. Write access with '0' does not influence this bit. Read access shows actual interrupt mask. Attention: Before activating interrupt mask, delete old pending interrupts by writing the same value to adr_pio_irq_raw. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x1FFFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:29]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pio</name>
              <bitRange>[28:0]</bitRange>
              <description>event or active level at PIO input </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pio_irq0_msk_reset': 0xFF801524-->
          <name>pio_irq0_msk_reset</name>
          <description>IRQ disable mask: This is the corresponding reset mask to disable interrupt requests for corresponding interrupt sources: Write access with '1' resets interrupt mask bit. Write access with '0' does not influence this bit. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000024</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x1FFFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:29]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pio</name>
              <bitRange>[28:0]</bitRange>
              <description>event or active level at PIO input </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pio_irq1_masked': 0xFF801528-->
          <name>pio_irq1_masked</name>
          <description>Masked IRQ: Shows status of masked IRQs (as connected to ARM/xPIC). </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000028</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x1FFFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:29]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pio</name>
              <bitRange>[28:0]</bitRange>
              <description>event or active level at PIO input </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pio_irq1_msk_set': 0xFF80152C-->
          <name>pio_irq1_msk_set</name>
          <description>IRQ enable mask: The IRQ mask enables interrupt requests for corresponding interrupt sources.   As its bits might be changed by different software tasks,   the IRQ mask register is not writable directly, but by set and reset masks: Write access with '1' sets interrupt mask bit. Write access with '0' does not influence this bit. Read access shows actual interrupt mask. Attention: Before activating interrupt mask, delete old pending interrupts by writing the same value to adr_pio_irq_raw. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000002C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x1FFFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:29]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pio</name>
              <bitRange>[28:0]</bitRange>
              <description>event or active level at PIO input </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pio_irq1_msk_reset': 0xFF801530-->
          <name>pio_irq1_msk_reset</name>
          <description>IRQ disable mask: This is the corresponding reset mask to disable interrupt requests for corresponding interrupt sources: Write access with '1' resets interrupt mask bit. Write access with '0' does not influence this bit. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000030</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x1FFFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:29]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pio</name>
              <bitRange>[28:0]</bitRange>
              <description>event or active level at PIO input </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pio_irq2_masked': 0xFF801534-->
          <name>pio_irq2_masked</name>
          <description>Masked IRQ: Shows status of masked IRQs (as connected to ARM/xPIC). </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000034</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x1FFFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:29]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pio</name>
              <bitRange>[28:0]</bitRange>
              <description>event or active level at PIO input </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pio_irq2_msk_set': 0xFF801538-->
          <name>pio_irq2_msk_set</name>
          <description>IRQ enable mask: The IRQ mask enables interrupt requests for corresponding interrupt sources.   As its bits might be changed by different software tasks,   the IRQ mask register is not writable directly, but by set and reset masks: Write access with '1' sets interrupt mask bit. Write access with '0' does not influence this bit. Read access shows actual interrupt mask. Attention: Before activating interrupt mask, delete old pending interrupts by writing the same value to adr_pio_irq_raw. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000038</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x1FFFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:29]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pio</name>
              <bitRange>[28:0]</bitRange>
              <description>event or active level at PIO input </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pio_irq2_msk_reset': 0xFF80153C-->
          <name>pio_irq2_msk_reset</name>
          <description>IRQ disable mask: This is the corresponding reset mask to disable interrupt requests for corresponding interrupt sources: Write access with '1' resets interrupt mask bit. Write access with '0' does not influence this bit. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000003C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x1FFFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:29]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pio</name>
              <bitRange>[28:0]</bitRange>
              <description>event or active level at PIO input </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pio_irq3_masked': 0xFF801540-->
          <name>pio_irq3_masked</name>
          <description>Masked IRQ: Shows status of masked IRQs (as connected to ARM/xPIC). </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000040</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x1FFFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:29]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pio</name>
              <bitRange>[28:0]</bitRange>
              <description>event or active level at PIO input </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pio_irq3_msk_set': 0xFF801544-->
          <name>pio_irq3_msk_set</name>
          <description>IRQ enable mask: The IRQ mask enables interrupt requests for corresponding interrupt sources.   As its bits might be changed by different software tasks,   the IRQ mask register is not writable directly, but by set and reset masks: Write access with '1' sets interrupt mask bit. Write access with '0' does not influence this bit. Read access shows actual interrupt mask. Attention: Before activating interrupt mask, delete old pending interrupts by writing the same value to adr_pio_irq_raw. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000044</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x1FFFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:29]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pio</name>
              <bitRange>[28:0]</bitRange>
              <description>event or active level at PIO input </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'pio_irq3_msk_reset': 0xFF801548-->
          <name>pio_irq3_msk_reset</name>
          <description>IRQ disable mask: This is the corresponding reset mask to disable interrupt requests for corresponding interrupt sources: Write access with '1' resets interrupt mask bit. Write access with '0' does not influence this bit. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000048</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x1FFFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:29]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>pio</name>
              <bitRange>[28:0]</bitRange>
              <description>event or active level at PIO input </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>timer_app</name>
      <description>timer_app</description>
      <baseAddress>0xFF801600</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>128</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>timer_app0</name>
        <value>1</value>
      </interrupt>
      <interrupt>
        <name>timer_app1</name>
        <value>2</value>
      </interrupt>
      <interrupt>
        <name>timer_app2</name>
        <value>3</value>
      </interrupt>
      <interrupt>
        <name>timer_app_systime_s</name>
        <value>4</value>
      </interrupt>
      <registers>
        <register>
          <!--Absolute address of 'timer_config_timer[%s]': 0xFF801600-->
          <dim>3</dim>
          <dimIncrement>4</dimIncrement>
          <name>timer_config_timer[%s]</name>
          <description>ARM TIMER Config register0 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>systime_config</name>
              <bitRange>[3:2]</bitRange>
              <description>systime  for timer  (2'b00.. systime_com, 2'b01.. systime_com_uc, 2'b10.. systime_app) </description>
            </field>
            <field>
              <name>mode</name>
              <bitRange>[1:0]</bitRange>
              <description>Timer0 2'b00 : Timer stops at 0 2'b01 : Timer is preload with value from preload register at 0 2'b10 : Timer (value) compare with systime (once) 2'b11 : reserved </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'timer_preload_timer[%s]': 0xFF80160C-->
          <dim>3</dim>
          <dimIncrement>4</dimIncrement>
          <name>timer_preload_timer[%s]</name>
          <description>ARM TIMER Timer 0 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>preload value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'timer_timer[%s]': 0xFF801618-->
          <dim>3</dim>
          <dimIncrement>4</dimIncrement>
          <name>timer_timer[%s]</name>
          <description>ARM TIMER Timer 0 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000018</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>actual value of timer / systime compare value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'timer_systime_s': 0xFF801624-->
          <name>timer_systime_s</name>
          <description>ARM_TIMER upper SYSTIME register To allow consistent values of systime_s and systime_ns, lower bits of systime is latched to systime_ns, when systime_s is read. This register should be dedicated to accesses via ARM. xPIC software should access systime via xpic_timer_systime_s. Host software should access systime via DPM at systime_s. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000024</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Systime high: Sample systime_ns at read access to systime_s. Value is incremented, if systime_ns reaches systime_border. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'timer_systime_ns': 0xFF801628-->
          <name>timer_systime_ns</name>
          <description>ARM_TIMER lower SYSTIME register To allow consistent values of systime_s and systime_ns, lower bits of systime is latched to systime_ns, when systime_s is read. If no systime_s is read before (e.g. at 2nd read access of systime_ns), the actual value of systime_ns is read. This register should be dedicated to accesses via ARM. xPIC software should access systime via xpic_timer_systime_ns. Host software should access systime via DPM at systime_ns. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000028</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Systime low: Sample systime_ns at read access to systime_s. Without sample read systime_s, read the actual value of systime_ns. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'timer_compare_systime_s_value': 0xFF80162C-->
          <name>timer_compare_systime_s_value</name>
          <description>SYSTIME sec compare value </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000002C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Compare value with systime_s (seconds): Systime_s_compare_irq is set, if systime_s matches. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'timer_irq_raw': 0xFF801630-->
          <name>timer_irq_raw</name>
          <description>ARM_TIMER Raw IRQ register: Read access shows status of unmasked IRQs.   IRQs are set automatically and reset by writing to this register: Write access with '1' resets the appropriate IRQ. Write access with '0' does not influence this bit. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000030</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>systime_s_irq</name>
              <bitRange>[3:3]</bitRange>
              <description>Systime sec Interrupt </description>
            </field>
            <field>
              <name>timer2_irq</name>
              <bitRange>[2:2]</bitRange>
              <description>Timer 2 Interrupt </description>
            </field>
            <field>
              <name>timer1_irq</name>
              <bitRange>[1:1]</bitRange>
              <description>Timer 1 Interrupt </description>
            </field>
            <field>
              <name>timer0_irq</name>
              <bitRange>[0:0]</bitRange>
              <description>Timer 0 Interrupt </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'timer_irq_masked': 0xFF801634-->
          <name>timer_irq_masked</name>
          <description>ARM_TIMER Masked IRQ register: Shows status of masked IRQs (as connected to ARM/xPIC) </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000034</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>systime_s_irq</name>
              <bitRange>[3:3]</bitRange>
              <description>Systime sec Interrupt </description>
            </field>
            <field>
              <name>timer2_irq</name>
              <bitRange>[2:2]</bitRange>
              <description>Timer 2 Interrupt </description>
            </field>
            <field>
              <name>timer1_irq</name>
              <bitRange>[1:1]</bitRange>
              <description>Timer 1 Interrupt </description>
            </field>
            <field>
              <name>timer0_irq</name>
              <bitRange>[0:0]</bitRange>
              <description>Timer 0 Interrupt </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'timer_irq_msk_set': 0xFF801638-->
          <name>timer_irq_msk_set</name>
          <description>ARM_TIMER interrupt mask set: The IRQ mask enables interrupt requests for corresponding interrupt sources.   As its bits might be changed by different software tasks,   the IRQ mask register is not writable directly, but by set and reset masks: Write access with '1' sets interrupt mask bit (enables interrupt request for corresponding interrupt source). Write access with '0' does not influence this bit. Read access shows actual interrupt mask. Attention: Before activating interrupt mask, delete old pending interrupts by writing the same value to arm_timer_irq_raw. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000038</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>systime_s_irq</name>
              <bitRange>[3:3]</bitRange>
              <description>Systime sec Interrupt </description>
            </field>
            <field>
              <name>timer2_irq</name>
              <bitRange>[2:2]</bitRange>
              <description>Timer 2 Interrupt </description>
            </field>
            <field>
              <name>timer1_irq</name>
              <bitRange>[1:1]</bitRange>
              <description>Timer 1 Interrupt </description>
            </field>
            <field>
              <name>timer0_irq</name>
              <bitRange>[0:0]</bitRange>
              <description>Timer 0 Interrupt </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'timer_irq_msk_reset': 0xFF80163C-->
          <name>timer_irq_msk_reset</name>
          <description>ARM_TIMER interrupt mask reset: This is the corresponding reset mask to disable interrupt requests for corresponding interrupt sources: Write access with '1' resets interrupt mask bit (disables interrupt request for corresponding interrupt source). Write access with '0' does not influence this bit. Read access shows actual interrupt mask. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000003C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>systime_s_irq</name>
              <bitRange>[3:3]</bitRange>
              <description>Systime sec Interrupt </description>
            </field>
            <field>
              <name>timer2_irq</name>
              <bitRange>[2:2]</bitRange>
              <description>Timer 2 Interrupt </description>
            </field>
            <field>
              <name>timer1_irq</name>
              <bitRange>[1:1]</bitRange>
              <description>Timer 1 Interrupt </description>
            </field>
            <field>
              <name>timer0_irq</name>
              <bitRange>[0:0]</bitRange>
              <description>Timer 0 Interrupt </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'timer_systime_config': 0xFF801640-->
          <name>timer_systime_config</name>
          <description>Select systime  for arm_timer_systime_(ns)s functions </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000040</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:2]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>systime_config</name>
              <bitRange>[1:0]</bitRange>
              <description>systime  for timer (2'b00.. systime_com, 2'b01.. systime_com_uc, 2'b10.. systime_app) </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>systime_lt_app</name>
      <description>systime_lt_app</description>
      <baseAddress>0xFF801680</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>64</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <!--Absolute address of 'intlogic_lt_systime_com_ns': 0xFF801680-->
          <name>intlogic_lt_systime_com_ns</name>
          <description>systime_com_ns last latched value </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>systime_com_ns last latched value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'intlogic_lt_systime_com_s': 0xFF801684-->
          <name>intlogic_lt_systime_com_s</name>
          <description>systime_com_s last latched value </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>systime_com_s last latched value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'intlogic_lt_systime_com_uc_ns': 0xFF801688-->
          <name>intlogic_lt_systime_com_uc_ns</name>
          <description>systime_com_uc_ns last latched value </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>systime_com_uc_ns last latched value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'intlogic_lt_systime_com_uc_s': 0xFF80168C-->
          <name>intlogic_lt_systime_com_uc_s</name>
          <description>systime_com_uc_s last latched value </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>systime_com_uc_s last latched value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'intlogic_lt_systime_app_ns': 0xFF801690-->
          <name>intlogic_lt_systime_app_ns</name>
          <description>systime_app_ns last latched value </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000010</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>systime_app_ns last latched value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'intlogic_lt_systime_app_s': 0xFF801694-->
          <name>intlogic_lt_systime_app_s</name>
          <description>systime_app_s last latched value </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000014</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>systime_app_s last latched value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'intlogic_lt_systimes_latch': 0xFF801698-->
          <name>intlogic_lt_systimes_latch</name>
          <description>latch systimes by writing 1'b1 to the assigned bit </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000018</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000003F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>systime_app_s</name>
              <bitRange>[5:5]</bitRange>
              <description>no field descpription</description>
            </field>
            <field>
              <name>systime_app_ns</name>
              <bitRange>[4:4]</bitRange>
              <description>no field descpription</description>
            </field>
            <field>
              <name>systime_com_uc_s</name>
              <bitRange>[3:3]</bitRange>
              <description>no field descpription</description>
            </field>
            <field>
              <name>systime_com_uc_ns</name>
              <bitRange>[2:2]</bitRange>
              <description>no field descpription</description>
            </field>
            <field>
              <name>systime_com_s</name>
              <bitRange>[1:1]</bitRange>
              <description>no field descpription</description>
            </field>
            <field>
              <name>systime_com_ns</name>
              <bitRange>[0:0]</bitRange>
              <description>no field descpription</description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>systime_app</name>
      <description>systime_app</description>
      <baseAddress>0xFF8016C0</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>16</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <!--Absolute address of 'systime_s': 0xFF8016C0-->
          <name>systime_s</name>
          <description>Upper SYSTIME register: To allow consistent values of systime_s and systime_ns, lower bits of systime is latched to systime_ns, when systime_s is read. This register should be dedicated to accesses via DPM. ARM software should access systime via arm_timer_systime_s. xPIC software should access systime via xpic_timer_systime_s. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>systime_s</name>
              <bitRange>[31:0]</bitRange>
              <description>systime high value is incremented, if systime_ns reaches systime_border Sample systime_ns at read access to systime_s. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'systime_ns': 0xFF8016C4-->
          <name>systime_ns</name>
          <description>Lower SYSTIME register: To allow consistent values of systime_s and systime_ns, lower bits of systime is latched to systime_ns, when systime_s is read. If no systime_s is read before (or at 2nd read access of systime_ns), the actual value of systime_ns is read. This register should be dedicated to accesses via DPM. ARM software should access systime via arm_timer_systime_ns. xPIC software should access systime via xpic_timer_systime_ns. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>systime_ns</name>
              <bitRange>[31:0]</bitRange>
              <description>Systime low: Sample systime_ns at read access to systime_s. Without sample read systime_s, read the actual value of systime_ns. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'systime_border': 0xFF8016C8-->
          <name>systime_border</name>
          <description>SYSTIME border register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3B9AC9FF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>systime_border</name>
              <bitRange>[31:0]</bitRange>
              <description>Systime border for lower systime: systime_ns counts from 0 to this value (inlcuded), i.e. systime_ns counts modulo (systime_border + 1) Attention: the border value Bit 3 to 1 must be b'1111 (hex f) for all netX systime - match functions </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'systime_count_value': 0xFF8016CC-->
          <name>systime_count_value</name>
          <description>SYSTIME count register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xA0000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>systime_count_value</name>
              <bitRange>[31:0]</bitRange>
              <description>Each clock cycle (systime_count_value &gt;&gt; 28) will be added to systime (rate multiplier for IEEE1588). Value 0x10000000 can be used for counting in 10ns (ethernet clock) steps. </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>mcp_app</name>
      <description>mcp_app</description>
      <baseAddress>0xFF8016E0</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>32</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>mcp_app</name>
        <value>7</value>
      </interrupt>
      <registers>
        <register>
          <!--Absolute address of 'hs_irq_set_raw': 0xFF8016E0-->
          <name>hs_irq_set_raw</name>
          <description>read: hs_iq_reg value write: hs_iq_reg set bit(s) </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>hs_irq_set_bits</name>
              <bitRange>[31:0]</bitRange>
              <description>IRQs for Inter-CPU-Communication </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hs_irq_reset_raw': 0xFF8016E4-->
          <name>hs_irq_reset_raw</name>
          <description>read: hs_iq_reg value write: hs_iq_reg reset bit(s) </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>hs_irq_reset_bits</name>
              <bitRange>[31:0]</bitRange>
              <description>IRQs for Inter-CPU-Communication </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hs_irq_set_mask': 0xFF8016E8-->
          <name>hs_irq_set_mask</name>
          <description>read: mask value </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>hs_irq_set_mask</name>
              <bitRange>[31:0]</bitRange>
              <description>IRQs for Inter-CPU-Communication </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hs_irq_reset_mask': 0xFF8016EC-->
          <name>hs_irq_reset_mask</name>
          <description>read: mask value </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>hs_irq_reset_mask</name>
              <bitRange>[31:0]</bitRange>
              <description>reset IRQs for Inter-CPU-Communication </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hs_irq_masked': 0xFF8016F0-->
          <name>hs_irq_masked</name>
          <description>read: hs_iq_reg masked value </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>hs_irq_masked</name>
              <bitRange>[31:0]</bitRange>
              <description>mask IRQs for Inter-CPU-Communication </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>wdg_app</name>
      <description>wdg_app</description>
      <baseAddress>0xFF801700</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>32</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>wdg_app</name>
        <value>5</value>
      </interrupt>
      <registers>
        <register>
          <!--Absolute address of 'netx_sys_wdg_ctrl': 0xFF801700-->
          <name>netx_sys_wdg_ctrl</name>
          <description>netX System Watchdog Trigger Register. The watchdog access code is generated by a pseudo random generator. It must be written correctly for a valid write access to this register (not only for triggering e.g. also for IRQ clearing). Note:    WDGACT signal is available as MMIO function.. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x910FFFFF</resetMask>
          <fields>
            <field>
              <name>write_enable</name>
              <bitRange>[31:31]</bitRange>
              <description>Write enable bit for timeout register: As long as this bit is not set all write accesses to the timeout register are ignored. </description>
            </field>
            <field>
              <name>bf_align2</name>
              <bitRange>[30:29]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>wdg_counter_trigger_w</name>
              <bitRange>[28:28]</bitRange>
              <description>Watchdog trigger bit: Bit must be set to trigger the watchdog counter. When read, this bit is always '0' </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[27:25]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>irq_req_watchdog</name>
              <bitRange>[24:24]</bitRange>
              <description>IRQ request of watchdog, writing 1 deletes IRQ </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[23:20]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>wdg_access_code</name>
              <bitRange>[19:0]</bitRange>
              <description>Watchdog trigger and control register access code. A read access gives the next 16 bit code for writing the 'netx_sys_wdg_ctrl' register. A write access with correct access code will trigger the watchdog counter. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'netx_sys_wdg': 0xFF801704-->
          <name>netx_sys_wdg</name>
          <description>netX System Watchdog Register The counter value is decremented each 10000 system clock cycles. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0001FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:17]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>wdg_counter</name>
              <bitRange>[16:0]</bitRange>
              <description>Actual watchdog counter value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'netx_sys_wdg_irq_timeout': 0xFF801708-->
          <name>netx_sys_wdg_irq_timeout</name>
          <description>netX System Wachtdog Interrupt Timout Register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>wdg_irq_timeout</name>
              <bitRange>[15:0]</bitRange>
              <description>Watchdog interrupt timeout The total netx_sys_irq timeout for a netX clock of 100MHz is: wdg_irq_timeout * 100us Note: The watchdog can be stopped by programming a 0. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'netx_sys_wdg_res_timeout': 0xFF80170C-->
          <name>netx_sys_wdg_res_timeout</name>
          <description>netX System Watchdog Reset Timeout Register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>wdg_res_timeout</name>
              <bitRange>[15:0]</bitRange>
              <description>Watchdog reset request timeout The total reset timeout for a netX clock of 100MHz is: (wdg_irq_timeout + wdg_res_timeout) * 100us Note: The watchdog can be stopped by programming a 0. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'netx_sys_wdg_irq_raw': 0xFF801710-->
          <name>netx_sys_wdg_irq_raw</name>
          <description>netX System Wachtdog IRQ raw register: Read access shows status of unmasked IRQs.   IRQs are set automatically and reset by writing to this register: Write access with '1' resets the appropriate IRQ. Write access with '0' does not influence this bit. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>wdg_res_irq</name>
              <bitRange>[0:0]</bitRange>
              <description>Watchdog reset request timeout interrupt </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'netx_sys_wdg_irq_masked': 0xFF801714-->
          <name>netx_sys_wdg_irq_masked</name>
          <description>netX System Wachtdog Masked IRQ register: Read access shows status of masked IRQs. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000014</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>wdg_res_irq</name>
              <bitRange>[0:0]</bitRange>
              <description>Watchdog reset request timeout interrupt </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'netx_sys_wdg_irq_msk_set': 0xFF801718-->
          <name>netx_sys_wdg_irq_msk_set</name>
          <description>netX System Wachtdog interrupt mask enable: The IRQ mask enables interrupt requests for corresponding interrupt sources.   As its bits might be changed by different software tasks,   the IRQ mask register is not writable directly, but by set and reset masks: Write access with '1' sets interrupt mask bit (enables interrupt request for corresponding interrupt source). Write access with '0' does not influence this bit. Read access shows actual interrupt mask. Attention: Before activating interrupt mask, delete old pending interrupts by writing the same value to irq_raw. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000018</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>wdg_res_irq</name>
              <bitRange>[0:0]</bitRange>
              <description>Watchdog reset request timeout interrupt </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'netx_sys_wdg_irq_msk_reset': 0xFF80171C-->
          <name>netx_sys_wdg_irq_msk_reset</name>
          <description>netX System Wachtdog interrupt mask disable: This is the corresponding reset mask to disable interrupt requests for corresponding interrupt sources: Write access with '1' resets interrupt mask bit (disables interrupt request for corresponding interrupt source). Write access with '0' does not influence this bit. Read access shows actual interrupt mask. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000001C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>wdg_res_irq</name>
              <bitRange>[0:0]</bitRange>
              <description>Watchdog reset request timeout interrupt </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>trigger_irq_app</name>
      <description>trigger_irq_app</description>
      <baseAddress>0xFF801720</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>32</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>trigger_out_edge0</name>
        <value>69</value>
      </interrupt>
      <interrupt>
        <name>trigger_out_edge1</name>
        <value>70</value>
      </interrupt>
      <registers>
        <register>
          <!--Absolute address of 'trigger_irq_cfg': 0xFF801720-->
          <name>trigger_irq_cfg</name>
          <description>Trigger IRQ configuration register. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:2]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>xc_trigger_out_polarity</name>
              <bitRange>[1:0]</bitRange>
              <description>Polarity of xc_trigger_out signals for edge detection. 0: Use pos-edge on xc_trigger_out signals to trigger an IRQ. 1: Use neg-edge on xc_trigger_out signals to trigger an IRQ. Note: Changing the polarity will trigger set an IRQ in the raw register (and when the mask is set also the IRQ signal to the CPU) due to the edge detection logic. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'trigger_irq_raw': 0xFF801724-->
          <name>trigger_irq_raw</name>
          <description>Trigger raw IRQ: Read access shows status of unmasked IRQs.   IRQs are set automatically and reset by writing to this register: Write access with '1' resets the appropriate IRQ. Write access with '0' does not influence this bit. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:2]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>xc_trigger_out_edge</name>
              <bitRange>[1:0]</bitRange>
              <description>Edge detected on xc_trigger_out. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'trigger_irq_masked': 0xFF801728-->
          <name>trigger_irq_masked</name>
          <description>Trigger masked IRQ: Shows status of masked IRQs. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:2]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>xc_trigger_out_edge</name>
              <bitRange>[1:0]</bitRange>
              <description>Edge detected on xc_trigger_out. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'trigger_irq_msk_set': 0xFF80172C-->
          <name>trigger_irq_msk_set</name>
          <description>Trigger IRQ mask set: The IRQ mask enables interrupt requests for corresponding interrupt sources.   As its bits might be changed by different software tasks,   the IRQ mask register is not writable directly, but by set and reset masks: Write access with '1' sets interrupt mask bit. Write access with '0' does not influence this bit. Read access shows actual interrupt mask. Attention: Before activating interrupt mask, delete old pending interrupts by writing the same value to bod_irq_raw. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:2]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>xc_trigger_out_edge</name>
              <bitRange>[1:0]</bitRange>
              <description>Edge detected on xc_trigger_out. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'trigger_irq_msk_reset': 0xFF801730-->
          <name>trigger_irq_msk_reset</name>
          <description>Trigger IRQ mask reset: This is the corresponding reset mask to disable interrupt requests for corresponding interrupt sources: Write access with '1' resets interrupt mask bit. Write access with '0' does not influence this bit. Read access shows actual interrupt mask. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:2]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>xc_trigger_out_edge</name>
              <bitRange>[1:0]</bitRange>
              <description>Edge detected on xc_trigger_out. </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>ecc_ctrl_app</name>
      <description>ecc_ctrl_app</description>
      <baseAddress>0xFF801800</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>64</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>ecc_app</name>
        <value>11</value>
      </interrupt>
      <registers>
        <register>
          <!--Absolute address of 'ecc_ctrl_app_intram6_ctrl': 0xFF801800-->
          <name>ecc_ctrl_app_intram6_ctrl</name>
          <description>INTRAM6 syndrome manipulation register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>syndrome_inv</name>
              <bitRange>[7:1]</bitRange>
              <description>Inverts syndrome bits for ECC testing </description>
            </field>
            <field>
              <name>enable</name>
              <bitRange>[0:0]</bitRange>
              <description>enable ECC </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'ecc_ctrl_app_intram7_ctrl': 0xFF801804-->
          <name>ecc_ctrl_app_intram7_ctrl</name>
          <description>INTRAM7 syndrome manipulation register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>syndrome_inv</name>
              <bitRange>[7:1]</bitRange>
              <description>Inverts syndrome bits for ECC testing </description>
            </field>
            <field>
              <name>enable</name>
              <bitRange>[0:0]</bitRange>
              <description>enable ECC </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'ecc_ctrl_app_xpic1_pram_ctrl': 0xFF801808-->
          <name>ecc_ctrl_app_xpic1_pram_ctrl</name>
          <description>XPIC1_PRAM syndrome manipulation register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>syndrome_inv</name>
              <bitRange>[7:1]</bitRange>
              <description>Inverts syndrome bits for ECC testing </description>
            </field>
            <field>
              <name>enable</name>
              <bitRange>[0:0]</bitRange>
              <description>enable ECC </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'ecc_ctrl_app_xpic1_dram_ctrl': 0xFF80180C-->
          <name>ecc_ctrl_app_xpic1_dram_ctrl</name>
          <description>XPIC1_DRAM syndrome manipulation register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000003F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>syndrome_inv</name>
              <bitRange>[5:1]</bitRange>
              <description>Inverts syndrome bits for ECC testing </description>
            </field>
            <field>
              <name>enable</name>
              <bitRange>[0:0]</bitRange>
              <description>enable ECC </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'ecc_ctrl_app_intram6_addr_sbe': 0xFF801810-->
          <name>ecc_ctrl_app_intram6_addr_sbe</name>
          <description>RAM Address of ECC single bit error (SBE): This register logs the RAM address where first ECC SBE occured. This first SBE address will be stored (even in case of further SBEs) until the appropriate bit in status_sbe register was cleared. Note1: Not all RAM ECCs support error address logging, e.g. dual-port RAMs Note2: This is the real RAM address, i.e. a 32-bit address except at xMAC 64-bit RAMs or RAMs that are not directly accessible by CPU. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000010</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0007FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:19]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>add_addr</name>
              <bitRange>[18:13]</bitRange>
              <description>RAM readmodwrite(1) and number of master that started errorneous RAM access(5) </description>
            </field>
            <field>
              <name>address</name>
              <bitRange>[12:0]</bitRange>
              <description>Address of last ECC single bit error </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'ecc_ctrl_app_intram7_addr_sbe': 0xFF801814-->
          <name>ecc_ctrl_app_intram7_addr_sbe</name>
          <description>RAM Address of ECC single bit error (SBE): This register logs the RAM address where first ECC SBE occured. This first SBE address will be stored (even in case of further SBEs) until the appropriate bit in status_sbe register was cleared. Note1: Not all RAM ECCs support error address logging, e.g. dual-port RAMs Note2: This is the real RAM address, i.e. a 32-bit address except at xMAC 64-bit RAMs or RAMs that are not directly accessible by CPU. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000014</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0007FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:19]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>add_addr</name>
              <bitRange>[18:13]</bitRange>
              <description>RAM readmodwrite(1) and number of master that started errorneous RAM access(5) </description>
            </field>
            <field>
              <name>address</name>
              <bitRange>[12:0]</bitRange>
              <description>Address of last ECC single bit error </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'ecc_ctrl_app_xpic1_pram_addr_sbe': 0xFF801818-->
          <name>ecc_ctrl_app_xpic1_pram_addr_sbe</name>
          <description>RAM Address of ECC single bit error (SBE): This register logs the RAM address where first ECC SBE occured. This first SBE address will be stored (even in case of further SBEs) until the appropriate bit in status_sbe register was cleared. Note1: Not all RAM ECCs support error address logging, e.g. dual-port RAMs Note2: This is the real RAM address, i.e. a 32-bit address except at xMAC 64-bit RAMs or RAMs that are not directly accessible by CPU. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000018</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000007FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:11]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>address</name>
              <bitRange>[10:0]</bitRange>
              <description>Address of last ECC single bit error </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'ecc_ctrl_app_xpic1_dram_addr_sbe': 0xFF80181C-->
          <name>ecc_ctrl_app_xpic1_dram_addr_sbe</name>
          <description>RAM Address of ECC single bit error (SBE): This register logs the RAM address where first ECC SBE occured. This first SBE address will be stored (even in case of further SBEs) until the appropriate bit in status_sbe register was cleared. Note1: Not all RAM ECCs support error address logging, e.g. dual-port RAMs Note2: This is the real RAM address, i.e. a 32-bit address except at xMAC 64-bit RAMs or RAMs that are not directly accessible by CPU. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000001C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000007FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:11]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>address</name>
              <bitRange>[10:0]</bitRange>
              <description>Address of last ECC single bit error </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'ecc_ctrl_app_intram6_addr_dbe': 0xFF801820-->
          <name>ecc_ctrl_app_intram6_addr_dbe</name>
          <description>RAM Address of ECC single bit error (DBE): This register logs the RAM address where first ECC DBE occured. This first DBE address will be stored (even in case of further DBEs) until the appropriate bit in status_sbe register was cleared. Note1: Not all RAM ECCs support error address logging, e.g. dual-port RAMs Note2: This is the real RAM address, i.e. a 32-bit address except at xMAC 64-bit RAMs or RAMs that are not directly accessible by CPU. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000020</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0007FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:19]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>add_addr</name>
              <bitRange>[18:13]</bitRange>
              <description>RAM readmodwrite(1) and number of master that started errorneous RAM access(5) </description>
            </field>
            <field>
              <name>address</name>
              <bitRange>[12:0]</bitRange>
              <description>Address of last ECC double bit error </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'ecc_ctrl_app_intram7_addr_dbe': 0xFF801824-->
          <name>ecc_ctrl_app_intram7_addr_dbe</name>
          <description>RAM Address of ECC single bit error (DBE): This register logs the RAM address where first ECC DBE occured. This first DBE address will be stored (even in case of further DBEs) until the appropriate bit in status_sbe register was cleared. Note1: Not all RAM ECCs support error address logging, e.g. dual-port RAMs Note2: This is the real RAM address, i.e. a 32-bit address except at xMAC 64-bit RAMs or RAMs that are not directly accessible by CPU. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000024</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0007FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:19]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>add_addr</name>
              <bitRange>[18:13]</bitRange>
              <description>RAM readmodwrite(1) and number of master that started errorneous RAM access(5) </description>
            </field>
            <field>
              <name>address</name>
              <bitRange>[12:0]</bitRange>
              <description>Address of last ECC double bit error </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'ecc_ctrl_app_xpic1_pram_addr_dbe': 0xFF801828-->
          <name>ecc_ctrl_app_xpic1_pram_addr_dbe</name>
          <description>RAM Address of ECC single bit error (DBE): This register logs the RAM address where first ECC DBE occured. This first DBE address will be stored (even in case of further DBEs) until the appropriate bit in status_sbe register was cleared. Note1: Not all RAM ECCs support error address logging, e.g. dual-port RAMs Note2: This is the real RAM address, i.e. a 32-bit address except at xMAC 64-bit RAMs or RAMs that are not directly accessible by CPU. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000028</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000007FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:11]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>address</name>
              <bitRange>[10:0]</bitRange>
              <description>Address of last ECC double bit error </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'ecc_ctrl_app_xpic1_dram_addr_dbe': 0xFF80182C-->
          <name>ecc_ctrl_app_xpic1_dram_addr_dbe</name>
          <description>RAM Address of ECC single bit error (DBE): This register logs the RAM address where first ECC DBE occured. This first DBE address will be stored (even in case of further DBEs) until the appropriate bit in status_sbe register was cleared. Note1: Not all RAM ECCs support error address logging, e.g. dual-port RAMs Note2: This is the real RAM address, i.e. a 32-bit address except at xMAC 64-bit RAMs or RAMs that are not directly accessible by CPU. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000002C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000007FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:11]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>address</name>
              <bitRange>[10:0]</bitRange>
              <description>Address of last ECC double bit error </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'ecc_ctrl_app_status_sbe': 0xFF801830-->
          <name>ecc_ctrl_app_status_sbe</name>
          <description>ECC status SBE: This register collects single bit error (SBE) status information. In case of ECC SBE, a bit in this register will be set. Bits can be reset by writing '1' to the apprpriate bit position (write to clear). If a SBE or DBE bit is set, IRQ signal will be asserted. Note: No mask register is required, as error correction can be enabled for each RAM separately. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000030</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>xpic1_dram</name>
              <bitRange>[3:3]</bitRange>
              <description>XPIC1_DRAM Single Bit Error occured </description>
            </field>
            <field>
              <name>xpic1_pram</name>
              <bitRange>[2:2]</bitRange>
              <description>XPIC1_PRAM Single Bit Error occured </description>
            </field>
            <field>
              <name>intram7</name>
              <bitRange>[1:1]</bitRange>
              <description>INTRAM7 Single Bit Error occured </description>
            </field>
            <field>
              <name>intram6</name>
              <bitRange>[0:0]</bitRange>
              <description>INTRAM6 Single Bit Error occured </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'ecc_ctrl_app_status_dbe': 0xFF801834-->
          <name>ecc_ctrl_app_status_dbe</name>
          <description>ECC status DBE: This register collects double bit error (DBE) status information. In case of ECC DBE, a bit of the appropriate RAM in this register will be set. Bits can be reset by writing '1' to the apprpriate bit position (write to clear). If a SBE or DBE bit is set, IRQ signal will be asserted. Note: No mask register is required, as error correction can be enabled for each RAM separately. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000034</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>xpic1_dram</name>
              <bitRange>[3:3]</bitRange>
              <description>XPIC1_DRAM Double Bit Error occured </description>
            </field>
            <field>
              <name>xpic1_pram</name>
              <bitRange>[2:2]</bitRange>
              <description>XPIC1_PRAM Double Bit Error occured </description>
            </field>
            <field>
              <name>intram7</name>
              <bitRange>[1:1]</bitRange>
              <description>INTRAM7 Double Bit Error occured </description>
            </field>
            <field>
              <name>intram6</name>
              <bitRange>[0:0]</bitRange>
              <description>INTRAM6 Double Bit Error occured </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>endat0_app</name>
      <description>endat0_app</description>
      <baseAddress>0xFF802000</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>64</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>endat_app0</name>
        <value>41</value>
      </interrupt>
      <registers>
        <register>
          <!--Absolute address of 'endat_send': 0xFF802000-->
          <name>endat_send</name>
          <description>Send register The send register contains data to be transmitted to the EnDat encoder. Mode command MRS code/address/port address (depends on the mode command) Parameters/instructions (depends on the mode command) </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x07000000</resetValue>
          <resetMask>0x3FFFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:30]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>byte4</name>
              <bitRange>[29:24]</bitRange>
              <description>Mode bits M[5:0] </description>
            </field>
            <field>
              <name>byte3</name>
              <bitRange>[23:16]</bitRange>
              <description>MRS code / Address / Port address A[7:0] </description>
            </field>
            <field>
              <name>byte2</name>
              <bitRange>[15:8]</bitRange>
              <description>Parameters / Instructions D[15:0] </description>
            </field>
            <field>
              <name>byte1</name>
              <bitRange>[7:0]</bitRange>
              <description>Parameters / Instructions D[7:0] </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'endat_receive1_0': 0xFF802004-->
          <name>endat_receive1_0</name>
          <description>Receive register 1 Depending on the transmitted type 2.1 mode command, receive register 1 contains different data. With EnDat type 2.2 mode commands and with SSI, the position value is always entered into receive-Reg 1. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>byte4</name>
              <bitRange>[31:24]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>byte3</name>
              <bitRange>[23:16]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>byte2</name>
              <bitRange>[15:8]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>byte1</name>
              <bitRange>[7:0]</bitRange>
              <description>... </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'endat_receive1_1': 0xFF802008-->
          <name>endat_receive1_1</name>
          <description>Receive register 1 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00FFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:24]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>byte7</name>
              <bitRange>[23:16]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>byte6</name>
              <bitRange>[15:8]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>byte5</name>
              <bitRange>[7:0]</bitRange>
              <description>... </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'endat_receive2': 0xFF80200C-->
          <name>endat_receive2</name>
          <description>Receive register 2 If a type 2.2 mode command was sent, receive register 2 will contain the contents of additional information 2 and its CRC. This data is to be interpreted in accordance with the EnDat Interface Description. In SSI protocol mode with double-word transmission, the redundant position value is stored here (right-aligned). </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>byte4</name>
              <bitRange>[31:24]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>byte3</name>
              <bitRange>[23:16]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>byte2</name>
              <bitRange>[15:8]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>byte1</name>
              <bitRange>[7:0]</bitRange>
              <description>... </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'endat_receive3': 0xFF802010-->
          <name>endat_receive3</name>
          <description>Receive register 3 If a type 2.2 mode command was sent, receive register 3 will contain the contents of additional information 1 and its CRC. This data is to be interpreted in accordance with the EnDat Interface Description. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000010</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>byte4</name>
              <bitRange>[31:24]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>byte3</name>
              <bitRange>[23:16]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>byte2</name>
              <bitRange>[15:8]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>byte1</name>
              <bitRange>[7:0]</bitRange>
              <description>... </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'endat_conf1': 0xFF802014-->
          <name>endat_conf1</name>
          <description>Configuration register 1 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000DF0</resetValue>
          <resetMask>0xFDFFFFF7</resetMask>
          <fields>
            <field>
              <name>endat_ssi</name>
              <bitRange>[31:30]</bitRange>
              <description>These two bits set either the EnDat (0x2) or the SSI (0x1) transmission mode. Values 0x0 and 0x3 are not permitted. Note: For debugging purposes, this function may also be used to perform an internal status engine software reset without clearing of the other internal registers. </description>
            </field>
            <field>
              <name>ic_reset</name>
              <bitRange>[29:29]</bitRange>
              <description>Setting of this bit has the effect that the entire interface component is reset to its initial state. IC reset inactive = 0 IC reset active = 1 </description>
            </field>
            <field>
              <name>f_sys</name>
              <bitRange>[28:26]</bitRange>
              <description>The system frequency actually used must be selected here. 64/48/32/50/100 MHz = 000/010/100/101/110 </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[25:25]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>delay_comp</name>
              <bitRange>[24:24]</bitRange>
              <description>Delay compensation. This bit switches propagation delay compensation on. When this bit is set, propagation time measurement is performed with the next data transmission to the EnDat encoder. The interface component determines the cable propagation time and saves this in conf_reg1. This value is used to determine propagation delay compensation. To measure the propagation time again, the delay compensation bit must be reset and set again. For 16-bit access it must be considered that the measured cable propagation time value is overwritten with 00/h. Delay compensation off = 0 Delay compensation on = 1 In SSI mode, this bit is always on: Delay compensation off = 0 (SSI mode) </description>
            </field>
            <field>
              <name>cable_prop_time</name>
              <bitRange>[23:16]</bitRange>
              <description>The cable propagation time determined by the interface component is stored here. (The application may change this value. If that is the case the status registers propagation time measurement (LZM) bit will automatically be reset). The binary value has a step width of one system clock. At a system clock of 64 MHz, this corresponds to a setting range from 0 us to 3.98 us in steps of 15.6 ns. The basic setting is 00 hex </description>
            </field>
            <field>
              <name>auto_reset</name>
              <bitRange>[15:15]</bitRange>
              <description>Autom. reset (automatic reset). If this bit is set, resetting of the status register and error register is performed automatically Autom. reset = 0 Resetting of the above-mentioned registers must be performed by the application. Autom. reset = 1 Resetting of the above-mentioned registers is done automatically. However, this resetting only occurs in the next EnDat transmission with the start of data reception. For safety applications: autom. reset = 0 </description>
            </field>
            <field>
              <name>reset_window</name>
              <bitRange>[14:14]</bitRange>
              <description>The set bit allows resetting of the status and error register only within a defined time period. Reset window = 0 Resetting of the registers mentioned above can be performed anytime (i.e. without considering malfunctions). Reset Window = 1 Resetting of the registers mentioned above must be performed within a defined time period for acceptance by the protocol engine. For safety applications: reset window = 1  </description>
            </field>
            <field>
              <name>data_word_len</name>
              <bitRange>[13:8]</bitRange>
              <description>Here the data word length is set binary with 6 bits for EnDat or SSI. The permissible setting range for EnDat is from 8 bits to 48 bits. The permissible setting range for SSI is from 8 bits to 48 bits. Data word length = 0 bits = 00 1000 : Data word length = 13 bits = 00 1101 : Data word length = 48 bits = 11 0000 Note: The Data word length has to set to 40/d bit while using mode command 'encoder transmit test values'. Note: In SSI mode the additionally required clock cycle for the parity bit is generated automatically by the circuit. </description>
            </field>
            <field>
              <name>f_tclk</name>
              <bitRange>[7:4]</bitRange>
              <description>Setting (4 bit) of transmission rate for EnDat and SSI from 100 kHz to 1 MHz (SSI) or 16 MHz (EnDat). Transmission frequency = 100kHz   = 1111 Transmission frequency = 200kHz   = 1110 Transmission frequency = 1MHz     = 1101 Transmission frequency = 2MHz     = 1100 Transmission frequency = 4.16MHz  = 1011 Transmission frequency = 8.33MHz  = 0110 Transmission frequency = 16.67MHz = 0000..0011 </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:3]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>endat_cont_clk_mode</name>
              <bitRange>[2:2]</bitRange>
              <description>This bit is used to select the EnDat continuous clock mode. Continuous clock off = 0 Continuous clock on = 1 </description>
            </field>
            <field>
              <name>uncond_transfer</name>
              <bitRange>[1:1]</bitRange>
              <description>This bit defines the unconditional data transfer to receive registers 1, 2, 3, 4 on completion of a data transmission process, despite a flag being set in the status register. Data transfer according to flag set in the status register = 0 Data transfer despite the flag in the status register = 1 For safety applications uncond_transfer = 1 must be set. </description>
            </field>
            <field>
              <name>hw_strobe</name>
              <bitRange>[0:0]</bitRange>
              <description>1: Enables external /STR signal as strobe signal </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'endat_conf2': 0xFF802018-->
          <name>endat_conf2</name>
          <description>Configuration register 2 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000018</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00040000</resetValue>
          <resetMask>0xFF7FFFFF</resetMask>
          <fields>
            <field>
              <name>hw_strobe_delay</name>
              <bitRange>[31:24]</bitRange>
              <description>Here the application can enter a value for the HW strobe delay. The binary value has a step width of one system clock. Setting 00 = Off, 3..255=3..255 system clock cycles The values 1, 2 are not permissible. At a system clock of 64 MHz, this corresponds to a value range from 46.88 ns to 3.98 us in steps of 15.6 ns. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[23:23]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>rtm</name>
              <bitRange>[22:22]</bitRange>
              <description>Activates the recovery time measurement that is then performed after each EnDat transmission with the mode command 1-1 'Encoder transmit position value and selection of memory area' with MRS code 0x43 (selection of 2nd word of position value 2). RTM=0 Recovery time measurement is deactivated (default setting after reset) RTM=1 Recovery time measurement is activated </description>
            </field>
            <field>
              <name>filter</name>
              <bitRange>[21:19]</bitRange>
              <description>The digital filter for the Data_RC data input can be adjusted in eight steps (3 bits) as shown in the table below. The filter setting value corresponds to system clock cycles. Setting 000 = Off Setting 001 = 3 Setting 010 = 4 Setting 011 = 5 Setting 100 = 6 Setting 101 = 10 Setting 110 = 20 Setting 111 = 40 Setting             000     001     010     011     100     101     110     111 Note on the application: The filter must be set according to the transmission rate of the serial interface to the encoder. Example: fTCLK = 1 MHz (corresponds to 64 system clock cycles with CLK = 64 MHz) For the filter, 1/10 of the fTCLK must be set. That means 6 system clock cycles leads to setting: 100 </description>
            </field>
            <field>
              <name>t_st</name>
              <bitRange>[18:16]</bitRange>
              <description>This time is to be set in accordance with EnDat specification. The set time has an accuracy of 0.1 us. Setting 000 = 0.5 * TCLK Setting 001 = 0.5 us Setting 010 = 1 us Setting 011 = 1.5 us Setting 100 = 2 us Setting 101 = 4 us Setting 110 = 8 us Setting 111 = 10 us </description>
            </field>
            <field>
              <name>watchdog</name>
              <bitRange>[15:8]</bitRange>
              <description>256 different watchdog time values can be set. In the default setting 00 hex or 80 hex the watchdog is off. </description>
            </field>
            <field>
              <name>timer_for_sampling_rate</name>
              <bitRange>[7:0]</bitRange>
              <description>256 different sampling rates can be set. In the default setting 00 hex or 80 hex the timer is off. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'endat_conf3': 0xFF80201C-->
          <name>endat_conf3</name>
          <description>Configuration register 3 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000001C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x000000CC</resetValue>
          <resetMask>0x000081FF</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>speed</name>
              <bitRange>[15:15]</bitRange>
              <description>(optional) This bit allows selection of the register width for velocity. 64-bit = 0 32-Bit = 1 </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[14:9]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>dw</name>
              <bitRange>[8:8]</bitRange>
              <description>This bit allows a double-word query to be selected with SSI transmission. Double-word query off = 0 Double word query on  = 1 </description>
            </field>
            <field>
              <name>singleturn_res</name>
              <bitRange>[7:3]</bitRange>
              <description>Here the number of steps per revolution is set to binary with 5 bits. This setting is only required for the fir tree format. Singleturn resolution = 13 bits = 0 1101 </description>
            </field>
            <field>
              <name>gray_to_binary</name>
              <bitRange>[2:2]</bitRange>
              <description>In SSI transmission mode, Gray code values can be converted here to binary code values. Gray-to-binary conversion inactive = 0 Gray-to-binary conversion inactive = 1 </description>
            </field>
            <field>
              <name>format</name>
              <bitRange>[1:1]</bitRange>
              <description>Here the transmission format for SSI transmission is selected. Fir tree: 0 Serial, right-aligned = 1 </description>
            </field>
            <field>
              <name>parity</name>
              <bitRange>[0:0]</bitRange>
              <description>Here the parity check for SSI transmission is selected. Parity off = 0 Parity on  = 1 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'endat_stat': 0xFF802020-->
          <name>endat_stat</name>
          <description>Status register The status bits are created by the sequencing controller of the interface component, as required. Status information remains set until it is reset by the application. The application can selectively reset status information with a write command. This occurs by writing 1 to the selected bits. In the event of concurrent access, the internal sequencing controller has priority. This ensures that status information is not 'lost'. The status bits (15:11) are only valid when additional information 1 or 2 has been received. Note on the application: The status register should be read after each data transmission. It provides information about validity of the data contained in the receive registers. The status bits must be reset in order that the internal sequencing controller can recognize a renewed setting of the status bits. Note: Each bit (except for LZM, LZK, Ready for Strobe) can trigger an interrupt (output: INT1). Masking is performed with the interrupt mask register. If a bit that has been set (and thus has triggered an interrupt) is reset, the INT1 output changes from low to three-state if no other bit has triggered an interrupt. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40000400</resetValue>
          <resetMask>0xF8C7FFFF</resetMask>
          <fields>
            <field>
              <name>ready</name>
              <bitRange>[31:31]</bitRange>
              <description>If the ready bit is set, the status register is completely updated. All checks have been performed. Data transmission is not yet completed, however, meaning that the EnDat protocol automation machine is not yet ready again. No Ready = 0 Ready    = 1 </description>
            </field>
            <field>
              <name>ready_for_strobe</name>
              <bitRange>[30:30]</bitRange>
              <description>This bit reports that data transmission has ended and that the EnDat protocol automation machine is ready for the next transmission. The time values Recovery time 1 (tm) and Recovery time 2 (tR) as specified in the EnDat specification are completed. No Ready = 0 Ready    = 1 This bit cannot be reset by writing a 1 to the respective bit as this is a status display of the current conditions of internal automation engines. The bit cannot cause an interrupt. </description>
            </field>
            <field>
              <name>speed_ready</name>
              <bitRange>[29:29]</bitRange>
              <description>(optional). This bit reports that a new velocity value has been calculated. No new velocity value calculated = 0 New velocity value calculated    = 1 </description>
            </field>
            <field>
              <name>rtm_stop</name>
              <bitRange>[28:28]</bitRange>
              <description>This bit indicates the end of the recovery time, if conf2(22)=1 during EnDat transmission with mode command 1-1 'Encoder transmit position value and selection of memory area' with MRS code 0x43 (selection of 2nd word of position value 2) </description>
            </field>
            <field>
              <name>rtm_start</name>
              <bitRange>[27:27]</bitRange>
              <description>This bit indicates the beginning of the recovery time, if conf2(22)=1 during EnDat transmission with mode command 1-1 'Encoder transmit position value and selection of memory area' with MRS code 0x43 (selection of 2nd word of position value 2) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[26:24]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>prop_time_measurement</name>
              <bitRange>[23:23]</bitRange>
              <description>(LZM). This bit reports that propagation time measurement was successfully completed. Condition: propagation delay compensation LZK in conf_reg1 is set. If the value for propagation delay compensation in configuration register 1 is corrected by the application, this bit will automatically be reset. LZM incomplete = 0 LZM complete   = 1 </description>
            </field>
            <field>
              <name>delay_comp</name>
              <bitRange>[22:22]</bitRange>
              <description>(LZK). This bit reports if propagation delay compensation is active. If propagation delay compensation in configuration register 1 is switched off, this bit and propagation time measurement will automatically be reset. LZK inactive = 0 LZK active   = 1 Neither the LZM nor the LZK bit can be reset by writing a 1 to the respective bit as this is a status display of the current conditions of internal automation engines. Neither of the two bits can cause an interrupt. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[21:19]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>f_type3</name>
              <bitRange>[18:18]</bitRange>
              <description>Type II error (transmission layer) triggers F type III. Error recognition occurs in the EnDat master. The error did not occur = 0 The error occurred      = 1 </description>
            </field>
            <field>
              <name>watchdog</name>
              <bitRange>[17:17]</bitRange>
              <description>Reports triggering of the watchdog. Condition: watchdog in conf_reg2 is set. Watchdog not triggered = 0 Watchdog triggered     = 1 </description>
            </field>
            <field>
              <name>spike</name>
              <bitRange>[16:16]</bitRange>
              <description>Reports that a Spike was detected at the data input port. Condition: filter in conf_reg1 is set. No spike       = 0 Spike occurred = 1 </description>
            </field>
            <field>
              <name>wrn</name>
              <bitRange>[15:15]</bitRange>
              <description>Contains the WRN status bit as transmitted in the EnDat protocol. WRN = 0 WRN = 1 </description>
            </field>
            <field>
              <name>rm</name>
              <bitRange>[14:14]</bitRange>
              <description>Contains the RM status bit as transmitted in the EnDat protocol. RM = 0 RM = 1 </description>
            </field>
            <field>
              <name>busy</name>
              <bitRange>[13:13]</bitRange>
              <description>Contains the Busy status bit as transmitted in the EnDat protocol. Busy = 0 Busy = 1 </description>
            </field>
            <field>
              <name>crc_zi2</name>
              <bitRange>[12:12]</bitRange>
              <description>During EnDat transmissions, this bit indicates the result of the CRC checking of additional information (ZI2). CRC check of ZI2 okay   = 0 CRC check of ZI2 faulty = 1 </description>
            </field>
            <field>
              <name>crc_zi1</name>
              <bitRange>[11:11]</bitRange>
              <description>During EnDat transmissions, this bit indicates the result of the CRC checking of additional information (ZI1). CRC check of ZI2 okay   = 0 CRC check of ZI2 faulty = 1 </description>
            </field>
            <field>
              <name>error2</name>
              <bitRange>[10:10]</bitRange>
              <description>Contains the /Error 2 status bit from the EnDat protocol (only with EnDat2.2 commands). /Error2 occurred      = 0 /Error2 did not occur = 1 </description>
            </field>
            <field>
              <name>receive3_reg</name>
              <bitRange>[9:9]</bitRange>
              <description>This status flag indicates that the data in Receive-Reg3 has been updated. It must be cleared after Receive-Reg3 has been read to allow the interface component to rewrite data. Receive-Reg3 not updated = 0 Receive-Reg3 updated     = 1 </description>
            </field>
            <field>
              <name>receive2_reg</name>
              <bitRange>[8:8]</bitRange>
              <description>This status flag indicates that the data in Receive-Reg 2 (3) has been updated. It must be cleared after Receive-Reg2 (3) has been read to allow the interface component to rewrite data. Receive-Reg2 (3) not updated = 0 Receive-Reg2 (3) updated     = 1 </description>
            </field>
            <field>
              <name>ir7</name>
              <bitRange>[7:7]</bitRange>
              <description>This bit indicates the state of input pin /IR7. Input /IR7 is at high level = 0 Input /IR7 is at low level  = 1 </description>
            </field>
            <field>
              <name>ir6</name>
              <bitRange>[6:6]</bitRange>
              <description>This bit indicates an H/L edge at input pin /IR6. No H/L edge transition at input /IR6 = 0 H/L edge transition has occurred at input /IR6R6 = 1 </description>
            </field>
            <field>
              <name>mrs_adr</name>
              <bitRange>[5:5]</bitRange>
              <description>The occurrence of an addressing or acknowledgement error is shown here as described in the EnDat Interface specification. The errors (F type I / II) are special cases of MRS/address errors, i.e. they are a sub-quantity of these. Accordingly, whenever a type I or type II error is identified, the MRS/Adr bit is set. For example, if an MRS/address bit is recognized incorrectly due to a disturbance, only the MRS/Adr status bit will be set, not the F TYP I/II bits. No acknowledgement or addressing error has occurred = 0 An acknowledgement or addressing error has occurred = 1 </description>
            </field>
            <field>
              <name>f_type2</name>
              <bitRange>[4:4]</bitRange>
              <description>Shows type II error handling in accordance with the EnDat specification at Annex A2. A type II error did not occur = 0 A type II error occurred = 1 </description>
            </field>
            <field>
              <name>f_type1</name>
              <bitRange>[3:3]</bitRange>
              <description>Shows type I error handling in accordance with the EnDat specification at Annex A2. A type I error did not occur = 0 A type I error occurred      = 1 </description>
            </field>
            <field>
              <name>crcpw_parity</name>
              <bitRange>[2:2]</bitRange>
              <description>This bit has two meanings. With EnDat transmission it represents the result of the CRC check of the received value (position value, parameter or test value). With SSI transmission it shows the result of the parity check. Condition: parity check in conf-Reg1 is switched on. CRC check or parity check okay = 0 CRC and parity check faulty    = 1 </description>
            </field>
            <field>
              <name>error1</name>
              <bitRange>[1:1]</bitRange>
              <description>The status bit error1 from the EnDat protocol is entered here. Error1 did not occur = 0 Error1 occurred = 1 </description>
            </field>
            <field>
              <name>receive1_reg</name>
              <bitRange>[0:0]</bitRange>
              <description>This status flag indicates that the data in Receive-Reg 1 has been updated. It must be cleared after Receive-Reg1 has been read to allow the interface component to rewrite data there. Receive-Reg1 not updated = 0 Receive-Reg1 updated     = 1 Note: This flag is ignored if the uncond_transfer bit is enabled in conf-Reg 1. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'endat_int': 0xFF802024-->
          <name>endat_int</name>
          <description>Interrupt mask The interrupt mask register is for the masking of the status registers interrupt sources. All bits shown in the status register (except for LZM, LZK, Ready for Strobe) can generate an interrupt. The bit assignments of the interrupt mask register are identical to those of the status register. An interrupt is allowed by setting the corresponding bit to 1. The INT output changes from three-state to low. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000024</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xA007FFFF</resetMask>
          <fields>
            <field>
              <name>ready</name>
              <bitRange>[31:31]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[30:30]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>speed_ready</name>
              <bitRange>[29:29]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[28:19]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>f_type3</name>
              <bitRange>[18:18]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>watchdog</name>
              <bitRange>[17:17]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>spike</name>
              <bitRange>[16:16]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>wrn</name>
              <bitRange>[15:15]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>RM</name>
              <bitRange>[14:14]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>busy</name>
              <bitRange>[13:13]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>crc_zi2</name>
              <bitRange>[12:12]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>crc_zi1</name>
              <bitRange>[11:11]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>error2</name>
              <bitRange>[10:10]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>receive3_reg</name>
              <bitRange>[9:9]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>receive2_reg</name>
              <bitRange>[8:8]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>ir7</name>
              <bitRange>[7:7]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>ir6</name>
              <bitRange>[6:6]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>mrs_adr</name>
              <bitRange>[5:5]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>f_type2</name>
              <bitRange>[4:4]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>f_type1</name>
              <bitRange>[3:3]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>crcpw_parity</name>
              <bitRange>[2:2]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>error1</name>
              <bitRange>[1:1]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>receive1_reg</name>
              <bitRange>[0:0]</bitRange>
              <description>... </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'endat_test1': 0xFF802028-->
          <name>endat_test1</name>
          <description>Test register 1 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000028</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFF7</resetMask>
          <fields>
            <field>
              <name>ic_test_values</name>
              <bitRange>[31:10]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>enDat_automation_engine</name>
              <bitRange>[9:4]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:3]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>status_zi</name>
              <bitRange>[2:1]</bitRange>
              <description>Allows testing of the IC-internal automation machine. IC sends no clocks for additional information = 00 IC sends clocks for one unit of additional information 1 = 01 IC sends clocks for one unit of additional information 2 = 10 IC sends clocks for two units of additional information (1+2) = 11 </description>
            </field>
            <field>
              <name>dl_high</name>
              <bitRange>[0:0]</bitRange>
              <description>For control of the EnDat automation machine. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'endat_test2': 0xFF80202C-->
          <name>endat_test2</name>
          <description>Test register 2 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000002C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFBC</resetMask>
          <fields>
            <field>
              <name>ic_test_data</name>
              <bitRange>[31:16]</bitRange>
              <description>RTM value - Counter value of the recovery time measurement if conf2(22)=1. Updated after the completion of the recovery time tm measurement during the EnDat transmission with mode command 1-1 'Encoder transmit position value and selection of memory area' with MRS code 0x43 (selection of 2nd word of position value 2). With conf2(22)=0, data for the recovery time measurement tm are not valid. Writing to the test register sets the internal counter of the recovery time measurement to the value of the 'write data' (31:16) - Init word or start value of the recovery time measurement. The value of the internal measuring counter is incremented with the system frequency during the time tm, and the carry is discarded. </description>
            </field>
            <field>
              <name>sel_test_mux3</name>
              <bitRange>[15:14]</bitRange>
              <description>(For testing at IC manufacturing site, internal resources can be read via test register 3) Write value test register 3        = 00 (Content written to test register 3 via the I/O port.) Test values counter TM measurement = 01 TM_High_Err &amp; TM_low_Err &amp; F_TM &amp; TM_CT2 &amp;TM_CT1 Limit values for TM measurement    = 10 C_WT_HIGH &amp; C_WT_LOW &amp; C_HIGH &amp; C_LOW Test values internal OEM Reg       = 11 (only available in customer-specific versions) </description>
            </field>
            <field>
              <name>sel_test_mux2</name>
              <bitRange>[13:12]</bitRange>
              <description>(For testing at IC manufacturing site, internal resources can be read via test register 4) Test_Mode_Divider = 0: Selection of test multiplexer 2: Test value Pos1b (Pos1 - Off2)      = 00 Test value Pos1c (Pos1 DIV nsrPos1) = 01 Test value Pos1d (Pos1 MOD srM)     = 10 Test value Pos2                     = 11 Test_Mode_Divider                   = 1 Selection of test multiplexer 2: Test value quotient (divider)  = 00 Test value remainder (divider) = 01 </description>
            </field>
            <field>
              <name>test_mode_divider</name>
              <bitRange>[11:11]</bitRange>
              <description>(For testing at IC manufacturing site, internal resources can be read via test register 4) Standard operating mode = 0 Test mode active = 1 </description>
            </field>
            <field>
              <name>selection_add_info</name>
              <bitRange>[10:8]</bitRange>
              <description>The number of required additional information units (ZI) can also be selected manually(alternatively to implemented ZI automation resources) Automated resources active = 0 00 IC sends clocks for one unit of additional information 1      = 0 01 IC sends clocks for one unit of additional information 2      = 0 10 IC sends clocks for two units of additional information (1+2) = 0 11 IC sends no clocks for additional information                 = 1 xx </description>
            </field>
            <field>
              <name>ic_test_mode</name>
              <bitRange>[7:7]</bitRange>
              <description>The IC can be switched to a special test mode, allowing the testing of internal modules Standard application mode = 0 Special test mode         = 1 </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[6:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sel_test_mux</name>
              <bitRange>[5:4]</bitRange>
              <description>(for testing at IC manufacturing site, internal resources can be read) Standard operating mode = 00 Central pre-dividers    = 01 Start bit counter       = 10 Delay counter and register, additional information bit = 11 </description>
            </field>
            <field>
              <name>test_receive_reg</name>
              <bitRange>[3:3]</bitRange>
              <description>Standard operating mode        = TST receive_reg = 0 Test mode for receive register = TST receive_reg = 1 By writing to the address of the receive registers, the content of test register 2 (bits (31:16) is transferred them. It is not possible to directly write to a receive register via the parallel port. </description>
            </field>
            <field>
              <name>selection_tst_out</name>
              <bitRange>[2:2]</bitRange>
              <description>For testing, the TST_OUT_PIN pin is assigned as follows: Internal (delayed by synchronization) DATA_RC_INT = 0 This signal is the signal that belongs to data strobe pulse. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[1:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'endat_receive4_0': 0xFF802030-->
          <name>endat_receive4_0</name>
          <description>Receive register 4 Receive register 4 contains position value 2 (Pos2), which is put together from the additional information 1 of Cycles 2, 3 and 4. Test function: with the test register 2 bits (13:12), internal test values can be read </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000030</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>byte4</name>
              <bitRange>[31:24]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>byte3</name>
              <bitRange>[23:16]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>byte2</name>
              <bitRange>[15:8]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>byte1</name>
              <bitRange>[7:0]</bitRange>
              <description>... </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'endat_receive4_1': 0xFF802034-->
          <name>endat_receive4_1</name>
          <description>Receive register 4 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000034</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>byte6</name>
              <bitRange>[15:8]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>byte5</name>
              <bitRange>[7:0]</bitRange>
              <description>... </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'endat_sw_strobe': 0xFF802038-->
          <name>endat_sw_strobe</name>
          <description>SW strobe </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000038</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>sw_strobe</name>
              <bitRange>[31:0]</bitRange>
              <description>Writing this register will in each case cause the first H/L transition of the TCLK transmission clock signal. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'endat_id': 0xFF80203C-->
          <name>endat_id</name>
          <description>Identification register The soft-macro specification (ID) is stored here. This information is helpful for automated configuration by higher-level user software. E22:  Designates the latest EnDat 2.2 protocol generation 6:    MAZeT-internal designation (E6) xxxx: Consecutive version number (this document is valid for all versions as of xx13.) </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000003C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>id</name>
              <bitRange>[31:0]</bitRange>
              <description>... </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>endat1_app</name>
      <description>endat1_app</description>
      <baseAddress>0xFF802040</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>64</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>endat_app1</name>
        <value>42</value>
      </interrupt>
      <registers>
        <register>
          <!--Absolute address of 'endat_send': 0xFF802040-->
          <name>endat_send</name>
          <description>Send register The send register contains data to be transmitted to the EnDat encoder. Mode command MRS code/address/port address (depends on the mode command) Parameters/instructions (depends on the mode command) </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x07000000</resetValue>
          <resetMask>0x3FFFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:30]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>byte4</name>
              <bitRange>[29:24]</bitRange>
              <description>Mode bits M[5:0] </description>
            </field>
            <field>
              <name>byte3</name>
              <bitRange>[23:16]</bitRange>
              <description>MRS code / Address / Port address A[7:0] </description>
            </field>
            <field>
              <name>byte2</name>
              <bitRange>[15:8]</bitRange>
              <description>Parameters / Instructions D[15:0] </description>
            </field>
            <field>
              <name>byte1</name>
              <bitRange>[7:0]</bitRange>
              <description>Parameters / Instructions D[7:0] </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'endat_receive1_0': 0xFF802044-->
          <name>endat_receive1_0</name>
          <description>Receive register 1 Depending on the transmitted type 2.1 mode command, receive register 1 contains different data. With EnDat type 2.2 mode commands and with SSI, the position value is always entered into receive-Reg 1. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>byte4</name>
              <bitRange>[31:24]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>byte3</name>
              <bitRange>[23:16]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>byte2</name>
              <bitRange>[15:8]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>byte1</name>
              <bitRange>[7:0]</bitRange>
              <description>... </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'endat_receive1_1': 0xFF802048-->
          <name>endat_receive1_1</name>
          <description>Receive register 1 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00FFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:24]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>byte7</name>
              <bitRange>[23:16]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>byte6</name>
              <bitRange>[15:8]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>byte5</name>
              <bitRange>[7:0]</bitRange>
              <description>... </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'endat_receive2': 0xFF80204C-->
          <name>endat_receive2</name>
          <description>Receive register 2 If a type 2.2 mode command was sent, receive register 2 will contain the contents of additional information 2 and its CRC. This data is to be interpreted in accordance with the EnDat Interface Description. In SSI protocol mode with double-word transmission, the redundant position value is stored here (right-aligned). </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>byte4</name>
              <bitRange>[31:24]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>byte3</name>
              <bitRange>[23:16]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>byte2</name>
              <bitRange>[15:8]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>byte1</name>
              <bitRange>[7:0]</bitRange>
              <description>... </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'endat_receive3': 0xFF802050-->
          <name>endat_receive3</name>
          <description>Receive register 3 If a type 2.2 mode command was sent, receive register 3 will contain the contents of additional information 1 and its CRC. This data is to be interpreted in accordance with the EnDat Interface Description. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000010</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>byte4</name>
              <bitRange>[31:24]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>byte3</name>
              <bitRange>[23:16]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>byte2</name>
              <bitRange>[15:8]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>byte1</name>
              <bitRange>[7:0]</bitRange>
              <description>... </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'endat_conf1': 0xFF802054-->
          <name>endat_conf1</name>
          <description>Configuration register 1 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000DF0</resetValue>
          <resetMask>0xFDFFFFF7</resetMask>
          <fields>
            <field>
              <name>endat_ssi</name>
              <bitRange>[31:30]</bitRange>
              <description>These two bits set either the EnDat (0x2) or the SSI (0x1) transmission mode. Values 0x0 and 0x3 are not permitted. Note: For debugging purposes, this function may also be used to perform an internal status engine software reset without clearing of the other internal registers. </description>
            </field>
            <field>
              <name>ic_reset</name>
              <bitRange>[29:29]</bitRange>
              <description>Setting of this bit has the effect that the entire interface component is reset to its initial state. IC reset inactive = 0 IC reset active = 1 </description>
            </field>
            <field>
              <name>f_sys</name>
              <bitRange>[28:26]</bitRange>
              <description>The system frequency actually used must be selected here. 64/48/32/50/100 MHz = 000/010/100/101/110 </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[25:25]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>delay_comp</name>
              <bitRange>[24:24]</bitRange>
              <description>Delay compensation. This bit switches propagation delay compensation on. When this bit is set, propagation time measurement is performed with the next data transmission to the EnDat encoder. The interface component determines the cable propagation time and saves this in conf_reg1. This value is used to determine propagation delay compensation. To measure the propagation time again, the delay compensation bit must be reset and set again. For 16-bit access it must be considered that the measured cable propagation time value is overwritten with 00/h. Delay compensation off = 0 Delay compensation on = 1 In SSI mode, this bit is always on: Delay compensation off = 0 (SSI mode) </description>
            </field>
            <field>
              <name>cable_prop_time</name>
              <bitRange>[23:16]</bitRange>
              <description>The cable propagation time determined by the interface component is stored here. (The application may change this value. If that is the case the status registers propagation time measurement (LZM) bit will automatically be reset). The binary value has a step width of one system clock. At a system clock of 64 MHz, this corresponds to a setting range from 0 us to 3.98 us in steps of 15.6 ns. The basic setting is 00 hex </description>
            </field>
            <field>
              <name>auto_reset</name>
              <bitRange>[15:15]</bitRange>
              <description>Autom. reset (automatic reset). If this bit is set, resetting of the status register and error register is performed automatically Autom. reset = 0 Resetting of the above-mentioned registers must be performed by the application. Autom. reset = 1 Resetting of the above-mentioned registers is done automatically. However, this resetting only occurs in the next EnDat transmission with the start of data reception. For safety applications: autom. reset = 0 </description>
            </field>
            <field>
              <name>reset_window</name>
              <bitRange>[14:14]</bitRange>
              <description>The set bit allows resetting of the status and error register only within a defined time period. Reset window = 0 Resetting of the registers mentioned above can be performed anytime (i.e. without considering malfunctions). Reset Window = 1 Resetting of the registers mentioned above must be performed within a defined time period for acceptance by the protocol engine. For safety applications: reset window = 1  </description>
            </field>
            <field>
              <name>data_word_len</name>
              <bitRange>[13:8]</bitRange>
              <description>Here the data word length is set binary with 6 bits for EnDat or SSI. The permissible setting range for EnDat is from 8 bits to 48 bits. The permissible setting range for SSI is from 8 bits to 48 bits. Data word length = 0 bits = 00 1000 : Data word length = 13 bits = 00 1101 : Data word length = 48 bits = 11 0000 Note: The Data word length has to set to 40/d bit while using mode command 'encoder transmit test values'. Note: In SSI mode the additionally required clock cycle for the parity bit is generated automatically by the circuit. </description>
            </field>
            <field>
              <name>f_tclk</name>
              <bitRange>[7:4]</bitRange>
              <description>Setting (4 bit) of transmission rate for EnDat and SSI from 100 kHz to 1 MHz (SSI) or 16 MHz (EnDat). Transmission frequency = 100kHz   = 1111 Transmission frequency = 200kHz   = 1110 Transmission frequency = 1MHz     = 1101 Transmission frequency = 2MHz     = 1100 Transmission frequency = 4.16MHz  = 1011 Transmission frequency = 8.33MHz  = 0110 Transmission frequency = 16.67MHz = 0000..0011 </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:3]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>endat_cont_clk_mode</name>
              <bitRange>[2:2]</bitRange>
              <description>This bit is used to select the EnDat continuous clock mode. Continuous clock off = 0 Continuous clock on = 1 </description>
            </field>
            <field>
              <name>uncond_transfer</name>
              <bitRange>[1:1]</bitRange>
              <description>This bit defines the unconditional data transfer to receive registers 1, 2, 3, 4 on completion of a data transmission process, despite a flag being set in the status register. Data transfer according to flag set in the status register = 0 Data transfer despite the flag in the status register = 1 For safety applications uncond_transfer = 1 must be set. </description>
            </field>
            <field>
              <name>hw_strobe</name>
              <bitRange>[0:0]</bitRange>
              <description>1: Enables external /STR signal as strobe signal </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'endat_conf2': 0xFF802058-->
          <name>endat_conf2</name>
          <description>Configuration register 2 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000018</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00040000</resetValue>
          <resetMask>0xFF7FFFFF</resetMask>
          <fields>
            <field>
              <name>hw_strobe_delay</name>
              <bitRange>[31:24]</bitRange>
              <description>Here the application can enter a value for the HW strobe delay. The binary value has a step width of one system clock. Setting 00 = Off, 3..255=3..255 system clock cycles The values 1, 2 are not permissible. At a system clock of 64 MHz, this corresponds to a value range from 46.88 ns to 3.98 us in steps of 15.6 ns. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[23:23]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>rtm</name>
              <bitRange>[22:22]</bitRange>
              <description>Activates the recovery time measurement that is then performed after each EnDat transmission with the mode command 1-1 'Encoder transmit position value and selection of memory area' with MRS code 0x43 (selection of 2nd word of position value 2). RTM=0 Recovery time measurement is deactivated (default setting after reset) RTM=1 Recovery time measurement is activated </description>
            </field>
            <field>
              <name>filter</name>
              <bitRange>[21:19]</bitRange>
              <description>The digital filter for the Data_RC data input can be adjusted in eight steps (3 bits) as shown in the table below. The filter setting value corresponds to system clock cycles. Setting 000 = Off Setting 001 = 3 Setting 010 = 4 Setting 011 = 5 Setting 100 = 6 Setting 101 = 10 Setting 110 = 20 Setting 111 = 40 Setting             000     001     010     011     100     101     110     111 Note on the application: The filter must be set according to the transmission rate of the serial interface to the encoder. Example: fTCLK = 1 MHz (corresponds to 64 system clock cycles with CLK = 64 MHz) For the filter, 1/10 of the fTCLK must be set. That means 6 system clock cycles leads to setting: 100 </description>
            </field>
            <field>
              <name>t_st</name>
              <bitRange>[18:16]</bitRange>
              <description>This time is to be set in accordance with EnDat specification. The set time has an accuracy of 0.1 us. Setting 000 = 0.5 * TCLK Setting 001 = 0.5 us Setting 010 = 1 us Setting 011 = 1.5 us Setting 100 = 2 us Setting 101 = 4 us Setting 110 = 8 us Setting 111 = 10 us </description>
            </field>
            <field>
              <name>watchdog</name>
              <bitRange>[15:8]</bitRange>
              <description>256 different watchdog time values can be set. In the default setting 00 hex or 80 hex the watchdog is off. </description>
            </field>
            <field>
              <name>timer_for_sampling_rate</name>
              <bitRange>[7:0]</bitRange>
              <description>256 different sampling rates can be set. In the default setting 00 hex or 80 hex the timer is off. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'endat_conf3': 0xFF80205C-->
          <name>endat_conf3</name>
          <description>Configuration register 3 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000001C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x000000CC</resetValue>
          <resetMask>0x000081FF</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>speed</name>
              <bitRange>[15:15]</bitRange>
              <description>(optional) This bit allows selection of the register width for velocity. 64-bit = 0 32-Bit = 1 </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[14:9]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>dw</name>
              <bitRange>[8:8]</bitRange>
              <description>This bit allows a double-word query to be selected with SSI transmission. Double-word query off = 0 Double word query on  = 1 </description>
            </field>
            <field>
              <name>singleturn_res</name>
              <bitRange>[7:3]</bitRange>
              <description>Here the number of steps per revolution is set to binary with 5 bits. This setting is only required for the fir tree format. Singleturn resolution = 13 bits = 0 1101 </description>
            </field>
            <field>
              <name>gray_to_binary</name>
              <bitRange>[2:2]</bitRange>
              <description>In SSI transmission mode, Gray code values can be converted here to binary code values. Gray-to-binary conversion inactive = 0 Gray-to-binary conversion inactive = 1 </description>
            </field>
            <field>
              <name>format</name>
              <bitRange>[1:1]</bitRange>
              <description>Here the transmission format for SSI transmission is selected. Fir tree: 0 Serial, right-aligned = 1 </description>
            </field>
            <field>
              <name>parity</name>
              <bitRange>[0:0]</bitRange>
              <description>Here the parity check for SSI transmission is selected. Parity off = 0 Parity on  = 1 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'endat_stat': 0xFF802060-->
          <name>endat_stat</name>
          <description>Status register The status bits are created by the sequencing controller of the interface component, as required. Status information remains set until it is reset by the application. The application can selectively reset status information with a write command. This occurs by writing 1 to the selected bits. In the event of concurrent access, the internal sequencing controller has priority. This ensures that status information is not 'lost'. The status bits (15:11) are only valid when additional information 1 or 2 has been received. Note on the application: The status register should be read after each data transmission. It provides information about validity of the data contained in the receive registers. The status bits must be reset in order that the internal sequencing controller can recognize a renewed setting of the status bits. Note: Each bit (except for LZM, LZK, Ready for Strobe) can trigger an interrupt (output: INT1). Masking is performed with the interrupt mask register. If a bit that has been set (and thus has triggered an interrupt) is reset, the INT1 output changes from low to three-state if no other bit has triggered an interrupt. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40000400</resetValue>
          <resetMask>0xF8C7FFFF</resetMask>
          <fields>
            <field>
              <name>ready</name>
              <bitRange>[31:31]</bitRange>
              <description>If the ready bit is set, the status register is completely updated. All checks have been performed. Data transmission is not yet completed, however, meaning that the EnDat protocol automation machine is not yet ready again. No Ready = 0 Ready    = 1 </description>
            </field>
            <field>
              <name>ready_for_strobe</name>
              <bitRange>[30:30]</bitRange>
              <description>This bit reports that data transmission has ended and that the EnDat protocol automation machine is ready for the next transmission. The time values Recovery time 1 (tm) and Recovery time 2 (tR) as specified in the EnDat specification are completed. No Ready = 0 Ready    = 1 This bit cannot be reset by writing a 1 to the respective bit as this is a status display of the current conditions of internal automation engines. The bit cannot cause an interrupt. </description>
            </field>
            <field>
              <name>speed_ready</name>
              <bitRange>[29:29]</bitRange>
              <description>(optional). This bit reports that a new velocity value has been calculated. No new velocity value calculated = 0 New velocity value calculated    = 1 </description>
            </field>
            <field>
              <name>rtm_stop</name>
              <bitRange>[28:28]</bitRange>
              <description>This bit indicates the end of the recovery time, if conf2(22)=1 during EnDat transmission with mode command 1-1 'Encoder transmit position value and selection of memory area' with MRS code 0x43 (selection of 2nd word of position value 2) </description>
            </field>
            <field>
              <name>rtm_start</name>
              <bitRange>[27:27]</bitRange>
              <description>This bit indicates the beginning of the recovery time, if conf2(22)=1 during EnDat transmission with mode command 1-1 'Encoder transmit position value and selection of memory area' with MRS code 0x43 (selection of 2nd word of position value 2) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[26:24]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>prop_time_measurement</name>
              <bitRange>[23:23]</bitRange>
              <description>(LZM). This bit reports that propagation time measurement was successfully completed. Condition: propagation delay compensation LZK in conf_reg1 is set. If the value for propagation delay compensation in configuration register 1 is corrected by the application, this bit will automatically be reset. LZM incomplete = 0 LZM complete   = 1 </description>
            </field>
            <field>
              <name>delay_comp</name>
              <bitRange>[22:22]</bitRange>
              <description>(LZK). This bit reports if propagation delay compensation is active. If propagation delay compensation in configuration register 1 is switched off, this bit and propagation time measurement will automatically be reset. LZK inactive = 0 LZK active   = 1 Neither the LZM nor the LZK bit can be reset by writing a 1 to the respective bit as this is a status display of the current conditions of internal automation engines. Neither of the two bits can cause an interrupt. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[21:19]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>f_type3</name>
              <bitRange>[18:18]</bitRange>
              <description>Type II error (transmission layer) triggers F type III. Error recognition occurs in the EnDat master. The error did not occur = 0 The error occurred      = 1 </description>
            </field>
            <field>
              <name>watchdog</name>
              <bitRange>[17:17]</bitRange>
              <description>Reports triggering of the watchdog. Condition: watchdog in conf_reg2 is set. Watchdog not triggered = 0 Watchdog triggered     = 1 </description>
            </field>
            <field>
              <name>spike</name>
              <bitRange>[16:16]</bitRange>
              <description>Reports that a Spike was detected at the data input port. Condition: filter in conf_reg1 is set. No spike       = 0 Spike occurred = 1 </description>
            </field>
            <field>
              <name>wrn</name>
              <bitRange>[15:15]</bitRange>
              <description>Contains the WRN status bit as transmitted in the EnDat protocol. WRN = 0 WRN = 1 </description>
            </field>
            <field>
              <name>rm</name>
              <bitRange>[14:14]</bitRange>
              <description>Contains the RM status bit as transmitted in the EnDat protocol. RM = 0 RM = 1 </description>
            </field>
            <field>
              <name>busy</name>
              <bitRange>[13:13]</bitRange>
              <description>Contains the Busy status bit as transmitted in the EnDat protocol. Busy = 0 Busy = 1 </description>
            </field>
            <field>
              <name>crc_zi2</name>
              <bitRange>[12:12]</bitRange>
              <description>During EnDat transmissions, this bit indicates the result of the CRC checking of additional information (ZI2). CRC check of ZI2 okay   = 0 CRC check of ZI2 faulty = 1 </description>
            </field>
            <field>
              <name>crc_zi1</name>
              <bitRange>[11:11]</bitRange>
              <description>During EnDat transmissions, this bit indicates the result of the CRC checking of additional information (ZI1). CRC check of ZI2 okay   = 0 CRC check of ZI2 faulty = 1 </description>
            </field>
            <field>
              <name>error2</name>
              <bitRange>[10:10]</bitRange>
              <description>Contains the /Error 2 status bit from the EnDat protocol (only with EnDat2.2 commands). /Error2 occurred      = 0 /Error2 did not occur = 1 </description>
            </field>
            <field>
              <name>receive3_reg</name>
              <bitRange>[9:9]</bitRange>
              <description>This status flag indicates that the data in Receive-Reg3 has been updated. It must be cleared after Receive-Reg3 has been read to allow the interface component to rewrite data. Receive-Reg3 not updated = 0 Receive-Reg3 updated     = 1 </description>
            </field>
            <field>
              <name>receive2_reg</name>
              <bitRange>[8:8]</bitRange>
              <description>This status flag indicates that the data in Receive-Reg 2 (3) has been updated. It must be cleared after Receive-Reg2 (3) has been read to allow the interface component to rewrite data. Receive-Reg2 (3) not updated = 0 Receive-Reg2 (3) updated     = 1 </description>
            </field>
            <field>
              <name>ir7</name>
              <bitRange>[7:7]</bitRange>
              <description>This bit indicates the state of input pin /IR7. Input /IR7 is at high level = 0 Input /IR7 is at low level  = 1 </description>
            </field>
            <field>
              <name>ir6</name>
              <bitRange>[6:6]</bitRange>
              <description>This bit indicates an H/L edge at input pin /IR6. No H/L edge transition at input /IR6 = 0 H/L edge transition has occurred at input /IR6R6 = 1 </description>
            </field>
            <field>
              <name>mrs_adr</name>
              <bitRange>[5:5]</bitRange>
              <description>The occurrence of an addressing or acknowledgement error is shown here as described in the EnDat Interface specification. The errors (F type I / II) are special cases of MRS/address errors, i.e. they are a sub-quantity of these. Accordingly, whenever a type I or type II error is identified, the MRS/Adr bit is set. For example, if an MRS/address bit is recognized incorrectly due to a disturbance, only the MRS/Adr status bit will be set, not the F TYP I/II bits. No acknowledgement or addressing error has occurred = 0 An acknowledgement or addressing error has occurred = 1 </description>
            </field>
            <field>
              <name>f_type2</name>
              <bitRange>[4:4]</bitRange>
              <description>Shows type II error handling in accordance with the EnDat specification at Annex A2. A type II error did not occur = 0 A type II error occurred = 1 </description>
            </field>
            <field>
              <name>f_type1</name>
              <bitRange>[3:3]</bitRange>
              <description>Shows type I error handling in accordance with the EnDat specification at Annex A2. A type I error did not occur = 0 A type I error occurred      = 1 </description>
            </field>
            <field>
              <name>crcpw_parity</name>
              <bitRange>[2:2]</bitRange>
              <description>This bit has two meanings. With EnDat transmission it represents the result of the CRC check of the received value (position value, parameter or test value). With SSI transmission it shows the result of the parity check. Condition: parity check in conf-Reg1 is switched on. CRC check or parity check okay = 0 CRC and parity check faulty    = 1 </description>
            </field>
            <field>
              <name>error1</name>
              <bitRange>[1:1]</bitRange>
              <description>The status bit error1 from the EnDat protocol is entered here. Error1 did not occur = 0 Error1 occurred = 1 </description>
            </field>
            <field>
              <name>receive1_reg</name>
              <bitRange>[0:0]</bitRange>
              <description>This status flag indicates that the data in Receive-Reg 1 has been updated. It must be cleared after Receive-Reg1 has been read to allow the interface component to rewrite data there. Receive-Reg1 not updated = 0 Receive-Reg1 updated     = 1 Note: This flag is ignored if the uncond_transfer bit is enabled in conf-Reg 1. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'endat_int': 0xFF802064-->
          <name>endat_int</name>
          <description>Interrupt mask The interrupt mask register is for the masking of the status registers interrupt sources. All bits shown in the status register (except for LZM, LZK, Ready for Strobe) can generate an interrupt. The bit assignments of the interrupt mask register are identical to those of the status register. An interrupt is allowed by setting the corresponding bit to 1. The INT output changes from three-state to low. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000024</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xA007FFFF</resetMask>
          <fields>
            <field>
              <name>ready</name>
              <bitRange>[31:31]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[30:30]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>speed_ready</name>
              <bitRange>[29:29]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[28:19]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>f_type3</name>
              <bitRange>[18:18]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>watchdog</name>
              <bitRange>[17:17]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>spike</name>
              <bitRange>[16:16]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>wrn</name>
              <bitRange>[15:15]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>RM</name>
              <bitRange>[14:14]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>busy</name>
              <bitRange>[13:13]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>crc_zi2</name>
              <bitRange>[12:12]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>crc_zi1</name>
              <bitRange>[11:11]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>error2</name>
              <bitRange>[10:10]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>receive3_reg</name>
              <bitRange>[9:9]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>receive2_reg</name>
              <bitRange>[8:8]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>ir7</name>
              <bitRange>[7:7]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>ir6</name>
              <bitRange>[6:6]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>mrs_adr</name>
              <bitRange>[5:5]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>f_type2</name>
              <bitRange>[4:4]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>f_type1</name>
              <bitRange>[3:3]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>crcpw_parity</name>
              <bitRange>[2:2]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>error1</name>
              <bitRange>[1:1]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>receive1_reg</name>
              <bitRange>[0:0]</bitRange>
              <description>... </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'endat_test1': 0xFF802068-->
          <name>endat_test1</name>
          <description>Test register 1 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000028</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFF7</resetMask>
          <fields>
            <field>
              <name>ic_test_values</name>
              <bitRange>[31:10]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>enDat_automation_engine</name>
              <bitRange>[9:4]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:3]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>status_zi</name>
              <bitRange>[2:1]</bitRange>
              <description>Allows testing of the IC-internal automation machine. IC sends no clocks for additional information = 00 IC sends clocks for one unit of additional information 1 = 01 IC sends clocks for one unit of additional information 2 = 10 IC sends clocks for two units of additional information (1+2) = 11 </description>
            </field>
            <field>
              <name>dl_high</name>
              <bitRange>[0:0]</bitRange>
              <description>For control of the EnDat automation machine. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'endat_test2': 0xFF80206C-->
          <name>endat_test2</name>
          <description>Test register 2 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000002C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFBC</resetMask>
          <fields>
            <field>
              <name>ic_test_data</name>
              <bitRange>[31:16]</bitRange>
              <description>RTM value - Counter value of the recovery time measurement if conf2(22)=1. Updated after the completion of the recovery time tm measurement during the EnDat transmission with mode command 1-1 'Encoder transmit position value and selection of memory area' with MRS code 0x43 (selection of 2nd word of position value 2). With conf2(22)=0, data for the recovery time measurement tm are not valid. Writing to the test register sets the internal counter of the recovery time measurement to the value of the 'write data' (31:16) - Init word or start value of the recovery time measurement. The value of the internal measuring counter is incremented with the system frequency during the time tm, and the carry is discarded. </description>
            </field>
            <field>
              <name>sel_test_mux3</name>
              <bitRange>[15:14]</bitRange>
              <description>(For testing at IC manufacturing site, internal resources can be read via test register 3) Write value test register 3        = 00 (Content written to test register 3 via the I/O port.) Test values counter TM measurement = 01 TM_High_Err &amp; TM_low_Err &amp; F_TM &amp; TM_CT2 &amp;TM_CT1 Limit values for TM measurement    = 10 C_WT_HIGH &amp; C_WT_LOW &amp; C_HIGH &amp; C_LOW Test values internal OEM Reg       = 11 (only available in customer-specific versions) </description>
            </field>
            <field>
              <name>sel_test_mux2</name>
              <bitRange>[13:12]</bitRange>
              <description>(For testing at IC manufacturing site, internal resources can be read via test register 4) Test_Mode_Divider = 0: Selection of test multiplexer 2: Test value Pos1b (Pos1 - Off2)      = 00 Test value Pos1c (Pos1 DIV nsrPos1) = 01 Test value Pos1d (Pos1 MOD srM)     = 10 Test value Pos2                     = 11 Test_Mode_Divider                   = 1 Selection of test multiplexer 2: Test value quotient (divider)  = 00 Test value remainder (divider) = 01 </description>
            </field>
            <field>
              <name>test_mode_divider</name>
              <bitRange>[11:11]</bitRange>
              <description>(For testing at IC manufacturing site, internal resources can be read via test register 4) Standard operating mode = 0 Test mode active = 1 </description>
            </field>
            <field>
              <name>selection_add_info</name>
              <bitRange>[10:8]</bitRange>
              <description>The number of required additional information units (ZI) can also be selected manually(alternatively to implemented ZI automation resources) Automated resources active = 0 00 IC sends clocks for one unit of additional information 1      = 0 01 IC sends clocks for one unit of additional information 2      = 0 10 IC sends clocks for two units of additional information (1+2) = 0 11 IC sends no clocks for additional information                 = 1 xx </description>
            </field>
            <field>
              <name>ic_test_mode</name>
              <bitRange>[7:7]</bitRange>
              <description>The IC can be switched to a special test mode, allowing the testing of internal modules Standard application mode = 0 Special test mode         = 1 </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[6:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sel_test_mux</name>
              <bitRange>[5:4]</bitRange>
              <description>(for testing at IC manufacturing site, internal resources can be read) Standard operating mode = 00 Central pre-dividers    = 01 Start bit counter       = 10 Delay counter and register, additional information bit = 11 </description>
            </field>
            <field>
              <name>test_receive_reg</name>
              <bitRange>[3:3]</bitRange>
              <description>Standard operating mode        = TST receive_reg = 0 Test mode for receive register = TST receive_reg = 1 By writing to the address of the receive registers, the content of test register 2 (bits (31:16) is transferred them. It is not possible to directly write to a receive register via the parallel port. </description>
            </field>
            <field>
              <name>selection_tst_out</name>
              <bitRange>[2:2]</bitRange>
              <description>For testing, the TST_OUT_PIN pin is assigned as follows: Internal (delayed by synchronization) DATA_RC_INT = 0 This signal is the signal that belongs to data strobe pulse. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[1:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'endat_receive4_0': 0xFF802070-->
          <name>endat_receive4_0</name>
          <description>Receive register 4 Receive register 4 contains position value 2 (Pos2), which is put together from the additional information 1 of Cycles 2, 3 and 4. Test function: with the test register 2 bits (13:12), internal test values can be read </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000030</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>byte4</name>
              <bitRange>[31:24]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>byte3</name>
              <bitRange>[23:16]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>byte2</name>
              <bitRange>[15:8]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>byte1</name>
              <bitRange>[7:0]</bitRange>
              <description>... </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'endat_receive4_1': 0xFF802074-->
          <name>endat_receive4_1</name>
          <description>Receive register 4 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000034</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>byte6</name>
              <bitRange>[15:8]</bitRange>
              <description>... </description>
            </field>
            <field>
              <name>byte5</name>
              <bitRange>[7:0]</bitRange>
              <description>... </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'endat_sw_strobe': 0xFF802078-->
          <name>endat_sw_strobe</name>
          <description>SW strobe </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000038</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>sw_strobe</name>
              <bitRange>[31:0]</bitRange>
              <description>Writing this register will in each case cause the first H/L transition of the TCLK transmission clock signal. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'endat_id': 0xFF80207C-->
          <name>endat_id</name>
          <description>Identification register The soft-macro specification (ID) is stored here. This information is helpful for automated configuration by higher-level user software. E22:  Designates the latest EnDat 2.2 protocol generation 6:    MAZeT-internal designation (E6) xxxx: Consecutive version number (this document is valid for all versions as of xx13.) </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000003C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>id</name>
              <bitRange>[31:0]</bitRange>
              <description>... </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>endat_ctrl0_app</name>
      <description>endat_ctrl0_app</description>
      <baseAddress>0xFF802080</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>16</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <!--Absolute address of 'endat_ctrl_trigger_cfg': 0xFF802080-->
          <name>endat_ctrl_trigger_cfg</name>
          <description>EnDat trigger configuration </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sel</name>
              <bitRange>[3:0]</bitRange>
              <description>Trigger source select This bit field configures which event is connected to the strobe signal of the EnDat core. A rising edge of the selected event will generate an event to the core according to the configuration in the strobe_cfg register. Note: When ntimer or n_si are selected, they are routed directly to the EnDat core (i.e. they are not connected to the pulse former). {       | Value   trigger event 0       none 1       manual 2       xc_trigger_out0 3       xc_trigger_out0 (inverted) 4       xc_trigger_out1 5       xc_trigger_out1 (inverted) 6       xc_sample_in0 7       xc_sample_in0 (inverted) 8       xc_sample_in1 9       xc_sample_in1 (inverted) 10      gpio_app_counter_zero0 11      gpio_app_counter_zero1 12      gpio_app_counter_zero2 13      ntimer signal of other EnDat instance 14      n_si signal of other EnDat instance 15      reserved } </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'endat_ctrl_trigger': 0xFF802084-->
          <name>endat_ctrl_trigger</name>
          <description>EnDat trigger </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>manual</name>
              <bitRange>[0:0]</bitRange>
              <description>Manual trigger. Writing '1' to this bit will trigger the EnDat core immediately in case the trigger_cfg.sel bit field is set to manual mode and the EnDat core is setup for external triggering by the strobe signal. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'endat_ctrl_strobe_cfg': 0xFF802088-->
          <name>endat_ctrl_strobe_cfg</name>
          <description>EnDat strobe pulse form configuration </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000303</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>high_len</name>
              <bitRange>[15:8]</bitRange>
              <description>Length of the high phase (i.e. inactive phase) of the strobe signal The high phase will be the programmed value + 1 clock cycle. Note: EnDat spec requires the high phase to be at least 4 clock cycles long, therefore 0 - 2 are illegal settings. Note: There is no other requirement on the high phase. This bit field is for debug and test only and should be kept at its default setting. </description>
            </field>
            <field>
              <name>low_len</name>
              <bitRange>[7:0]</bitRange>
              <description>Length of the low phase (i.e. active phase) of the strobe signal The low phase will be the programmed value + 1 clock cycle. Note: EnDat spec requires the low phase to be at least 4 clock cycles long, therefore 0 - 2 are illegal settings. Note: If a strobe delay is configured in the EnDat core, the minimum length is strobe delay + 1 (i.e. program low_len = strobe delay). </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>endat_ctrl1_app</name>
      <description>endat_ctrl1_app</description>
      <baseAddress>0xFF802090</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>16</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <!--Absolute address of 'endat_ctrl_trigger_cfg': 0xFF802090-->
          <name>endat_ctrl_trigger_cfg</name>
          <description>EnDat trigger configuration </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sel</name>
              <bitRange>[3:0]</bitRange>
              <description>Trigger source select This bit field configures which event is connected to the strobe signal of the EnDat core. A rising edge of the selected event will generate an event to the core according to the configuration in the strobe_cfg register. Note: When ntimer or n_si are selected, they are routed directly to the EnDat core (i.e. they are not connected to the pulse former). {       | Value   trigger event 0       none 1       manual 2       xc_trigger_out0 3       xc_trigger_out0 (inverted) 4       xc_trigger_out1 5       xc_trigger_out1 (inverted) 6       xc_sample_in0 7       xc_sample_in0 (inverted) 8       xc_sample_in1 9       xc_sample_in1 (inverted) 10      gpio_app_counter_zero0 11      gpio_app_counter_zero1 12      gpio_app_counter_zero2 13      ntimer signal of other EnDat instance 14      n_si signal of other EnDat instance 15      reserved } </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'endat_ctrl_trigger': 0xFF802094-->
          <name>endat_ctrl_trigger</name>
          <description>EnDat trigger </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>manual</name>
              <bitRange>[0:0]</bitRange>
              <description>Manual trigger. Writing '1' to this bit will trigger the EnDat core immediately in case the trigger_cfg.sel bit field is set to manual mode and the EnDat core is setup for external triggering by the strobe signal. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'endat_ctrl_strobe_cfg': 0xFF802098-->
          <name>endat_ctrl_strobe_cfg</name>
          <description>EnDat strobe pulse form configuration </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000303</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>high_len</name>
              <bitRange>[15:8]</bitRange>
              <description>Length of the high phase (i.e. inactive phase) of the strobe signal The high phase will be the programmed value + 1 clock cycle. Note: EnDat spec requires the high phase to be at least 4 clock cycles long, therefore 0 - 2 are illegal settings. Note: There is no other requirement on the high phase. This bit field is for debug and test only and should be kept at its default setting. </description>
            </field>
            <field>
              <name>low_len</name>
              <bitRange>[7:0]</bitRange>
              <description>Length of the low phase (i.e. active phase) of the strobe signal The low phase will be the programmed value + 1 clock cycle. Note: EnDat spec requires the low phase to be at least 4 clock cycles long, therefore 0 - 2 are illegal settings. Note: If a strobe delay is configured in the EnDat core, the minimum length is strobe delay + 1 (i.e. program low_len = strobe delay). </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>biss_ctrl0_app</name>
      <description>biss_ctrl0_app</description>
      <baseAddress>0xFF8020A0</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>32</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <!--Absolute address of 'biss_ctrl_trigger_cfg': 0xFF8020A0-->
          <name>biss_ctrl_trigger_cfg</name>
          <description>BiSS trigger configuration </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sel</name>
              <bitRange>[3:0]</bitRange>
              <description>Trigger source select This bit field configures which event is connected to the GETSENS signal of the BiSS core. A rising edge of the selected event will generate an event to the core. {       | Value   trigger event 0       none 1       manual 2       xc_trigger_out0 3       xc_trigger_out0 (inverted) 4       xc_trigger_out1 5       xc_trigger_out1 (inverted) 6       xc_sample_in0 7       xc_sample_in0 (inverted) 8       xc_sample_in1 9       xc_sample_in1 (inverted) 10      gpio_app_counter_zero0 11      gpio_app_counter_zero1 12      gpio_app_counter_zero2 13-15   reserved } </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_ctrl_trigger': 0xFF8020A4-->
          <name>biss_ctrl_trigger</name>
          <description>BiSS trigger </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>manual</name>
              <bitRange>[0:0]</bitRange>
              <description>Manual trigger. Writing '1' to this bit will trigger the BiSS core immediately in case the trigger_cfg.sel bit field is set to manual mode and the BiSS core is setup for external triggering by the GETSENS signal. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_ctrl_irq_raw': 0xFF8020A8-->
          <name>biss_ctrl_irq_raw</name>
          <description>BiSS raw IRQ: Read access shows status of unmasked IRQs.   IRQs are set automatically and reset by writing to this register: Write access with '1' resets the appropriate IRQ. Write access with '0' does not influence this bit. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:2]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>err</name>
              <bitRange>[1:1]</bitRange>
              <description>Error signal from the BiSS core. Only a falling edge on the NER signal will set the interrupt. </description>
            </field>
            <field>
              <name>eot</name>
              <bitRange>[0:0]</bitRange>
              <description>End-Of-Transmission signal from the BiSS core. Only a rising edge on the EOT signal will set the interrupt. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_ctrl_irq_masked': 0xFF8020AC-->
          <name>biss_ctrl_irq_masked</name>
          <description>BiSS masked IRQ: Shows status of masked IRQs. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:2]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>err</name>
              <bitRange>[1:1]</bitRange>
              <description>Error signal from the BiSS core. </description>
            </field>
            <field>
              <name>eot</name>
              <bitRange>[0:0]</bitRange>
              <description>End-Of-Transmission signal from the BiSS core. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_ctrl_irq_msk_set': 0xFF8020B0-->
          <name>biss_ctrl_irq_msk_set</name>
          <description>BiSS IRQ mask set: The IRQ mask enables interrupt requests for corresponding interrupt sources.   As its bits might be changed by different software tasks,   the IRQ mask register is not writable directly, but by set and reset masks: Write access with '1' sets interrupt mask bit. Write access with '0' does not influence this bit. Read access shows actual interrupt mask. Attention: Before activating interrupt mask, delete old pending interrupts by writing the same value to mtgy_irq_raw. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:2]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>err</name>
              <bitRange>[1:1]</bitRange>
              <description>Error signal from the BiSS core. </description>
            </field>
            <field>
              <name>eot</name>
              <bitRange>[0:0]</bitRange>
              <description>End-Of-Transmission signal from the BiSS core. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_ctrl_irq_msk_reset': 0xFF8020B4-->
          <name>biss_ctrl_irq_msk_reset</name>
          <description>BiSS IRQ mask reset: This is the corresponding reset mask to disable interrupt requests for corresponding interrupt sources: Write access with '1' resets interrupt mask bit. Write access with '0' does not influence this bit. Read access shows actual interrupt mask. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:2]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>err</name>
              <bitRange>[1:1]</bitRange>
              <description>Error signal from the BiSS core. </description>
            </field>
            <field>
              <name>eot</name>
              <bitRange>[0:0]</bitRange>
              <description>End-Of-Transmission signal from the BiSS core. </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>biss_ctrl1_app</name>
      <description>biss_ctrl1_app</description>
      <baseAddress>0xFF8020C0</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>32</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <!--Absolute address of 'biss_ctrl_trigger_cfg': 0xFF8020C0-->
          <name>biss_ctrl_trigger_cfg</name>
          <description>BiSS trigger configuration </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sel</name>
              <bitRange>[3:0]</bitRange>
              <description>Trigger source select This bit field configures which event is connected to the GETSENS signal of the BiSS core. A rising edge of the selected event will generate an event to the core. {       | Value   trigger event 0       none 1       manual 2       xc_trigger_out0 3       xc_trigger_out0 (inverted) 4       xc_trigger_out1 5       xc_trigger_out1 (inverted) 6       xc_sample_in0 7       xc_sample_in0 (inverted) 8       xc_sample_in1 9       xc_sample_in1 (inverted) 10      gpio_app_counter_zero0 11      gpio_app_counter_zero1 12      gpio_app_counter_zero2 13-15   reserved } </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_ctrl_trigger': 0xFF8020C4-->
          <name>biss_ctrl_trigger</name>
          <description>BiSS trigger </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>manual</name>
              <bitRange>[0:0]</bitRange>
              <description>Manual trigger. Writing '1' to this bit will trigger the BiSS core immediately in case the trigger_cfg.sel bit field is set to manual mode and the BiSS core is setup for external triggering by the GETSENS signal. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_ctrl_irq_raw': 0xFF8020C8-->
          <name>biss_ctrl_irq_raw</name>
          <description>BiSS raw IRQ: Read access shows status of unmasked IRQs.   IRQs are set automatically and reset by writing to this register: Write access with '1' resets the appropriate IRQ. Write access with '0' does not influence this bit. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:2]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>err</name>
              <bitRange>[1:1]</bitRange>
              <description>Error signal from the BiSS core. Only a falling edge on the NER signal will set the interrupt. </description>
            </field>
            <field>
              <name>eot</name>
              <bitRange>[0:0]</bitRange>
              <description>End-Of-Transmission signal from the BiSS core. Only a rising edge on the EOT signal will set the interrupt. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_ctrl_irq_masked': 0xFF8020CC-->
          <name>biss_ctrl_irq_masked</name>
          <description>BiSS masked IRQ: Shows status of masked IRQs. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:2]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>err</name>
              <bitRange>[1:1]</bitRange>
              <description>Error signal from the BiSS core. </description>
            </field>
            <field>
              <name>eot</name>
              <bitRange>[0:0]</bitRange>
              <description>End-Of-Transmission signal from the BiSS core. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_ctrl_irq_msk_set': 0xFF8020D0-->
          <name>biss_ctrl_irq_msk_set</name>
          <description>BiSS IRQ mask set: The IRQ mask enables interrupt requests for corresponding interrupt sources.   As its bits might be changed by different software tasks,   the IRQ mask register is not writable directly, but by set and reset masks: Write access with '1' sets interrupt mask bit. Write access with '0' does not influence this bit. Read access shows actual interrupt mask. Attention: Before activating interrupt mask, delete old pending interrupts by writing the same value to mtgy_irq_raw. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:2]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>err</name>
              <bitRange>[1:1]</bitRange>
              <description>Error signal from the BiSS core. </description>
            </field>
            <field>
              <name>eot</name>
              <bitRange>[0:0]</bitRange>
              <description>End-Of-Transmission signal from the BiSS core. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_ctrl_irq_msk_reset': 0xFF8020D4-->
          <name>biss_ctrl_irq_msk_reset</name>
          <description>BiSS IRQ mask reset: This is the corresponding reset mask to disable interrupt requests for corresponding interrupt sources: Write access with '1' resets interrupt mask bit. Write access with '0' does not influence this bit. Read access shows actual interrupt mask. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:2]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>err</name>
              <bitRange>[1:1]</bitRange>
              <description>Error signal from the BiSS core. </description>
            </field>
            <field>
              <name>eot</name>
              <bitRange>[0:0]</bitRange>
              <description>End-Of-Transmission signal from the BiSS core. </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>biss0_app</name>
      <description>biss0_app</description>
      <baseAddress>0xFF802100</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>256</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>biss_app0</name>
        <value>43</value>
      </interrupt>
      <registers>
        <register>
          <!--Absolute address of 'biss_scdata0_0': 0xFF802100-->
          <name>biss_scdata0_0</name>
          <description>Sensor and Actuator Data </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCDATA0_0</name>
              <bitRange>[31:0]</bitRange>
              <description>Slave0 (SCD)single cycle data[31:0] </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_scdata0_1': 0xFF802104-->
          <name>biss_scdata0_1</name>
          <description>Sensor and Actuator Data </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCDATA0_1</name>
              <bitRange>[31:0]</bitRange>
              <description>Slave0 (SCD)single cycle data[63:32] </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_scdata1_0': 0xFF802108-->
          <name>biss_scdata1_0</name>
          <description>Sensor and Actuator Data </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCDATA1_0</name>
              <bitRange>[31:0]</bitRange>
              <description>Slave1 (SCD)single cycle data[31:0] </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_scdata1_1': 0xFF80210C-->
          <name>biss_scdata1_1</name>
          <description>Sensor and Actuator Data </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCDATA1_1</name>
              <bitRange>[31:0]</bitRange>
              <description>Slave1 (SCD)single cycle data[63:32] </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_scdata2_0': 0xFF802110-->
          <name>biss_scdata2_0</name>
          <description>Sensor and Actuator Data </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCDATA2_0</name>
              <bitRange>[31:0]</bitRange>
              <description>Slave2 (SCD)single cycle data[31:0] </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_scdata2_1': 0xFF802114-->
          <name>biss_scdata2_1</name>
          <description>Sensor and Actuator Data </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCDATA2_1</name>
              <bitRange>[31:0]</bitRange>
              <description>Slave2 (SCD)single cycle data[63:32] </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_scdata3_0': 0xFF802118-->
          <name>biss_scdata3_0</name>
          <description>Sensor and Actuator Data </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000018</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCDATA3_0</name>
              <bitRange>[31:0]</bitRange>
              <description>Slave3 (SCD)single cycle data[31:0] </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_scdata3_1': 0xFF80211C-->
          <name>biss_scdata3_1</name>
          <description>Sensor and Actuator Data </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000001C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCDATA3_1</name>
              <bitRange>[31:0]</bitRange>
              <description>Slave3 (SCD)single cycle data[63:32] </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_scdata4_0': 0xFF802120-->
          <name>biss_scdata4_0</name>
          <description>Sensor and Actuator Data </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCDATA4_0</name>
              <bitRange>[31:0]</bitRange>
              <description>Slave4 (SCD)single cycle data[31:0] </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_scdata4_1': 0xFF802124-->
          <name>biss_scdata4_1</name>
          <description>Sensor and Actuator Data </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000024</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCDATA4_1</name>
              <bitRange>[31:0]</bitRange>
              <description>Slave4 (SCD)single cycle data[63:32] </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_scdata5_0': 0xFF802128-->
          <name>biss_scdata5_0</name>
          <description>Sensor and Actuator Data </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000028</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCDATA5_0</name>
              <bitRange>[31:0]</bitRange>
              <description>Slave5 (SCD)single cycle data[31:0] </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_scdata5_1': 0xFF80212C-->
          <name>biss_scdata5_1</name>
          <description>Sensor and Actuator Data </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000002C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCDATA5_1</name>
              <bitRange>[31:0]</bitRange>
              <description>Slave5 (SCD)single cycle data[63:32] </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_scdata6_0': 0xFF802130-->
          <name>biss_scdata6_0</name>
          <description>Sensor and Actuator Data </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000030</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCDATA6_0</name>
              <bitRange>[31:0]</bitRange>
              <description>Slave6 (SCD)single cycle data[31:0] </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_scdata6_1': 0xFF802134-->
          <name>biss_scdata6_1</name>
          <description>Sensor and Actuator Data </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000034</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCDATA6_1</name>
              <bitRange>[31:0]</bitRange>
              <description>Slave6 (SCD)single cycle data[63:32] </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_scdata7_0': 0xFF802138-->
          <name>biss_scdata7_0</name>
          <description>Sensor and Actuator Data </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000038</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCDATA7_0</name>
              <bitRange>[31:0]</bitRange>
              <description>Slave0 (SCD)single cycle data[31:0] </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_scdata7_1': 0xFF80213C-->
          <name>biss_scdata7_1</name>
          <description>Sensor and Actuator Data </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000003C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCDATA7_1</name>
              <bitRange>[31:0]</bitRange>
              <description>Slave7 (SCD)single cycle data[63:32] </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_rdata0': 0xFF802180-->
          <name>biss_rdata0</name>
          <description>Register Data </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000080</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDATA0</name>
              <bitRange>[31:0]</bitRange>
              <description>- Using register access in control communication RDATA0: register data DWord0 - Using command/instructions in control communication IDS: ID-Select, command/instruction addressing combinable </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_rdata1': 0xFF802184-->
          <name>biss_rdata1</name>
          <description>Register Data </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000084</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDATA1</name>
              <bitRange>[31:0]</bitRange>
              <description>register data DWord1 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_rdata2': 0xFF802188-->
          <name>biss_rdata2</name>
          <description>Register Data </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000088</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDATA2</name>
              <bitRange>[31:0]</bitRange>
              <description>register data DWord2 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_rdata3': 0xFF80218C-->
          <name>biss_rdata3</name>
          <description>Register Data </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000008C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDATA3</name>
              <bitRange>[31:0]</bitRange>
              <description>register data DWord3 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_rdata4': 0xFF802190-->
          <name>biss_rdata4</name>
          <description>Register Data </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000090</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDATA4</name>
              <bitRange>[31:0]</bitRange>
              <description>register data DWord4 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_rdata5': 0xFF802194-->
          <name>biss_rdata5</name>
          <description>Register Data </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000094</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDATA5</name>
              <bitRange>[31:0]</bitRange>
              <description>register data DWord5 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_rdata6': 0xFF802198-->
          <name>biss_rdata6</name>
          <description>Register Data </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000098</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDATA6</name>
              <bitRange>[31:0]</bitRange>
              <description>register data DWord6 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_rdata7': 0xFF80219C-->
          <name>biss_rdata7</name>
          <description>Register Data </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000009C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDATA7</name>
              <bitRange>[31:0]</bitRange>
              <description>register data DWord7 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_rdata8': 0xFF8021A0-->
          <name>biss_rdata8</name>
          <description>Register Data </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000A0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDATA8</name>
              <bitRange>[31:0]</bitRange>
              <description>register data DWord8 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_rdata9': 0xFF8021A4-->
          <name>biss_rdata9</name>
          <description>Register Data </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000A4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDATA9</name>
              <bitRange>[31:0]</bitRange>
              <description>register data DWord9 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_rdata10': 0xFF8021A8-->
          <name>biss_rdata10</name>
          <description>Register Data </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000A8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDATA10</name>
              <bitRange>[31:0]</bitRange>
              <description>register data DWord10 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_rdata11': 0xFF8021AC-->
          <name>biss_rdata11</name>
          <description>Register Data </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000AC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDATA11</name>
              <bitRange>[31:0]</bitRange>
              <description>register data DWord11 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_rdata12': 0xFF8021B0-->
          <name>biss_rdata12</name>
          <description>Register Data </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000B0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDATA12</name>
              <bitRange>[31:0]</bitRange>
              <description>register data DWord12 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_rdata13': 0xFF8021B4-->
          <name>biss_rdata13</name>
          <description>Register Data </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000B4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDATA13</name>
              <bitRange>[31:0]</bitRange>
              <description>register data DWord13 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_rdata14': 0xFF8021B8-->
          <name>biss_rdata14</name>
          <description>Register Data </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000B8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDATA14</name>
              <bitRange>[31:0]</bitRange>
              <description>register data DWord14 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_rdata15': 0xFF8021BC-->
          <name>biss_rdata15</name>
          <description>Register Data </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000BC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDATA15</name>
              <bitRange>[31:0]</bitRange>
              <description>register data DWord15 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_sc0': 0xFF8021C0-->
          <name>biss_sc0</name>
          <description>Slave Configuration </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000C0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCRCSTART0</name>
              <bitRange>[31:16]</bitRange>
              <description>Start value for polynomial SCD CRC calculation </description>
            </field>
            <field>
              <name>SELCRCS0</name>
              <bitRange>[15:15]</bitRange>
              <description>Selection between polynomial or length for SCD CRC polynomial 0: CRC bit length in SCRCLENx (see SCRCPOLYx) apply dedicated CRC polynomials 1: CRC polynomial(7:1) in SCRCPOLYx. SELCRCSx = 1 not applicable with CRC polynomial SCRCPOLYx(7:0) = 0x00 </description>
            </field>
            <field>
              <name>SCRCPOLY0</name>
              <bitRange>[14:8]</bitRange>
              <description>- SELCRCx == 0 ( SCRCLENx: polynomial selection by length for SCD CRC check) 0: CRC for single cycle data not present, CRC verification deactivated. SELCRCSx = 0b0 3: CRC polynomial = 0x0b 4: CRC polynomial = 0x13 5: CRC polynomial = 0x25 6: CRC polynomial = 0x43 7: CRC polynomial = 0x89 8: CRC polynomial = 0x12f 16: CRC polynomial = 0x190d9 ..: other CRC length are not permitted with SELCRCSx = 0 - SELCRCx == 1 (SCRCPOLYx: polynomial for SCD CRC check) 0x00       : CRC polynomial 0x00 not applicable with SELCRCSx = 1 0x01.. 0x7f: CRC polynomial for single cycle data = SCRCPOLYx(7:1) + 0x01 </description>
            </field>
            <field>
              <name>LSTOP0</name>
              <bitRange>[7:7]</bitRange>
              <description>- BISS mode(LSTOPx = Actuator stop bit control) 0: no leading STOP bit on single cycle actuator data 1: leading STOP bit on single cycle actuator data - SSI mode(GRAYSx = Enable SCD gray to binary conversion) 0: SSI single cycle data binary coded 1: SSI single cycle data gray coded </description>
            </field>
            <field>
              <name>ENSCD0</name>
              <bitRange>[6:6]</bitRange>
              <description>Enable single cycle data 0: single cycle data not available 1: single cycle data available </description>
            </field>
            <field>
              <name>SCDLEN0</name>
              <bitRange>[5:0]</bitRange>
              <description>Single cycle data length 0 : single cycle data length = 1 1 : single cycle data length = 2 ... single cycle data length = SCDLENx + 1 62: single cycle data length = 63 63: single cycle data length = 64 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_sc1': 0xFF8021C4-->
          <name>biss_sc1</name>
          <description>Slave Configuration </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000C4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCRCSTART1</name>
              <bitRange>[31:16]</bitRange>
              <description>Start value for polynomial SCD CRC calculation </description>
            </field>
            <field>
              <name>SELCRCS1</name>
              <bitRange>[15:15]</bitRange>
              <description>Selection between polynomial or length for SCD CRC polynomial 0: CRC bit length in SCRCLENx (see SCRCPOLYx) apply dedicated CRC polynomials 1: CRC polynomial(7:1) in SCRCPOLYx. SELCRCSx = 1 not applicable with CRC polynomial SCRCPOLYx(7:0) = 0x00 </description>
            </field>
            <field>
              <name>SCRCPOLY1</name>
              <bitRange>[14:8]</bitRange>
              <description>- SELCRCx == 0 ( SCRCLENx: polynomial selection by length for SCD CRC check) 0: CRC for single cycle data not present, CRC verification deactivated. SELCRCSx = 0b0 3: CRC polynomial = 0x0b 4: CRC polynomial = 0x13 5: CRC polynomial = 0x25 6: CRC polynomial = 0x43 7: CRC polynomial = 0x89 8: CRC polynomial = 0x12f 16: CRC polynomial = 0x190d9 ..: other CRC length are not permitted with SELCRCSx = 0 - SELCRCx == 1 (SCRCPOLYx: polynomial for SCD CRC check) 0x00       : CRC polynomial 0x00 not applicable with SELCRCSx = 1 0x01.. 0x7f: CRC polynomial for single cycle data = SCRCPOLYx(7:1) + 0x01 </description>
            </field>
            <field>
              <name>LSTOP1</name>
              <bitRange>[7:7]</bitRange>
              <description>- BISS mode(LSTOPx = Actuator stop bit control) 0: no leading STOP bit on single cycle actuator data 1: leading STOP bit on single cycle actuator data - SSI mode(GRAYSx = Enable SCD gray to binary conversion) 0: SSI single cycle data binary coded 1: SSI single cycle data gray coded </description>
            </field>
            <field>
              <name>ENSCD1</name>
              <bitRange>[6:6]</bitRange>
              <description>Enable single cycle data 0: single cycle data not available 1: single cycle data available </description>
            </field>
            <field>
              <name>SCDLEN1</name>
              <bitRange>[5:0]</bitRange>
              <description>Single cycle data length 0 : single cycle data length = 1 1 : single cycle data length = 2 ... single cycle data length = SCDLENx + 1 62: single cycle data length = 63 63: single cycle data length = 64 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_sc2': 0xFF8021C8-->
          <name>biss_sc2</name>
          <description>Slave Configuration </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000C8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCRCSTART2</name>
              <bitRange>[31:16]</bitRange>
              <description>Start value for polynomial SCD CRC calculation </description>
            </field>
            <field>
              <name>SELCRCS2</name>
              <bitRange>[15:15]</bitRange>
              <description>Selection between polynomial or length for SCD CRC polynomial 0: CRC bit length in SCRCLENx (see SCRCPOLYx) apply dedicated CRC polynomials 1: CRC polynomial(7:1) in SCRCPOLYx. SELCRCSx = 1 not applicable with CRC polynomial SCRCPOLYx(7:0) = 0x00 </description>
            </field>
            <field>
              <name>SCRCPOLY2</name>
              <bitRange>[14:8]</bitRange>
              <description>- SELCRCx == 0 ( SCRCLENx: polynomial selection by length for SCD CRC check) 0: CRC for single cycle data not present, CRC verification deactivated. SELCRCSx = 0b0 3: CRC polynomial = 0x0b 4: CRC polynomial = 0x13 5: CRC polynomial = 0x25 6: CRC polynomial = 0x43 7: CRC polynomial = 0x89 8: CRC polynomial = 0x12f 16: CRC polynomial = 0x190d9 ..: other CRC length are not permitted with SELCRCSx = 0 - SELCRCx == 1 (SCRCPOLYx: polynomial for SCD CRC check) 0x00       : CRC polynomial 0x00 not applicable with SELCRCSx = 1 0x01.. 0x7f: CRC polynomial for single cycle data = SCRCPOLYx(7:1) + 0x01 </description>
            </field>
            <field>
              <name>LSTOP2</name>
              <bitRange>[7:7]</bitRange>
              <description>- BISS mode(LSTOPx = Actuator stop bit control) 0: no leading STOP bit on single cycle actuator data 1: leading STOP bit on single cycle actuator data - SSI mode(GRAYSx = Enable SCD gray to binary conversion) 0: SSI single cycle data binary coded 1: SSI single cycle data gray coded </description>
            </field>
            <field>
              <name>ENSCD2</name>
              <bitRange>[6:6]</bitRange>
              <description>Enable single cycle data 0: single cycle data not available 1: single cycle data available </description>
            </field>
            <field>
              <name>SCDLEN2</name>
              <bitRange>[5:0]</bitRange>
              <description>Single cycle data length 0 : single cycle data length = 1 1 : single cycle data length = 2 ... single cycle data length = SCDLENx + 1 62: single cycle data length = 63 63: single cycle data length = 64 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_sc3': 0xFF8021CC-->
          <name>biss_sc3</name>
          <description>Slave Configuration </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000CC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCRCSTART3</name>
              <bitRange>[31:16]</bitRange>
              <description>Start value for polynomial SCD CRC calculation </description>
            </field>
            <field>
              <name>SELCRCS3</name>
              <bitRange>[15:15]</bitRange>
              <description>Selection between polynomial or length for SCD CRC polynomial 0: CRC bit length in SCRCLENx (see SCRCPOLYx) apply dedicated CRC polynomials 1: CRC polynomial(7:1) in SCRCPOLYx. SELCRCSx = 1 not applicable with CRC polynomial SCRCPOLYx(7:0) = 0x00 </description>
            </field>
            <field>
              <name>SCRCPOLY3</name>
              <bitRange>[14:8]</bitRange>
              <description>- SELCRCx == 0 ( SCRCLENx: polynomial selection by length for SCD CRC check) 0: CRC for single cycle data not present, CRC verification deactivated. SELCRCSx = 0b0 3: CRC polynomial = 0x0b 4: CRC polynomial = 0x13 5: CRC polynomial = 0x25 6: CRC polynomial = 0x43 7: CRC polynomial = 0x89 8: CRC polynomial = 0x12f 16: CRC polynomial = 0x190d9 ..: other CRC length are not permitted with SELCRCSx = 0 - SELCRCx == 1 (SCRCPOLYx: polynomial for SCD CRC check) 0x00       : CRC polynomial 0x00 not applicable with SELCRCSx = 1 0x01.. 0x7f: CRC polynomial for single cycle data = SCRCPOLYx(7:1) + 0x01 </description>
            </field>
            <field>
              <name>LSTOP3</name>
              <bitRange>[7:7]</bitRange>
              <description>- BISS mode(LSTOPx = Actuator stop bit control) 0: no leading STOP bit on single cycle actuator data 1: leading STOP bit on single cycle actuator data - SSI mode(GRAYSx = Enable SCD gray to binary conversion) 0: SSI single cycle data binary coded 1: SSI single cycle data gray coded </description>
            </field>
            <field>
              <name>ENSCD3</name>
              <bitRange>[6:6]</bitRange>
              <description>Enable single cycle data 0: single cycle data not available 1: single cycle data available </description>
            </field>
            <field>
              <name>SCDLEN3</name>
              <bitRange>[5:0]</bitRange>
              <description>Single cycle data length 0 : single cycle data length = 1 1 : single cycle data length = 2 ... single cycle data length = SCDLENx + 1 62: single cycle data length = 63 63: single cycle data length = 64 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_sc4': 0xFF8021D0-->
          <name>biss_sc4</name>
          <description>Slave Configuration </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000D0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCRCSTART4</name>
              <bitRange>[31:16]</bitRange>
              <description>Start value for polynomial SCD CRC calculation </description>
            </field>
            <field>
              <name>SELCRCS4</name>
              <bitRange>[15:15]</bitRange>
              <description>Selection between polynomial or length for SCD CRC polynomial 0: CRC bit length in SCRCLENx (see SCRCPOLYx) apply dedicated CRC polynomials 1: CRC polynomial(7:1) in SCRCPOLYx. SELCRCSx = 1 not applicable with CRC polynomial SCRCPOLYx(7:0) = 0x00 </description>
            </field>
            <field>
              <name>SCRCPOLY4</name>
              <bitRange>[14:8]</bitRange>
              <description>- SELCRCx == 0 ( SCRCLENx: polynomial selection by length for SCD CRC check) 0: CRC for single cycle data not present, CRC verification deactivated. SELCRCSx = 0b0 3: CRC polynomial = 0x0b 4: CRC polynomial = 0x13 5: CRC polynomial = 0x25 6: CRC polynomial = 0x43 7: CRC polynomial = 0x89 8: CRC polynomial = 0x12f 16: CRC polynomial = 0x190d9 ..: other CRC length are not permitted with SELCRCSx = 0 - SELCRCx == 1 (SCRCPOLYx: polynomial for SCD CRC check) 0x00       : CRC polynomial 0x00 not applicable with SELCRCSx = 1 0x01.. 0x7f: CRC polynomial for single cycle data = SCRCPOLYx(7:1) + 0x01 </description>
            </field>
            <field>
              <name>LSTOP4</name>
              <bitRange>[7:7]</bitRange>
              <description>- BISS mode(LSTOPx = Actuator stop bit control) 0: no leading STOP bit on single cycle actuator data 1: leading STOP bit on single cycle actuator data - SSI mode(GRAYSx = Enable SCD gray to binary conversion) 0: SSI single cycle data binary coded 1: SSI single cycle data gray coded </description>
            </field>
            <field>
              <name>ENSCD4</name>
              <bitRange>[6:6]</bitRange>
              <description>Enable single cycle data 0: single cycle data not available 1: single cycle data available </description>
            </field>
            <field>
              <name>SCDLEN4</name>
              <bitRange>[5:0]</bitRange>
              <description>Single cycle data length 0 : single cycle data length = 1 1 : single cycle data length = 2 ... single cycle data length = SCDLENx + 1 62: single cycle data length = 63 63: single cycle data length = 64 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_sc5': 0xFF8021D4-->
          <name>biss_sc5</name>
          <description>Slave Configuration </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000D4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCRCSTART5</name>
              <bitRange>[31:16]</bitRange>
              <description>Start value for polynomial SCD CRC calculation </description>
            </field>
            <field>
              <name>SELCRCS5</name>
              <bitRange>[15:15]</bitRange>
              <description>Selection between polynomial or length for SCD CRC polynomial 0: CRC bit length in SCRCLENx (see SCRCPOLYx) apply dedicated CRC polynomials 1: CRC polynomial(7:1) in SCRCPOLYx. SELCRCSx = 1 not applicable with CRC polynomial SCRCPOLYx(7:0) = 0x00 </description>
            </field>
            <field>
              <name>SCRCPOLY5</name>
              <bitRange>[14:8]</bitRange>
              <description>- SELCRCx == 0 ( SCRCLENx: polynomial selection by length for SCD CRC check) 0: CRC for single cycle data not present, CRC verification deactivated. SELCRCSx = 0b0 3: CRC polynomial = 0x0b 4: CRC polynomial = 0x13 5: CRC polynomial = 0x25 6: CRC polynomial = 0x43 7: CRC polynomial = 0x89 8: CRC polynomial = 0x12f 16: CRC polynomial = 0x190d9 ..: other CRC length are not permitted with SELCRCSx = 0 - SELCRCx == 1 (SCRCPOLYx: polynomial for SCD CRC check) 0x00       : CRC polynomial 0x00 not applicable with SELCRCSx = 1 0x01.. 0x7f: CRC polynomial for single cycle data = SCRCPOLYx(7:1) + 0x01 </description>
            </field>
            <field>
              <name>LSTOP5</name>
              <bitRange>[7:7]</bitRange>
              <description>- BISS mode(LSTOPx = Actuator stop bit control) 0: no leading STOP bit on single cycle actuator data 1: leading STOP bit on single cycle actuator data - SSI mode(GRAYSx = Enable SCD gray to binary conversion) 0: SSI single cycle data binary coded 1: SSI single cycle data gray coded </description>
            </field>
            <field>
              <name>ENSCD5</name>
              <bitRange>[6:6]</bitRange>
              <description>Enable single cycle data 0: single cycle data not available 1: single cycle data available </description>
            </field>
            <field>
              <name>SCDLEN5</name>
              <bitRange>[5:0]</bitRange>
              <description>Single cycle data length 0 : single cycle data length = 1 1 : single cycle data length = 2 ... single cycle data length = SCDLENx + 1 62: single cycle data length = 63 63: single cycle data length = 64 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_sc6': 0xFF8021D8-->
          <name>biss_sc6</name>
          <description>Slave Configuration </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000D8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCRCSTART6</name>
              <bitRange>[31:16]</bitRange>
              <description>Start value for polynomial SCD CRC calculation </description>
            </field>
            <field>
              <name>SELCRCS6</name>
              <bitRange>[15:15]</bitRange>
              <description>Selection between polynomial or length for SCD CRC polynomial 0: CRC bit length in SCRCLENx (see SCRCPOLYx) apply dedicated CRC polynomials 1: CRC polynomial(7:1) in SCRCPOLYx. SELCRCSx = 1 not applicable with CRC polynomial SCRCPOLYx(7:0) = 0x00 </description>
            </field>
            <field>
              <name>SCRCPOLY6</name>
              <bitRange>[14:8]</bitRange>
              <description>- SELCRCx == 0 ( SCRCLENx: polynomial selection by length for SCD CRC check) 0: CRC for single cycle data not present, CRC verification deactivated. SELCRCSx = 0b0 3: CRC polynomial = 0x0b 4: CRC polynomial = 0x13 5: CRC polynomial = 0x25 6: CRC polynomial = 0x43 7: CRC polynomial = 0x89 8: CRC polynomial = 0x12f 16: CRC polynomial = 0x190d9 ..: other CRC length are not permitted with SELCRCSx = 0 - SELCRCx == 1 (SCRCPOLYx: polynomial for SCD CRC check) 0x00       : CRC polynomial 0x00 not applicable with SELCRCSx = 1 0x01.. 0x7f: CRC polynomial for single cycle data = SCRCPOLYx(7:1) + 0x01 </description>
            </field>
            <field>
              <name>LSTOP6</name>
              <bitRange>[7:7]</bitRange>
              <description>- BISS mode(LSTOPx = Actuator stop bit control) 0: no leading STOP bit on single cycle actuator data 1: leading STOP bit on single cycle actuator data - SSI mode(GRAYSx = Enable SCD gray to binary conversion) 0: SSI single cycle data binary coded 1: SSI single cycle data gray coded </description>
            </field>
            <field>
              <name>ENSCD6</name>
              <bitRange>[6:6]</bitRange>
              <description>Enable single cycle data 0: single cycle data not available 1: single cycle data available </description>
            </field>
            <field>
              <name>SCDLEN6</name>
              <bitRange>[5:0]</bitRange>
              <description>Single cycle data length 0 : single cycle data length = 1 1 : single cycle data length = 2 ... single cycle data length = SCDLENx + 1 62: single cycle data length = 63 63: single cycle data length = 64 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_sc7': 0xFF8021DC-->
          <name>biss_sc7</name>
          <description>Slave Configuration </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000DC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCRCSTART7</name>
              <bitRange>[31:16]</bitRange>
              <description>Start value for polynomial SCD CRC calculation </description>
            </field>
            <field>
              <name>SELCRCS7</name>
              <bitRange>[15:15]</bitRange>
              <description>Selection between polynomial or length for SCD CRC polynomial 0: CRC bit length in SCRCLENx (see SCRCPOLYx) apply dedicated CRC polynomials 1: CRC polynomial(7:1) in SCRCPOLYx. SELCRCSx = 1 not applicable with CRC polynomial SCRCPOLYx(7:0) = 0x00 </description>
            </field>
            <field>
              <name>SCRCPOLY7</name>
              <bitRange>[14:8]</bitRange>
              <description>- SELCRCx == 0 (SCRCLENx: polynomial selection by length for SCD CRC check) 0: CRC for single cycle data not present, CRC verification deactivated. SELCRCSx = 0b0 3: CRC polynomial = 0x0b 4: CRC polynomial = 0x13 5: CRC polynomial = 0x25 6: CRC polynomial = 0x43 7: CRC polynomial = 0x89 8: CRC polynomial = 0x12f 16: CRC polynomial = 0x190d9 ..: other CRC length are not permitted with SELCRCSx = 0 - SELCRCx == 1 (SCRCPOLYx: polynomial for SCD CRC check) 0x00       : CRC polynomial 0x00 not applicable with SELCRCSx = 1 0x01.. 0x7f: CRC polynomial for single cycle data = SCRCPOLYx(7:1) + 0x01 </description>
            </field>
            <field>
              <name>LSTOP7</name>
              <bitRange>[7:7]</bitRange>
              <description>- BISS mode(LSTOPx = Actuator stop bit control) 0: no leading STOP bit on single cycle actuator data 1: leading STOP bit on single cycle actuator data - SSI mode(GRAYSx = Enable SCD gray to binary conversion) 0: SSI single cycle data binary coded 1: SSI single cycle data gray coded </description>
            </field>
            <field>
              <name>ENSC7</name>
              <bitRange>[6:6]</bitRange>
              <description>Enable single cycle data 0: single cycle data not available 1: single cycle data available </description>
            </field>
            <field>
              <name>SCDLEN7</name>
              <bitRange>[5:0]</bitRange>
              <description>Single cycle data length 0 : single cycle data length = 1 1 : single cycle data length = 2 ... single cycle data length = SCDLENx + 1 62: single cycle data length = 63 63: single cycle data length = 64 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_ccc0': 0xFF8021E0-->
          <name>biss_ccc0</name>
          <description>Register Communication Configuration </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000E0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x3FFF0000</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:30]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>REGNUM</name>
              <bitRange>[29:24]</bitRange>
              <description>Register data count 0x00       : register count = 1 0x01 ..0x3f: register count = REGNUM(5:0)+1 </description>
            </field>
            <field>
              <name>WNR</name>
              <bitRange>[23:23]</bitRange>
              <description>Register access read/write selector 0: read register data 1: write register data </description>
            </field>
            <field>
              <name>REGADR</name>
              <bitRange>[22:16]</bitRange>
              <description>Register access start address 0x00 .. 0x7f </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[15:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_ccc1_mc0': 0xFF8021E4-->
          <name>biss_ccc1_mc0</name>
          <description>Register Communication Configuration / Master Configuration </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000E4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x03FFFB03</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:26]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>NOCRC</name>
              <bitRange>[25:25]</bitRange>
              <description>CRC for SCD not to be stored in RAM 0: CRC of SCD is stored RAM (only applicable with active CRC verification and CRC polynome &gt; 0) 1: CRC of SCD not to be stored in RAM </description>
            </field>
            <field>
              <name>SINGLEBANK</name>
              <bitRange>[24:24]</bitRange>
              <description>Use of only one RAM bank for SCD 0: two RAM banks are used for SCD 1: one RAM bank is used for SCD </description>
            </field>
            <field>
              <name>FREQR</name>
              <bitRange>[23:21]</bitRange>
              <description>Frequency division register communication BiSS B 0 .. 7: freqSens/(2*(FREQ(7:5)+1)) 0: FreqSens/2 1: FreqSens/4 2: FreqSens/8 3: FreqSens/16 4: FreqSens/32 5: FreqSens/64 6: FreqSens/128 7: FreqSens/256 </description>
            </field>
            <field>
              <name>FREQS</name>
              <bitRange>[20:16]</bitRange>
              <description>Frequency division 0x00: fCLK/2 0x01: fCLK/4 0x02: fCLK/6 0x03: fCLK/8 ... 0x09: fCLK/20 ... 0x0d: fCLK/28 0x0e: fCLK/30 0x0f: fCLK/32 0x10: not permitted 0x11: fCLK/40 0x12: fCLK/60 0x13: fCLK/80 ... 0x1d: fCLK/280 0x1e: fCLK/300 0x1f: fCLK/320 </description>
            </field>
            <field>
              <name>CTS</name>
              <bitRange>[15:15]</bitRange>
              <description>Register transmission or instruction selector 0: command/instruction communication 1: register communication </description>
            </field>
            <field>
              <name>REGVERS</name>
              <bitRange>[14:14]</bitRange>
              <description>BiSS model A/B or C selector - Using register access in control communication 0: register communication BiSS A/B 1: register communication BiSS C - Using command/instructions in control communication 0: not applicable with command/instruction communication 1: command communication BiSS C </description>
            </field>
            <field>
              <name>CMD</name>
              <bitRange>[13:12]</bitRange>
              <description>- Using register access in control communication SLAVEID[2:1]: slave selector bit2_1 - Using command/instructions in control communication Command of access slave     # default 0x00 0x00 .. 0x03: command/instruction 0b00 .. 0b11 </description>
            </field>
            <field>
              <name>IDA_TEST</name>
              <bitRange>[11:11]</bitRange>
              <description>- Using register access in control communication SLAVEID[0]: slave selector bit0 - Using command/instructions in control communication IDA_TEST: command/instruction execution control 0: the slaves feedback (IDA) is tested before execution (EX bit after IDA) 1: immediate execution </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[10:10]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>EN_MO</name>
              <bitRange>[9:9]</bitRange>
              <description>Enable output at MOx for actuator data or delayed start bit 0: MO forced to low 1: Parameterized processing time by master on MO signal active (length: MO_BUSY) </description>
            </field>
            <field>
              <name>HOLDCDM</name>
              <bitRange>[8:8]</bitRange>
              <description>Hold CDM(control data master) 0: clock line high at end of cycle 1: clock line constant with CDM bit until start of next cycle </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[7:2]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>CHSEL</name>
              <bitRange>[1:0]</bitRange>
              <description>Channel selector 0: channel 1 used for control communication, channel 2 not used 1: channel 1 used for control communication, channel 2 not used 2: channel 2 used for control communication, channel 1 not used. Note: Channel 2 is not available with IC-MB4 TSSOP24 3: channel 1,2 used for control communication. Note: Channel 2 is not available with IC-MB4 TSSOP24 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_mc1': 0xFF8021E8-->
          <name>biss_mc1</name>
          <description>Master Configuration </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000E8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VERSION</name>
              <bitRange>[31:24]</bitRange>
              <description>Device identifier 0x83: iC-MB3 0x84: iC-MB4 .. 0xff </description>
            </field>
            <field>
              <name>REVISION</name>
              <bitRange>[23:16]</bitRange>
              <description>Revision 0x10: Z(first revision) 0x11: Z1 0x12: Y .. 0xff </description>
            </field>
            <field>
              <name>MO_BUSY</name>
              <bitRange>[15:8]</bitRange>
              <description>Delay of start bit at output MOx 0x00 .. 0xff: count of MA clocks as the parameterized processing time by master on MO signal Premise: EN_MO = 1 </description>
            </field>
            <field>
              <name>FREQAGS</name>
              <bitRange>[7:0]</bitRange>
              <description>AutoGetSens Frequency division 0x00.. 0x7b: fCLK/(20*(FREQAGS(6:0)+1)) 0x7c       : AGSMIN( the master automatically restarts the next cycle after the prior was finished. AGSMIN is the fastest SCD rate with complete SCD cycles. ) 0x7d.. 0x7f: AGSINFINITE( the master does not automatically restart the next cycle after the prior one was finished. AGSINFINITE requires a trigger event to start the next SCD cycle. ) 0x80.. 0xff: fCLK/(625*(FREQAGS(6:0)+1)) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_cc_sl': 0xFF8021EC-->
          <name>biss_cc_sl</name>
          <description>Channel Configuration </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000EC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFF000F1F</resetMask>
          <fields>
            <field>
              <name>ACTnSENS</name>
              <bitRange>[31:24]</bitRange>
              <description>Sensor or actuator data selector 0x00: all slaves are sensors 0x01: slave 0 is actuator 0x02: slave 1 is actuator 0x04: slave 2 is actuator 0x08: slave 3 is actuator 0x10: slave 4 is actuator 0x20: slave 5 is actuator 0x40: slave 6 is actuator 0x80: slave 7 is actuator 0xff: all slaves are actuators </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[23:12]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>CFGCH2</name>
              <bitRange>[11:10]</bitRange>
              <description>Channel 2 configuration 0x00: BiSS B 0x01: BiSS C 0x02: SSI 0x03: channel is not used </description>
            </field>
            <field>
              <name>CFGCH1</name>
              <bitRange>[9:8]</bitRange>
              <description>Channel 1 configuration 0x00: BiSS B 0x01: BiSS C 0x02: SSI 0x03: channel is not used </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[7:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>SLAVELOC5</name>
              <bitRange>[4:4]</bitRange>
              <description>Slave location 0: slaves 4-7 are connected to channel 1 1: slaves 4-7 are connected to channel 2(only available with iC-MB4 QFN28) </description>
            </field>
            <field>
              <name>cc_sl_reserved1</name>
              <bitRange>[3:0]</bitRange>
              <description>no field descpription</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_status0': 0xFF8021F0-->
          <name>biss_status0</name>
          <description>Status Information </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000F0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFAAAAFF</resetMask>
          <fields>
            <field>
              <name>CDMTIMEOUT</name>
              <bitRange>[31:31]</bitRange>
              <description>CDM(Control Data Master) timeout reached 0: CDMTIMEOUT not reached 1: CDMTIMEOUT reached </description>
            </field>
            <field>
              <name>CDSSEL</name>
              <bitRange>[30:30]</bitRange>
              <description>CDS(Control Data Slave) bit from the selected channel </description>
            </field>
            <field>
              <name>REGBYTES</name>
              <bitRange>[29:24]</bitRange>
              <description>Number of valid register data transmission in case of error 0x00       : after transfer: no register communication error 0x01 . 0x3f: after transfer: number of successfully transferred registers before register communication error </description>
            </field>
            <field>
              <name>SVALID7</name>
              <bitRange>[23:23]</bitRange>
              <description>SCDATA7 validity indication 0: SCD invalid 1: SCD valid The SVALIDx bit indicates the validity of each slaves SCD CRC verification. A prior set SVALIDx bit can be reset by writing 0 into the register. </description>
            </field>
            <field>
              <name>bf_align7</name>
              <bitRange>[22:22]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>SVALID6</name>
              <bitRange>[21:21]</bitRange>
              <description>SCDATA6 validity indication 0: SCD invalid 1: SCD valid The SVALIDx bit indicates the validity of each slaves SCD CRC verification. A prior set SVALIDx bit can be reset by writing 0 into the register. </description>
            </field>
            <field>
              <name>bf_align6</name>
              <bitRange>[20:20]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>SVALID5</name>
              <bitRange>[19:19]</bitRange>
              <description>SCDATA5 validity indication 0: SCD invalid 1: SCD valid The SVALIDx bit indicates the validity of each slaves SCD CRC verification. A prior set SVALIDx bit can be reset by writing 0 into the register. </description>
            </field>
            <field>
              <name>bf_align5</name>
              <bitRange>[18:18]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>SVALID4</name>
              <bitRange>[17:17]</bitRange>
              <description>SCDATA4 validity indication 0: SCD invalid 1: SCD valid The SVALIDx bit indicates the validity of each slaves SCD CRC verification. A prior set SVALIDx bit can be reset by writing 0 into the register. </description>
            </field>
            <field>
              <name>bf_align4</name>
              <bitRange>[16:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>SVALID3</name>
              <bitRange>[15:15]</bitRange>
              <description>SCDATA3 validity indication 0: SCD invalid 1: SCD valid The SVALIDx bit indicates the validity of each slaves SCD CRC verification. A prior set SVALIDx bit can be reset by writing 0 into the register. </description>
            </field>
            <field>
              <name>bf_align3</name>
              <bitRange>[14:14]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>SVALID2</name>
              <bitRange>[13:13]</bitRange>
              <description>SCDATA2 validity indication 0: SCD invalid 1: SCD valid The SVALIDx bit indicates the validity of each slaves SCD CRC verification. A prior set SVALIDx bit can be reset by writing 0 into the register. </description>
            </field>
            <field>
              <name>bf_align2</name>
              <bitRange>[12:12]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>SVALID1</name>
              <bitRange>[11:11]</bitRange>
              <description>SCDATA1 validity indication 0: SCD invalid 1: SCD valid The SVALIDx bit indicates the validity of each slaves SCD CRC verification. A prior set SVALIDx bit can be reset by writing 0 into the register. </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[10:10]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>SVALID0</name>
              <bitRange>[9:9]</bitRange>
              <description>SCDATA0 validity indication 0: SCD invalid 1: SCD valid The SVALIDx bit indicates the validity of each slaves SCD CRC verification. A prior set SVALIDx bit can be reset by writing 0 into the register. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[8:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>nERR</name>
              <bitRange>[7:7]</bitRange>
              <description>Transmission error (error at NER pin) 0: error 1: no error It is possible to connect other components to pin NER which can also generate an error message; this can then be read out via this bit. </description>
            </field>
            <field>
              <name>nAGSERR</name>
              <bitRange>[6:6]</bitRange>
              <description>AGS error 0: AGS(Automatic Get Sensor data) watchdog error 1: no AGS watchdog error An AGS watchdog error is set during the automatic transmission of sensor data if no new cycle could be initiated; bit AGS in the command register is reset and the automatic request of sensor data aborted. </description>
            </field>
            <field>
              <name>nDELAYERR</name>
              <bitRange>[5:5]</bitRange>
              <description>Missing start bit during register communication 0: delay error 1: no delay error </description>
            </field>
            <field>
              <name>nSCDERR</name>
              <bitRange>[4:4]</bitRange>
              <description>Error in single cycle data transmission 0: error in last single cycle data transmission 1: no error in last single cycle data transmission </description>
            </field>
            <field>
              <name>nREGERR</name>
              <bitRange>[3:3]</bitRange>
              <description>Error in register data transmission 0: error in last register data transmission 1: no error in last register data transmission </description>
            </field>
            <field>
              <name>REGEND</name>
              <bitRange>[2:2]</bitRange>
              <description>Register data transmission completed 0: no valid register data available 1: register data transmission completed </description>
            </field>
            <field>
              <name>status0_reserved1</name>
              <bitRange>[1:1]</bitRange>
              <description>reserved value</description>
            </field>
            <field>
              <name>EOT</name>
              <bitRange>[0:0]</bitRange>
              <description>Data transmission completed 0: data transmission active 1: data transmission finished </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_ir': 0xFF8021F4-->
          <name>biss_ir</name>
          <description>Instruction Register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000F4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>MAVO</name>
              <bitRange>[15:15]</bitRange>
              <description>Not selected MA line control level 0: low definition of unselected(CHSEL) MA clock lines 1: high definition of unselected(CHSEL) MA clock lines </description>
            </field>
            <field>
              <name>MAFO</name>
              <bitRange>[14:14]</bitRange>
              <description>Not selected MA line control selection 0: controlling unselected(CHSEL) MA clock line: using MA signal 1: controlling unselected(CHSEL) MA clock line: using MAVS level </description>
            </field>
            <field>
              <name>MAVS</name>
              <bitRange>[13:13]</bitRange>
              <description>Selected MA line control level 0: low definition of selected(CHSEL) MA clock lines 1: high definition of selected(CHSEL) MA clock lines </description>
            </field>
            <field>
              <name>MAFS</name>
              <bitRange>[12:12]</bitRange>
              <description>Selected MA line control selection 0: controlling selected/CHSEL) MA clock line: using MA signal 1: controlling selected(CHSEL) MA clock line: using MAVS level </description>
            </field>
            <field>
              <name>CFGIF</name>
              <bitRange>[11:10]</bitRange>
              <description>Configure physical interface 0x00: TTL 0x01: CMOS 0x02: RS422 0x03: LVDS </description>
            </field>
            <field>
              <name>ENTEST</name>
              <bitRange>[9:9]</bitRange>
              <description>Enable test interface 0: device in normal operation mode 1: device in test mode </description>
            </field>
            <field>
              <name>CLKENI</name>
              <bitRange>[8:8]</bitRange>
              <description>Enable internal clock 0: the master clock is generated by an external clock oscillator 1: the master clock is generated by the basic clock of the internal 20MHz oscillator </description>
            </field>
            <field>
              <name>BREAK</name>
              <bitRange>[7:7]</bitRange>
              <description>Data transmission interrupt 0: no change 1: abort data transmission nSCDERR, nREGERR, nDELAYERR, nAGSERR = 1, REGEND = 0 All current actions can be aborted using the BREAK command so that a defined state can be resumed if one of the sensors proves faulty, for example. BREAK= 1 aborts the active data transmission and all status information will be reset. </description>
            </field>
            <field>
              <name>HOLDBANK</name>
              <bitRange>[6:6]</bitRange>
              <description>RAM bank control 0: no bank switching lock permitted 1: bank switching lock permitted During the readout of more than one sensor data register by the controller it is possible that the RAM banks in the master could be swapped over once a sensor data transmission is completed. So that the controller only reads related values bit HOLDBANK should be set at the start of the readout and reset at the end; this suppresses the RAM swap. With the start of a new sensor data cycle previous values are then overwritten by the new sensor data. </description>
            </field>
            <field>
              <name>SWBANK</name>
              <bitRange>[5:5]</bitRange>
              <description>Switch RAM banks 0: RAM banks are not switched 1: RAM banks are switched </description>
            </field>
            <field>
              <name>INIT</name>
              <bitRange>[4:4]</bitRange>
              <description>Start INIT sequence 0: no changes on the data channel 1: initialize data channel </description>
            </field>
            <field>
              <name>INSTR</name>
              <bitRange>[3:1]</bitRange>
              <description>SCD control instruction 0b010       : CDM = 0 0b001       : CDM = 1 0b100, 0b110: register communication condition: CDMTIMEOUT = 1 0b111       : register communication(reduced protocol) condition: CDMTIMEOUT = 1 The transmission of sensor data can be triggered via INSTR. With INSTR=0b010 the ccle finishes with a CDM=0. With INSTR= 0b001 the cycle finishes with a CDM=1. A BiSS C register access to a slave can be operated by INSTR=0b100. A reduced protocol for a shorter BiSS C register access to a slave can be operated by INST=0b111. </description>
            </field>
            <field>
              <name>AGS</name>
              <bitRange>[0:0]</bitRange>
              <description>AutoGetSens(Automatic Get Sensordata) 0: no automatic data transmission 1: - start of data transmission after TIMEOUTSENS condition: FREQAGS = AGSMIN - start of data transmission triggered by pin condition: FREQAGS = AGSINFINITE - start of data transmission after timeout With AGS = 0 the master starts the data transmission after finishing writing the instruction register(rising edge of NWR). A nAGSERR error will be generated if the SL line is low, TIMEOUTSENS has not exceeded. If an AGS bit has been set sensor data is read in cyclically according to the cycle frequency set in FREQAGS. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_status1': 0xFF8021F8-->
          <name>biss_status1</name>
          <description>Status Information </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000F8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x01000003</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:25]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>SWBANKFAILS</name>
              <bitRange>[24:24]</bitRange>
              <description>Bank switching status 0: bank switching(SCD) successful 1: bank switching(SCD) not successful </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[23:2]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>CDS1</name>
              <bitRange>[1:1]</bitRange>
              <description>CDS bit of channel 1 0: CDS = 0 1: CDS = 1 </description>
            </field>
            <field>
              <name>SL1</name>
              <bitRange>[0:0]</bitRange>
              <description>Current SL line level of channel 1 0: SL line level low 1: SL line level high </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>biss1_app</name>
      <description>biss1_app</description>
      <baseAddress>0xFF802200</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>256</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>biss_app1</name>
        <value>44</value>
      </interrupt>
      <registers>
        <register>
          <!--Absolute address of 'biss_scdata0_0': 0xFF802200-->
          <name>biss_scdata0_0</name>
          <description>Sensor and Actuator Data </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCDATA0_0</name>
              <bitRange>[31:0]</bitRange>
              <description>Slave0 (SCD)single cycle data[31:0] </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_scdata0_1': 0xFF802204-->
          <name>biss_scdata0_1</name>
          <description>Sensor and Actuator Data </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCDATA0_1</name>
              <bitRange>[31:0]</bitRange>
              <description>Slave0 (SCD)single cycle data[63:32] </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_scdata1_0': 0xFF802208-->
          <name>biss_scdata1_0</name>
          <description>Sensor and Actuator Data </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCDATA1_0</name>
              <bitRange>[31:0]</bitRange>
              <description>Slave1 (SCD)single cycle data[31:0] </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_scdata1_1': 0xFF80220C-->
          <name>biss_scdata1_1</name>
          <description>Sensor and Actuator Data </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCDATA1_1</name>
              <bitRange>[31:0]</bitRange>
              <description>Slave1 (SCD)single cycle data[63:32] </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_scdata2_0': 0xFF802210-->
          <name>biss_scdata2_0</name>
          <description>Sensor and Actuator Data </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCDATA2_0</name>
              <bitRange>[31:0]</bitRange>
              <description>Slave2 (SCD)single cycle data[31:0] </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_scdata2_1': 0xFF802214-->
          <name>biss_scdata2_1</name>
          <description>Sensor and Actuator Data </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCDATA2_1</name>
              <bitRange>[31:0]</bitRange>
              <description>Slave2 (SCD)single cycle data[63:32] </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_scdata3_0': 0xFF802218-->
          <name>biss_scdata3_0</name>
          <description>Sensor and Actuator Data </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000018</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCDATA3_0</name>
              <bitRange>[31:0]</bitRange>
              <description>Slave3 (SCD)single cycle data[31:0] </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_scdata3_1': 0xFF80221C-->
          <name>biss_scdata3_1</name>
          <description>Sensor and Actuator Data </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000001C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCDATA3_1</name>
              <bitRange>[31:0]</bitRange>
              <description>Slave3 (SCD)single cycle data[63:32] </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_scdata4_0': 0xFF802220-->
          <name>biss_scdata4_0</name>
          <description>Sensor and Actuator Data </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCDATA4_0</name>
              <bitRange>[31:0]</bitRange>
              <description>Slave4 (SCD)single cycle data[31:0] </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_scdata4_1': 0xFF802224-->
          <name>biss_scdata4_1</name>
          <description>Sensor and Actuator Data </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000024</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCDATA4_1</name>
              <bitRange>[31:0]</bitRange>
              <description>Slave4 (SCD)single cycle data[63:32] </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_scdata5_0': 0xFF802228-->
          <name>biss_scdata5_0</name>
          <description>Sensor and Actuator Data </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000028</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCDATA5_0</name>
              <bitRange>[31:0]</bitRange>
              <description>Slave5 (SCD)single cycle data[31:0] </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_scdata5_1': 0xFF80222C-->
          <name>biss_scdata5_1</name>
          <description>Sensor and Actuator Data </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000002C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCDATA5_1</name>
              <bitRange>[31:0]</bitRange>
              <description>Slave5 (SCD)single cycle data[63:32] </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_scdata6_0': 0xFF802230-->
          <name>biss_scdata6_0</name>
          <description>Sensor and Actuator Data </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000030</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCDATA6_0</name>
              <bitRange>[31:0]</bitRange>
              <description>Slave6 (SCD)single cycle data[31:0] </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_scdata6_1': 0xFF802234-->
          <name>biss_scdata6_1</name>
          <description>Sensor and Actuator Data </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000034</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCDATA6_1</name>
              <bitRange>[31:0]</bitRange>
              <description>Slave6 (SCD)single cycle data[63:32] </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_scdata7_0': 0xFF802238-->
          <name>biss_scdata7_0</name>
          <description>Sensor and Actuator Data </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000038</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCDATA7_0</name>
              <bitRange>[31:0]</bitRange>
              <description>Slave0 (SCD)single cycle data[31:0] </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_scdata7_1': 0xFF80223C-->
          <name>biss_scdata7_1</name>
          <description>Sensor and Actuator Data </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000003C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCDATA7_1</name>
              <bitRange>[31:0]</bitRange>
              <description>Slave7 (SCD)single cycle data[63:32] </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_rdata0': 0xFF802280-->
          <name>biss_rdata0</name>
          <description>Register Data </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000080</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDATA0</name>
              <bitRange>[31:0]</bitRange>
              <description>- Using register access in control communication RDATA0: register data DWord0 - Using command/instructions in control communication IDS: ID-Select, command/instruction addressing combinable </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_rdata1': 0xFF802284-->
          <name>biss_rdata1</name>
          <description>Register Data </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000084</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDATA1</name>
              <bitRange>[31:0]</bitRange>
              <description>register data DWord1 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_rdata2': 0xFF802288-->
          <name>biss_rdata2</name>
          <description>Register Data </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000088</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDATA2</name>
              <bitRange>[31:0]</bitRange>
              <description>register data DWord2 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_rdata3': 0xFF80228C-->
          <name>biss_rdata3</name>
          <description>Register Data </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000008C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDATA3</name>
              <bitRange>[31:0]</bitRange>
              <description>register data DWord3 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_rdata4': 0xFF802290-->
          <name>biss_rdata4</name>
          <description>Register Data </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000090</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDATA4</name>
              <bitRange>[31:0]</bitRange>
              <description>register data DWord4 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_rdata5': 0xFF802294-->
          <name>biss_rdata5</name>
          <description>Register Data </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000094</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDATA5</name>
              <bitRange>[31:0]</bitRange>
              <description>register data DWord5 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_rdata6': 0xFF802298-->
          <name>biss_rdata6</name>
          <description>Register Data </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000098</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDATA6</name>
              <bitRange>[31:0]</bitRange>
              <description>register data DWord6 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_rdata7': 0xFF80229C-->
          <name>biss_rdata7</name>
          <description>Register Data </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000009C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDATA7</name>
              <bitRange>[31:0]</bitRange>
              <description>register data DWord7 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_rdata8': 0xFF8022A0-->
          <name>biss_rdata8</name>
          <description>Register Data </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000A0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDATA8</name>
              <bitRange>[31:0]</bitRange>
              <description>register data DWord8 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_rdata9': 0xFF8022A4-->
          <name>biss_rdata9</name>
          <description>Register Data </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000A4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDATA9</name>
              <bitRange>[31:0]</bitRange>
              <description>register data DWord9 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_rdata10': 0xFF8022A8-->
          <name>biss_rdata10</name>
          <description>Register Data </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000A8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDATA10</name>
              <bitRange>[31:0]</bitRange>
              <description>register data DWord10 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_rdata11': 0xFF8022AC-->
          <name>biss_rdata11</name>
          <description>Register Data </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000AC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDATA11</name>
              <bitRange>[31:0]</bitRange>
              <description>register data DWord11 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_rdata12': 0xFF8022B0-->
          <name>biss_rdata12</name>
          <description>Register Data </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000B0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDATA12</name>
              <bitRange>[31:0]</bitRange>
              <description>register data DWord12 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_rdata13': 0xFF8022B4-->
          <name>biss_rdata13</name>
          <description>Register Data </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000B4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDATA13</name>
              <bitRange>[31:0]</bitRange>
              <description>register data DWord13 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_rdata14': 0xFF8022B8-->
          <name>biss_rdata14</name>
          <description>Register Data </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000B8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDATA14</name>
              <bitRange>[31:0]</bitRange>
              <description>register data DWord14 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_rdata15': 0xFF8022BC-->
          <name>biss_rdata15</name>
          <description>Register Data </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000BC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDATA15</name>
              <bitRange>[31:0]</bitRange>
              <description>register data DWord15 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_sc0': 0xFF8022C0-->
          <name>biss_sc0</name>
          <description>Slave Configuration </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000C0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCRCSTART0</name>
              <bitRange>[31:16]</bitRange>
              <description>Start value for polynomial SCD CRC calculation </description>
            </field>
            <field>
              <name>SELCRCS0</name>
              <bitRange>[15:15]</bitRange>
              <description>Selection between polynomial or length for SCD CRC polynomial 0: CRC bit length in SCRCLENx (see SCRCPOLYx) apply dedicated CRC polynomials 1: CRC polynomial(7:1) in SCRCPOLYx. SELCRCSx = 1 not applicable with CRC polynomial SCRCPOLYx(7:0) = 0x00 </description>
            </field>
            <field>
              <name>SCRCPOLY0</name>
              <bitRange>[14:8]</bitRange>
              <description>- SELCRCx == 0 ( SCRCLENx: polynomial selection by length for SCD CRC check) 0: CRC for single cycle data not present, CRC verification deactivated. SELCRCSx = 0b0 3: CRC polynomial = 0x0b 4: CRC polynomial = 0x13 5: CRC polynomial = 0x25 6: CRC polynomial = 0x43 7: CRC polynomial = 0x89 8: CRC polynomial = 0x12f 16: CRC polynomial = 0x190d9 ..: other CRC length are not permitted with SELCRCSx = 0 - SELCRCx == 1 (SCRCPOLYx: polynomial for SCD CRC check) 0x00       : CRC polynomial 0x00 not applicable with SELCRCSx = 1 0x01.. 0x7f: CRC polynomial for single cycle data = SCRCPOLYx(7:1) + 0x01 </description>
            </field>
            <field>
              <name>LSTOP0</name>
              <bitRange>[7:7]</bitRange>
              <description>- BISS mode(LSTOPx = Actuator stop bit control) 0: no leading STOP bit on single cycle actuator data 1: leading STOP bit on single cycle actuator data - SSI mode(GRAYSx = Enable SCD gray to binary conversion) 0: SSI single cycle data binary coded 1: SSI single cycle data gray coded </description>
            </field>
            <field>
              <name>ENSCD0</name>
              <bitRange>[6:6]</bitRange>
              <description>Enable single cycle data 0: single cycle data not available 1: single cycle data available </description>
            </field>
            <field>
              <name>SCDLEN0</name>
              <bitRange>[5:0]</bitRange>
              <description>Single cycle data length 0 : single cycle data length = 1 1 : single cycle data length = 2 ... single cycle data length = SCDLENx + 1 62: single cycle data length = 63 63: single cycle data length = 64 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_sc1': 0xFF8022C4-->
          <name>biss_sc1</name>
          <description>Slave Configuration </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000C4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCRCSTART1</name>
              <bitRange>[31:16]</bitRange>
              <description>Start value for polynomial SCD CRC calculation </description>
            </field>
            <field>
              <name>SELCRCS1</name>
              <bitRange>[15:15]</bitRange>
              <description>Selection between polynomial or length for SCD CRC polynomial 0: CRC bit length in SCRCLENx (see SCRCPOLYx) apply dedicated CRC polynomials 1: CRC polynomial(7:1) in SCRCPOLYx. SELCRCSx = 1 not applicable with CRC polynomial SCRCPOLYx(7:0) = 0x00 </description>
            </field>
            <field>
              <name>SCRCPOLY1</name>
              <bitRange>[14:8]</bitRange>
              <description>- SELCRCx == 0 ( SCRCLENx: polynomial selection by length for SCD CRC check) 0: CRC for single cycle data not present, CRC verification deactivated. SELCRCSx = 0b0 3: CRC polynomial = 0x0b 4: CRC polynomial = 0x13 5: CRC polynomial = 0x25 6: CRC polynomial = 0x43 7: CRC polynomial = 0x89 8: CRC polynomial = 0x12f 16: CRC polynomial = 0x190d9 ..: other CRC length are not permitted with SELCRCSx = 0 - SELCRCx == 1 (SCRCPOLYx: polynomial for SCD CRC check) 0x00       : CRC polynomial 0x00 not applicable with SELCRCSx = 1 0x01.. 0x7f: CRC polynomial for single cycle data = SCRCPOLYx(7:1) + 0x01 </description>
            </field>
            <field>
              <name>LSTOP1</name>
              <bitRange>[7:7]</bitRange>
              <description>- BISS mode(LSTOPx = Actuator stop bit control) 0: no leading STOP bit on single cycle actuator data 1: leading STOP bit on single cycle actuator data - SSI mode(GRAYSx = Enable SCD gray to binary conversion) 0: SSI single cycle data binary coded 1: SSI single cycle data gray coded </description>
            </field>
            <field>
              <name>ENSCD1</name>
              <bitRange>[6:6]</bitRange>
              <description>Enable single cycle data 0: single cycle data not available 1: single cycle data available </description>
            </field>
            <field>
              <name>SCDLEN1</name>
              <bitRange>[5:0]</bitRange>
              <description>Single cycle data length 0 : single cycle data length = 1 1 : single cycle data length = 2 ... single cycle data length = SCDLENx + 1 62: single cycle data length = 63 63: single cycle data length = 64 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_sc2': 0xFF8022C8-->
          <name>biss_sc2</name>
          <description>Slave Configuration </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000C8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCRCSTART2</name>
              <bitRange>[31:16]</bitRange>
              <description>Start value for polynomial SCD CRC calculation </description>
            </field>
            <field>
              <name>SELCRCS2</name>
              <bitRange>[15:15]</bitRange>
              <description>Selection between polynomial or length for SCD CRC polynomial 0: CRC bit length in SCRCLENx (see SCRCPOLYx) apply dedicated CRC polynomials 1: CRC polynomial(7:1) in SCRCPOLYx. SELCRCSx = 1 not applicable with CRC polynomial SCRCPOLYx(7:0) = 0x00 </description>
            </field>
            <field>
              <name>SCRCPOLY2</name>
              <bitRange>[14:8]</bitRange>
              <description>- SELCRCx == 0 ( SCRCLENx: polynomial selection by length for SCD CRC check) 0: CRC for single cycle data not present, CRC verification deactivated. SELCRCSx = 0b0 3: CRC polynomial = 0x0b 4: CRC polynomial = 0x13 5: CRC polynomial = 0x25 6: CRC polynomial = 0x43 7: CRC polynomial = 0x89 8: CRC polynomial = 0x12f 16: CRC polynomial = 0x190d9 ..: other CRC length are not permitted with SELCRCSx = 0 - SELCRCx == 1 (SCRCPOLYx: polynomial for SCD CRC check) 0x00       : CRC polynomial 0x00 not applicable with SELCRCSx = 1 0x01.. 0x7f: CRC polynomial for single cycle data = SCRCPOLYx(7:1) + 0x01 </description>
            </field>
            <field>
              <name>LSTOP2</name>
              <bitRange>[7:7]</bitRange>
              <description>- BISS mode(LSTOPx = Actuator stop bit control) 0: no leading STOP bit on single cycle actuator data 1: leading STOP bit on single cycle actuator data - SSI mode(GRAYSx = Enable SCD gray to binary conversion) 0: SSI single cycle data binary coded 1: SSI single cycle data gray coded </description>
            </field>
            <field>
              <name>ENSCD2</name>
              <bitRange>[6:6]</bitRange>
              <description>Enable single cycle data 0: single cycle data not available 1: single cycle data available </description>
            </field>
            <field>
              <name>SCDLEN2</name>
              <bitRange>[5:0]</bitRange>
              <description>Single cycle data length 0 : single cycle data length = 1 1 : single cycle data length = 2 ... single cycle data length = SCDLENx + 1 62: single cycle data length = 63 63: single cycle data length = 64 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_sc3': 0xFF8022CC-->
          <name>biss_sc3</name>
          <description>Slave Configuration </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000CC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCRCSTART3</name>
              <bitRange>[31:16]</bitRange>
              <description>Start value for polynomial SCD CRC calculation </description>
            </field>
            <field>
              <name>SELCRCS3</name>
              <bitRange>[15:15]</bitRange>
              <description>Selection between polynomial or length for SCD CRC polynomial 0: CRC bit length in SCRCLENx (see SCRCPOLYx) apply dedicated CRC polynomials 1: CRC polynomial(7:1) in SCRCPOLYx. SELCRCSx = 1 not applicable with CRC polynomial SCRCPOLYx(7:0) = 0x00 </description>
            </field>
            <field>
              <name>SCRCPOLY3</name>
              <bitRange>[14:8]</bitRange>
              <description>- SELCRCx == 0 ( SCRCLENx: polynomial selection by length for SCD CRC check) 0: CRC for single cycle data not present, CRC verification deactivated. SELCRCSx = 0b0 3: CRC polynomial = 0x0b 4: CRC polynomial = 0x13 5: CRC polynomial = 0x25 6: CRC polynomial = 0x43 7: CRC polynomial = 0x89 8: CRC polynomial = 0x12f 16: CRC polynomial = 0x190d9 ..: other CRC length are not permitted with SELCRCSx = 0 - SELCRCx == 1 (SCRCPOLYx: polynomial for SCD CRC check) 0x00       : CRC polynomial 0x00 not applicable with SELCRCSx = 1 0x01.. 0x7f: CRC polynomial for single cycle data = SCRCPOLYx(7:1) + 0x01 </description>
            </field>
            <field>
              <name>LSTOP3</name>
              <bitRange>[7:7]</bitRange>
              <description>- BISS mode(LSTOPx = Actuator stop bit control) 0: no leading STOP bit on single cycle actuator data 1: leading STOP bit on single cycle actuator data - SSI mode(GRAYSx = Enable SCD gray to binary conversion) 0: SSI single cycle data binary coded 1: SSI single cycle data gray coded </description>
            </field>
            <field>
              <name>ENSCD3</name>
              <bitRange>[6:6]</bitRange>
              <description>Enable single cycle data 0: single cycle data not available 1: single cycle data available </description>
            </field>
            <field>
              <name>SCDLEN3</name>
              <bitRange>[5:0]</bitRange>
              <description>Single cycle data length 0 : single cycle data length = 1 1 : single cycle data length = 2 ... single cycle data length = SCDLENx + 1 62: single cycle data length = 63 63: single cycle data length = 64 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_sc4': 0xFF8022D0-->
          <name>biss_sc4</name>
          <description>Slave Configuration </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000D0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCRCSTART4</name>
              <bitRange>[31:16]</bitRange>
              <description>Start value for polynomial SCD CRC calculation </description>
            </field>
            <field>
              <name>SELCRCS4</name>
              <bitRange>[15:15]</bitRange>
              <description>Selection between polynomial or length for SCD CRC polynomial 0: CRC bit length in SCRCLENx (see SCRCPOLYx) apply dedicated CRC polynomials 1: CRC polynomial(7:1) in SCRCPOLYx. SELCRCSx = 1 not applicable with CRC polynomial SCRCPOLYx(7:0) = 0x00 </description>
            </field>
            <field>
              <name>SCRCPOLY4</name>
              <bitRange>[14:8]</bitRange>
              <description>- SELCRCx == 0 ( SCRCLENx: polynomial selection by length for SCD CRC check) 0: CRC for single cycle data not present, CRC verification deactivated. SELCRCSx = 0b0 3: CRC polynomial = 0x0b 4: CRC polynomial = 0x13 5: CRC polynomial = 0x25 6: CRC polynomial = 0x43 7: CRC polynomial = 0x89 8: CRC polynomial = 0x12f 16: CRC polynomial = 0x190d9 ..: other CRC length are not permitted with SELCRCSx = 0 - SELCRCx == 1 (SCRCPOLYx: polynomial for SCD CRC check) 0x00       : CRC polynomial 0x00 not applicable with SELCRCSx = 1 0x01.. 0x7f: CRC polynomial for single cycle data = SCRCPOLYx(7:1) + 0x01 </description>
            </field>
            <field>
              <name>LSTOP4</name>
              <bitRange>[7:7]</bitRange>
              <description>- BISS mode(LSTOPx = Actuator stop bit control) 0: no leading STOP bit on single cycle actuator data 1: leading STOP bit on single cycle actuator data - SSI mode(GRAYSx = Enable SCD gray to binary conversion) 0: SSI single cycle data binary coded 1: SSI single cycle data gray coded </description>
            </field>
            <field>
              <name>ENSCD4</name>
              <bitRange>[6:6]</bitRange>
              <description>Enable single cycle data 0: single cycle data not available 1: single cycle data available </description>
            </field>
            <field>
              <name>SCDLEN4</name>
              <bitRange>[5:0]</bitRange>
              <description>Single cycle data length 0 : single cycle data length = 1 1 : single cycle data length = 2 ... single cycle data length = SCDLENx + 1 62: single cycle data length = 63 63: single cycle data length = 64 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_sc5': 0xFF8022D4-->
          <name>biss_sc5</name>
          <description>Slave Configuration </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000D4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCRCSTART5</name>
              <bitRange>[31:16]</bitRange>
              <description>Start value for polynomial SCD CRC calculation </description>
            </field>
            <field>
              <name>SELCRCS5</name>
              <bitRange>[15:15]</bitRange>
              <description>Selection between polynomial or length for SCD CRC polynomial 0: CRC bit length in SCRCLENx (see SCRCPOLYx) apply dedicated CRC polynomials 1: CRC polynomial(7:1) in SCRCPOLYx. SELCRCSx = 1 not applicable with CRC polynomial SCRCPOLYx(7:0) = 0x00 </description>
            </field>
            <field>
              <name>SCRCPOLY5</name>
              <bitRange>[14:8]</bitRange>
              <description>- SELCRCx == 0 ( SCRCLENx: polynomial selection by length for SCD CRC check) 0: CRC for single cycle data not present, CRC verification deactivated. SELCRCSx = 0b0 3: CRC polynomial = 0x0b 4: CRC polynomial = 0x13 5: CRC polynomial = 0x25 6: CRC polynomial = 0x43 7: CRC polynomial = 0x89 8: CRC polynomial = 0x12f 16: CRC polynomial = 0x190d9 ..: other CRC length are not permitted with SELCRCSx = 0 - SELCRCx == 1 (SCRCPOLYx: polynomial for SCD CRC check) 0x00       : CRC polynomial 0x00 not applicable with SELCRCSx = 1 0x01.. 0x7f: CRC polynomial for single cycle data = SCRCPOLYx(7:1) + 0x01 </description>
            </field>
            <field>
              <name>LSTOP5</name>
              <bitRange>[7:7]</bitRange>
              <description>- BISS mode(LSTOPx = Actuator stop bit control) 0: no leading STOP bit on single cycle actuator data 1: leading STOP bit on single cycle actuator data - SSI mode(GRAYSx = Enable SCD gray to binary conversion) 0: SSI single cycle data binary coded 1: SSI single cycle data gray coded </description>
            </field>
            <field>
              <name>ENSCD5</name>
              <bitRange>[6:6]</bitRange>
              <description>Enable single cycle data 0: single cycle data not available 1: single cycle data available </description>
            </field>
            <field>
              <name>SCDLEN5</name>
              <bitRange>[5:0]</bitRange>
              <description>Single cycle data length 0 : single cycle data length = 1 1 : single cycle data length = 2 ... single cycle data length = SCDLENx + 1 62: single cycle data length = 63 63: single cycle data length = 64 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_sc6': 0xFF8022D8-->
          <name>biss_sc6</name>
          <description>Slave Configuration </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000D8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCRCSTART6</name>
              <bitRange>[31:16]</bitRange>
              <description>Start value for polynomial SCD CRC calculation </description>
            </field>
            <field>
              <name>SELCRCS6</name>
              <bitRange>[15:15]</bitRange>
              <description>Selection between polynomial or length for SCD CRC polynomial 0: CRC bit length in SCRCLENx (see SCRCPOLYx) apply dedicated CRC polynomials 1: CRC polynomial(7:1) in SCRCPOLYx. SELCRCSx = 1 not applicable with CRC polynomial SCRCPOLYx(7:0) = 0x00 </description>
            </field>
            <field>
              <name>SCRCPOLY6</name>
              <bitRange>[14:8]</bitRange>
              <description>- SELCRCx == 0 ( SCRCLENx: polynomial selection by length for SCD CRC check) 0: CRC for single cycle data not present, CRC verification deactivated. SELCRCSx = 0b0 3: CRC polynomial = 0x0b 4: CRC polynomial = 0x13 5: CRC polynomial = 0x25 6: CRC polynomial = 0x43 7: CRC polynomial = 0x89 8: CRC polynomial = 0x12f 16: CRC polynomial = 0x190d9 ..: other CRC length are not permitted with SELCRCSx = 0 - SELCRCx == 1 (SCRCPOLYx: polynomial for SCD CRC check) 0x00       : CRC polynomial 0x00 not applicable with SELCRCSx = 1 0x01.. 0x7f: CRC polynomial for single cycle data = SCRCPOLYx(7:1) + 0x01 </description>
            </field>
            <field>
              <name>LSTOP6</name>
              <bitRange>[7:7]</bitRange>
              <description>- BISS mode(LSTOPx = Actuator stop bit control) 0: no leading STOP bit on single cycle actuator data 1: leading STOP bit on single cycle actuator data - SSI mode(GRAYSx = Enable SCD gray to binary conversion) 0: SSI single cycle data binary coded 1: SSI single cycle data gray coded </description>
            </field>
            <field>
              <name>ENSCD6</name>
              <bitRange>[6:6]</bitRange>
              <description>Enable single cycle data 0: single cycle data not available 1: single cycle data available </description>
            </field>
            <field>
              <name>SCDLEN6</name>
              <bitRange>[5:0]</bitRange>
              <description>Single cycle data length 0 : single cycle data length = 1 1 : single cycle data length = 2 ... single cycle data length = SCDLENx + 1 62: single cycle data length = 63 63: single cycle data length = 64 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_sc7': 0xFF8022DC-->
          <name>biss_sc7</name>
          <description>Slave Configuration </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000DC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCRCSTART7</name>
              <bitRange>[31:16]</bitRange>
              <description>Start value for polynomial SCD CRC calculation </description>
            </field>
            <field>
              <name>SELCRCS7</name>
              <bitRange>[15:15]</bitRange>
              <description>Selection between polynomial or length for SCD CRC polynomial 0: CRC bit length in SCRCLENx (see SCRCPOLYx) apply dedicated CRC polynomials 1: CRC polynomial(7:1) in SCRCPOLYx. SELCRCSx = 1 not applicable with CRC polynomial SCRCPOLYx(7:0) = 0x00 </description>
            </field>
            <field>
              <name>SCRCPOLY7</name>
              <bitRange>[14:8]</bitRange>
              <description>- SELCRCx == 0 (SCRCLENx: polynomial selection by length for SCD CRC check) 0: CRC for single cycle data not present, CRC verification deactivated. SELCRCSx = 0b0 3: CRC polynomial = 0x0b 4: CRC polynomial = 0x13 5: CRC polynomial = 0x25 6: CRC polynomial = 0x43 7: CRC polynomial = 0x89 8: CRC polynomial = 0x12f 16: CRC polynomial = 0x190d9 ..: other CRC length are not permitted with SELCRCSx = 0 - SELCRCx == 1 (SCRCPOLYx: polynomial for SCD CRC check) 0x00       : CRC polynomial 0x00 not applicable with SELCRCSx = 1 0x01.. 0x7f: CRC polynomial for single cycle data = SCRCPOLYx(7:1) + 0x01 </description>
            </field>
            <field>
              <name>LSTOP7</name>
              <bitRange>[7:7]</bitRange>
              <description>- BISS mode(LSTOPx = Actuator stop bit control) 0: no leading STOP bit on single cycle actuator data 1: leading STOP bit on single cycle actuator data - SSI mode(GRAYSx = Enable SCD gray to binary conversion) 0: SSI single cycle data binary coded 1: SSI single cycle data gray coded </description>
            </field>
            <field>
              <name>ENSC7</name>
              <bitRange>[6:6]</bitRange>
              <description>Enable single cycle data 0: single cycle data not available 1: single cycle data available </description>
            </field>
            <field>
              <name>SCDLEN7</name>
              <bitRange>[5:0]</bitRange>
              <description>Single cycle data length 0 : single cycle data length = 1 1 : single cycle data length = 2 ... single cycle data length = SCDLENx + 1 62: single cycle data length = 63 63: single cycle data length = 64 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_ccc0': 0xFF8022E0-->
          <name>biss_ccc0</name>
          <description>Register Communication Configuration </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000E0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x3FFF0000</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:30]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>REGNUM</name>
              <bitRange>[29:24]</bitRange>
              <description>Register data count 0x00       : register count = 1 0x01 ..0x3f: register count = REGNUM(5:0)+1 </description>
            </field>
            <field>
              <name>WNR</name>
              <bitRange>[23:23]</bitRange>
              <description>Register access read/write selector 0: read register data 1: write register data </description>
            </field>
            <field>
              <name>REGADR</name>
              <bitRange>[22:16]</bitRange>
              <description>Register access start address 0x00 .. 0x7f </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[15:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_ccc1_mc0': 0xFF8022E4-->
          <name>biss_ccc1_mc0</name>
          <description>Register Communication Configuration / Master Configuration </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000E4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x03FFFB03</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:26]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>NOCRC</name>
              <bitRange>[25:25]</bitRange>
              <description>CRC for SCD not to be stored in RAM 0: CRC of SCD is stored RAM (only applicable with active CRC verification and CRC polynome &gt; 0) 1: CRC of SCD not to be stored in RAM </description>
            </field>
            <field>
              <name>SINGLEBANK</name>
              <bitRange>[24:24]</bitRange>
              <description>Use of only one RAM bank for SCD 0: two RAM banks are used for SCD 1: one RAM bank is used for SCD </description>
            </field>
            <field>
              <name>FREQR</name>
              <bitRange>[23:21]</bitRange>
              <description>Frequency division register communication BiSS B 0 .. 7: freqSens/(2*(FREQ(7:5)+1)) 0: FreqSens/2 1: FreqSens/4 2: FreqSens/8 3: FreqSens/16 4: FreqSens/32 5: FreqSens/64 6: FreqSens/128 7: FreqSens/256 </description>
            </field>
            <field>
              <name>FREQS</name>
              <bitRange>[20:16]</bitRange>
              <description>Frequency division 0x00: fCLK/2 0x01: fCLK/4 0x02: fCLK/6 0x03: fCLK/8 ... 0x09: fCLK/20 ... 0x0d: fCLK/28 0x0e: fCLK/30 0x0f: fCLK/32 0x10: not permitted 0x11: fCLK/40 0x12: fCLK/60 0x13: fCLK/80 ... 0x1d: fCLK/280 0x1e: fCLK/300 0x1f: fCLK/320 </description>
            </field>
            <field>
              <name>CTS</name>
              <bitRange>[15:15]</bitRange>
              <description>Register transmission or instruction selector 0: command/instruction communication 1: register communication </description>
            </field>
            <field>
              <name>REGVERS</name>
              <bitRange>[14:14]</bitRange>
              <description>BiSS model A/B or C selector - Using register access in control communication 0: register communication BiSS A/B 1: register communication BiSS C - Using command/instructions in control communication 0: not applicable with command/instruction communication 1: command communication BiSS C </description>
            </field>
            <field>
              <name>CMD</name>
              <bitRange>[13:12]</bitRange>
              <description>- Using register access in control communication SLAVEID[2:1]: slave selector bit2_1 - Using command/instructions in control communication Command of access slave     # default 0x00 0x00 .. 0x03: command/instruction 0b00 .. 0b11 </description>
            </field>
            <field>
              <name>IDA_TEST</name>
              <bitRange>[11:11]</bitRange>
              <description>- Using register access in control communication SLAVEID[0]: slave selector bit0 - Using command/instructions in control communication IDA_TEST: command/instruction execution control 0: the slaves feedback (IDA) is tested before execution (EX bit after IDA) 1: immediate execution </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[10:10]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>EN_MO</name>
              <bitRange>[9:9]</bitRange>
              <description>Enable output at MOx for actuator data or delayed start bit 0: MO forced to low 1: Parameterized processing time by master on MO signal active (length: MO_BUSY) </description>
            </field>
            <field>
              <name>HOLDCDM</name>
              <bitRange>[8:8]</bitRange>
              <description>Hold CDM(control data master) 0: clock line high at end of cycle 1: clock line constant with CDM bit until start of next cycle </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[7:2]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>CHSEL</name>
              <bitRange>[1:0]</bitRange>
              <description>Channel selector 0: channel 1 used for control communication, channel 2 not used 1: channel 1 used for control communication, channel 2 not used 2: channel 2 used for control communication, channel 1 not used. Note: Channel 2 is not available with IC-MB4 TSSOP24 3: channel 1,2 used for control communication. Note: Channel 2 is not available with IC-MB4 TSSOP24 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_mc1': 0xFF8022E8-->
          <name>biss_mc1</name>
          <description>Master Configuration </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000E8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VERSION</name>
              <bitRange>[31:24]</bitRange>
              <description>Device identifier 0x83: iC-MB3 0x84: iC-MB4 .. 0xff </description>
            </field>
            <field>
              <name>REVISION</name>
              <bitRange>[23:16]</bitRange>
              <description>Revision 0x10: Z(first revision) 0x11: Z1 0x12: Y .. 0xff </description>
            </field>
            <field>
              <name>MO_BUSY</name>
              <bitRange>[15:8]</bitRange>
              <description>Delay of start bit at output MOx 0x00 .. 0xff: count of MA clocks as the parameterized processing time by master on MO signal Premise: EN_MO = 1 </description>
            </field>
            <field>
              <name>FREQAGS</name>
              <bitRange>[7:0]</bitRange>
              <description>AutoGetSens Frequency division 0x00.. 0x7b: fCLK/(20*(FREQAGS(6:0)+1)) 0x7c       : AGSMIN( the master automatically restarts the next cycle after the prior was finished. AGSMIN is the fastest SCD rate with complete SCD cycles. ) 0x7d.. 0x7f: AGSINFINITE( the master does not automatically restart the next cycle after the prior one was finished. AGSINFINITE requires a trigger event to start the next SCD cycle. ) 0x80.. 0xff: fCLK/(625*(FREQAGS(6:0)+1)) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_cc_sl': 0xFF8022EC-->
          <name>biss_cc_sl</name>
          <description>Channel Configuration </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000EC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFF000F1F</resetMask>
          <fields>
            <field>
              <name>ACTnSENS</name>
              <bitRange>[31:24]</bitRange>
              <description>Sensor or actuator data selector 0x00: all slaves are sensors 0x01: slave 0 is actuator 0x02: slave 1 is actuator 0x04: slave 2 is actuator 0x08: slave 3 is actuator 0x10: slave 4 is actuator 0x20: slave 5 is actuator 0x40: slave 6 is actuator 0x80: slave 7 is actuator 0xff: all slaves are actuators </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[23:12]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>CFGCH2</name>
              <bitRange>[11:10]</bitRange>
              <description>Channel 2 configuration 0x00: BiSS B 0x01: BiSS C 0x02: SSI 0x03: channel is not used </description>
            </field>
            <field>
              <name>CFGCH1</name>
              <bitRange>[9:8]</bitRange>
              <description>Channel 1 configuration 0x00: BiSS B 0x01: BiSS C 0x02: SSI 0x03: channel is not used </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[7:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>SLAVELOC5</name>
              <bitRange>[4:4]</bitRange>
              <description>Slave location 0: slaves 4-7 are connected to channel 1 1: slaves 4-7 are connected to channel 2(only available with iC-MB4 QFN28) </description>
            </field>
            <field>
              <name>cc_sl_reserved1</name>
              <bitRange>[3:0]</bitRange>
              <description>no field descpription</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_status0': 0xFF8022F0-->
          <name>biss_status0</name>
          <description>Status Information </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000F0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFAAAAFF</resetMask>
          <fields>
            <field>
              <name>CDMTIMEOUT</name>
              <bitRange>[31:31]</bitRange>
              <description>CDM(Control Data Master) timeout reached 0: CDMTIMEOUT not reached 1: CDMTIMEOUT reached </description>
            </field>
            <field>
              <name>CDSSEL</name>
              <bitRange>[30:30]</bitRange>
              <description>CDS(Control Data Slave) bit from the selected channel </description>
            </field>
            <field>
              <name>REGBYTES</name>
              <bitRange>[29:24]</bitRange>
              <description>Number of valid register data transmission in case of error 0x00       : after transfer: no register communication error 0x01 . 0x3f: after transfer: number of successfully transferred registers before register communication error </description>
            </field>
            <field>
              <name>SVALID7</name>
              <bitRange>[23:23]</bitRange>
              <description>SCDATA7 validity indication 0: SCD invalid 1: SCD valid The SVALIDx bit indicates the validity of each slaves SCD CRC verification. A prior set SVALIDx bit can be reset by writing 0 into the register. </description>
            </field>
            <field>
              <name>bf_align7</name>
              <bitRange>[22:22]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>SVALID6</name>
              <bitRange>[21:21]</bitRange>
              <description>SCDATA6 validity indication 0: SCD invalid 1: SCD valid The SVALIDx bit indicates the validity of each slaves SCD CRC verification. A prior set SVALIDx bit can be reset by writing 0 into the register. </description>
            </field>
            <field>
              <name>bf_align6</name>
              <bitRange>[20:20]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>SVALID5</name>
              <bitRange>[19:19]</bitRange>
              <description>SCDATA5 validity indication 0: SCD invalid 1: SCD valid The SVALIDx bit indicates the validity of each slaves SCD CRC verification. A prior set SVALIDx bit can be reset by writing 0 into the register. </description>
            </field>
            <field>
              <name>bf_align5</name>
              <bitRange>[18:18]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>SVALID4</name>
              <bitRange>[17:17]</bitRange>
              <description>SCDATA4 validity indication 0: SCD invalid 1: SCD valid The SVALIDx bit indicates the validity of each slaves SCD CRC verification. A prior set SVALIDx bit can be reset by writing 0 into the register. </description>
            </field>
            <field>
              <name>bf_align4</name>
              <bitRange>[16:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>SVALID3</name>
              <bitRange>[15:15]</bitRange>
              <description>SCDATA3 validity indication 0: SCD invalid 1: SCD valid The SVALIDx bit indicates the validity of each slaves SCD CRC verification. A prior set SVALIDx bit can be reset by writing 0 into the register. </description>
            </field>
            <field>
              <name>bf_align3</name>
              <bitRange>[14:14]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>SVALID2</name>
              <bitRange>[13:13]</bitRange>
              <description>SCDATA2 validity indication 0: SCD invalid 1: SCD valid The SVALIDx bit indicates the validity of each slaves SCD CRC verification. A prior set SVALIDx bit can be reset by writing 0 into the register. </description>
            </field>
            <field>
              <name>bf_align2</name>
              <bitRange>[12:12]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>SVALID1</name>
              <bitRange>[11:11]</bitRange>
              <description>SCDATA1 validity indication 0: SCD invalid 1: SCD valid The SVALIDx bit indicates the validity of each slaves SCD CRC verification. A prior set SVALIDx bit can be reset by writing 0 into the register. </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[10:10]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>SVALID0</name>
              <bitRange>[9:9]</bitRange>
              <description>SCDATA0 validity indication 0: SCD invalid 1: SCD valid The SVALIDx bit indicates the validity of each slaves SCD CRC verification. A prior set SVALIDx bit can be reset by writing 0 into the register. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[8:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>nERR</name>
              <bitRange>[7:7]</bitRange>
              <description>Transmission error (error at NER pin) 0: error 1: no error It is possible to connect other components to pin NER which can also generate an error message; this can then be read out via this bit. </description>
            </field>
            <field>
              <name>nAGSERR</name>
              <bitRange>[6:6]</bitRange>
              <description>AGS error 0: AGS(Automatic Get Sensor data) watchdog error 1: no AGS watchdog error An AGS watchdog error is set during the automatic transmission of sensor data if no new cycle could be initiated; bit AGS in the command register is reset and the automatic request of sensor data aborted. </description>
            </field>
            <field>
              <name>nDELAYERR</name>
              <bitRange>[5:5]</bitRange>
              <description>Missing start bit during register communication 0: delay error 1: no delay error </description>
            </field>
            <field>
              <name>nSCDERR</name>
              <bitRange>[4:4]</bitRange>
              <description>Error in single cycle data transmission 0: error in last single cycle data transmission 1: no error in last single cycle data transmission </description>
            </field>
            <field>
              <name>nREGERR</name>
              <bitRange>[3:3]</bitRange>
              <description>Error in register data transmission 0: error in last register data transmission 1: no error in last register data transmission </description>
            </field>
            <field>
              <name>REGEND</name>
              <bitRange>[2:2]</bitRange>
              <description>Register data transmission completed 0: no valid register data available 1: register data transmission completed </description>
            </field>
            <field>
              <name>status0_reserved1</name>
              <bitRange>[1:1]</bitRange>
              <description>reserved value</description>
            </field>
            <field>
              <name>EOT</name>
              <bitRange>[0:0]</bitRange>
              <description>Data transmission completed 0: data transmission active 1: data transmission finished </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_ir': 0xFF8022F4-->
          <name>biss_ir</name>
          <description>Instruction Register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000F4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>MAVO</name>
              <bitRange>[15:15]</bitRange>
              <description>Not selected MA line control level 0: low definition of unselected(CHSEL) MA clock lines 1: high definition of unselected(CHSEL) MA clock lines </description>
            </field>
            <field>
              <name>MAFO</name>
              <bitRange>[14:14]</bitRange>
              <description>Not selected MA line control selection 0: controlling unselected(CHSEL) MA clock line: using MA signal 1: controlling unselected(CHSEL) MA clock line: using MAVS level </description>
            </field>
            <field>
              <name>MAVS</name>
              <bitRange>[13:13]</bitRange>
              <description>Selected MA line control level 0: low definition of selected(CHSEL) MA clock lines 1: high definition of selected(CHSEL) MA clock lines </description>
            </field>
            <field>
              <name>MAFS</name>
              <bitRange>[12:12]</bitRange>
              <description>Selected MA line control selection 0: controlling selected/CHSEL) MA clock line: using MA signal 1: controlling selected(CHSEL) MA clock line: using MAVS level </description>
            </field>
            <field>
              <name>CFGIF</name>
              <bitRange>[11:10]</bitRange>
              <description>Configure physical interface 0x00: TTL 0x01: CMOS 0x02: RS422 0x03: LVDS </description>
            </field>
            <field>
              <name>ENTEST</name>
              <bitRange>[9:9]</bitRange>
              <description>Enable test interface 0: device in normal operation mode 1: device in test mode </description>
            </field>
            <field>
              <name>CLKENI</name>
              <bitRange>[8:8]</bitRange>
              <description>Enable internal clock 0: the master clock is generated by an external clock oscillator 1: the master clock is generated by the basic clock of the internal 20MHz oscillator </description>
            </field>
            <field>
              <name>BREAK</name>
              <bitRange>[7:7]</bitRange>
              <description>Data transmission interrupt 0: no change 1: abort data transmission nSCDERR, nREGERR, nDELAYERR, nAGSERR = 1, REGEND = 0 All current actions can be aborted using the BREAK command so that a defined state can be resumed if one of the sensors proves faulty, for example. BREAK= 1 aborts the active data transmission and all status information will be reset. </description>
            </field>
            <field>
              <name>HOLDBANK</name>
              <bitRange>[6:6]</bitRange>
              <description>RAM bank control 0: no bank switching lock permitted 1: bank switching lock permitted During the readout of more than one sensor data register by the controller it is possible that the RAM banks in the master could be swapped over once a sensor data transmission is completed. So that the controller only reads related values bit HOLDBANK should be set at the start of the readout and reset at the end; this suppresses the RAM swap. With the start of a new sensor data cycle previous values are then overwritten by the new sensor data. </description>
            </field>
            <field>
              <name>SWBANK</name>
              <bitRange>[5:5]</bitRange>
              <description>Switch RAM banks 0: RAM banks are not switched 1: RAM banks are switched </description>
            </field>
            <field>
              <name>INIT</name>
              <bitRange>[4:4]</bitRange>
              <description>Start INIT sequence 0: no changes on the data channel 1: initialize data channel </description>
            </field>
            <field>
              <name>INSTR</name>
              <bitRange>[3:1]</bitRange>
              <description>SCD control instruction 0b010       : CDM = 0 0b001       : CDM = 1 0b100, 0b110: register communication condition: CDMTIMEOUT = 1 0b111       : register communication(reduced protocol) condition: CDMTIMEOUT = 1 The transmission of sensor data can be triggered via INSTR. With INSTR=0b010 the ccle finishes with a CDM=0. With INSTR= 0b001 the cycle finishes with a CDM=1. A BiSS C register access to a slave can be operated by INSTR=0b100. A reduced protocol for a shorter BiSS C register access to a slave can be operated by INST=0b111. </description>
            </field>
            <field>
              <name>AGS</name>
              <bitRange>[0:0]</bitRange>
              <description>AutoGetSens(Automatic Get Sensordata) 0: no automatic data transmission 1: - start of data transmission after TIMEOUTSENS condition: FREQAGS = AGSMIN - start of data transmission triggered by pin condition: FREQAGS = AGSINFINITE - start of data transmission after timeout With AGS = 0 the master starts the data transmission after finishing writing the instruction register(rising edge of NWR). A nAGSERR error will be generated if the SL line is low, TIMEOUTSENS has not exceeded. If an AGS bit has been set sensor data is read in cyclically according to the cycle frequency set in FREQAGS. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'biss_status1': 0xFF8022F8-->
          <name>biss_status1</name>
          <description>Status Information </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000000F8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x01000003</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:25]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>SWBANKFAILS</name>
              <bitRange>[24:24]</bitRange>
              <description>Bank switching status 0: bank switching(SCD) successful 1: bank switching(SCD) not successful </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[23:2]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>CDS1</name>
              <bitRange>[1:1]</bitRange>
              <description>CDS bit of channel 1 0: CDS = 0 1: CDS = 1 </description>
            </field>
            <field>
              <name>SL1</name>
              <bitRange>[0:0]</bitRange>
              <description>Current SL line level of channel 1 0: SL line level low 1: SL line level high </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>menc_app</name>
      <description>menc_app</description>
      <baseAddress>0xFF802300</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>128</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>menc_app_irq_enc0</name>
        <value>50</value>
      </interrupt>
      <interrupt>
        <name>menc_app_irq_enc1</name>
        <value>51</value>
      </interrupt>
      <interrupt>
        <name>menc_app_irq_cap_mp</name>
        <value>52</value>
      </interrupt>
      <interrupt>
        <name>menc_app_irq_err</name>
        <value>53</value>
      </interrupt>
      <registers>
        <register>
          <!--Absolute address of 'menc_config': 0xFF802300-->
          <name>menc_config</name>
          <description>Encoder configuration register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0F0F1F1F</resetMask>
          <fields>
            <field>
              <name>bf_align3</name>
              <bitRange>[31:28]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>mp1_filter_sample_rate</name>
              <bitRange>[27:25]</bitRange>
              <description>Filter sample rate for mp1 signal: {          | 0: none   - Filter is disabled. 1: 10 ns  - pulses &lt; 10ns  will be blocked, pulses &gt; 20ns will pass. 2: 20 ns  - pulses &lt; 20ns  will be blocked, pulses &gt; 40ns will pass. 3: 50 ns  - pulses &lt; 50ns  will be blocked, pulses &gt; 100ns will pass. 4: 100 ns - pulses &lt; 100ns will be blocked, pulses &gt; 200ns will pass. 5: 200 ns - pulses &lt; 200ns will be blocked, pulses &gt; 400ns will pass. 6: 500 ns - pulses &lt; 500ns will be blocked, pulses &gt; 1us will pass. 7: 1 us   - pulses &lt; 1us   will be blocked, pulses &gt; 2us will pass. } </description>
            </field>
            <field>
              <name>mp1_en</name>
              <bitRange>[24:24]</bitRange>
              <description>mp1 enable: 0: Disable interrupts based on mp1 signal. </description>
            </field>
            <field>
              <name>bf_align2</name>
              <bitRange>[23:20]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>mp0_filter_sample_rate</name>
              <bitRange>[19:17]</bitRange>
              <description>Filter sample rate for mp0 signal: {          | 0: none   - Filter is disabled. 1: 10 ns  - pulses &lt; 10ns  will be blocked, pulses &gt; 20ns will pass. 2: 20 ns  - pulses &lt; 20ns  will be blocked, pulses &gt; 40ns will pass. 3: 50 ns  - pulses &lt; 50ns  will be blocked, pulses &gt; 100ns will pass. 4: 100 ns - pulses &lt; 100ns will be blocked, pulses &gt; 200ns will pass. 5: 200 ns - pulses &lt; 200ns will be blocked, pulses &gt; 400ns will pass. 6: 500 ns - pulses &lt; 500ns will be blocked, pulses &gt; 1us will pass. 7: 1 us   - pulses &lt; 1us   will be blocked, pulses &gt; 2us will pass. } </description>
            </field>
            <field>
              <name>mp0_en</name>
              <bitRange>[16:16]</bitRange>
              <description>mp0 enable: 0: Disable interrupts based on mp0 signal. </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[15:13]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>enc1_count_dir</name>
              <bitRange>[12:12]</bitRange>
              <description>Encoder1 count direction: 0: standard 1: inverted </description>
            </field>
            <field>
              <name>enc1_filter_sample_rate</name>
              <bitRange>[11:9]</bitRange>
              <description>Encoder1 filter sample rate: {          | 0: none   - Filter is disabled. 1: 10 ns  - pulses &lt; 10ns  will be blocked, pulses &gt; 20ns will pass. 2: 20 ns  - pulses &lt; 20ns  will be blocked, pulses &gt; 40ns will pass. 3: 50 ns  - pulses &lt; 50ns  will be blocked, pulses &gt; 100ns will pass. 4: 100 ns - pulses &lt; 100ns will be blocked, pulses &gt; 200ns will pass. 5: 200 ns - pulses &lt; 200ns will be blocked, pulses &gt; 400ns will pass. 6: 500 ns - pulses &lt; 500ns will be blocked, pulses &gt; 1us will pass. 7: 1 us   - pulses &lt; 1us   will be blocked, pulses &gt; 2us will pass. } </description>
            </field>
            <field>
              <name>enc1_en</name>
              <bitRange>[8:8]</bitRange>
              <description>Encoder1 enable: 0: Disable interrupts based on encoder1 signals. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[7:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>enc0_count_dir</name>
              <bitRange>[4:4]</bitRange>
              <description>Encoder0 count direction: 0: standard 1: inverted </description>
            </field>
            <field>
              <name>enc0_filter_sample_rate</name>
              <bitRange>[3:1]</bitRange>
              <description>Encoder0 filter sample rate: {          | 0: none   - Filter is disabled. 1: 10 ns  - pulses &lt; 10ns  will be blocked, pulses &gt; 20ns will pass. 2: 20 ns  - pulses &lt; 20ns  will be blocked, pulses &gt; 40ns will pass. 3: 50 ns  - pulses &lt; 50ns  will be blocked, pulses &gt; 100ns will pass. 4: 100 ns - pulses &lt; 100ns will be blocked, pulses &gt; 200ns will pass. 5: 200 ns - pulses &lt; 200ns will be blocked, pulses &gt; 400ns will pass. 6: 500 ns - pulses &lt; 500ns will be blocked, pulses &gt; 1us will pass. 7: 1 us   - pulses &lt; 1us   will be blocked, pulses &gt; 2us will pass. } </description>
            </field>
            <field>
              <name>enc0_en</name>
              <bitRange>[0:0]</bitRange>
              <description>Encoder0 enable: 0: Disable interrupts based on encoder0 signals. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'menc_enc0_position': 0xFF802304-->
          <name>menc_enc0_position</name>
          <description>Position of encoder 0 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Actual position of encoder 0. This register is writable but can also be changed by hardware. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'menc_enc1_position': 0xFF802308-->
          <name>menc_enc1_position</name>
          <description>Position of encoder 1 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Actual position of encoder 1. This register is writable but can also be changed by hardware. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'menc_capture_now': 0xFF80230C-->
          <name>menc_capture_now</name>
          <description>Capture now register: This register allows activating the capture event by software for all 4 capture units. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>cap3_now</name>
              <bitRange>[3:3]</bitRange>
              <description>Capture menc_capture3 now (by SW). Capture by writing 1 to this register, reset automatically. </description>
            </field>
            <field>
              <name>cap2_now</name>
              <bitRange>[2:2]</bitRange>
              <description>Capture menc_capture2 now (by SW). Capture by writing 1 to this register, reset automatically. </description>
            </field>
            <field>
              <name>cap1_now</name>
              <bitRange>[1:1]</bitRange>
              <description>Capture menc_capture1 now (by SW). Capture by writing 1 to this register, reset automatically. </description>
            </field>
            <field>
              <name>cap0_now</name>
              <bitRange>[0:0]</bitRange>
              <description>Capture menc_capture0 now (by SW). Capture by writing 1 to this register, reset automatically. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'menc_capture0_config': 0xFF802310-->
          <name>menc_capture0_config</name>
          <description>Capture unit 0 configuration register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0001FFFF</resetValue>
          <resetMask>0x003FFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:22]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>conce</name>
              <bitRange>[21:21]</bitRange>
              <description>Capture once: 0:  continuous capture: each event overwrites old capture register 1:  capture once: capture only, if menc_status.cap0 = 0 </description>
            </field>
            <field>
              <name>src_nr</name>
              <bitRange>[20:20]</bitRange>
              <description>Capture source channel: 0:  encoder/channel 0 1:  encoder/channel 1 </description>
            </field>
            <field>
              <name>src</name>
              <bitRange>[19:17]</bitRange>
              <description>Capture source (what to capture): 0:  system time ns (independent of src_nr) 1:  position channel 0/1 2:  Ta of channel 0/1 3:  Te of channel 0/1 4:  Ta+Te of channel 0/1 5:  period in clock cycles (independent of src_nr) </description>
            </field>
            <field>
              <name>trigger</name>
              <bitRange>[16:0]</bitRange>
              <description>Capture start signal: 0x0...0x0FFFF: start at (ECNT == trigger) 0x10000:       positive edge of enc0_n 0x10001:       negative edge of enc0_n 0x10002:       positive edge of enc1_n 0x10003:       positive edge of enc1_n 0x10004:       any edge of enc0_a or enc0_b 0x10005:       any edge of enc1_a or enc0_b 0x10006:       positive edge of mp0 0x10007:       negative edge of mp0 0x10008:       positive edge of mp1 0x10009:       negative edge of mp1 0x1000a:       GPIO_APP_COUNTER0 = 0 0x1000b:       GPIO_APP_COUNTER1 = 0 0x1000c:       GPIO_APP_COUNTER2 = 0 0x1000d:       positive edge of xc_trigger[0] 0x1000e:       positive edge of xc_trigger[1] 0x1000f:       negative edge of xc_trigger[0] 0x10010:       negative edge of xc_trigger[1] 0x10011:       positive edge of xc_sample[0] 0x10012:       positive edge of xc_sample[1] 0x10013:       negative edge of xc_sample[0] 0x10014:       negative edge of xc_sample[1] 0x1FFFF:       off (no automatic capture, only capture_now) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'menc_capture0_val': 0xFF802314-->
          <name>menc_capture0_val</name>
          <description>Capture unit 0 captured value </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000014</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Captured value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'menc_capture0_ta': 0xFF802318-->
          <name>menc_capture0_ta</name>
          <description>Capture unit 0 Ta: This register is only used for debug purposes. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000018</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000FFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:20]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[19:0]</bitRange>
              <description>Actual Ta: Time before first encoder pulse in period. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'menc_capture0_te': 0xFF80231C-->
          <name>menc_capture0_te</name>
          <description>Capture unit 0 Te This register is only used for debug purposes. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000001C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000FFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:20]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[19:0]</bitRange>
              <description>Actual Te: Time after last encoder pulse in period. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'menc_capture1_config': 0xFF802320-->
          <name>menc_capture1_config</name>
          <description>Capture unit 1 configuration register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0001FFFF</resetValue>
          <resetMask>0x003FFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:22]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>conce</name>
              <bitRange>[21:21]</bitRange>
              <description>Capture once: 0:  continuous capture: each event overwrites old capture register 1:  capture once: capture only, if menc_status.cap0 = 0 </description>
            </field>
            <field>
              <name>src_nr</name>
              <bitRange>[20:20]</bitRange>
              <description>Capture source channel: 0:  encoder/channel 0 1:  encoder/channel 1 </description>
            </field>
            <field>
              <name>src</name>
              <bitRange>[19:17]</bitRange>
              <description>Capture source (what to capture): s. capture0_config-src </description>
            </field>
            <field>
              <name>trigger</name>
              <bitRange>[16:0]</bitRange>
              <description>Capture start signal: s. capture0_config-trigger </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'menc_capture1_val': 0xFF802324-->
          <name>menc_capture1_val</name>
          <description>Capture unit 1 captured value </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000024</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Captured value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'menc_capture1_ta': 0xFF802328-->
          <name>menc_capture1_ta</name>
          <description>Capture unit 1 Ta: This register is only used for debug purposes. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000028</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000FFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:20]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[19:0]</bitRange>
              <description>Actual Ta: Time before first encoder pulse in period. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'menc_capture1_te': 0xFF80232C-->
          <name>menc_capture1_te</name>
          <description>Capture unit 1 Te This register is only used for debug purposes. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000002C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000FFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:20]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[19:0]</bitRange>
              <description>Actual Te: Time after last encoder pulse in period. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'menc_capture2_config': 0xFF802330-->
          <name>menc_capture2_config</name>
          <description>Capture unit 2 configuration register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000030</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0001FFFF</resetValue>
          <resetMask>0x003FFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:22]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>conce</name>
              <bitRange>[21:21]</bitRange>
              <description>Capture once: 0:  continuous capture: each event overwrites old capture register 1:  capture once: capture only, if menc_status.cap0 = 0 </description>
            </field>
            <field>
              <name>src_nr</name>
              <bitRange>[20:20]</bitRange>
              <description>Capture source channel: 0:  encoder/channel 0 1:  encoder/channel 1 </description>
            </field>
            <field>
              <name>src</name>
              <bitRange>[19:17]</bitRange>
              <description>Capture source (what to capture): s. capture0_config-src </description>
            </field>
            <field>
              <name>trigger</name>
              <bitRange>[16:0]</bitRange>
              <description>Capture start signal: s. capture0_config-trigger </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'menc_capture2_val': 0xFF802334-->
          <name>menc_capture2_val</name>
          <description>Capture unit 2 captured value </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000034</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Captured value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'menc_capture2_ta': 0xFF802338-->
          <name>menc_capture2_ta</name>
          <description>Capture unit 2 Ta: This register is only used for debug purposes. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000038</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000FFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:20]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[19:0]</bitRange>
              <description>Actual Ta: Time before first encoder pulse in period. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'menc_capture2_te': 0xFF80233C-->
          <name>menc_capture2_te</name>
          <description>Capture unit 2 Te This register is only used for debug purposes. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000003C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000FFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:20]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[19:0]</bitRange>
              <description>Actual Te: Time after last encoder pulse in period. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'menc_capture3_config': 0xFF802340-->
          <name>menc_capture3_config</name>
          <description>Capture unit 3 configuration register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000040</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0001FFFF</resetValue>
          <resetMask>0x003FFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:22]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>conce</name>
              <bitRange>[21:21]</bitRange>
              <description>Capture once: 0:  continuous capture: each event overwrites old capture register 1:  capture once: capture only, if menc_status.cap0 = 0 </description>
            </field>
            <field>
              <name>src_nr</name>
              <bitRange>[20:20]</bitRange>
              <description>Capture source channel: 0:  encoder/channel 0 1:  encoder/channel 1 </description>
            </field>
            <field>
              <name>src</name>
              <bitRange>[19:17]</bitRange>
              <description>Capture source (what to capture): s. capture0_config-src </description>
            </field>
            <field>
              <name>trigger</name>
              <bitRange>[16:0]</bitRange>
              <description>Capture start signal: s. capture0_config-trigger </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'menc_capture3_val': 0xFF802344-->
          <name>menc_capture3_val</name>
          <description>Capture unit 3 captured value </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000044</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Captured value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'menc_capture3_ta': 0xFF802348-->
          <name>menc_capture3_ta</name>
          <description>Capture unit 3 Ta: This register is only used for debug purposes. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000048</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000FFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:20]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[19:0]</bitRange>
              <description>Actual Ta: Time before first encoder pulse in period. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'menc_capture3_te': 0xFF80234C-->
          <name>menc_capture3_te</name>
          <description>Capture unit 3 Te This register is only used for debug purposes. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000004C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000FFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:20]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[19:0]</bitRange>
              <description>Actual Te: Time after last encoder pulse in period. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'menc_status': 0xFF802350-->
          <name>menc_status</name>
          <description>Position and capture status: This register includes all raw IRQs and encoder direction. To reset an IRQ, write 1 to appropriate bit (except enc?_dir_ro). </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000050</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x030F9F9F</resetMask>
          <fields>
            <field>
              <name>bf_align3</name>
              <bitRange>[31:26]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>mp1</name>
              <bitRange>[25:25]</bitRange>
              <description>Rising edge at Measurement Point 1 </description>
            </field>
            <field>
              <name>mp0</name>
              <bitRange>[24:24]</bitRange>
              <description>Rising edge at Measurement Point 0 </description>
            </field>
            <field>
              <name>bf_align2</name>
              <bitRange>[23:20]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>cap3</name>
              <bitRange>[19:19]</bitRange>
              <description>Captured register 3 </description>
            </field>
            <field>
              <name>cap2</name>
              <bitRange>[18:18]</bitRange>
              <description>Captured register 2 </description>
            </field>
            <field>
              <name>cap1</name>
              <bitRange>[17:17]</bitRange>
              <description>Captured register 1 </description>
            </field>
            <field>
              <name>cap0</name>
              <bitRange>[16:16]</bitRange>
              <description>Captured register 0 </description>
            </field>
            <field>
              <name>enc1_dir_ro</name>
              <bitRange>[15:15]</bitRange>
              <description>Encoder1 direction (read only) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[14:13]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>enc1_n</name>
              <bitRange>[12:12]</bitRange>
              <description>Rising edge at input enc1_n. </description>
            </field>
            <field>
              <name>enc1_phase_error</name>
              <bitRange>[11:11]</bitRange>
              <description>Phase error at encoder 1: Encoder inputs changed 2 phases in 1 cycle, which leads to unknown position. </description>
            </field>
            <field>
              <name>enc1_ovfl_neg</name>
              <bitRange>[10:10]</bitRange>
              <description>Encoder1 overflow negative </description>
            </field>
            <field>
              <name>enc1_ovfl_pos</name>
              <bitRange>[9:9]</bitRange>
              <description>Encoder1 overflow positive </description>
            </field>
            <field>
              <name>enc1_edge</name>
              <bitRange>[8:8]</bitRange>
              <description>Edge at Encoder 1 occurred (rising or falling of enc1_a or enc1_b) </description>
            </field>
            <field>
              <name>enc0_dir_ro</name>
              <bitRange>[7:7]</bitRange>
              <description>Encoder0 direction (read only) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[6:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>enc0_n</name>
              <bitRange>[4:4]</bitRange>
              <description>Rising edge at input enc0_n. </description>
            </field>
            <field>
              <name>enc0_phase_error</name>
              <bitRange>[3:3]</bitRange>
              <description>Phase error at encoder 0: Encoder inputs changed 2 phases in 1 cycle, which leads to unknown position. </description>
            </field>
            <field>
              <name>enc0_ovfl_neg</name>
              <bitRange>[2:2]</bitRange>
              <description>Encoder0 overflow negative </description>
            </field>
            <field>
              <name>enc0_ovfl_pos</name>
              <bitRange>[1:1]</bitRange>
              <description>Encoder0 overflow positive </description>
            </field>
            <field>
              <name>enc0_edge</name>
              <bitRange>[0:0]</bitRange>
              <description>Edge at Encoder 0 occurred (rising or falling of enc0_a or enc0_b) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'menc_irq_masked': 0xFF802354-->
          <name>menc_irq_masked</name>
          <description>Masked IRQ register: Shows status of masked IRQs (as connected to ARM/xPIC). </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000054</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x030F1F1F</resetMask>
          <fields>
            <field>
              <name>bf_align3</name>
              <bitRange>[31:26]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>mp1</name>
              <bitRange>[25:25]</bitRange>
              <description>Rising edge at Measurement Point 1 </description>
            </field>
            <field>
              <name>mp0</name>
              <bitRange>[24:24]</bitRange>
              <description>Rising edge at Measurement Point 0 </description>
            </field>
            <field>
              <name>bf_align2</name>
              <bitRange>[23:20]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>cap3</name>
              <bitRange>[19:19]</bitRange>
              <description>Captured register 3 </description>
            </field>
            <field>
              <name>cap2</name>
              <bitRange>[18:18]</bitRange>
              <description>Captured register 2 </description>
            </field>
            <field>
              <name>cap1</name>
              <bitRange>[17:17]</bitRange>
              <description>Captured register 1 </description>
            </field>
            <field>
              <name>cap0</name>
              <bitRange>[16:16]</bitRange>
              <description>Captured register 0 </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[15:13]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>enc1_n</name>
              <bitRange>[12:12]</bitRange>
              <description>Rising edge at input enc1_n. </description>
            </field>
            <field>
              <name>enc1_phase_error</name>
              <bitRange>[11:11]</bitRange>
              <description>Phase error at encoder 1: Encoder inputs changed 2 phases in 1 cycle, which leads to unknown position. </description>
            </field>
            <field>
              <name>enc1_ovfl_neg</name>
              <bitRange>[10:10]</bitRange>
              <description>Encoder1 overflow negative </description>
            </field>
            <field>
              <name>enc1_ovfl_pos</name>
              <bitRange>[9:9]</bitRange>
              <description>Encoder1 overflow positive </description>
            </field>
            <field>
              <name>enc1_edge</name>
              <bitRange>[8:8]</bitRange>
              <description>Edge at Encoder 1 occurred (rising or falling of enc1_a or enc1_b) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[7:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>enc0_n</name>
              <bitRange>[4:4]</bitRange>
              <description>Rising edge at input enc0_n. </description>
            </field>
            <field>
              <name>enc0_phase_error</name>
              <bitRange>[3:3]</bitRange>
              <description>Phase error at encoder 0: Encoder inputs changed 2 phases in 1 cycle, which leads to unknown position. </description>
            </field>
            <field>
              <name>enc0_ovfl_neg</name>
              <bitRange>[2:2]</bitRange>
              <description>Encoder0 overflow negative </description>
            </field>
            <field>
              <name>enc0_ovfl_pos</name>
              <bitRange>[1:1]</bitRange>
              <description>Encoder0 overflow positive </description>
            </field>
            <field>
              <name>enc0_edge</name>
              <bitRange>[0:0]</bitRange>
              <description>Edge at Encoder 0 occurred (rising or falling of enc0_a or enc0_b) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'menc_irq_msk_set': 0xFF802358-->
          <name>menc_irq_msk_set</name>
          <description>IRQ mask enable: The IRQ mask enables interrupt requests for corresponding interrupt sources.   As its bits might be changed by different software tasks,   the IRQ mask register is not writable directly, but by set and reset masks: Write access with '1' sets interrupt mask bit. Write access with '0' does not influence this bit. Read access shows actual interrupt mask. Attention: Before activating interrupt mask, delete old pending interrupts by writing the same value to adr_menc_status </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000058</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x030F1F1F</resetMask>
          <fields>
            <field>
              <name>bf_align3</name>
              <bitRange>[31:26]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>mp1</name>
              <bitRange>[25:25]</bitRange>
              <description>Rising edge at Measurement Point 1 </description>
            </field>
            <field>
              <name>mp0</name>
              <bitRange>[24:24]</bitRange>
              <description>Rising edge at Measurement Point 0 </description>
            </field>
            <field>
              <name>bf_align2</name>
              <bitRange>[23:20]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>cap3</name>
              <bitRange>[19:19]</bitRange>
              <description>Captured register 3 </description>
            </field>
            <field>
              <name>cap2</name>
              <bitRange>[18:18]</bitRange>
              <description>Captured register 2 </description>
            </field>
            <field>
              <name>cap1</name>
              <bitRange>[17:17]</bitRange>
              <description>Captured register 1 </description>
            </field>
            <field>
              <name>cap0</name>
              <bitRange>[16:16]</bitRange>
              <description>Captured register 0 </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[15:13]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>enc1_n</name>
              <bitRange>[12:12]</bitRange>
              <description>Rising edge at input enc1_n. </description>
            </field>
            <field>
              <name>enc1_phase_error</name>
              <bitRange>[11:11]</bitRange>
              <description>Phase error at encoder 1: Encoder inputs changed 2 phases in 1 cycle, which leads to unknown position. </description>
            </field>
            <field>
              <name>enc1_ovfl_neg</name>
              <bitRange>[10:10]</bitRange>
              <description>Encoder1 overflow negative </description>
            </field>
            <field>
              <name>enc1_ovfl_pos</name>
              <bitRange>[9:9]</bitRange>
              <description>Encoder1 overflow positive </description>
            </field>
            <field>
              <name>enc1_edge</name>
              <bitRange>[8:8]</bitRange>
              <description>Edge at Encoder 1 occurred (rising or falling of enc1_a or enc1_b) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[7:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>enc0_n</name>
              <bitRange>[4:4]</bitRange>
              <description>Rising edge at input enc0_n. </description>
            </field>
            <field>
              <name>enc0_phase_error</name>
              <bitRange>[3:3]</bitRange>
              <description>Phase error at encoder 0: Encoder inputs changed 2 phases in 1 cycle, which leads to unknown position. </description>
            </field>
            <field>
              <name>enc0_ovfl_neg</name>
              <bitRange>[2:2]</bitRange>
              <description>Encoder0 overflow negative </description>
            </field>
            <field>
              <name>enc0_ovfl_pos</name>
              <bitRange>[1:1]</bitRange>
              <description>Encoder0 overflow positive </description>
            </field>
            <field>
              <name>enc0_edge</name>
              <bitRange>[0:0]</bitRange>
              <description>Edge at Encoder 0 occurred (rising or falling of enc0_a or enc0_b) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'menc_irq_msk_reset': 0xFF80235C-->
          <name>menc_irq_msk_reset</name>
          <description>IRQ mask disable: This is the corresponding reset mask to disable interrupt requests for corresponding interrupt sources: Write access with '1' resets interrupt mask bit. Write access with '0' does not influence this bit. Read access shows actual interrupt mask. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000005C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x030F1F1F</resetMask>
          <fields>
            <field>
              <name>bf_align3</name>
              <bitRange>[31:26]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>mp1</name>
              <bitRange>[25:25]</bitRange>
              <description>Rising edge at Measurement Point 1 </description>
            </field>
            <field>
              <name>mp0</name>
              <bitRange>[24:24]</bitRange>
              <description>Rising edge at Measurement Point 0 </description>
            </field>
            <field>
              <name>bf_align2</name>
              <bitRange>[23:20]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>cap3</name>
              <bitRange>[19:19]</bitRange>
              <description>Captured register 3 </description>
            </field>
            <field>
              <name>cap2</name>
              <bitRange>[18:18]</bitRange>
              <description>Captured register 2 </description>
            </field>
            <field>
              <name>cap1</name>
              <bitRange>[17:17]</bitRange>
              <description>Captured register 1 </description>
            </field>
            <field>
              <name>cap0</name>
              <bitRange>[16:16]</bitRange>
              <description>Captured register 0 </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[15:13]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>enc1_n</name>
              <bitRange>[12:12]</bitRange>
              <description>Rising edge at input enc1_n. </description>
            </field>
            <field>
              <name>enc1_phase_error</name>
              <bitRange>[11:11]</bitRange>
              <description>Phase error at encoder 1: Encoder inputs changed 2 phases in 1 cycle, which leads to unknown position. </description>
            </field>
            <field>
              <name>enc1_ovfl_neg</name>
              <bitRange>[10:10]</bitRange>
              <description>Encoder1 overflow negative </description>
            </field>
            <field>
              <name>enc1_ovfl_pos</name>
              <bitRange>[9:9]</bitRange>
              <description>Encoder1 overflow positive </description>
            </field>
            <field>
              <name>enc1_edge</name>
              <bitRange>[8:8]</bitRange>
              <description>Edge at Encoder 1 occurred (rising or falling of enc1_a or enc1_b) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[7:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>enc0_n</name>
              <bitRange>[4:4]</bitRange>
              <description>Rising edge at input enc0_n. </description>
            </field>
            <field>
              <name>enc0_phase_error</name>
              <bitRange>[3:3]</bitRange>
              <description>Phase error at encoder 0: Encoder inputs changed 2 phases in 1 cycle, which leads to unknown position. </description>
            </field>
            <field>
              <name>enc0_ovfl_neg</name>
              <bitRange>[2:2]</bitRange>
              <description>Encoder0 overflow negative </description>
            </field>
            <field>
              <name>enc0_ovfl_pos</name>
              <bitRange>[1:1]</bitRange>
              <description>Encoder0 overflow positive </description>
            </field>
            <field>
              <name>enc0_edge</name>
              <bitRange>[0:0]</bitRange>
              <description>Edge at Encoder 0 occurred (rising or falling of enc0_a or enc0_b) </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>mpwm_app</name>
      <description>mpwm_app</description>
      <baseAddress>0xFF802400</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>512</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>mpwm</name>
        <value>49</value>
      </interrupt>
      <registers>
        <register>
          <!--Absolute address of 'mpwm_cfg': 0xFF802400-->
          <name>mpwm_cfg</name>
          <description>Config register: General config bits for the MPWM module. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000800</resetValue>
          <resetMask>0x00FFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:24]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>eci_fil_thresh</name>
              <bitRange>[23:16]</bitRange>
              <description>ECI filter threshold: Threshold value for the error condition input integral filter. </description>
            </field>
            <field>
              <name>evt_cnt_top</name>
              <bitRange>[15:11]</bitRange>
              <description>evt_cnt_top Used to specify the maximum value of EVT_CNT. When EVT_CNT is zero and a begin of period )BOP) event occurs, an event counter zero (ECZ) event is emitted and EVT_CNT is reset to evt_cnt_top. If an begin of period event occurs and EVT_CNT is not zero, EVT_CNT is decremented. This mechanism can be used as an event prescaler to reduce the number of period interrupts from the MPWM module. Examples: If evt_cnt_top is zero, ECZ events and BOP events will coincide. If evt_cnt_top is one, ECZ events will appear every other period (half the frequency of BOP events). If evt_cnt_top is two, ECZ events will appear every third period (one third the frequency of BOP events). </description>
            </field>
            <field>
              <name>sce_src_mop</name>
              <bitRange>[10:10]</bitRange>
              <description>sce_src_mop 1=emit shadow copy event on middle of PWM period bit </description>
            </field>
            <field>
              <name>sce_src_bop</name>
              <bitRange>[9:9]</bitRange>
              <description>sce_src_bop 1=emit shadow copy event on beginning of PWM period </description>
            </field>
            <field>
              <name>sce_src_ecz</name>
              <bitRange>[8:8]</bitRange>
              <description>sce_src_ecz 1=emit shadow copy event when event counter reaches zero </description>
            </field>
            <field>
              <name>eci_ks_en</name>
              <bitRange>[7:7]</bitRange>
              <description>eci_ks_en Set 1 to enable synchronous error condition input (eci) kill switch. The synchronous eci kill switch is a flip flop that is set once eci is active. The eci kill switch can only be reset through MPWM_ECI_CMD. When the eci kill switch is set, all PWM module outputs are disabled. </description>
            </field>
            <field>
              <name>eci_gate_en</name>
              <bitRange>[6:6]</bitRange>
              <description>eci_gate_en Set 1 to gate all pwm outputs with the integral filtered error control input. This means that the outputs will be disabled asynchronously whenever eci is active. </description>
            </field>
            <field>
              <name>eci_inv</name>
              <bitRange>[5:5]</bitRange>
              <description>eci_inv This bit controls the polarity of the error condition input (eci). Set 0 for active high eci, 1 for active low eci. </description>
            </field>
            <field>
              <name>sync_in_pol</name>
              <bitRange>[4:4]</bitRange>
              <description>Polarity of sync signal from trigger_latch unit 0: Sync on rising edge 1: Sync on falling edge </description>
            </field>
            <field>
              <name>sync_in_restart</name>
              <bitRange>[3:3]</bitRange>
              <description>Restart at sync signal from trigger_latch unit 0: Restart counter only by restart command. 1: Restart counter at sync signal or by restart command. </description>
            </field>
            <field>
              <name>cnt_en_rs</name>
              <bitRange>[2:2]</bitRange>
              <description>cnt_en_rs When this bit is one and sync_in is active, save the value of MPWM_CNT to the MPWM_CNT_RS (rs = read sync) register. </description>
            </field>
            <field>
              <name>cnt_mode</name>
              <bitRange>[1:0]</bitRange>
              <description>Counter mode: 00: sawtooth 01: triangle 10: inv sawtooth 11: inv triangle </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mpwm_cnt_max': 0xFF802404-->
          <name>mpwm_cnt_max</name>
          <description>Counter top register: This is the maximum / top value for the PWM counter. In inverse sawtooth mode, MPWM_CNT   will be loaded with MPWM_CNT_MAX after reaching zero or when restarting the counter. In sawtooth   mode, MPWM_CNT will be reset to zero after reaching MPWM_CNT_MAX. In inverse sawtooth   mode, MPWM_CNT will be set to MPWM_CNT_MAX when restarting the counter, and when it reaches   MPWM_CNT_MAX while counting up, it will change to counting down. In inverse sawtooth mode,   when MPWM_CNT reaches MPWM_CNT_MAX while counting up, it will change to counting down. In   either sawtooth mode, the most significant bit must be zero. This is necessary to ensure a   valid MPWM_ECNT.   The CNT_MAX register must be at least 1 for correct operation of the counter. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[15:0]</bitRange>
              <description>Counter top value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mpwm_cnt_ps_max': 0xFF802408-->
          <name>mpwm_cnt_ps_max</name>
          <description>Counter prescaler max value register: The values of this register determines how often MPWM_CNT and the counters in the dead   time generators will be updated. When setting MPWM_CNT_PS_MAX to n, MPWM_CNT will be   updated every n + 1 system clock cycles. This register can be used to slow down operation   of the counter. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[7:0]</bitRange>
              <description>Counter prescaler max value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mpwm_dt': 0xFF80240C-->
          <name>mpwm_dt</name>
          <description>Dead time register: This is the number of dead (LS and HS off) cycles (prescaled by MPWM_CNT_PS) that the dead   time generator inserts when the direct PWM signal changes from zero to one (rise_val) and   from one to zero (fall_val). Set to zero for no dead cycles. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>fall_val</name>
              <bitRange>[15:8]</bitRange>
              <description>Dead time cycles at falling edge of PWM signal </description>
            </field>
            <field>
              <name>rise_val</name>
              <bitRange>[7:0]</bitRange>
              <description>Dead time cycles at rising edge of PWM signal </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mpwm_ocfg': 0xFF802410-->
          <name>mpwm_ocfg</name>
          <description>Output section config register: Output select, enable, invert and edge detect values. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x7FFFFFBF</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:31]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>oedpol5</name>
              <bitRange>[30:30]</bitRange>
              <description>Channel 5 edge detector polarity (0 = detect positive edge, 1 = detect negative edge) </description>
            </field>
            <field>
              <name>oedpol4</name>
              <bitRange>[29:29]</bitRange>
              <description>Channel 4 edge detector polarity </description>
            </field>
            <field>
              <name>oedpol3</name>
              <bitRange>[28:28]</bitRange>
              <description>Channel 3 edge detector polarity </description>
            </field>
            <field>
              <name>oedpol2</name>
              <bitRange>[27:27]</bitRange>
              <description>Channel 2 edge detector polarity </description>
            </field>
            <field>
              <name>oedpol1</name>
              <bitRange>[26:26]</bitRange>
              <description>Channel 1 edge detector polarity </description>
            </field>
            <field>
              <name>oedpol0</name>
              <bitRange>[25:25]</bitRange>
              <description>Channel 0 edge detector polarity </description>
            </field>
            <field>
              <name>oeden5</name>
              <bitRange>[24:24]</bitRange>
              <description>Channel 5 edge detector enable </description>
            </field>
            <field>
              <name>oeden4</name>
              <bitRange>[23:23]</bitRange>
              <description>Channel 4 edge detector enable </description>
            </field>
            <field>
              <name>oeden3</name>
              <bitRange>[22:22]</bitRange>
              <description>Channel 3 edge detector enable </description>
            </field>
            <field>
              <name>oeden2</name>
              <bitRange>[21:21]</bitRange>
              <description>Channel 2 edge detector enable </description>
            </field>
            <field>
              <name>oeden1</name>
              <bitRange>[20:20]</bitRange>
              <description>Channel 1 edge detector enable </description>
            </field>
            <field>
              <name>oeden0</name>
              <bitRange>[19:19]</bitRange>
              <description>Channel 0 edge detector enable </description>
            </field>
            <field>
              <name>oinv5</name>
              <bitRange>[18:18]</bitRange>
              <description>Output 5 invert </description>
            </field>
            <field>
              <name>oinv4</name>
              <bitRange>[17:17]</bitRange>
              <description>Output 4 invert </description>
            </field>
            <field>
              <name>oinv3</name>
              <bitRange>[16:16]</bitRange>
              <description>Output 3 invert </description>
            </field>
            <field>
              <name>oinv2</name>
              <bitRange>[15:15]</bitRange>
              <description>Output 2 invert </description>
            </field>
            <field>
              <name>oinv1</name>
              <bitRange>[14:14]</bitRange>
              <description>Output 1 invert </description>
            </field>
            <field>
              <name>oinv0</name>
              <bitRange>[13:13]</bitRange>
              <description>Output 0 invert (see output section diagram) </description>
            </field>
            <field>
              <name>oe5</name>
              <bitRange>[12:12]</bitRange>
              <description>Output 5 enable </description>
            </field>
            <field>
              <name>oe4</name>
              <bitRange>[11:11]</bitRange>
              <description>Output 4 enable </description>
            </field>
            <field>
              <name>oe3</name>
              <bitRange>[10:10]</bitRange>
              <description>Output 3 enable </description>
            </field>
            <field>
              <name>oe2</name>
              <bitRange>[9:9]</bitRange>
              <description>Output 2 enable </description>
            </field>
            <field>
              <name>oe1</name>
              <bitRange>[8:8]</bitRange>
              <description>Output 1 enable </description>
            </field>
            <field>
              <name>oe0</name>
              <bitRange>[7:7]</bitRange>
              <description>Output 0 enable (see output section diagram) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[6:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>osel5</name>
              <bitRange>[5:5]</bitRange>
              <description>Output 5 selector: 0: compare channel 5 direct PWM output 1: dead time generator channel 2 LS </description>
            </field>
            <field>
              <name>osel4</name>
              <bitRange>[4:4]</bitRange>
              <description>Output 4 selector: 0: compare channel 4 direct PWM output 1: dead time generator channel 2 HS </description>
            </field>
            <field>
              <name>osel3</name>
              <bitRange>[3:3]</bitRange>
              <description>Output 3 selector: 0: compare channel 3 direct PWM output 1: dead time generator channel 1 LS </description>
            </field>
            <field>
              <name>osel2</name>
              <bitRange>[2:2]</bitRange>
              <description>Output 2 selector: 0: compare channel 2 direct PWM output 1: dead time generator channel 1 HS </description>
            </field>
            <field>
              <name>osel1</name>
              <bitRange>[1:1]</bitRange>
              <description>Output 1 selector: 0: compare channel 1 direct PWM output 1: dead time generator channel 0 LS </description>
            </field>
            <field>
              <name>osel0</name>
              <bitRange>[0:0]</bitRange>
              <description>Output 0 selector: 0: compare channel 0 direct PWM output 1: dead time generator channel 0 HS </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mpwm_cnt_max_s': 0xFF802414-->
          <name>mpwm_cnt_max_s</name>
          <description>Counter top shadow register: Shadow register for MPWM_CNT_TOP. After writing this register, an internal flag is set. If   the internal flag is set, at the next occurence of a shadow copy event cnt_top will be   overwritten by MPWM_CNT_MAX_S and the internal flag will be reset. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[15:0]</bitRange>
              <description>Counter top shadow value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mpwm_dt_s': 0xFF802418-->
          <name>mpwm_dt_s</name>
          <description>Dead time shadow register: Shadow register for MPWM_DT register. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000018</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>fall_val</name>
              <bitRange>[15:8]</bitRange>
              <description>Dead time shadow value for falling edge of PWM signal </description>
            </field>
            <field>
              <name>rise_val</name>
              <bitRange>[7:0]</bitRange>
              <description>Dead time shadow value for rising edge of PWM signal </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mpwm_status': 0xFF80241C-->
          <name>mpwm_status</name>
          <description>Status register: This register can be read to obtain information about the current status of the MPWM   module. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000001C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>cnt_half</name>
              <bitRange>[3:3]</bitRange>
              <description>count half: 0: counter is in first half period of triangle mode or inverted triangle mode or counter is in sawtooth or inverse sawtooth mode. 1: counter is in second half period of triangle mode or inverted triangle mode </description>
            </field>
            <field>
              <name>cnt_updown</name>
              <bitRange>[2:2]</bitRange>
              <description>count updown 0: counter is counting down 1: counter is counting up </description>
            </field>
            <field>
              <name>eci_val_unfil</name>
              <bitRange>[1:1]</bitRange>
              <description>Error Condition Input unfiltered: Read the current value of the error condition input before the digital integral filter. This bit is corrected for polarity, which means it reads zero for inactive, one for active. </description>
            </field>
            <field>
              <name>running</name>
              <bitRange>[0:0]</bitRange>
              <description>MPWM is running </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mpwm_cmd': 0xFF802420-->
          <name>mpwm_cmd</name>
          <description>Command register: </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000020</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000003F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>eci_ks_rst</name>
              <bitRange>[5:5]</bitRange>
              <description>ECI kill switch reset: Command register to reset the eci kill switch. </description>
            </field>
            <field>
              <name>evt_cnt_rst</name>
              <bitRange>[4:4]</bitRange>
              <description>Event Counter Reset </description>
            </field>
            <field>
              <name>sce_emit</name>
              <bitRange>[3:3]</bitRange>
              <description>Copy shadow registers to corresponding registers </description>
            </field>
            <field>
              <name>restart</name>
              <bitRange>[2:2]</bitRange>
              <description>Restart: Write 1 to this bit to reset MPWM_CNT and MPWM_CNT_PS and start counter operation. MPWM_CNT_PS is reset to MPWM_CNT_PS_MAX. In triangle and sawtooth mode, MPWM_CNT is reset to 0. In inverse triangle and inverse sawtooth mode, MPWM_CNT is reset to MPWM_CNT_MAX. If the restart and the stop bit are written as 1 in the same access, the MPWM_CNT and MPWM_CNT_PS registers will be reset but the counter will remain stopped. </description>
            </field>
            <field>
              <name>stop</name>
              <bitRange>[1:1]</bitRange>
              <description>Stop: Write 1 to this bit to stop counter operation and prescaler operation. </description>
            </field>
            <field>
              <name>start</name>
              <bitRange>[0:0]</bitRange>
              <description>Start: Write 1 to start counter operation and prescaler operation. This does not reset the counter state. If the counter operating before, it will resume operation from where it was stopped. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mpwm_cnt': 0xFF802424-->
          <name>mpwm_cnt</name>
          <description>Counter: Global counter. Used for all the comparisons that then generate the PWM signals. See   counter behaviour diagram. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000024</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[15:0]</bitRange>
              <description>value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mpwm_ecnt': 0xFF802428-->
          <name>mpwm_ecnt</name>
          <description>Extended counter: Counter extended by one bit to distinguish between counting up and down. See counter   behaviour diagram. The content of this register is also exposed to the outside of this   module to allow other system components to synchronize themselves to the MPWM counter. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000028</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[15:0]</bitRange>
              <description>value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mpwm_cnt_rs': 0xFF80242C-->
          <name>mpwm_cnt_rs</name>
          <description>Counter save register: When CFG.cnt_en_rs (rs = read sync) is set, this register is used to save the value of the   MPWM_CNT and MPWM_CNT_PS register every time that sync_in becomes active. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000002C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00FFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:24]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ps_val</name>
              <bitRange>[23:16]</bitRange>
              <description>saved value of the MPWM_CNT_PS register </description>
            </field>
            <field>
              <name>cnt_val</name>
              <bitRange>[15:0]</bitRange>
              <description>saved value of the MPWM_CNT register </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mpwm_cnt_ps': 0xFF802430-->
          <name>mpwm_cnt_ps</name>
          <description>Counter prescaler register: Internal counter that is responsible for determining, in which clock cycles cnt will be   incremented / decremented. MPWM_CNT_PS is reloaded with MPWM_CNT_PS_MAX when it reaches   zero. In every clock cycle, in which MPWM_CNT_PS is zero, cnt will be incremented /   decremented. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000030</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[7:0]</bitRange>
              <description>value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mpwm_evt_cnt': 0xFF802434-->
          <name>mpwm_evt_cnt</name>
          <description>Event counter register: This counter counts down whenever a full PWM period is finished. When MPWM_EVT_CNT reaches   zero, a event counter zero event is emitted and MPWM_EVT_CNT is reset to MPWM_EVT_CNT_TOP. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000034</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000001F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[4:0]</bitRange>
              <description>Current counter value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mpwm_bc_s': 0xFF802438-->
          <name>mpwm_bc_s</name>
          <description>Brake chopper shadow register: Shadow register for the brake chopper output </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000038</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[0:0]</bitRange>
              <description>value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mpwm_bc': 0xFF80243C-->
          <name>mpwm_bc</name>
          <description>Brake chopper register: The brake chopper output signal is determined by the value of this register. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000003C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[0:0]</bitRange>
              <description>value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mpwm_ch0_cmp0_s': 0xFF802500-->
          <name>mpwm_ch0_cmp0_s</name>
          <description>Channel 0 compare value 0 shadow register: Compare value 0 shadow register for channel 0. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[15:0]</bitRange>
              <description>value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mpwm_ch0_cmp1_s': 0xFF802504-->
          <name>mpwm_ch0_cmp1_s</name>
          <description>Channel 0 compare value 1 shadow register: Compare value 1 shadow register for channel 0. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000104</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[15:0]</bitRange>
              <description>value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mpwm_ch0_cmp0': 0xFF802508-->
          <name>mpwm_ch0_cmp0</name>
          <description>Channel 0 compare value 0 register: Compare value 0 for channel 0. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000108</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[15:0]</bitRange>
              <description>value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mpwm_ch0_cmp1': 0xFF80250C-->
          <name>mpwm_ch0_cmp1</name>
          <description>Channel 0 compare value 1 register: Compare value 1 for channel 0. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000010C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[15:0]</bitRange>
              <description>value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mpwm_ch0_muxin_s': 0xFF802510-->
          <name>mpwm_ch0_muxin_s</name>
          <description>Channel 0 multiplexer input shadow register: Shadow register for channel 0 multiplexer input register. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000110</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000007</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:3]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ab</name>
              <bitRange>[2:2]</bitRange>
              <description>above </description>
            </field>
            <field>
              <name>bt</name>
              <bitRange>[1:1]</bitRange>
              <description>between </description>
            </field>
            <field>
              <name>bl</name>
              <bitRange>[0:0]</bitRange>
              <description>below </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mpwm_ch0_muxin': 0xFF802514-->
          <name>mpwm_ch0_muxin</name>
          <description>Channel 0 multiplexer input register: This register is central in determining the direct PWM output value of channel 0.   When (CNT  &lt; CHX_CMP0) and (CNT  &lt; CHX_CMP1), then the direct PWM output signal   is equal to CHX_MUXIN.bl (counter value is BeLow both compare values).   When (CNT &gt;= CHX_CMP0) and (CNT &gt;= CHX_CMP1), then the direct PWM output signal   is equal to CHX_MUXIN.ab (counter value is ABove both compare values).   If neither is the case, CNT is BeTween CHX_CMP0 and CHX_CMP1 and the direct PWM output signal   is equal to CHX_MUXIN.bt. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000114</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000007</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:3]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ab</name>
              <bitRange>[2:2]</bitRange>
              <description>above </description>
            </field>
            <field>
              <name>bt</name>
              <bitRange>[1:1]</bitRange>
              <description>between </description>
            </field>
            <field>
              <name>bl</name>
              <bitRange>[0:0]</bitRange>
              <description>below </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mpwm_ch1_cmp0_s': 0xFF802520-->
          <name>mpwm_ch1_cmp0_s</name>
          <description>Channel 1 compare value 0 shadow register: Compare value 0 shadow register for channel 1. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000120</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[15:0]</bitRange>
              <description>value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mpwm_ch1_cmp1_s': 0xFF802524-->
          <name>mpwm_ch1_cmp1_s</name>
          <description>Channel 1 compare value 1 shadow register: Compare value 1 shadow register for channel 1. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000124</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[15:0]</bitRange>
              <description>value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mpwm_ch1_cmp0': 0xFF802528-->
          <name>mpwm_ch1_cmp0</name>
          <description>Channel 1 compare value 0 register: Compare value 0 for channel 1. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000128</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[15:0]</bitRange>
              <description>value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mpwm_ch1_cmp1': 0xFF80252C-->
          <name>mpwm_ch1_cmp1</name>
          <description>Channel 1 compare value 1 register: Compare value 1 for channel 1. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000012C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[15:0]</bitRange>
              <description>value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mpwm_ch1_muxin_s': 0xFF802530-->
          <name>mpwm_ch1_muxin_s</name>
          <description>Channel 1 multiplexer input shadow register: Shadow register for channel 1 multiplexer input register. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000130</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000007</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:3]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ab</name>
              <bitRange>[2:2]</bitRange>
              <description>above </description>
            </field>
            <field>
              <name>bt</name>
              <bitRange>[1:1]</bitRange>
              <description>between </description>
            </field>
            <field>
              <name>bl</name>
              <bitRange>[0:0]</bitRange>
              <description>below </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mpwm_ch1_muxin': 0xFF802534-->
          <name>mpwm_ch1_muxin</name>
          <description>Channel 1 multiplexer input register: This register is central in determining the direct PWM output value of channel 1. When   (CHX_CMP0 $&gt;=$ CNT) and (CHX_CMP1 $&gt;=$ CNT), the direct PWM output signal is equal to   CHX_MUXIN.bl (counter value is below both compare values). When (CHX_CMP0 $&gt;=$ CNT) xor   (CHX_CMP1 $&gt;=$ CNT) is true, then the direct PWM output signal is equal to CHX_MUXIN.bt   (counter value is between both compare values). When not (CHX_CMP0 $&gt;=$ CNT) and not   (CHX_CMP1 $&gt;=$ CNT), then the direct PWM output signal is equal to CHX_MUXIN.ab (counter   value is above both compare values). </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000134</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000007</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:3]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ab</name>
              <bitRange>[2:2]</bitRange>
              <description>above </description>
            </field>
            <field>
              <name>bt</name>
              <bitRange>[1:1]</bitRange>
              <description>between </description>
            </field>
            <field>
              <name>bl</name>
              <bitRange>[0:0]</bitRange>
              <description>below </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mpwm_ch2_cmp0_s': 0xFF802540-->
          <name>mpwm_ch2_cmp0_s</name>
          <description>Channel 2 compare value 0 shadow register: Compare value 0 shadow register for channel 2. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000140</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[15:0]</bitRange>
              <description>value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mpwm_ch2_cmp1_s': 0xFF802544-->
          <name>mpwm_ch2_cmp1_s</name>
          <description>Channel 2 compare value 1 shadow register: Compare value 1 shadow register for channel 2. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000144</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[15:0]</bitRange>
              <description>value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mpwm_ch2_cmp0': 0xFF802548-->
          <name>mpwm_ch2_cmp0</name>
          <description>Channel 2 compare value 0 register: Compare value 0 for channel 2. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000148</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[15:0]</bitRange>
              <description>value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mpwm_ch2_cmp1': 0xFF80254C-->
          <name>mpwm_ch2_cmp1</name>
          <description>Channel 2 compare value 1 register: Compare value 1 for channel 2. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000014C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[15:0]</bitRange>
              <description>value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mpwm_ch2_muxin_s': 0xFF802550-->
          <name>mpwm_ch2_muxin_s</name>
          <description>Channel 2 multiplexer input shadow register: Shadow register for channel 2 multiplexer input register. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000150</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000007</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:3]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ab</name>
              <bitRange>[2:2]</bitRange>
              <description>above </description>
            </field>
            <field>
              <name>bt</name>
              <bitRange>[1:1]</bitRange>
              <description>between </description>
            </field>
            <field>
              <name>bl</name>
              <bitRange>[0:0]</bitRange>
              <description>below </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mpwm_ch2_muxin': 0xFF802554-->
          <name>mpwm_ch2_muxin</name>
          <description>Channel 2 multiplexer input register: This register is central in determining the direct PWM output value of channel 2. When   (CHX_CMP0 $&gt;=$ CNT) and (CHX_CMP1 $&gt;=$ CNT), the direct PWM output signal is equal to   CHX_MUXIN.bl (counter value is below both compare values). When (CHX_CMP0 $&gt;=$ CNT) xor   (CHX_CMP1 $&gt;=$ CNT) is true, then the direct PWM output signal is equal to CHX_MUXIN.bt   (counter value is between both compare values). When not (CHX_CMP0 $&gt;=$ CNT) and not   (CHX_CMP1 $&gt;=$ CNT), then the direct PWM output signal is equal to CHX_MUXIN.ab (counter   value is above both compare values). </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000154</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000007</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:3]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ab</name>
              <bitRange>[2:2]</bitRange>
              <description>above </description>
            </field>
            <field>
              <name>bt</name>
              <bitRange>[1:1]</bitRange>
              <description>between </description>
            </field>
            <field>
              <name>bl</name>
              <bitRange>[0:0]</bitRange>
              <description>below </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mpwm_ch3_cmp0_s': 0xFF802560-->
          <name>mpwm_ch3_cmp0_s</name>
          <description>Channel 3 compare value 0 shadow register: Compare value 0 shadow register for channel 3. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000160</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[15:0]</bitRange>
              <description>value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mpwm_ch3_cmp1_s': 0xFF802564-->
          <name>mpwm_ch3_cmp1_s</name>
          <description>Channel 3 compare value 1 shadow register: Compare value 1 shadow register for channel 3. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000164</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[15:0]</bitRange>
              <description>value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mpwm_ch3_cmp0': 0xFF802568-->
          <name>mpwm_ch3_cmp0</name>
          <description>Channel 3 compare value 0 register: Compare value 0 for channel 3. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000168</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[15:0]</bitRange>
              <description>value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mpwm_ch3_cmp1': 0xFF80256C-->
          <name>mpwm_ch3_cmp1</name>
          <description>Channel 3 compare value 1 register: Compare value 1 for channel 3. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000016C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[15:0]</bitRange>
              <description>value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mpwm_ch3_muxin_s': 0xFF802570-->
          <name>mpwm_ch3_muxin_s</name>
          <description>Channel 3 multiplexer input shadow register: Shadow register for channel 3 multiplexer input register. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000170</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000007</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:3]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ab</name>
              <bitRange>[2:2]</bitRange>
              <description>above </description>
            </field>
            <field>
              <name>bt</name>
              <bitRange>[1:1]</bitRange>
              <description>between </description>
            </field>
            <field>
              <name>bl</name>
              <bitRange>[0:0]</bitRange>
              <description>below </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mpwm_ch3_muxin': 0xFF802574-->
          <name>mpwm_ch3_muxin</name>
          <description>Channel 3 multiplexer input register: This register is central in determining the direct PWM output value of channel 3. When   (CHX_CMP0 $&gt;=$ CNT) and (CHX_CMP1 $&gt;=$ CNT), the direct PWM output signal is equal to   CHX_MUXIN.bl (counter value is below both compare values). When (CHX_CMP0 $&gt;=$ CNT) xor   (CHX_CMP1 $&gt;=$ CNT) is true, then the direct PWM output signal is equal to CHX_MUXIN.bt   (counter value is between both compare values). When not (CHX_CMP0 $&gt;=$ CNT) and not   (CHX_CMP1 $&gt;=$ CNT), then the direct PWM output signal is equal to CHX_MUXIN.ab (counter   value is above both compare values). </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000174</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000007</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:3]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ab</name>
              <bitRange>[2:2]</bitRange>
              <description>above </description>
            </field>
            <field>
              <name>bt</name>
              <bitRange>[1:1]</bitRange>
              <description>between </description>
            </field>
            <field>
              <name>bl</name>
              <bitRange>[0:0]</bitRange>
              <description>below </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mpwm_ch4_cmp0_s': 0xFF802580-->
          <name>mpwm_ch4_cmp0_s</name>
          <description>Channel 4 compare value 0 shadow register: Compare value 0 shadow register for channel 4. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000180</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[15:0]</bitRange>
              <description>value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mpwm_ch4_cmp1_s': 0xFF802584-->
          <name>mpwm_ch4_cmp1_s</name>
          <description>Channel 4 compare value 1 shadow register: Compare value 1 shadow register for channel 4. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000184</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[15:0]</bitRange>
              <description>value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mpwm_ch4_cmp0': 0xFF802588-->
          <name>mpwm_ch4_cmp0</name>
          <description>Channel 4 compare value 0 register: Compare value 0 for channel 4. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000188</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[15:0]</bitRange>
              <description>value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mpwm_ch4_cmp1': 0xFF80258C-->
          <name>mpwm_ch4_cmp1</name>
          <description>Channel 4 compare value 1 register: Compare value 1 for channel 4. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000018C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[15:0]</bitRange>
              <description>value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mpwm_ch4_muxin_s': 0xFF802590-->
          <name>mpwm_ch4_muxin_s</name>
          <description>Channel 4 multiplexer input shadow register: Shadow register for channel 4 multiplexer input register. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000190</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000007</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:3]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ab</name>
              <bitRange>[2:2]</bitRange>
              <description>above </description>
            </field>
            <field>
              <name>bt</name>
              <bitRange>[1:1]</bitRange>
              <description>between </description>
            </field>
            <field>
              <name>bl</name>
              <bitRange>[0:0]</bitRange>
              <description>below </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mpwm_ch4_muxin': 0xFF802594-->
          <name>mpwm_ch4_muxin</name>
          <description>Channel 4 multiplexer input register: This register is central in determining the direct PWM output value of channel 4. When   (CHX_CMP0 $&gt;=$ CNT) and (CHX_CMP1 $&gt;=$ CNT), the direct PWM output signal is equal to   CHX_MUXIN.bl (counter value is below both compare values). When (CHX_CMP0 $&gt;=$ CNT) xor   (CHX_CMP1 $&gt;=$ CNT) is true, then the direct PWM output signal is equal to CHX_MUXIN.bt   (counter value is between both compare values). When not (CHX_CMP0 $&gt;=$ CNT) and not   (CHX_CMP1 $&gt;=$ CNT), then the direct PWM output signal is equal to CHX_MUXIN.ab (counter   value is above both compare values). </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000194</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000007</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:3]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ab</name>
              <bitRange>[2:2]</bitRange>
              <description>above </description>
            </field>
            <field>
              <name>bt</name>
              <bitRange>[1:1]</bitRange>
              <description>between </description>
            </field>
            <field>
              <name>bl</name>
              <bitRange>[0:0]</bitRange>
              <description>below </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mpwm_ch5_cmp0_s': 0xFF8025A0-->
          <name>mpwm_ch5_cmp0_s</name>
          <description>Channel 5 compare value 0 shadow register: Compare value 0 shadow register for channel 5. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000001A0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[15:0]</bitRange>
              <description>value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mpwm_ch5_cmp1_s': 0xFF8025A4-->
          <name>mpwm_ch5_cmp1_s</name>
          <description>Channel 5 compare value 1 shadow register: Compare value 1 shadow register for channel 5. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000001A4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[15:0]</bitRange>
              <description>value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mpwm_ch5_cmp0': 0xFF8025A8-->
          <name>mpwm_ch5_cmp0</name>
          <description>Channel 5 compare value 0 register: Compare value 0 for channel 5. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000001A8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[15:0]</bitRange>
              <description>value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mpwm_ch5_cmp1': 0xFF8025AC-->
          <name>mpwm_ch5_cmp1</name>
          <description>Channel 5 compare value 1 register: Compare value 1 for channel 5. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000001AC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[15:0]</bitRange>
              <description>value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mpwm_ch5_muxin_s': 0xFF8025B0-->
          <name>mpwm_ch5_muxin_s</name>
          <description>Channel 5 multiplexer input shadow register: Shadow register for channel 5 multiplexer input register. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000001B0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000007</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:3]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ab</name>
              <bitRange>[2:2]</bitRange>
              <description>above </description>
            </field>
            <field>
              <name>bt</name>
              <bitRange>[1:1]</bitRange>
              <description>between </description>
            </field>
            <field>
              <name>bl</name>
              <bitRange>[0:0]</bitRange>
              <description>below </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mpwm_ch5_muxin': 0xFF8025B4-->
          <name>mpwm_ch5_muxin</name>
          <description>Channel 5 multiplexer input register: This register is central in determining the direct PWM output value of channel 5. When   (CHX_CMP0 $&gt;=$ CNT) and (CHX_CMP1 $&gt;=$ CNT), the direct PWM output signal is equal to   CHX_MUXIN.bl (counter value is below both compare values). When (CHX_CMP0 $&gt;=$ CNT) xor   (CHX_CMP1 $&gt;=$ CNT) is true, then the direct PWM output signal is equal to CHX_MUXIN.bt   (counter value is between both compare values). When not (CHX_CMP0 $&gt;=$ CNT) and not   (CHX_CMP1 $&gt;=$ CNT), then the direct PWM output signal is equal to CHX_MUXIN.ab (counter   value is above both compare values). </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000001B4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000007</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:3]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ab</name>
              <bitRange>[2:2]</bitRange>
              <description>above </description>
            </field>
            <field>
              <name>bt</name>
              <bitRange>[1:1]</bitRange>
              <description>between </description>
            </field>
            <field>
              <name>bl</name>
              <bitRange>[0:0]</bitRange>
              <description>below </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mpwm_irq_raw': 0xFF8025C0-->
          <name>mpwm_irq_raw</name>
          <description>Raw IRQ: Read access shows status of unmasked IRQs.   IRQs are set automatically and reset by writing to this register: Write access with '1' resets the appropriate IRQ (if event irq, reset status irqs at their source). Write access with '0' does not influence this bit. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000001C0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000007FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:11]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>oede</name>
              <bitRange>[10:5]</bitRange>
              <description>event: output section edge detector </description>
            </field>
            <field>
              <name>eci_ks_state</name>
              <bitRange>[4:4]</bitRange>
              <description>status: error condition kill switch state bit </description>
            </field>
            <field>
              <name>eci_val</name>
              <bitRange>[3:3]</bitRange>
              <description>status: eci_val error condition input value bit after filter </description>
            </field>
            <field>
              <name>mop</name>
              <bitRange>[2:2]</bitRange>
              <description>event: middle of PWM period bit </description>
            </field>
            <field>
              <name>bop</name>
              <bitRange>[1:1]</bitRange>
              <description>event: beginning of PWM period bit </description>
            </field>
            <field>
              <name>ecz</name>
              <bitRange>[0:0]</bitRange>
              <description>event: evt_counter reached zero bit </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mpwm_irq_masked': 0xFF8025C4-->
          <name>mpwm_irq_masked</name>
          <description>Masked IRQ: Shows status of masked IRQs (as connected to ARM/xPIC). </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000001C4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000007FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:11]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>oede</name>
              <bitRange>[10:5]</bitRange>
              <description>event: output section edge detector </description>
            </field>
            <field>
              <name>eci_ks_state</name>
              <bitRange>[4:4]</bitRange>
              <description>status: error condition kill switch state bit </description>
            </field>
            <field>
              <name>eci_val</name>
              <bitRange>[3:3]</bitRange>
              <description>status: eci_val error condition input value bit after filter </description>
            </field>
            <field>
              <name>mop</name>
              <bitRange>[2:2]</bitRange>
              <description>event: middle of PWM period bit </description>
            </field>
            <field>
              <name>bop</name>
              <bitRange>[1:1]</bitRange>
              <description>event: beginning of PWM period bit </description>
            </field>
            <field>
              <name>ecz</name>
              <bitRange>[0:0]</bitRange>
              <description>event: evt_counter reached zero bit </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mpwm_irq_msk_set': 0xFF8025C8-->
          <name>mpwm_irq_msk_set</name>
          <description>IRQ enable mask: The IRQ mask enables interrupt requests for corresponding interrupt sources.   As its bits might be changed by different software tasks,   the IRQ mask register is not writable directly, but by set and reset masks: Write access with '1' sets interrupt mask bit. Write access with '0' does not influence this bit. Read access shows actual interrupt mask. Attention: Before activating interrupt mask, delete old pending interrupts by writing the same value to adr_mpwm_irq_raw. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000001C8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000007FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:11]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>oede</name>
              <bitRange>[10:5]</bitRange>
              <description>event: output section edge detector </description>
            </field>
            <field>
              <name>eci_ks_state</name>
              <bitRange>[4:4]</bitRange>
              <description>status: error condition kill switch state bit </description>
            </field>
            <field>
              <name>eci_val</name>
              <bitRange>[3:3]</bitRange>
              <description>status: eci_val error condition input value bit after filter </description>
            </field>
            <field>
              <name>mop</name>
              <bitRange>[2:2]</bitRange>
              <description>event: middle of PWM period bit </description>
            </field>
            <field>
              <name>bop</name>
              <bitRange>[1:1]</bitRange>
              <description>event: beginning of PWM period bit </description>
            </field>
            <field>
              <name>ecz</name>
              <bitRange>[0:0]</bitRange>
              <description>event: evt_counter reached zero bit </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mpwm_irq_msk_reset': 0xFF8025CC-->
          <name>mpwm_irq_msk_reset</name>
          <description>IRQ disable mask: This is the corresponding reset mask to disable interrupt requests for corresponding interrupt sources: Write access with '1' resets interrupt mask bit. Write access with '0' does not influence this bit. Read access is undefined </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000001CC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000007FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:11]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>oede</name>
              <bitRange>[10:5]</bitRange>
              <description>event: output section edge detector </description>
            </field>
            <field>
              <name>eci_ks_state</name>
              <bitRange>[4:4]</bitRange>
              <description>status: error condition kill switch state bit </description>
            </field>
            <field>
              <name>eci_val</name>
              <bitRange>[3:3]</bitRange>
              <description>status: eci_val error condition input value bit after filter </description>
            </field>
            <field>
              <name>mop</name>
              <bitRange>[2:2]</bitRange>
              <description>event: middle of PWM period bit </description>
            </field>
            <field>
              <name>bop</name>
              <bitRange>[1:1]</bitRange>
              <description>event: beginning of PWM period bit </description>
            </field>
            <field>
              <name>ecz</name>
              <bitRange>[0:0]</bitRange>
              <description>event: evt_counter reached zero bit </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'mpwm_irq_no': 0xFF8025D0-->
          <name>mpwm_irq_no</name>
          <description>IRQ number: This shows the bit number of the lowest active bit in IRQ_MASKED or MAX+1 when no bit is set. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x000001D0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[3:0]</bitRange>
              <description>lowest active IRQ number </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>xpic_app_regs</name>
      <description>xpic_app_regs</description>
      <baseAddress>0xFF884000</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>128</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <!--Absolute address of 'xpic_r0': 0xFF884000-->
          <name>xpic_r0</name>
          <description>xPIC work register for indirect addressing </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>r0</name>
              <bitRange>[31:0]</bitRange>
              <description>Work Register 0 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_r1': 0xFF884004-->
          <name>xpic_r1</name>
          <description>xPIC work register for indirect addressing </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>r1</name>
              <bitRange>[31:0]</bitRange>
              <description>Work Register 1 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_r2': 0xFF884008-->
          <name>xpic_r2</name>
          <description>xPIC work register for indirect addressing </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>r2</name>
              <bitRange>[31:0]</bitRange>
              <description>Work Register 2 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_r3': 0xFF88400C-->
          <name>xpic_r3</name>
          <description>xPIC work register for indirect addressing </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>r3</name>
              <bitRange>[31:0]</bitRange>
              <description>Work Register 3 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_r4': 0xFF884010-->
          <name>xpic_r4</name>
          <description>xPIC work register for indirect addressing </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>r4</name>
              <bitRange>[31:0]</bitRange>
              <description>Work Register 4 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_r5': 0xFF884014-->
          <name>xpic_r5</name>
          <description>xPIC work register for indirect addressing </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>r5</name>
              <bitRange>[31:0]</bitRange>
              <description>Work Register 5 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_r6': 0xFF884018-->
          <name>xpic_r6</name>
          <description>xPIC work register for indirect addressing </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000018</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>r6</name>
              <bitRange>[31:0]</bitRange>
              <description>Work Register 6 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_r7': 0xFF88401C-->
          <name>xpic_r7</name>
          <description>xPIC work register for indirect addressing </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000001C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>r7</name>
              <bitRange>[31:0]</bitRange>
              <description>Work Register 7 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_usr0': 0xFF884020-->
          <name>xpic_usr0</name>
          <description>xPIC user Register additional work register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>usr0</name>
              <bitRange>[31:0]</bitRange>
              <description>User Register 0 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_usr1': 0xFF884024-->
          <name>xpic_usr1</name>
          <description>xPIC user Register additional work register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000024</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>usr1</name>
              <bitRange>[31:0]</bitRange>
              <description>User Register 1 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_usr2': 0xFF884028-->
          <name>xpic_usr2</name>
          <description>xPIC user Register additional work register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000028</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>usr2</name>
              <bitRange>[31:0]</bitRange>
              <description>User Register 2 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_usr3': 0xFF88402C-->
          <name>xpic_usr3</name>
          <description>xPIC user Register additional work register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000002C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>usr3</name>
              <bitRange>[31:0]</bitRange>
              <description>User Register 3 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_usr4': 0xFF884030-->
          <name>xpic_usr4</name>
          <description>xPIC user Register additional work register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000030</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>usr4</name>
              <bitRange>[31:0]</bitRange>
              <description>User Register 4 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_pc': 0xFF884034-->
          <name>xpic_pc</name>
          <description>xPIC Program Counter Shared in xPIC 64_BIT_MUL_TARGET mode with usr32 (w mode) </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000034</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFC</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>pc</name>
              <bitRange>[31:0]</bitRange>
              <description>Program Counter (dword address inside DPRAM) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_stat': 0xFF884038-->
          <name>xpic_stat</name>
          <description>Processor Status Register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000038</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>stat</name>
              <bitRange>[31:0]</bitRange>
              <description>no field descpription</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_zero': 0xFF88403C-->
          <name>xpic_zero</name>
          <description>Zero Register Shared in xPIC 64_BIT_MUL_TARGET mode with usr10 (w mode) </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000003C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>zero</name>
              <bitRange>[31:0]</bitRange>
              <description>Always Zero </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>xpic_app_debug</name>
      <description>xpic_app_debug</description>
      <baseAddress>0xFF884080</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>128</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>xpic_debug_app</name>
        <value>12</value>
      </interrupt>
      <interrupt>
        <name>wdg_xpic_app_arm</name>
        <value>13</value>
      </interrupt>
      <registers>
        <register>
          <!--Absolute address of 'xpic_hold_pc': 0xFF884080-->
          <name>xpic_hold_pc</name>
          <description>no Register description</description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>reset_xpic</name>
              <bitRange>[7:7]</bitRange>
              <description>REQUEST reset all internal internal states and the pipeline EXCEPT: the internal register (r0-r7, usr0-4), bank0 and bank1 reset this registers manually EXCEPT: xpic hard_breaker/debug registers 1 - xPIC reset request </description>
            </field>
            <field>
              <name>bank_control</name>
              <bitRange>[6:6]</bitRange>
              <description>control over the register bank selection WARNING: reset this BIT to 0 BEFORE start xPIC (clear hold bits) </description>
            </field>
            <field>
              <name>bank_select</name>
              <bitRange>[5:5]</bitRange>
              <description>Select register bank (0: default bank, 1: fiq bank) Access registers in xpic_regs area (xpic_r0 .. xpic_r7, xpic_stat) </description>
            </field>
            <field>
              <name>misalignment_hold</name>
              <bitRange>[4:4]</bitRange>
              <description>0: xPIC triggers misalignment_irq on misaligned memory accesses but does not stop. 1: xPIC stops after a misaligned memory accesses and triggers misalignment_irq. Write '1' into xpic_break_irq_raw.misalignment_irq to continue. </description>
            </field>
            <field>
              <name>disable_int</name>
              <bitRange>[3:3]</bitRange>
              <description>disable interrupts </description>
            </field>
            <field>
              <name>monitor_mode</name>
              <bitRange>[2:2]</bitRange>
              <description>0: xPIC stops when hardware breakpoint is triggered. Write '1' into xpic_break_irq_raw.break0_irq or break1_irq to continue. 1: Hardware breakpoints still generate irqs but do not stop the xPIC. </description>
            </field>
            <field>
              <name>single_step</name>
              <bitRange>[1:1]</bitRange>
              <description>0: Disable single step mode 1: xPIC processes a single pipeline step then stops and triggers the single_step_irq. Write '1' into xpic_break_irq_raw.single_step_irq to continue. </description>
            </field>
            <field>
              <name>hold</name>
              <bitRange>[0:0]</bitRange>
              <description>0: Start xPIC 1: Hold xPIC </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_break0_addr': 0xFF884084-->
          <name>xpic_break0_addr</name>
          <description>no Register description</description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Breakpoint 0 address value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_break0_addr_mask': 0xFF884088-->
          <name>xpic_break0_addr_mask</name>
          <description>no Register description</description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Breakpoint 0 address mask </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_break0_data': 0xFF88408C-->
          <name>xpic_break0_data</name>
          <description>no Register description</description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Breakpoint 0 data value   (for data access only) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_break0_data_mask': 0xFF884090-->
          <name>xpic_break0_data_mask</name>
          <description>no Register description</description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Breakpoint 0 data mask    (for data access only) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_break0_contr': 0xFF884094-->
          <name>xpic_break0_contr</name>
          <description>no Register description</description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000001FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:9]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>enable</name>
              <bitRange>[8:8]</bitRange>
              <description>Breakpoint 0 </description>
            </field>
            <field>
              <name>range</name>
              <bitRange>[7:7]</bitRange>
              <description>Breakpoint 0 input from Breakpoint 1 </description>
            </field>
            <field>
              <name>chain</name>
              <bitRange>[6:6]</bitRange>
              <description>Breakpoint 0 input from Breakpoint 1 </description>
            </field>
            <field>
              <name>irq_mode</name>
              <bitRange>[5:5]</bitRange>
              <description>Breakpoint 0  xPIC in IRQ Mode </description>
            </field>
            <field>
              <name>fiq_mode</name>
              <bitRange>[4:4]</bitRange>
              <description>Breakpoint 0  xPIC in FIQ Mode </description>
            </field>
            <field>
              <name>data_access</name>
              <bitRange>[3:3]</bitRange>
              <description>Breakpoint 0  (1: data access, 0: instruction fetch) </description>
            </field>
            <field>
              <name>mas</name>
              <bitRange>[2:1]</bitRange>
              <description>Breakpoint 0  memory access size (00: byte. 01: word, 10 dword, 11 reserved) </description>
            </field>
            <field>
              <name>write</name>
              <bitRange>[0:0]</bitRange>
              <description>Breakpoint 0  write/read access </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_break0_contr_mask': 0xFF884098-->
          <name>xpic_break0_contr_mask</name>
          <description>no Register description</description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000018</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[7:0]</bitRange>
              <description>Breakpoint 0 control mask </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_break1_addr': 0xFF88409C-->
          <name>xpic_break1_addr</name>
          <description>no Register description</description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000001C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Breakpoint 1 address value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_break1_addr_mask': 0xFF8840A0-->
          <name>xpic_break1_addr_mask</name>
          <description>no Register description</description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Breakpoint 1 address mask </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_break1_data': 0xFF8840A4-->
          <name>xpic_break1_data</name>
          <description>no Register description</description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000024</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Breakpoint 1 data value   (for data access only) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_break1_data_mask': 0xFF8840A8-->
          <name>xpic_break1_data_mask</name>
          <description>no Register description</description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000028</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Breakpoint 1 data mask   (for data access only) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_break1_contr': 0xFF8840AC-->
          <name>xpic_break1_contr</name>
          <description>no Register description</description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000002C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000001FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:9]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>enable</name>
              <bitRange>[8:8]</bitRange>
              <description>Breakpoint 1 </description>
            </field>
            <field>
              <name>range</name>
              <bitRange>[7:7]</bitRange>
              <description>reserved value</description>
            </field>
            <field>
              <name>chain</name>
              <bitRange>[6:6]</bitRange>
              <description>reserved value</description>
            </field>
            <field>
              <name>irq_mode</name>
              <bitRange>[5:5]</bitRange>
              <description>Breakpoint 1  xPIC in IRQ Mode </description>
            </field>
            <field>
              <name>fiq_mode</name>
              <bitRange>[4:4]</bitRange>
              <description>Breakpoint 1  xPIC in FIQ Mode </description>
            </field>
            <field>
              <name>data_access</name>
              <bitRange>[3:3]</bitRange>
              <description>Breakpoint 1  (1: data access, 0: instruction fetch) </description>
            </field>
            <field>
              <name>mas</name>
              <bitRange>[2:1]</bitRange>
              <description>Breakpoint 1  memory access size (00: byte. 01: word, 10 dword, 11 reserved) </description>
            </field>
            <field>
              <name>write</name>
              <bitRange>[0:0]</bitRange>
              <description>Breakpoint 1  write/read access </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_break1_contr_mask': 0xFF8840B0-->
          <name>xpic_break1_contr_mask</name>
          <description>no Register description</description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000030</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[7:0]</bitRange>
              <description>Breakpoint 1 control mask </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_break_last_pc': 0xFF8840B4-->
          <name>xpic_break_last_pc</name>
          <description>no Register description</description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000034</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>last PC </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_break_status': 0xFF8840B8-->
          <name>xpic_break_status</name>
          <description>Read access shows the reason why xPIC is in HOLD / BREAK </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000038</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000003FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:10]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>xpic_reset_status</name>
              <bitRange>[9:9]</bitRange>
              <description>1 = XPIC ist in Reset(read only) </description>
            </field>
            <field>
              <name>break1_read_data</name>
              <bitRange>[8:8]</bitRange>
              <description>Breakpoint 1 last load access (read only) </description>
            </field>
            <field>
              <name>break0_read_data</name>
              <bitRange>[7:7]</bitRange>
              <description>Breakpoint 0 last load access (read only) </description>
            </field>
            <field>
              <name>data_misalignment</name>
              <bitRange>[6:6]</bitRange>
              <description>Data Misaligment is active(read only) </description>
            </field>
            <field>
              <name>single_step</name>
              <bitRange>[5:5]</bitRange>
              <description>Single Step Break is active(read only) </description>
            </field>
            <field>
              <name>soft_break</name>
              <bitRange>[4:4]</bitRange>
              <description>Software Break is active(read only) </description>
            </field>
            <field>
              <name>break1</name>
              <bitRange>[3:3]</bitRange>
              <description>Breakpoint 1 is active(read only) </description>
            </field>
            <field>
              <name>break0</name>
              <bitRange>[2:2]</bitRange>
              <description>Breakpoint 0 is active(read only) </description>
            </field>
            <field>
              <name>hold</name>
              <bitRange>[1:1]</bitRange>
              <description>global HOLD BIT status 0- start xPIC, 1- hold xPIC (read only) </description>
            </field>
            <field>
              <name>xpic_in_hold</name>
              <bitRange>[0:0]</bitRange>
              <description>xPIC is in Break or Hold (read only) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_break_irq_raw': 0xFF8840BC-->
          <name>xpic_break_irq_raw</name>
          <description>xPIC_DEBUG Raw IRQ register: Read access shows status of unmasked IRQs.   IRQs are set automatically and reset by writing to this register: Write access with '1' resets the appropriate IRQ. Write access with '0' does not influence this bit. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000003C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000001F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>misalignment_irq</name>
              <bitRange>[4:4]</bitRange>
              <description>Data Misalignment Error Interrupt </description>
            </field>
            <field>
              <name>single_step_irq</name>
              <bitRange>[3:3]</bitRange>
              <description>single step Breakpoint Interrupt </description>
            </field>
            <field>
              <name>soft_break_irq</name>
              <bitRange>[2:2]</bitRange>
              <description>Software Breakpoint Interrupt </description>
            </field>
            <field>
              <name>break1_irq</name>
              <bitRange>[1:1]</bitRange>
              <description>Breakpoint 1 Interrupt </description>
            </field>
            <field>
              <name>break0_irq</name>
              <bitRange>[0:0]</bitRange>
              <description>Breakpoint 0 Interrupt </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_break_irq_masked': 0xFF8840C0-->
          <name>xpic_break_irq_masked</name>
          <description>xPIC_DEBUG Masked IRQ register for other CPU (ARM): Shows status of masked IRQs (as connected to ARM) </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000040</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000001F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>misalignment_irq</name>
              <bitRange>[4:4]</bitRange>
              <description>Data Misalignment Error Interrupt </description>
            </field>
            <field>
              <name>single_step_irq</name>
              <bitRange>[3:3]</bitRange>
              <description>single step Breakpoint Interrupt </description>
            </field>
            <field>
              <name>soft_break_irq</name>
              <bitRange>[2:2]</bitRange>
              <description>Software Breakpoint Interrupt </description>
            </field>
            <field>
              <name>break1_irq</name>
              <bitRange>[1:1]</bitRange>
              <description>Breakpoint 1 Interrupt </description>
            </field>
            <field>
              <name>break0_irq</name>
              <bitRange>[0:0]</bitRange>
              <description>Breakpoint 0 Interrupt </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_break_irq_msk_set': 0xFF8840C4-->
          <name>xpic_break_irq_msk_set</name>
          <description>xPIC_DEBUG interrupt mask set for other CPU (ARM): The IRQ mask enables interrupt requests for corresponding interrupt sources.   As its bits might be changed by different software tasks,   the IRQ mask register is not writable directly, but by set and reset masks: Write access with '1' sets interrupt mask bit (enables interrupt request for corresponding interrupt source). Write access with '0' does not influence this bit. Read access shows actual interrupt mask. Attention: Before activating interrupt mask, delete old pending interrupts by writing the same value to xpic_break_irq_raw. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000044</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000001F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>misalignment_irq</name>
              <bitRange>[4:4]</bitRange>
              <description>Data Misalignment Error Interrupt </description>
            </field>
            <field>
              <name>single_step_irq</name>
              <bitRange>[3:3]</bitRange>
              <description>single step Breakpoint Interrupt </description>
            </field>
            <field>
              <name>soft_break_irq</name>
              <bitRange>[2:2]</bitRange>
              <description>Software Breakpoint Interrupt </description>
            </field>
            <field>
              <name>break1_irq</name>
              <bitRange>[1:1]</bitRange>
              <description>Breakpoint 1 Interrupt </description>
            </field>
            <field>
              <name>break0_irq</name>
              <bitRange>[0:0]</bitRange>
              <description>Breakpoint 0 Interrupt </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_break_irq_msk_reset': 0xFF8840C8-->
          <name>xpic_break_irq_msk_reset</name>
          <description>xPIC_DEBUG interrupt mask reset for other CPU (ARM): This is the corresponding reset mask to disable interrupt requests for corresponding interrupt sources: Write access with '1' resets interrupt mask bit (disables interrupt request for corresponding interrupt source). Write access with '0' does not influence this bit. Read access shows actual interrupt mask. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000048</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000001F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>misalignment_irq</name>
              <bitRange>[4:4]</bitRange>
              <description>Data Misalignment Error Interrupt </description>
            </field>
            <field>
              <name>single_step_irq</name>
              <bitRange>[3:3]</bitRange>
              <description>single step Breakpoint Interrupt </description>
            </field>
            <field>
              <name>soft_break_irq</name>
              <bitRange>[2:2]</bitRange>
              <description>Software Breakpoint Interrupt </description>
            </field>
            <field>
              <name>break1_irq</name>
              <bitRange>[1:1]</bitRange>
              <description>Breakpoint 1 Interrupt </description>
            </field>
            <field>
              <name>break0_irq</name>
              <bitRange>[0:0]</bitRange>
              <description>Breakpoint 0 Interrupt </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_break_own_irq_masked': 0xFF8840CC-->
          <name>xpic_break_own_irq_masked</name>
          <description>xPIC_DEBUG own Masked IRQ register (for xPIC): Shows status of masked IRQs (as connected to xPIC) </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000004C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>misalignment_irq</name>
              <bitRange>[0:0]</bitRange>
              <description>Data Misalignment Error Interrupt </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_break_own_irq_msk_set': 0xFF8840D0-->
          <name>xpic_break_own_irq_msk_set</name>
          <description>xPIC_DEBUG own interrupt mask set (for xPIC): The IRQ mask enables interrupt requests for corresponding interrupt sources.   As its bits might be changed by different software tasks,   the IRQ mask register is not writable directly, but by set and reset masks: Write access with '1' sets interrupt mask bit (enables interrupt request for corresponding interrupt source). Write access with '0' does not influence this bit. Read access shows actual interrupt mask. Attention: Before activating interrupt mask, delete old pending interrupts by writing the same value to xpic_break_irq_raw. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000050</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>misalignment_irq</name>
              <bitRange>[0:0]</bitRange>
              <description>Data Misalignment Error Interrupt </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_break_own_irq_msk_reset': 0xFF8840D4-->
          <name>xpic_break_own_irq_msk_reset</name>
          <description>xPIC_DEBUG own interrupt mask reset (for XPIC): This is the corresponding reset mask to disable interrupt requests for corresponding interrupt sources: Write access with '1' resets interrupt mask bit (disables interrupt request for corresponding interrupt source). Write access with '0' does not influence this bit. Read access shows actual interrupt mask. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000054</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>misalignment_irq</name>
              <bitRange>[0:0]</bitRange>
              <description>Data Misalignment Error Interrupt </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_break_return_fiq_pc': 0xFF8840D8-->
          <name>xpic_break_return_fiq_pc</name>
          <description>xPIC_DEBUG information FIQ return PC value valid if xPIC is in FIQ </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000058</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>xPIC FIQ return value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_break_return_irq_pc': 0xFF8840DC-->
          <name>xpic_break_return_irq_pc</name>
          <description>xPIC_DEBUG information last IRQ return PC value valid if xPIC is in IRQ </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000005C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>xPIC last IRQ return value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_irq_status': 0xFF8840E0-->
          <name>xpic_irq_status</name>
          <description>Read access shows the xpic irq status and the xpic irq enable bits </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000060</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>fiq_enable</name>
              <bitRange>[3:3]</bitRange>
              <description>FIQ enable bit </description>
            </field>
            <field>
              <name>irq_enable</name>
              <bitRange>[2:2]</bitRange>
              <description>IRQ enable bit </description>
            </field>
            <field>
              <name>fiq_status</name>
              <bitRange>[1:1]</bitRange>
              <description>FIQ status </description>
            </field>
            <field>
              <name>irq_status</name>
              <bitRange>[0:0]</bitRange>
              <description>IRQ status </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>vic_xpic_app</name>
      <description>vic_xpic_app</description>
      <baseAddress>0xFF900000</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>256</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <!--Absolute address of 'xpic_vic_config': 0xFF900000-->
          <name>xpic_vic_config</name>
          <description>XPIC VIC Configuration register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:2]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>table</name>
              <bitRange>[1:1]</bitRange>
              <description>use far or near Table 0 = Base Pointer Addr for IRQ Jmp Table + (n*4) DWORD Table 1 = Base Pointer Addr for IRQ Jmp Table + (n*16) 4 DWORD Table n = IRQ vector number </description>
            </field>
            <field>
              <name>enable</name>
              <bitRange>[0:0]</bitRange>
              <description>global enable of xPIC VIC (0: disable/ 1: enable) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_vic_raw_intr0': 0xFF900004-->
          <name>xpic_vic_raw_intr0</name>
          <description>XPIC VIC Raw0 interrupt status register see netx4000_irq doc </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>irqs</name>
              <bitRange>[31:0]</bitRange>
              <description>see netx doc </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_vic_raw_intr1': 0xFF900008-->
          <name>xpic_vic_raw_intr1</name>
          <description>XPIC VIC Raw1 interrupt status register see netx4000_irq doc </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>irqs</name>
              <bitRange>[31:0]</bitRange>
              <description>see netx doc </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_vic_raw_intr2': 0xFF90000C-->
          <name>xpic_vic_raw_intr2</name>
          <description>XPIC VIC Raw2 interrupt status register see netx4000_irq doc </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>irqs</name>
              <bitRange>[31:0]</bitRange>
              <description>see netx doc </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_vic_softint0_set': 0xFF900010-->
          <name>xpic_vic_softint0_set</name>
          <description>XPIC VIC Software0 interrupt set register: Read status or set IRQ by writing '1' to the appropriate bit. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>irqs</name>
              <bitRange>[31:0]</bitRange>
              <description>see netx doc </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_vic_softint1_set': 0xFF900014-->
          <name>xpic_vic_softint1_set</name>
          <description>XPIC VIC Software1 interrupt set register: Read status or set IRQ by writing '1' to the appropriate bit. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>irqs</name>
              <bitRange>[31:0]</bitRange>
              <description>see netx doc </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_vic_softint2_set': 0xFF900018-->
          <name>xpic_vic_softint2_set</name>
          <description>XPIC VIC Software2 interrupt set register: Read status or set IRQ by writing '1' to the appropriate bit. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000018</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>irqs</name>
              <bitRange>[31:0]</bitRange>
              <description>see netx doc </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_vic_softint0_reset': 0xFF90001C-->
          <name>xpic_vic_softint0_reset</name>
          <description>XPIC VIC Software0 interrupt reset register: Read status or reset IRQ by writing '1' to the appropriate bit. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000001C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>irqs</name>
              <bitRange>[31:0]</bitRange>
              <description>see netx doc </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_vic_softint1_reset': 0xFF900020-->
          <name>xpic_vic_softint1_reset</name>
          <description>XPIC VIC Software1 interrupt reset register: Read status or reset IRQ by writing '1' to the appropriate bit. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>irqs</name>
              <bitRange>[31:0]</bitRange>
              <description>see netx doc </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_vic_softint2_reset': 0xFF900024-->
          <name>xpic_vic_softint2_reset</name>
          <description>XPIC VIC Software2 interrupt reset register: Read status or reset IRQ by writing '1' to the appropriate bit. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000024</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>irqs</name>
              <bitRange>[31:0]</bitRange>
              <description>see netx doc </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_vic_fiq_addr': 0xFF900028-->
          <name>xpic_vic_fiq_addr</name>
          <description>XPIC VIC FIQ Vector address 0 register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000028</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>FIQ handler address </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_vic_irq_addr': 0xFF90002C-->
          <name>xpic_vic_irq_addr</name>
          <description>XPIC VIC normal IRQ address register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000002C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>IRQ handler address </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_vic_vector_addr': 0xFF900030-->
          <name>xpic_vic_vector_addr</name>
          <description>XPIC VIC IRQ Vector address </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000030</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>IRQ vector address read access get actuel highest prior IRQ read access get  adr_xpic_vic_table_base_addr + IRQ Number * (4/16) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_vic_table_base_addr': 0xFF900034-->
          <name>xpic_vic_table_base_addr</name>
          <description>XPIC VIC IRQ TABLE ADDRESS BASE POINTER </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000034</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>IRQ Table base address the Base Pointer Addr for IRQ Jmp Table </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_vic_fiq_vect_config': 0xFF900038-->
          <name>xpic_vic_fiq_vect_config</name>
          <description>no Register description</description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000038</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xC000007F</resetMask>
          <fields>
            <field>
              <name>enable</name>
              <bitRange>[31:31]</bitRange>
              <description>vector interrupt enable </description>
            </field>
            <field>
              <name>select_fiq_default</name>
              <bitRange>[30:30]</bitRange>
              <description>1 = select default vector for fiq (overwrite the int_source selection) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[29:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>int_source</name>
              <bitRange>[6:0]</bitRange>
              <description>INT_SOURCE 0-95 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_vic_vect_config0': 0xFF90003C-->
          <name>xpic_vic_vect_config0</name>
          <description>highest priority </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000003C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x8000007F</resetMask>
          <fields>
            <field>
              <name>enable</name>
              <bitRange>[31:31]</bitRange>
              <description>vector interrupt enable </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[30:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>int_source</name>
              <bitRange>[6:0]</bitRange>
              <description>INT_SOURCE 0-95 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_vic_vect_config1': 0xFF900040-->
          <name>xpic_vic_vect_config1</name>
          <description>no Register description</description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000040</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x8000007F</resetMask>
          <fields>
            <field>
              <name>enable</name>
              <bitRange>[31:31]</bitRange>
              <description>vector interrupt enable </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[30:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>int_source</name>
              <bitRange>[6:0]</bitRange>
              <description>INT_SOURCE 0-95 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_vic_vect_config2': 0xFF900044-->
          <name>xpic_vic_vect_config2</name>
          <description>no Register description</description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000044</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x8000007F</resetMask>
          <fields>
            <field>
              <name>enable</name>
              <bitRange>[31:31]</bitRange>
              <description>vector interrupt enable </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[30:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>int_source</name>
              <bitRange>[6:0]</bitRange>
              <description>INT_SOURCE 0-95 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_vic_vect_config3': 0xFF900048-->
          <name>xpic_vic_vect_config3</name>
          <description>no Register description</description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000048</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x8000007F</resetMask>
          <fields>
            <field>
              <name>enable</name>
              <bitRange>[31:31]</bitRange>
              <description>vector interrupt enable </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[30:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>int_source</name>
              <bitRange>[6:0]</bitRange>
              <description>INT_SOURCE 0-95 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_vic_vect_config4': 0xFF90004C-->
          <name>xpic_vic_vect_config4</name>
          <description>no Register description</description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000004C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x8000007F</resetMask>
          <fields>
            <field>
              <name>enable</name>
              <bitRange>[31:31]</bitRange>
              <description>vector interrupt enable </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[30:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>int_source</name>
              <bitRange>[6:0]</bitRange>
              <description>INT_SOURCE 0-95 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_vic_vect_config5': 0xFF900050-->
          <name>xpic_vic_vect_config5</name>
          <description>no Register description</description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000050</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x8000007F</resetMask>
          <fields>
            <field>
              <name>enable</name>
              <bitRange>[31:31]</bitRange>
              <description>vector interrupt enable </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[30:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>int_source</name>
              <bitRange>[6:0]</bitRange>
              <description>INT_SOURCE 0-95 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_vic_vect_config6': 0xFF900054-->
          <name>xpic_vic_vect_config6</name>
          <description>no Register description</description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000054</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x8000007F</resetMask>
          <fields>
            <field>
              <name>enable</name>
              <bitRange>[31:31]</bitRange>
              <description>vector interrupt enable </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[30:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>int_source</name>
              <bitRange>[6:0]</bitRange>
              <description>INT_SOURCE 0-95 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_vic_vect_config7': 0xFF900058-->
          <name>xpic_vic_vect_config7</name>
          <description>no Register description</description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000058</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x8000007F</resetMask>
          <fields>
            <field>
              <name>enable</name>
              <bitRange>[31:31]</bitRange>
              <description>vector interrupt enable </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[30:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>int_source</name>
              <bitRange>[6:0]</bitRange>
              <description>INT_SOURCE 0-95 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_vic_vect_config8': 0xFF90005C-->
          <name>xpic_vic_vect_config8</name>
          <description>no Register description</description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000005C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x8000007F</resetMask>
          <fields>
            <field>
              <name>enable</name>
              <bitRange>[31:31]</bitRange>
              <description>vector interrupt enable </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[30:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>int_source</name>
              <bitRange>[6:0]</bitRange>
              <description>INT_SOURCE 0-95 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_vic_vect_config9': 0xFF900060-->
          <name>xpic_vic_vect_config9</name>
          <description>no Register description</description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000060</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x8000007F</resetMask>
          <fields>
            <field>
              <name>enable</name>
              <bitRange>[31:31]</bitRange>
              <description>vector interrupt enable </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[30:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>int_source</name>
              <bitRange>[6:0]</bitRange>
              <description>INT_SOURCE 0-95 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_vic_vect_config10': 0xFF900064-->
          <name>xpic_vic_vect_config10</name>
          <description>no Register description</description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000064</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x8000007F</resetMask>
          <fields>
            <field>
              <name>enable</name>
              <bitRange>[31:31]</bitRange>
              <description>vector interrupt enable </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[30:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>int_source</name>
              <bitRange>[6:0]</bitRange>
              <description>INT_SOURCE 0-95 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_vic_vect_config11': 0xFF900068-->
          <name>xpic_vic_vect_config11</name>
          <description>no Register description</description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000068</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x8000007F</resetMask>
          <fields>
            <field>
              <name>enable</name>
              <bitRange>[31:31]</bitRange>
              <description>vector interrupt enable </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[30:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>int_source</name>
              <bitRange>[6:0]</bitRange>
              <description>INT_SOURCE 0-95 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_vic_vect_config12': 0xFF90006C-->
          <name>xpic_vic_vect_config12</name>
          <description>no Register description</description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000006C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x8000007F</resetMask>
          <fields>
            <field>
              <name>enable</name>
              <bitRange>[31:31]</bitRange>
              <description>vector interrupt enable </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[30:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>int_source</name>
              <bitRange>[6:0]</bitRange>
              <description>INT_SOURCE 0-95 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_vic_vect_config13': 0xFF900070-->
          <name>xpic_vic_vect_config13</name>
          <description>no Register description</description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000070</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x8000007F</resetMask>
          <fields>
            <field>
              <name>enable</name>
              <bitRange>[31:31]</bitRange>
              <description>vector interrupt enable </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[30:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>int_source</name>
              <bitRange>[6:0]</bitRange>
              <description>INT_SOURCE 0-95 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_vic_vect_config14': 0xFF900074-->
          <name>xpic_vic_vect_config14</name>
          <description>no Register description</description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000074</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x8000007F</resetMask>
          <fields>
            <field>
              <name>enable</name>
              <bitRange>[31:31]</bitRange>
              <description>vector interrupt enable </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[30:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>int_source</name>
              <bitRange>[6:0]</bitRange>
              <description>INT_SOURCE 0-95 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_vic_vect_config15': 0xFF900078-->
          <name>xpic_vic_vect_config15</name>
          <description>XPIC default interrupt vector, all interrupt sources (wired-OR) select with default interrupt vector register lowest priority </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000078</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>enable</name>
              <bitRange>[31:31]</bitRange>
              <description>vector interrupt enable </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[30:0]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_vic_default0': 0xFF90007C-->
          <name>xpic_vic_default0</name>
          <description>XPIC default interrupt vector select0 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000007C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>select int0 - int31 (wired-OR) 1-selected 0-not selected </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_vic_default1': 0xFF900080-->
          <name>xpic_vic_default1</name>
          <description>XPIC default interrupt vector select1 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000080</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>select int32 - int63 (wired-OR) 1-selected 0-not selected </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_vic_default2': 0xFF900084-->
          <name>xpic_vic_default2</name>
          <description>XPIC default interrupt vector select1 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000084</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>select int64 - int95 (wired-OR) 1-selected 0-not selected </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_vic_fiq_default0': 0xFF900088-->
          <name>xpic_vic_fiq_default0</name>
          <description>XPIC default interrupt vector select0 for fiq </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000088</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>select int0 - int31 (wired-OR) 1-selected 0-not selected </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_vic_fiq_default1': 0xFF90008C-->
          <name>xpic_vic_fiq_default1</name>
          <description>XPIC default interrupt vector select1 for fiq </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000008C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>select int32 - int63 (wired-OR) 1-selected 0-not selected </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_vic_fiq_default2': 0xFF900090-->
          <name>xpic_vic_fiq_default2</name>
          <description>XPIC default interrupt vector select1 for fiq </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000090</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>select int64 - int95 (wired-OR) 1-selected 0-not selected </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>timer_xpic_app</name>
      <description>timer_xpic_app</description>
      <baseAddress>0xFF900100</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>128</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <!--Absolute address of 'timer_config_timer[%s]': 0xFF900100-->
          <dim>3</dim>
          <dimIncrement>4</dimIncrement>
          <name>timer_config_timer[%s]</name>
          <description>ARM TIMER Config register0 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>systime_config</name>
              <bitRange>[3:2]</bitRange>
              <description>systime  for timer  (2'b00.. systime_com, 2'b01.. systime_com_uc, 2'b10.. systime_app) </description>
            </field>
            <field>
              <name>mode</name>
              <bitRange>[1:0]</bitRange>
              <description>Timer0 2'b00 : Timer stops at 0 2'b01 : Timer is preload with value from preload register at 0 2'b10 : Timer (value) compare with systime (once) 2'b11 : reserved </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'timer_preload_timer[%s]': 0xFF90010C-->
          <dim>3</dim>
          <dimIncrement>4</dimIncrement>
          <name>timer_preload_timer[%s]</name>
          <description>ARM TIMER Timer 0 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>preload value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'timer_timer[%s]': 0xFF900118-->
          <dim>3</dim>
          <dimIncrement>4</dimIncrement>
          <name>timer_timer[%s]</name>
          <description>ARM TIMER Timer 0 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000018</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>actual value of timer / systime compare value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'timer_systime_s': 0xFF900124-->
          <name>timer_systime_s</name>
          <description>ARM_TIMER upper SYSTIME register To allow consistent values of systime_s and systime_ns, lower bits of systime is latched to systime_ns, when systime_s is read. This register should be dedicated to accesses via ARM. xPIC software should access systime via xpic_timer_systime_s. Host software should access systime via DPM at systime_s. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000024</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Systime high: Sample systime_ns at read access to systime_s. Value is incremented, if systime_ns reaches systime_border. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'timer_systime_ns': 0xFF900128-->
          <name>timer_systime_ns</name>
          <description>ARM_TIMER lower SYSTIME register To allow consistent values of systime_s and systime_ns, lower bits of systime is latched to systime_ns, when systime_s is read. If no systime_s is read before (e.g. at 2nd read access of systime_ns), the actual value of systime_ns is read. This register should be dedicated to accesses via ARM. xPIC software should access systime via xpic_timer_systime_ns. Host software should access systime via DPM at systime_ns. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000028</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Systime low: Sample systime_ns at read access to systime_s. Without sample read systime_s, read the actual value of systime_ns. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'timer_compare_systime_s_value': 0xFF90012C-->
          <name>timer_compare_systime_s_value</name>
          <description>SYSTIME sec compare value </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000002C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Compare value with systime_s (seconds): Systime_s_compare_irq is set, if systime_s matches. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'timer_irq_raw': 0xFF900130-->
          <name>timer_irq_raw</name>
          <description>ARM_TIMER Raw IRQ register: Read access shows status of unmasked IRQs.   IRQs are set automatically and reset by writing to this register: Write access with '1' resets the appropriate IRQ. Write access with '0' does not influence this bit. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000030</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>systime_s_irq</name>
              <bitRange>[3:3]</bitRange>
              <description>Systime sec Interrupt </description>
            </field>
            <field>
              <name>timer2_irq</name>
              <bitRange>[2:2]</bitRange>
              <description>Timer 2 Interrupt </description>
            </field>
            <field>
              <name>timer1_irq</name>
              <bitRange>[1:1]</bitRange>
              <description>Timer 1 Interrupt </description>
            </field>
            <field>
              <name>timer0_irq</name>
              <bitRange>[0:0]</bitRange>
              <description>Timer 0 Interrupt </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'timer_irq_masked': 0xFF900134-->
          <name>timer_irq_masked</name>
          <description>ARM_TIMER Masked IRQ register: Shows status of masked IRQs (as connected to ARM/xPIC) </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000034</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>systime_s_irq</name>
              <bitRange>[3:3]</bitRange>
              <description>Systime sec Interrupt </description>
            </field>
            <field>
              <name>timer2_irq</name>
              <bitRange>[2:2]</bitRange>
              <description>Timer 2 Interrupt </description>
            </field>
            <field>
              <name>timer1_irq</name>
              <bitRange>[1:1]</bitRange>
              <description>Timer 1 Interrupt </description>
            </field>
            <field>
              <name>timer0_irq</name>
              <bitRange>[0:0]</bitRange>
              <description>Timer 0 Interrupt </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'timer_irq_msk_set': 0xFF900138-->
          <name>timer_irq_msk_set</name>
          <description>ARM_TIMER interrupt mask set: The IRQ mask enables interrupt requests for corresponding interrupt sources.   As its bits might be changed by different software tasks,   the IRQ mask register is not writable directly, but by set and reset masks: Write access with '1' sets interrupt mask bit (enables interrupt request for corresponding interrupt source). Write access with '0' does not influence this bit. Read access shows actual interrupt mask. Attention: Before activating interrupt mask, delete old pending interrupts by writing the same value to arm_timer_irq_raw. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000038</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>systime_s_irq</name>
              <bitRange>[3:3]</bitRange>
              <description>Systime sec Interrupt </description>
            </field>
            <field>
              <name>timer2_irq</name>
              <bitRange>[2:2]</bitRange>
              <description>Timer 2 Interrupt </description>
            </field>
            <field>
              <name>timer1_irq</name>
              <bitRange>[1:1]</bitRange>
              <description>Timer 1 Interrupt </description>
            </field>
            <field>
              <name>timer0_irq</name>
              <bitRange>[0:0]</bitRange>
              <description>Timer 0 Interrupt </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'timer_irq_msk_reset': 0xFF90013C-->
          <name>timer_irq_msk_reset</name>
          <description>ARM_TIMER interrupt mask reset: This is the corresponding reset mask to disable interrupt requests for corresponding interrupt sources: Write access with '1' resets interrupt mask bit (disables interrupt request for corresponding interrupt source). Write access with '0' does not influence this bit. Read access shows actual interrupt mask. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000003C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>systime_s_irq</name>
              <bitRange>[3:3]</bitRange>
              <description>Systime sec Interrupt </description>
            </field>
            <field>
              <name>timer2_irq</name>
              <bitRange>[2:2]</bitRange>
              <description>Timer 2 Interrupt </description>
            </field>
            <field>
              <name>timer1_irq</name>
              <bitRange>[1:1]</bitRange>
              <description>Timer 1 Interrupt </description>
            </field>
            <field>
              <name>timer0_irq</name>
              <bitRange>[0:0]</bitRange>
              <description>Timer 0 Interrupt </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'timer_systime_config': 0xFF900140-->
          <name>timer_systime_config</name>
          <description>Select systime  for arm_timer_systime_(ns)s functions </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000040</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:2]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>systime_config</name>
              <bitRange>[1:0]</bitRange>
              <description>systime  for timer (2'b00.. systime_com, 2'b01.. systime_com_uc, 2'b10.. systime_app) </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>wdg_xpic_app</name>
      <description>wdg_xpic_app</description>
      <baseAddress>0xFF900180</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>32</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <!--Absolute address of 'xpic_wdg_trig': 0xFF900180-->
          <name>xpic_wdg_trig</name>
          <description>netX xPIC Watchdog Trigger Register. The watchdog access code is generated by a pseudo random generator. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x910FFFFF</resetMask>
          <fields>
            <field>
              <name>write_enable</name>
              <bitRange>[31:31]</bitRange>
              <description>Write enable bit for timeout register: As long as this bit is not set all write accesses to the timeout register are ignored. </description>
            </field>
            <field>
              <name>bf_align2</name>
              <bitRange>[30:29]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>wdg_counter_trigger_w</name>
              <bitRange>[28:28]</bitRange>
              <description>Watchdog trigger bit: Bit must be set to trigger the watchdog counter. When read, this bit is always '0' </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[27:25]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>irq_req_watchdog</name>
              <bitRange>[24:24]</bitRange>
              <description>xPIC IRQ request of watchdog, writing 1 deletes IRQ to xPIC </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[23:20]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>wdg_access_code</name>
              <bitRange>[19:0]</bitRange>
              <description>Watchdog access code for triggering. A read access gives the next 16 bit code for trigger. A write access with correct access code will trigger the watchdog counter. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_wdg_counter': 0xFF900184-->
          <name>xpic_wdg_counter</name>
          <description>netX xPIC Watchdog Counter Register The counter value is decremented each 10000 system clock cycles. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0001FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:17]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[16:0]</bitRange>
              <description>Actual watchdog counter value: Bit 16 shows: 1: Watchdog is counting down from xpic_irq_timeout to 0 for xPIC-IRQ 0: Watchdog is counting down from arm_irq_timeout to 0 for ARM-IRQ </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_wdg_xpic_irq_timeout': 0xFF900188-->
          <name>xpic_wdg_xpic_irq_timeout</name>
          <description>netX xPIC Watchdog xPIC interrupt timout register: xpic_irq_timeout or arm_irq_timeout must be nonzero to enable watchdog </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[15:0]</bitRange>
              <description>Watchdog interrupt timeout The total xpic_irq timeout for a netX clock of 100MHz is: xpic_wdg_xpic_irq_timeout * 100us </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_wdg_arm_irq_timeout': 0xFF90018C-->
          <name>xpic_wdg_arm_irq_timeout</name>
          <description>netX xPIC Watchdog ARM interrupt timout register: xpic_irq_timeout or arm_irq_timeout must be nonzero to enable watchdog </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:16]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[15:0]</bitRange>
              <description>Watchdog ARM interrupt timeout The total arm_irq timeout for a netX clock of 100MHz is: (xpic_wdg_xpic_irq_timeout + xpic_wdg_arm_irq_timeout) * 100us </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_wdg_irq_raw': 0xFF900190-->
          <name>xpic_wdg_irq_raw</name>
          <description>Read access shows status of unmasked IRQs.   IRQs are set automatically and reset by writing to this register: Write access with '1' resets the appropriate IRQ. Write access with '0' does not influence this bit. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>wdg_arm_irq</name>
              <bitRange>[0:0]</bitRange>
              <description>Interrupt from xPIC Watchdog to ARM </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_wdg_irq_masked': 0xFF900194-->
          <name>xpic_wdg_irq_masked</name>
          <description>xpic_wdg Masked IRQ register: Shows status of masked IRQs (as connected to xPIC). </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000014</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>wdg_arm_irq</name>
              <bitRange>[0:0]</bitRange>
              <description>Interrupt from xPIC Watchdog to ARM </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_wdg_irq_msk_set': 0xFF900198-->
          <name>xpic_wdg_irq_msk_set</name>
          <description>xpic_wdg interrupt mask enable: The IRQ mask enables interrupt requests for corresponding interrupt sources.   As its bits might be changed by different software tasks,   the IRQ mask register is not writable directly, but by set and reset masks: Write access with '1' sets interrupt mask bit (enables interrupt request for corresponding interrupt source). Write access with '0' does not influence this bit. Read access shows actual interrupt mask. Attention: Before activating interrupt mask, delete old pending interrupts by writing the same value to wdg_irq_raw. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000018</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>wdg_arm_irq</name>
              <bitRange>[0:0]</bitRange>
              <description>Interrupt from xPIC Watchdog to ARM </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xpic_wdg_irq_msk_reset': 0xFF90019C-->
          <name>xpic_wdg_irq_msk_reset</name>
          <description>xpic_wdg interrupt mask disable: This is the corresponding reset mask to disable interrupt requests for corresponding interrupt sources: Write access with '1' resets interrupt mask bit (disables interrupt request for corresponding interrupt source). Write access with '0' does not influence this bit. Read access shows actual interrupt mask. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000001C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:1]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>wdg_arm_irq</name>
              <bitRange>[0:0]</bitRange>
              <description>Interrupt from xPIC Watchdog to ARM </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>mcp_xpic_app</name>
      <description>mcp_xpic_app</description>
      <baseAddress>0xFF9001A0</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>32</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <!--Absolute address of 'hs_irq_set_raw': 0xFF9001A0-->
          <name>hs_irq_set_raw</name>
          <description>read: hs_iq_reg value write: hs_iq_reg set bit(s) </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>hs_irq_set_bits</name>
              <bitRange>[31:0]</bitRange>
              <description>IRQs for Inter-CPU-Communication </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hs_irq_reset_raw': 0xFF9001A4-->
          <name>hs_irq_reset_raw</name>
          <description>read: hs_iq_reg value write: hs_iq_reg reset bit(s) </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>hs_irq_reset_bits</name>
              <bitRange>[31:0]</bitRange>
              <description>IRQs for Inter-CPU-Communication </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hs_irq_set_mask': 0xFF9001A8-->
          <name>hs_irq_set_mask</name>
          <description>read: mask value </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>hs_irq_set_mask</name>
              <bitRange>[31:0]</bitRange>
              <description>IRQs for Inter-CPU-Communication </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hs_irq_reset_mask': 0xFF9001AC-->
          <name>hs_irq_reset_mask</name>
          <description>read: mask value </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>hs_irq_reset_mask</name>
              <bitRange>[31:0]</bitRange>
              <description>reset IRQs for Inter-CPU-Communication </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'hs_irq_masked': 0xFF9001B0-->
          <name>hs_irq_masked</name>
          <description>read: hs_iq_reg masked value </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>hs_irq_masked</name>
              <bitRange>[31:0]</bitRange>
              <description>mask IRQs for Inter-CPU-Communication </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>systime_lt_xpic_app</name>
      <description>systime_lt_xpic_app</description>
      <baseAddress>0xFF9001C0</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>64</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <!--Absolute address of 'intlogic_lt_systime_com_ns': 0xFF9001C0-->
          <name>intlogic_lt_systime_com_ns</name>
          <description>systime_com_ns last latched value </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>systime_com_ns last latched value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'intlogic_lt_systime_com_s': 0xFF9001C4-->
          <name>intlogic_lt_systime_com_s</name>
          <description>systime_com_s last latched value </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>systime_com_s last latched value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'intlogic_lt_systime_com_uc_ns': 0xFF9001C8-->
          <name>intlogic_lt_systime_com_uc_ns</name>
          <description>systime_com_uc_ns last latched value </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>systime_com_uc_ns last latched value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'intlogic_lt_systime_com_uc_s': 0xFF9001CC-->
          <name>intlogic_lt_systime_com_uc_s</name>
          <description>systime_com_uc_s last latched value </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>systime_com_uc_s last latched value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'intlogic_lt_systime_app_ns': 0xFF9001D0-->
          <name>intlogic_lt_systime_app_ns</name>
          <description>systime_app_ns last latched value </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000010</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>systime_app_ns last latched value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'intlogic_lt_systime_app_s': 0xFF9001D4-->
          <name>intlogic_lt_systime_app_s</name>
          <description>systime_app_s last latched value </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000014</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>systime_app_s last latched value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'intlogic_lt_systimes_latch': 0xFF9001D8-->
          <name>intlogic_lt_systimes_latch</name>
          <description>latch systimes by writing 1'b1 to the assigned bit </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000018</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000003F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>systime_app_s</name>
              <bitRange>[5:5]</bitRange>
              <description>no field descpription</description>
            </field>
            <field>
              <name>systime_app_ns</name>
              <bitRange>[4:4]</bitRange>
              <description>no field descpription</description>
            </field>
            <field>
              <name>systime_com_uc_s</name>
              <bitRange>[3:3]</bitRange>
              <description>no field descpription</description>
            </field>
            <field>
              <name>systime_com_uc_ns</name>
              <bitRange>[2:2]</bitRange>
              <description>no field descpription</description>
            </field>
            <field>
              <name>systime_com_s</name>
              <bitRange>[1:1]</bitRange>
              <description>no field descpription</description>
            </field>
            <field>
              <name>systime_com_ns</name>
              <bitRange>[0:0]</bitRange>
              <description>no field descpription</description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>gpio_xpic_app</name>
      <description>gpio_xpic_app</description>
      <baseAddress>0xFF900200</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>256</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <!--Absolute address of 'gpio_app_cfg[%s]': 0xFF900200-->
          <dim>8</dim>
          <dimIncrement>4</dimIncrement>
          <name>gpio_app_cfg[%s]</name>
          <description>GPIO_APP pin 0 config register: This register is accessible via address areas inlogic_app and xpic_app_system. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00001FFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:13]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>blink_once</name>
              <bitRange>[12:12]</bitRange>
              <description>Run blink sequence only once (blink mode only) </description>
            </field>
            <field>
              <name>blink_len</name>
              <bitRange>[11:7]</bitRange>
              <description>Length of blink sequence minus 1 (blink mode only) 00000: use bit 0 of gpio_app_tc 00001: use bits 0..1 of gpio_app_tc 00010: use bits 0..2 of gpio_app_tc ... 11111: use bits 0..31 of gpio_app_tc </description>
            </field>
            <field>
              <name>count_ref</name>
              <bitRange>[6:5]</bitRange>
              <description>counter reference 00: counter 0 01: counter 1 10: counter 2 11: sys_time (global system time) </description>
            </field>
            <field>
              <name>inv</name>
              <bitRange>[4:4]</bitRange>
              <description>1: invert input/output value 0: do not invert input/output </description>
            </field>
            <field>
              <name>mode</name>
              <bitRange>[3:0]</bitRange>
              <description>defines the gp input or output mode - depends on io_cfg Input modes: 0000: read mode 0001: capture continued at rising edge (allows gpio_app_irq on each capture) 0010: capture once at rising edge (reset gpio_app_irq to capture again) 0011: capture once at high level (reset gpio_app_irq to capture again) Output modes: 0100: set to 0 0101: set to 1 0110: set to gpio_app_line[0] 0111: pwm mode, direct threshold update (might cause hazards on output) 1000: blink mode Multi pin modes: 1111: pwm2-mode with threshold update at counter=0 from gpio_app_tc[n+1] register (hazard-free) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'gpio_app_tc[%s]': 0xFF900220-->
          <dim>8</dim>
          <dimIncrement>4</dimIncrement>
          <name>gpio_app_tc[%s]</name>
          <description>GPIO_APP pin 0 threshold or capture register: This register is accessible via address areas inlogic_app and xpic_app_system. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Threshold/Capture register: PWM mode (threshold): { | The counter threshold value equals the number of inactive clock cycles per period (cycles with pwm=0). Therefore it is interpreted differently in symmetrical and asymmetrical counter mode: Asymmetrical mode (sawtooth): pwm = (counter &gt;= gpio_app_tc) Symmetrical mode (triangle) : Counter is compared with gpio_app_tc[31:1], gpio_app_tc[0] extends the inactive phase by 1 clock cycle only while counting up. This allows running a 10 ns resolution even in symmetrical mode.} Capture mode (capture register) { | In the capture mode, this register holds the captured counter value.} Blink mode (blink sequence) { | In the blink mode, this register holds the blinking sequence starting from bit 0.} </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'gpio_app_counter_ctrl[%s]': 0xFF900240-->
          <dim>3</dim>
          <dimIncrement>4</dimIncrement>
          <name>gpio_app_counter_ctrl[%s]</name>
          <description>GPIO_APP counter0 control register: This register is accessible via address areas inlogic_app and xpic_app_system. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000040</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000003FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:10]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>gpio_ref</name>
              <bitRange>[9:7]</bitRange>
              <description>gpio reference (0 - 7) </description>
            </field>
            <field>
              <name>event_act</name>
              <bitRange>[6:5]</bitRange>
              <description>Define action of selected external event (dependent on sel_event, gpio_ref) 00: count every clock cycle, ignore external events 01: count only external events (edge or level according to bit sel_event) 10: enable watchdog mode of counter (external event will be reset without IRQ, overflow generates IRQ). 11: enable automatic run mode (external event sets run bit, used for DC-DC PWM in combination with bit once=1) </description>
            </field>
            <field>
              <name>once</name>
              <bitRange>[4:4]</bitRange>
              <description>1: count once (reset run bit after 1 period) 0: count continuously </description>
            </field>
            <field>
              <name>sel_event</name>
              <bitRange>[3:3]</bitRange>
              <description>select external event 0: high level, invert gpio in register gpio_app_cfg to select low level 1: pos. edge, invert gpio in register gpio_app_cfg to select neg. edge </description>
            </field>
            <field>
              <name>irq_en</name>
              <bitRange>[2:2]</bitRange>
              <description>1: enable interrupt request on sel_event 0: disable interrupt request </description>
            </field>
            <field>
              <name>sym_nasym</name>
              <bitRange>[1:1]</bitRange>
              <description>1: symmetric mode (triangle) 0: asymmetric mode (sawtooth) </description>
            </field>
            <field>
              <name>run</name>
              <bitRange>[0:0]</bitRange>
              <description>1: start counter, counter is running 0: stop counter </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'gpio_app_counter_max[%s]': 0xFF90024C-->
          <dim>3</dim>
          <dimIncrement>4</dimIncrement>
          <name>gpio_app_counter_max[%s]</name>
          <description>GPIO_APP counter0 max value: This register is accessible via address areas inlogic_app and xpic_app_system. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000004C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>Asymmetric mode: Counting period in cc + 1 Symmetric mode: Counting period in cc </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'gpio_app_counter_cnt[%s]': 0xFF900258-->
          <dim>3</dim>
          <dimIncrement>4</dimIncrement>
          <name>gpio_app_counter_cnt[%s]</name>
          <description>GPIO_APP counter0 current value: This register is accessible via address areas inlogic_app and xpic_app_system. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000058</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>val</name>
              <bitRange>[31:0]</bitRange>
              <description>current counter value </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'gpio_app_line': 0xFF900264-->
          <name>gpio_app_line</name>
          <description>GPIO_APP line register This register is accessible via address areas inlogic_app and xpic_app_system. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000064</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[7:0]</bitRange>
              <description>gpio_app output values </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'gpio_app_in': 0xFF900268-->
          <name>gpio_app_in</name>
          <description>GPIO_APP latched inputs register: This register is accessible via address areas inlogic_app and xpic_app_system. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000068</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>val</name>
              <bitRange>[7:0]</bitRange>
              <description>gpio_app input values </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'gpio_app_irq_raw': 0xFF90026C-->
          <name>gpio_app_irq_raw</name>
          <description>GPIO_APP raw IRQ register: Read access shows the status of unmasked IRQs.   IRQs are set automatically and reset by writing to this register: Write access with '1' resets the corresponding IRQ. Write access with '0' does not influence this bit. This register is accessible via address areas inlogic_app and xpic_app_system. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000006C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>gpio_app7</name>
              <bitRange>[7:7]</bitRange>
              <description>Interrupt bit for GPIO_APP7 </description>
            </field>
            <field>
              <name>gpio_app6</name>
              <bitRange>[6:6]</bitRange>
              <description>Interrupt bit for GPIO_APP6 </description>
            </field>
            <field>
              <name>gpio_app5</name>
              <bitRange>[5:5]</bitRange>
              <description>Interrupt bit for GPIO_APP5 </description>
            </field>
            <field>
              <name>gpio_app4</name>
              <bitRange>[4:4]</bitRange>
              <description>Interrupt bit for GPIO_APP4 </description>
            </field>
            <field>
              <name>gpio_app3</name>
              <bitRange>[3:3]</bitRange>
              <description>Interrupt bit for GPIO_APP3 </description>
            </field>
            <field>
              <name>gpio_app2</name>
              <bitRange>[2:2]</bitRange>
              <description>Interrupt bit for GPIO_APP2 </description>
            </field>
            <field>
              <name>gpio_app1</name>
              <bitRange>[1:1]</bitRange>
              <description>Interrupt bit for GPIO_APP1 </description>
            </field>
            <field>
              <name>gpio_app0</name>
              <bitRange>[0:0]</bitRange>
              <description>Interrupt bit for GPIO_APP0 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'gpio_app_irq_masked': 0xFF900270-->
          <name>gpio_app_irq_masked</name>
          <description>GPIO_APP masked IRQ register: This register exists 2x for the different system busses (address areas) it is connected to.   This allows 2 CPUs to work in parallel on this module: ARM_APP, xPIC_APP. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000070</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>gpio_app7</name>
              <bitRange>[7:7]</bitRange>
              <description>Interrupt bit for GPIO_APP7 </description>
            </field>
            <field>
              <name>gpio_app6</name>
              <bitRange>[6:6]</bitRange>
              <description>Interrupt bit for GPIO_APP6 </description>
            </field>
            <field>
              <name>gpio_app5</name>
              <bitRange>[5:5]</bitRange>
              <description>Interrupt bit for GPIO_APP5 </description>
            </field>
            <field>
              <name>gpio_app4</name>
              <bitRange>[4:4]</bitRange>
              <description>Interrupt bit for GPIO_APP4 </description>
            </field>
            <field>
              <name>gpio_app3</name>
              <bitRange>[3:3]</bitRange>
              <description>Interrupt bit for GPIO_APP3 </description>
            </field>
            <field>
              <name>gpio_app2</name>
              <bitRange>[2:2]</bitRange>
              <description>Interrupt bit for GPIO_APP2 </description>
            </field>
            <field>
              <name>gpio_app1</name>
              <bitRange>[1:1]</bitRange>
              <description>Interrupt bit for GPIO_APP1 </description>
            </field>
            <field>
              <name>gpio_app0</name>
              <bitRange>[0:0]</bitRange>
              <description>Interrupt bit for GPIO_APP0 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'gpio_app_irq_mask_set': 0xFF900274-->
          <name>gpio_app_irq_mask_set</name>
          <description>GPIO_APP interrupt mask set: The interrupt mask register exists 2x for the different system busses (address areas) it is connected to.   This allows 2 CPUs to work in parallel on this module: ARM_APP, xPIC_APP. The inlogic_app IRQ mask enables interrupt requests for ARM_APP.   The xpic_app_system IRQ mask enables interrupt requests for xPIC_APP.   Since different software tasks might change its bits,   the IRQ mask register is not writable directly, but by set and reset masks: Write access with '1' sets the interrupt mask bit (enables the interrupt request for the corresponding interrupt source). Write access with '0' does not influence this bit. Read access shows the current interrupt mask. Note: Before activating the interrupt mask, delete old pending interrupts by writing the same value to gpio_app_irq_raw. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000074</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>gpio_app7</name>
              <bitRange>[7:7]</bitRange>
              <description>Interrupt bit for GPIO_APP7 </description>
            </field>
            <field>
              <name>gpio_app6</name>
              <bitRange>[6:6]</bitRange>
              <description>Interrupt bit for GPIO_APP6 </description>
            </field>
            <field>
              <name>gpio_app5</name>
              <bitRange>[5:5]</bitRange>
              <description>Interrupt bit for GPIO_APP5 </description>
            </field>
            <field>
              <name>gpio_app4</name>
              <bitRange>[4:4]</bitRange>
              <description>Interrupt bit for GPIO_APP4 </description>
            </field>
            <field>
              <name>gpio_app3</name>
              <bitRange>[3:3]</bitRange>
              <description>Interrupt bit for GPIO_APP3 </description>
            </field>
            <field>
              <name>gpio_app2</name>
              <bitRange>[2:2]</bitRange>
              <description>Interrupt bit for GPIO_APP2 </description>
            </field>
            <field>
              <name>gpio_app1</name>
              <bitRange>[1:1]</bitRange>
              <description>Interrupt bit for GPIO_APP1 </description>
            </field>
            <field>
              <name>gpio_app0</name>
              <bitRange>[0:0]</bitRange>
              <description>Interrupt bit for GPIO_APP0 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'gpio_app_irq_mask_rst': 0xFF900278-->
          <name>gpio_app_irq_mask_rst</name>
          <description>GPIO_APP interrupt mask reset: This reset mask serves to disable the interrupt requests for the corresponding interrupt sources.   Like irq_msk_set, this address exists for the following address areas: inlogic_app, xpic_app_system. Write access with '1' resets the interrupt mask bit (disables the interrupt request for the corresponding interrupt source). Write access with '0' does not influence this bit. Read access shows the current interrupt mask. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000078</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>gpio_app7</name>
              <bitRange>[7:7]</bitRange>
              <description>Interrupt bit for GPIO_APP7 </description>
            </field>
            <field>
              <name>gpio_app6</name>
              <bitRange>[6:6]</bitRange>
              <description>Interrupt bit for GPIO_APP6 </description>
            </field>
            <field>
              <name>gpio_app5</name>
              <bitRange>[5:5]</bitRange>
              <description>Interrupt bit for GPIO_APP5 </description>
            </field>
            <field>
              <name>gpio_app4</name>
              <bitRange>[4:4]</bitRange>
              <description>Interrupt bit for GPIO_APP4 </description>
            </field>
            <field>
              <name>gpio_app3</name>
              <bitRange>[3:3]</bitRange>
              <description>Interrupt bit for GPIO_APP3 </description>
            </field>
            <field>
              <name>gpio_app2</name>
              <bitRange>[2:2]</bitRange>
              <description>Interrupt bit for GPIO_APP2 </description>
            </field>
            <field>
              <name>gpio_app1</name>
              <bitRange>[1:1]</bitRange>
              <description>Interrupt bit for GPIO_APP1 </description>
            </field>
            <field>
              <name>gpio_app0</name>
              <bitRange>[0:0]</bitRange>
              <description>Interrupt bit for GPIO_APP0 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'gpio_app_cnt_irq_raw': 0xFF90027C-->
          <name>gpio_app_cnt_irq_raw</name>
          <description>Counter raw IRQ register: Read access shows the status of unmasked IRQs.   IRQs are set automatically and reset by writing to this register: Write access with '1' resets the corresponding IRQ. Write access with '0' does not influence this bit. This register is accessible via address areas inlogic_app and xpic_app_system. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000007C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000007</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:3]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>cnt2</name>
              <bitRange>[2:2]</bitRange>
              <description>Interrupt bit for counter2 </description>
            </field>
            <field>
              <name>cnt1</name>
              <bitRange>[1:1]</bitRange>
              <description>Interrupt bit for counter1 </description>
            </field>
            <field>
              <name>cnt0</name>
              <bitRange>[0:0]</bitRange>
              <description>Interrupt bit for counter0 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'gpio_app_cnt_irq_masked': 0xFF900280-->
          <name>gpio_app_cnt_irq_masked</name>
          <description>Counter masked IRQ register: Read access shows the status of masked IRQs (cnt_irq_raw AND cnt_irq_mask). This register exists 2x for the different system busses (address areas) it is connected to.   This allows 2 CPUs to work in parallel on this module: ARM_APP, xPIC_APP. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000080</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000007</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:3]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>cnt2</name>
              <bitRange>[2:2]</bitRange>
              <description>Interrupt bit for counter2 </description>
            </field>
            <field>
              <name>cnt1</name>
              <bitRange>[1:1]</bitRange>
              <description>Interrupt bit for counter1 </description>
            </field>
            <field>
              <name>cnt0</name>
              <bitRange>[0:0]</bitRange>
              <description>Interrupt bit for counter0 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'gpio_app_cnt_irq_mask_set': 0xFF900284-->
          <name>gpio_app_cnt_irq_mask_set</name>
          <description>Counter interrupt mask set: The interrupt mask register exists 2x for the different system busses (address areas) it is connected to.   This allows 2 CPUs to work in parallel on this module: ARM_APP, xPIC_APP. The inlogic_app IRQ mask enables interrupt requests for ARM_APP.   The xpic_app_system IRQ mask enables interrupt requests for xPIC_APP.   Since different software tasks might change its bits,   the IRQ mask register is not writable directly, but by set and reset masks: Write access with '1' sets the interrupt mask bit (enables the interrupt request for the corresponding interrupt source). Write access with '0' does not influence this bit. Read access shows the current interrupt mask. Note: Before activating the interrupt mask, delete old pending interrupts by writing the same value to cnt_irq_raw. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000084</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000007</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:3]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>cnt2</name>
              <bitRange>[2:2]</bitRange>
              <description>Interrupt bit for counter2 </description>
            </field>
            <field>
              <name>cnt1</name>
              <bitRange>[1:1]</bitRange>
              <description>Interrupt bit for counter1 </description>
            </field>
            <field>
              <name>cnt0</name>
              <bitRange>[0:0]</bitRange>
              <description>Interrupt bit for counter0 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'gpio_app_cnt_irq_mask_rst': 0xFF900288-->
          <name>gpio_app_cnt_irq_mask_rst</name>
          <description>Counter interrupt mask reset: This reset mask serves to disable the interrupt requests for the corresponding interrupt sources.   Like cnt_irq_msk_set, this address exists for the following address areas: inlogic_app, xpic_app_system. Write access with '1' resets the interrupt mask bit (disables the interrupt request for the corresponding interrupt source). Write access with '0' does not influence this bit. Read access shows the current interrupt mask. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000088</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000007</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:3]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>cnt2</name>
              <bitRange>[2:2]</bitRange>
              <description>Interrupt bit for counter2 </description>
            </field>
            <field>
              <name>cnt1</name>
              <bitRange>[1:1]</bitRange>
              <description>Interrupt bit for counter1 </description>
            </field>
            <field>
              <name>cnt0</name>
              <bitRange>[0:0]</bitRange>
              <description>Interrupt bit for counter0 </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>uart_xpic_app</name>
      <description>uart_xpic_app</description>
      <baseAddress>0xFF900300</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>64</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>uart_xpic_app</name>
        <value>21</value>
      </interrupt>
      <registers>
        <register>
          <!--Absolute address of 'uartdr': 0xFF900300-->
          <name>uartdr</name>
          <description>data read or written from the interface </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000007FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:11]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>BE</name>
              <bitRange>[10:10]</bitRange>
              <description>Break Error, read only, mirrored from uartrsr, to handle in DMA-read-out data </description>
            </field>
            <field>
              <name>PE</name>
              <bitRange>[9:9]</bitRange>
              <description>Parity Error, read only, mirrored from uartrsr, to handle in DMA-read-out data </description>
            </field>
            <field>
              <name>FE</name>
              <bitRange>[8:8]</bitRange>
              <description>Framing Error, read only, mirrored from uartrsr, to handle in DMA-read-out data </description>
            </field>
            <field>
              <name>DATA</name>
              <bitRange>[7:0]</bitRange>
              <description>data read or written from the interface </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'uartrsr': 0xFF900304-->
          <name>uartrsr</name>
          <description>receive status register (read) / Error Clear Register (write) </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>OE</name>
              <bitRange>[3:3]</bitRange>
              <description>Overrun Error </description>
            </field>
            <field>
              <name>BE</name>
              <bitRange>[2:2]</bitRange>
              <description>Break Error </description>
            </field>
            <field>
              <name>PE</name>
              <bitRange>[1:1]</bitRange>
              <description>Parity Error </description>
            </field>
            <field>
              <name>FE</name>
              <bitRange>[0:0]</bitRange>
              <description>Framing Error </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'uartlcr_h': 0xFF900308-->
          <name>uartlcr_h</name>
          <description>Line control Register, high byte </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000007F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>WLEN</name>
              <bitRange>[6:5]</bitRange>
              <description>Word Length '00' 5 bits '01' 6 bits '10' 7 bits '11' 8 bits </description>
            </field>
            <field>
              <name>FEN</name>
              <bitRange>[4:4]</bitRange>
              <description>FIFO Enable </description>
            </field>
            <field>
              <name>STP2</name>
              <bitRange>[3:3]</bitRange>
              <description>2 Stop Bits Select </description>
            </field>
            <field>
              <name>EPS</name>
              <bitRange>[2:2]</bitRange>
              <description>Even Parity Select </description>
            </field>
            <field>
              <name>PEN</name>
              <bitRange>[1:1]</bitRange>
              <description>Parity Enalble </description>
            </field>
            <field>
              <name>BRK</name>
              <bitRange>[0:0]</bitRange>
              <description>Send Break </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'uartlcr_m': 0xFF90030C-->
          <name>uartlcr_m</name>
          <description>Line control Register, middle byte </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>BAUDDIVMS</name>
              <bitRange>[7:0]</bitRange>
              <description>bauddiv : Baud Divisor Most Significant Byte use higher byte of bauddiv = (system clk / (16 * baud rate)) - 1 if not alternative settings by register uartcr_2 are done </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'uartlcr_l': 0xFF900310-->
          <name>uartlcr_l</name>
          <description>Line control Register, low byte </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>BAUDDIVLS</name>
              <bitRange>[7:0]</bitRange>
              <description>Baud Divisor Least Significant Byte use lower byte of bauddiv = (system clk / (16 * baud rate)) - 1 if not alternative settings by register uartcr_2 are done </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'uartcr': 0xFF900314-->
          <name>uartcr</name>
          <description>uart control Register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000001FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:9]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>TX_RX_LOOP</name>
              <bitRange>[8:8]</bitRange>
              <description>internal loop (TX -&gt; RX) (test purpose only) </description>
            </field>
            <field>
              <name>LBE</name>
              <bitRange>[7:7]</bitRange>
              <description>Loop Back Enable for IrDA mode </description>
            </field>
            <field>
              <name>RTIE</name>
              <bitRange>[6:6]</bitRange>
              <description>Receive Timeout Interrupt Enable </description>
            </field>
            <field>
              <name>TIE</name>
              <bitRange>[5:5]</bitRange>
              <description>Transmit Interrupt Enable </description>
            </field>
            <field>
              <name>RIE</name>
              <bitRange>[4:4]</bitRange>
              <description>Receive Interrupt Enable </description>
            </field>
            <field>
              <name>MSIE</name>
              <bitRange>[3:3]</bitRange>
              <description>Modem Status Interrupt Enable </description>
            </field>
            <field>
              <name>SIRLP</name>
              <bitRange>[2:2]</bitRange>
              <description>IrDA SIR Low Power Mode </description>
            </field>
            <field>
              <name>SIREN</name>
              <bitRange>[1:1]</bitRange>
              <description>SIR Enable </description>
            </field>
            <field>
              <name>uartEN</name>
              <bitRange>[0:0]</bitRange>
              <description>uart Enable </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'uartfr': 0xFF900318-->
          <name>uartfr</name>
          <description>uart Flag Register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000018</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>TXFE</name>
              <bitRange>[7:7]</bitRange>
              <description>Transmit FIFO Empty </description>
            </field>
            <field>
              <name>RXFF</name>
              <bitRange>[6:6]</bitRange>
              <description>Receive FIFO Full </description>
            </field>
            <field>
              <name>TXFF</name>
              <bitRange>[5:5]</bitRange>
              <description>Transmit FIFO Full </description>
            </field>
            <field>
              <name>RXFE</name>
              <bitRange>[4:4]</bitRange>
              <description>Receive FIFO Empty </description>
            </field>
            <field>
              <name>BUSY</name>
              <bitRange>[3:3]</bitRange>
              <description>uart BUSY </description>
            </field>
            <field>
              <name>DCD</name>
              <bitRange>[2:2]</bitRange>
              <description>Data Carrier Detect </description>
            </field>
            <field>
              <name>DSR</name>
              <bitRange>[1:1]</bitRange>
              <description>Data Set Ready </description>
            </field>
            <field>
              <name>CTS</name>
              <bitRange>[0:0]</bitRange>
              <description>Clear To Send </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'uartiir': 0xFF90031C-->
          <name>uartiir</name>
          <description>Interrupt Identification (read) / interrupt clear (write) </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000001C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>RTIS</name>
              <bitRange>[3:3]</bitRange>
              <description>Receive Timeout Interrupt Status </description>
            </field>
            <field>
              <name>TIS</name>
              <bitRange>[2:2]</bitRange>
              <description>Transmit Interrupt Status </description>
            </field>
            <field>
              <name>RIS</name>
              <bitRange>[1:1]</bitRange>
              <description>Receive Interrupt Status </description>
            </field>
            <field>
              <name>MIS</name>
              <bitRange>[0:0]</bitRange>
              <description>Modem Interrupt Status </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'uartilpr': 0xFF900320-->
          <name>uartilpr</name>
          <description>IrDA Low Power Counter Register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ILPDVSR</name>
              <bitRange>[7:0]</bitRange>
              <description>IrDA Low Power Divisor </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'uartrts': 0xFF900324-->
          <name>uartrts</name>
          <description>RTS Control Register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000024</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>STICK</name>
              <bitRange>[7:7]</bitRange>
              <description>stick parity </description>
            </field>
            <field>
              <name>CTS_pol</name>
              <bitRange>[6:6]</bitRange>
              <description>nUARTCTS polarity: 1=active high </description>
            </field>
            <field>
              <name>CTS_ctr</name>
              <bitRange>[5:5]</bitRange>
              <description>nUARTCTS control </description>
            </field>
            <field>
              <name>RTS_pol</name>
              <bitRange>[4:4]</bitRange>
              <description>RTS polarity: 1=active high </description>
            </field>
            <field>
              <name>MOD2</name>
              <bitRange>[3:3]</bitRange>
              <description>mode1/mode2 </description>
            </field>
            <field>
              <name>COUNT</name>
              <bitRange>[2:2]</bitRange>
              <description>count base: 1=system clocks, 0=time in bauds </description>
            </field>
            <field>
              <name>RTS</name>
              <bitRange>[1:1]</bitRange>
              <description>if AUTO=0: controlled by this bit </description>
            </field>
            <field>
              <name>AUTO</name>
              <bitRange>[0:0]</bitRange>
              <description>automatic or controlled by the next bit (RTS) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'uartforerun': 0xFF900328-->
          <name>uartforerun</name>
          <description>RTS forerun cycles </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000028</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>FORERUN</name>
              <bitRange>[7:0]</bitRange>
              <description>number of forerun cycles in system clocks or bauds </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'uarttrail': 0xFF90032C-->
          <name>uarttrail</name>
          <description>RTS trail cycles </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000002C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>TRAIL</name>
              <bitRange>[7:0]</bitRange>
              <description>number of trail cycles in system clocks or bauds </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'uartdrvout': 0xFF900330-->
          <name>uartdrvout</name>
          <description>Drive Output </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000030</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:2]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>DRVRTS</name>
              <bitRange>[1:1]</bitRange>
              <description>enable driver for RTS </description>
            </field>
            <field>
              <name>DRVTX</name>
              <bitRange>[0:0]</bitRange>
              <description>enable driver for TX </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'uartcr_2': 0xFF900334-->
          <name>uartcr_2</name>
          <description>Control Register 2 </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000034</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:2]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>oversampling_8x</name>
              <bitRange>[1:1]</bitRange>
              <description>Oversampling mode: 0: Use default 16x oversampling. 1: Use reduced accuracy 8x oversampling. This can be used to increase the max. baudrate. When selected, the configured baudrate will be doubled. Note that the bit reception is more error-prone in noisy environments. </description>
            </field>
            <field>
              <name>Baud_Rate_Mode</name>
              <bitRange>[0:0]</bitRange>
              <description>If this bit is set the baud rate is generated more exactly by the following formula: value = ( (Baud Rate * 16) / System Frequency ) * 2^16  . You have to write this 16-bit value in register uartlcr_l and uartlcr_m. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'uartrxiflsel': 0xFF900338-->
          <name>uartrxiflsel</name>
          <description>RX FIFO trigger level and RX-DMA enable </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000038</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000008</resetValue>
          <resetMask>0x0000003F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>RXDMA</name>
              <bitRange>[5:5]</bitRange>
              <description>Enable DMA-requests for RX-fifo-data. A request will be generated if RX-FIFO is not empty and uartcr.uartEN (module enable) is set. Burst request to DMA-Ctrl will be done if the RX-FIFO contains at least 4 words (set DMA-burst-size to 4) If this bit is reset or the module is disabled, DMA-request will also be reset. single transfer request: RX-FIFO contains 1 byte or more, burst request: 4 bytes or more note: set adr_dmac_chctrl.SBSize = 1 (i.e. burst size: 4) in the DMA module </description>
            </field>
            <field>
              <name>RXIFLSEL</name>
              <bitRange>[4:0]</bitRange>
              <description>Choose a number between 1 and 16. It defines the IRQ trigger level of the receive fifo. The IRQ (UARTRXINTR) will be set if the number of received bytes in the receive fifo are greater than or equal RXIFLSEL. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'uarttxiflsel': 0xFF90033C-->
          <name>uarttxiflsel</name>
          <description>TX FIFO trigger level and TX-DMA enable </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000003C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000008</resetValue>
          <resetMask>0x0000003F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:6]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>TXDMA</name>
              <bitRange>[5:5]</bitRange>
              <description>Enable DMA-requests for TX-fifo-data. A request will be generated if TX-FIFO is not full and uartcr.uartEN (module enable) is set. Burst request to DMA-Ctrl will be done if at least 4 words are writable to the TX-FIFO (set DMA-burst-size to 4) If this bit is reset or the module is disabled, DMA-request will also be reset. note: set adr_dmac_chctrl.DBSize = 1 (i.e. burst size: 4) in the DMA module </description>
            </field>
            <field>
              <name>TXIFLSEL</name>
              <bitRange>[4:0]</bitRange>
              <description>Choose a number between 1 and 16. It defines the IRQ trigger level of the transmit fifo. The IRQ (UARTTXINTR) will be set if the number of transmitted bytes in the transmit fifo are less than TXIFLSEL. </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>i2c_xpic_app</name>
      <description>i2c_xpic_app</description>
      <baseAddress>0xFF900340</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>64</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>i2c_xpic_app</name>
        <value>10</value>
      </interrupt>
      <registers>
        <register>
          <!--Absolute address of 'i2c_mcr': 0xFF900340-->
          <name>i2c_mcr</name>
          <description>I2C master control register: </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000707FF</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:19]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>en_timeout</name>
              <bitRange>[18:18]</bitRange>
              <description>Enable I2C command timeout detection. Enabling the timeout detection is recommended to prevent the module from stalling if another device holds the I2C signals permanently low. For details, see the description of bit i2s_sr.timeout. </description>
            </field>
            <field>
              <name>rst_i2c</name>
              <bitRange>[17:17]</bitRange>
              <description>Reset the I2C bus-state-detection logic. To avoid conflicts with other masters, some I2C bus states, which are important when there are multiple masters on the I2C bus, are always monitored, even if the I2C module is disabled. For details, see bits i2c_sr.started and i2c.bus_master. However, it may happen that bus states are detected which lock up the I2C module. E.g. hazards during power-up or IO configuration or sequences, which are not I2C compliant, can cause a lock-up. This bit can be used to escape from such a situation. Write a '1' here to reset the I2C bus-state-detection logic of register i2c_sr. Note: This bit is new since netX51/52. It is always '0' when read. </description>
            </field>
            <field>
              <name>pio_mode</name>
              <bitRange>[16:16]</bitRange>
              <description>If this bit is set, SCL and SDA can be controlled directly by register i2c_pio (e.g. to access devices being incompatible with I2C). In PIO mode, the I2C controller state machine is disabled: FIFOs are not used, no IRQs will be set, and no DMA controlling is possible. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[15:11]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sadr</name>
              <bitRange>[10:4]</bitRange>
              <description>7-bit slave address sent after (r)START: For 10-bit addressing, the first byte (10-bit start '11110', address bits[9:8] must be programmed here. The second start byte (lower slave address bits) must be on top of the master FIFO (i2c_mdr). This register must be rewritten (even if the value does not change) to address another slave in the 10-bit mode (run 2-byte start sequence). The register must not be rewritten before a repeated START on the same 10-bit addressed slave (run 1-byte start sequence e.g. write to read change). </description>
            </field>
            <field>
              <name>mode</name>
              <bitRange>[3:1]</bitRange>
              <description>I2C-speed-mode: If this device is used as a slave only, the mode should be set to the data rate generated by the fastest master on the I2C-bus for appropriate input filtering and spike suppression. 000: Fast/Standard mode, 50 kbit/s 001: Fast/Standard mode, 100 kbit/s 010: Fast/Standard mode, 200 kbit/s 011: Fast/Standard mode, 400 kbit/s 100: High-speed mode, 800 kbit/s 101: High-speed mode, 1.2 Mbit/s 110: High-speed mode, 1.7 Mbit/s 111: High-speed mode, 3.4 Mbit/s) </description>
            </field>
            <field>
              <name>en_i2c</name>
              <bitRange>[0:0]</bitRange>
              <description>Global I2C controller enable 1: Enable I2C controller 0: Disable I2C controller Disabling the I2C module during a transfer will immediately disconnect the I2C module from the bus without generating a STOP. The internal I2C state machine will be set back to initial/idle state. The I2C bus-state-detection for the bits i2c_sr.bus_master and i2c_sr.started are performed even if the module is disabled. For details, see these bits. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'i2c_scr': 0xFF900344-->
          <name>i2c_scr</name>
          <description>I2C slave control register: </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x001707FF</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:21]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>autoreset_ac_start</name>
              <bitRange>[20:20]</bitRange>
              <description>Auto reset ac_start (ac_start must be set again after any (r)START): 0: ac_start will not be reset automatically (netX 50-compatible, but not recommended) 1: Reset ac_start after this slave acknowledged a start sequence (recommended) </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[19:19]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>ac_gcall</name>
              <bitRange>[18:18]</bitRange>
              <description>General call acknowledge: 0: Do not generate an acknowledge after a general call 1: Generate an acknowledge after a general call </description>
            </field>
            <field>
              <name>ac_start</name>
              <bitRange>[17:17]</bitRange>
              <description>Enable start sequence acknowledge: If the received address matches the sid-bits, the start-byte (2 bytes if sid10 is set) will be acknowledged. If the master requests a read transfer, a slave FIFO read access will be carried out immediately after the acknowledge, i.e. valid data must be present in the slave FIFO before enabling the acknowledge. If autoreset_ac_start is enabled, the controller will automatically reset this bit. If it is not enabled, the software should reset this bit after the start sequence has been acknowledged to avoid acknowledge and FIFO errors after the next (r)START. 0: Do not generate an acknowledge after the start sequence 1: Generate an acknowledge after the start sequence This bit is writable, but can also be changed by hardware. </description>
            </field>
            <field>
              <name>ac_srx</name>
              <bitRange>[16:16]</bitRange>
              <description>Enable slave-receive-data acknowledge: 0: Do not acknowledge receive bytes 1: Acknowledge receive bytes If the slave FIFO is full, receive data will not be acknowledged. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[15:11]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sid10</name>
              <bitRange>[10:10]</bitRange>
              <description>10-bit slave device ID/address: 0: Wait for 7-bit slave address after (r)START 1: Wait for 10-bit slave address after (r)START </description>
            </field>
            <field>
              <name>sid</name>
              <bitRange>[9:0]</bitRange>
              <description>Slave device ID/address: External masters can address this device (this I2C module in slave mode) by the ID/address programmed here. If sid10 is not set, bits 9 to 7 will be ignored. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'i2c_cmd': 0xFF900348-->
          <name>i2c_cmd</name>
          <description>I2C master command register: </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000000E</resetValue>
          <resetMask>0x0FF3FF0F</resetMask>
          <fields>
            <field>
              <name>bf_align2</name>
              <bitRange>[31:28]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>acpollmax</name>
              <bitRange>[27:20]</bitRange>
              <description>Number of tries (acpollmax+1, i.e. 1 to 256) for start sequence acknowledge polling: For 7-bit addressing, acknowledge polling START and the first byte containing the slave address (i2c_mcr.sadr) will be repeated up to acpollmax+1 times until a slave generates an acknowledge. If no acknowledge is received within acpollmax+1 tries, IRQ cmd_err will be generated. For 10-bit-addressing, the 2-byte start sequence is performed. The second address byte (lower address bits) must be on top of the master FIFO (i2c_mdr). For subsequent transfers, the value programmed in tsize has to ignore this byte. The programmed value of acpollmax will count down during acknowledge polling after each start sequence. This bit is writable, but can also be changed by hardware. </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[19:18]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>tsize</name>
              <bitRange>[17:8]</bitRange>
              <description>Transfer tsize+1 bytes (1...1024): If no acknowledge is generated by the slave (receiver), write transfers will be terminated and IRQ cmd_err will be generated. For 10-bit-addressing, the second start-byte (lower address bits) must be on top of the master FIFO. For subsequent transfers, the value programmed here has to ignore this byte. This value will count down during transfers after each byte. This bit is writable, but can also be changed by hardware. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[7:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>cmd</name>
              <bitRange>[3:1]</bitRange>
              <description>I2C sequence command: All commands will generate IRQ cmd_ok or IRQ cmd_err. A successful command termination will always generate IRQ cmd_ok. In case of an unsuccessful command termination, IRQ cmd_err will be set. {    |         | 000  START     Generate (r)START-condition 001  S_AC      Acknowledge-polling: generate up to acpollmax+1 START-sequences (until acknowledged by slave) 010  S_AC_T    Run S_AC, then transfer tsize+1 bytes from/to master FIFO. Not to be continued 011  S_AC_TC   Run S_AC, then transfer tsize+1 bytes from/to master FIFO. To be continued 100  CT        Continued transfer not to be continued 101  CTC       Continued transfer to be continued 110  STOP      Generate STOP-condition 111  IDLE      Nothing to do, last command finished, break current command } Sequences including read transfers that are not to be continued (S_AC_T, CT with 'nwr' bit set) will not generate an acknowledge after the last received byte (read transfer ends). Read transfers that are to be continued (S_AC_TC, CTC) will generate an acknowledge after the last received byte and must be followed by CT or CTC. Before continued transfers (CT, CTC), a command including START (START, S_AC, S_AC_T, S_AC_TC) must be executed to generate a valid I2C sequence. STOP must always be executed by software to free the bus after transfer end. STOP is not included in any command sequence and never executed automatically by this module. Some commands are handled as sequences (i.e. after setting S_AC_T, first S_AC then CT will be seen when read). You need not poll for IDLE here before setting up a new command, but you have to wait for cmd_ok or cmd_err status flags of register i2c_irqsr to be set. This bit is writable, but can also be changed by hardware. </description>
            </field>
            <field>
              <name>nwr</name>
              <bitRange>[0:0]</bitRange>
              <description>Transfer direction (not-write/read): 0: cmd will be executed as write 1: cmd will be executed as read Master FIFO-requests (IRQ and DMA) are generated depending on this direction flag. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'i2c_mdr': 0xFF90034C-->
          <name>i2c_mdr</name>
          <description>I2C master data register (master FIFO): There is only one FIFO for both receive and transmit master data with a depth of 16 bytes. For master write access, data sent by the master is delivered from the FIFO. For master read access, data received by the master is stored in the FIFO. In case of imminent data transfer failure (read transfer and FIFO is full or write transfer and FIFO is empty), the transfer will be interrupted. To continue the transfer, the FIFO must be handled first (filled for write transfer, read out for read transfer). Note: The FIFO behavior has been changed: For netX 51/52/56 and older versions, the current command was aborted and the cmd_err was raised. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>mdata</name>
              <bitRange>[7:0]</bitRange>
              <description>I2C master transmit or receive data: Write data will be removed from the FIFO after the receiving slave has generated the corresponding acknowledge. Write data that has not been acknowledged will not be removed from the FIFO. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'i2c_sdr': 0xFF900350-->
          <name>i2c_sdr</name>
          <description>I2C slave data register (slave FIFO): There is only one FIFO for both receive and transmit slave data with a depth of 16 bytes. For master read access, data sent by the slave is delivered from the FIFO. For master write access, data received by the slave is stored in the FIFO. A transfer is initiated after the detection of I2C-start-sequence to the device address (i2c_scr.sid, sreq IRQ) which is acknowledged by this device (i2c_scr.ac_start). For read transfers, sent data is read from the FIFO immediately after the detection of the acknowledge on the I2C-bus. SDA will be driven with the next data MSB immediately after the acknowledge SCL high phase. In case of a master read transfer and slave FIFO underrun, corrupted data will be sent to the master and the IRQ fifo_err will be set. In case of a master write transfer and slave FIFO is full, no acknowledge will be generated for the last received byte. No FIFO overflow will occur, but the last transferred byte (not acknowledged) will be lost and has to be sent again by the master. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:8]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sdata</name>
              <bitRange>[7:0]</bitRange>
              <description>I2C slave transmit or receive data: The software must handle i2c_scr.ac_start correctly to avoid FIFO errors after (r)START. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'i2c_mfifo_cr': 0xFF900354-->
          <name>i2c_mfifo_cr</name>
          <description>I2C master FIFO control register: </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000010F</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:9]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>mfifo_clr</name>
              <bitRange>[8:8]</bitRange>
              <description>Clear master data FIFO, write only bit. This bit is writable, but can also be changed by hardware. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[7:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>mfifo_wm</name>
              <bitRange>[3:0]</bitRange>
              <description>Master FIFO watermark for the generation of IRQ mfifo_req: If the master is the transmitter (enabled and i2c_cmd.nwr is 0), IRQ mfifo_req is generated if mfifo_level&lt;mfifo_wm. If the master is the receiver (enabled and i2c_cmd.nwr is 1), IRQ mfifo_req is generated if mfifo_level&gt;mfifo_wm. Note: Set the watermark to 0 at transfer end to avoid further IRQ generation. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'i2c_sfifo_cr': 0xFF900358-->
          <name>i2c_sfifo_cr</name>
          <description>I2C slave FIFO control register: </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000018</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000010F</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:9]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sfifo_clr</name>
              <bitRange>[8:8]</bitRange>
              <description>Clear slave data FIFO, write only bit. This bit is writable, but can also be changed by hardware. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[7:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sfifo_wm</name>
              <bitRange>[3:0]</bitRange>
              <description>Slave FIFO watermark for the generation of IRQ sfifo_req: If the slave is the transmitter (start sequence with set read bit was acknowledged by this slave), IRQ sfifo_req is generated if sfifo_level&lt;sfifo_wm. If the slave is not the transmitter (is receiver or not selected), IRQ sfifo_req is generated if sfifo_level&gt;sfifo_wm. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'i2c_sr': 0xFF90035C-->
          <name>i2c_sr</name>
          <description>I2C status register: </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000001C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xC0110040</resetValue>
          <resetMask>0xDFFF7FDF</resetMask>
          <fields>
            <field>
              <name>sda_state</name>
              <bitRange>[31:31]</bitRange>
              <description>SDA signal state sampled and filtered from bus (e.g. to detect bus blockings) This is a read-only status bit. </description>
            </field>
            <field>
              <name>scl_state</name>
              <bitRange>[30:30]</bitRange>
              <description>SCL signal state sampled and filtered from bus (e.g. to detect bus blockings) This is a read-only status bit. </description>
            </field>
            <field>
              <name>bf_align2</name>
              <bitRange>[29:29]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>timeout</name>
              <bitRange>[28:28]</bitRange>
              <description>I2C command timeout detection (for I2C master). I2C slaves can stretch low SCL phases by holding the SCL line low. The master must detect this and wait until the SCL line is released before the current transfer can continue. In error cases, the I2C bus can be blocked permanently by a low signal state of SCL. The reason for the blocking can be e.g. a crashed I2C slave or a false I/O configuration. To escape from such a situation, a timeout watchdog is implemented: A timeout will be detected if the SCL line is held low for more than 256 SCL periods. In this case, the recent command will be terminated and IRQ cmd_err will be set. The timeout detection must be enabled by bit i2c_mcr.en_timeout. It is disabled by default for backward compatibility. However, enabling is strongly recommended. If timeout is detected, the status bit must be cleared before a new command can be applied. This status bit can be cleared by writing a '1' to it or when bit i2c_mcr.rst_i2c performs a reset of the bus-state-detection logic. </description>
            </field>
            <field>
              <name>sid10_aced</name>
              <bitRange>[27:27]</bitRange>
              <description>10-bit slave address acknowledge state. {  | 0: There was no 10-bit slave address or it was not acknowledged. 1: A 10-bit slave address was broadcasted and a slave acknowledged this broadcast. I.e. for the master side: A 10-bit slave was addressed and the slave acknowledged. I.e. for the slave side: A master broadcasted a start with the address programmed in register i2c_scr.sid and the i2c module acknowledged this broadcast as bit i2c_scr.ac_start is set.} This read-only status bit is cleared automatically when the module detects a STOP or when register i2c_mcr is written (e.g. to perform a module reset by bit i2c_mcr.rst_i2c or to address another slave by changing the bits i2c_mcr.sadr). Remember that during rSTART, the master will generate only the first START-byte. </description>
            </field>
            <field>
              <name>gcall_aced</name>
              <bitRange>[26:26]</bitRange>
              <description>General call acknowledge state. 0: No general call start-byte, or general call start-byte was not acknowledged. 1: The slave side of the i2c module received and acknowledged a general call. Bit i2c_scr.ac_gcall controls the acknowledging of a general call. This read-only status bit will be cleared automatically if the last start-byte is not a general call or if it is a general call but bit i2c_scr.ac_gcall is not set. This bit is forced to '0' when the bit i2c_mcr.rst_i2c performs a reset of the bus-state-detection logic. Note: The bit has no function for the master side of the i2c module </description>
            </field>
            <field>
              <name>nwr_aced</name>
              <bitRange>[25:25]</bitRange>
              <description>Transfer direction (nwr-bit) of the last acknowledged start-byte (or 2-byte start sequence for 10-bit addressing). 0: The last acknowledged start-byte defined a write transfer. 1: The last acknowledged start-byte defined a read transfer. Slave FIFO requests generating IRQ and DMA requests depend on this direction flag. This read-only status bit is forced to '0' when bit i2c_mcr.rst_i2c performs a reset of the bus-state-detection logic. </description>
            </field>
            <field>
              <name>last_ac</name>
              <bitRange>[24:24]</bitRange>
              <description>Last acknowledge detected on bus. 0: SDA was high at the last acknowledge, i.e. no acknowledge. 1: SDA was low at the last acknowledge, i.e. acknowledge. This read-only status bit is forced to '0' when bit i2c_mcr.rst_i2c performs a reset of the bus-state-detection logic. </description>
            </field>
            <field>
              <name>slave_access</name>
              <bitRange>[23:23]</bitRange>
              <description>Slave access state. 0: No slave access to this device. 1: A master addressed this slave device. This read-only status bit is set if a start-byte (2 bytes for 10-bit address) containing the address programmed in register i2c_scr.sid has been received. This bit is always reset to 0 during START or STOP. This bit is forced to '0' when bit i2c_mcr.rst_i2c performs a reset of the bus-state-detection logic. Note: This bit does not depend on whether the start-byte has been acknowledged or not. </description>
            </field>
            <field>
              <name>started</name>
              <bitRange>[22:22]</bitRange>
              <description>START condition detection: 0: The bus is idle (STOP was detected, not started). 1: (r)START was detected on the bus. The bus is occupied. This detection will also take place while the module is disabled. This is important if there are multiple I2C masters on the bus: If another master occupies the bus while the I2C module is disabled, the I2C module must not start a transfer, before the other master has released the bus. Use bit i2c_mcr.rst_i2c to force this read-only status bit to '0', e.g. in order to escape from an accidentally detected START or a START that is not followed by a STOP. </description>
            </field>
            <field>
              <name>nwr</name>
              <bitRange>[21:21]</bitRange>
              <description>Transfer direction detected after last (r)START. 0: The last start-byte defined a write transfer. 1: The last start-byte defined a read transfer. This read-only status bit is always reset to 0 during (r)START. This bit is forced to '0' when bit i2c_mcr.rst_i2c performs a reset of the bus-state-detection logic. Note: This bit does not depend on whether the start-byte has been acknowledged or not. </description>
            </field>
            <field>
              <name>bus_master</name>
              <bitRange>[20:20]</bitRange>
              <description>Bus arbitration state. 0: Master lost I2C bus arbitration, bus is busy by another master. 1: Master gains I2C bus arbitration or bus is idle. This read-only status bit is set when the monitored bus state does not match the bus state expected by the I2C module. The bit is reset, when a STOP is detected. This detection will also take place while the module is disabled. This is important if there are multiple I2C masters on the bus: If another master occupies the bus while the I2C module is disabled, the I2C module must not start a transfer, before the other master has released the bus. Use bit i2c_mcr.rst_i2c to force this bit to '0', e.g. in order to escape from an arbitration loss not followed by a STOP. </description>
            </field>
            <field>
              <name>sfifo_err_undr</name>
              <bitRange>[19:19]</bitRange>
              <description>Slave FIFO underrun error occurred. Data is lost and the slave FIFO must be cleared by bit i2c_sfifo_cr.sfifo_clr. Clearing the slave FIFO will also clear this read-only status bit. </description>
            </field>
            <field>
              <name>sfifo_err_ovfl</name>
              <bitRange>[18:18]</bitRange>
              <description>Slave FIFO overflow error occurred. Data is lost and the slave FIFO must be cleared by bit i2c_sfifo_cr.sfifo_clr. Clearing the slave FIFO will also clear this read-only status bit. </description>
            </field>
            <field>
              <name>sfifo_full</name>
              <bitRange>[17:17]</bitRange>
              <description>Slave FIFO is full (1 if full) This is a read-only status bit. </description>
            </field>
            <field>
              <name>sfifo_empty</name>
              <bitRange>[16:16]</bitRange>
              <description>Slave FIFO is empty (1 if empty) This is a read-only status bit. </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[15:15]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sfifo_level</name>
              <bitRange>[14:10]</bitRange>
              <description>Slave FIFO level (0..16) This is a read-only status bit field. </description>
            </field>
            <field>
              <name>mfifo_err_undr</name>
              <bitRange>[9:9]</bitRange>
              <description>Master FIFO underrun error occurred. Data is lost and the master FIFO must be cleared by bit i2c_mfifo_cr.mfifo_clr. Clearing the master FIFO will also clear this read-only status bit. </description>
            </field>
            <field>
              <name>mfifo_err_ovfl</name>
              <bitRange>[8:8]</bitRange>
              <description>Master FIFO overflow error occurred. Data is lost and the master FIFO must be cleared by bit i2c_mfifo_cr.mfifo_clr. Clearing the master FIFO will also clear this read-only status bit. </description>
            </field>
            <field>
              <name>mfifo_full</name>
              <bitRange>[7:7]</bitRange>
              <description>Master FIFO is full (1 if full) This is a read-only status bit. </description>
            </field>
            <field>
              <name>mfifo_empty</name>
              <bitRange>[6:6]</bitRange>
              <description>Master FIFO is empty (1 if empty) This is a read-only status bit. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>mfifo_level</name>
              <bitRange>[4:0]</bitRange>
              <description>Master FIFO level (0..16) This is a read-only status bit field. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'i2c_irqmsk': 0xFF900360-->
          <name>i2c_irqmsk</name>
          <description>I2C interrupt mask set or clear register: These bits have AND-mask character. The corresponding IRQ will generate the module IRQ only if the mask bit is set. Changing a mask bit from '0' to '1' will clear the corresponding raw IRQ state. For a detailed IRQ description, see i2c_irqraw. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000007F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sreq</name>
              <bitRange>[6:6]</bitRange>
              <description>Slave request interrupt mask </description>
            </field>
            <field>
              <name>sfifo_req</name>
              <bitRange>[5:5]</bitRange>
              <description>Slave FIFO action request interrupt mask </description>
            </field>
            <field>
              <name>mfifo_req</name>
              <bitRange>[4:4]</bitRange>
              <description>Master FIFO action request interrupt mask </description>
            </field>
            <field>
              <name>bus_busy</name>
              <bitRange>[3:3]</bitRange>
              <description>External I2C-bus is busy interrupt mask </description>
            </field>
            <field>
              <name>fifo_err</name>
              <bitRange>[2:2]</bitRange>
              <description>FIFO error interrupt mask </description>
            </field>
            <field>
              <name>cmd_err</name>
              <bitRange>[1:1]</bitRange>
              <description>Command error interrupt mask </description>
            </field>
            <field>
              <name>cmd_ok</name>
              <bitRange>[0:0]</bitRange>
              <description>Command OK interrupt mask </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'i2c_irqsr': 0xFF900364-->
          <name>i2c_irqsr</name>
          <description>I2C interrupt state register (raw interrupt before masking): Writing '1' will clear the corresponding IRQ. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000024</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000007F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sreq</name>
              <bitRange>[6:6]</bitRange>
              <description>Unmasked slave request interrupt state: Purpose: Set up slave FIFO 1: External master was running START-sequence and requested this slave 0: Slave is not requested </description>
            </field>
            <field>
              <name>sfifo_req</name>
              <bitRange>[5:5]</bitRange>
              <description>Unmasked slave FIFO action request interrupt state: Purpose: Slave FIFO should be updated 1: Slave FIFO request: i2c_sr.sfifo_level is above or below i2c_sfifo_cr.sfifo_wm (see description i2c_sfifo_cr) 0: Slave FIFO state not critical </description>
            </field>
            <field>
              <name>mfifo_req</name>
              <bitRange>[4:4]</bitRange>
              <description>Unmasked master FIFO action request interrupt state: Purpose: Master FIFO should be updated 1: Master FIFO request: i2c_sr.mfifo_level is above or below i2c_mfifo_cr.mfifo_wm (see description i2c_mfifo_cr) 0: Master FIFO state not critical </description>
            </field>
            <field>
              <name>bus_busy</name>
              <bitRange>[3:3]</bitRange>
              <description>Unmasked external I2C-bus is busy interrupt state: Purpose: Detect I2C-bus arbitration loss 1: Master did not gain the requested bus access because another master accessed the bus 0: Bus is idle or no transfer is requested by this master </description>
            </field>
            <field>
              <name>fifo_err</name>
              <bitRange>[2:2]</bitRange>
              <description>Unmasked FIFO error interrupt state: Purpose: Detect FIFO errors/transfer failures 1: FIFO error occurred, check register i2c_sr 0: FIFOs ok </description>
            </field>
            <field>
              <name>cmd_err</name>
              <bitRange>[1:1]</bitRange>
              <description>Unmasked command error interrupt state: Purpose: Check last command termination 1: Last command finished erroneously 0: Command not finished, no command or command finished successfully </description>
            </field>
            <field>
              <name>cmd_ok</name>
              <bitRange>[0:0]</bitRange>
              <description>Unmasked command OK interrupt state: Purpose: Check last command termination 1: Last command finished successfully 0: Command not finished, no command or command finished erroneously </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'i2c_irqmsked': 0xFF900368-->
          <name>i2c_irqmsked</name>
          <description>I2C masked interrupt state register: If one of these bits is set, the I2C IRQ will be set to the interrupt controller. For a detailed IRQ description, see i2c_irqraw. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000028</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000007F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sreq</name>
              <bitRange>[6:6]</bitRange>
              <description>Masked slave request interrupt state </description>
            </field>
            <field>
              <name>sfifo_req</name>
              <bitRange>[5:5]</bitRange>
              <description>Masked slave FIFO action request interrupt state </description>
            </field>
            <field>
              <name>mfifo_req</name>
              <bitRange>[4:4]</bitRange>
              <description>Masked master FIFO action request interrupt state </description>
            </field>
            <field>
              <name>bus_busy</name>
              <bitRange>[3:3]</bitRange>
              <description>Masked external I2C-bus is busy interrupt state </description>
            </field>
            <field>
              <name>fifo_err</name>
              <bitRange>[2:2]</bitRange>
              <description>Masked FIFO error interrupt state </description>
            </field>
            <field>
              <name>cmd_err</name>
              <bitRange>[1:1]</bitRange>
              <description>Masked command error interrupt state </description>
            </field>
            <field>
              <name>cmd_ok</name>
              <bitRange>[0:0]</bitRange>
              <description>Masked command OK interrupt state </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'i2c_dmacr': 0xFF90036C-->
          <name>i2c_dmacr</name>
          <description>I2C DMA control register: Required settings for the DMA controller: - DMA transfer size to/from I2C module: Byte - DMA burst length to/from I2C module: 4 DMA burst requests will be generated if the corresponding FIFO contains more than 4 bytes (receive case) or if more than 4 bytes are writable to the corresponding FIFO (transmit case). DMA single transfer requests will be generated if the corresponding FIFO contains more than 1 byte (receive case) or if more than 1 byte is writable to the corresponding FIFO (transmit case). No further DMA requests will be generated if all transmit data is written to the master FIFO and the i2c module is the DMA flow controller (for master data only). Once all data is written to the master FIFO, the last burst/single request will be generated for the DMA controller. If the DMA controller sets DMACTC (terminal count) to indicate the end of transfer, the corresponding bit will be cleared. If one of the bits of this register is set to 0 by software and a DMA transfer has been requested before, the DMA controller will perform one last transfer to reset DMA request signals. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000002C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sdmab_en</name>
              <bitRange>[3:3]</bitRange>
              <description>Enable DMA burst requests for I2C slave data. The DMA controller must be the flow controller. This bit is writable, but can also be changed by hardware. </description>
            </field>
            <field>
              <name>sdmas_en</name>
              <bitRange>[2:2]</bitRange>
              <description>Enable DMA single requests for I2C slave data. The DMA controller must be the flow controller. This bit is writable, but can also be changed by hardware. </description>
            </field>
            <field>
              <name>mdmab_en</name>
              <bitRange>[1:1]</bitRange>
              <description>Enable DMA burst requests for I2C master data. The I2C module is the flow controller (i.e. peripheral-controlled flow control). Both, single and burst requests must be enabled. This bit is writable, but can also be changed by hardware. </description>
            </field>
            <field>
              <name>mdmas_en</name>
              <bitRange>[0:0]</bitRange>
              <description>Enable DMA single requests for I2C master data. The I2C module is the flow controller (i.e. peripheral-controlled flow control). Both, single and burst requests must be enabled. This bit is writable, but can also be changed by hardware. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'i2c_pio': 0xFF900370-->
          <name>i2c_pio</name>
          <description>PIO mode register: This register can directly control the I2C signals SCL and SDA if pio_mode is enabled in register i2c_mcr. In PIO mode, the I2C controller state machine is disabled, thus, no FIFO action takes place, no IRQs will be set, and no DMA-controlling is possible. Note: To avoid external driving conflicts, the I2C signals SCL and SDA are never driven active-high according to the I2C bus specification. The high level of these signals is realized by a pull-up (of the pad or externally)   and by setting the appropriate output enable to 0 (scl_oe, sda_oe) instead of driving the level active-high. Driving the signals directly by enabling the outputs (programming the bits sda_oe or scl_oe to '1') can lead to driving conflicts and could cause damage. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000030</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000044</resetValue>
          <resetMask>0x00000077</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sda_in_ro</name>
              <bitRange>[6:6]</bitRange>
              <description>SDA input state (read-only) </description>
            </field>
            <field>
              <name>sda_oe</name>
              <bitRange>[5:5]</bitRange>
              <description>SDA output enable 0: Do not drive SDA, switch pad to high-z. 1: Drive SDA, switch pad to programmed sda_out-state </description>
            </field>
            <field>
              <name>sda_out</name>
              <bitRange>[4:4]</bitRange>
              <description>Driving level of SDA (1: high, 0: low) if output is enabled (sda_oe is set) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:3]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>scl_in_ro</name>
              <bitRange>[2:2]</bitRange>
              <description>SCL input state (read-only) </description>
            </field>
            <field>
              <name>scl_oe</name>
              <bitRange>[1:1]</bitRange>
              <description>SCL output enable 0: Do not drive SCL, switch pad to high-z. 1: Drive SCL, switch pad to programmed scl_out-state </description>
            </field>
            <field>
              <name>scl_out</name>
              <bitRange>[0:0]</bitRange>
              <description>Driving level of SCL (1: high, 0: low) if output is enabled (scl_oe is set) </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>spi_xpic_app</name>
      <description>spi_xpic_app</description>
      <baseAddress>0xFF900380</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>64</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>spi_xpic_app</name>
        <value>19</value>
      </interrupt>
      <registers>
        <register>
          <!--Absolute address of 'spi_cr0': 0xFF900380-->
          <name>spi_cr0</name>
          <description>SPI control register 0 Registers 0x30..0x3C can be used instead of registers 0x00...0x24 to keep netx50 software compliant to netx100/500. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80080007</resetValue>
          <resetMask>0x9B0FFFCF</resetMask>
          <fields>
            <field>
              <name>netx100_comp</name>
              <bitRange>[31:31]</bitRange>
              <description>Use netx100/500-compatible SPI mode: 0: start transfer after writing data 1: start transfer after setting CR_write or CR_read </description>
            </field>
            <field>
              <name>bf_align3</name>
              <bitRange>[30:29]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>slave_sig_early</name>
              <bitRange>[28:28]</bitRange>
              <description>Generate MISO in slave mode 1 SCK clock edge earlier than defined in the SPI specification. This is to compensate pad or sampling delays on fast data rates. However, hold timing problems could come up as MISO is generated very fast after the sampling SPI clock edge. If filter_in is enabled, it takes at least 3 system clocks to generate MISO after SCK. If filter_in is disabled, it takes at least 2 system clocks to generate MISO after SCK. </description>
            </field>
            <field>
              <name>filter_in</name>
              <bitRange>[27:27]</bitRange>
              <description>Receive data is sampled every 10ns (100MHz system clock). If this bit is set, the stored receive value will be the result of a majority decision of the three sampling points around a SPI-clock edge (if two or more '1s! were sampled a '1' will be stored, else a '0' will be stored. In slave mode chip-select and SCK edges will also be detected by oversampling if this bit is set: An edge will be detected if the majority-result of 3 subsequent sampled values toggles. Input filtering should be used for sck_muladd&lt;=0x200 (i.e. below 12.5MHz). Stable signal phases are too short with higher frequencies and input filtering cannot be used. </description>
            </field>
            <field>
              <name>bf_align2</name>
              <bitRange>[26:26]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>format</name>
              <bitRange>[25:24]</bitRange>
              <description>Frame format: 00:     Motorola SPI frame format 01..11: reserved </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[23:20]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>sck_muladd</name>
              <bitRange>[19:8]</bitRange>
              <description>Serial clock rate multiply add value for master SCK generation. The SPI clock frequency is: f_spi_sck = (sck_muladd * 100)/4096 [MHz]. Default value 0x800 equals 50MHz SPI clock rate. All serial clock rates are derived from 100MHz netX system clock. Hence, all serial clock phases are multiples of 10ns. This leads to non-constant serial clock phases when a clock rate is programmed which cannot be generated by 100MHz/(2*n) without remainder. E.g. programming 0x4CC here will lead to a mean clock-rate of 30MHz. However, single clock high and low phases of 10ns and clock periods of 30ns will occur. This must be considered for serial device selection. E.g. using a 30MHz device which requires 33ns minimum clock period and a duty cycle of 50% will fail. Note: If sck_muladd is set to zero, SPI transfer will freeze. The SPI clock must not exceed (system frequency/4) in slave mode, if correct data sampling should always be guaranteed. Note: The value programmed here has no impact in slave mode. </description>
            </field>
            <field>
              <name>SPH</name>
              <bitRange>[7:7]</bitRange>
              <description>Serial clock phase (netx500: CR_ncpha): 1: sample data at second clock edge, data is generated half a clock phase before sampling 0: sample data at first clock edge, data is generated half a clock phase before sampling </description>
            </field>
            <field>
              <name>SPO</name>
              <bitRange>[6:6]</bitRange>
              <description>Serial clock polarity (netx500: CR_cpol): 0: idle: clock is low, first edge is rising 1: idle: clock is high, first edge is falling </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[5:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>datasize</name>
              <bitRange>[3:0]</bitRange>
              <description>DSS: data size select (transfer size = datasize + 1 bits): {            | 0000...0010: reserved 0011:        4 bit 0100:        5 bit ... 0111:        8 bit ... 1111:        16 bit } Note: 16 bit TX-data-loss bug of netX50/netX5 is fixed since netX10. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'spi_cr1': 0xFF900384-->
          <name>spi_cr1</name>
          <description>SPI control register 1 Registers 0x30..0x3C can be used instead of registers 0x00...0x24 to keep netx50 software compliant to netx100/500. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x08080000</resetValue>
          <resetMask>0x1F1F0F0F</resetMask>
          <fields>
            <field>
              <name>bf_align3</name>
              <bitRange>[31:29]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>rx_fifo_clr</name>
              <bitRange>[28:28]</bitRange>
              <description>Writing '1' to this bit will clear the receive FIFOs. </description>
            </field>
            <field>
              <name>rx_fifo_wm</name>
              <bitRange>[27:24]</bitRange>
              <description>Receive FIFO watermark for IRQ generation </description>
            </field>
            <field>
              <name>bf_align2</name>
              <bitRange>[23:21]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>tx_fifo_clr</name>
              <bitRange>[20:20]</bitRange>
              <description>Writing '1' to this bit will clear the transmit FIFOs. Note: There must be at least 1 system clock idle after clear before writing new data to the FIFO. This is guaranteed by the netX internal bus structure and needs not being considered by software. </description>
            </field>
            <field>
              <name>tx_fifo_wm</name>
              <bitRange>[19:16]</bitRange>
              <description>Transmit FIFO watermark for IRQ generation </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[15:12]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>fss_static</name>
              <bitRange>[11:11]</bitRange>
              <description>SPI static chip-select: {  | 0: SPI chip-select will be toggled automatically before and after each transferred word according to fss and datasize. 1: SPI chip-select will be set statically according to the fss bits. } </description>
            </field>
            <field>
              <name>fss</name>
              <bitRange>[10:8]</bitRange>
              <description>Frame or slave select. There are up to 3 external SPI chip-select signals. In master mode, the fss bits define the states of the chip-select signals. The inversion for low-active chip-selects (e.g. for Motorola SPI frame format) is done automatically depending on the value programmed to the 'format' bits. Example: To use the netX IO CS1 as chip-select, program '010' here, regardless whether the external chip-select is low or high active. In slave mode, the fss bits are a mask to select which netX input should be used as chip-select. Example: To use the netX IO CS0 as chip-select, program '001' here. </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[7:4]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>SOD</name>
              <bitRange>[3:3]</bitRange>
              <description>Slave mode output disable (to connect multiple slaves to one master): 0: MISO can be driven in slave mode 1: MISO is not driven in slave mode </description>
            </field>
            <field>
              <name>MS</name>
              <bitRange>[2:2]</bitRange>
              <description>Mode select: 0: Module is configured as master 1: Module is configured as slave </description>
            </field>
            <field>
              <name>SSE</name>
              <bitRange>[1:1]</bitRange>
              <description>SPI enable: 0: Module disabled 1: Module enabled </description>
            </field>
            <field>
              <name>LBM</name>
              <bitRange>[0:0]</bitRange>
              <description>Loop back mode: 0: Internal loop back disabled 1: Internal loop back enabled, spi_cr0.filter_in must be set for loopback function </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'spi_dr': 0xFF900388-->
          <name>spi_dr</name>
          <description>SPI data register Registers 0x30..0x3C can be used instead of registers 0x00...0x24 to keep netx50 software compliant to netx100/500. The SPI module has 2 FIFOs: One for transmit data and one for receive data. Read access: Received data byte is delivered from receive FIFO. Write access: Transmit data byte is written to send FIFO. Both FIFOs (receive and transmit) have a depth of 16. SPI master mode: MISO input data will be stored in the receive FIFO; transmit FIFO generates MOSI output data. SPI slave mode: MOSI input data will be stored in the receive FIFO; transmit FIFO generates MISO output data. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0001FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:17]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>data</name>
              <bitRange>[16:0]</bitRange>
              <description>Transmit data: Only lowest bits according to spi_cr0.datasize will be sent. Receive data will be delivered on the lowest bits, unused bits (above spi_cr0.datasize) will be '0'. In slave mode transmit data is requested from the FIFO when the last bit of the currently transferred word is set to the MISO signal. If no next transmit data can be read from the FIFO until the current word's last bit was transferred, a FIFO underrun will occur in case chip-select does not go inactive at the next detected SCK edge. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'spi_sr': 0xFF90038C-->
          <name>spi_sr</name>
          <description>SPI status register Registers 0x30..0x3C can be used instead of registers 0x00...0x24 to keep netx50 software compliant to netx100/500. Note: Both FIFOs (receive and transmit) have a depth of 16. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xDFDF001F</resetMask>
          <fields>
            <field>
              <name>rx_fifo_err_undr</name>
              <bitRange>[31:31]</bitRange>
              <description>Receive FIFO underrun error occurred, data is lost </description>
            </field>
            <field>
              <name>rx_fifo_err_ovfl</name>
              <bitRange>[30:30]</bitRange>
              <description>Receive FIFO overflow error occurred, data is lost </description>
            </field>
            <field>
              <name>bf_align2</name>
              <bitRange>[29:29]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>rx_fifo_level</name>
              <bitRange>[28:24]</bitRange>
              <description>Receive FIFO level (number of received words to read out are left in FIFO) </description>
            </field>
            <field>
              <name>tx_fifo_err_undr</name>
              <bitRange>[23:23]</bitRange>
              <description>Transmit FIFO underrun error occurred, data is lost </description>
            </field>
            <field>
              <name>tx_fifo_err_ovfl</name>
              <bitRange>[22:22]</bitRange>
              <description>Transmit FIFO overflow error occurred, data is lost </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[21:21]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>tx_fifo_level</name>
              <bitRange>[20:16]</bitRange>
              <description>Transmit FIFO level (number of words to transmit are left in FIFO) </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[15:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>BSY</name>
              <bitRange>[4:4]</bitRange>
              <description>Device busy (1 if data is currently transmitted/received or the transmit FIFO is not empty) </description>
            </field>
            <field>
              <name>RFF</name>
              <bitRange>[3:3]</bitRange>
              <description>Receive FIFO is full (1 if full) </description>
            </field>
            <field>
              <name>RNE</name>
              <bitRange>[2:2]</bitRange>
              <description>Receive FIFO is not empty (0 if empty) </description>
            </field>
            <field>
              <name>TNF</name>
              <bitRange>[1:1]</bitRange>
              <description>Transmit FIFO is not full (0 if full) </description>
            </field>
            <field>
              <name>TFE</name>
              <bitRange>[0:0]</bitRange>
              <description>Transmit FIFO is empty (1 if empty) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'spi_imsc': 0xFF900394-->
          <name>spi_imsc</name>
          <description>SPI Interrupt Mask Set and Clear register: Registers 0x30..0x3C can be used instead of registers 0x00...0x24 to keep netx50 software compliant to netx100/500. IRQ mask is an AND-mask: only raw interrupts with mask bit set can generate a module IRQ. When writing this register, the corresponding interrupt is cleared similar to writing the register spi_icr.  Note: The functionality of this register is similar to the corresponding SQI register sqi_irq_mask.       However, in contrast to this register, setting bits in sqi_irq_mask does not clear the corresponding interrupts.  Note: Both FIFOs (receive and transmit) have a depth of 16. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000007F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>txeim</name>
              <bitRange>[6:6]</bitRange>
              <description>Transmit FIFO empty interrupt mask (for netx100/500 compliance) </description>
            </field>
            <field>
              <name>rxfim</name>
              <bitRange>[5:5]</bitRange>
              <description>Receive FIFO full interrupt mask (for netx100/500 compliance) </description>
            </field>
            <field>
              <name>rxneim</name>
              <bitRange>[4:4]</bitRange>
              <description>Receive FIFO not empty interrupt mask (for netx100/500 compliance) </description>
            </field>
            <field>
              <name>TXIM</name>
              <bitRange>[3:3]</bitRange>
              <description>Transmit FIFO interrupt mask </description>
            </field>
            <field>
              <name>RXIM</name>
              <bitRange>[2:2]</bitRange>
              <description>Receive FIFO interrupt mask </description>
            </field>
            <field>
              <name>RTIM</name>
              <bitRange>[1:1]</bitRange>
              <description>Receive timeout interrupt mask </description>
            </field>
            <field>
              <name>RORIM</name>
              <bitRange>[0:0]</bitRange>
              <description>Receive FIFO overrun interrupt mask </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'spi_ris': 0xFF900398-->
          <name>spi_ris</name>
          <description>SPI interrupt state before masking register (raw interrupt) Registers 0x30..0x3C can be used instead of registers 0x00...0x24 to keep netx50 software compliant to netx100/500. Note: Both FIFOs (receive and transmit) have a depth of 16. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000018</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000007F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>txeris</name>
              <bitRange>[6:6]</bitRange>
              <description>Unmasked transmit FIFO empty interrupt state (for netx100/500 compliance) 1: transmit FIFO is empty 0: transmit FIFO is not empty </description>
            </field>
            <field>
              <name>rxfris</name>
              <bitRange>[5:5]</bitRange>
              <description>Unmasked receive FIFO full interrupt state (for netx100/500 compliance) 1: receive FIFO is full 0: receive FIFO is not full </description>
            </field>
            <field>
              <name>rxneris</name>
              <bitRange>[4:4]</bitRange>
              <description>Unmasked receive FIFO not empty interrupt state (for netx100/500 compliance) 1: receive FIFO is not empty 0: receive FIFO is empty </description>
            </field>
            <field>
              <name>TXRIS</name>
              <bitRange>[3:3]</bitRange>
              <description>Unmasked transmit FIFO interrupt state 1: transmit FIFO level is below spi_cr1.tx_fifo_wm 0: transmit FIFO equals or is higher than spi_cr1.tx_fifo_wm </description>
            </field>
            <field>
              <name>RXRIS</name>
              <bitRange>[2:2]</bitRange>
              <description>Unmasked receive FIFO interrupt state 1: receive FIFO is higher than spi_cr1.rx_fifo_wm 0: receive FIFO is equals or is below spi_cr1.rx_fifo_wm </description>
            </field>
            <field>
              <name>RTRIS</name>
              <bitRange>[1:1]</bitRange>
              <description>Unmasked receive timeout interrupt state Timeout period are 32 SPI clock periods depending on adr_spi_cr0.sck_muladd 1: receive FIFO is not empty and not read out in the passed timeout period 0: receive FIFO is empty or read during the last timeout period </description>
            </field>
            <field>
              <name>RORRIS</name>
              <bitRange>[0:0]</bitRange>
              <description>Unmasked receive FIFO overrun interrupt state 1: receive FIFO overrun error occurred 0: no receive FIFO overrun error occurred </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'spi_mis': 0xFF90039C-->
          <name>spi_mis</name>
          <description>SPI interrupt status register Registers 0x30..0x3C can be used instead of registers 0x00...0x24 to keep netx50 software compliant to netx100/500. Note: Both FIFOs (receive and transmit) have a depth of 16. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000001C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000007F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>txemis</name>
              <bitRange>[6:6]</bitRange>
              <description>Masked transmit FIFO empty interrupt state (for netx100/500 compliance) </description>
            </field>
            <field>
              <name>rxfmis</name>
              <bitRange>[5:5]</bitRange>
              <description>Masked receive FIFO full interrupt state (for netx100/500 compliance) </description>
            </field>
            <field>
              <name>rxnemis</name>
              <bitRange>[4:4]</bitRange>
              <description>Masked receive FIFO not empty interrupt state (for netx100/500 compliance) </description>
            </field>
            <field>
              <name>TXMIS</name>
              <bitRange>[3:3]</bitRange>
              <description>Masked transmit FIFO interrupt state </description>
            </field>
            <field>
              <name>RXMIS</name>
              <bitRange>[2:2]</bitRange>
              <description>Masked receive FIFO interrupt state </description>
            </field>
            <field>
              <name>RTMIS</name>
              <bitRange>[1:1]</bitRange>
              <description>Masked receive timeout interrupt state </description>
            </field>
            <field>
              <name>RORMIS</name>
              <bitRange>[0:0]</bitRange>
              <description>Masked receive FIFO overrun interrupt state </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'spi_icr': 0xFF9003A0-->
          <name>spi_icr</name>
          <description>SPI interrupt clear register Registers 0x30..0x3C can be used instead of registers 0x00...0x24 to keep netx50 software compliant to netx100/500. An interrupt is cleared by writing '1' to the according bit. Note: Both FIFOs (receive and transmit) have a depth of 16. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000007F</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>txeic</name>
              <bitRange>[6:6]</bitRange>
              <description>Clear transmit FIFO empty interrupt (for netx100/500 compliance) </description>
            </field>
            <field>
              <name>rxfic</name>
              <bitRange>[5:5]</bitRange>
              <description>Clear receive FIFO full interrupt (for netx100/500 compliance) </description>
            </field>
            <field>
              <name>rxneic</name>
              <bitRange>[4:4]</bitRange>
              <description>Clear receive FIFO not empty interrupt (for netx100/500 compliance) </description>
            </field>
            <field>
              <name>TXIC</name>
              <bitRange>[3:3]</bitRange>
              <description>PL022 extension: clear transmit FIFO interrupt </description>
            </field>
            <field>
              <name>RXIC</name>
              <bitRange>[2:2]</bitRange>
              <description>PL022 extension: clear receive FIFO interrupt </description>
            </field>
            <field>
              <name>RTIC</name>
              <bitRange>[1:1]</bitRange>
              <description>Clear receive FIFO overrun interrupt </description>
            </field>
            <field>
              <name>RORIC</name>
              <bitRange>[0:0]</bitRange>
              <description>Clear receive FIFO overrun interrupt Writing '1' here will clear the receive FIFO </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'spi_dmacr': 0xFF9003A8-->
          <name>spi_dmacr</name>
          <description>SPI DMA control register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000028</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:2]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>TXDMAE</name>
              <bitRange>[1:1]</bitRange>
              <description>Enable DMA for SPI transmit data. A single request will be generated if the transmit FIFO is not full and spi_cr1.SSE (module enable) is set. Burst requests to the DMA controller will be generated if at least 4 words are writable to the transmit FIFO (set DMA burst size to 4). If this bit is reset or the module is disabled, the DMA request signals will also be reset. Note: set dmac_chctrl.SBSize = 1 (i.e. burst size: 4) in the DMA controller. </description>
            </field>
            <field>
              <name>RXDMAE</name>
              <bitRange>[0:0]</bitRange>
              <description>Enable DMA for SPI receive data. A single request will be generated if the receive FIFO is not empty and spi_cr1.SSE (module enable) is set. Burst request to the DMA controller will be generated if the receive FIFO contains at least 4 words (set DMA burst size to 4). If this bit is reset or the module is disabled, the DMA request signals will also be reset. Note: set dmac_chctrl.SBSize = 1 (i.e. burst size: 4) in the DMA controller. </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'spi_data_register': 0xFF9003B0-->
          <name>spi_data_register</name>
          <description>netx100/500 compliant SPI data register (DR) Registers 0x30..0x3C can be used instead of registers 0x00...0x24 to keep netx50 software compliant to netx100/500. 2 data bytes with valid bits. During a write access data_byte_1 and dr_valid1 must not be used. dr_valid0 must be set. In netx50 and later versions both FIFOs (receive and transmit) have a depth of 16, fill values are fixed to 4. To keep software compatible, not more than 8 bytes should be in netx100/500 FIFOs. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000030</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0003FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:18]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>dr_valid1</name>
              <bitRange>[17:17]</bitRange>
              <description>Obsolete, always 0 </description>
            </field>
            <field>
              <name>dr_valid0</name>
              <bitRange>[16:16]</bitRange>
              <description>Valid bit for data_byte_0 This bit shows if data_byte_0 is valid and must be set during a FIFO write access. </description>
            </field>
            <field>
              <name>data_byte_1</name>
              <bitRange>[15:8]</bitRange>
              <description>Obsolete, don't use </description>
            </field>
            <field>
              <name>data_byte_0</name>
              <bitRange>[7:0]</bitRange>
              <description>Data byte 0 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'spi_status_register': 0xFF9003B4-->
          <name>spi_status_register</name>
          <description>netx100/500 compliant SPI status register (SR): Shows the actual status of the SPI interface. Bits 24..18 show occurred interrupts; writing ones into these bits clears the interrupts. Writing into other bits has no effect. In netx50 and later versions both FIFOs (receive and transmit) have a depth of 16, fill values are fixed to 4. To keep software compatible, not more than 8 bytes should be in netx100/500 FIFOs. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000034</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x03FFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:26]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>SR_selected</name>
              <bitRange>[25:25]</bitRange>
              <description>External master has access to SPI interface </description>
            </field>
            <field>
              <name>SR_out_full</name>
              <bitRange>[24:24]</bitRange>
              <description>Output FIFO is full. This is only with netx100/500 an IRQ. </description>
            </field>
            <field>
              <name>SR_out_empty</name>
              <bitRange>[23:23]</bitRange>
              <description>Output FIFO is empty in slave mode (equals spi_ris.txeris in netx50 and later versions) </description>
            </field>
            <field>
              <name>SR_out_fw</name>
              <bitRange>[22:22]</bitRange>
              <description>netX is writing data too fast into output FIFO. Available as an IRQ only on netx100/500 (equals spi_sr.tx_fifo_err_ovfl in netx50 and later versions). </description>
            </field>
            <field>
              <name>SR_out_fuel</name>
              <bitRange>[21:21]</bitRange>
              <description>Adjustable fill value of output FIFO reached (equals spi_ris.TXRIS in netx50 and later versions) </description>
            </field>
            <field>
              <name>SR_in_full</name>
              <bitRange>[20:20]</bitRange>
              <description>Input FIFO is full (equals spi_ris.rxfris in netx50 and later versions) </description>
            </field>
            <field>
              <name>SR_in_recdata</name>
              <bitRange>[19:19]</bitRange>
              <description>Valid data bytes in input FIFO (equals spi_ris.rxneris in netx50 and later versions) </description>
            </field>
            <field>
              <name>SR_in_fuel</name>
              <bitRange>[18:18]</bitRange>
              <description>Adjustable fill value of input FIFO reached (equals spi_ris.RXRIS in netx50 and later versions) </description>
            </field>
            <field>
              <name>SR_out_fuel_val</name>
              <bitRange>[17:9]</bitRange>
              <description>Output FIFO fill value (number of bytes) </description>
            </field>
            <field>
              <name>SR_in_fuel_val</name>
              <bitRange>[8:0]</bitRange>
              <description>Input FIFO fill value (number of bytes) </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'spi_control_register': 0xFF9003B8-->
          <name>spi_control_register</name>
          <description>netx100/500 compliant SPI control register (CR) </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000038</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFF00FDF</resetMask>
          <fields>
            <field>
              <name>CR_en</name>
              <bitRange>[31:31]</bitRange>
              <description>1: enable 0: disable SPI interface </description>
            </field>
            <field>
              <name>CR_ms</name>
              <bitRange>[30:30]</bitRange>
              <description>1: master mode 0:slave mode </description>
            </field>
            <field>
              <name>CR_cpol</name>
              <bitRange>[29:29]</bitRange>
              <description>1: falling edge of SCK is primary 0: rising edge of SCK is primary </description>
            </field>
            <field>
              <name>CR_ncpha</name>
              <bitRange>[28:28]</bitRange>
              <description>SPI clock phase mode (Note: meaning of this bit is inverted to functionality of bit spi_cr0.SPH): {  | 0: change data on secondary SCK edge data is active on primary SCK edge 1: change data on primary SCK edge data is active on secondary SCK edge } </description>
            </field>
            <field>
              <name>CR_burst</name>
              <bitRange>[27:25]</bitRange>
              <description>netx100/netx500 only, obsolete in later versions: burst length = 2^CR_burst </description>
            </field>
            <field>
              <name>CR_burstdelay</name>
              <bitRange>[24:22]</bitRange>
              <description>netx100/netx500 only, obsolete in later versions: delay between transmission of 2 data bytes (0 to 7 SCK cycles) </description>
            </field>
            <field>
              <name>CR_clr_outfifo</name>
              <bitRange>[21:21]</bitRange>
              <description>Clear output FIFO </description>
            </field>
            <field>
              <name>CR_clr_infifo</name>
              <bitRange>[20:20]</bitRange>
              <description>Clear input FIFO </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[19:12]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>CS_mode</name>
              <bitRange>[11:11]</bitRange>
              <description>1: chip select is generated automatically by the internal state machine 0: chip select is directly controlled by software (see bits CR_ss). </description>
            </field>
            <field>
              <name>CR_ss</name>
              <bitRange>[10:8]</bitRange>
              <description>External slave select </description>
            </field>
            <field>
              <name>CR_write</name>
              <bitRange>[7:7]</bitRange>
              <description>netx100/netx500 only, in later versions always '1':  1: enable SPI interface write data </description>
            </field>
            <field>
              <name>CR_read</name>
              <bitRange>[6:6]</bitRange>
              <description>netx100/netx500 only, in later versions always '1':  1: enable SPI interface read data </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[5:5]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>CR_speed</name>
              <bitRange>[4:1]</bitRange>
              <description>Clock divider for SPI clock (2 - 2^16) If SPI clock rate is changed using spi_cr0.sck_muladd, this value will not be updated and may be incorrect There are 16 different SPI clocks frequencies to choose: 0000: 0.025 MHz (Note: Not compatible to netx100/500. '0000' freezes SCK in netx100/500.) 0001: 0.05 MHz 0010: 0.1 MHz 0011: 0.2 MHz 0100: 0.5 MHz 0101: 1 MHz 0110: 1.25 MHz 0111: 2 MHz 1000: 2.5 MHz 1001: 3.3333 MHz 1010: 5 MHz 1011: 10 MHz 1100: 12.5 MHz 1101: 16.6666 MHz 1110: 25 MHz 1111: 50 MHz </description>
            </field>
            <field>
              <name>CR_softreset</name>
              <bitRange>[0:0]</bitRange>
              <description>write only: no function in netx100/netx500; later versions: clears IRQs and FIFOs </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'spi_interrupt_control_register': 0xFF9003BC-->
          <name>spi_interrupt_control_register</name>
          <description>netx100/500 compliant SPI interrupt control register (IR) In netx50 and later versions both FIFOs (receive and transmit) have a depth of 16, fill values are fixed to 4. To keep software compatible, not more than 8 bytes should be in netx100/500 FIFOs. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000003C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x01FFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:25]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>IR_out_full_en</name>
              <bitRange>[24:24]</bitRange>
              <description>IRQ enable for irq_spi(6), netx100/netx500 only, always '0' in later versions </description>
            </field>
            <field>
              <name>IR_out_empty_en</name>
              <bitRange>[23:23]</bitRange>
              <description>IRQ enable for irq_spi(5)  (equals spi_imsc.rxeim in netx50 and later versions) </description>
            </field>
            <field>
              <name>IR_out_fw_en</name>
              <bitRange>[22:22]</bitRange>
              <description>IRQ enable for irq_spi(4), netx100/netx500 only, always '0' in later versions </description>
            </field>
            <field>
              <name>IR_out_fuel_en</name>
              <bitRange>[21:21]</bitRange>
              <description>IRQ enable for irq_spi(3)  (equals spi_imsc.TXIM in netx50 and later versions) </description>
            </field>
            <field>
              <name>IR_in_full_en</name>
              <bitRange>[20:20]</bitRange>
              <description>IRQ enable for irq_spi(2)  (equals spi_imsc.txfim in netx50 and later versions) </description>
            </field>
            <field>
              <name>IR_in_recdata_en</name>
              <bitRange>[19:19]</bitRange>
              <description>IRQ enable for irq_spi(1)  (equals spi_imsc.txneim in netx50 and later versions) </description>
            </field>
            <field>
              <name>IR_in_fuel_en</name>
              <bitRange>[18:18]</bitRange>
              <description>IRQ enable for irq_spi(0)  (equals spi_imsc.RXIM in netx50 and later versions) </description>
            </field>
            <field>
              <name>IR_out_fuel</name>
              <bitRange>[17:9]</bitRange>
              <description>Adjustable watermark level of output FIFO </description>
            </field>
            <field>
              <name>IR_in_fuel</name>
              <bitRange>[8:0]</bitRange>
              <description>Adjustable watermark level of input FIFO </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>xlink0</name>
      <description>xlink0</description>
      <baseAddress>0xFF900400</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>16</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <!--Absolute address of 'xlink_cfg': 0xFF900400-->
          <name>xlink_cfg</name>
          <description>configuration register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xB4A0001B</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>end_spl</name>
              <bitRange>[31:28]</bitRange>
              <description>end sample point  for receive data </description>
            </field>
            <field>
              <name>start_spl</name>
              <bitRange>[27:24]</bitRange>
              <description>start sample point for receive data a sample period is defined as 1/16 of the bitrate period range: 0x0 - 0xf note: settings for start_spl and end_spl should always fulfill the condition: (start_spl &lt; end_spl) </description>
            </field>
            <field>
              <name>bits2rec</name>
              <bitRange>[23:20]</bitRange>
              <description>count of bits to receive note: the reset value expect: 1stopbit, 8databits, 1paritybit and 1stopbit </description>
            </field>
            <field>
              <name>cnt_da</name>
              <bitRange>[19:19]</bitRange>
              <description>test feature, do not set this bit! </description>
            </field>
            <field>
              <name>bclk2oe_en</name>
              <bitRange>[18:18]</bitRange>
              <description>test feature, do not set this bit! </description>
            </field>
            <field>
              <name>fb_en</name>
              <bitRange>[17:17]</bitRange>
              <description>test feature, enable internal feedback </description>
            </field>
            <field>
              <name>xlink_en</name>
              <bitRange>[16:16]</bitRange>
              <description>disable the output enable, and activity </description>
            </field>
            <field>
              <name>rate_inc</name>
              <bitRange>[15:0]</bitRange>
              <description>bitrate compare value for bit clock counter (bit_cnt) BITRATE = 100e6/(rate_inc) typical settings for IOLINK: {| cols=4 BIT_RATE | rate_inc | clock period | calc: 1/BIT_RATE 4800     | 0x5160   | 208,33 us    | 208,3333us 38400    | 0xa2b    |  26,04 us    |  26,04167us 230400   | 0x1b1    |   4,34 us    |   4,340278us ...      |          | invalid: 0   | 0        | 0            | 0 } </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xlink_tx': 0xFF900404-->
          <name>xlink_tx</name>
          <description>xlink transmit register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00030000</resetValue>
          <resetMask>0x0003FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:18]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>idle_ro</name>
              <bitRange>[17:17]</bitRange>
              <description>indicates no activity on tx </description>
            </field>
            <field>
              <name>rdy_ro</name>
              <bitRange>[16:16]</bitRange>
              <description>TX buffer ready (valid on ready) 0 TX buffer not ready 1 TX buffer ready </description>
            </field>
            <field>
              <name>hold</name>
              <bitRange>[15:0]</bitRange>
              <description>hold register format for a valid serial DATA sequence: &lt;-ctrl.DATA-&gt;&lt;------------------- serial DATA --------------------&gt; { END_BIT:1 }[{STOPBIT:1}{DATABITS max. 12:0101..0010}{STARTBIT:0}] notes: ENDBIT is a hardware marker to stop the shifting, and will not be transmitted. this condition implied, than all other not used bits should be zero </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xlink_rx': 0xFF900408-->
          <name>xlink_rx</name>
          <description>xlink RX register writing to the register, reset the ready bit, the overflow bit and the sampling error bit </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000FFFF</resetValue>
          <resetMask>0x0039FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:22]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>spl_err_ro</name>
              <bitRange>[21:21]</bitRange>
              <description>sampling error detected if the amount of sampled bits (HI or LOW) do not fulfill the condition: (end_spl - start_spl) &lt; (count of HI/LOW bits) </description>
            </field>
            <field>
              <name>ovf_err_ro</name>
              <bitRange>[20:20]</bitRange>
              <description>overflow error on received data </description>
            </field>
            <field>
              <name>rxd_ro</name>
              <bitRange>[19:19]</bitRange>
              <description>current status of rx data </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[18:17]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>rdy_ro</name>
              <bitRange>[16:16]</bitRange>
              <description>RX buffer ready (valid on ready) 0 RX buffer not ready 1 RX buffer ready </description>
            </field>
            <field>
              <name>hold_ro</name>
              <bitRange>[15:0]</bitRange>
              <description>RX byte (when valid) hold[15:0] is used to shift in RX(LSB first!) the amount of shifted bits is defined by bits2rec shift order is bit15 downto bit0 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xlink_stat': 0xFF90040C-->
          <name>xlink_stat</name>
          <description>xlink status register &amp; io control writing to this register set the bit clock counter to zero! </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x01000000</resetValue>
          <resetMask>0x01FFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:25]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>filter_en</name>
              <bitRange>[24:24]</bitRange>
              <description>enable 3 majority ruling filter </description>
            </field>
            <field>
              <name>set_wakeup</name>
              <bitRange>[23:23]</bitRange>
              <description>set the wakeup port </description>
            </field>
            <field>
              <name>set_txoe</name>
              <bitRange>[22:22]</bitRange>
              <description>set the tx output enable </description>
            </field>
            <field>
              <name>set_tx</name>
              <bitRange>[21:21]</bitRange>
              <description>set the tx port, </description>
            </field>
            <field>
              <name>io_mode</name>
              <bitRange>[20:20]</bitRange>
              <description>enable the io mode on tx and wakeup 0 : disable io function on tx, txoe, wakeup 1 : enable io function on tx, txoe, wakeup </description>
            </field>
            <field>
              <name>txoe_ro</name>
              <bitRange>[19:19]</bitRange>
              <description>status of tx output enable </description>
            </field>
            <field>
              <name>rxo_ro</name>
              <bitRange>[18:18]</bitRange>
              <description>status of rx input </description>
            </field>
            <field>
              <name>txo_ro</name>
              <bitRange>[17:17]</bitRange>
              <description>status of tx output </description>
            </field>
            <field>
              <name>bit_clk_ro</name>
              <bitRange>[16:16]</bitRange>
              <description>status of bit clock signal </description>
            </field>
            <field>
              <name>bit_cnt_ro</name>
              <bitRange>[15:0]</bitRange>
              <description>status of bit clock counter </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>xlink1</name>
      <description>xlink1</description>
      <baseAddress>0xFF900410</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>16</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <!--Absolute address of 'xlink_cfg': 0xFF900410-->
          <name>xlink_cfg</name>
          <description>configuration register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xB4A0001B</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>end_spl</name>
              <bitRange>[31:28]</bitRange>
              <description>end sample point  for receive data </description>
            </field>
            <field>
              <name>start_spl</name>
              <bitRange>[27:24]</bitRange>
              <description>start sample point for receive data a sample period is defined as 1/16 of the bitrate period range: 0x0 - 0xf note: settings for start_spl and end_spl should always fulfill the condition: (start_spl &lt; end_spl) </description>
            </field>
            <field>
              <name>bits2rec</name>
              <bitRange>[23:20]</bitRange>
              <description>count of bits to receive note: the reset value expect: 1stopbit, 8databits, 1paritybit and 1stopbit </description>
            </field>
            <field>
              <name>cnt_da</name>
              <bitRange>[19:19]</bitRange>
              <description>test feature, do not set this bit! </description>
            </field>
            <field>
              <name>bclk2oe_en</name>
              <bitRange>[18:18]</bitRange>
              <description>test feature, do not set this bit! </description>
            </field>
            <field>
              <name>fb_en</name>
              <bitRange>[17:17]</bitRange>
              <description>test feature, enable internal feedback </description>
            </field>
            <field>
              <name>xlink_en</name>
              <bitRange>[16:16]</bitRange>
              <description>disable the output enable, and activity </description>
            </field>
            <field>
              <name>rate_inc</name>
              <bitRange>[15:0]</bitRange>
              <description>bitrate compare value for bit clock counter (bit_cnt) BITRATE = 100e6/(rate_inc) typical settings for IOLINK: {| cols=4 BIT_RATE | rate_inc | clock period | calc: 1/BIT_RATE 4800     | 0x5160   | 208,33 us    | 208,3333us 38400    | 0xa2b    |  26,04 us    |  26,04167us 230400   | 0x1b1    |   4,34 us    |   4,340278us ...      |          | invalid: 0   | 0        | 0            | 0 } </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xlink_tx': 0xFF900414-->
          <name>xlink_tx</name>
          <description>xlink transmit register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00030000</resetValue>
          <resetMask>0x0003FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:18]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>idle_ro</name>
              <bitRange>[17:17]</bitRange>
              <description>indicates no activity on tx </description>
            </field>
            <field>
              <name>rdy_ro</name>
              <bitRange>[16:16]</bitRange>
              <description>TX buffer ready (valid on ready) 0 TX buffer not ready 1 TX buffer ready </description>
            </field>
            <field>
              <name>hold</name>
              <bitRange>[15:0]</bitRange>
              <description>hold register format for a valid serial DATA sequence: &lt;-ctrl.DATA-&gt;&lt;------------------- serial DATA --------------------&gt; { END_BIT:1 }[{STOPBIT:1}{DATABITS max. 12:0101..0010}{STARTBIT:0}] notes: ENDBIT is a hardware marker to stop the shifting, and will not be transmitted. this condition implied, than all other not used bits should be zero </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xlink_rx': 0xFF900418-->
          <name>xlink_rx</name>
          <description>xlink RX register writing to the register, reset the ready bit, the overflow bit and the sampling error bit </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000FFFF</resetValue>
          <resetMask>0x0039FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:22]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>spl_err_ro</name>
              <bitRange>[21:21]</bitRange>
              <description>sampling error detected if the amount of sampled bits (HI or LOW) do not fulfill the condition: (end_spl - start_spl) &lt; (count of HI/LOW bits) </description>
            </field>
            <field>
              <name>ovf_err_ro</name>
              <bitRange>[20:20]</bitRange>
              <description>overflow error on received data </description>
            </field>
            <field>
              <name>rxd_ro</name>
              <bitRange>[19:19]</bitRange>
              <description>current status of rx data </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[18:17]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>rdy_ro</name>
              <bitRange>[16:16]</bitRange>
              <description>RX buffer ready (valid on ready) 0 RX buffer not ready 1 RX buffer ready </description>
            </field>
            <field>
              <name>hold_ro</name>
              <bitRange>[15:0]</bitRange>
              <description>RX byte (when valid) hold[15:0] is used to shift in RX(LSB first!) the amount of shifted bits is defined by bits2rec shift order is bit15 downto bit0 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xlink_stat': 0xFF90041C-->
          <name>xlink_stat</name>
          <description>xlink status register &amp; io control writing to this register set the bit clock counter to zero! </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x01000000</resetValue>
          <resetMask>0x01FFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:25]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>filter_en</name>
              <bitRange>[24:24]</bitRange>
              <description>enable 3 majority ruling filter </description>
            </field>
            <field>
              <name>set_wakeup</name>
              <bitRange>[23:23]</bitRange>
              <description>set the wakeup port </description>
            </field>
            <field>
              <name>set_txoe</name>
              <bitRange>[22:22]</bitRange>
              <description>set the tx output enable </description>
            </field>
            <field>
              <name>set_tx</name>
              <bitRange>[21:21]</bitRange>
              <description>set the tx port, </description>
            </field>
            <field>
              <name>io_mode</name>
              <bitRange>[20:20]</bitRange>
              <description>enable the io mode on tx and wakeup 0 : disable io function on tx, txoe, wakeup 1 : enable io function on tx, txoe, wakeup </description>
            </field>
            <field>
              <name>txoe_ro</name>
              <bitRange>[19:19]</bitRange>
              <description>status of tx output enable </description>
            </field>
            <field>
              <name>rxo_ro</name>
              <bitRange>[18:18]</bitRange>
              <description>status of rx input </description>
            </field>
            <field>
              <name>txo_ro</name>
              <bitRange>[17:17]</bitRange>
              <description>status of tx output </description>
            </field>
            <field>
              <name>bit_clk_ro</name>
              <bitRange>[16:16]</bitRange>
              <description>status of bit clock signal </description>
            </field>
            <field>
              <name>bit_cnt_ro</name>
              <bitRange>[15:0]</bitRange>
              <description>status of bit clock counter </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>xlink2</name>
      <description>xlink2</description>
      <baseAddress>0xFF900420</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>16</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <!--Absolute address of 'xlink_cfg': 0xFF900420-->
          <name>xlink_cfg</name>
          <description>configuration register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xB4A0001B</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>end_spl</name>
              <bitRange>[31:28]</bitRange>
              <description>end sample point  for receive data </description>
            </field>
            <field>
              <name>start_spl</name>
              <bitRange>[27:24]</bitRange>
              <description>start sample point for receive data a sample period is defined as 1/16 of the bitrate period range: 0x0 - 0xf note: settings for start_spl and end_spl should always fulfill the condition: (start_spl &lt; end_spl) </description>
            </field>
            <field>
              <name>bits2rec</name>
              <bitRange>[23:20]</bitRange>
              <description>count of bits to receive note: the reset value expect: 1stopbit, 8databits, 1paritybit and 1stopbit </description>
            </field>
            <field>
              <name>cnt_da</name>
              <bitRange>[19:19]</bitRange>
              <description>test feature, do not set this bit! </description>
            </field>
            <field>
              <name>bclk2oe_en</name>
              <bitRange>[18:18]</bitRange>
              <description>test feature, do not set this bit! </description>
            </field>
            <field>
              <name>fb_en</name>
              <bitRange>[17:17]</bitRange>
              <description>test feature, enable internal feedback </description>
            </field>
            <field>
              <name>xlink_en</name>
              <bitRange>[16:16]</bitRange>
              <description>disable the output enable, and activity </description>
            </field>
            <field>
              <name>rate_inc</name>
              <bitRange>[15:0]</bitRange>
              <description>bitrate compare value for bit clock counter (bit_cnt) BITRATE = 100e6/(rate_inc) typical settings for IOLINK: {| cols=4 BIT_RATE | rate_inc | clock period | calc: 1/BIT_RATE 4800     | 0x5160   | 208,33 us    | 208,3333us 38400    | 0xa2b    |  26,04 us    |  26,04167us 230400   | 0x1b1    |   4,34 us    |   4,340278us ...      |          | invalid: 0   | 0        | 0            | 0 } </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xlink_tx': 0xFF900424-->
          <name>xlink_tx</name>
          <description>xlink transmit register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00030000</resetValue>
          <resetMask>0x0003FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:18]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>idle_ro</name>
              <bitRange>[17:17]</bitRange>
              <description>indicates no activity on tx </description>
            </field>
            <field>
              <name>rdy_ro</name>
              <bitRange>[16:16]</bitRange>
              <description>TX buffer ready (valid on ready) 0 TX buffer not ready 1 TX buffer ready </description>
            </field>
            <field>
              <name>hold</name>
              <bitRange>[15:0]</bitRange>
              <description>hold register format for a valid serial DATA sequence: &lt;-ctrl.DATA-&gt;&lt;------------------- serial DATA --------------------&gt; { END_BIT:1 }[{STOPBIT:1}{DATABITS max. 12:0101..0010}{STARTBIT:0}] notes: ENDBIT is a hardware marker to stop the shifting, and will not be transmitted. this condition implied, than all other not used bits should be zero </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xlink_rx': 0xFF900428-->
          <name>xlink_rx</name>
          <description>xlink RX register writing to the register, reset the ready bit, the overflow bit and the sampling error bit </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000FFFF</resetValue>
          <resetMask>0x0039FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:22]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>spl_err_ro</name>
              <bitRange>[21:21]</bitRange>
              <description>sampling error detected if the amount of sampled bits (HI or LOW) do not fulfill the condition: (end_spl - start_spl) &lt; (count of HI/LOW bits) </description>
            </field>
            <field>
              <name>ovf_err_ro</name>
              <bitRange>[20:20]</bitRange>
              <description>overflow error on received data </description>
            </field>
            <field>
              <name>rxd_ro</name>
              <bitRange>[19:19]</bitRange>
              <description>current status of rx data </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[18:17]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>rdy_ro</name>
              <bitRange>[16:16]</bitRange>
              <description>RX buffer ready (valid on ready) 0 RX buffer not ready 1 RX buffer ready </description>
            </field>
            <field>
              <name>hold_ro</name>
              <bitRange>[15:0]</bitRange>
              <description>RX byte (when valid) hold[15:0] is used to shift in RX(LSB first!) the amount of shifted bits is defined by bits2rec shift order is bit15 downto bit0 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xlink_stat': 0xFF90042C-->
          <name>xlink_stat</name>
          <description>xlink status register &amp; io control writing to this register set the bit clock counter to zero! </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x01000000</resetValue>
          <resetMask>0x01FFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:25]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>filter_en</name>
              <bitRange>[24:24]</bitRange>
              <description>enable 3 majority ruling filter </description>
            </field>
            <field>
              <name>set_wakeup</name>
              <bitRange>[23:23]</bitRange>
              <description>set the wakeup port </description>
            </field>
            <field>
              <name>set_txoe</name>
              <bitRange>[22:22]</bitRange>
              <description>set the tx output enable </description>
            </field>
            <field>
              <name>set_tx</name>
              <bitRange>[21:21]</bitRange>
              <description>set the tx port, </description>
            </field>
            <field>
              <name>io_mode</name>
              <bitRange>[20:20]</bitRange>
              <description>enable the io mode on tx and wakeup 0 : disable io function on tx, txoe, wakeup 1 : enable io function on tx, txoe, wakeup </description>
            </field>
            <field>
              <name>txoe_ro</name>
              <bitRange>[19:19]</bitRange>
              <description>status of tx output enable </description>
            </field>
            <field>
              <name>rxo_ro</name>
              <bitRange>[18:18]</bitRange>
              <description>status of rx input </description>
            </field>
            <field>
              <name>txo_ro</name>
              <bitRange>[17:17]</bitRange>
              <description>status of tx output </description>
            </field>
            <field>
              <name>bit_clk_ro</name>
              <bitRange>[16:16]</bitRange>
              <description>status of bit clock signal </description>
            </field>
            <field>
              <name>bit_cnt_ro</name>
              <bitRange>[15:0]</bitRange>
              <description>status of bit clock counter </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>xlink3</name>
      <description>xlink3</description>
      <baseAddress>0xFF900430</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>16</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <!--Absolute address of 'xlink_cfg': 0xFF900430-->
          <name>xlink_cfg</name>
          <description>configuration register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xB4A0001B</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>end_spl</name>
              <bitRange>[31:28]</bitRange>
              <description>end sample point  for receive data </description>
            </field>
            <field>
              <name>start_spl</name>
              <bitRange>[27:24]</bitRange>
              <description>start sample point for receive data a sample period is defined as 1/16 of the bitrate period range: 0x0 - 0xf note: settings for start_spl and end_spl should always fulfill the condition: (start_spl &lt; end_spl) </description>
            </field>
            <field>
              <name>bits2rec</name>
              <bitRange>[23:20]</bitRange>
              <description>count of bits to receive note: the reset value expect: 1stopbit, 8databits, 1paritybit and 1stopbit </description>
            </field>
            <field>
              <name>cnt_da</name>
              <bitRange>[19:19]</bitRange>
              <description>test feature, do not set this bit! </description>
            </field>
            <field>
              <name>bclk2oe_en</name>
              <bitRange>[18:18]</bitRange>
              <description>test feature, do not set this bit! </description>
            </field>
            <field>
              <name>fb_en</name>
              <bitRange>[17:17]</bitRange>
              <description>test feature, enable internal feedback </description>
            </field>
            <field>
              <name>xlink_en</name>
              <bitRange>[16:16]</bitRange>
              <description>disable the output enable, and activity </description>
            </field>
            <field>
              <name>rate_inc</name>
              <bitRange>[15:0]</bitRange>
              <description>bitrate compare value for bit clock counter (bit_cnt) BITRATE = 100e6/(rate_inc) typical settings for IOLINK: {| cols=4 BIT_RATE | rate_inc | clock period | calc: 1/BIT_RATE 4800     | 0x5160   | 208,33 us    | 208,3333us 38400    | 0xa2b    |  26,04 us    |  26,04167us 230400   | 0x1b1    |   4,34 us    |   4,340278us ...      |          | invalid: 0   | 0        | 0            | 0 } </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xlink_tx': 0xFF900434-->
          <name>xlink_tx</name>
          <description>xlink transmit register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00030000</resetValue>
          <resetMask>0x0003FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:18]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>idle_ro</name>
              <bitRange>[17:17]</bitRange>
              <description>indicates no activity on tx </description>
            </field>
            <field>
              <name>rdy_ro</name>
              <bitRange>[16:16]</bitRange>
              <description>TX buffer ready (valid on ready) 0 TX buffer not ready 1 TX buffer ready </description>
            </field>
            <field>
              <name>hold</name>
              <bitRange>[15:0]</bitRange>
              <description>hold register format for a valid serial DATA sequence: &lt;-ctrl.DATA-&gt;&lt;------------------- serial DATA --------------------&gt; { END_BIT:1 }[{STOPBIT:1}{DATABITS max. 12:0101..0010}{STARTBIT:0}] notes: ENDBIT is a hardware marker to stop the shifting, and will not be transmitted. this condition implied, than all other not used bits should be zero </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xlink_rx': 0xFF900438-->
          <name>xlink_rx</name>
          <description>xlink RX register writing to the register, reset the ready bit, the overflow bit and the sampling error bit </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000FFFF</resetValue>
          <resetMask>0x0039FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:22]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>spl_err_ro</name>
              <bitRange>[21:21]</bitRange>
              <description>sampling error detected if the amount of sampled bits (HI or LOW) do not fulfill the condition: (end_spl - start_spl) &lt; (count of HI/LOW bits) </description>
            </field>
            <field>
              <name>ovf_err_ro</name>
              <bitRange>[20:20]</bitRange>
              <description>overflow error on received data </description>
            </field>
            <field>
              <name>rxd_ro</name>
              <bitRange>[19:19]</bitRange>
              <description>current status of rx data </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[18:17]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>rdy_ro</name>
              <bitRange>[16:16]</bitRange>
              <description>RX buffer ready (valid on ready) 0 RX buffer not ready 1 RX buffer ready </description>
            </field>
            <field>
              <name>hold_ro</name>
              <bitRange>[15:0]</bitRange>
              <description>RX byte (when valid) hold[15:0] is used to shift in RX(LSB first!) the amount of shifted bits is defined by bits2rec shift order is bit15 downto bit0 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xlink_stat': 0xFF90043C-->
          <name>xlink_stat</name>
          <description>xlink status register &amp; io control writing to this register set the bit clock counter to zero! </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x01000000</resetValue>
          <resetMask>0x01FFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:25]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>filter_en</name>
              <bitRange>[24:24]</bitRange>
              <description>enable 3 majority ruling filter </description>
            </field>
            <field>
              <name>set_wakeup</name>
              <bitRange>[23:23]</bitRange>
              <description>set the wakeup port </description>
            </field>
            <field>
              <name>set_txoe</name>
              <bitRange>[22:22]</bitRange>
              <description>set the tx output enable </description>
            </field>
            <field>
              <name>set_tx</name>
              <bitRange>[21:21]</bitRange>
              <description>set the tx port, </description>
            </field>
            <field>
              <name>io_mode</name>
              <bitRange>[20:20]</bitRange>
              <description>enable the io mode on tx and wakeup 0 : disable io function on tx, txoe, wakeup 1 : enable io function on tx, txoe, wakeup </description>
            </field>
            <field>
              <name>txoe_ro</name>
              <bitRange>[19:19]</bitRange>
              <description>status of tx output enable </description>
            </field>
            <field>
              <name>rxo_ro</name>
              <bitRange>[18:18]</bitRange>
              <description>status of rx input </description>
            </field>
            <field>
              <name>txo_ro</name>
              <bitRange>[17:17]</bitRange>
              <description>status of tx output </description>
            </field>
            <field>
              <name>bit_clk_ro</name>
              <bitRange>[16:16]</bitRange>
              <description>status of bit clock signal </description>
            </field>
            <field>
              <name>bit_cnt_ro</name>
              <bitRange>[15:0]</bitRange>
              <description>status of bit clock counter </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>xlink4</name>
      <description>xlink4</description>
      <baseAddress>0xFF900440</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>16</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <!--Absolute address of 'xlink_cfg': 0xFF900440-->
          <name>xlink_cfg</name>
          <description>configuration register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xB4A0001B</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>end_spl</name>
              <bitRange>[31:28]</bitRange>
              <description>end sample point  for receive data </description>
            </field>
            <field>
              <name>start_spl</name>
              <bitRange>[27:24]</bitRange>
              <description>start sample point for receive data a sample period is defined as 1/16 of the bitrate period range: 0x0 - 0xf note: settings for start_spl and end_spl should always fulfill the condition: (start_spl &lt; end_spl) </description>
            </field>
            <field>
              <name>bits2rec</name>
              <bitRange>[23:20]</bitRange>
              <description>count of bits to receive note: the reset value expect: 1stopbit, 8databits, 1paritybit and 1stopbit </description>
            </field>
            <field>
              <name>cnt_da</name>
              <bitRange>[19:19]</bitRange>
              <description>test feature, do not set this bit! </description>
            </field>
            <field>
              <name>bclk2oe_en</name>
              <bitRange>[18:18]</bitRange>
              <description>test feature, do not set this bit! </description>
            </field>
            <field>
              <name>fb_en</name>
              <bitRange>[17:17]</bitRange>
              <description>test feature, enable internal feedback </description>
            </field>
            <field>
              <name>xlink_en</name>
              <bitRange>[16:16]</bitRange>
              <description>disable the output enable, and activity </description>
            </field>
            <field>
              <name>rate_inc</name>
              <bitRange>[15:0]</bitRange>
              <description>bitrate compare value for bit clock counter (bit_cnt) BITRATE = 100e6/(rate_inc) typical settings for IOLINK: {| cols=4 BIT_RATE | rate_inc | clock period | calc: 1/BIT_RATE 4800     | 0x5160   | 208,33 us    | 208,3333us 38400    | 0xa2b    |  26,04 us    |  26,04167us 230400   | 0x1b1    |   4,34 us    |   4,340278us ...      |          | invalid: 0   | 0        | 0            | 0 } </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xlink_tx': 0xFF900444-->
          <name>xlink_tx</name>
          <description>xlink transmit register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00030000</resetValue>
          <resetMask>0x0003FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:18]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>idle_ro</name>
              <bitRange>[17:17]</bitRange>
              <description>indicates no activity on tx </description>
            </field>
            <field>
              <name>rdy_ro</name>
              <bitRange>[16:16]</bitRange>
              <description>TX buffer ready (valid on ready) 0 TX buffer not ready 1 TX buffer ready </description>
            </field>
            <field>
              <name>hold</name>
              <bitRange>[15:0]</bitRange>
              <description>hold register format for a valid serial DATA sequence: &lt;-ctrl.DATA-&gt;&lt;------------------- serial DATA --------------------&gt; { END_BIT:1 }[{STOPBIT:1}{DATABITS max. 12:0101..0010}{STARTBIT:0}] notes: ENDBIT is a hardware marker to stop the shifting, and will not be transmitted. this condition implied, than all other not used bits should be zero </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xlink_rx': 0xFF900448-->
          <name>xlink_rx</name>
          <description>xlink RX register writing to the register, reset the ready bit, the overflow bit and the sampling error bit </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000FFFF</resetValue>
          <resetMask>0x0039FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:22]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>spl_err_ro</name>
              <bitRange>[21:21]</bitRange>
              <description>sampling error detected if the amount of sampled bits (HI or LOW) do not fulfill the condition: (end_spl - start_spl) &lt; (count of HI/LOW bits) </description>
            </field>
            <field>
              <name>ovf_err_ro</name>
              <bitRange>[20:20]</bitRange>
              <description>overflow error on received data </description>
            </field>
            <field>
              <name>rxd_ro</name>
              <bitRange>[19:19]</bitRange>
              <description>current status of rx data </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[18:17]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>rdy_ro</name>
              <bitRange>[16:16]</bitRange>
              <description>RX buffer ready (valid on ready) 0 RX buffer not ready 1 RX buffer ready </description>
            </field>
            <field>
              <name>hold_ro</name>
              <bitRange>[15:0]</bitRange>
              <description>RX byte (when valid) hold[15:0] is used to shift in RX(LSB first!) the amount of shifted bits is defined by bits2rec shift order is bit15 downto bit0 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xlink_stat': 0xFF90044C-->
          <name>xlink_stat</name>
          <description>xlink status register &amp; io control writing to this register set the bit clock counter to zero! </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x01000000</resetValue>
          <resetMask>0x01FFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:25]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>filter_en</name>
              <bitRange>[24:24]</bitRange>
              <description>enable 3 majority ruling filter </description>
            </field>
            <field>
              <name>set_wakeup</name>
              <bitRange>[23:23]</bitRange>
              <description>set the wakeup port </description>
            </field>
            <field>
              <name>set_txoe</name>
              <bitRange>[22:22]</bitRange>
              <description>set the tx output enable </description>
            </field>
            <field>
              <name>set_tx</name>
              <bitRange>[21:21]</bitRange>
              <description>set the tx port, </description>
            </field>
            <field>
              <name>io_mode</name>
              <bitRange>[20:20]</bitRange>
              <description>enable the io mode on tx and wakeup 0 : disable io function on tx, txoe, wakeup 1 : enable io function on tx, txoe, wakeup </description>
            </field>
            <field>
              <name>txoe_ro</name>
              <bitRange>[19:19]</bitRange>
              <description>status of tx output enable </description>
            </field>
            <field>
              <name>rxo_ro</name>
              <bitRange>[18:18]</bitRange>
              <description>status of rx input </description>
            </field>
            <field>
              <name>txo_ro</name>
              <bitRange>[17:17]</bitRange>
              <description>status of tx output </description>
            </field>
            <field>
              <name>bit_clk_ro</name>
              <bitRange>[16:16]</bitRange>
              <description>status of bit clock signal </description>
            </field>
            <field>
              <name>bit_cnt_ro</name>
              <bitRange>[15:0]</bitRange>
              <description>status of bit clock counter </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>xlink5</name>
      <description>xlink5</description>
      <baseAddress>0xFF900450</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>16</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <!--Absolute address of 'xlink_cfg': 0xFF900450-->
          <name>xlink_cfg</name>
          <description>configuration register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xB4A0001B</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>end_spl</name>
              <bitRange>[31:28]</bitRange>
              <description>end sample point  for receive data </description>
            </field>
            <field>
              <name>start_spl</name>
              <bitRange>[27:24]</bitRange>
              <description>start sample point for receive data a sample period is defined as 1/16 of the bitrate period range: 0x0 - 0xf note: settings for start_spl and end_spl should always fulfill the condition: (start_spl &lt; end_spl) </description>
            </field>
            <field>
              <name>bits2rec</name>
              <bitRange>[23:20]</bitRange>
              <description>count of bits to receive note: the reset value expect: 1stopbit, 8databits, 1paritybit and 1stopbit </description>
            </field>
            <field>
              <name>cnt_da</name>
              <bitRange>[19:19]</bitRange>
              <description>test feature, do not set this bit! </description>
            </field>
            <field>
              <name>bclk2oe_en</name>
              <bitRange>[18:18]</bitRange>
              <description>test feature, do not set this bit! </description>
            </field>
            <field>
              <name>fb_en</name>
              <bitRange>[17:17]</bitRange>
              <description>test feature, enable internal feedback </description>
            </field>
            <field>
              <name>xlink_en</name>
              <bitRange>[16:16]</bitRange>
              <description>disable the output enable, and activity </description>
            </field>
            <field>
              <name>rate_inc</name>
              <bitRange>[15:0]</bitRange>
              <description>bitrate compare value for bit clock counter (bit_cnt) BITRATE = 100e6/(rate_inc) typical settings for IOLINK: {| cols=4 BIT_RATE | rate_inc | clock period | calc: 1/BIT_RATE 4800     | 0x5160   | 208,33 us    | 208,3333us 38400    | 0xa2b    |  26,04 us    |  26,04167us 230400   | 0x1b1    |   4,34 us    |   4,340278us ...      |          | invalid: 0   | 0        | 0            | 0 } </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xlink_tx': 0xFF900454-->
          <name>xlink_tx</name>
          <description>xlink transmit register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00030000</resetValue>
          <resetMask>0x0003FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:18]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>idle_ro</name>
              <bitRange>[17:17]</bitRange>
              <description>indicates no activity on tx </description>
            </field>
            <field>
              <name>rdy_ro</name>
              <bitRange>[16:16]</bitRange>
              <description>TX buffer ready (valid on ready) 0 TX buffer not ready 1 TX buffer ready </description>
            </field>
            <field>
              <name>hold</name>
              <bitRange>[15:0]</bitRange>
              <description>hold register format for a valid serial DATA sequence: &lt;-ctrl.DATA-&gt;&lt;------------------- serial DATA --------------------&gt; { END_BIT:1 }[{STOPBIT:1}{DATABITS max. 12:0101..0010}{STARTBIT:0}] notes: ENDBIT is a hardware marker to stop the shifting, and will not be transmitted. this condition implied, than all other not used bits should be zero </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xlink_rx': 0xFF900458-->
          <name>xlink_rx</name>
          <description>xlink RX register writing to the register, reset the ready bit, the overflow bit and the sampling error bit </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000FFFF</resetValue>
          <resetMask>0x0039FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:22]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>spl_err_ro</name>
              <bitRange>[21:21]</bitRange>
              <description>sampling error detected if the amount of sampled bits (HI or LOW) do not fulfill the condition: (end_spl - start_spl) &lt; (count of HI/LOW bits) </description>
            </field>
            <field>
              <name>ovf_err_ro</name>
              <bitRange>[20:20]</bitRange>
              <description>overflow error on received data </description>
            </field>
            <field>
              <name>rxd_ro</name>
              <bitRange>[19:19]</bitRange>
              <description>current status of rx data </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[18:17]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>rdy_ro</name>
              <bitRange>[16:16]</bitRange>
              <description>RX buffer ready (valid on ready) 0 RX buffer not ready 1 RX buffer ready </description>
            </field>
            <field>
              <name>hold_ro</name>
              <bitRange>[15:0]</bitRange>
              <description>RX byte (when valid) hold[15:0] is used to shift in RX(LSB first!) the amount of shifted bits is defined by bits2rec shift order is bit15 downto bit0 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xlink_stat': 0xFF90045C-->
          <name>xlink_stat</name>
          <description>xlink status register &amp; io control writing to this register set the bit clock counter to zero! </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x01000000</resetValue>
          <resetMask>0x01FFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:25]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>filter_en</name>
              <bitRange>[24:24]</bitRange>
              <description>enable 3 majority ruling filter </description>
            </field>
            <field>
              <name>set_wakeup</name>
              <bitRange>[23:23]</bitRange>
              <description>set the wakeup port </description>
            </field>
            <field>
              <name>set_txoe</name>
              <bitRange>[22:22]</bitRange>
              <description>set the tx output enable </description>
            </field>
            <field>
              <name>set_tx</name>
              <bitRange>[21:21]</bitRange>
              <description>set the tx port, </description>
            </field>
            <field>
              <name>io_mode</name>
              <bitRange>[20:20]</bitRange>
              <description>enable the io mode on tx and wakeup 0 : disable io function on tx, txoe, wakeup 1 : enable io function on tx, txoe, wakeup </description>
            </field>
            <field>
              <name>txoe_ro</name>
              <bitRange>[19:19]</bitRange>
              <description>status of tx output enable </description>
            </field>
            <field>
              <name>rxo_ro</name>
              <bitRange>[18:18]</bitRange>
              <description>status of rx input </description>
            </field>
            <field>
              <name>txo_ro</name>
              <bitRange>[17:17]</bitRange>
              <description>status of tx output </description>
            </field>
            <field>
              <name>bit_clk_ro</name>
              <bitRange>[16:16]</bitRange>
              <description>status of bit clock signal </description>
            </field>
            <field>
              <name>bit_cnt_ro</name>
              <bitRange>[15:0]</bitRange>
              <description>status of bit clock counter </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>xlink6</name>
      <description>xlink6</description>
      <baseAddress>0xFF900460</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>16</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <!--Absolute address of 'xlink_cfg': 0xFF900460-->
          <name>xlink_cfg</name>
          <description>configuration register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xB4A0001B</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>end_spl</name>
              <bitRange>[31:28]</bitRange>
              <description>end sample point  for receive data </description>
            </field>
            <field>
              <name>start_spl</name>
              <bitRange>[27:24]</bitRange>
              <description>start sample point for receive data a sample period is defined as 1/16 of the bitrate period range: 0x0 - 0xf note: settings for start_spl and end_spl should always fulfill the condition: (start_spl &lt; end_spl) </description>
            </field>
            <field>
              <name>bits2rec</name>
              <bitRange>[23:20]</bitRange>
              <description>count of bits to receive note: the reset value expect: 1stopbit, 8databits, 1paritybit and 1stopbit </description>
            </field>
            <field>
              <name>cnt_da</name>
              <bitRange>[19:19]</bitRange>
              <description>test feature, do not set this bit! </description>
            </field>
            <field>
              <name>bclk2oe_en</name>
              <bitRange>[18:18]</bitRange>
              <description>test feature, do not set this bit! </description>
            </field>
            <field>
              <name>fb_en</name>
              <bitRange>[17:17]</bitRange>
              <description>test feature, enable internal feedback </description>
            </field>
            <field>
              <name>xlink_en</name>
              <bitRange>[16:16]</bitRange>
              <description>disable the output enable, and activity </description>
            </field>
            <field>
              <name>rate_inc</name>
              <bitRange>[15:0]</bitRange>
              <description>bitrate compare value for bit clock counter (bit_cnt) BITRATE = 100e6/(rate_inc) typical settings for IOLINK: {| cols=4 BIT_RATE | rate_inc | clock period | calc: 1/BIT_RATE 4800     | 0x5160   | 208,33 us    | 208,3333us 38400    | 0xa2b    |  26,04 us    |  26,04167us 230400   | 0x1b1    |   4,34 us    |   4,340278us ...      |          | invalid: 0   | 0        | 0            | 0 } </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xlink_tx': 0xFF900464-->
          <name>xlink_tx</name>
          <description>xlink transmit register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00030000</resetValue>
          <resetMask>0x0003FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:18]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>idle_ro</name>
              <bitRange>[17:17]</bitRange>
              <description>indicates no activity on tx </description>
            </field>
            <field>
              <name>rdy_ro</name>
              <bitRange>[16:16]</bitRange>
              <description>TX buffer ready (valid on ready) 0 TX buffer not ready 1 TX buffer ready </description>
            </field>
            <field>
              <name>hold</name>
              <bitRange>[15:0]</bitRange>
              <description>hold register format for a valid serial DATA sequence: &lt;-ctrl.DATA-&gt;&lt;------------------- serial DATA --------------------&gt; { END_BIT:1 }[{STOPBIT:1}{DATABITS max. 12:0101..0010}{STARTBIT:0}] notes: ENDBIT is a hardware marker to stop the shifting, and will not be transmitted. this condition implied, than all other not used bits should be zero </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xlink_rx': 0xFF900468-->
          <name>xlink_rx</name>
          <description>xlink RX register writing to the register, reset the ready bit, the overflow bit and the sampling error bit </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000FFFF</resetValue>
          <resetMask>0x0039FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:22]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>spl_err_ro</name>
              <bitRange>[21:21]</bitRange>
              <description>sampling error detected if the amount of sampled bits (HI or LOW) do not fulfill the condition: (end_spl - start_spl) &lt; (count of HI/LOW bits) </description>
            </field>
            <field>
              <name>ovf_err_ro</name>
              <bitRange>[20:20]</bitRange>
              <description>overflow error on received data </description>
            </field>
            <field>
              <name>rxd_ro</name>
              <bitRange>[19:19]</bitRange>
              <description>current status of rx data </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[18:17]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>rdy_ro</name>
              <bitRange>[16:16]</bitRange>
              <description>RX buffer ready (valid on ready) 0 RX buffer not ready 1 RX buffer ready </description>
            </field>
            <field>
              <name>hold_ro</name>
              <bitRange>[15:0]</bitRange>
              <description>RX byte (when valid) hold[15:0] is used to shift in RX(LSB first!) the amount of shifted bits is defined by bits2rec shift order is bit15 downto bit0 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xlink_stat': 0xFF90046C-->
          <name>xlink_stat</name>
          <description>xlink status register &amp; io control writing to this register set the bit clock counter to zero! </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x01000000</resetValue>
          <resetMask>0x01FFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:25]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>filter_en</name>
              <bitRange>[24:24]</bitRange>
              <description>enable 3 majority ruling filter </description>
            </field>
            <field>
              <name>set_wakeup</name>
              <bitRange>[23:23]</bitRange>
              <description>set the wakeup port </description>
            </field>
            <field>
              <name>set_txoe</name>
              <bitRange>[22:22]</bitRange>
              <description>set the tx output enable </description>
            </field>
            <field>
              <name>set_tx</name>
              <bitRange>[21:21]</bitRange>
              <description>set the tx port, </description>
            </field>
            <field>
              <name>io_mode</name>
              <bitRange>[20:20]</bitRange>
              <description>enable the io mode on tx and wakeup 0 : disable io function on tx, txoe, wakeup 1 : enable io function on tx, txoe, wakeup </description>
            </field>
            <field>
              <name>txoe_ro</name>
              <bitRange>[19:19]</bitRange>
              <description>status of tx output enable </description>
            </field>
            <field>
              <name>rxo_ro</name>
              <bitRange>[18:18]</bitRange>
              <description>status of rx input </description>
            </field>
            <field>
              <name>txo_ro</name>
              <bitRange>[17:17]</bitRange>
              <description>status of tx output </description>
            </field>
            <field>
              <name>bit_clk_ro</name>
              <bitRange>[16:16]</bitRange>
              <description>status of bit clock signal </description>
            </field>
            <field>
              <name>bit_cnt_ro</name>
              <bitRange>[15:0]</bitRange>
              <description>status of bit clock counter </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>xlink7</name>
      <description>xlink7</description>
      <baseAddress>0xFF900470</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>16</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <!--Absolute address of 'xlink_cfg': 0xFF900470-->
          <name>xlink_cfg</name>
          <description>configuration register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xB4A0001B</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>end_spl</name>
              <bitRange>[31:28]</bitRange>
              <description>end sample point  for receive data </description>
            </field>
            <field>
              <name>start_spl</name>
              <bitRange>[27:24]</bitRange>
              <description>start sample point for receive data a sample period is defined as 1/16 of the bitrate period range: 0x0 - 0xf note: settings for start_spl and end_spl should always fulfill the condition: (start_spl &lt; end_spl) </description>
            </field>
            <field>
              <name>bits2rec</name>
              <bitRange>[23:20]</bitRange>
              <description>count of bits to receive note: the reset value expect: 1stopbit, 8databits, 1paritybit and 1stopbit </description>
            </field>
            <field>
              <name>cnt_da</name>
              <bitRange>[19:19]</bitRange>
              <description>test feature, do not set this bit! </description>
            </field>
            <field>
              <name>bclk2oe_en</name>
              <bitRange>[18:18]</bitRange>
              <description>test feature, do not set this bit! </description>
            </field>
            <field>
              <name>fb_en</name>
              <bitRange>[17:17]</bitRange>
              <description>test feature, enable internal feedback </description>
            </field>
            <field>
              <name>xlink_en</name>
              <bitRange>[16:16]</bitRange>
              <description>disable the output enable, and activity </description>
            </field>
            <field>
              <name>rate_inc</name>
              <bitRange>[15:0]</bitRange>
              <description>bitrate compare value for bit clock counter (bit_cnt) BITRATE = 100e6/(rate_inc) typical settings for IOLINK: {| cols=4 BIT_RATE | rate_inc | clock period | calc: 1/BIT_RATE 4800     | 0x5160   | 208,33 us    | 208,3333us 38400    | 0xa2b    |  26,04 us    |  26,04167us 230400   | 0x1b1    |   4,34 us    |   4,340278us ...      |          | invalid: 0   | 0        | 0            | 0 } </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xlink_tx': 0xFF900474-->
          <name>xlink_tx</name>
          <description>xlink transmit register </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00030000</resetValue>
          <resetMask>0x0003FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:18]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>idle_ro</name>
              <bitRange>[17:17]</bitRange>
              <description>indicates no activity on tx </description>
            </field>
            <field>
              <name>rdy_ro</name>
              <bitRange>[16:16]</bitRange>
              <description>TX buffer ready (valid on ready) 0 TX buffer not ready 1 TX buffer ready </description>
            </field>
            <field>
              <name>hold</name>
              <bitRange>[15:0]</bitRange>
              <description>hold register format for a valid serial DATA sequence: &lt;-ctrl.DATA-&gt;&lt;------------------- serial DATA --------------------&gt; { END_BIT:1 }[{STOPBIT:1}{DATABITS max. 12:0101..0010}{STARTBIT:0}] notes: ENDBIT is a hardware marker to stop the shifting, and will not be transmitted. this condition implied, than all other not used bits should be zero </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xlink_rx': 0xFF900478-->
          <name>xlink_rx</name>
          <description>xlink RX register writing to the register, reset the ready bit, the overflow bit and the sampling error bit </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000FFFF</resetValue>
          <resetMask>0x0039FFFF</resetMask>
          <fields>
            <field>
              <name>bf_align1</name>
              <bitRange>[31:22]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>spl_err_ro</name>
              <bitRange>[21:21]</bitRange>
              <description>sampling error detected if the amount of sampled bits (HI or LOW) do not fulfill the condition: (end_spl - start_spl) &lt; (count of HI/LOW bits) </description>
            </field>
            <field>
              <name>ovf_err_ro</name>
              <bitRange>[20:20]</bitRange>
              <description>overflow error on received data </description>
            </field>
            <field>
              <name>rxd_ro</name>
              <bitRange>[19:19]</bitRange>
              <description>current status of rx data </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[18:17]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>rdy_ro</name>
              <bitRange>[16:16]</bitRange>
              <description>RX buffer ready (valid on ready) 0 RX buffer not ready 1 RX buffer ready </description>
            </field>
            <field>
              <name>hold_ro</name>
              <bitRange>[15:0]</bitRange>
              <description>RX byte (when valid) hold[15:0] is used to shift in RX(LSB first!) the amount of shifted bits is defined by bits2rec shift order is bit15 downto bit0 </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'xlink_stat': 0xFF90047C-->
          <name>xlink_stat</name>
          <description>xlink status register &amp; io control writing to this register set the bit clock counter to zero! </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x01000000</resetValue>
          <resetMask>0x01FFFFFF</resetMask>
          <fields>
            <field>
              <name>bf_align0</name>
              <bitRange>[31:25]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>filter_en</name>
              <bitRange>[24:24]</bitRange>
              <description>enable 3 majority ruling filter </description>
            </field>
            <field>
              <name>set_wakeup</name>
              <bitRange>[23:23]</bitRange>
              <description>set the wakeup port </description>
            </field>
            <field>
              <name>set_txoe</name>
              <bitRange>[22:22]</bitRange>
              <description>set the tx output enable </description>
            </field>
            <field>
              <name>set_tx</name>
              <bitRange>[21:21]</bitRange>
              <description>set the tx port, </description>
            </field>
            <field>
              <name>io_mode</name>
              <bitRange>[20:20]</bitRange>
              <description>enable the io mode on tx and wakeup 0 : disable io function on tx, txoe, wakeup 1 : enable io function on tx, txoe, wakeup </description>
            </field>
            <field>
              <name>txoe_ro</name>
              <bitRange>[19:19]</bitRange>
              <description>status of tx output enable </description>
            </field>
            <field>
              <name>rxo_ro</name>
              <bitRange>[18:18]</bitRange>
              <description>status of rx input </description>
            </field>
            <field>
              <name>txo_ro</name>
              <bitRange>[17:17]</bitRange>
              <description>status of tx output </description>
            </field>
            <field>
              <name>bit_clk_ro</name>
              <bitRange>[16:16]</bitRange>
              <description>status of bit clock signal </description>
            </field>
            <field>
              <name>bit_cnt_ro</name>
              <bitRange>[15:0]</bitRange>
              <description>status of bit clock counter </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>io_link_irq</name>
      <description>io_link_irq</description>
      <baseAddress>0xFF900480</baseAddress>
      <addressBlock>
        <offset></offset>
        <size>32</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>io_link_irq_xpic_app</name>
        <value>15</value>
      </interrupt>
      <registers>
        <register>
          <!--Absolute address of 'io_link_irq_raw': 0xFF900480-->
          <name>io_link_irq_raw</name>
          <description>IO-Link raw interrupts: Read access shows status of unmasked IRQs.   IRQs are set automatically and reset by writing to this register: Write access with '1' resets the appropriate IRQ. Write access with '0' does not influence this bit. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x77777777</resetMask>
          <fields>
            <field>
              <name>bf_align7</name>
              <bitRange>[31:31]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>xlink7_shift_en</name>
              <bitRange>[30:30]</bitRange>
              <description>shift_en interrupt </description>
            </field>
            <field>
              <name>xlink7_rx_next</name>
              <bitRange>[29:29]</bitRange>
              <description>rx_next interrupt </description>
            </field>
            <field>
              <name>xlink7_tx_next</name>
              <bitRange>[28:28]</bitRange>
              <description>tx_next interrupt </description>
            </field>
            <field>
              <name>bf_align6</name>
              <bitRange>[27:27]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>xlink6_shift_en</name>
              <bitRange>[26:26]</bitRange>
              <description>shift_en interrupt </description>
            </field>
            <field>
              <name>xlink6_rx_next</name>
              <bitRange>[25:25]</bitRange>
              <description>rx_next interrupt </description>
            </field>
            <field>
              <name>xlink6_tx_next</name>
              <bitRange>[24:24]</bitRange>
              <description>tx_next interrupt </description>
            </field>
            <field>
              <name>bf_align5</name>
              <bitRange>[23:23]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>xlink5_shift_en</name>
              <bitRange>[22:22]</bitRange>
              <description>shift_en interrupt </description>
            </field>
            <field>
              <name>xlink5_rx_next</name>
              <bitRange>[21:21]</bitRange>
              <description>rx_next interrupt </description>
            </field>
            <field>
              <name>xlink5_tx_next</name>
              <bitRange>[20:20]</bitRange>
              <description>tx_next interrupt </description>
            </field>
            <field>
              <name>bf_align4</name>
              <bitRange>[19:19]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>xlink4_shift_en</name>
              <bitRange>[18:18]</bitRange>
              <description>shift_en interrupt </description>
            </field>
            <field>
              <name>xlink4_rx_next</name>
              <bitRange>[17:17]</bitRange>
              <description>rx_next interrupt </description>
            </field>
            <field>
              <name>xlink4_tx_next</name>
              <bitRange>[16:16]</bitRange>
              <description>tx_next interrupt </description>
            </field>
            <field>
              <name>bf_align3</name>
              <bitRange>[15:15]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>xlink3_shift_en</name>
              <bitRange>[14:14]</bitRange>
              <description>shift_en interrupt </description>
            </field>
            <field>
              <name>xlink3_rx_next</name>
              <bitRange>[13:13]</bitRange>
              <description>rx_next interrupt </description>
            </field>
            <field>
              <name>xlink3_tx_next</name>
              <bitRange>[12:12]</bitRange>
              <description>tx_next interrupt </description>
            </field>
            <field>
              <name>bf_align2</name>
              <bitRange>[11:11]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>xlink2_shift_en</name>
              <bitRange>[10:10]</bitRange>
              <description>shift_en interrupt </description>
            </field>
            <field>
              <name>xlink2_rx_next</name>
              <bitRange>[9:9]</bitRange>
              <description>rx_next interrupt </description>
            </field>
            <field>
              <name>xlink2_tx_next</name>
              <bitRange>[8:8]</bitRange>
              <description>tx_next interrupt </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[7:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>xlink1_shift_en</name>
              <bitRange>[6:6]</bitRange>
              <description>shift_en interrupt </description>
            </field>
            <field>
              <name>xlink1_rx_next</name>
              <bitRange>[5:5]</bitRange>
              <description>rx_next interrupt </description>
            </field>
            <field>
              <name>xlink1_tx_next</name>
              <bitRange>[4:4]</bitRange>
              <description>tx_next interrupt </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:3]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>xlink0_shift_en</name>
              <bitRange>[2:2]</bitRange>
              <description>shift_en interrupt </description>
            </field>
            <field>
              <name>xlink0_rx_next</name>
              <bitRange>[1:1]</bitRange>
              <description>rx_next interrupt </description>
            </field>
            <field>
              <name>xlink0_tx_next</name>
              <bitRange>[0:0]</bitRange>
              <description>tx_next interrupt </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'io_link_irq_masked': 0xFF900484-->
          <name>io_link_irq_masked</name>
          <description>IO-Link Masked IRQ register Shows status of masked IRQs (as connected to ARM/xPIC) </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x77777777</resetMask>
          <fields>
            <field>
              <name>bf_align7</name>
              <bitRange>[31:31]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>xlink7_shift_en</name>
              <bitRange>[30:30]</bitRange>
              <description>shift_en interrupt </description>
            </field>
            <field>
              <name>xlink7_rx_next</name>
              <bitRange>[29:29]</bitRange>
              <description>rx_next interrupt </description>
            </field>
            <field>
              <name>xlink7_tx_next</name>
              <bitRange>[28:28]</bitRange>
              <description>tx_next interrupt </description>
            </field>
            <field>
              <name>bf_align6</name>
              <bitRange>[27:27]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>xlink6_shift_en</name>
              <bitRange>[26:26]</bitRange>
              <description>shift_en interrupt </description>
            </field>
            <field>
              <name>xlink6_rx_next</name>
              <bitRange>[25:25]</bitRange>
              <description>rx_next interrupt </description>
            </field>
            <field>
              <name>xlink6_tx_next</name>
              <bitRange>[24:24]</bitRange>
              <description>tx_next interrupt </description>
            </field>
            <field>
              <name>bf_align5</name>
              <bitRange>[23:23]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>xlink5_shift_en</name>
              <bitRange>[22:22]</bitRange>
              <description>shift_en interrupt </description>
            </field>
            <field>
              <name>xlink5_rx_next</name>
              <bitRange>[21:21]</bitRange>
              <description>rx_next interrupt </description>
            </field>
            <field>
              <name>xlink5_tx_next</name>
              <bitRange>[20:20]</bitRange>
              <description>tx_next interrupt </description>
            </field>
            <field>
              <name>bf_align4</name>
              <bitRange>[19:19]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>xlink4_shift_en</name>
              <bitRange>[18:18]</bitRange>
              <description>shift_en interrupt </description>
            </field>
            <field>
              <name>xlink4_rx_next</name>
              <bitRange>[17:17]</bitRange>
              <description>rx_next interrupt </description>
            </field>
            <field>
              <name>xlink4_tx_next</name>
              <bitRange>[16:16]</bitRange>
              <description>tx_next interrupt </description>
            </field>
            <field>
              <name>bf_align3</name>
              <bitRange>[15:15]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>xlink3_shift_en</name>
              <bitRange>[14:14]</bitRange>
              <description>shift_en interrupt </description>
            </field>
            <field>
              <name>xlink3_rx_next</name>
              <bitRange>[13:13]</bitRange>
              <description>rx_next interrupt </description>
            </field>
            <field>
              <name>xlink3_tx_next</name>
              <bitRange>[12:12]</bitRange>
              <description>tx_next interrupt </description>
            </field>
            <field>
              <name>bf_align2</name>
              <bitRange>[11:11]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>xlink2_shift_en</name>
              <bitRange>[10:10]</bitRange>
              <description>shift_en interrupt </description>
            </field>
            <field>
              <name>xlink2_rx_next</name>
              <bitRange>[9:9]</bitRange>
              <description>rx_next interrupt </description>
            </field>
            <field>
              <name>xlink2_tx_next</name>
              <bitRange>[8:8]</bitRange>
              <description>tx_next interrupt </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[7:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>xlink1_shift_en</name>
              <bitRange>[6:6]</bitRange>
              <description>shift_en interrupt </description>
            </field>
            <field>
              <name>xlink1_rx_next</name>
              <bitRange>[5:5]</bitRange>
              <description>rx_next interrupt </description>
            </field>
            <field>
              <name>xlink1_tx_next</name>
              <bitRange>[4:4]</bitRange>
              <description>tx_next interrupt </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:3]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>xlink0_shift_en</name>
              <bitRange>[2:2]</bitRange>
              <description>shift_en interrupt </description>
            </field>
            <field>
              <name>xlink0_rx_next</name>
              <bitRange>[1:1]</bitRange>
              <description>rx_next interrupt </description>
            </field>
            <field>
              <name>xlink0_tx_next</name>
              <bitRange>[0:0]</bitRange>
              <description>tx_next interrupt </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'io_link_irq_msk_set': 0xFF900488-->
          <name>io_link_irq_msk_set</name>
          <description>IO-Link interrupt mask enable: The IRQ mask enables interrupt requests for corresponding interrupt sources.   As its bits might be changed by different software tasks,   the IRQ mask register is not writable directly, but by set and reset masks: Write access with '1' sets interrupt mask bit (enables interrupt request for corresponding interrupt source). Write access with '0' does not influence this bit. Read access shows actual interrupt mask. Attention: Before activating interrupt mask, delete old pending interrupts by writing the same value to io_link_irq_raw. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x77777777</resetMask>
          <fields>
            <field>
              <name>bf_align7</name>
              <bitRange>[31:31]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>xlink7_shift_en</name>
              <bitRange>[30:30]</bitRange>
              <description>shift_en interrupt </description>
            </field>
            <field>
              <name>xlink7_rx_next</name>
              <bitRange>[29:29]</bitRange>
              <description>rx_next interrupt </description>
            </field>
            <field>
              <name>xlink7_tx_next</name>
              <bitRange>[28:28]</bitRange>
              <description>tx_next interrupt </description>
            </field>
            <field>
              <name>bf_align6</name>
              <bitRange>[27:27]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>xlink6_shift_en</name>
              <bitRange>[26:26]</bitRange>
              <description>shift_en interrupt </description>
            </field>
            <field>
              <name>xlink6_rx_next</name>
              <bitRange>[25:25]</bitRange>
              <description>rx_next interrupt </description>
            </field>
            <field>
              <name>xlink6_tx_next</name>
              <bitRange>[24:24]</bitRange>
              <description>tx_next interrupt </description>
            </field>
            <field>
              <name>bf_align5</name>
              <bitRange>[23:23]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>xlink5_shift_en</name>
              <bitRange>[22:22]</bitRange>
              <description>shift_en interrupt </description>
            </field>
            <field>
              <name>xlink5_rx_next</name>
              <bitRange>[21:21]</bitRange>
              <description>rx_next interrupt </description>
            </field>
            <field>
              <name>xlink5_tx_next</name>
              <bitRange>[20:20]</bitRange>
              <description>tx_next interrupt </description>
            </field>
            <field>
              <name>bf_align4</name>
              <bitRange>[19:19]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>xlink4_shift_en</name>
              <bitRange>[18:18]</bitRange>
              <description>shift_en interrupt </description>
            </field>
            <field>
              <name>xlink4_rx_next</name>
              <bitRange>[17:17]</bitRange>
              <description>rx_next interrupt </description>
            </field>
            <field>
              <name>xlink4_tx_next</name>
              <bitRange>[16:16]</bitRange>
              <description>tx_next interrupt </description>
            </field>
            <field>
              <name>bf_align3</name>
              <bitRange>[15:15]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>xlink3_shift_en</name>
              <bitRange>[14:14]</bitRange>
              <description>shift_en interrupt </description>
            </field>
            <field>
              <name>xlink3_rx_next</name>
              <bitRange>[13:13]</bitRange>
              <description>rx_next interrupt </description>
            </field>
            <field>
              <name>xlink3_tx_next</name>
              <bitRange>[12:12]</bitRange>
              <description>tx_next interrupt </description>
            </field>
            <field>
              <name>bf_align2</name>
              <bitRange>[11:11]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>xlink2_shift_en</name>
              <bitRange>[10:10]</bitRange>
              <description>shift_en interrupt </description>
            </field>
            <field>
              <name>xlink2_rx_next</name>
              <bitRange>[9:9]</bitRange>
              <description>rx_next interrupt </description>
            </field>
            <field>
              <name>xlink2_tx_next</name>
              <bitRange>[8:8]</bitRange>
              <description>tx_next interrupt </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[7:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>xlink1_shift_en</name>
              <bitRange>[6:6]</bitRange>
              <description>shift_en interrupt </description>
            </field>
            <field>
              <name>xlink1_rx_next</name>
              <bitRange>[5:5]</bitRange>
              <description>rx_next interrupt </description>
            </field>
            <field>
              <name>xlink1_tx_next</name>
              <bitRange>[4:4]</bitRange>
              <description>tx_next interrupt </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:3]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>xlink0_shift_en</name>
              <bitRange>[2:2]</bitRange>
              <description>shift_en interrupt </description>
            </field>
            <field>
              <name>xlink0_rx_next</name>
              <bitRange>[1:1]</bitRange>
              <description>rx_next interrupt </description>
            </field>
            <field>
              <name>xlink0_tx_next</name>
              <bitRange>[0:0]</bitRange>
              <description>tx_next interrupt </description>
            </field>
          </fields>
        </register>
        <register>
          <!--Absolute address of 'io_link_irq_msk_reset': 0xFF90048C-->
          <name>io_link_irq_msk_reset</name>
          <description>IO-Link interrupt mask disable: This is the corresponding reset mask to disable interrupt requests for corresponding interrupt sources: Write access with '1' resets interrupt mask bit (disables interrupt request for corresponding interrupt source). Write access with '0' does not influence this bit. Read access shows actual interrupt mask. </description>
          <dataType>uint32_t</dataType>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x77777777</resetMask>
          <fields>
            <field>
              <name>bf_align7</name>
              <bitRange>[31:31]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>xlink7_shift_en</name>
              <bitRange>[30:30]</bitRange>
              <description>shift_en interrupt </description>
            </field>
            <field>
              <name>xlink7_rx_next</name>
              <bitRange>[29:29]</bitRange>
              <description>rx_next interrupt </description>
            </field>
            <field>
              <name>xlink7_tx_next</name>
              <bitRange>[28:28]</bitRange>
              <description>tx_next interrupt </description>
            </field>
            <field>
              <name>bf_align6</name>
              <bitRange>[27:27]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>xlink6_shift_en</name>
              <bitRange>[26:26]</bitRange>
              <description>shift_en interrupt </description>
            </field>
            <field>
              <name>xlink6_rx_next</name>
              <bitRange>[25:25]</bitRange>
              <description>rx_next interrupt </description>
            </field>
            <field>
              <name>xlink6_tx_next</name>
              <bitRange>[24:24]</bitRange>
              <description>tx_next interrupt </description>
            </field>
            <field>
              <name>bf_align5</name>
              <bitRange>[23:23]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>xlink5_shift_en</name>
              <bitRange>[22:22]</bitRange>
              <description>shift_en interrupt </description>
            </field>
            <field>
              <name>xlink5_rx_next</name>
              <bitRange>[21:21]</bitRange>
              <description>rx_next interrupt </description>
            </field>
            <field>
              <name>xlink5_tx_next</name>
              <bitRange>[20:20]</bitRange>
              <description>tx_next interrupt </description>
            </field>
            <field>
              <name>bf_align4</name>
              <bitRange>[19:19]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>xlink4_shift_en</name>
              <bitRange>[18:18]</bitRange>
              <description>shift_en interrupt </description>
            </field>
            <field>
              <name>xlink4_rx_next</name>
              <bitRange>[17:17]</bitRange>
              <description>rx_next interrupt </description>
            </field>
            <field>
              <name>xlink4_tx_next</name>
              <bitRange>[16:16]</bitRange>
              <description>tx_next interrupt </description>
            </field>
            <field>
              <name>bf_align3</name>
              <bitRange>[15:15]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>xlink3_shift_en</name>
              <bitRange>[14:14]</bitRange>
              <description>shift_en interrupt </description>
            </field>
            <field>
              <name>xlink3_rx_next</name>
              <bitRange>[13:13]</bitRange>
              <description>rx_next interrupt </description>
            </field>
            <field>
              <name>xlink3_tx_next</name>
              <bitRange>[12:12]</bitRange>
              <description>tx_next interrupt </description>
            </field>
            <field>
              <name>bf_align2</name>
              <bitRange>[11:11]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>xlink2_shift_en</name>
              <bitRange>[10:10]</bitRange>
              <description>shift_en interrupt </description>
            </field>
            <field>
              <name>xlink2_rx_next</name>
              <bitRange>[9:9]</bitRange>
              <description>rx_next interrupt </description>
            </field>
            <field>
              <name>xlink2_tx_next</name>
              <bitRange>[8:8]</bitRange>
              <description>tx_next interrupt </description>
            </field>
            <field>
              <name>bf_align1</name>
              <bitRange>[7:7]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>xlink1_shift_en</name>
              <bitRange>[6:6]</bitRange>
              <description>shift_en interrupt </description>
            </field>
            <field>
              <name>xlink1_rx_next</name>
              <bitRange>[5:5]</bitRange>
              <description>rx_next interrupt </description>
            </field>
            <field>
              <name>xlink1_tx_next</name>
              <bitRange>[4:4]</bitRange>
              <description>tx_next interrupt </description>
            </field>
            <field>
              <name>bf_align0</name>
              <bitRange>[3:3]</bitRange>
              <description>bitField alignment value for aeabi compatibility</description>
            </field>
            <field>
              <name>xlink0_shift_en</name>
              <bitRange>[2:2]</bitRange>
              <description>shift_en interrupt </description>
            </field>
            <field>
              <name>xlink0_rx_next</name>
              <bitRange>[1:1]</bitRange>
              <description>rx_next interrupt </description>
            </field>
            <field>
              <name>xlink0_tx_next</name>
              <bitRange>[0:0]</bitRange>
              <description>tx_next interrupt </description>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
  </peripherals>
</device>
